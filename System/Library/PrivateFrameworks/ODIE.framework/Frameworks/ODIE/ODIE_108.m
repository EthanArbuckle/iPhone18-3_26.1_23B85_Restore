char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::CallOp,mlir::ValueTypeRange<mlir::ResultRange>,mlir::TypedAttr &,mlir::ResultRange>(uint64_t **a1, uint64_t a2, __int128 *a3, uint64_t *a4, void *a5)
{
  v28 = *MEMORY[0x277D85DE8];
  v10 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::CallOp,void>::id, *(**a2 + 32));
  if ((v11 & 1) == 0)
  {
    v19 = 1283;
    *&v18 = "coreml.llo.call";
    *(&v18 + 1) = 15;
    v27 = 259;
    llvm::operator+(&v17, v26, v20);
    llvm::report_fatal_error(v20, 1);
  }

  v20[0] = a2;
  v20[1] = v10;
  v20[2] = v21;
  v20[3] = 0x400000000;
  v21[4] = v22;
  v21[5] = 0x400000000;
  v22[4] = v23;
  v22[5] = 0x400000000;
  v23[8] = 4;
  v23[9] = v24;
  v23[10] = 0x100000000;
  v24[1] = v25;
  v24[2] = 0x100000000;
  v25[1] = 0;
  v25[2] = 0;
  v25[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v25[4] = 0;
  v25[6] = 0;
  v12 = a3[1];
  v17 = *a3;
  v18 = v12;
  mlir::TypeRange::TypeRange<mlir::ResultRange>(v26, &v17);
  mlir::ODIE::Compiler::CoreML::CallOp::build(a1, v20, v26[0], v26[1], *a4, a4[1], *a5 & 0xFFFFFFFFFFFFFFF9 | 4, a5[1], 0, 0, 0);
  v13 = mlir::Operation::create(v20);
  mlir::OpBuilder::insert(a1, v13);
  if (*(*(v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::CallOp,void>::id)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  mlir::OperationState::~OperationState(v20);
  v15 = *MEMORY[0x277D85DE8];
  return v14;
}

void *llvm::DenseMap<mlir::Attribute,mlir::Operation *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::Operation *>>::copyFrom(uint64_t a1, uint64_t a2)
{
  result = MEMORY[0x25F891030](*a1, 8);
  v5 = *(a2 + 16);
  *(a1 + 16) = v5;
  if (v5)
  {
    buffer = llvm::allocate_buffer((16 * v5), 8uLL);
    *a1 = buffer;
    *(a1 + 8) = *(a2 + 8);
    v7 = *a2;
    v8 = 16 * *(a1 + 16);

    return memcpy(buffer, v7, v8);
  }

  else
  {
    *a1 = 0;
    *(a1 + 8) = 0;
  }

  return result;
}

uint64_t llvm::cl::opt<mlir::ODIE::Compiler::Action,false,mlir::detail::PassOptions::GenericOptionParser<mlir::ODIE::Compiler::Action>>::operator=<mlir::ODIE::Compiler::Action>(uint64_t a1, _DWORD *a2)
{
  *(a1 + 120) = *a2;
  v2 = a1 + 120;
  v3 = *(a1 + 584);
  if (v3)
  {
    (*(*v3 + 48))(v3);
    return v2;
  }

  else
  {
    v5 = std::__throw_bad_function_call[abi:nn200100]();
    return mlir::ODIE::Compiler::Transforms::impl::createOutlineCompositeOps(v5);
  }
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::OutlineCompositeOpsPass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OutlineCompositeOpsPass::~OutlineCompositeOpsPass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OutlineCompositeOpsPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::OutlineCompositeOpsBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::OutlineCompositeOpsPass>::getDependentDialects(uint64_t a1, uint64_t a2)
{
  mlir::DialectRegistry::insert<mlir::ODIE::Compiler::CoreML::CoreMLDialect>(a2);

  return mlir::DialectRegistry::insert<mlir::ODIE::Compiler::TorchImport::TorchImportDialect>(a2);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OutlineCompositeOpsPass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OutlineCompositeOpsPass *this)
{
  v134[8] = *MEMORY[0x277D85DE8];
  v2 = (*(this + 5) & 0xFFFFFFFFFFFFFFF8);
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v93 = 0;
  v126.__r_.__value_.__r.__words[0] = &v93;
  v126.__r_.__value_.__l.__size_ = &v94;
  if (v93 == 1)
  {
    *(this + 5) |= 4uLL;
    goto LABEL_139;
  }

  v91[0] = 0;
  v91[1] = 0;
  v92 = 0;
  SymbolTable = mlir::SymbolTableCollection::getSymbolTable(v91, v2);
  v4 = *SymbolTable;
  v89 = 0;
  v88[0] = 0;
  v88[1] = 0;
  llvm::DenseMap<mlir::Attribute,mlir::Operation *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::Operation *>>::copyFrom(v88, SymbolTable + 8);
  v90 = *(SymbolTable + 32);
  if (v95)
  {
    if (v96)
    {
      v5 = 304 * v96;
      v6 = v94;
      while (*v6 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v6 += 304;
        v5 -= 304;
        if (!v5)
        {
          goto LABEL_138;
        }
      }
    }

    else
    {
      v6 = v94;
    }

    v7 = v94 + 304 * v96;
    if (v6 != v7)
    {
      v86 = v2;
LABEL_12:
      v8 = *v6;
      __n = *(v6 + 8);
      v10 = *(v2 + 2);
      v9 = *(v2 + 3);
      v107[0] = *(**v9 + 32);
      v107[1] = 0;
      v108 = v10;
      v109 = v2;
      v11 = *(**v9 + 32);
      v104 = 0;
      v105 = 0;
      v106 = 0;
      v120 = v122;
      v121 = 0x600000000;
      v103 = 0u;
      memset(v102, 0, sizeof(v102));
      v12 = *(v6 + 248);
      if (v12)
      {
        __s2 = v8;
        v13 = *(v6 + 240);
        v14 = 8 * v12;
        do
        {
          v15 = *v13++;
          v126.__r_.__value_.__r.__words[0] = v15;
          std::deque<mlir::Operation *>::push_back(v102, &v126);
          v14 -= 8;
        }

        while (v14);
        v16 = *(&v103 + 1);
        v97 = v101;
        v98 = 4;
        v99 = 0;
        v100 = 1;
        if (*(&v103 + 1))
        {
          while (1)
          {
            v17 = *(*(v102[1] + ((v103 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v103 & 0x1FF));
            *&v103 = v103 + 1;
            *(&v103 + 1) = v16 - 1;
            if (v103 >= 0x400)
            {
              operator delete(*v102[1]);
              v102[1] += 8;
              *&v103 = v103 - 512;
            }

            if (llvm::SmallPtrSetImplBase::contains_imp(&v97, v17))
            {
              goto LABEL_58;
            }

            llvm::SmallPtrSetImpl<mlir::Operation *>::insert(&v97, v17, &v126);
            v18 = *(*(v17 + 48) + 8);
            v19 = *(v18 + 16);
            v20 = *(v18 + 24);
            if (v20 != 34)
            {
              break;
            }

            if (memcmp(v19, "TorchImport.label_tensor_as_output", 0x22uLL))
            {
              goto LABEL_28;
            }

            AttrFromOpOr = mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(v17, "id", 2uLL, 0);
            if ((v22 & 1) == 0 || *(AttrFromOpOr + 24) != __n || __n && memcmp(*(AttrFromOpOr + 16), __s2, __n))
            {
              goto LABEL_28;
            }

LABEL_29:
            if ((*(v17 + 46) & 0x80) != 0)
            {
              v23 = *(v17 + 68);
              if (v23)
              {
                v24 = 0;
                v25 = *(v17 + 72);
                do
                {
                  v26 = *(v25 + 32 * v24 + 24);
                  v111.__r_.__value_.__r.__words[0] = v26;
                  if ((~*(v26 + 8) & 7) == 0)
                  {
                    v26 = 0;
                  }

                  if (!v26)
                  {
                    v116 = 0;
LABEL_56:
                    llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::try_emplace<llvm::detail::DenseSetEmpty&>(&v104, &v111, &v126);
                    goto LABEL_57;
                  }

                  v27 = *(v26 + 8) & 7;
                  if (v27 == 6)
                  {
                    v28 = v26 + 24 * *(v26 + 16);
                    v29 = (v28 + 120);
                    v116 = (v28 + 120);
                    if (v28 == -120)
                    {
                      goto LABEL_56;
                    }
                  }

                  else
                  {
                    v29 = (v26 + 16 * v27 + 16);
                    v116 = v29;
                  }

                  v30 = *(v29[6] + 8);
                  v31 = *(v30 + 16);
                  v32 = *(v30 + 24);
                  if (v32 == 34)
                  {
                    v33 = "TorchImport.label_tensor_as_output";
                    v34 = 34;
                  }

                  else
                  {
                    if (v32 != 33)
                    {
                      goto LABEL_45;
                    }

                    v33 = "TorchImport.label_tensor_as_input";
                    v34 = 33;
                  }

                  if (!memcmp(v31, v33, v34))
                  {
                    goto LABEL_54;
                  }

LABEL_45:
                  v35 = *(v6 + 184);
                  if (!v35)
                  {
                    goto LABEL_54;
                  }

                  v36 = *(v6 + 176);
                  v37 = 8 * v35 - 8;
                  do
                  {
                    v38 = *v36++;
                    v39 = mlir::Operation::isBeforeInBlock(v38, v29);
                    v40 = !v39 || v37 == 0;
                    v37 -= 8;
                  }

                  while (!v40);
                  if (!v39)
                  {
                    goto LABEL_56;
                  }

                  v29 = v116;
                  if (v116)
                  {
LABEL_54:
                    if (!llvm::SmallPtrSetImplBase::contains_imp(&v97, v29))
                    {
                      std::deque<mlir::Operation *>::push_back(v102, &v116);
                    }
                  }

LABEL_57:
                  ++v24;
                }

                while (v24 != v23);
              }
            }

LABEL_58:
            v16 = *(&v103 + 1);
            if (!*(&v103 + 1))
            {
              goto LABEL_61;
            }
          }

          if (v20 == 33 && !memcmp(v19, "TorchImport.label_tensor_as_input", 0x21uLL))
          {
            goto LABEL_58;
          }

LABEL_28:
          llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(&v120, v17);
          goto LABEL_29;
        }
      }

      else
      {
        v97 = v101;
        v98 = 4;
        v99 = 0;
        v100 = 1;
      }

LABEL_61:
      mlir::ODIE::Compiler::Transforms::getSortedListOfIO(&v116, *(v6 + 176), *(v6 + 184));
      mlir::ODIE::Compiler::Transforms::getSortedListOfIO(&v112, *(v6 + 240), *(v6 + 248));
      v41 = v119 & v115;
      if (v119 & v115)
      {
        v42 = v116;
        v43 = v112;
        v44 = v113;
        v126.__r_.__value_.__r.__words[0] = &v126.__r_.__value_.__r.__words[2];
        v126.__r_.__value_.__l.__size_ = 0x600000000;
        v111.__r_.__value_.__r.__words[0] = &v111.__r_.__value_.__r.__words[2];
        v111.__r_.__value_.__l.__size_ = 0x600000000;
        if (v117)
        {
          v45 = 8 * v117;
          do
          {
            v46 = *v42++;
            v47 = v46 - 16;
            if (!*(v46 + 36))
            {
              v47 = 0;
            }

            llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(&v126, *(v47 + 8) & 0xFFFFFFFFFFFFFFF8);
            v45 -= 8;
          }

          while (v45);
        }

        if (v105)
        {
          if (v106)
          {
            v48 = 8 * v106;
            v49 = v104;
            while ((*v49 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              ++v49;
              v48 -= 8;
              if (!v48)
              {
                goto LABEL_82;
              }
            }
          }

          else
          {
            v49 = v104;
          }

          v50 = &v104[v106];
          if (v50 != v49)
          {
            v51 = *v49;
            do
            {
              llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(&v126, *(v51 + 8) & 0xFFFFFFFFFFFFFFF8);
              do
              {
                if (++v49 == v50)
                {
                  goto LABEL_82;
                }

                v51 = *v49;
              }

              while ((*v49 | 0x1000) == 0xFFFFFFFFFFFFF000);
            }

            while (v49 != v50);
          }
        }

LABEL_82:
        if (v44)
        {
          v52 = 8 * v44;
          do
          {
            v53 = *v43++;
            v54 = v53 - 16;
            if (!*(v53 + 36))
            {
              v54 = 0;
            }

            llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(&v111, *(v54 + 8) & 0xFFFFFFFFFFFFFFF8);
            v52 -= 8;
          }

          while (v52);
        }

        *&__p = v126.__r_.__value_.__r.__words[0] & 0xFFFFFFFFFFFFFFF9 | 2;
        *(&__p + 1) = LODWORD(v126.__r_.__value_.__r.__words[1]);
        *&v123 = v111.__r_.__value_.__r.__words[0] & 0xFFFFFFFFFFFFFFF9 | 2;
        *(&v123 + 1) = LODWORD(v111.__r_.__value_.__r.__words[1]);
        v55 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v11, &__p, &v123);
        if (v111.__r_.__value_.__l.__data_ != &v111.__r_.__value_.__r.__words[2])
        {
          free(v111.__r_.__value_.__l.__data_);
        }

        if (v126.__r_.__value_.__l.__data_ != &v126.__r_.__value_.__r.__words[2])
        {
          free(v126.__r_.__value_.__l.__data_);
        }

        if (v121)
        {
          v56 = 0;
          v57 = v120;
          v126.__r_.__value_.__r.__words[0] = &v126.__r_.__value_.__r.__words[2];
          v58 = 8 * v121;
          v126.__r_.__value_.__l.__size_ = 0x600000000;
          do
          {
            llvm::SmallVectorTemplateBase<mlir::Location,true>::push_back(&v126, *(*&v57[v56] + 24));
            v56 += 8;
          }

          while (v58 != v56);
          v59 = mlir::FusedLoc::get(v126.__r_.__value_.__l.__data_, LODWORD(v126.__r_.__value_.__r.__words[1]), 0, *(***(*v57 + 24) + 32));
          if (v126.__r_.__value_.__l.__data_ != &v126.__r_.__value_.__r.__words[2])
          {
            free(v126.__r_.__value_.__l.__data_);
          }
        }

        else
        {
          v59 = *(*v11 + 616);
        }

        v60 = *(**(v6 + 240) + 16);
        if (v60)
        {
          v60 = *(v60 + 24) & 0xFFFFFFFFFFFFFFF8;
          if (v60)
          {
            v60 = *(v60 + 16);
          }
        }

        v108 = *(v60 + 16);
        v109 = v60;
        if ((atomic_load_explicit(_MergedGlobals_64, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(_MergedGlobals_64))
        {
          std::random_device::random_device[abi:nn200100](&v126);
          v69 = arc4random();
          qword_27FC24E78 = v69;
          v70 = 2;
          v71 = 1;
          do
          {
            v72 = 0x5851F42D4C957F2DLL * (v69 ^ (v69 >> 62));
            v69 = v72 + v71;
            _MergedGlobals_64[v70] = v70 + v72 - 1;
            ++v71;
            ++v70;
          }

          while (v70 != 313);
          qword_27FC25838 = 0;
          std::random_device::~random_device(&v126);
          __cxa_guard_release(_MergedGlobals_64);
        }

        std::string::basic_string[abi:nn200100]<0>(&v126, "composite_op_");
        v61 = std::mersenne_twister_engine<unsigned long long,64ul,312ul,156ul,31ul,13043109905998158313ull,29ul,6148914691236517205ull,17ul,8202884508482404352ull,37ul,18444473444759240704ull,43ul,6364136223846793005ull>::operator()(&qword_27FC24E78);
        std::to_string(&v111, v61);
        if ((v111.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v62 = &v111;
        }

        else
        {
          v62 = v111.__r_.__value_.__r.__words[0];
        }

        if ((v111.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          size = HIBYTE(v111.__r_.__value_.__r.__words[2]);
        }

        else
        {
          size = v111.__r_.__value_.__l.__size_;
        }

        v64 = std::string::append(&v126, v62, size);
        v65 = v64->__r_.__value_.__r.__words[2];
        __p = *&v64->__r_.__value_.__l.__data_;
        v125 = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v111.__r_.__value_.__l.__data_);
        }

        if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v126.__r_.__value_.__l.__data_);
        }

        v66 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::GraphOp>(v107, *(**v59 + 32));
        v126.__r_.__value_.__r.__words[0] = v59;
        v126.__r_.__value_.__l.__size_ = v66;
        v126.__r_.__value_.__r.__words[2] = &v128;
        v127 = 0x400000000;
        v129 = v131;
        v130 = 0x400000000;
        v131[4] = v132;
        v131[5] = 0x400000000;
        v132[8] = 4;
        v132[9] = v133;
        v132[10] = 0x100000000;
        v133[1] = v134;
        v133[2] = 0x100000000;
        v134[1] = 0;
        v134[2] = 0;
        v134[3] = &mlir::detail::TypeIDResolver<void,void>::id;
        v134[4] = 0;
        if (v125 >= 0)
        {
          p_p = &__p;
        }

        else
        {
          p_p = __p;
        }

        if (v125 >= 0)
        {
          v68 = SHIBYTE(v125);
        }

        else
        {
          v68 = *(&__p + 1);
        }

        v134[6] = 0;
        mlir::ODIE::Compiler::CoreML::GraphOp::build(v107, &v126, p_p, v68, v55, 0, 0, 0, 0, 0, 0, 0);
      }

      v2 = v86;
      if ((v115 & 1) != 0 && v112 != &v114)
      {
        free(v112);
      }

      if (v119 == 1 && v116 != &v118)
      {
        free(v116);
      }

      if ((v100 & 1) == 0)
      {
        free(v97);
      }

      std::deque<mlir::Operation *>::~deque[abi:nn200100](v102);
      if (v120 != v122)
      {
        free(v120);
      }

      MEMORY[0x25F891030](v104, 8);
      if (v41)
      {
        while (1)
        {
          v6 += 304;
          if (v6 == v7)
          {
            break;
          }

          if (*v6 < 0xFFFFFFFFFFFFFFFELL)
          {
            if (v6 != v7)
            {
              goto LABEL_12;
            }

            break;
          }
        }
      }

      else
      {
        v73 = *(v86 + 3);
        v126.__r_.__value_.__r.__words[0] = "Failed to outline composite ops";
        v128 = 259;
        emitDiag(v73, 2, &v126, v110);
        mlir::InFlightDiagnostic::~InFlightDiagnostic(v110);
        *(this + 5) |= 4uLL;
      }
    }
  }

LABEL_138:
  MEMORY[0x25F891030](v88[0], 8);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v91);
  MEMORY[0x25F891030](v91[0], 8);
LABEL_139:
  v74 = v94;
  if (v96)
  {
    v75 = 0;
    v76 = 304 * v96;
    do
    {
      if (*(v74 + v75) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v77 = v74 + v75;
        v78 = *(v74 + v75 + 240);
        if ((v74 + v75 + 256) != v78)
        {
          free(v78);
        }

        v79 = *(v77 + 176);
        if ((v77 + 192) != v79)
        {
          free(v79);
        }

        v80 = v74 + v75;
        v81 = *(v74 + v75 + 112);
        if ((v74 + v75 + 128) != v81)
        {
          free(v81);
        }

        v82 = *(v80 + 48);
        if ((v80 + 64) != v82)
        {
          free(v82);
        }
      }

      v75 += 304;
    }

    while (v76 != v75);
    v74 = v94;
  }

  result = MEMORY[0x25F891030](v74, 8);
  v84 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::OutlineCompositeOpsPass::runOnOperation(void)::$_0>(uint64_t a1, uint64_t a2)
{
  v4 = *(*(a2 + 48) + 8);
  v5 = *(v4 + 16);
  v6 = *(v4 + 24);
  if (v6 == 34)
  {
    v7 = "TorchImport.label_tensor_as_output";
    v8 = *(v4 + 16);
    v9 = 34;
  }

  else
  {
    if (v6 != 33)
    {
      return 1;
    }

    v7 = "TorchImport.label_tensor_as_input";
    v8 = *(v4 + 16);
    v9 = 33;
  }

  if (memcmp(v8, v7, v9))
  {
    return 1;
  }

  AttrFromOpOr = mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(a2, "id", 2uLL, 0);
  v12 = v11;
  v13 = mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(a2, "op_name", 7uLL, 0);
  v15 = v14;
  v16 = mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(a2, "name", 4uLL, 0);
  v18 = v17;
  v19 = mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(a2, "attributes", 0xAuLL, 1);
  if ((v18 & 1) != 0 && (v12 & 1) != 0 && (v15 & 1) != 0 && (*(a2 + 46) & 0x80) != 0 && *(a2 + 68) == 2 && *(a2 + 36) == 1)
  {
    v21 = v20;
    v34 = v19;
    v36 = *(AttrFromOpOr + 16);
    v22 = *(v13 + 16);
    v23 = *(v13 + 24);
    v25 = *(v16 + 16);
    v24 = *(v16 + 24);
    *v26 = v22;
    v26[1] = v23;
    if (v6 == 33 && !memcmp(v5, "TorchImport.label_tensor_as_input", 0x21uLL))
    {
      llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v29 + 160, a2);
      llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(v30 + 32, v25, v24);
      if (v21)
      {
        v31 = *(v34 + 16);
        v32 = *(v34 + 24);
        *(v33 + 16) = v31;
        *(v33 + 24) = v32;
      }
    }

    else
    {
      llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v27 + 224, a2);
      llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(v28 + 96, v25, v24);
    }

    return 1;
  }

  result = 0;
  **a1 = 1;
  return result;
}

unint64_t mlir::ODIE::Compiler::Transforms::getAttrFromOpOr(uint64_t a1, const void *a2, size_t a3, char a4)
{
  v17[25] = *MEMORY[0x277D85DE8];
  Attr = mlir::Operation::getAttr(a1, a2, a3);
  if (Attr && *(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    v11 = Attr & 0xFFFFFFFFFFFFFF00;
    v10 = Attr;
  }

  else
  {
    if ((a4 & 1) == 0)
    {
      v9 = *(a1 + 24);
      v15 = 257;
      emitDiag(v9, 2, v14, &v16);
      if (v16)
      {
        mlir::Diagnostic::operator<<<49ul>(v17, "Couldn't find valid composite op attr with name ");
        if (v16)
        {
          v15 = 261;
          v14[0] = a2;
          v14[1] = a3;
          mlir::Diagnostic::operator<<(v17, v14);
        }
      }

      mlir::InFlightDiagnostic::~InFlightDiagnostic(&v16);
    }

    v10 = 0;
    v11 = 0;
  }

  v12 = *MEMORY[0x277D85DE8];
  return v11 | v10;
}

unint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>,llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>::operator[](uint64_t a1, _OWORD *a2)
{
  v9 = 0;
  v5 = v9;
  if (v4)
  {
    return v5 + 16;
  }

  v10 = v9;
  v6 = *(a1 + 8);
  v7 = *(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }

  if (v7 + ~v6 - *(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    v6 = *(a1 + 8);
    v5 = v10;
  }

  *(a1 + 8) = v6 + 1;
  if (*v5 != -1)
  {
    --*(a1 + 12);
  }

  *v5 = *a2;
  *(v5 + 16) = 0u;
  *(v5 + 32) = 0u;
  *(v5 + 48) = 0u;
  *(v5 + 80) = 0u;
  *(v5 + 96) = 0u;
  *(v5 + 112) = 0u;
  *(v5 + 144) = 0u;
  *(v5 + 160) = 0u;
  *(v5 + 176) = 0u;
  *(v5 + 208) = 0u;
  *(v5 + 224) = 0u;
  *(v5 + 240) = 0u;
  *(v5 + 256) = 0u;
  *(v5 + 192) = 0u;
  *(v5 + 128) = 0u;
  *(v5 + 64) = 0u;
  *(v5 + 272) = 0u;
  *(v5 + 288) = 0u;
  *(v5 + 48) = v5 + 64;
  *(v5 + 60) = 3;
  *(v5 + 112) = v5 + 128;
  *(v5 + 124) = 3;
  *(v5 + 176) = v5 + 192;
  *(v5 + 188) = 6;
  *(v5 + 240) = v5 + 256;
  *(v5 + 252) = 6;
  return v5 + 16;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>,llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>::LookupBucketFor<llvm::StringRef>(uint64_t a1, int a2, uint64_t a3, unint64_t *a4)
{
  if (a2)
  {
    v7 = a2 - 1;
    v8 = (a2 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(*a3, *a3 + *(a3 + 8), a3, a4);
    v9 = a1 + 304 * v8;
    if (llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a3, *(a3 + 8), *v9, *(v9 + 8)))
    {
      result = 1;
    }

    else
    {
      v11 = 0;
      v12 = 1;
      while (*v9 != -1)
      {
        if (v11)
        {
          v13 = 0;
        }

        else
        {
          v13 = *v9 == -2;
        }

        if (v13)
        {
          v11 = v9;
        }

        v17 = v11;
        v14 = v12 + 1;
        v8 = (v8 + v12) & v7;
        v9 = a1 + 304 * v8;
        isEqual = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a3, *(a3 + 8), *v9, *(v9 + 8));
        v11 = v17;
        v16 = isEqual;
        result = 1;
        v12 = v14;
        if (v16)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v11)
      {
        v9 = v11;
      }
    }
  }

  else
  {
    v9 = 0;
    result = 0;
  }

LABEL_5:
  *a4 = v9;
  return result;
}

_OWORD *llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>,llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,mlir::ODIE::Compiler::Transforms::anonymous namespace::CompositeOpMetadata>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((304 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 304 * v10;
      do
      {
        *result = xmmword_25D0A05E0;
        result += 19;
        v11 -= 304;
      }

      while (v11);
    }

    if (v3)
    {
      v12 = 0;
      v13 = 304 * v3;
      do
      {
        v14 = v4 + v12;
        if (*(v4 + v12) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v27 = 0;
          v15 = v27;
          *v27 = *v14;
          v16 = *(v14 + 32);
          v15[1] = *(v14 + 16);
          v15[2] = v16;
          *(v15 + 6) = v15 + 4;
          *(v15 + 7) = 0x300000000;
          if (*(v14 + 56))
          {
            llvm::SmallVectorImpl<llvm::StringRef>::operator=((v15 + 3), v4 + v12 + 48);
          }

          *(v15 + 14) = v15 + 8;
          *(v15 + 15) = 0x300000000;
          v17 = v4 + v12;
          if (*(v4 + v12 + 120))
          {
            llvm::SmallVectorImpl<llvm::StringRef>::operator=((v15 + 7), v17 + 112);
          }

          *(v15 + 22) = v15 + 12;
          *(v15 + 23) = 0x600000000;
          if (*(v17 + 184))
          {
            llvm::SmallVectorImpl<mlir::Operation *>::operator=((v15 + 11), v4 + v12 + 176);
          }

          *(v15 + 30) = v15 + 16;
          v18 = (v15 + 15);
          *(v18 + 8) = 0x600000000;
          v19 = v4 + v12;
          if (*(v4 + v12 + 248))
          {
            llvm::SmallVectorImpl<mlir::Operation *>::operator=(v18, v19 + 240);
          }

          ++*(a1 + 8);
          v20 = *(v19 + 240);
          if ((v19 + 256) != v20)
          {
            free(v20);
          }

          v21 = v4 + v12;
          v22 = *(v4 + v12 + 176);
          if ((v4 + v12 + 192) != v22)
          {
            free(v22);
          }

          v23 = *(v21 + 112);
          if ((v21 + 128) != v23)
          {
            free(v23);
          }

          v24 = *(v4 + v12 + 48);
          if ((v4 + v12 + 64) != v24)
          {
            free(v24);
          }
        }

        v12 += 304;
      }

      while (v13 != v12);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v25 = *(a1 + 16);
  if (v25)
  {
    v26 = 304 * v25;
    do
    {
      *result = xmmword_25D0A05E0;
      result += 19;
      v26 -= 304;
    }

    while (v26);
  }

  return result;
}

void mlir::ODIE::Compiler::Transforms::getSortedListOfIO(uint64_t a1, mlir::Operation **a2, uint64_t a3)
{
  v40 = *MEMORY[0x277D85DE8];
  v33 = v35;
  v34 = 0x300000000;
  if (a3)
  {
    v4 = a2;
    v5 = &a2[a3];
    do
    {
      v6 = *v4;
      v7 = *(*(*v4 + 9) + 56);
      v31 = 0;
      v36 = &v31;
      if ((~*(v7 + 8) & 7) == 0)
      {
        v7 = 0;
      }

      if (!v7)
      {
        goto LABEL_30;
      }

      v8 = *(v7 + 8) & 7;
      if (v8 == 6)
      {
        v9 = v7 + 24 * *(v7 + 16);
        v10 = v9 + 120;
        if (v9 == -120)
        {
          goto LABEL_30;
        }
      }

      else
      {
        v10 = v7 + 16 * v8 + 16;
      }

      if (!mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(&v36, v10))
      {
        goto LABEL_29;
      }

      v11 = *(v31 + 8);
      v12 = (*(*(v31 + 16) + 24))();
      if (v13)
      {
        v14 = 8 * v13;
        v15 = 1;
        do
        {
          v16 = *v12++;
          v15 *= v16;
          v14 -= 8;
        }

        while (v14);
        if (v15 != 1)
        {
LABEL_29:
          v6 = *v4;
LABEL_30:
          v36 = "Expected constant input for index.";
          v39 = 259;
          mlir::Operation::emitOpError(v6, &v36, v32);
          mlir::InFlightDiagnostic::~InFlightDiagnostic(v32);
          *a1 = 0;
          *(a1 + 64) = 0;
          goto LABEL_34;
        }
      }

      mlir::DenseElementsAttr::tryGetValues<int,void>(&v31, &v36);
      if (v37)
      {
        v17 = 0;
      }

      else
      {
        v17 = v38[0];
      }

      v18 = *(v36 + v17);
      v19 = *v4;
      v20 = v34;
      if (v34 >= HIDWORD(v34))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v33, v35, v34 + 1, 16);
        v20 = v34;
      }

      v21 = v33 + 16 * v20;
      *v21 = v18;
      v21[1] = v19;
      v22 = (v34 + 1);
      LODWORD(v34) = v34 + 1;
      ++v4;
    }

    while (v4 != v5);
    v24 = v33;
    v23 = v33 + 16 * v22;
    if (v22)
    {
      v25 = 126 - 2 * __clz(v22);
      goto LABEL_24;
    }
  }

  else
  {
    v23 = v35;
    v24 = v35;
  }

  v25 = 0;
LABEL_24:
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,false>(v24, v23, v25, 1);
  v36 = v38;
  v37 = 0x600000000;
  if (v34)
  {
    v26 = 16 * v34;
    v27 = (v33 + 8);
    do
    {
      v28 = *v27;
      v27 += 2;
      llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(&v36, v28);
      v26 -= 16;
    }

    while (v26);
    v29 = v37;
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
    if (v29)
    {
      llvm::SmallVectorImpl<mlir::Operation *>::operator=(a1, &v36);
    }
  }

  else
  {
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
  }

  *(a1 + 64) = 1;
  if (v36 != v38)
  {
    free(v36);
  }

LABEL_34:
  if (v33 != v35)
  {
    free(v33);
  }

  v30 = *MEMORY[0x277D85DE8];
}

void mlir::ODIE::Compiler::Transforms::getBoundaryOpInput(void *a1, uint64_t *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x600000000;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      v6 = *a2++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(a1, *(*(v6 + 72) + 24));
      v5 -= 8;
    }

    while (v5);
  }
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OutputOp,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v17[8] = *MEMORY[0x277D85DE8];
  v6 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::OutputOp>(a1, *(**a2 + 32));
  v11[0] = a2;
  v11[1] = v6;
  v12[0] = v13;
  v12[1] = 0x400000000;
  v13[4] = v14;
  v13[5] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[8] = 4;
  v15[9] = v16;
  v15[10] = 0x100000000;
  v16[1] = v17;
  v16[2] = 0x100000000;
  v17[1] = 0;
  v17[2] = 0;
  v17[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v17[4] = 0;
  v17[6] = 0;
  llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(v12, *a3 & 0xFFFFFFFFFFFFFFF9, 0, *a3 & 0xFFFFFFFFFFFFFFF9, *(a3 + 8));
  v7 = mlir::Operation::create(v11);
  mlir::OpBuilder::insert(a1, v7);
  if (*(*(v7 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OutputOp,void>::id)
  {
    v8 = v7;
  }

  else
  {
    v8 = 0;
  }

  mlir::OperationState::~OperationState(v11);
  v9 = *MEMORY[0x277D85DE8];
  return v8;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,false>(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  v7 = result;
LABEL_2:
  v8 = (a2 - 16);
  j = v7;
  while (1)
  {
    v7 = j;
    v10 = (a2 - j) >> 4;
    if (v10 > 2)
    {
      switch(v10)
      {
        case 3:

          return std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(j, (j + 16), (a2 - 16));
        case 4:
          result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(j, (j + 16), (j + 32));
          v44 = *(a2 - 16);
          v45 = *(j + 32);
          if (v44 >= v45)
          {
            if (v45 < v44)
            {
              return result;
            }

            v47 = *(a2 - 8);
            v46 = *(j + 40);
            if (v47 >= v46)
            {
              return result;
            }
          }

          else
          {
            v46 = *(j + 40);
            v47 = *(a2 - 8);
          }

          *(j + 32) = v44;
          *(a2 - 16) = v45;
          *(j + 40) = v47;
          *(a2 - 8) = v46;
          v48 = *(j + 32);
          v49 = *(j + 16);
          if (v48 >= v49)
          {
            if (v49 < v48)
            {
              return result;
            }

            v51 = *(j + 40);
            v50 = *(j + 24);
            if (v51 >= v50)
            {
              return result;
            }
          }

          else
          {
            v50 = *(j + 24);
            v51 = *(j + 40);
          }

          *(j + 16) = v48;
          *(j + 32) = v49;
          *(j + 24) = v51;
          *(j + 40) = v50;
          v52 = *j;
          if (v48 >= *j)
          {
            if (v52 < v48)
            {
              return result;
            }

            v53 = *(j + 8);
            if (v51 >= v53)
            {
              return result;
            }
          }

          else
          {
            v53 = *(j + 8);
          }

          *j = v48;
          *(j + 16) = v52;
          *(j + 8) = v51;
          *(j + 24) = v53;
          return result;
        case 5:

          return std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(j, j + 16, j + 32, j + 48, (a2 - 16));
      }
    }

    else
    {
      if (v10 < 2)
      {
        return result;
      }

      if (v10 == 2)
      {
        v54 = *(a2 - 16);
        v55 = *j;
        if (v54 >= *j)
        {
          if (v55 < v54)
          {
            return result;
          }

          v57 = *(a2 - 8);
          v56 = *(j + 8);
          if (v57 >= v56)
          {
            return result;
          }
        }

        else
        {
          v56 = *(j + 8);
          v57 = *(a2 - 8);
        }

        *j = v54;
        *(a2 - 16) = v55;
        *(j + 8) = v57;
        *(a2 - 8) = v56;
        return result;
      }
    }

    if (v10 <= 23)
    {
      break;
    }

    if (!a3)
    {
      if (j == a2)
      {
        return result;
      }

      v73 = (v10 - 2) >> 1;
      v74 = v73;
      while (1)
      {
        v75 = v74;
        if (v73 >= v74)
        {
          v76 = (2 * v74) | 1;
          v77 = j + 16 * v76;
          if (2 * v75 + 2 < v10)
          {
            v78 = *(v77 + 16);
            if (*v77 < v78 || v78 >= *v77 && *(v77 + 8) < *(v77 + 24))
            {
              v77 += 16;
              v76 = 2 * v75 + 2;
            }
          }

          v79 = j + 16 * v75;
          v80 = *v77;
          v81 = *v79;
          if (*v77 >= *v79)
          {
            if (v81 < v80)
            {
              v82 = *(v79 + 8);
              v83 = *(v77 + 8);
LABEL_147:
              *v79 = v80;
              *(v79 + 8) = v83;
              if (v73 >= v76)
              {
                while (1)
                {
                  v85 = 2 * v76;
                  v76 = (2 * v76) | 1;
                  v84 = j + 16 * v76;
                  v86 = v85 + 2;
                  if (v86 < v10)
                  {
                    result = *(v84 + 16);
                    if (*v84 < result || result >= *v84 && (result = *(v84 + 8), result < *(v84 + 24)))
                    {
                      v84 += 16;
                      v76 = v86;
                    }
                  }

                  v87 = *v84;
                  if (*v84 < v81)
                  {
                    break;
                  }

                  v88 = *(v84 + 8);
                  if (v81 >= v87 && v88 < v82)
                  {
                    break;
                  }

                  *v77 = v87;
                  *(v77 + 8) = v88;
                  v77 = v84;
                  if (v73 < v76)
                  {
                    goto LABEL_149;
                  }
                }
              }

              v84 = v77;
LABEL_149:
              *v84 = v81;
              *(v84 + 8) = v82;
              goto LABEL_150;
            }

            v83 = *(v77 + 8);
            v82 = *(v79 + 8);
            if (v83 >= v82)
            {
              goto LABEL_147;
            }
          }
        }

LABEL_150:
        v74 = v75 - 1;
        if (!v75)
        {
          while (1)
          {
            v92 = 0;
            v93 = *j;
            v94 = *(j + 8);
            v95 = j;
            do
            {
              v96 = v95;
              v97 = v95 + 16 * v92;
              v95 = v97 + 16;
              v98 = 2 * v92;
              v92 = (2 * v92) | 1;
              v99 = v98 + 2;
              if (v99 < v10)
              {
                result = *(v97 + 32);
                v100 = *(v97 + 16);
                if (v100 < result || result >= v100 && (result = *(v97 + 24), result < *(v97 + 40)))
                {
                  v95 = v97 + 32;
                  v92 = v99;
                }
              }

              *v96 = *v95;
              *(v96 + 8) = *(v95 + 8);
            }

            while (v92 <= ((v10 - 2) >> 1));
            if (v95 == a2 - 16)
            {
              *v95 = v93;
              *(v95 + 8) = v94;
            }

            else
            {
              *v95 = *(a2 - 16);
              *(v95 + 8) = *(a2 - 8);
              *(a2 - 16) = v93;
              *(a2 - 8) = v94;
              v101 = (v95 - j + 16) >> 4;
              v102 = v101 - 2;
              if (v101 >= 2)
              {
                v103 = v102 >> 1;
                v104 = j + 16 * (v102 >> 1);
                v105 = *v104;
                v106 = *v95;
                if (*v104 < *v95)
                {
                  v91 = *(v95 + 8);
                  v90 = *(v104 + 8);
LABEL_179:
                  *v95 = v105;
                  *(v95 + 8) = v90;
                  if (v102 >= 2)
                  {
                    while (1)
                    {
                      v108 = v103 - 1;
                      v103 = (v103 - 1) >> 1;
                      v107 = j + 16 * v103;
                      v109 = *v107;
                      if (*v107 >= v106)
                      {
                        if (v106 < v109)
                        {
                          break;
                        }

                        v110 = *(v107 + 8);
                        if (v110 >= v91)
                        {
                          break;
                        }
                      }

                      else
                      {
                        v110 = *(v107 + 8);
                      }

                      *v104 = v109;
                      *(v104 + 8) = v110;
                      v104 = j + 16 * v103;
                      if (v108 <= 1)
                      {
                        goto LABEL_186;
                      }
                    }
                  }

                  v107 = v104;
LABEL_186:
                  *v107 = v106;
                  *(v107 + 8) = v91;
                  goto LABEL_188;
                }

                if (v106 >= v105)
                {
                  v90 = *(v104 + 8);
                  v91 = *(v95 + 8);
                  if (v90 < v91)
                  {
                    goto LABEL_179;
                  }
                }
              }
            }

LABEL_188:
            a2 -= 16;
            if (v10-- <= 2)
            {
              return result;
            }
          }
        }
      }
    }

    v11 = v10 >> 1;
    v12 = j + 16 * (v10 >> 1);
    if (v10 < 0x81)
    {
      result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>((v7 + 16 * (v10 >> 1)), v7, (a2 - 16));
    }

    else
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(v7, (v7 + 16 * (v10 >> 1)), (a2 - 16));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>((v7 + 16), (v12 - 16), (a2 - 32));
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>((v7 + 32), (v7 + 16 + 16 * v11), (a2 - 48));
      result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>((v12 - 16), v12, (v7 + 16 + 16 * v11));
      v13 = *v7;
      *v7 = *v12;
      *v12 = v13;
      v14 = *(v7 + 8);
      *(v7 + 8) = *(v12 + 8);
      *(v12 + 8) = v14;
    }

    --a3;
    v15 = *v7;
    if ((a4 & 1) != 0 || (v16 = *(v7 - 16), v16 < v15))
    {
LABEL_19:
      v18 = 0;
      v19 = *(v7 + 8);
      while (1)
      {
        v20 = *(v7 + v18 + 16);
        if (v20 >= v15 && (v15 < v20 || *(v7 + v18 + 24) >= v19))
        {
          break;
        }

        v18 += 16;
      }

      v21 = v7 + v18 + 16;
      if (v18)
      {
        v22 = *v8;
        for (i = a2 - 16; v22 >= v15 && (v15 < v22 || *(i + 8) >= v19); i -= 16)
        {
          v24 = *(i - 16);
          v22 = v24;
        }
      }

      else
      {
        i = a2;
        if (v21 < a2)
        {
          v25 = *v8;
          i = a2 - 16;
          if (*v8 >= v15)
          {
            i = a2 - 16;
            do
            {
              if (v15 >= v25)
              {
                if (v21 >= i || *(i + 8) < v19)
                {
                  break;
                }
              }

              else if (v21 >= i)
              {
                break;
              }

              v26 = *(i - 16);
              i -= 16;
              v25 = v26;
            }

            while (v26 >= v15);
          }
        }
      }

      if (v21 >= i)
      {
        j = v21;
      }

      else
      {
        v27 = *i;
        j = v21;
        v28 = i;
        do
        {
          *j = v27;
          *v28 = v20;
          v29 = *(j + 8);
          *(j + 8) = *(v28 + 8);
          *(v28 + 8) = v29;
          do
          {
            do
            {
              v30 = *(j + 16);
              j += 16;
              v20 = v30;
            }

            while (v30 < v15);
          }

          while (v15 >= v20 && *(j + 8) < v19);
          do
          {
            v31 = *(v28 - 16);
            v28 -= 16;
            v27 = v31;
          }

          while (v31 >= v15 && (v15 < v27 || *(v28 + 8) >= v19));
        }

        while (j < v28);
      }

      if (j - 16 != v7)
      {
        *v7 = *(j - 16);
        *(v7 + 8) = *(j - 8);
      }

      *(j - 16) = v15;
      *(j - 8) = v19;
      if (v21 < i)
      {
LABEL_56:
        result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,false>(v7, j - 16, a3, a4 & 1);
        a4 = 0;
      }

      else
      {
        v32 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *>(v7, j - 16);
        result = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *>(j, a2);
        if (result)
        {
          a2 = j - 16;
          if (v32)
          {
            return result;
          }

          goto LABEL_2;
        }

        if (!v32)
        {
          goto LABEL_56;
        }
      }
    }

    else
    {
      if (v15 < v16)
      {
        v17 = *(v7 + 8);
      }

      else
      {
        v17 = *(v7 + 8);
        if (*(v7 - 8) < v17)
        {
          goto LABEL_19;
        }
      }

      v33 = *v8;
      if (v15 < *v8 || v33 >= v15 && v17 < *(a2 - 8))
      {
        j = v7;
        do
        {
          v35 = *(j + 16);
          j += 16;
          v34 = v35;
        }

        while (v15 >= v35 && (v34 < v15 || v17 >= *(j + 8)));
      }

      else
      {
          ;
        }
      }

      k = a2;
      if (j < a2)
      {
        for (k = a2 - 16; v15 < v33 || v33 >= v15 && v17 < *(k + 8); k -= 16)
        {
          v37 = *(k - 16);
          v33 = v37;
        }
      }

      if (j < k)
      {
        v38 = *j;
        v39 = *k;
        do
        {
          *j = v39;
          *k = v38;
          v40 = *(j + 16);
          j += 16;
          v38 = v40;
          v41 = *(j - 8);
          *(j - 8) = *(k + 8);
          *(k + 8) = v41;
          while (v15 >= v38 && (v38 < v15 || v17 >= *(j + 8)))
          {
            v42 = *(j + 16);
            j += 16;
            v38 = v42;
          }

          do
          {
            do
            {
              v43 = *(k - 16);
              k -= 16;
              v39 = v43;
            }

            while (v15 < v43);
          }

          while (v39 >= v15 && v17 < *(k + 8));
        }

        while (j < k);
      }

      if (j - 16 != v7)
      {
        *v7 = *(j - 16);
        *(v7 + 8) = *(j - 8);
      }

      a4 = 0;
      *(j - 16) = v15;
      *(j - 8) = v17;
    }
  }

  v58 = j + 16;
  v60 = j == a2 || v58 == a2;
  if ((a4 & 1) == 0)
  {
    if (v60)
    {
      return result;
    }

    for (m = j + 8; ; m += 16)
    {
      v113 = v7;
      v7 = v58;
      v114 = *(v113 + 16);
      v115 = *v113;
      if (v114 < *v113)
      {
        break;
      }

      if (v115 >= v114)
      {
        v116 = *(v113 + 24);
        if (v116 < *(v113 + 8))
        {
          goto LABEL_201;
        }
      }

LABEL_209:
      v58 = v7 + 16;
      if (v7 + 16 == a2)
      {
        return result;
      }
    }

    v116 = *(v113 + 24);
LABEL_201:
    for (n = m; ; n -= 16)
    {
      *(n + 8) = v115;
      *(n + 16) = *n;
      v115 = *(n - 24);
      if (v114 >= v115 && (v115 < v114 || v116 >= *(n - 16)))
      {
        break;
      }
    }

    *(n - 8) = v114;
    *n = v116;
    goto LABEL_209;
  }

  if (v60)
  {
    return result;
  }

  v61 = 0;
  v62 = j;
  while (2)
  {
    v63 = v62;
    v62 = v58;
    v64 = *(v63 + 16);
    v65 = *v63;
    if (v64 >= *v63)
    {
      if (v65 < v64)
      {
        goto LABEL_133;
      }

      v66 = *(v63 + 24);
      v67 = *(v63 + 8);
      if (v66 >= v67)
      {
        goto LABEL_133;
      }
    }

    else
    {
      v66 = *(v63 + 24);
      v67 = *(v63 + 8);
    }

    *(v63 + 16) = v65;
    *(v62 + 8) = v67;
    v68 = j;
    if (v63 == j)
    {
      goto LABEL_132;
    }

    v69 = v61;
    while (2)
    {
      v70 = *(j + v69 - 16);
      if (v64 < v70)
      {
        v71 = *(j + v69 - 8);
        goto LABEL_126;
      }

      if (v70 >= v64)
      {
        v68 = j + v69;
        v71 = *(j + v69 - 8);
        if (v66 >= v71)
        {
          goto LABEL_132;
        }

LABEL_126:
        v63 -= 16;
        v72 = j + v69;
        *v72 = v70;
        *(v72 + 8) = v71;
        v69 -= 16;
        if (!v69)
        {
          v68 = j;
          goto LABEL_132;
        }

        continue;
      }

      break;
    }

    v68 = v63;
LABEL_132:
    *v68 = v64;
    *(v68 + 8) = v66;
LABEL_133:
    v58 = v62 + 16;
    v61 += 16;
    if (v62 + 16 != a2)
    {
      continue;
    }

    return result;
  }
}

int *std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(int *result, int *a2, int *a3)
{
  v3 = *a2;
  v4 = *result;
  if (*a2 < *result || v4 >= v3 && *(a2 + 1) < *(result + 1))
  {
    v5 = *a3;
    if (*a3 < v3)
    {
      v6 = *(a3 + 1);
LABEL_4:
      *result = v5;
      *a3 = v4;
      v7 = *(result + 1);
      *(result + 1) = v6;
      *(a3 + 1) = v7;
      return result;
    }

    if (v3 >= v5)
    {
      v6 = *(a3 + 1);
      v15 = *(a2 + 1);
      if (v6 < v15)
      {
        goto LABEL_4;
      }
    }

    else
    {
      v15 = *(a2 + 1);
    }

    *result = v3;
    *a2 = v4;
    v16 = *(result + 1);
    *(result + 1) = v15;
    *(a2 + 1) = v16;
    v17 = *a3;
    if (*a3 >= v4)
    {
      if (v4 < v17)
      {
        return result;
      }

      v18 = *(a3 + 1);
      if (v18 >= v16)
      {
        return result;
      }
    }

    else
    {
      v18 = *(a3 + 1);
    }

    *a2 = v17;
    *a3 = v4;
    *(a2 + 1) = v18;
    *(a3 + 1) = v16;
    return result;
  }

  v8 = *a3;
  if (*a3 >= v3)
  {
    if (v3 < v8)
    {
      return result;
    }

    v10 = *(a3 + 1);
    v9 = *(a2 + 1);
    if (v10 >= v9)
    {
      return result;
    }
  }

  else
  {
    v9 = *(a2 + 1);
    v10 = *(a3 + 1);
  }

  *a2 = v8;
  *a3 = v3;
  *(a2 + 1) = v10;
  *(a3 + 1) = v9;
  v11 = *a2;
  v12 = *result;
  if (*a2 < *result)
  {
    v13 = *(result + 1);
    v14 = *(a2 + 1);
LABEL_11:
    *result = v11;
    *a2 = v12;
    *(result + 1) = v14;
    *(a2 + 1) = v13;
    return result;
  }

  if (v12 >= v11)
  {
    v14 = *(a2 + 1);
    v13 = *(result + 1);
    if (v14 < v13)
    {
      goto LABEL_11;
    }
  }

  return result;
}

int *std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(a1, a2, a3);
  v11 = *a4;
  v12 = *a3;
  if (*a4 >= *a3)
  {
    if (v12 < v11)
    {
      goto LABEL_16;
    }

    v14 = *(a4 + 8);
    v13 = *(a3 + 8);
    if (v14 >= v13)
    {
      goto LABEL_16;
    }
  }

  else
  {
    v13 = *(a3 + 8);
    v14 = *(a4 + 8);
  }

  *a3 = v11;
  *a4 = v12;
  *(a3 + 8) = v14;
  *(a4 + 8) = v13;
  v15 = *a3;
  v16 = *a2;
  if (*a3 >= *a2)
  {
    if (v16 < v15)
    {
      goto LABEL_16;
    }

    v18 = *(a3 + 8);
    v17 = *(a2 + 8);
    if (v18 >= v17)
    {
      goto LABEL_16;
    }
  }

  else
  {
    v17 = *(a2 + 8);
    v18 = *(a3 + 8);
  }

  *a2 = v15;
  *a3 = v16;
  *(a2 + 8) = v18;
  *(a3 + 8) = v17;
  v19 = *a2;
  v20 = *a1;
  if (*a2 < *a1)
  {
    v21 = *(a1 + 8);
    v22 = *(a2 + 8);
LABEL_7:
    *a1 = v19;
    *a2 = v20;
    *(a1 + 8) = v22;
    *(a2 + 8) = v21;
    goto LABEL_16;
  }

  if (v20 >= v19)
  {
    v22 = *(a2 + 8);
    v21 = *(a1 + 8);
    if (v22 < v21)
    {
      goto LABEL_7;
    }
  }

LABEL_16:
  v23 = *a5;
  v24 = *a4;
  if (*a5 >= *a4)
  {
    if (v24 < v23)
    {
      return result;
    }

    v26 = *(a5 + 1);
    v25 = *(a4 + 8);
    if (v26 >= v25)
    {
      return result;
    }
  }

  else
  {
    v25 = *(a4 + 8);
    v26 = *(a5 + 1);
  }

  *a4 = v23;
  *a5 = v24;
  *(a4 + 8) = v26;
  *(a5 + 1) = v25;
  v27 = *a4;
  v28 = *a3;
  if (*a4 >= *a3)
  {
    if (v28 < v27)
    {
      return result;
    }

    v30 = *(a4 + 8);
    v29 = *(a3 + 8);
    if (v30 >= v29)
    {
      return result;
    }
  }

  else
  {
    v29 = *(a3 + 8);
    v30 = *(a4 + 8);
  }

  *a3 = v27;
  *a4 = v28;
  *(a3 + 8) = v30;
  *(a4 + 8) = v29;
  v31 = *a3;
  v32 = *a2;
  if (*a3 >= *a2)
  {
    if (v32 < v31)
    {
      return result;
    }

    v34 = *(a3 + 8);
    v33 = *(a2 + 8);
    if (v34 >= v33)
    {
      return result;
    }
  }

  else
  {
    v33 = *(a2 + 8);
    v34 = *(a3 + 8);
  }

  *a2 = v31;
  *a3 = v32;
  *(a2 + 8) = v34;
  *(a3 + 8) = v33;
  v35 = *a2;
  v36 = *a1;
  if (*a2 < *a1)
  {
    v37 = *(a1 + 8);
    v38 = *(a2 + 8);
LABEL_24:
    *a1 = v35;
    *a2 = v36;
    *(a1 + 8) = v38;
    *(a2 + 8) = v37;
    return result;
  }

  if (v36 >= v35)
  {
    v38 = *(a2 + 8);
    v37 = *(a1 + 8);
    if (v38 < v37)
    {
      goto LABEL_24;
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *>(uint64_t a1, uint64_t a2)
{
  v4 = (a2 - a1) >> 4;
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(a1, (a1 + 16), (a2 - 16));
        return 1;
      case 4:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(a1, (a1 + 16), (a1 + 32));
        v22 = *(a2 - 16);
        v23 = *(a1 + 32);
        if (v22 >= v23)
        {
          if (v23 < v22)
          {
            return 1;
          }

          v25 = *(a2 - 8);
          v24 = *(a1 + 40);
          if (v25 >= v24)
          {
            return 1;
          }
        }

        else
        {
          v24 = *(a1 + 40);
          v25 = *(a2 - 8);
        }

        *(a1 + 32) = v22;
        *(a2 - 16) = v23;
        *(a1 + 40) = v25;
        *(a2 - 8) = v24;
        v26 = *(a1 + 32);
        v27 = *(a1 + 16);
        if (v26 >= v27)
        {
          if (v27 < v26)
          {
            return 1;
          }

          v29 = *(a1 + 40);
          v28 = *(a1 + 24);
          if (v29 >= v28)
          {
            return 1;
          }
        }

        else
        {
          v28 = *(a1 + 24);
          v29 = *(a1 + 40);
        }

        *(a1 + 16) = v26;
        *(a1 + 32) = v27;
        *(a1 + 24) = v29;
        *(a1 + 40) = v28;
        v30 = *a1;
        if (v26 >= *a1)
        {
          if (v30 < v26)
          {
            return 1;
          }

          v31 = *(a1 + 8);
          if (v29 >= v31)
          {
            return 1;
          }
        }

        else
        {
          v31 = *(a1 + 8);
        }

        *a1 = v26;
        *(a1 + 16) = v30;
        *(a1 + 8) = v29;
        result = 1;
        *(a1 + 24) = v31;
        return result;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(a1, a1 + 16, a1 + 32, a1 + 48, (a2 - 16));
        return 1;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = *(a2 - 16);
      v6 = *a1;
      if (v5 < *a1)
      {
        v7 = *(a1 + 8);
        v8 = *(a2 - 8);
LABEL_6:
        *a1 = v5;
        *(a2 - 16) = v6;
        *(a1 + 8) = v8;
        result = 1;
        *(a2 - 8) = v7;
        return result;
      }

      if (v6 >= v5)
      {
        v8 = *(a2 - 8);
        v7 = *(a1 + 8);
        if (v8 < v7)
        {
          goto LABEL_6;
        }
      }

      return 1;
    }
  }

  v10 = a1 + 32;
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,mlir::Operation *> *,0>(a1, (a1 + 16), (a1 + 32));
  v11 = a1 + 48;
  if (a1 + 48 == a2)
  {
    return 1;
  }

  v12 = 0;
  v13 = 0;
  while (2)
  {
    v14 = *v11;
    v15 = *v10;
    if (*v11 >= *v10)
    {
      if (v15 < v14)
      {
        goto LABEL_28;
      }

      v16 = *(v11 + 8);
      v17 = *(v10 + 8);
      if (v16 >= v17)
      {
        goto LABEL_28;
      }
    }

    else
    {
      v16 = *(v11 + 8);
      v17 = *(v10 + 8);
    }

    *v11 = v15;
    *(v11 + 8) = v17;
    v18 = v12;
    while (1)
    {
      v19 = a1 + v18;
      v20 = *(a1 + v18 + 16);
      if (v14 >= v20)
      {
        break;
      }

      v21 = *(v19 + 24);
LABEL_21:
      v10 -= 16;
      *(v19 + 32) = v20;
      *(a1 + v18 + 40) = v21;
      v18 -= 16;
      if (v18 == -32)
      {
        v10 = a1;
        goto LABEL_27;
      }
    }

    if (v20 >= v14)
    {
      v21 = *(a1 + v18 + 24);
      if (v16 >= v21)
      {
        goto LABEL_27;
      }

      goto LABEL_21;
    }

    v10 = a1 + v18 + 32;
LABEL_27:
    *v10 = v14;
    *(v10 + 8) = v16;
    if (++v13 != 8)
    {
LABEL_28:
      v10 = v11;
      v12 += 16;
      v11 += 16;
      if (v11 == a2)
      {
        return 1;
      }

      continue;
    }

    return v11 + 16 == a2;
  }
}

std::random_device *std::random_device::random_device[abi:nn200100](std::random_device *a1)
{
  std::string::basic_string[abi:nn200100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__token.__r_.__value_.__l.__data_);
  }

  return a1;
}

void *std::pair<llvm::SmallVector<mlir::Type,6u>,llvm::SmallVector<mlir::Location,6u>>::pair[abi:nn200100]<llvm::SmallVector<mlir::Type,6u>&,llvm::SmallVector<mlir::Location,6u>&,0>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x600000000;
  if (*(a2 + 8))
  {
    llvm::SmallVectorImpl<mlir::Type>::operator=(a1, a2);
  }

  a1[8] = a1 + 10;
  a1[9] = 0x600000000;
  if (*(a3 + 8))
  {
    llvm::SmallVectorImpl<mlir::Location>::operator=((a1 + 8), a3);
  }

  return a1;
}

uint64_t **mlir::ResultRange::replaceAllUsesWith<llvm::ArrayRef<mlir::Value>>(uint64_t **result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4)
  {
    v5 = result;
    v6 = 0;
    v7 = 8 * a4 - 8;
    v8 = a2 - 1;
    v9 = result;
    while (1)
    {
      v10 = v5;
      if (!v6)
      {
        goto LABEL_10;
      }

      v11 = v5;
      v12 = v6;
      if (v5)
      {
        v13 = v5[1] & 7;
        v11 = v5;
        v12 = v6;
        if (v13 != 6)
        {
          v14 = (5 - v13);
          v10 = v9;
          v12 = v6 - v14;
          if (v6 <= v14)
          {
            goto LABEL_10;
          }

          v11 = &v5[-2 * v14];
        }
      }

      v10 = &v11[-3 * v12];
LABEL_10:
      v16 = *(a3 + 8 * v6);
      result = mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith<mlir::Value &>(v10, &v16);
      if (v8 != v6)
      {
        ++v6;
        v15 = v7;
        v7 -= 8;
        v9 -= 2;
        if (v15)
        {
          continue;
        }
      }

      return result;
    }
  }

  return result;
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteHardwareBackedIOToGraphBoundaries>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA49D8;
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 1872);
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 1632);
    mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(v2 + 1368);
    mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(v2 + 1104);
    mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(v2 + 840);
    mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(v2 + 576);
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 336);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::PromoteHardwareBackedIOToGraphBoundariesBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteHardwareBackedIOToGraphBoundaries>::PromoteHardwareBackedIOToGraphBoundariesBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA49D8;
  *&v3 = "The name of the graph to force to hardware-backed IO.";
  *(&v3 + 1) = 53;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 336), (a1 + 144), "force-graph-name", 16, &v3);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  *&v3 = "The arguments to force to hardware-backed IO.";
  *(&v3 + 1) = 45;
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::ListOption<llvm::cl::desc>(a1 + 576, (a1 + 144), "force-argument-idxs", 19, &v3);
  *(a1 + 576) = &unk_286EA4A48;
  *(a1 + 816) = &unk_286EA4AC8;
  *&v3 = "The results to force to hardware-backed IO.";
  *(&v3 + 1) = 43;
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::ListOption<llvm::cl::desc>(a1 + 840, (a1 + 144), "force-result-idxs", 17, &v3);
  *(a1 + 840) = &unk_286EA4A48;
  *(a1 + 1080) = &unk_286EA4AC8;
  *&v3 = "The alignments of the hardware-backed IO.";
  *(&v3 + 1) = 41;
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::ListOption<llvm::cl::desc>(a1 + 1104, (a1 + 144), "alignments", 10, &v3);
  *(a1 + 1104) = &unk_286EA4C78;
  *(a1 + 1344) = &unk_286EA4CF8;
  *&v3 = "The interleave of the hardware-backed IO.";
  *(&v3 + 1) = 41;
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::ListOption<llvm::cl::desc>(a1 + 1368, (a1 + 144), "interleave", 10, &v3);
  *(a1 + 1368) = &unk_286EA4C78;
  *(a1 + 1608) = &unk_286EA4CF8;
  *&v3 = "The parameter name to use for the hardware-backed IO.";
  *(&v3 + 1) = 53;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 1632), (a1 + 144), "parameter-name", 14, &v3);
  *(a1 + 1632) = &unk_286E98FD0;
  *(a1 + 1856) = &unk_286E99050;
  *&v3 = "The allocation type of the hardware-backed IO.";
  *(&v3 + 1) = 46;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 1872), (a1 + 144), "allocation-type", 15, &v3);
  *(a1 + 1872) = &unk_286E98FD0;
  *(a1 + 2096) = &unk_286E99050;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteHardwareBackedIOToGraphBoundaries::~PromoteHardwareBackedIOToGraphBoundaries(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PromoteHardwareBackedIOToGraphBoundaries *this)
{
  *this = &unk_286EA49D8;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 1872);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 1632);
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(this + 1368);
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(this + 1104);
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(this + 840);
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(this + 576);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA49D8;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 1872);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 1632);
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(this + 1368);
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(this + 1104);
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(this + 840);
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(this + 576);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteHardwareBackedIOToGraphBoundaries::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PromoteHardwareBackedIOToGraphBoundaries *this)
{
  v193 = *MEMORY[0x277D85DE8];
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *(v2 + 24);
  v4 = *(this + 479);
  if (v4 < 0)
  {
    v5 = *(this + 58);
  }

  else
  {
    v5 = *(this + 479);
  }

  if (!v5)
  {
LABEL_168:
    v140 = *(**v3 + 32);
    *&__p[8] = 0u;
    v163 = 0u;
    *__p = v140;
    v164 = v166;
    v165 = 0x600000000;
    v166[6] = 0;
    v166[7] = 0;
    v167 = 0;
    v168 = 0;
    v169 = 0;
    v170 = 0;
    v171 = 40;
    v172 = 0;
    v173 = 0;
    v174 = 0;
    v175 = 40;
    v141 = *(***(v2 + 24) + 32);
    operator new();
  }

  v159 = v161;
  v160 = 0x300000000;
  v6 = *(this + 57);
  if (v4 < 0)
  {
    v4 = *(this + 58);
  }

  else
  {
    v6 = this + 456;
  }

  *__p = v6;
  *&__p[8] = v4;
  llvm::StringRef::split(__p, &v159, 46, -1, 1);
  v156 = v158;
  v157 = 0x600000000;
  llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::resizeImpl<false>(&v156, v160 - 1);
  v8 = v159;
  v9 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  if (v160 != 1)
  {
    v10 = v159 + 16 * v160;
    v11 = *(***(v9 + 24) + 32);
    v12 = v156;
    v13 = v159 + 16;
    do
    {
      v14 = *v13;
      v15 = *(v13 + 1);
      v13 += 16;
      WORD4(v163) = 261;
      *__p = v14;
      *&__p[8] = v15;
      v16 = mlir::StringAttr::get(v11, __p, v7);
      *v12++ = mlir::SymbolRefAttr::get(v16, 0, 0, v17);
    }

    while (v13 != v10);
    v8 = v159;
    v9 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  }

  v18 = *(***(v9 + 24) + 32);
  v20 = *v8;
  v19 = v8[1];
  v21 = v156;
  v22 = v157;
  WORD4(v163) = 261;
  *__p = v20;
  *&__p[8] = v19;
  v23 = mlir::StringAttr::get(v18, __p, v7);
  v25 = mlir::SymbolRefAttr::get(v23, v21, v22, v24);
  v150[0] = 0;
  v150[1] = 0;
  v151 = 0;
  v26 = mlir::SymbolTableCollection::lookupSymbolIn(v150, *(this + 5) & 0xFFFFFFFFFFFFFFF8, v25);
  if (!v26 || ((v27 = *(v26[2].__r_.__value_.__r.__words[0] + 16), v28 = v27 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id, v27 != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id) ? (v29 = 0) : (v29 = v26), !v28))
  {
    v179 = "failed to find graph named ";
    LOWORD(v183) = 259;
    emitDiag(v3, 2, &v179, __p);
    if (*__p)
    {
      LOWORD(v188) = 260;
      v184 = this + 456;
      mlir::Diagnostic::operator<<(&__p[8], &v184);
      if (*__p)
      {
        mlir::Diagnostic::operator<<<13ul>(&__p[8], " parsed as (");
        if (*__p)
        {
          LODWORD(v184) = 0;
          v185 = v25;
          v30 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v163, &v184, 1);
          v31 = v163 + 24 * DWORD2(v163);
          v32 = *v30;
          *(v31 + 16) = *(v30 + 16);
          *v31 = v32;
          ++DWORD2(v163);
          if (*__p)
          {
            mlir::Diagnostic::operator<<<3ul>(&__p[8], ").");
          }
        }
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(__p);
    *(this + 5) |= 4uLL;
    llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v150);
    MEMORY[0x25F891030](v150[0], 8);
    if (v156 != v158)
    {
      free(v156);
    }

    if (v159 != v161)
    {
      free(v159);
    }

    goto LABEL_169;
  }

  v149 = v29;
  v155 = v26;
  v33 = *(*(&v26[3].__r_.__value_.__l.__size_ + 2 * ((HIDWORD(v26[1].__r_.__value_.__r.__words[2]) >> 23) & 1)) + 8);
  v34 = *(v33 + 16);
  v35 = &v34[8 * *(v33 + 8)];
  v184 = &v186;
  v185 = 0x600000000;
  llvm::SmallVectorImpl<mlir::Type>::append<mlir::Type const*,void>(&v184, v34, v35);
  v147 = v33;
  v36 = (*(v33 + 16) + 8 * *(v33 + 8));
  v37 = &v36[8 * *(v33 + 12)];
  v179 = &v181;
  v180 = 0x600000000;
  llvm::SmallVectorImpl<mlir::Type>::append<mlir::Type const*,void>(&v179, v36, v37);
  mlir::ODIE::Compiler::CoreML::detail::ParamScopeOpInterfaceTrait<mlir::ODIE::Compiler::CoreML::GraphOp>::getAllParamDecls(&v155, &v176);
  v38 = v176;
  v39 = v177;
  if (v177)
  {
    v40 = *(this + 1775);
    if (v40 >= 0)
    {
      v41 = this + 1752;
    }

    else
    {
      v41 = *(this + 219);
    }

    if (v40 >= 0)
    {
      v42 = *(this + 1775);
    }

    else
    {
      v42 = *(this + 220);
    }

    v43 = 8 * v177;
    v44 = v176;
    while (1)
    {
      v45 = *(*v44 + 8);
      if (*(v45 + 24) == v42 && (!v42 || !memcmp(*(v45 + 16), v41, v42)))
      {
        break;
      }

      v44 += 8;
      v43 -= 8;
      if (!v43)
      {
        v46 = 0;
        goto LABEL_43;
      }
    }
  }

  else
  {
    v44 = v176;
  }

  if (v44 == &v38[8 * v39])
  {
    v46 = 0;
  }

  else
  {
    v46 = mlir::ODIE::Compiler::CoreML::ParamRefAttr::get(*v44);
  }

LABEL_43:
  v47 = *(this + 2015);
  if (v47 >= 0)
  {
    v48 = this + 1992;
  }

  else
  {
    v48 = *(this + 249);
  }

  v49 = *(this + 250);
  if (v47 >= 0)
  {
    v50 = *(this + 2015);
  }

  else
  {
    v50 = *(this + 250);
  }

  v51 = mlir::ODIE::Compiler::CoreMLAX::convertToEnum(v48, v50);
  v52 = *(this + 1775);
  if (v52 < 0)
  {
    v52 = *(this + 220);
  }

  if (v52)
  {
    if (v46)
    {
      if ((v51 & 0x100000000) != 0)
      {
        data = v155[1].__r_.__value_.__l.__data_;
        v192 = 257;
        emitDiag(data, 1, &v191, __p);
        if (*__p)
        {
          mlir::Diagnostic::operator<<<75ul>(&__p[8], "found allocation type alongside parameter, allocation type will be ignored");
        }

        mlir::InFlightDiagnostic::~InFlightDiagnostic(__p);
      }

      if (*(this + 153) != *(this + 154))
      {
        v54 = v155[1].__r_.__value_.__l.__data_;
        v192 = 257;
        emitDiag(v54, 1, &v191, __p);
        if (*__p)
        {
          mlir::Diagnostic::operator<<<65ul>(&__p[8], "found alignments alongside parameter, alignments will be ignored");
        }

        mlir::InFlightDiagnostic::~InFlightDiagnostic(__p);
      }

      if (*(this + 186) != *(this + 187))
      {
        v55 = v155[1].__r_.__value_.__l.__data_;
        v192 = 257;
        emitDiag(v55, 1, &v191, __p);
        if (*__p)
        {
          mlir::Diagnostic::operator<<<65ul>(&__p[8], "found interleave alongside parameter, interleave will be ignored");
        }

        mlir::InFlightDiagnostic::~InFlightDiagnostic(__p);
      }

      goto LABEL_68;
    }

    v86 = v155[1].__r_.__value_.__l.__data_;
    v192 = 257;
    emitDiag(v86, 2, &v191, __p);
    if (*__p)
    {
      mlir::Diagnostic::operator<<<32ul>(&__p[8], "referring to invalid parameter ");
      if (*__p)
      {
        v192 = 260;
        v191.__r_.__value_.__r.__words[0] = this + 1752;
        mlir::Diagnostic::operator<<(&__p[8], &v191);
      }
    }

LABEL_99:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(__p);
    v84 = 0;
    v85 = 0;
    v83 = 0;
    goto LABEL_100;
  }

  if ((v51 & 0x100000000) == 0)
  {
    v56 = v155[1].__r_.__value_.__l.__data_;
    v192 = 257;
    emitDiag(v56, 2, &v191, __p);
    if (*__p)
    {
      mlir::Diagnostic::operator<<<25ul>(&__p[8], "invalid allocation type.");
    }

    goto LABEL_99;
  }

LABEL_68:
  v57 = *(this + 87);
  v58 = *(this + 88);
  if (v57 == v58)
  {
LABEL_81:
    v69 = *(this + 120);
    v70 = *(this + 121);
    if (v69 == v70)
    {
LABEL_94:
      v81 = *(**v147 + 32);
      *__p = v184 & 0xFFFFFFFFFFFFFFF9 | 2;
      *&__p[8] = v185;
      v191.__r_.__value_.__r.__words[0] = v179 & 0xFFFFFFFFFFFFFFF9 | 2;
      v191.__r_.__value_.__l.__size_ = v180;
      v82 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v81, __p, &v191);
      v83 = v82 & 0xFFFFFFFFFFFFFF00;
      v84 = v82;
      v85 = 1;
      goto LABEL_100;
    }

    while (1)
    {
      v71 = *v69;
      v154 = v71;
      v72 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
      v73 = v155[1].__r_.__value_.__l.__data_;
      llvm::to_string<long long>(&v191, &v154);
      v74 = std::string::insert(&v191, 0, "result ");
      v75 = v74->__r_.__value_.__r.__words[2];
      *__p = *&v74->__r_.__value_.__l.__data_;
      *&__p[16] = v75;
      v74->__r_.__value_.__l.__size_ = 0;
      v74->__r_.__value_.__r.__words[2] = 0;
      v74->__r_.__value_.__r.__words[0] = 0;
      if (__p[23] >= 0)
      {
        v76 = __p;
      }

      else
      {
        v76 = *__p;
      }

      if (__p[23] >= 0)
      {
        v77 = __p[23];
      }

      else
      {
        v77 = *&__p[8];
      }

      ForcedType = mlir::ODIE::Compiler::Transforms::createForcedType(v72, v73, v76, v77, *(v179 + v71), v46, *(this + 153), (*(this + 154) - *(this + 153)) >> 3, *(this + 186), (*(this + 187) - *(this + 186)) >> 3, v51);
      v80 = v79;
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*__p);
      }

      if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v191.__r_.__value_.__l.__data_);
      }

      if ((v80 & 1) == 0)
      {
        break;
      }

      *(v179 + v71) = ForcedType;
      if (++v69 == v70)
      {
        goto LABEL_94;
      }
    }
  }

  else
  {
    while (1)
    {
      v59 = *v57;
      v154 = v59;
      v60 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
      v61 = v155[1].__r_.__value_.__l.__data_;
      llvm::to_string<long long>(&v191, &v154);
      v62 = std::string::insert(&v191, 0, "operand ");
      v63 = v62->__r_.__value_.__r.__words[2];
      *__p = *&v62->__r_.__value_.__l.__data_;
      *&__p[16] = v63;
      v62->__r_.__value_.__l.__size_ = 0;
      v62->__r_.__value_.__r.__words[2] = 0;
      v62->__r_.__value_.__r.__words[0] = 0;
      if (__p[23] >= 0)
      {
        v64 = __p;
      }

      else
      {
        v64 = *__p;
      }

      if (__p[23] >= 0)
      {
        v65 = __p[23];
      }

      else
      {
        v65 = *&__p[8];
      }

      v66 = mlir::ODIE::Compiler::Transforms::createForcedType(v60, v61, v64, v65, *(v184 + 8 * v59), v46, *(this + 153), (*(this + 154) - *(this + 153)) >> 3, *(this + 186), (*(this + 187) - *(this + 186)) >> 3, v51);
      v68 = v67;
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*__p);
      }

      if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v191.__r_.__value_.__l.__data_);
      }

      if ((v68 & 1) == 0)
      {
        break;
      }

      *(v184 + 8 * v59) = v66;
      if (++v57 == v58)
      {
        goto LABEL_81;
      }
    }
  }

  v84 = 0;
  v85 = 0;
  v83 = 0;
LABEL_100:
  if (v176 != &v178)
  {
    free(v176);
  }

  if (v179 != &v181)
  {
    free(v179);
  }

  if (v184 != &v186)
  {
    free(v184);
  }

  if (v85)
  {
    v145 = v85;
    v87 = v83 | v84;
    v180 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
    v182 = 0;
    v183 = 0;
    v181 = 0;
    v179 = &unk_286E76228;
    v88 = *(v87 + 16);
    v89 = *(v87 + 8);
    v90 = v149;
    v154 = v149;
    v148 = v149 + 64;
    v91 = *(((v149 + 64 + 16 * ((*(v149 + 44) >> 23) & 1) + ((*(v149 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v149 + 40) + 8);
    v92 = (v91 - 8);
    if (!v91)
    {
      v92 = 0;
    }

    v94 = v92[5];
    v93 = v92[6];
    v182 = v92;
    v183 = v94;
    v152 = &v154;
    v95 = v92[7];
    v176 = &v153;
    v177 = &v152;
    *__p = &__p[16];
    *&__p[8] = 0x300000000;
    v146 = v87;
    if (v89 && v95 != v93)
    {
      v96 = v88 & 0xFFFFFFFFFFFFFFF9 | 2;
      v97 = (v95 - v93) >> 3;
      v98 = v93 & 0xFFFFFFFFFFFFFFF9;
      v99 = v89 - 1;
      if (v89 - 1 >= (v97 - 1))
      {
        v99 = v97 - 1;
      }

      v143 = v99 + 1;
      if (v99 < 3)
      {
        v100 = 0;
        v101 = &__p[16];
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(__p, &__p[16], v99 + 1, 16);
        v100 = *&__p[8];
        v101 = *__p;
      }

      v102 = 0;
      v103 = 0;
      v184 = v98;
      v185 = 0;
      v186 = v96;
      v187 = 0;
      v188 = &v176;
      v189 = &v179;
      v104 = &v101[16 * v100];
      LOBYTE(v190) = 1;
      do
      {
        v105 = mlir::ValueRange::dereference_iterator(&v184, v103);
        v106 = mlir::TypeRange::dereference_iterator(v186, v102);
        v107 = (*(v105 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v107 == v106)
        {
          v108 = 0;
        }

        else
        {
          v109 = v106;
          v110 = v189;
          v111 = **v188[1];
          (*(*v189 + 5))(v189, v111);
          *(v105 + 8) = *(v105 + 8) & 7 | v109;
          (*(*v110 + 48))(v110, v111);
          v112 = mlir::ODIE::Compiler::Transforms::materializeFromHardwareBackedTensorConversion(v110, v105, v107);
          if ((~*(v112 + 8) & 7) != 0)
          {
            v113 = v112;
          }

          else
          {
            v113 = 0;
          }

          if (v113)
          {
            v114 = *(v113 + 8) & 7;
            if (v114 == 6)
            {
              v113 += 24 * *(v113 + 16) + 120;
            }

            else
            {
              v113 += 16 * v114 + 16;
            }
          }

          v191.__r_.__value_.__r.__words[0] = v113;
          v155 = &v191;
          mlir::RewriterBase::replaceUsesWithIf(v110, v105, v112, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v155, 0);
          v108 = 1;
        }

        *v104 = 0;
        v104[8] = v108;
        v103 = v185 + 1;
        v102 = v187 + 1;
        v185 = v103;
        ++v187;
        v104 += 16;
      }

      while (v103 != v97 && v102 != v89);
      *&__p[8] += v143;
      v90 = v149;
      v87 = v146;
      if (*__p != &__p[16])
      {
        free(*__p);
      }
    }

    v182 = 0;
    v183 = 0;
    v116 = *(v87 + 16);
    v118 = *(v87 + 8);
    v117 = *(v87 + 12);
    v119 = *(((v148 + 16 * ((*(v90 + 44) >> 23) & 1) + ((*(v90 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v90 + 40) + 8);
    if (v119)
    {
      v120 = v119 - 8;
    }

    else
    {
      v120 = 0;
    }

    v121 = *(v120 + 32);
    v182 = *(v121 + 16);
    v183 = v121;
    if ((*(v121 + 46) & 0x80) != 0 && (v122 = *(v121 + 72), v123 = *(v121 + 68), *__p = &__p[16], *&__p[8] = 0x300000000, v117) && v123)
    {
      v124 = v116 + 8 * v118;
      v125 = v117 - 1;
      v126 = (v123 - 1) & 0x7FFFFFFFFFFFFFFLL;
      if (v117 - 1 < v126)
      {
        v126 = v117 - 1;
      }

      v144 = v126 + 1;
      if (v126 < 3)
      {
        v127 = 0;
        v128 = &__p[16];
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(__p, &__p[16], v126 + 1, 16);
        v127 = *&__p[8];
        v128 = *__p;
      }

      v129 = 0;
      v130 = v124 & 0xFFFFFFFFFFFFFFF9;
      v131 = &v128[16 * v127];
      v132 = 32 * v123 - 32;
      do
      {
        v133 = mlir::TypeRange::dereference_iterator(v130 | 2, v129);
        v134 = v122[3];
        if ((*(v134 + 8) & 0xFFFFFFFFFFFFFFF8) == v133)
        {
          v135 = 0;
        }

        else
        {
          v136 = mlir::ODIE::Compiler::Transforms::materializeToHardwareBackedTensorConversion(&v179, v134, v133);
          (*(v179 + 5))(&v179, v121);
          v137 = v122[1];
          if (v137)
          {
            v138 = *v122;
            *v137 = *v122;
            if (v138)
            {
              *(v138 + 8) = v122[1];
            }
          }

          v122[3] = v136;
          v122[1] = v136;
          v139 = *v136;
          *v122 = *v136;
          if (v139)
          {
            *(v139 + 8) = v122;
          }

          *v136 = v122;
          (*(v179 + 6))(&v179, v121);
          v135 = 1;
        }

        *v131 = 0;
        v131[8] = v135;
        if (!v132)
        {
          break;
        }

        v122 += 4;
        v131 += 16;
        v132 -= 32;
        v28 = v125 == v129++;
      }

      while (!v28);
      *&__p[8] += v144;
      if (*__p != &__p[16])
      {
        free(*__p);
      }
    }

    else
    {
      *&__p[8] = 0;
    }

    v182 = 0;
    v183 = 0;
    v182 = *(v149 + 16);
    v183 = v149;
    (*(v179 + 5))(&v179, v149);
    *(v148 + 16 * ((*(v149 + 44) >> 23) & 1) + 16) = mlir::TypeAttr::get(v146);
    (*(v179 + 6))(&v179, v149);
    mlir::ODIE::Compiler::Transforms::updateCallerSignatures(&v179, v149, v146);
    v85 = v145;
  }

  else
  {
    *(this + 5) |= 4uLL;
  }

  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v150);
  MEMORY[0x25F891030](v150[0], 8);
  if (v156 != v158)
  {
    free(v156);
  }

  if (v159 != v161)
  {
    free(v159);
  }

  if (v85)
  {
    v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
    v3 = *(v2 + 24);
    goto LABEL_168;
  }

LABEL_169:
  v142 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::ListOption<llvm::cl::desc>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  v10 = llvm::cl::Option::Option(a1, 1, 0);
  *(v10 + 168) = 0;
  *(v10 + 152) = 0u;
  *(v10 + 136) = 0u;
  *(v10 + 120) = 0u;
  *v10 = &unk_286EA4BC8;
  *(v10 + 184) = 0;
  *(v10 + 192) = 0;
  *(v10 + 176) = 0;
  *(v10 + 200) = &unk_286E79150;
  *(v10 + 208) = &unk_286EA4C30;
  *(v10 + 232) = v10 + 208;
  llvm::cl::Option::setArgStr(v10, a3, a4);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v12);
  *(a1 + 32) = *a5;
  llvm::cl::Option::addArgument(a1);
  *(a1 + 248) = 0;
  *a1 = &unk_286EA4B08;
  *(a1 + 240) = &unk_286EA4B88;
  *(a1 + 256) = &unk_286E79150;
  if ((*(a1 + 168) & 1) == 0)
  {
    *(a1 + 168) = 1;
  }

  v12[0] = a1 + 240;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100]((a2 + 160), v12);
  return a1;
}

BOOL mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::handleOccurrence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    *(a1 + 128) = *(a1 + 120);
    *(a1 + 168) = 0;
  }

  v11[4] = v6;
  v11[5] = v7;
  *(a1 + 248) = 1;
  v9 = a1;
  v10[0] = a1 + 256;
  v11[0] = a3;
  v11[1] = a4;
  v10[1] = a1;
  v10[2] = v11;
  v10[3] = &v9;
  return (mlir::detail::pass_options::parseCommaSeparatedList(a1, a3, a4, a5, a6, llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<unsigned int>,mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(unsigned int const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<unsigned int> &,mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(unsigned int const&)#1} &&)::{lambda(llvm::StringRef)#1}>, v10) & 1) == 0;
}

void mlir::Pass::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::list<unsigned int,BOOL,llvm::cl::parser<unsigned int>>::setDefault(void *a1)
{
  v2 = (a1 + 15);
  v1 = a1[15];
  a1[23] = a1[22];
  a1[16] = v1;
  v3 = a1[18];
  v4 = a1[19];
  while (v3 != v4)
  {
    std::vector<unsigned int>::push_back[abi:nn200100](v2, (v3 + 8));
    v3 += 16;
  }
}

llvm::raw_ostream *mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  v3 = result;
  if (*(result + 168) != 1)
  {
    goto LABEL_12;
  }

  v4 = *(result + 18);
  v5 = *(result + 19) - v4;
  v6 = v5 >> 4;
  v7 = *(result + 15);
  if (v5 >> 4 != (*(result + 16) - v7) >> 2)
  {
    goto LABEL_12;
  }

  if ((v5 & 0xFFFFFFFF0) != 0)
  {
    v8 = 0;
    v9 = (v5 >> 4);
    v10 = (v4 + 12);
    while (*v10 == 1 && *(v10 - 1) == *(v7 + 4 * v8))
    {
      ++v8;
      v10 += 16;
      if (v9 == v8)
      {
        LODWORD(v8) = v6;
        break;
      }
    }

    v11 = v8;
  }

  else
  {
    v11 = 0;
  }

  if (v6 != v11)
  {
LABEL_12:
    result = llvm::raw_ostream::operator<<(this, *(result + 2), *(result + 3));
    v12 = *(result + 4);
    if (*(result + 3) - v12 > 1uLL)
    {
      *v12 = 31549;
      *(result + 4) += 2;
    }

    else
    {
      result = llvm::raw_ostream::write(result, "={", 2uLL);
    }

    v13 = *(v3 + 15);
    v14 = *(v3 + 16);
    if (v13 != v14)
    {
      v16 = *v13;
      v15 = v13 + 1;
      for (result = write_unsigned<unsigned long long>(this, v16, 0, 0, 0); v15 != v14; result = write_unsigned<unsigned long long>(this, v18, 0, 0, 0))
      {
        v17 = *(this + 4);
        if (*(this + 3) == v17)
        {
          llvm::raw_ostream::write(this, ",", 1uLL);
        }

        else
        {
          *v17 = 44;
          ++*(this + 4);
        }

        v18 = *v15++;
      }
    }

    v19 = *(this + 4);
    if (*(this + 3) == v19)
    {

      return llvm::raw_ostream::write(this, "}", 1uLL);
    }

    else
    {
      *v19 = 125;
      ++*(this + 4);
    }
  }

  return result;
}

void *mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::vector<unsigned int>::__assign_with_size[abi:nn200100]<unsigned int const*,unsigned int const*>((a1 + 120), *(a2 - 120), *(a2 - 112), (*(a2 - 112) - *(a2 - 120)) >> 2);
  *(a1 + 248) = 1;
  *(a1 + 248) = *(a2 + 8);
  return result;
}

void non-virtual thunk tomlir::Pass::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

void *non-virtual thunk tomlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::vector<unsigned int>::__assign_with_size[abi:nn200100]<unsigned int const*,unsigned int const*>((a1 - 120), *(a2 - 120), *(a2 - 112), (*(a2 - 112) - *(a2 - 120)) >> 2);
  *(a1 + 8) = 1;
  *(a1 + 8) = *(a2 + 8);
  return result;
}

void mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

{
  *a1 = &unk_286EA4BC8;
  std::__function::__value_func<void ()(unsigned int const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::list<unsigned int,BOOL,llvm::cl::parser<unsigned int>>::handleOccurrence(uint64_t a1, int a2, uint64_t a3, unint64_t *a4, unint64_t a5, unint64_t a6)
{
  v6 = a2;
  v12 = 0;
  v13 = a2;
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    *(a1 + 128) = *(a1 + 120);
    *(a1 + 168) = 0;
  }

  v8 = llvm::cl::parser<unsigned int>::parse(a1 + 200, a1, a3, a4, a5, a6, &v12);
  if (v8)
  {
    return v8;
  }

  std::vector<unsigned int>::push_back[abi:nn200100]((a1 + 120), &v12);
  *(a1 + 12) = v6;
  std::vector<unsigned int>::push_back[abi:nn200100]((a1 + 176), &v13);
  v9 = *(a1 + 232);
  if (v9)
  {
    (*(*v9 + 48))(v9, &v12);
    return v8;
  }

  v11 = std::__throw_bad_function_call[abi:nn200100]();
  return llvm::cl::list<unsigned int,BOOL,llvm::cl::parser<unsigned int>>::~list(v11);
}

void llvm::cl::list<unsigned int,BOOL,llvm::cl::parser<unsigned int>>::~list(uint64_t a1)
{
  *a1 = &unk_286EA4BC8;
  std::__function::__value_func<void ()(unsigned int const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA4BC8;
  std::__function::__value_func<void ()(unsigned int const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<unsigned int>,mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(unsigned int const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<unsigned int> &,mlir::detail::PassOptions::ListOption<unsigned int,llvm::cl::parser<unsigned int>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(unsigned int const&)#1} &&)::{lambda(llvm::StringRef)#1}>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  v6 = 0;
  v4 = llvm::cl::parser<unsigned int>::parse(*a1, *(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8), a2, a3, &v6);
  result = 0;
  if ((v4 & 1) == 0)
  {
    std::vector<unsigned int>::push_back[abi:nn200100]((**(a1 + 24) + 120), &v6);
    return 1;
  }

  return result;
}

void *std::vector<unsigned int>::__assign_with_size[abi:nn200100]<unsigned int const*,unsigned int const*>(void *result, char *__src, char *a3, unint64_t a4)
{
  v6 = result;
  v7 = result[2];
  v8 = *result;
  if (a4 > (v7 - *result) >> 2)
  {
    if (v8)
    {
      result[1] = v8;
      operator delete(v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }

    if (!(a4 >> 62))
    {
      v9 = v7 >> 1;
      if (v7 >> 1 <= a4)
      {
        v9 = a4;
      }

      if (v7 >= 0x7FFFFFFFFFFFFFFCLL)
      {
        v10 = 0x3FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v10 = v9;
      }

      std::vector<unsigned int>::__vallocate[abi:nn200100](v6, v10);
    }

    std::vector<unsigned int>::__throw_length_error[abi:nn200100]();
  }

  v11 = result[1];
  v12 = v11 - v8;
  if (a4 <= (v11 - v8) >> 2)
  {
    v18 = a3 - __src;
    if (v18)
    {
      result = memmove(*result, __src, v18);
    }

    v17 = &v8[v18];
  }

  else
  {
    v13 = &__src[v12];
    if (v11 != v8)
    {
      result = memmove(*result, __src, v12);
      v11 = v6[1];
    }

    v14 = v11;
    if (v13 != a3)
    {
      v14 = v11;
      v15 = v11;
      do
      {
        v16 = *v13;
        v13 += 4;
        *v15 = v16;
        v15 += 4;
        v14 += 4;
      }

      while (v13 != a3);
    }

    v17 = v14;
  }

  v6[1] = v17;
  return result;
}

uint64_t mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::ListOption<llvm::cl::desc>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  v10 = llvm::cl::Option::Option(a1, 1, 0);
  *(v10 + 168) = 0;
  *(v10 + 152) = 0u;
  *(v10 + 136) = 0u;
  *(v10 + 120) = 0u;
  *v10 = &unk_286EA4DF8;
  *(v10 + 184) = 0;
  *(v10 + 192) = 0;
  *(v10 + 176) = 0;
  *(v10 + 200) = &unk_286E79120;
  *(v10 + 208) = &unk_286EA4E60;
  *(v10 + 232) = v10 + 208;
  llvm::cl::Option::setArgStr(v10, a3, a4);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v12);
  *(a1 + 32) = *a5;
  llvm::cl::Option::addArgument(a1);
  *(a1 + 248) = 0;
  *a1 = &unk_286EA4D38;
  *(a1 + 240) = &unk_286EA4DB8;
  *(a1 + 256) = &unk_286E79120;
  if ((*(a1 + 168) & 1) == 0)
  {
    *(a1 + 168) = 1;
  }

  v12[0] = a1 + 240;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100]((a2 + 160), v12);
  return a1;
}

BOOL mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::handleOccurrence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    *(a1 + 128) = *(a1 + 120);
    *(a1 + 168) = 0;
  }

  v11[4] = v6;
  v11[5] = v7;
  *(a1 + 248) = 1;
  v9 = a1;
  v10[0] = a1 + 256;
  v11[0] = a3;
  v11[1] = a4;
  v10[1] = a1;
  v10[2] = v11;
  v10[3] = &v9;
  return (mlir::detail::pass_options::parseCommaSeparatedList(a1, a3, a4, a5, a6, llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<long long>,mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(long long const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<long long> &,mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(long long const&)#1} &&)::{lambda(llvm::StringRef)#1}>, v10) & 1) == 0;
}

void mlir::Pass::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::list<long long,BOOL,llvm::cl::parser<long long>>::setDefault(void *a1)
{
  v2 = (a1 + 15);
  v1 = a1[15];
  a1[23] = a1[22];
  a1[16] = v1;
  v3 = a1[18];
  v4 = a1[19];
  while (v3 != v4)
  {
    llvm::cl::list_storage<long long,BOOL>::addValue<long long>(v2, (v3 + 8));
    v3 += 24;
  }
}

llvm::raw_ostream *mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  v3 = result;
  if (*(result + 168) != 1)
  {
    goto LABEL_12;
  }

  v4 = *(result + 18);
  v5 = 0xAAAAAAAAAAAAAAABLL * ((*(result + 19) - v4) >> 3);
  v6 = *(result + 15);
  if (v5 != (*(result + 16) - v6) >> 3)
  {
    goto LABEL_12;
  }

  if (v5)
  {
    v7 = 0;
    v8 = (v4 + 16);
    while (*v8 == 1 && *(v8 - 1) == *(v6 + 8 * v7))
    {
      ++v7;
      v8 += 24;
      if (v5 == v7)
      {
        LODWORD(v7) = v5;
        break;
      }
    }

    v9 = v7;
  }

  else
  {
    v9 = 0;
  }

  if (v5 != v9)
  {
LABEL_12:
    result = llvm::raw_ostream::operator<<(this, *(result + 2), *(result + 3));
    v10 = *(result + 4);
    if (*(result + 3) - v10 > 1uLL)
    {
      *v10 = 31549;
      *(result + 4) += 2;
    }

    else
    {
      result = llvm::raw_ostream::write(result, "={", 2uLL);
    }

    v11 = *(v3 + 15);
    v12 = *(v3 + 16);
    if (v11 != v12)
    {
      v14 = *v11;
      v13 = v11 + 1;
      for (result = llvm::write_integer(this, v14, 0, 0); v13 != v12; result = llvm::write_integer(this, v16, 0, 0))
      {
        v15 = *(this + 4);
        if (*(this + 3) == v15)
        {
          llvm::raw_ostream::write(this, ",", 1uLL);
        }

        else
        {
          *v15 = 44;
          ++*(this + 4);
        }

        v16 = *v13++;
      }
    }

    v17 = *(this + 4);
    if (*(this + 3) == v17)
    {

      return llvm::raw_ostream::write(this, "}", 1uLL);
    }

    else
    {
      *v17 = 125;
      ++*(this + 4);
    }
  }

  return result;
}

void *mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::vector<long long>::__assign_with_size[abi:nn200100]<long long const*,long long const*>((a1 + 120), *(a2 - 120), *(a2 - 112), (*(a2 - 112) - *(a2 - 120)) >> 3);
  *(a1 + 248) = 1;
  *(a1 + 248) = *(a2 + 8);
  return result;
}

void non-virtual thunk tomlir::Pass::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

void *non-virtual thunk tomlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::vector<long long>::__assign_with_size[abi:nn200100]<long long const*,long long const*>((a1 - 120), *(a2 - 120), *(a2 - 112), (*(a2 - 112) - *(a2 - 120)) >> 3);
  *(a1 + 8) = 1;
  *(a1 + 8) = *(a2 + 8);
  return result;
}

void mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

{
  *a1 = &unk_286EA4DF8;
  std::__function::__value_func<void ()(long long const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::list<long long,BOOL,llvm::cl::parser<long long>>::handleOccurrence(uint64_t a1, int a2, uint64_t a3, unint64_t *a4, unint64_t a5, unint64_t a6)
{
  v6 = a2;
  v13 = a2;
  v12 = 0;
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    *(a1 + 128) = *(a1 + 120);
    *(a1 + 168) = 0;
  }

  v8 = llvm::cl::parser<long long>::parse(a1 + 200, a1, a3, a4, a5, a6, &v12);
  if (v8)
  {
    return v8;
  }

  llvm::cl::list_storage<long long,BOOL>::addValue<long long>((a1 + 120), &v12);
  *(a1 + 12) = v6;
  std::vector<unsigned int>::push_back[abi:nn200100]((a1 + 176), &v13);
  v9 = *(a1 + 232);
  if (v9)
  {
    (*(*v9 + 48))(v9, &v12);
    return v8;
  }

  v11 = std::__throw_bad_function_call[abi:nn200100]();
  return llvm::cl::list<long long,BOOL,llvm::cl::parser<long long>>::~list(v11);
}

void llvm::cl::list<long long,BOOL,llvm::cl::parser<long long>>::~list(uint64_t a1)
{
  *a1 = &unk_286EA4DF8;
  std::__function::__value_func<void ()(long long const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA4DF8;
  std::__function::__value_func<void ()(long long const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = *(a1 + 120);
  if (v4)
  {
    *(a1 + 128) = v4;
    operator delete(v4);
  }

  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::list_storage<long long,BOOL>::addValue<long long>(const void **a1, void *a2)
{
  v5 = a1[1];
  v4 = a1[2];
  if (v5 >= v4)
  {
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = (v8 >> 3) + 1;
    if (v9 >> 61)
    {
      std::vector<long long>::__throw_length_error[abi:nn200100]();
    }

    v10 = v4 - v7;
    if (v10 >> 2 > v9)
    {
      v9 = v10 >> 2;
    }

    v11 = v10 >= 0x7FFFFFFFFFFFFFF8;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11)
    {
      v12 = v9;
    }

    if (v12)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<long long>>(a1, v12);
    }

    v13 = (8 * (v8 >> 3));
    *v13 = *a2;
    v6 = v13 + 1;
    memcpy(0, v7, v8);
    v14 = *a1;
    *a1 = 0;
    a1[1] = v6;
    a1[2] = 0;
    if (v14)
    {
      operator delete(v14);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }

  a1[1] = v6;
}

uint64_t llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<long long>,mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(long long const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<long long> &,mlir::detail::PassOptions::ListOption<long long,llvm::cl::parser<long long>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(long long const&)#1} &&)::{lambda(llvm::StringRef)#1}>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  v5 = 0;
  if (llvm::cl::parser<long long>::parse(*a1, *(a1 + 8), **(a1 + 16), *(*(a1 + 16) + 8), a2, a3, &v5))
  {
    return 0;
  }

  llvm::cl::list_storage<long long,BOOL>::addValue<long long>((**(a1 + 24) + 120), &v5);
  return 1;
}

void *std::vector<long long>::__assign_with_size[abi:nn200100]<long long const*,long long const*>(void *result, char *__src, char *a3, unint64_t a4)
{
  v6 = result;
  v7 = result[2];
  v8 = *result;
  if (a4 > (v7 - *result) >> 3)
  {
    if (v8)
    {
      result[1] = v8;
      operator delete(v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }

    if (!(a4 >> 61))
    {
      v9 = v7 >> 2;
      if (v7 >> 2 <= a4)
      {
        v9 = a4;
      }

      if (v7 >= 0x7FFFFFFFFFFFFFF8)
      {
        v10 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v10 = v9;
      }

      std::vector<long long>::__vallocate[abi:nn200100](v6, v10);
    }

    std::vector<long long>::__throw_length_error[abi:nn200100]();
  }

  v11 = result[1];
  v12 = v11 - v8;
  if (a4 <= (v11 - v8) >> 3)
  {
    v18 = a3 - __src;
    if (v18)
    {
      result = memmove(*result, __src, v18);
    }

    v17 = &v8[v18];
  }

  else
  {
    v13 = &__src[v12];
    if (v11 != v8)
    {
      result = memmove(*result, __src, v12);
      v11 = v6[1];
    }

    v14 = v11;
    if (v13 != a3)
    {
      v14 = v11;
      v15 = v11;
      do
      {
        v16 = *v13;
        v13 += 8;
        *v15 = v16;
        v15 += 8;
        v14 += 8;
      }

      while (v13 != a3);
    }

    v17 = v14;
  }

  v6[1] = v17;
  return result;
}

void mlir::ODIE::Compiler::Transforms::updateCallerSignatures(uint64_t a1, mlir::SymbolTable *this, uint64_t a3)
{
  v4 = this;
  v58[8] = *MEMORY[0x277D85DE8];
  while (1)
  {
    v6 = *(this + 2);
    if (!v6)
    {
      break;
    }

    v7 = *(v6 + 24) & 0xFFFFFFFFFFFFFFF8;
    if (!v7)
    {
      break;
    }

    this = *(v7 + 16);
    if (!this || *(*(this + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
    {
      goto LABEL_8;
    }
  }

  this = 0;
LABEL_8:
  mlir::SymbolTable::getSymbolUses(v4, this, &v38);
  if (v40 == 1)
  {
    v9 = v38;
    v8 = v39;
    if (v38 == v39)
    {
      goto LABEL_47;
    }

    v10 = &v50;
    v11 = &v47;
    v36 = v39;
    do
    {
      v12 = *v9;
      if (*v9)
      {
        v13 = *(*(*v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id;
      }

      else
      {
        v13 = 0;
      }

      if (v13)
      {
        v41 = *v9;
        if ((*(v12 + 46) & 0x80) != 0)
        {
          v14 = *(v12 + 68);
          v15 = *(v12 + 72);
        }

        else
        {
          v15 = 0;
          v14 = 0;
        }

        v16 = v10;
        v48 = v10;
        v49 = 0x600000000;
        llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v48, v15, 0, v15, v14);
        v17 = *(v41 + 36);
        if (v17)
        {
          v18 = v41 - 16;
        }

        else
        {
          v18 = 0;
        }

        v19 = v11;
        v45 = v11;
        v46 = 0x600000000;
        llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator,void>(&v45, v18, 0, v18, v17);
        v37 = *(a1 + 24);
        v20 = v41;
        *(a1 + 24) = *(v41 + 16);
        *(a1 + 32) = v20;
        mlir::ODIE::Compiler::Transforms::materializeConversions<mlir::Value,mlir::ValueRange,mlir::Value (&)(mlir::RewriterBase &,mlir::Value,mlir::Type)>(&v42, a1, mlir::ODIE::Compiler::Transforms::materializeToHardwareBackedTensorConversion, v48 & 0xFFFFFFFFFFFFFFF9, v49, *(a3 + 16) & 0xFFFFFFFFFFFFFFF9 | 2, *(a3 + 8));
        v21 = *(v41 + 24);
        CalleeAttr = mlir::ODIE::Compiler::CoreML::InvokeOp::getCalleeAttr(&v41);
        v24 = v23;
        v25 = *(a3 + 12);
        v26 = *(a3 + 16) + 8 * *(a3 + 8);
        v27 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::InvokeOp>(a1 + 8, *(**v21 + 32));
        v51 = v21;
        v52 = v27;
        v53[0] = v54;
        v53[1] = 0x400000000;
        v54[4] = v55;
        v54[5] = 0x400000000;
        v55[4] = v56;
        v55[5] = 0x400000000;
        v56[8] = 4;
        v56[9] = v57;
        v56[10] = 0x100000000;
        v57[1] = v58;
        v57[2] = 0x100000000;
        v58[1] = 0;
        v58[2] = 0;
        v58[3] = &mlir::detail::TypeIDResolver<void,void>::id;
        v58[4] = 0;
        v58[6] = 0;
        mlir::ODIE::Compiler::CoreML::InvokeOp::build(a1 + 8, &v51, CalleeAttr, v24, v26 & 0xFFFFFFFFFFFFFFF9 | 2, v25, v42 & 0xFFFFFFFFFFFFFFF9, v43);
        v28 = mlir::Operation::create(&v51);
        mlir::OpBuilder::insert((a1 + 8), v28);
        v29 = *(*(v28 + 6) + 16);
        mlir::OperationState::~OperationState(&v51);
        if (v29 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
        {
          v30 = v28;
        }

        else
        {
          v30 = 0;
        }

        v31 = *(v30 + 9);
        v32 = (v30 - 16) & 0xFFFFFFFFFFFFFFF9 | 4;
        if (v31)
        {
          v33 = v32;
        }

        else
        {
          v33 = 4;
        }

        if (v46)
        {
          v34 = v45 & 0xFFFFFFFFFFFFFFF8;
        }

        else
        {
          v34 = 0;
        }

        mlir::ODIE::Compiler::Transforms::materializeConversions<mlir::Value,mlir::ValueRange,mlir::Value (&)(mlir::RewriterBase &,mlir::Value,mlir::Type)>(&v51, a1, mlir::ODIE::Compiler::Transforms::materializeFromHardwareBackedTensorConversion, v33, v31, v34, v46);
        (**a1)(a1, v41, v51 & 0xFFFFFFFFFFFFFFF9, v52);
        if (v51 != v53)
        {
          free(v51);
        }

        if (v42 != &v44)
        {
          free(v42);
        }

        v10 = v16;
        v11 = v19;
        if (v37)
        {
          *(a1 + 24) = v37;
        }

        else
        {
          *(a1 + 24) = 0;
          *(a1 + 32) = 0;
        }

        if (v45 != v19)
        {
          free(v45);
        }

        if (v48 != v16)
        {
          free(v48);
        }

        v8 = v36;
      }

      v9 += 16;
    }

    while (v9 != v8);
    if (v40)
    {
      v9 = v38;
LABEL_47:
      if (v9)
      {
        v39 = v9;
        operator delete(v9);
      }
    }
  }

  v35 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::Compiler::Transforms::createForcedType(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t *a6, void *a7, uint64_t a8, void *a9, uint64_t a10, int a11)
{
  v36[24] = *MEMORY[0x277D85DE8];
  if (*(*a5 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v15 = a6;
    if (!a6)
    {
      v20 = a5[2];
      v34 = v36;
      v35 = 0x600000000;
      llvm::SmallVectorImpl<long long>::assign(&v34, v20 + 1, 1);
      v21 = (a8 ? a7 : v34);
      v22 = a8 ? a8 : v35;
      v23 = a10 ? a9 : v34;
      v24 = a10 ? a10 : v35 - 1;
      v25 = a5[4];
      if (v25)
      {
        v26 = *(*v25 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TensorEncodingAttr,void>::id ? a5[4] : 0;
      }

      else
      {
        v26 = 0;
      }

      v15 = mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsAttr::get(a1, v21, v22, v23, v24, a11, v26);
      if (v34 != v36)
      {
        free(v34);
      }
    }

    v27 = a5[1];
    v28 = a5[2];
    v29 = a5[3];
    v34 = a2;
    v36[1] = &llvm::detail::UniqueFunctionBase<mlir::InFlightDiagnostic>::CallbacksHolder<mlir::detail::getDefaultDiagnosticEmitFn(mlir::Location const&)::$_0,mlir::detail::getDefaultDiagnosticEmitFn(mlir::Location const&)::$_0,void>::Callbacks + 2;
    v14 = mlir::detail::StorageUserBase<mlir::RankedTensorType,mlir::TensorType,mlir::detail::RankedTensorTypeStorage,mlir::detail::TypeUniquer,mlir::ShapedType::Trait,mlir::ValueSemantics>::getChecked<llvm::ArrayRef<long long>,mlir::Type,mlir::Attribute>(llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<llvm::unique_function<mlir::InFlightDiagnostic ()(void)>>, &v34, *(**v29 + 32), v27, v28, v29, v15);
    llvm::detail::UniqueFunctionBase<mlir::InFlightDiagnostic>::~UniqueFunctionBase(&v34);
  }

  else
  {
    v33 = 257;
    emitDiag(a2, 2, v32, &v34);
    if (v34)
    {
      v33 = 261;
      v32[0] = a3;
      v32[1] = a4;
      mlir::Diagnostic::operator<<(&v35, v32);
      if (v34)
      {
        mlir::Diagnostic::operator<<<25ul>(&v35, " is not a ranked tensor.");
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v34);
    v14 = 0;
  }

  v30 = *MEMORY[0x277D85DE8];
  return v14;
}

void llvm::to_string<long long>(void *a1, unint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = 0;
  v8 = 0;
  v9 = 1;
  v6 = 0;
  v7 = 0;
  v5 = 0;
  v3 = &unk_286E79D28;
  v10 = a1;
  llvm::raw_ostream::SetUnbuffered(&v3);
  llvm::write_integer(&v3, *a2, 0, 0);
  llvm::raw_ostream::~raw_ostream(&v3);
}

uint64_t llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<llvm::unique_function<mlir::InFlightDiagnostic ()(void)>>(void *a1)
{
  v1 = a1[3];
  if ((v1 & 2) == 0)
  {
    a1 = *a1;
  }

  return (*(v1 & 0xFFFFFFFFFFFFFFF8))(a1);
}

uint64_t mlir::ODIE::Compiler::Transforms::materializeFromHardwareBackedTensorConversion(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a2;
  v38[8] = *MEMORY[0x277D85DE8];
  v31 = a3;
  v32 = a2;
  v6 = *(a2 + 8);
  if (*(*(v6 & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v7 = *((v6 & 0xFFFFFFFFFFFFFFF8) + 32);
    if (v7)
    {
      v8 = (*v7)[17];
      if (v8 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamRefAttr,void>::id)
      {
        v9 = *(*v7[2] + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsType,void>::id;
      }

      else
      {
        v9 = v8 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsAttr,void>::id;
      }

      LODWORD(v7) = v9;
    }
  }

  else
  {
    LODWORD(v7) = 0;
  }

  v10 = *(*a3 + 136);
  if (v10 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v17 = a3[4];
    if (v17)
    {
      v18 = (*v17)[17];
      v19 = v18 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamRefAttr,void>::id ? *(*v17[2] + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsType,void>::id : v18 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsAttr,void>::id;
      v24 = v19;
      if ((v7 & v24) == 1)
      {
        if ((~v6 & 7) != 0)
        {
          v25 = a2;
        }

        else
        {
          v25 = 0;
        }

        if (!v25)
        {
          goto LABEL_45;
        }

        v26 = *(v25 + 8) & 7;
        if (v26 == 6)
        {
          v27 = v25 + 24 * *(v25 + 16) + 120;
          if (!v27)
          {
LABEL_45:
            v28 = (a2 + 32);
LABEL_48:
            v23 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::CastOp,mlir::Type &,mlir::Value &>((a1 + 8), *v28, &v31, &v32);
LABEL_49:
            if (*(v23 + 9))
            {
              v4 = (v23 - 16);
            }

            else
            {
              v4 = 0;
            }

            goto LABEL_52;
          }
        }

        else
        {
          v27 = v25 + 16 * v26 + 16;
        }

        v28 = (v27 + 24);
        goto LABEL_48;
      }
    }
  }

  if (v10 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v10 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v12 = v7;
  }

  else
  {
    v12 = 0;
  }

  if (v12 == 1)
  {
    if ((~v6 & 7) != 0)
    {
      v13 = a2;
    }

    else
    {
      v13 = 0;
    }

    if (!v13)
    {
      goto LABEL_24;
    }

    v14 = *(v13 + 8) & 7;
    if (v14 == 6)
    {
      v15 = v13 + 24 * *(v13 + 16) + 120;
      if (!v15)
      {
LABEL_24:
        v16 = a2 + 32;
LABEL_30:
        v20 = *v16;
        v21 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp>(a1 + 8, *(***v16 + 32));
        v33[0] = v20;
        v33[1] = v21;
        v33[2] = v34;
        v33[3] = 0x400000000;
        v34[4] = v35;
        v34[5] = 0x400000000;
        v35[4] = v36;
        v35[5] = 0x400000000;
        v36[8] = 4;
        v36[9] = v37;
        v36[10] = 0x100000000;
        v37[1] = v38;
        v37[2] = 0x100000000;
        v38[1] = 0;
        v38[2] = 0;
        v38[3] = &mlir::detail::TypeIDResolver<void,void>::id;
        v38[4] = 0;
        v38[6] = 0;
        mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp::build(a1 + 8, v33, a3, v4);
        v22 = mlir::Operation::create(v33);
        mlir::OpBuilder::insert((a1 + 8), v22);
        if (*(*(v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp,void>::id)
        {
          v23 = v22;
        }

        else
        {
          v23 = 0;
        }

        mlir::OperationState::~OperationState(v33);
        goto LABEL_49;
      }
    }

    else
    {
      v15 = v13 + 16 * v14 + 16;
    }

    v16 = v15 + 24;
    goto LABEL_30;
  }

LABEL_52:
  v29 = *MEMORY[0x277D85DE8];
  return v4;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::CastOp,mlir::Type &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreMLAX::CastOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreMLAX::CastOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CastOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

uint64_t mlir::ODIE::Compiler::Transforms::materializeToHardwareBackedTensorConversion(uint64_t a1, uint64_t a2, void *a3)
{
  v4 = a2;
  v38[8] = *MEMORY[0x277D85DE8];
  v31 = a3;
  v32 = a2;
  v6 = *(a2 + 8);
  v7 = *(*(v6 & 0xFFFFFFFFFFFFFFF8) + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v8 = *((v6 & 0xFFFFFFFFFFFFFFF8) + 32);
    if (v8)
    {
      v9 = (*v8)[17];
      if (v9 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamRefAttr,void>::id)
      {
        v10 = *(*v8[2] + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsType,void>::id;
      }

      else
      {
        v10 = v9 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsAttr,void>::id;
      }

      LODWORD(v8) = v10;
    }
  }

  else
  {
    LODWORD(v8) = 0;
  }

  if (*(*a3 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v11 = a3[4];
    if (v11)
    {
      v12 = (*v11)[17];
      if (v12 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamRefAttr,void>::id)
      {
        v13 = *(*v11[2] + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsType,void>::id;
      }

      else
      {
        v13 = v12 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::HardwareConstraintsAttr,void>::id;
      }

      v14 = v13;
      if ((v8 & v14) == 1)
      {
        if ((~v6 & 7) != 0)
        {
          v15 = a2;
        }

        else
        {
          v15 = 0;
        }

        if (!v15)
        {
          goto LABEL_25;
        }

        v16 = *(v15 + 8) & 7;
        if (v16 == 6)
        {
          v17 = v15 + 24 * *(v15 + 16) + 120;
          if (!v17)
          {
LABEL_25:
            v18 = (a2 + 32);
LABEL_42:
            v25 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreMLAX::CastOp,mlir::Type &,mlir::Value &>((a1 + 8), *v18, &v31, &v32);
LABEL_49:
            if (*(v25 + 9))
            {
              v4 = (v25 - 16);
            }

            else
            {
              v4 = 0;
            }

            goto LABEL_52;
          }
        }

        else
        {
          v17 = v15 + 16 * v16 + 16;
        }

        v18 = (v17 + 24);
        goto LABEL_42;
      }

      v19 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
      v20 = v19;
      if ((v20 & v14) == 1)
      {
        if ((~v6 & 7) != 0)
        {
          v21 = a2;
        }

        else
        {
          v21 = 0;
        }

        if (!v21)
        {
          goto LABEL_39;
        }

        v22 = *(v21 + 8) & 7;
        if (v22 == 6)
        {
          v23 = v21 + 24 * *(v21 + 16) + 120;
          if (!v23)
          {
LABEL_39:
            v24 = a2 + 32;
LABEL_45:
            v26 = *v24;
            v27 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp>(a1 + 8, *(***v24 + 32));
            v33[0] = v26;
            v33[1] = v27;
            v33[2] = v34;
            v33[3] = 0x400000000;
            v34[4] = v35;
            v34[5] = 0x400000000;
            v35[4] = v36;
            v35[5] = 0x400000000;
            v36[8] = 4;
            v36[9] = v37;
            v36[10] = 0x100000000;
            v37[1] = v38;
            v37[2] = 0x100000000;
            v38[1] = 0;
            v38[2] = 0;
            v38[3] = &mlir::detail::TypeIDResolver<void,void>::id;
            v38[4] = 0;
            v38[6] = 0;
            mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp::build(a1 + 8, v33, a3, v4);
            v28 = mlir::Operation::create(v33);
            mlir::OpBuilder::insert((a1 + 8), v28);
            if (*(*(v28 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id)
            {
              v25 = v28;
            }

            else
            {
              v25 = 0;
            }

            mlir::OperationState::~OperationState(v33);
            goto LABEL_49;
          }
        }

        else
        {
          v23 = v21 + 16 * v22 + 16;
        }

        v24 = v23 + 24;
        goto LABEL_45;
      }
    }
  }

LABEL_52:
  v29 = *MEMORY[0x277D85DE8];
  return v4;
}

void *mlir::ODIE::Compiler::Transforms::materializeConversions<mlir::Value,mlir::ValueRange,mlir::Value (&)(mlir::RewriterBase &,mlir::Value,mlir::Type)>(void *result, uint64_t a2, uint64_t (*a3)(void, void, void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v8 = result;
  v32 = *MEMORY[0x277D85DE8];
  v9 = (result + 2);
  *result = result + 2;
  result[1] = 0x600000000;
  if (a5 && a7)
  {
    v13 = a7 - 1;
    v14 = a5 - 1;
    if (a7 - 1 >= (a5 - 1))
    {
      v15 = a5 - 1;
    }

    else
    {
      v15 = a7 - 1;
    }

    v16 = v15 + 1;
    if (v15 < 6)
    {
      v17 = 0;
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(result, v9, v15 + 1, 8);
      v17 = *(v8 + 2);
      v9 = *v8;
    }

    v19 = 0;
    v25 = a4;
    v26 = 0;
    v27 = a6;
    v28 = 0;
    v29 = a3;
    v30 = a2;
    v20 = &v9[8 * v17];
    v31 = 1;
    do
    {
      v21 = mlir::ValueRange::dereference_iterator(&v25, v19);
      v22 = mlir::TypeRange::dereference_iterator(a6, v19);
      result = a3(a2, v21, v22);
      *&v20[8 * v19] = result;
      v26 = v19 + 1;
      v28 = v19 + 1;
      if (v14 == v19)
      {
        break;
      }
    }

    while (v13 != v19++);
    v18 = *(v8 + 2) + v16;
  }

  else
  {
    v18 = 0;
  }

  *(v8 + 2) = v18;
  v24 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteIOTypesPattern::~PromoteIOTypesPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PromoteIOTypesPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteIOTypesPattern::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  v48 = *MEMORY[0x277D85DE8];
  v5 = (a3 + 24);
  v6 = *(a3 + 24);
  v7 = (((&a2[4 * ((a2[11] >> 23) & 1) + 17] + ((a2[11] >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * a2[10]);
  if (*v7 == v7)
  {
    v35 = 0;
    v36 = 0;
    v37 = 1;
  }

  else
  {
    v45 = (a3 + 24);
    v8 = v7[1];
    if (v8)
    {
      v9 = (v8 - 8);
    }

    else
    {
      v9 = 0;
    }

    v10 = v9[6];
    v11 = v9[7];
    v41 = v11 - v10;
    v43 = a2 + 16;
    v44 = *(a3 + 24);
    if (v11 != v10)
    {
      v12 = v9[6];
      v13 = v12;
      do
      {
        v14 = **v13;
        if (v14 && !*v14)
        {
          v15 = v14[2];
          if (v15 && *(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id)
          {
            v17 = *(*(*v13 + 16) + 24) & 0xFFFFFFFFFFFFFFF8;
            if (v17)
            {
              v18 = *(v17 + 16);
            }

            else
            {
              v18 = 0;
            }

            (*(*a3 + 40))(a3, v18);
            if (*(v15 + 36))
            {
              v19 = v15 - 16;
            }

            else
            {
              v19 = 0;
            }

            *(*v13 + 8) = *(v19 + 8) & 0xFFFFFFFFFFFFFFF8 | *(*v13 + 8) & 7;
            (*(*a3 + 48))(a3, v18);
            v20 = *(*v13 + 16);
            v21 = *(v20 + 40);
            *(a3 + 24) = v20;
            *(a3 + 32) = v21;
            (**a3)(a3, v15, v12, 1);
          }
        }

        v13 += 8;
        v12 += 8;
      }

      while (v13 != v11);
    }

    v22 = v41 >> 3;
    v23 = v9[4];
    if ((*(v23 + 46) & 0x80) != 0)
    {
      v24 = *(v23 + 72);
      v25 = *(v23 + 68);
      if (!v25)
      {
        goto LABEL_36;
      }

      v42 = v41 >> 3;
      v26 = 32 * v25;
      v27 = (v24 + 24);
      while (1)
      {
        v28 = *v27;
        if ((~*(*v27 + 8) & 7) == 0)
        {
          v28 = 0;
        }

        if (!v28)
        {
          goto LABEL_34;
        }

        v29 = *(v28 + 8) & 7;
        if (v29 != 6)
        {
          break;
        }

        v30 = v28 + 24 * *(v28 + 16);
        v31 = v30 + 120;
        if (v30 != -120)
        {
          goto LABEL_32;
        }

LABEL_34:
        v27 += 4;
        v26 -= 32;
        if (!v26)
        {
          v22 = v42;
          goto LABEL_36;
        }
      }

      v31 = v28 + 16 * v29 + 16;
LABEL_32:
      if (*(*(v31 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp,void>::id)
      {
        *&v47 = *(*(v31 + 72) + 24);
        (**a3)(a3);
      }

      goto LABEL_34;
    }

    v24 = 0;
    v25 = 0;
LABEL_36:
    v32 = v10 & 0xFFFFFFFFFFFFFFF8;
    if (v11 == v10)
    {
      v32 = 0;
    }

    v33 = *(***(*&v43[4 * ((a2[11] >> 23) & 1) + 4] + 8) + 32);
    *&v47 = v32;
    *(&v47 + 1) = v22;
    *&v46 = v24 & 0xFFFFFFFFFFFFFFF9 | 4;
    *(&v46 + 1) = v25;
    v34 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v33, &v47, &v46);
    if (v34 == *(*&v43[4 * ((a2[11] >> 23) & 1) + 4] + 8))
    {
      v35 = 0;
      v36 = 0;
      v37 = 1;
    }

    else
    {
      v38 = v34;
      (*(*a3 + 40))(a3, a2);
      *&v43[4 * ((a2[11] >> 23) & 1) + 4] = mlir::TypeAttr::get(v38);
      (*(*a3 + 48))(a3, a2);
      v37 = 0;
      v36 = v38 & 0xFFFFFFFFFFFFFF00;
      v35 = v38;
    }

    v5 = v45;
    v6 = v44;
  }

  if (!v6)
  {
    *v5 = 0;
    v5[1] = 0;
    if (v37)
    {
      goto LABEL_45;
    }

LABEL_47:
    mlir::ODIE::Compiler::Transforms::updateCallerSignatures(a3, a2, v36 | v35);
    result = 1;
    goto LABEL_48;
  }

  *v5 = v6;
  if ((v37 & 1) == 0)
  {
    goto LABEL_47;
  }

LABEL_45:
  result = 0;
LABEL_48:
  v40 = *MEMORY[0x277D85DE8];
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PromoteIOTypesPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PromoteIOTypesPattern]";
  v6 = 140;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FuseCopyOrCastIntoInterpreterRegion::~FuseCopyOrCastIntoInterpreterRegion(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FuseCopyOrCastIntoInterpreterRegion *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FuseCopyOrCastIntoInterpreterRegion::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v5 = a2 + 64;
  v6 = *(a2 + 44);
  v7 = (v6 >> 23) & 1;
  v8 = *(a2 + 64 + 16 * v7 + 8);
  if (*(v8 + 24) == 11)
  {
    v9 = *(v8 + 16);
    v10 = *v9;
    v11 = *(v9 + 3);
    if (v10 == 0x6572707265746E49 && v11 == 0x7265746572707265)
    {
      if ((v6 & 0x800000) != 0 && (v15 = *(a2 + 68), v15))
      {
        v16 = 0;
        v17 = *(a2 + 72);
        v18 = 32 * v15;
        v19 = v17;
        do
        {
          v20 = v19[3];
          if ((~*(v20 + 8) & 7) != 0)
          {
            v21 = v19[3];
          }

          else
          {
            v21 = 0;
          }

          if (v21)
          {
            v22 = *(v21 + 8) & 7;
            if (v22 == 6)
            {
              v23 = (v21 + 24 * *(v21 + 16) + 120);
            }

            else
            {
              v23 = (v21 + 16 * v22 + 16);
            }
          }

          else
          {
            v23 = 0;
          }

          v24 = *v20;
          if (v24 && v23 && !*v24)
          {
            v25 = *(v23[6] + 16);
            v26 = v25 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CastOp,void>::id || v25 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id;
            if (v26 || v25 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp,void>::id)
            {
              v28 = *(((v5 + 16 * ((*(a2 + 44) >> 23) & 1) + ((*(a2 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40) + 8);
              if (v28)
              {
                v29 = v28 - 8;
              }

              else
              {
                v29 = 0;
              }

              mlir::RewriterBase::moveOpBefore(a3, v23, v29, *(v29 + 40));
              (*(*a3 + 40))(a3, a2);
              v30 = *(v23[9] + 24);
              v31 = v19[1];
              if (v31)
              {
                v32 = *v19;
                *v31 = *v19;
                if (v32)
                {
                  *(v32 + 8) = v19[1];
                }
              }

              v19[3] = v30;
              v19[1] = v30;
              v33 = *v30;
              *v19 = *v30;
              if (v33)
              {
                *(v33 + 8) = v19;
              }

              *v30 = v19;
              v34 = *(((v5 + 16 * ((*(a2 + 44) >> 23) & 1) + ((*(a2 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40) + 8);
              if (v34)
              {
                v35 = v34 - 8;
              }

              else
              {
                v35 = 0;
              }

              v36 = v19[2];
              if ((*(v36 + 46) & 0x80) != 0)
              {
                v37 = *(v36 + 72);
              }

              else
              {
                v37 = 0;
              }

              v38 = *(*(v35 + 48) + 8 * ((v17 - v37) >> 5));
              *(v38 + 8) = *(v19[3] + 8) & 0xFFFFFFFFFFFFFFF8 | *(v38 + 8) & 7;
              v39 = v23[9];
              v40 = v39[1];
              if (v40)
              {
                v41 = *v39;
                *v40 = *v39;
                if (v41)
                {
                  *(v41 + 8) = v39[1];
                }
              }

              v39[3] = v38;
              v39[1] = v38;
              v42 = *v38;
              *v39 = *v38;
              if (v42)
              {
                v42[1] = v39;
              }

              *v38 = v39;
              v71[0] = v23;
              v73 = v71;
              mlir::RewriterBase::replaceUsesWithIf(a3, v38, v23 - 2, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v73, 0);
              (*(*a3 + 48))(a3, a2);
              v16 = 1;
            }
          }

          v19 += 4;
          v17 += 4;
          v18 -= 32;
        }

        while (v18);
        v6 = *(a2 + 44);
        v7 = (v6 >> 23) & 1;
      }

      else
      {
        v16 = 0;
      }

      v43 = *(a2 + 36);
      v44 = *(((v5 + 16 * v7 + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40) + 8);
      if (v44)
      {
        v45 = v44 - 8;
      }

      else
      {
        v45 = 0;
      }

      if (v43)
      {
        v46 = (a2 - 16);
      }

      else
      {
        v46 = 0;
      }

      if (!v43)
      {
        return v16 & 1;
      }

      v47 = 0;
      v48 = *(v45 + 32);
      for (i = v46; ; i -= 2)
      {
        v50 = v46;
        if (v47)
        {
          v51 = *(a2 - 8) & 7;
          v52 = (a2 - 16);
          v53 = v47;
          if (v51 == 6)
          {
            goto LABEL_68;
          }

          v54 = (5 - v51);
          v50 = i;
          v53 = v47 - v54;
          if (v47 > v54)
          {
            break;
          }
        }

LABEL_69:
        v55 = *(*v50 + 16);
        if (v55)
        {
          v56 = **v50 == 0;
        }

        else
        {
          v56 = 0;
        }

        if (v56)
        {
          v57 = *(*(v55 + 48) + 16);
          v58 = v57 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CastOp,void>::id || v57 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyWithConstraintsOp,void>::id;
          if (v58 || v57 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreMLAX::CopyDiscardingConstraintsOp,void>::id)
          {
            mlir::RewriterBase::moveOpBefore(a3, *(*v50 + 16), v48[2], v48);
            (*(*a3 + 40))(a3, a2);
            v60 = v50[1] & 7;
            if (v60 == 6)
            {
              v60 = (*(v50 + 4) + 6);
            }

            v61 = v48[9];
            v62 = *(v61 + 32 * v60 + 24);
            v63 = (v61 + 32 * v60);
            v64 = v63[1];
            if (v64)
            {
              v65 = *v63;
              *v64 = *v63;
              if (v65)
              {
                *(v65 + 8) = v63[1];
              }
            }

            v63[3] = v55 - 16;
            v63[1] = v55 - 16;
            v66 = *(v55 - 16);
            *v63 = v66;
            if (v66)
            {
              *(v66 + 8) = v63;
            }

            *(v55 - 16) = v63;
            v50[1] = *(v55 - 8) & 0xFFFFFFFFFFFFFFF8 | v50[1] & 7;
            v67 = *(v55 + 72);
            v68 = v67[1];
            if (v68)
            {
              v69 = *v67;
              *v68 = *v67;
              if (v69)
              {
                *(v69 + 8) = v67[1];
              }
            }

            v67[3] = v62;
            v67[1] = v62;
            v70 = *v62;
            *v67 = *v62;
            if (v70)
            {
              *(v70 + 8) = v67;
            }

            *v62 = v67;
            v71[0] = v48;
            v73 = v71;
            mlir::RewriterBase::replaceUsesWithIf(a3, (v55 - 16), v50, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v73, 0);
            (*(*a3 + 48))(a3, a2);
            v16 = 1;
          }
        }

        if (v43 == ++v47)
        {
          return v16 & 1;
        }
      }

      v52 = &v46[-2 * v54];
LABEL_68:
      v50 = &v52[-3 * v53];
      goto LABEL_69;
    }
  }

  v71[0] = "not tagged for interpreter";
  v72 = 259;
  v73 = v71;
  v13 = a3[2];
  if (v13)
  {
    if (v13[2] == 1)
    {
      (*(*v13 + 88))(v13, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp &>(mlir::ODIE::Compiler::CoreML::IsolatedGroupOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v73);
    }
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FuseCopyOrCastIntoInterpreterRegion>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FuseCopyOrCastIntoInterpreterRegion]";
  v6 = 154;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveSymbolicTypesPass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveSymbolicTypesPass::~RemoveSymbolicTypesPass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::RemoveSymbolicTypesPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveSymbolicTypesPass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::RemoveSymbolicTypesPass *this)
{
  v10 = *MEMORY[0x277D85DE8];
  v6 = 0;
  v5 = 0u;
  memset(v4, 0, sizeof(v4));
  v7 = &unk_286EA4FC8;
  v8 = 0;
  v9 = &v7;
  std::vector<std::function<std::optional<std::pair<mlir::Type,mlir::WalkResult>> ()(mlir::Type)>>::push_back[abi:nn200100](&v4[1] + 1, &v7);
  std::__function::__value_func<std::optional<std::pair<mlir::Type,mlir::WalkResult>> ()(mlir::Type)>::~__value_func[abi:nn200100](&v7);
  v2 = *(this + 5);
  mlir::detail::AttrTypeReplacerBase<mlir::AttrTypeReplacer>::recursivelyReplaceElementsIn(v4, v2 & 0xFFFFFFFFFFFFFFF8, 1, 0, 1);
  mlir::Operation::removeAttr(v2 & 0xFFFFFFFFFFFFFFF8, "TorchImport.RangeConstraints", 0x1C);
  MEMORY[0x25F891030](v5, 8);
  v7 = &v4[1] + 1;
  std::vector<std::function<std::optional<std::pair<mlir::Type,mlir::WalkResult>> ()(mlir::Type)>>::__destroy_vector::operator()[abi:nn200100](&v7);
  v7 = v4;
  std::vector<std::function<std::optional<std::pair<mlir::Attribute,mlir::WalkResult>> ()(mlir::Attribute)>>::__destroy_vector::operator()[abi:nn200100](&v7);
  v3 = *MEMORY[0x277D85DE8];
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZNS2_4ODIE8Compiler10Transforms12_GLOBAL__N_123RemoveSymbolicTypesPass14runOnOperationEvE3__0NS2_16RankedTensorTypeENS2_4TypeESE_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISI_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSF_E_NS_9allocatorIST_EEFNSK_INSL_ISF_SM_EEEESF_EE7__cloneEPNS0_6__baseISY_EE(uint64_t result, uint64_t a2)
{
  *a2 = &unk_286EA4FC8;
  *(a2 + 8) = *(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZNS2_4ODIE8Compiler10Transforms12_GLOBAL__N_123RemoveSymbolicTypesPass14runOnOperationEvE3__0NS2_16RankedTensorTypeENS2_4TypeESE_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISI_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSF_E_NS_9allocatorIST_EEFNSK_INSL_ISF_SM_EEEESF_EEclEOSF_@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  result = *a1;
  if (*(**a1 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = *(result + 32);
    if (v5 && *(*v5 + 136) == &mlir::detail::TypeIDResolver<mlir::AffineMapAttr,void>::id)
    {
      v6 = *(result + 24);
      v9 = *(result + 8);
      v7 = 0;
      v8 = v6;
      result = mlir::detail::TypeUniquer::get<mlir::RankedTensorType,llvm::ArrayRef<long long> &,mlir::Type &,mlir::Attribute &>(*(**v6 + 32), &v9, &v8, &v7);
    }

    *a2 = result;
    v4 = 1;
    *(a2 + 8) = 1;
  }

  else
  {
    v4 = 0;
    *a2 = 0;
  }

  *(a2 + 16) = v4;
  return result;
}

void mlir::ODIE::Compiler::Transforms::createResolveImports(uint64_t a1)
{
  v2[6] = *MEMORY[0x277D85DE8];
  v1[0] = v2;
  v1[1] = 0x200000000;
  if (*(a1 + 8))
  {
    llvm::SmallVectorImpl<std::string>::operator=(v1, a1);
  }

  mlir::ODIE::Compiler::Transforms::impl::createResolveImports();
}

void resolveImportFile(mlir::Location,std::__fs::filesystem::path,llvm::ArrayRef<std::__fs::filesystem::path>,llvm::ArrayRef<llvm::StringRef>)::$_0::operator()(std::string *a1, uint64_t *a2, uint64_t a3)
{
  v26 = *MEMORY[0x277D85DE8];
  memset(&v22, 0, sizeof(v22));
  __ec.__val_ = 0;
  v6 = std::system_category();
  __ec.__cat_ = v6;
  v7 = *a2;
  if (*(*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v20, *v7, *(v7 + 1));
  }

  else
  {
    v8 = *v7;
    v20.__r_.__value_.__r.__words[2] = *(v7 + 2);
    *&v20.__r_.__value_.__l.__data_ = v8;
  }

  v9 = a2[1];
  v10 = v9[1];
  if (v10)
  {
    v11 = *v9;
    v12 = 16 * v10;
    while (1)
    {
      v19 = *v11;
      llvm::StringRef::str(&v19, &__p);
      __replacement = __p;
      memset(&__p, 0, sizeof(__p));
      std::__fs::filesystem::path::replace_extension(&v20, &__replacement);
      if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__pn_.__r_.__value_.__l.__data_);
      }

      std::__fs::filesystem::operator/[abi:nn200100](&v20, a3, &__replacement);
      std::__fs::filesystem::__status(&__replacement, &__ec);
      v13 = __p.__pn_.__r_.__value_.__s.__data_[0];
      if (__p.__pn_.__r_.__value_.__s.__data_[0])
      {
        __ec.__val_ = 0;
        __ec.__cat_ = v6;
      }

      if (SHIBYTE(__replacement.__pn_.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__replacement.__pn_.__r_.__value_.__l.__data_);
        if (v13)
        {
LABEL_16:
          if (v13 != 255)
          {
            std::__fs::filesystem::operator/[abi:nn200100](&v20, a3, &__replacement);
            if (SHIBYTE(v22.__pn_.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v22.__pn_.__r_.__value_.__l.__data_);
            }

            v22 = __replacement;
            if (__ec.__val_)
            {
              v16 = *a2[2];
              v24 = 257;
              emitDiag(v16, 1, &__p, &__replacement);
              if (__replacement.__pn_.__r_.__value_.__r.__words[0])
              {
                mlir::Diagnostic::operator<<<16ul>(&__replacement.__pn_.__r_.__value_.__l.__size_, "while checking ");
                if (__replacement.__pn_.__r_.__value_.__r.__words[0])
                {
                  mlir::Diagnostic::appendRange<std::__fs::filesystem::path>(&__replacement.__pn_.__r_.__value_.__l.__size_, &v22, ", ");
                  if (__replacement.__pn_.__r_.__value_.__r.__words[0])
                  {
                    mlir::Diagnostic::operator<<<17ul>(&__replacement.__pn_.__r_.__value_.__l.__size_, " for existence: ");
                  }
                }
              }

              std::error_code::message(&v18, &__ec);
              if (__replacement.__pn_.__r_.__value_.__r.__words[0])
              {
                v24 = 260;
                __p.__pn_.__r_.__value_.__r.__words[0] = &v18;
                mlir::Diagnostic::operator<<(&__replacement.__pn_.__r_.__value_.__l.__size_, &__p);
              }

              a1->__r_.__value_.__s.__data_[0] = 0;
              a1[1].__r_.__value_.__s.__data_[0] = 0;
              if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v18.__r_.__value_.__l.__data_);
              }

              goto LABEL_45;
            }
          }
        }
      }

      else if (__p.__pn_.__r_.__value_.__s.__data_[0])
      {
        goto LABEL_16;
      }

      ++v11;
      v12 -= 16;
      if (!v12)
      {
        if (*(a2[1] + 8))
        {
          goto LABEL_26;
        }

        break;
      }
    }
  }

  if (std::__fs::filesystem::path::__extension(*a2).__size_)
  {
    std::__fs::filesystem::operator/[abi:nn200100](*a2, a3, &__replacement);
    if (SHIBYTE(v22.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v22.__pn_.__r_.__value_.__l.__data_);
    }

    v22 = __replacement;
  }

LABEL_26:
  size = HIBYTE(v22.__pn_.__r_.__value_.__r.__words[2]);
  if ((v22.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    size = v22.__pn_.__r_.__value_.__l.__size_;
  }

  if (size)
  {
    std::__fs::filesystem::__status(&v22, &__ec);
    if ((__replacement.__pn_.__r_.__value_.__r.__words[0] & 0x10000000000) != 0)
    {
      if (SHIBYTE(v22.__pn_.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(a1, v22.__pn_.__r_.__value_.__l.__data_, v22.__pn_.__r_.__value_.__l.__size_);
      }

      else
      {
        *a1 = v22;
      }

      a1[1].__r_.__value_.__s.__data_[0] = 1;
    }

    else
    {
      v15 = *a2[2];
      v24 = 257;
      emitDiag(v15, 1, &__p, &__replacement);
      if (__replacement.__pn_.__r_.__value_.__r.__words[0])
      {
        mlir::Diagnostic::appendRange<std::__fs::filesystem::path>(&__replacement.__pn_.__r_.__value_.__l.__size_, &v22, ", ");
        if (__replacement.__pn_.__r_.__value_.__r.__words[0])
        {
          mlir::Diagnostic::operator<<<30ul>(&__replacement.__pn_.__r_.__value_.__l.__size_, " is not readable by this user");
        }
      }

      a1->__r_.__value_.__s.__data_[0] = 0;
      a1[1].__r_.__value_.__s.__data_[0] = 0;
LABEL_45:
      mlir::InFlightDiagnostic::~InFlightDiagnostic(&__replacement);
    }
  }

  else
  {
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[1].__r_.__value_.__s.__data_[0] = 0;
  }

  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v22.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v22.__pn_.__r_.__value_.__l.__data_);
  }

  v17 = *MEMORY[0x277D85DE8];
}

double std::__fs::filesystem::path::parent_path[abi:nn200100]@<D0>(const std::__fs::filesystem::path *a1@<X0>, uint64_t a2@<X8>)
{
  v3 = std::__fs::filesystem::path::__parent_path(a1);
  if (v3.__size_ >= 0x7FFFFFFFFFFFFFF8)
  {
    std::string::__throw_length_error[abi:nn200100]();
  }

  if (v3.__size_ >= 0x17)
  {
    operator new();
  }

  HIBYTE(v6) = v3.__size_;
  if (v3.__size_)
  {
    memmove(&__dst, v3.__data_, v3.__size_);
  }

  *(&__dst + v3.__size_) = 0;
  result = *&__dst;
  *a2 = __dst;
  *(a2 + 16) = v6;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEE3__0NS2_13SymbolRefAttrENS2_9AttributeESF_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISJ_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSG_E_NS_9allocatorISU_EEFNSL_INSM_ISG_SN_EEEESG_EE7__cloneEPNS0_6__baseISZ_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA5010;
  a2[1] = v2;
  return result;
}

void _ZNSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEE3__0NS2_13SymbolRefAttrENS2_9AttributeESF_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISJ_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSG_E_NS_9allocatorISU_EEFNSL_INSM_ISG_SN_EEEESG_EEclEOSG_(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  v14[6] = *MEMORY[0x277D85DE8];
  v4 = *a2;
  if (*(**a2 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
  {
    v6 = *(**(a1 + 8) + 16 * ((*(**(a1 + 8) + 44) >> 23) & 1) + 72);
    v7 = *(**(a1 + 8) + 16 * ((*(**(a1 + 8) + 44) >> 23) & 1) + 80);
    if (v7[1] != v6 && *(v4 + 8) == v6)
    {
      v8 = v7[2];
      v9 = &v8[8 * v7[3]];
      v12 = v14;
      v13 = 0x600000000;
      llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::append<mlir::FlatSymbolRefAttr const*,void>(&v12, v8, v9);
      llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::append<mlir::FlatSymbolRefAttr const*,void>(&v12, *(v4 + 16), (*(v4 + 16) + 8 * *(v4 + 24)));
      v4 = mlir::SymbolRefAttr::get(v7[1], v12, v13, v10);
      if (v12 != v14)
      {
        free(v12);
      }
    }

    *a3 = v4;
    v5 = 1;
    *(a3 + 8) = 1;
  }

  else
  {
    v5 = 0;
    *a3 = 0;
  }

  *(a3 + 16) = v5;
  v11 = *MEMORY[0x277D85DE8];
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<readBytecodeImport(mlir::ODIE::Compiler::CoreML::ImportOp,llvm::MemoryBufferRef)::$_1>(uint64_t a1, mlir::Operation *a2)
{
  v11 = *MEMORY[0x277D85DE8];
  v5 = a2;
  mlir::detail::AttrTypeReplacerBase<mlir::AttrTypeReplacer>::replaceElementsIn(*a1, a2, 1, 0, 1);
  mlir::Operation::getAttrDictionary(a2);
  v4 = *(a1 + 8);
  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  operator new();
}

__n128 _ZNKSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIZZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEENK3__1clEPNS2_9OperationEEUlNS2_13SymbolRefAttrEE_SE_NS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSG_E_NS_9allocatorISP_EEFNS2_10WalkResultESG_EE7__cloneEPNS0_6__baseIST_EE(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_286EA5058;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIZZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEENK3__1clEPNS2_9OperationEEUlNS2_13SymbolRefAttrEE_SE_NS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSG_E_NS_9allocatorISP_EEFNS2_10WalkResultESG_EEclEOSG_(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  if (*(**a2 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
  {
    v6 = *a2;
    if (isSymbolExpectedInImport(v3, **(a1 + 8)))
    {
      v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::operator[](*(a1 + 16), &v6);
      if (*(v4 + 8) <= 9u)
      {
        llvm::SmallVectorTemplateBase<mlir::Location,true>::push_back(v4, *(**(a1 + 24) + 24));
      }
    }
  }

  return 1;
}

BOOL isSymbolExpectedInImport(void *a1, uint64_t a2)
{
  v2 = a2 + 16 * ((*(a2 + 44) >> 23) & 1);
  v3 = a1[1];
  if (v3 == *(v2 + 72))
  {
    return 1;
  }

  v4 = *(v2 + 80);
  if (v4[1] != v3)
  {
    return 0;
  }

  v5 = v4[3];
  if (a1[3] < v5)
  {
    return 0;
  }

  if (!v5)
  {
    return 1;
  }

  v7 = a1[2];
  v8 = v4[2];
  v9 = 8 * v5 - 8;
  do
  {
    v11 = *v7++;
    v10 = v11;
    v12 = *v8++;
    result = v12 == v10;
    v13 = v12 != v10 || v9 == 0;
    v9 -= 8;
  }

  while (!v13);
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::operator[](uint64_t a1, uint64_t *a2)
{
  v10 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::LookupBucketFor<mlir::SymbolRefAttr>(*a1, *(a1 + 16), *a2, &v10);
  v5 = v10;
  if (v4)
  {
    return v5 + 8;
  }

  v11 = v10;
  v6 = *(a1 + 8);
  v7 = *(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }

  if (v7 + ~v6 - *(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::grow(a1, v7);
    llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::LookupBucketFor<mlir::SymbolRefAttr>(*a1, *(a1 + 16), *a2, &v11);
    v6 = *(a1 + 8);
    v5 = v11;
  }

  *(a1 + 8) = v6 + 1;
  if (*v5 != -4096)
  {
    --*(a1 + 12);
  }

  v8 = *a2;
  *(v5 + 40) = 0u;
  *(v5 + 56) = 0u;
  *(v5 + 72) = 0u;
  *(v5 + 24) = 0u;
  *(v5 + 88) = 0u;
  *v5 = v8;
  *(v5 + 8) = v5 + 24;
  *(v5 + 16) = 0xA00000000;
  return v5 + 8;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::LookupBucketFor<mlir::SymbolRefAttr>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 104 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 104 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

void *llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((104 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = 104 * v10 - 104;
      v13 = vdupq_n_s64(v12 / 0x68);
      do
      {
        v14 = vmovn_s64(vcgeq_u64(v13, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v14.i8[0])
        {
          *result = -4096;
        }

        if (v14.i8[4])
        {
          result[13] = -4096;
        }

        v11 += 2;
        result += 26;
      }

      while (((v12 / 0x68 + 2) & 0x7FFFFFFFFFFFFFELL) != v11);
    }

    if (v3)
    {
      v15 = (v4 + 24);
      v16 = 104 * v3;
      do
      {
        v17 = *(v15 - 3);
        if ((v17 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v26 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::LookupBucketFor<mlir::SymbolRefAttr>(*a1, *(a1 + 16), v17, &v26);
          v18 = v26;
          *v26 = *(v15 - 3);
          v18[2] = 0xA00000000;
          v18[1] = v18 + 3;
          v19 = (v18 + 1);
          if (*(v15 - 2))
          {
            llvm::SmallVectorImpl<mlir::Location>::operator=(v19, (v15 - 2));
          }

          ++*(a1 + 8);
          v20 = *(v15 - 2);
          if (v15 != v20)
          {
            free(v20);
          }
        }

        v15 += 13;
        v16 -= 104;
      }

      while (v16);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v21 = *(a1 + 16);
  if (v21)
  {
    v22 = 0;
    v23 = 104 * v21 - 104;
    v24 = vdupq_n_s64(v23 / 0x68);
    do
    {
      v25 = vmovn_s64(vcgeq_u64(v24, vorrq_s8(vdupq_n_s64(v22), xmmword_25D0A0500)));
      if (v25.i8[0])
      {
        *result = -4096;
      }

      if (v25.i8[4])
      {
        result[13] = -4096;
      }

      v22 += 2;
      result += 26;
    }

    while (((v23 / 0x68 + 2) & 0x7FFFFFFFFFFFFFELL) != v22);
  }

  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIZZZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEENK3__1clEPNS2_9OperationEENKUlNS2_5ValueEE_clESE_EUlNS2_13SymbolRefAttrEE_SG_NS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSI_E_NS_9allocatorISR_EEFNS2_10WalkResultESI_EE7__cloneEPNS0_6__baseISV_EE(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_286EA50A0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIZZZL18readBytecodeImportNS2_4ODIE8Compiler6CoreML8ImportOpEN4llvm15MemoryBufferRefEENK3__1clEPNS2_9OperationEENKUlNS2_5ValueEE_clESE_EUlNS2_13SymbolRefAttrEE_SG_NS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSI_E_NS_9allocatorISR_EEFNS2_10WalkResultESI_EEclEOSI_(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  if (*(**a2 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
  {
    v11 = *a2;
    if (isSymbolExpectedInImport(v3, **(a1 + 8)))
    {
      v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::operator[](*(a1 + 16), &v11);
      if (*(v4 + 8) <= 9u)
      {
        v5 = **(a1 + 24);
        if ((~*(v5 + 8) & 7) != 0)
        {
          v6 = **(a1 + 24);
        }

        else
        {
          v6 = 0;
        }

        if (!v6)
        {
          goto LABEL_10;
        }

        v7 = *(v6 + 8) & 7;
        if (v7 == 6)
        {
          v8 = v6 + 24 * *(v6 + 16) + 120;
          if (!v8)
          {
LABEL_10:
            v9 = (v5 + 32);
LABEL_13:
            llvm::SmallVectorTemplateBase<mlir::Location,true>::push_back(v4, *v9);
            return 1;
          }
        }

        else
        {
          v8 = v6 + 16 * v7 + 16;
        }

        v9 = (v8 + 24);
        goto LABEL_13;
      }
    }
  }

  return 1;
}

double _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZL18readBytecodeImportNS1_4ODIE8Compiler6CoreML8ImportOpENS_15MemoryBufferRefEE3__4NS1_17SymbolOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, mlir::SymbolOpInterface *a2)
{
  v3 = llvm::DefaultDoCastIfPossible<mlir::SymbolOpInterface,mlir::Operation *,llvm::CastInfo<mlir::SymbolOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2, a2);
  if (v3)
  {
    v6 = *a1;
    v7.n128_u64[0] = v3;
    v7.n128_u64[1] = v4;
    if (*(*(v3 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
    {
      *&result = std::deque<mlir::SymbolOpInterface>::push_back(*v6, &v7).n128_u64[0];
    }
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>,mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::LookupBucketFor<mlir::SymbolOpInterface>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 24 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 24 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>,mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::InsertIntoBucketImpl<mlir::SymbolOpInterface>(uint64_t a1, uint64_t *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>,mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::LookupBucketFor<mlir::SymbolOpInterface>(*a1, *(a1 + 16), *a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

_OWORD *llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((24 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 24 * v10;
      do
      {
        *result = xmmword_25D0A0570;
        result = (result + 24);
        v11 -= 24;
      }

      while (v11);
    }

    if (v3)
    {
      v12 = 24 * v3;
      v13 = v4;
      do
      {
        v14 = *v13;
        if ((*v13 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v18 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>,mlir::SymbolOpInterface,unsigned int,llvm::DenseMapInfo<mlir::SymbolOpInterface,void>,llvm::detail::DenseMapPair<mlir::SymbolOpInterface,unsigned int>>::LookupBucketFor<mlir::SymbolOpInterface>(*a1, *(a1 + 16), v14, &v18);
          v15 = v18;
          *v18 = *v13;
          *(v15 + 4) = *(v13 + 16);
          ++*(a1 + 8);
        }

        v13 += 24;
        v12 -= 24;
      }

      while (v12);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v16 = *(a1 + 16);
  if (v16)
  {
    v17 = 24 * v16;
    do
    {
      *result = xmmword_25D0A0570;
      result = (result + 24);
      v17 -= 24;
    }

    while (v17);
  }

  return result;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::SymbolOpInterface,llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>>,false>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<mlir::SymbolOpInterface const&>,std::tuple<llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>&>>(uint64_t a1, _OWORD **a2, uint64_t *a3)
{
  v12 = 0;
  v6 = a1 + 16;
  v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (a1 + 16), 0, 80, &v12);
  v8 = &v7[80 * *(a1 + 8)];
  v9 = *a3;
  *v8 = **a2;
  *(v8 + 3) = 0x600000000;
  *(v8 + 2) = v8 + 32;
  v10 = (v8 + 16);
  if (*(v9 + 8))
  {
    llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::operator=(v10, v9);
  }

  llvm::SmallVectorTemplateBase<std::pair<mlir::SymbolOpInterface,llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>>,false>::moveElementsForGrow(a1, v7);
  v11 = v12;
  if (*a1 != v6)
  {
    free(*a1);
  }

  *a1 = v7;
  ++*(a1 + 8);
  *(a1 + 12) = v11;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::SymbolOpInterface,llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>>,false>::moveElementsForGrow(uint64_t *a1, uint64_t a2)
{
  v2 = *(a1 + 2);
  if (v2)
  {
    v4 = *a1;
    v5 = *a1 + 80 * v2;
    v6 = (a2 + 16);
    v7 = v4 + 16;
    do
    {
      *(v6 - 1) = *(v7 - 16);
      *v6 = v6 + 2;
      v6[1] = 0x600000000;
      if (*(v7 + 8))
      {
        v6 = llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::operator=(v6, v7);
      }

      v8 = v7 - 16;
      v6 += 10;
      v7 += 80;
    }

    while (v8 + 80 != v5);
    v9 = *(a1 + 2);
    if (v9)
    {
      v10 = (*a1 + 80 * v9 - 64);
      v11 = -80 * v9;
      do
      {
        if (v10 + 2 != *v10)
        {
          free(*v10);
        }

        v10 -= 10;
        v11 += 80;
      }

      while (v11);
    }
  }
}

uint64_t llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v5 = (a2 + 16);
    v4 = *a2;
    if (v4 != v5)
    {
      v6 = *a1;
      if (*a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }

      *a1 = v4;
      v7 = (a2 + 8);
      *(a1 + 8) = *(a2 + 8);
      *a2 = v5;
      *(a2 + 12) = 0;
      goto LABEL_17;
    }

    v7 = (a2 + 8);
    v8 = *(a2 + 8);
    v9 = *(a1 + 8);
    if (v9 >= v8)
    {
      if (v8)
      {
        memmove(*a1, v4, 8 * v8);
      }

      goto LABEL_16;
    }

    if (*(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*a1, v4, 8 * v9);
        goto LABEL_14;
      }
    }

    else
    {
      *(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v8, 8);
    }

    v9 = 0;
LABEL_14:
    v10 = *v7 - v9;
    if (v10)
    {
      memcpy((*a1 + 8 * v9), (*a2 + 8 * v9), 8 * v10);
    }

LABEL_16:
    *(a1 + 8) = v8;
LABEL_17:
    *v7 = 0;
  }

  return a1;
}

{
  if (a1 != a2)
  {
    v4 = *(a2 + 8);
    v5 = *(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        memmove(*a1, *a2, 8 * v4);
      }

      goto LABEL_12;
    }

    if (*(a1 + 12) >= v4)
    {
      if (v5)
      {
        memmove(*a1, *a2, 8 * v5);
        goto LABEL_10;
      }
    }

    else
    {
      *(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4, 8);
    }

    v5 = 0;
LABEL_10:
    v6 = *(a2 + 8) - v5;
    if (v6)
    {
      memcpy((*a1 + 8 * v5), (*a2 + 8 * v5), 8 * v6);
    }

LABEL_12:
    *(a1 + 8) = v4;
  }

  return a1;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::SymbolOpInterface,llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>>,false>::grow(uint64_t a1, unint64_t a2)
{
  v6 = 0;
  v3 = a1 + 16;
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (a1 + 16), a2, 80, &v6);
  llvm::SmallVectorTemplateBase<std::pair<mlir::SymbolOpInterface,llvm::SmallVector<mlir::FlatSymbolRefAttr,6u>>,false>::moveElementsForGrow(a1, v4);
  v5 = v6;
  if (*a1 != v3)
  {
    free(*a1);
  }

  *a1 = v4;
  *(a1 + 12) = v5;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  v1 = a1;
  if (!mlir::OpInterface<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::ODIE::Compiler::CoreML::detail::ImportableOpInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    return 0;
  }

  if (v1)
  {
    mlir::OpInterface<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::ODIE::Compiler::CoreML::detail::ImportableOpInterfaceInterfaceTraits>::getInterfaceFor(v1);
  }

  return v1;
}

uint64_t mlir::OpInterface<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::ODIE::Compiler::CoreML::detail::ImportableOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (*(v1 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11 = *(*(v1 + 8) + 32);
    if (!v11)
    {
      return 0;
    }

    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,void>::resolveTypeID();
    v8 = *(*v11 + 104);
    v9 = v11;
    v10 = v1;
  }

  else
  {
    v3 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,void>::resolveTypeID();
    result = mlir::detail::InterfaceMap::lookup(v1 + 32, v3);
    if (result)
    {
      return result;
    }

    v5 = *(v1 + 24);
    v6 = *(a1 + 48);
    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,void>::resolveTypeID();
    v8 = *(*v5 + 104);
    v9 = v5;
    v10 = v6;
  }

  return v8(v9, v7, v10);
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>,mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseMapPair<mlir::SymbolRefAttr,BoundedVector<mlir::Location,10ul>>>::doFind<mlir::SymbolRefAttr>(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2)
  {
    return 0;
  }

  v3 = a2 - 1;
  v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
  v5 = (a1 + 104 * v4);
  v6 = *v5;
  if (*v5 != a3)
  {
    v7 = 1;
    while (v6 != -4096)
    {
      v8 = v4 + v7++;
      v4 = v8 & v3;
      v5 = (a1 + 104 * (v8 & v3));
      v6 = *v5;
      if (*v5 == a3)
      {
        return v5;
      }
    }

    return 0;
  }

  return v5;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>,mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::try_emplace<llvm::detail::DenseSetEmpty&>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v12 = 0;
  result = llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>,mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::LookupBucketFor<mlir::SymbolRefAttr>(*a2, *(a2 + 16), *a3, &v12);
  v7 = v12;
  if (result)
  {
    v8 = 0;
    goto LABEL_8;
  }

  v13 = v12;
  v9 = *(a2 + 8);
  v10 = *(a2 + 16);
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
    goto LABEL_10;
  }

  if (v10 + ~v9 - *(a2 + 12) <= v10 >> 3)
  {
LABEL_10:
    llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::grow(a2, v10);
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>,mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::LookupBucketFor<mlir::SymbolRefAttr>(*a2, *(a2 + 16), *a3, &v13);
    v9 = *(a2 + 8);
    v7 = v13;
  }

  *(a2 + 8) = v9 + 1;
  if (*v7 != -4096)
  {
    --*(a2 + 12);
  }

  *v7 = *a3;
  v8 = 1;
LABEL_8:
  v11 = *a2 + 8 * *(a2 + 16);
  *a1 = v7;
  *(a1 + 8) = v11;
  *(a1 + 16) = v8;
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>,mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::LookupBucketFor<mlir::SymbolRefAttr>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 8 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 8 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((8 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0x1FFFFFFFFFFFFFFFLL;
      v13 = v12 & 0x1FFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0x1FFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 8;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 1) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 2;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 8 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v29 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>,mlir::SymbolRefAttr,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::SymbolRefAttr,void>,llvm::detail::DenseSetPair<mlir::SymbolRefAttr>>::LookupBucketFor<mlir::SymbolRefAttr>(*a1, *(a1 + 16), v20, &v29);
          *v29 = *v19;
          ++*(a1 + 8);
        }

        ++v19;
        v18 -= 8;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v21 = *(a1 + 16);
  if (v21)
  {
    v22 = 0;
    v23 = v21 + 0x1FFFFFFFFFFFFFFFLL;
    v24 = v23 & 0x1FFFFFFFFFFFFFFFLL;
    v25 = (v23 & 0x1FFFFFFFFFFFFFFFLL) - (v23 & 1) + 2;
    v26 = vdupq_n_s64(v24);
    v27 = result + 8;
    do
    {
      v28 = vmovn_s64(vcgeq_u64(v26, vorrq_s8(vdupq_n_s64(v22), xmmword_25D0A0500)));
      if (v28.i8[0])
      {
        *(v27 - 1) = -4096;
      }

      if (v28.i8[4])
      {
        *v27 = -4096;
      }

      v22 += 2;
      v27 += 2;
    }

    while (v25 != v22);
  }

  return result;
}

double _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE0ENS1_15ForwardIteratorEZL18readBytecodeImportNS1_4ODIE8Compiler6CoreML8ImportOpENS_15MemoryBufferRefEE3__6NS1_17SymbolOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::SymbolOpInterface *a2)
{
  v3 = llvm::DefaultDoCastIfPossible<mlir::SymbolOpInterface,mlir::Operation *,llvm::CastInfo<mlir::SymbolOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2, a2);
  if (v3)
  {
    v6 = *a1;
    v7.n128_u64[0] = v3;
    v7.n128_u64[1] = v4;
    if (v3 != **v6)
    {
      *&result = std::deque<mlir::SymbolOpInterface>::push_back(*(v6 + 8), &v7).n128_u64[0];
    }
  }

  return result;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZL14readTextImportNS1_4ODIE8Compiler6CoreML8ImportOpENS_15MemoryBufferRefEE3__0NSD_21ImportableOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t a1, uint64_t a2)
{
  v2 = llvm::DefaultDoCastIfPossible<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::ODIE::Compiler::CoreML::ImportableOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (v2)
  {
    v4 = v2;
    if (((*v3)(v3, v2) & 1) == 0)
    {
      if (*(v4 + 2))
      {
        *(v4 + 2) = 0;
        v6 = *v4;
        v5 = *(v4 + 1);
        *v5 = *v4;
        *(v6 + 8) = v5;
        *v4 = 0;
        *(v4 + 1) = 0;
      }

      mlir::Operation::destroy(v4);
    }
  }
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::ResolveImportsBase<anonymous namespace::ResolveImportsPass>::ResolveImportsBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA5158;
  *&v3 = "Directories to search for imports that don't have static paths attached.";
  *(&v3 + 1) = 72;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>((a1 + 336), (a1 + 144), "search-paths", 12, &v3);
  *(a1 + 336) = &unk_286E77088;
  *(a1 + 576) = &unk_286E77108;
  return a1;
}

void anonymous namespace::ResolveImportsPass::~ResolveImportsPass(_anonymous_namespace_::ResolveImportsPass *this)
{
  *this = &unk_286EA5158;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA5158;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t anonymous namespace::ResolveImportsPass::runOnOperation(_anonymous_namespace_::ResolveImportsPass *this)
{
  v111 = *MEMORY[0x277D85DE8];
  v79 = &v81;
  v80 = 0x200000000;
  v1 = *(this + 57);
  for (i = *(this + 58); v1 != i; v1 += 24)
  {
    memset(&__p, 0, sizeof(__p));
    v3 = *(v1 + 23);
    if (v3 >= 0)
    {
      v4 = v1;
    }

    else
    {
      v4 = *v1;
    }

    if (v3 < 0)
    {
      v3 = *(v1 + 8);
    }

    std::string::append[abi:nn200100]<char const*,0>(&__p, v4, (v4 + v3));
    v5 = llvm::SmallVectorTemplateCommon<std::__fs::filesystem::path,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>>(&v79, &__p);
    v6 = &v79[3 * v80];
    v7 = *v5;
    v6[2] = *(v5 + 16);
    *v6 = v7;
    *(v5 + 8) = 0;
    *(v5 + 16) = 0;
    *v5 = 0;
    LODWORD(v80) = v80 + 1;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v62 = 0u;
  v63 = 0u;
  *v61 = 0u;
  v8 = *(this + 5);
  v84[0] = v61;
  __p.__r_.__value_.__r.__words[0] = v84;
  mlir::detail::walk<mlir::ForwardIterator>(v8 & 0xFFFFFFFFFFFFFFF8, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE0ENS1_15ForwardIteratorEZN12_GLOBAL__N_118ResolveImportsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML8ImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &__p, 0);
  v9 = *(&v63 + 1);
  if (*(&v63 + 1))
  {
    while (1)
    {
      v10 = *(*(v61[1] + ((v63 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v63 & 0x1FF));
      *&v63 = v63 + 1;
      *(&v63 + 1) = v9 - 1;
      if (v63 >= 0x400)
      {
        operator delete(*v61[1]);
        v61[1] = v61[1] + 8;
        *&v63 = v63 - 512;
      }

      v11 = v79;
      v12 = v80;
      v13 = *(v10 + 64 + 16 * ((*(v10 + 44) >> 23) & 1));
      if (v13)
      {
        v15 = *(v13 + 16);
        v14 = *(v13 + 24);
      }

      else
      {
        v14 = 0;
        v15 = &byte_25D0A27DF;
      }

      __p.__r_.__value_.__r.__words[0] = v15;
      __p.__r_.__value_.__l.__size_ = v14;
      llvm::StringRef::str(&__p.__r_.__value_.__l.__data_, &v66);
      v16 = *(v10 + 64 + 16 * ((*(v10 + 44) >> 23) & 1) + 16);
      *v84 = *(v16[1] + 16);
      llvm::StringRef::str(v84, &__p);
      v65 = __p;
      v17 = v16[3];
      if (v17)
      {
        v18 = v16[2];
        v19 = 8 * v17;
        do
        {
          *v84 = *(*(*v18 + 8) + 16);
          llvm::StringRef::str(v84, &__p);
          std::__fs::filesystem::path::append[abi:nn200100]<std::string>(&v65, &__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }

          v18 += 8;
          v19 -= 8;
        }

        while (v19);
      }

      if (v13)
      {
        goto LABEL_22;
      }

      v35 = *(v10 + 24);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v64, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
      }

      else
      {
        v64 = v65;
      }

      *v84 = xmmword_2799BED30;
      v85 = *&off_2799BED40;
      v86 = xmmword_2799BED50;
      v75[0] = v35;
      v69[0] = v84;
      v69[1] = 3;
      *&v100 = &v64;
      *(&v100 + 1) = v69;
      *&v101 = v75;
      if (!v12)
      {
        break;
      }

      v36 = 24 * v12;
      while (1)
      {
        resolveImportFile(mlir::Location,std::__fs::filesystem::path,llvm::ArrayRef<std::__fs::filesystem::path>,llvm::ArrayRef<llvm::StringRef>)::$_0::operator()(&__p, &v100, v11);
        if (p_p == 1)
        {
          break;
        }

        v11 += 24;
        v36 -= 24;
        if (!v36)
        {
          goto LABEL_54;
        }
      }

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v90, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        v91 = 1;
        if ((p_p & 1) == 0 || (SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_103;
        }

        v47 = __p.__r_.__value_.__r.__words[0];
        goto LABEL_102;
      }

      v90 = __p;
      v91 = 1;
LABEL_103:
      if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v64.__r_.__value_.__l.__data_);
      }

      if (v91 != 1)
      {
        v22 = 0;
        goto LABEL_136;
      }

      if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v90.__r_.__value_.__l.__data_, v90.__r_.__value_.__l.__size_);
      }

      else
      {
        __p = v90;
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      v66 = __p;
      if ((v91 & 1) != 0 && SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v90.__r_.__value_.__l.__data_);
      }

LABEL_22:
      LOWORD(v105) = 260;
      __p.__r_.__value_.__r.__words[0] = &v66;
      getFileAux<llvm::MemoryBuffer>(&__p, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, 0, &v82);
      if (v83)
      {
        v20 = *(v10 + 24);
        LOWORD(v86) = 257;
        emitDiag(v20, 2, v84, &__p);
        if (__p.__r_.__value_.__r.__words[0])
        {
          mlir::Diagnostic::operator<<<14ul>(&__p.__r_.__value_.__l.__size_, "opening file ");
          if (__p.__r_.__value_.__r.__words[0])
          {
            LOWORD(v86) = 260;
            v84[0] = &v66;
            mlir::Diagnostic::operator<<(&__p.__r_.__value_.__l.__size_, v84);
            if (__p.__r_.__value_.__r.__words[0])
            {
              mlir::Diagnostic::operator<<<10ul>(&__p.__r_.__value_.__l.__size_, " failed: ");
            }
          }
        }

        *&v90.__r_.__value_.__l.__data_ = v82;
        std::error_code::message(&v92, &v90);
        if (__p.__r_.__value_.__r.__words[0])
        {
          LOWORD(v86) = 260;
          v84[0] = &v92;
          mlir::Diagnostic::operator<<(&__p.__r_.__value_.__l.__size_, v84);
        }

        v21 = v110[72];
        if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v92.__r_.__value_.__l.__data_);
        }

        v22 = v21 ^ 1;
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&__p);
      }

      else
      {
        v23 = v82;
        *&v82 = 0;
        v24 = v23[1];
        v25 = v23[2] - v24;
        (*(*v23 + 16))(v23);
        if (v25 >= 4 && *v24 == *"ML\xEF\x52duplicate top-level section: ")
        {
          v40 = v23[1];
          v41 = v23[2] - v40;
          v42 = (*(*v23 + 16))(v23);
          v44 = v43;
          v77 = v10;
          v101 = 0u;
          v100 = 0u;
          v102[0] = v102;
          v102[1] = v102;
          memset(&v102[2], 0, 24);
          while (1)
          {
            v45 = *(v10 + 16);
            if (!v45)
            {
              break;
            }

            v46 = *(v45 + 24) & 0xFFFFFFFFFFFFFFF8;
            if (!v46)
            {
              break;
            }

            v10 = *(v46 + 16);
            if (!v10 || *(*(v10 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
            {
              goto LABEL_147;
            }
          }

          v10 = 0;
LABEL_147:
          v75[1] = 0;
          v75[0] = 0;
          v76 = 0;
          v74 = 0;
          v72 = 0u;
          v73 = 0u;
          memset(v71, 0, sizeof(v71));
          __p.__r_.__value_.__r.__words[0] = &unk_286EA5010;
          __p.__r_.__value_.__l.__size_ = &v77;
          p_p = &__p;
          std::vector<std::function<std::optional<std::pair<mlir::Attribute,mlir::WalkResult>> ()(mlir::Attribute)>>::emplace_back<std::function<std::optional<std::pair<mlir::Attribute,mlir::WalkResult>> ()(mlir::Attribute)>>(v71, &__p);
          std::__function::__value_func<std::optional<std::pair<mlir::Attribute,mlir::WalkResult>> ()(mlir::Attribute)>::~__value_func[abi:nn200100](&__p);
          __p.__r_.__value_.__r.__words[0] = v71;
          __p.__r_.__value_.__l.__size_ = &v77;
          __p.__r_.__value_.__r.__words[2] = v75;
          mlir::detail::walk<mlir::ForwardIterator>(v10, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<readBytecodeImport(mlir::ODIE::Compiler::CoreML::ImportOp,llvm::MemoryBufferRef)::$_1>, &__p, 1);
          v92.__r_.__value_.__r.__words[0] = *(***(v77 + 3) + 32);
          v92.__r_.__value_.__s.__data_[8] = 0;
          v92.__r_.__value_.__r.__words[2] = 0;
          v93 = 0;
          v94 = 0;
          v95 = 0;
          v96 = v98;
          v97 = 0x600000000;
          v98[6] = &v99;
          v98[7] = 0x600000000;
          __p.__r_.__value_.__r.__words[0] = v40;
          __p.__r_.__value_.__l.__size_ = v41;
          __p.__r_.__value_.__r.__words[2] = v42;
          p_p = v44;
          v84[1] = 0;
          v84[0] = 0;
          mlir::BytecodeReader::BytecodeReader(&v70, &__p, &v92);
        }

        v26 = v23[1];
        v27 = v23[2] - v26;
        (*(*v23 + 16))(v23);
        *v84 = 0u;
        v85 = 0u;
        *&v86 = &v86;
        *(&v86 + 1) = &v86;
        v88 = 0;
        v89 = 0;
        v87 = 0;
        __p.__r_.__value_.__r.__words[0] = *(***(v10 + 24) + 32);
        __p.__r_.__value_.__s.__data_[8] = 1;
        __p.__r_.__value_.__r.__words[2] = 0;
        p_p = 0;
        v105 = 0;
        v106 = 0;
        v107[0] = &v108;
        v107[1] = 0x600000000;
        v109[0] = v110;
        v109[1] = 0x600000000;
        v22 = mlir::parseSourceString(v26, v27, v84, &__p, &byte_25D0A27DF, 0, 0);
        llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeReader<mlir::Type>>,6u>::~SmallVector(v109);
        llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeReader<mlir::Attribute>>,6u>::~SmallVector(v107);
        llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>,llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>::destroyAll(&__p.__r_.__value_.__r.__words[2]);
        MEMORY[0x25F891030](__p.__r_.__value_.__r.__words[2], 8);
        if (v22)
        {
          v28 = *(&v86 + 1);
          if (*(&v86 + 1) != &v86)
          {
            do
            {
              v29 = *(v28 + 8);
              __p.__r_.__value_.__r.__words[0] = &v92;
              mlir::detail::walk<mlir::ForwardIterator>(v28, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZL14readTextImportNS1_4ODIE8Compiler6CoreML8ImportOpENS_15MemoryBufferRefEE3__0NSD_21ImportableOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, &__p, 1);
              v28 = v29;
            }

            while (v29 != &v86);
          }

          v30 = v10;
          do
          {
            v30 = *((*(*(v30 + 16) + 24) & 0xFFFFFFFFFFFFFFF8) + 16);
          }

          while (*(*(v30 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id);
          v31 = *(((v30 + 16 * ((*(v30 + 44) >> 23) & 1) + ((*(v30 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v30 + 40) + 8);
          if (v31)
          {
            v32 = v31 - 8;
          }

          else
          {
            v32 = 0;
          }

          v33 = *(&v86 + 1);
          if (*(&v86 + 1) == &v86)
          {
            goto LABEL_128;
          }

          v34 = *(&v86 + 1);
          while (*(*(v34 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
          {
            v34 = *(v34 + 8);
            if (v34 == &v86)
            {
              goto LABEL_128;
            }
          }

          if (v34 == &v86)
          {
LABEL_128:
            if (v86 != &v86)
            {
              llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>,llvm::ilist_traits<mlir::Operation>>::transfer(v32 + 32, v10, &v86, *(&v86 + 1), &v86);
            }
          }

          else
          {
            do
            {
              if (*(*(v33 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
              {
                break;
              }

              v33 = *(v33 + 8);
            }

            while (v33 != &v86);
            while (v33 != &v86)
            {
              v48 = *(v33 + 16 * ((*(v33 + 44) >> 23) & 1) + ((*(v33 + 44) >> 21) & 0x7F8) + 32 * *(v33 + 40) + 72);
              if (v48)
              {
                v49 = v48 - 8;
              }

              else
              {
                v49 = 0;
              }

              if (*(v49 + 32) != v49 + 32)
              {
                llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>,llvm::ilist_traits<mlir::Operation>>::transfer(v32 + 32, v10, v49 + 32, *(v49 + 40), (v49 + 32));
              }

              do
              {
                v33 = *(v33 + 8);
              }

              while (v33 != &v86 && *(*(v33 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id);
            }
          }

          if (*(v10 + 16))
          {
            *(v10 + 16) = 0;
            v51 = *v10;
            v50 = *(v10 + 8);
            *v50 = *v10;
            *(v51 + 8) = v50;
            *v10 = 0;
            *(v10 + 8) = 0;
          }

          mlir::Operation::destroy(v10);
        }

        mlir::Block::~Block(v84);
        (*(*v23 + 8))(v23);
        if ((v83 & 1) == 0 && v82)
        {
          (*(*v82 + 8))(v82);
        }
      }

LABEL_136:
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v65.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      v52 = *(this + 5);
      if ((v22 & 1) == 0)
      {
        *(this + 5) = v52 | 4;
        goto LABEL_152;
      }

      v84[0] = v61;
      __p.__r_.__value_.__r.__words[0] = v84;
      mlir::detail::walk<mlir::ForwardIterator>(v52 & 0xFFFFFFFFFFFFFFF8, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE0ENS1_15ForwardIteratorEZN12_GLOBAL__N_118ResolveImportsPass14runOnOperationEvE3__1NS1_4ODIE8Compiler6CoreML8ImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &__p, 0);
      v9 = *(&v63 + 1);
      if (!*(&v63 + 1))
      {
        goto LABEL_152;
      }
    }

LABEL_54:
    std::__fs::filesystem::__current_path(v71, 0);
    v37 = std::__fs::filesystem::path::__root_directory(v71);
    if (v37.__size_ >= 0x7FFFFFFFFFFFFFF8)
    {
      std::string::__throw_length_error[abi:nn200100]();
    }

    if (v37.__size_ >= 0x17)
    {
      operator new();
    }

    *(&__p.__r_.__value_.__s + 23) = v37.__size_;
    if (v37.__size_)
    {
      memmove(&__p, v37.__data_, v37.__size_);
    }

    __p.__r_.__value_.__s.__data_[v37.__size_] = 0;
    *&v68 = *(&__p.__r_.__value_.__l + 2);
    *v67 = *&__p.__r_.__value_.__l.__data_;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v38.__data_ = v67;
    }

    else
    {
      v38.__data_ = __p.__r_.__value_.__r.__words[0];
    }

    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v38.__size_ = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v38.__size_ = __p.__r_.__value_.__l.__size_;
    }

    if (std::__fs::filesystem::path::__compare(v71, v38))
    {
      while (1)
      {
        resolveImportFile(mlir::Location,std::__fs::filesystem::path,llvm::ArrayRef<std::__fs::filesystem::path>,llvm::ArrayRef<llvm::StringRef>)::$_0::operator()(&__p, &v100, v71);
        if (p_p == 1)
        {
          break;
        }

        std::__fs::filesystem::path::parent_path[abi:nn200100](v71, &__p);
        if ((v71[23] & 0x80000000) != 0)
        {
          operator delete(*v71);
        }

        *v71 = __p;
        if ((SBYTE7(v68) & 0x80u) == 0)
        {
          v39.__data_ = v67;
        }

        else
        {
          v39.__data_ = v67[0];
        }

        if ((SBYTE7(v68) & 0x80u) == 0)
        {
          v39.__size_ = BYTE7(v68);
        }

        else
        {
          v39.__size_ = v67[1];
        }

        if (!std::__fs::filesystem::path::__compare(v71, v39))
        {
          goto LABEL_77;
        }
      }

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v90, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        v91 = 1;
        if ((p_p & 1) != 0 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      else
      {
        v90 = __p;
        v91 = 1;
      }
    }

    else
    {
LABEL_77:
      LOWORD(v94) = 257;
      emitDiag(v75[0], 2, &v92, &__p);
      if (__p.__r_.__value_.__r.__words[0])
      {
        mlir::Diagnostic::operator<<<20ul>(&__p.__r_.__value_.__l.__size_, "could not resolve ");
      }

      if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v78, v64.__r_.__value_.__l.__data_, v64.__r_.__value_.__l.__size_);
      }

      else
      {
        v78 = v64;
      }

      if (__p.__r_.__value_.__r.__words[0])
      {
        LOWORD(v94) = 260;
        v92.__r_.__value_.__r.__words[0] = &v78;
        mlir::Diagnostic::operator<<(&__p.__r_.__value_.__l.__size_, &v92);
        if (__p.__r_.__value_.__r.__words[0])
        {
          mlir::Diagnostic::operator<<<32ul>(&__p.__r_.__value_.__l.__size_, " to an existing, readable file");
        }
      }

      v90.__r_.__value_.__s.__data_[0] = 0;
      v91 = 0;
      if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v78.__r_.__value_.__l.__data_);
      }

      mlir::InFlightDiagnostic::~InFlightDiagnostic(&__p);
    }

    if (SBYTE7(v68) < 0)
    {
      operator delete(v67[0]);
    }

    if ((v71[23] & 0x80000000) == 0)
    {
      goto LABEL_103;
    }

    v47 = *v71;
LABEL_102:
    operator delete(v47);
    goto LABEL_103;
  }

LABEL_152:
  v53 = v61[1];
  v54 = v62;
  *(&v63 + 1) = 0;
  v55 = (v62 - v61[1]) >> 3;
  if (v55 >= 3)
  {
    do
    {
      operator delete(*v53);
      v54 = v62;
      v53 = (v61[1] + 8);
      v61[1] = v53;
      v55 = (v62 - v53) >> 3;
    }

    while (v55 > 2);
  }

  if (v55 == 1)
  {
    v56 = 256;
    goto LABEL_158;
  }

  if (v55 == 2)
  {
    v56 = 512;
LABEL_158:
    *&v63 = v56;
  }

  if (v53 != v54)
  {
    do
    {
      v57 = *v53++;
      operator delete(v57);
    }

    while (v53 != v54);
    if (v62 != v61[1])
    {
      *&v62 = v62 + ((v61[1] - v62 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (v61[0])
  {
    operator delete(v61[0]);
  }

  result = llvm::SmallVector<std::__fs::filesystem::path,2u>::~SmallVector(&v79);
  v59 = *MEMORY[0x277D85DE8];
  return result;
}

unint64_t llvm::SmallVectorTemplateCommon<std::__fs::filesystem::path,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>>(uint64_t a1, unint64_t a2)
{
  v2 = a2;
  v3 = *(a1 + 8);
  if (v3 >= *(a1 + 12))
  {
    if (*a1 <= a2 && *a1 + 24 * v3 > a2)
    {
      v6 = a2 - *a1;
      llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>::grow(a1, v3 + 1);
      return *a1 + v6;
    }

    else
    {
      llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>::grow(a1, v3 + 1);
    }
  }

  return v2;
}

void llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>::grow(uint64_t a1, unint64_t a2)
{
  v16 = 0;
  v3 = (a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (a1 + 16), a2, 24, &v16);
  v5 = *a1;
  v6 = *(a1 + 8);
  if (v6)
  {
    v7 = 24 * v6;
    v8 = v4;
    do
    {
      v9 = *v5;
      v8[2] = v5[2];
      *v8 = v9;
      v8 += 3;
      v5[1] = 0;
      v5[2] = 0;
      *v5 = 0;
      v5 += 3;
      v7 -= 24;
    }

    while (v7);
    v5 = *a1;
    v10 = *(a1 + 8);
    if (v10)
    {
      v11 = &v5[3 * v10 - 1] + 7;
      v12 = -24 * v10;
      v13 = v11;
      do
      {
        v14 = *v13;
        v13 -= 24;
        if (v14 < 0)
        {
          operator delete(*(v11 - 23));
        }

        v11 = v13;
        v12 += 24;
      }

      while (v12);
      v5 = *a1;
    }
  }

  v15 = v16;
  if (v5 != v3)
  {
    free(v5);
  }

  *a1 = v4;
  *(a1 + 12) = v15;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE0ENS1_15ForwardIteratorEZN12_GLOBAL__N_118ResolveImportsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML8ImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_(void *a1, uint64_t a2)
{
  result = 1;
  if (a2)
  {
    if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportOp,void>::id)
    {
      v7[1] = v2;
      v7[2] = v3;
      v6 = *a1;
      v7[0] = a2;
      std::deque<mlir::ODIE::Compiler::CoreML::ImportOp>::push_back(*v6, v7);
      return 0;
    }
  }

  return result;
}

void *std::deque<mlir::ODIE::Compiler::CoreML::ImportOp>::push_back(void *result, void *a2)
{
  v3 = result;
  v4 = result[1];
  v5 = result[2];
  if (v5 == v4)
  {
    v6 = 0;
  }

  else
  {
    v6 = ((v5 - v4) << 6) - 1;
  }

  v7 = result[4];
  v8 = result[5] + v7;
  if (v6 == v8)
  {
    if (v7 < 0x200)
    {
      v9 = result[3];
      v10 = v9 - *result;
      if (v5 - v4 < v10)
      {
        operator new();
      }

      v11 = v10 >> 2;
      if (v9 == *result)
      {
        v12 = 1;
      }

      else
      {
        v12 = v11;
      }

      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::CoreML::ImportOp *>>(v12);
    }

    result[4] = v7 - 512;
    v13 = *v4;
    result[1] = v4 + 8;
    result = std::__split_buffer<mlir::ODIE::Compiler::CoreML::ImportOp *>::emplace_back<mlir::ODIE::Compiler::CoreML::ImportOp *&>(result, &v13);
    v4 = v3[1];
    v8 = v3[5] + v3[4];
  }

  *(*&v4[(v8 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v8 & 0x1FF)) = *a2;
  ++v3[5];
  return result;
}

void *std::__split_buffer<mlir::ODIE::Compiler::CoreML::ImportOp *>::emplace_back<mlir::ODIE::Compiler::CoreML::ImportOp *&>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      if (v4 == *result)
      {
        v11 = 1;
      }

      else
      {
        v11 = &v4[-*result] >> 2;
      }

      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::CoreML::ImportOp *>>(v11);
    }

    v7 = ((v6 >> 3) + 1) / -2;
    v8 = ((v6 >> 3) + 1) / 2;
    v9 = &v5[-8 * v8];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v8], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v7];
    v3[2] = &v9[v10];
  }

  *v4 = *a2;
  v3[2] += 8;
  return result;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::CoreML::ImportOp *>>(unint64_t a1)
{
  if (!(a1 >> 61))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE0ENS1_15ForwardIteratorEZN12_GLOBAL__N_118ResolveImportsPass14runOnOperationEvE3__1NS1_4ODIE8Compiler6CoreML8ImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_(void *a1, uint64_t a2)
{
  result = 1;
  if (a2)
  {
    if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ImportOp,void>::id)
    {
      v7[1] = v2;
      v7[2] = v3;
      v6 = *a1;
      v7[0] = a2;
      std::deque<mlir::ODIE::Compiler::CoreML::ImportOp>::push_back(*v6, v7);
      return 0;
    }
  }

  return result;
}

uint64_t llvm::SmallVector<std::__fs::filesystem::path,2u>::~SmallVector(uint64_t a1)
{
  v2 = *a1;
  v3 = *(a1 + 8);
  if (v3)
  {
    v4 = v2 + 24 * v3 - 1;
    v5 = -24 * v3;
    v6 = v4;
    do
    {
      v7 = *v6;
      v6 -= 24;
      if (v7 < 0)
      {
        operator delete(*(v4 - 23));
      }

      v4 = v6;
      v5 += 24;
    }

    while (v5);
    v2 = *a1;
  }

  if (v2 != (a1 + 16))
  {
    free(v2);
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::ResolveFFIImportsBase<anonymous namespace::ResolveFFIImportsPass>::ResolveFFIImportsBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA5238;
  *&v3 = "Directories to search for imports that don't have static paths attached.";
  *(&v3 + 1) = 72;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>((a1 + 336), (a1 + 144), "search-paths", 12, &v3);
  *(a1 + 336) = &unk_286E77088;
  *(a1 + 576) = &unk_286E77108;
  *&v3 = "Where the compilation database (compile-commands.json) can be found.";
  *(&v3 + 1) = 68;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 600), (a1 + 144), "compilation-database", 20, &v3);
  *(a1 + 600) = &unk_286E98FD0;
  *(a1 + 824) = &unk_286E99050;
  return a1;
}

void anonymous namespace::ResolveFFIImportsPass::~ResolveFFIImportsPass(_anonymous_namespace_::ResolveFFIImportsPass *this)
{
  *this = &unk_286EA5238;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 600);
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA5238;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 600);
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::ResolveFFIImportsBase<anonymous namespace::ResolveFFIImportsPass>::getDependentDialects(uint64_t a1, uint64_t a2)
{
  mlir::DialectRegistry::insert<mlir::ODIE::Compiler::CoreML::CoreMLDialect>(a2);

  return mlir::DialectRegistry::insert<mlir::LLVM::LLVMDialect>(a2);
}

uint64_t anonymous namespace::ResolveFFIImportsPass::runOnOperation(_anonymous_namespace_::ResolveFFIImportsPass *this)
{
  v20[6] = *MEMORY[0x277D85DE8];
  v18 = v20;
  v19 = 0x200000000;
  v2 = *(this + 57);
  for (i = *(this + 58); v2 != i; v2 += 24)
  {
    memset(&__p, 0, sizeof(__p));
    v4 = *(v2 + 23);
    if (v4 >= 0)
    {
      v5 = v2;
    }

    else
    {
      v5 = *v2;
    }

    if (v4 < 0)
    {
      v4 = *(v2 + 8);
    }

    std::string::append[abi:nn200100]<char const*,0>(&__p, v5, (v5 + v4));
    v6 = llvm::SmallVectorTemplateCommon<std::__fs::filesystem::path,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<std::__fs::filesystem::path,false>>(&v18, &__p);
    v7 = &v18[3 * v19];
    v8 = *v6;
    v7[2] = *(v6 + 16);
    *v7 = v8;
    *(v6 + 8) = 0;
    *(v6 + 16) = 0;
    *v6 = 0;
    LODWORD(v19) = v19 + 1;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v9 = (this + 720);
  if (*(this + 743) < 0)
  {
    v9 = v9->__r_.__value_.__r.__words[0];
  }

  memset(&__p, 0, sizeof(__p));
  v10 = (v9 - 1);
  do
  {
    v11 = v10->__r_.__value_.__s.__data_[1];
    v10 = (v10 + 1);
  }

  while (v11);
  std::string::append[abi:nn200100]<char const*,0>(&__p, v9, v10);
  v12 = *(this + 5);
  v15[0] = &__p;
  v15[1] = &v18;
  v17 = v15;
  if (!mlir::detail::walk<mlir::ForwardIterator>(v12 & 0xFFFFFFFFFFFFFFF8, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_121ResolveFFIImportsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML11FFIImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v17, 1))
  {
    *(this + 5) |= 4uLL;
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  result = llvm::SmallVector<std::__fs::filesystem::path,2u>::~SmallVector(&v18);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_121ResolveFFIImportsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML11FFIImportOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_(int a1, void **this)
{
  v9 = *MEMORY[0x277D85DE8];
  v2 = 1;
  if (this && *(this[6] + 2) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FFIImportOp,void>::id)
  {
    v5 = "compiler built without clang; cannot resolve an FFI import";
    v6 = 259;
    mlir::Operation::emitError(v7, this, &v5);
    v2 = v8 ^ 1u;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v7);
  }

  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

std::string *std::__fs::filesystem::path::append[abi:nn200100]<std::string>(std::string *this, uint64_t a2)
{
  if (*(a2 + 23) < 0)
  {
    if (!*(a2 + 8))
    {
      goto LABEL_9;
    }

    v4 = *a2;
  }

  else
  {
    v4 = a2;
    if (!*(a2 + 23))
    {
      goto LABEL_9;
    }
  }

  if (*v4 == 47)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }

    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *(&this->__r_.__value_.__s + 23) = 0;
    }

    goto LABEL_12;
  }

LABEL_9:
  if (std::__fs::filesystem::path::__filename(this).__size_)
  {
    std::string::push_back(this, 47);
  }

LABEL_12:
  v5 = *(a2 + 23);
  if (v5 >= 0)
  {
    v6 = a2;
  }

  else
  {
    v6 = *a2;
  }

  if (v5 < 0)
  {
    v5 = *(a2 + 8);
  }

  std::string::append[abi:nn200100]<char const*,0>(this, v6, (v6 + v5));
  return this;
}

void anonymous namespace::RemoveUnusedExternalizeGraphsPass::~RemoveUnusedExternalizeGraphsPass(_anonymous_namespace_::RemoveUnusedExternalizeGraphsPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t anonymous namespace::RemoveUnusedExternalizeGraphsPass::runOnOperation(_anonymous_namespace_::RemoveUnusedExternalizeGraphsPass *this)
{
  v7[0] = 0;
  v7[1] = 0;
  v8 = 0;
  mlir::SymbolUserMap::SymbolUserMap(v5, v7, (*(this + 5) & 0xFFFFFFFFFFFFFFF8));
  v2 = *(this + 5);
  v4 = v5;
  v9 = &v4;
  mlir::detail::walk<mlir::ForwardIterator>(v2 & 0xFFFFFFFFFFFFFFF8, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_133RemoveUnusedExternalizeGraphsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML7GraphOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v9, 1);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::destroyAll(v6);
  MEMORY[0x25F891030](v6[0], 8);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v7);
  return MEMORY[0x25F891030](v7[0], 8);
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_133RemoveUnusedExternalizeGraphsPass14runOnOperationEvE3__0NS1_4ODIE8Compiler6CoreML7GraphOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, mlir::Operation *a2)
{
  if (a2)
  {
    if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
    {
      if (*(a2 + 2 * ((*(a2 + 11) >> 23) & 1) + 9))
      {
        v3 = **a1;
        v6 = a2;
        if (!llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::doFind<mlir::Operation const*>((v3 + 8), &v6))
        {
          if (*(a2 + 2))
          {
            *(a2 + 2) = 0;
            v5 = *a2;
            v4 = *(a2 + 1);
            *v4 = *a2;
            *(v5 + 8) = v4;
            *a2 = 0;
            *(a2 + 1) = 0;
          }

          mlir::Operation::destroy(a2);
        }
      }
    }
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::destroyAll(uint64_t result)
{
  v1 = *(result + 16);
  if (v1)
  {
    v2 = 48 * v1;
    v3 = *result + 48;
    do
    {
      if ((*(v3 - 48) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(v3 - 16);
        if (v3 != v4)
        {
          free(v4);
        }

        result = MEMORY[0x25F891030](*(v3 - 40), 8);
      }

      v3 += 48;
      v2 -= 48;
    }

    while (v2);
  }

  return result;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ReplaceDecomposableOpsPass::~ReplaceDecomposableOpsPass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ReplaceDecomposableOpsPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ReplaceDecomposableOpsPass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ReplaceDecomposableOpsPass *this)
{
  v1 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v4[1] = *(***(v1 + 24) + 32);
  v4[2] = 0;
  v4[3] = *(v1 + 16);
  v4[4] = v1;
  v3 = v4;
  v4[0] = &unk_286E76228;
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::ReplaceDecomposableOpsPass::runOnOperation(void)::$_0>(uint64_t *a1, uint64_t a2)
{
  v4 = mlir::detail::TypeIDResolver<mlir::OpTrait::ODIE::Compiler::CoreML::Decomposable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ODIE::Compiler::CoreML::Decomposable>(void)::Empty>,void>::resolveTypeID();
  result = (*(**(a2 + 48) + 32))(*(a2 + 48), v4);
  if (!result)
  {
    return result;
  }

  v6 = *a1;
  v7 = *(a2 + 44);
  v8 = *(((a2 + 16 * ((v7 >> 23) & 1) + ((v7 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40) + 8);
  if (v8)
  {
    v9 = v8 - 8;
  }

  else
  {
    v9 = 0;
  }

  v10 = *(v9 + 32);
  if ((*(v10 + 46) & 0x80) != 0)
  {
    v11 = *(v10 + 68);
    v12 = *(v10 + 72) & 0xFFFFFFFFFFFFFFF9 | 2;
    if ((v7 & 0x800000) == 0)
    {
      goto LABEL_8;
    }
  }

  else
  {
    v11 = 0;
    v12 = 2;
    if ((v7 & 0x800000) == 0)
    {
      goto LABEL_8;
    }
  }

  v13 = *(a2 + 68);
  v14 = *(a2 + 72) & 0xFFFFFFFFFFFFFFF9 | 2;
LABEL_8:
  v15 = *(a2 + 16);
  (*(*v6 + 32))(v6);
  (**v6)(v6, a2, v12, v11);
  v16 = *(*v6 + 16);

  return v16(v6, v10);
}

void mlir::ODIE::Compiler::Transforms::createSegmentForDelegates(uint64_t a1)
{
  v5 = *MEMORY[0x277D85DE8];
  std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::__value_func[abi:nn200100](&v2, a1);
  *__p = *(a1 + 32);
  v4 = *(a1 + 48);
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  *(a1 + 32) = 0;
  mlir::ODIE::Compiler::Transforms::impl::createSegmentForDelegates();
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentForDelegates>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA53F8;
    mlir::detail::PassOptions::Option<std::__fs::filesystem::path,mlir::detail::PassOptions::GenericOptionParser<std::__fs::filesystem::path>>::~Option(v2 + 896);
    mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(v2 + 336);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::SegmentForDelegatesBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentForDelegates>::SegmentForDelegatesBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA53F8;
  *&v3 = "The segmenter to use";
  *(&v3 + 1) = 20;
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::Option<llvm::cl::desc>(a1 + 336, (a1 + 144), &v3);
  *(a1 + 336) = &unk_286EA5468;
  *(a1 + 880) = &unk_286EA54E8;
  *&v3 = "The directory in which to place assets.";
  *(&v3 + 1) = 39;
  mlir::detail::PassOptions::Option<std::__fs::filesystem::path,mlir::detail::PassOptions::GenericOptionParser<std::__fs::filesystem::path>>::Option<llvm::cl::desc>((a1 + 896), (a1 + 144), "binaryDir", 9, &v3);
  *(a1 + 896) = &unk_286EA3C60;
  *(a1 + 1432) = &unk_286EA3CE0;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentForDelegates::~SegmentForDelegates(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SegmentForDelegates *this)
{
  *this = &unk_286EA53F8;
  mlir::detail::PassOptions::Option<std::__fs::filesystem::path,mlir::detail::PassOptions::GenericOptionParser<std::__fs::filesystem::path>>::~Option(this + 896);
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA53F8;
  mlir::detail::PassOptions::Option<std::__fs::filesystem::path,mlir::detail::PassOptions::GenericOptionParser<std::__fs::filesystem::path>>::~Option(this + 896);
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentForDelegates::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SegmentForDelegates *this)
{
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  if (*(this + 60))
  {
    mlir::ODIE::Compiler::Serialization::rewriteModuleWithFxn(*(this + 5) & 0xFFFFFFFFFFFFFFF8);
  }

  v6 = *(***(v2 + 24) + 32);
  v7 = 0;
  v8 = *(v2 + 16);
  v9 = v2;
  v4 = &v5;
  v5 = &unk_286E76228;
  v10 = &v4;
  result = mlir::detail::walk<mlir::ForwardIterator>(v2, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__0NS1_19FunctionOpInterfaceES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v10, 1);
  if (result)
  {
    v10 = this;
    v5 = &v10;
    mlir::detail::walk<mlir::ForwardIterator>(v2, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__1NS1_15CallOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v5, 1);
    v5 = 0;
    v6 = 0;
    LODWORD(v7) = 0;
    v4 = &v5;
    v10 = &v4;
    mlir::detail::walk<mlir::ForwardIterator>(v2, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__2NSD_6CoreML8InvokeOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v10, 1);
    llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(&v5);
    return MEMORY[0x25F891030](v5, 8);
  }

  else
  {
    *(this + 5) |= 4uLL;
  }

  return result;
}

uint64_t mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::Option<llvm::cl::desc>(uint64_t a1, char *a2, _OWORD *a3)
{
  v14[3] = *MEMORY[0x277D85DE8];
  v6 = llvm::cl::Option::Option(a1, 0, 0);
  v6[18] = 0;
  v6[19] = &unk_286EA5650;
  *v6 = &unk_286EA55E8;
  v6[21] = v6;
  v6[22] = v6 + 24;
  v6[23] = 0x800000000;
  v6[20] = &unk_286EA5670;
  v7 = v6 + 64;
  v6[64] = &unk_286EA5710;
  v6[67] = v6 + 64;
  llvm::cl::Option::setArgStr(v6, "segmenter", 9);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v12);
  *(a1 + 32) = *a3;
  llvm::cl::Option::addArgument(a1);
  *(a1 + 552) = 0;
  *a1 = &unk_286EA5528;
  *(a1 + 544) = &unk_286EA55A8;
  v12[0] = a1 + 544;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100]((a2 + 160), v12);
  v11[0] = &unk_286EA5758;
  v11[1] = a1;
  v13 = v12;
  v11[3] = v11;
  v12[0] = &unk_286EA5758;
  v12[1] = a1;
  if (v12 != v7)
  {
    v8 = *(a1 + 536);
    if (v8 == v7)
    {
      v14[0] = &unk_286EA5758;
      v14[1] = a1;
      v13 = 0;
      (*(*v8 + 24))(v8, v12);
      (*(**(a1 + 536) + 32))(*(a1 + 536));
      *(a1 + 536) = 0;
      v13 = v12;
      (*(v14[0] + 24))(v14, v7);
      (*(v14[0] + 32))(v14);
    }

    else
    {
      *(a1 + 512) = &unk_286EA5758;
      *(a1 + 520) = a1;
      v13 = v8;
    }

    *(a1 + 536) = v7;
  }

  std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](v12);
  std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](v11);
  v9 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::handleOccurrence(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v23 = *MEMORY[0x277D85DE8];
  v22 = 0;
  v8 = *(*(a1 + 168) + 24) == 0;
  v18 = 1283;
  if (!v8)
  {
    a4 = a6;
  }

  if (!v8)
  {
    a3 = a5;
  }

  v17[0] = "Cannot find option named '";
  v17[2] = a3;
  v17[3] = a4;
  v19[0] = v17;
  v19[2] = "'!";
  v20 = 770;
  v11 = llvm::errs(a1);
  v12 = llvm::cl::Option::error(a1, v19, 0, 0, v11);
  if (v12)
  {
    goto LABEL_10;
  }

  std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::operator=((a1 + 120), v21);
  *(a1 + 12) = a2;
  v13 = *(a1 + 536);
  if (v13)
  {
    (*(*v13 + 48))(v13, v21);
LABEL_10:
    std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::~__value_func[abi:nn200100](v21);
    v14 = *MEMORY[0x277D85DE8];
    return v12;
  }

  v16 = std::__throw_bad_function_call[abi:nn200100]();
  return llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::getValueExpectedFlagDefault(v16);
}

uint64_t llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::getValueExpectedFlagDefault(uint64_t a1)
{
  if (*(*(a1 + 168) + 24))
  {
    return 2;
  }

  else
  {
    return 3;
  }
}

void mlir::Pass::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::setDefault(uint64_t a1)
{
  v5 = *MEMORY[0x277D85DE8];
  v4 = 0;
  std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::operator=((a1 + 120), v3);
  result = std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::~__value_func[abi:nn200100](v3);
  v2 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  v2 = llvm::raw_ostream::operator<<(this, *(a1 + 16), *(a1 + 24));
  llvm::raw_ostream::write(v2, 61);
  __break(1u);
}

void *mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::operator=((a1 + 120), a2 - 424);
  *(a1 + 552) = *(a2 + 8);
  return result;
}

void non-virtual thunk tomlir::Pass::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1 - 544);
}

{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1 - 544);

  JUMPOUT(0x25F891040);
}

void non-virtual thunk tomlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  v2 = llvm::raw_ostream::operator<<(this, *(a1 - 528), *(a1 - 520));
  llvm::raw_ostream::write(v2, 61);
  __break(1u);
}

void *non-virtual thunk tomlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::operator=((a1 - 424), a2 - 424);
  *(a1 + 8) = *(a2 + 8);
  return result;
}

void mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1);

  JUMPOUT(0x25F891040);
}

{
  *a1 = &unk_286EA55E8;
  std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](a1 + 512);
  *(a1 + 160) = &unk_286EA56C0;
  v2 = *(a1 + 176);
  if (v2 != (a1 + 192))
  {
    free(v2);
  }

  std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::~__value_func[abi:nn200100](a1 + 120);

  llvm::cl::Option::~Option(a1);
}

void non-virtual thunk tomlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1 - 544);
}

{
  mlir::detail::PassOptions::Option<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~Option(a1 - 544);

  JUMPOUT(0x25F891040);
}

void llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~opt(uint64_t a1)
{
  *a1 = &unk_286EA55E8;
  std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](a1 + 512);
  *(a1 + 160) = &unk_286EA56C0;
  v2 = *(a1 + 176);
  if (v2 != (a1 + 192))
  {
    free(v2);
  }

  std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::~__value_func[abi:nn200100](a1 + 120);

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA55E8;
  std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](a1 + 512);
  *(a1 + 160) = &unk_286EA56C0;
  v2 = *(a1 + 176);
  if (v2 != (a1 + 192))
  {
    free(v2);
  }

  std::__function::__value_func<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::~__value_func[abi:nn200100](a1 + 120);
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

void *mlir::detail::PassOptions::GenericOptionParser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~GenericOptionParser(void *a1)
{
  *a1 = &unk_286EA56C0;
  v2 = a1[2];
  if (v2 != a1 + 4)
  {
    free(v2);
  }

  return a1;
}

void mlir::detail::PassOptions::GenericOptionParser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~GenericOptionParser(void *a1)
{
  *a1 = &unk_286EA56C0;
  v2 = a1[2];
  if (v2 != a1 + 4)
  {
    free(v2);
  }

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::parser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::getOption(uint64_t a1, unsigned int a2)
{
  v2 = (*(a1 + 16) + 40 * a2);
  result = *v2;
  v4 = v2[1];
  return result;
}

uint64_t llvm::cl::parser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::getDescription(uint64_t a1, unsigned int a2)
{
  v2 = *(a1 + 16) + 40 * a2;
  result = *(v2 + 16);
  v4 = *(v2 + 24);
  return result;
}

void *llvm::cl::parser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~parser(void *a1)
{
  *a1 = &unk_286EA56C0;
  v2 = a1[2];
  if (v2 != a1 + 4)
  {
    free(v2);
  }

  return a1;
}

void llvm::cl::parser<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::~parser(void *a1)
{
  *a1 = &unk_286EA56C0;
  v2 = a1[2];
  if (v2 != a1 + 4)
  {
    free(v2);
  }

  JUMPOUT(0x25F891040);
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_8functionIFNS_10unique_ptrIN4llvm12MemoryBufferENS_14default_deleteIS9_EEEEOSC_RKNS_4__fs10filesystem4pathENS8_12function_refIFvRKNS8_5TwineEEEEEEENS4_19GenericOptionParserISQ_EEEC1IJNS8_2cl4descEEEERS4_NS8_9StringRefEDpOT_EUlRKT_E_NS_9allocatorIS15_EEFvRKSQ_EE7__cloneEPNS0_6__baseIS1A_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA5758;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__value_func<void ()(std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__0NS1_19FunctionOpInterfaceES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, uint64_t a2)
{
  v3 = llvm::DefaultDoCastIfPossible<mlir::FunctionOpInterface,mlir::Operation *,llvm::CastInfo<mlir::FunctionOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (v3)
  {
    return mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(v3, v4, "Interpreter", 11, **a1) & 1;
  }

  else
  {
    return 1;
  }
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__1NS1_15CallOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, uint64_t a2)
{
  v15[6] = *MEMORY[0x277D85DE8];
  v3 = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (v3)
  {
    v5 = v3;
    v6 = **a1;
    v7 = (*v4)(v4, v3);
    v8 = mlir::Operation::getParentOfType<mlir::FunctionOpInterface>(v5);
    v12 = mlir::ODIE::Compiler::CoreML::flattenSymbolRef((v7 & 0xFFFFFFFFFFFFFFF8));
    v13 = v15;
    v14 = 0x600000000;
    llvm::SmallVectorImpl<mlir::Attribute>::append<mlir::Attribute const*,void>(&v13, &v12, &v13);
    Attr = mlir::Operation::getAttr(v8, "meta.callees", 0xCuLL);
    if (Attr && *(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      llvm::SmallVectorImpl<mlir::Attribute>::append<mlir::Attribute const*,void>(&v13, *(Attr + 8), (*(Attr + 8) + 8 * *(Attr + 16)));
    }

    v10 = mlir::ArrayAttr::get(*(***((*(v6 + 40) & 0xFFFFFFFFFFFFFFF8) + 24) + 32), v13, v14);
    mlir::Operation::setAttr(v8, "meta.callees", 0xC, v10);
    if (v13 != v15)
    {
      free(v13);
    }
  }

  v11 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_119SegmentForDelegates14runOnOperationEvE3__2NSD_6CoreML8InvokeOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_(mlir::SymbolTableCollection ***a1, mlir::Operation *a2)
{
  v39 = *MEMORY[0x277D85DE8];
  result = 1;
  if (a2)
  {
    v4 = a2;
    if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
    {
      v5 = *a1;
      v31 = a2;
      do
      {
        v6 = *(v4 + 2);
        if (v6)
        {
          v7 = *(v6 + 24) & 0xFFFFFFFFFFFFFFF8;
          if (v7)
          {
            v4 = *(v7 + 16);
            if (v4)
            {
              continue;
            }
          }
        }

        goto LABEL_23;
      }

      while (*(*(v4 + 6) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id);
      v8 = v4 + 64;
      v9 = *(v4 + 2 * ((*(v4 + 11) >> 23) & 1) + 9);
      v11 = *(v9 + 16);
      v10 = *(v9 + 24);
      v12 = mlir::ODIE::Compiler::CoreML::InvokeOp::resolveCallee(&v31, *v5);
      if (!v12 || (v13 = v12, *(v12[6] + 2) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id))
      {
        *&v27 = "failed to resolve its callee ";
        v29 = 259;
        mlir::Operation::emitError(&v35, v31, &v27);
        CalleeAttr = mlir::ODIE::Compiler::CoreML::InvokeOp::getCalleeAttr(&v31);
        if (v35)
        {
          LODWORD(v32) = 0;
          v33 = CalleeAttr;
          v15 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v37, &v32, 1);
          v16 = v37 + 24 * v38;
          v17 = *v15;
          *(v16 + 16) = *(v15 + 16);
          *v16 = v17;
          ++v38;
          if (v35)
          {
            mlir::Diagnostic::operator<<<19ul>(v36, " to existing graph");
          }
        }

        goto LABEL_13;
      }

      v18 = (((&v12[2 * ((*(v12 + 11) >> 23) & 1) + 8] + ((*(v12 + 11) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v12 + 10));
      if (*v18 != v18)
      {
        mlir::Region::getOps<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp>(v18, &v27);
        if (!llvm::hasSingleElement<llvm::iterator_range<mlir::detail::op_iterator<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,mlir::Region::OpIterator>> &>(&v27))
        {
          v25[0] = "expected one nested isolatedGroupOp in graph with delegate id = ";
          v26 = 259;
          mlir::Operation::emitError(&v35, v13, v25);
          if (!v35)
          {
LABEL_13:
            mlir::InFlightDiagnostic::~InFlightDiagnostic(&v35);
            result = 0;
            goto LABEL_24;
          }

          v34 = 261;
          v32 = v11;
          v33 = v10;
LABEL_27:
          mlir::Diagnostic::operator<<(v36, &v32);
          goto LABEL_13;
        }

        v19 = v30(v28);
        v20 = *(v19 + 16 * ((*(v19 + 44) >> 23) & 1) + 72);
        if (*(v20 + 24) != v10 || v10 && memcmp(*(v20 + 16), v11, v10))
        {
          v21 = v30(v28);
          v25[0] = "InvokeOp of delegate ";
          v26 = 259;
          mlir::Operation::emitError(&v35, v21, v25);
          if (!v35)
          {
            goto LABEL_13;
          }

          v34 = 261;
          v32 = v11;
          v33 = v10;
          mlir::Diagnostic::operator<<(v36, &v32);
          if (!v35)
          {
            goto LABEL_13;
          }

          mlir::Diagnostic::operator<<<35ul>(v36, " cannot invoke callee of delegate ");
          if (!v35)
          {
            goto LABEL_13;
          }

          v22 = *(*&v8[16 * ((*(v4 + 11) >> 23) & 1) + 8] + 16);
          v23 = *(*&v8[16 * ((*(v4 + 11) >> 23) & 1) + 8] + 24);
          v34 = 261;
          v32 = v22;
          v33 = v23;
          goto LABEL_27;
        }
      }

LABEL_23:
      result = 1;
    }
  }

LABEL_24:
  v24 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::cl::opt<std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>,false,mlir::detail::PassOptions::GenericOptionParser<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>>::operator=<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>(uint64_t a1, uint64_t a2)
{
  std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)>::operator=((a1 + 120), a2);
  v4 = *(a1 + 536);
  if (v4)
  {
    (*(*v4 + 48))(v4, a2);
    return a1 + 120;
  }

  else
  {
    v6 = std::__throw_bad_function_call[abi:nn200100]();
    return mlir::ODIE::Compiler::Transforms::impl::createSegmentDelegatedGraphs(v6);
  }
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentDelegatedGraphs>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentDelegatedGraphs::~SegmentDelegatedGraphs(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SegmentDelegatedGraphs *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SegmentDelegatedGraphs::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SegmentDelegatedGraphs *this)
{
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v6 = xmmword_2799BED60;
  v5[1] = *(***(v2 + 24) + 32);
  v5[2] = 0;
  v5[3] = *(v2 + 16);
  v5[4] = v2;
  v4[1] = v5;
  v5[0] = &unk_286E76228;
  v4[0] = &v6;
  v7 = v4;
  result = mlir::detail::walk<mlir::ForwardIterator>(v2, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_122SegmentDelegatedGraphs14runOnOperationEvE3__0NSD_6CoreML7GraphOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v7, 1);
  if (!result)
  {
    *(this + 5) |= 4uLL;
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_122SegmentDelegatedGraphs14runOnOperationEvE3__0NSD_6CoreML7GraphOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_(const void ****a1, uint64_t a2)
{
  v20 = *MEMORY[0x277D85DE8];
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
  {
    v2 = a2;
  }

  else
  {
    v2 = 0;
  }

  if (v2 && (v3 = *a1, (Attr = mlir::Operation::getAttr(v2, ***a1, (**a1)[1])) != 0) && (v5 = Attr, *(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) && (mlir::Operation::removeAttr(v2, **v3, (*v3)[1]), InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v2), (mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(v2, InterfaceFor, *(v5 + 16), *(v5 + 24), v3[1]) & 1) == 0))
  {
    v13 = 257;
    mlir::Operation::emitError(&v16, v2, v12);
    if (v16)
    {
      mlir::Diagnostic::operator<<<53ul>(&v17, "Unable to segment annotated graph for delegate id = ");
      if (v16)
      {
        v14 = 0;
        v15 = v5;
        v9 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v18, &v14, 1);
        v10 = v18 + 24 * v19;
        v11 = *v9;
        *(v10 + 16) = *(v9 + 16);
        *v10 = v11;
        ++v19;
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v16);
    result = 0;
  }

  else
  {
    result = 1;
  }

  v8 = *MEMORY[0x277D85DE8];
  return result;
}

__n128 std::__move_impl<std::_ClassicAlgPolicy>::operator()[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping *,mlir::ODIE::Compiler::ImportMapping *,mlir::ODIE::Compiler::ImportMapping *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v4 = a1;
    v5 = (a3 + 31);
    do
    {
      *(v5 - 31) = *v4;
      v6 = (v5 - 23);
      if (*v5 < 0)
      {
        operator delete(*v6);
      }

      v7 = *(v4 + 8);
      *(v5 - 7) = *(v4 + 24);
      *v6 = v7;
      *(v4 + 31) = 0;
      *(v4 + 8) = 0;
      if (v5[24] < 0)
      {
        operator delete(*(v5 + 1));
      }

      result = *(v4 + 32);
      *(v5 + 17) = *(v4 + 48);
      *(v5 + 1) = result;
      *(v4 + 55) = 0;
      *(v4 + 32) = 0;
      v4 += 56;
      v5 += 56;
    }

    while (v4 != a2);
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::StaticizeDynamicCallBase<anonymous namespace::StaticizeDynamicCallPass>::StaticizeDynamicCallBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA5880;
  *&v4 = "The name of the main entrypoint, which this pass will modify.";
  *(&v4 + 1) = 61;
  v3 = "main";
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::initializer<char [5]>>((a1 + 336), (a1 + 144), "entrypoint", 10, &v4, &v3);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  *&v4 = "The name of the new argument to be added to the list of argument names on the entrypoint, if there is one.";
  *(&v4 + 1) = 106;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 576), (a1 + 144), "new-arg-name", 12, &v4);
  *(a1 + 576) = &unk_286E98FD0;
  *(a1 + 800) = &unk_286E99050;
  *&v4 = "The mapping for selector -> file + callee symbol the pass shoulduse to generate the conditional.";
  *(&v4 + 1) = 96;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::ListOption<llvm::cl::desc>(a1 + 816, (a1 + 144), &v4);
  *(a1 + 816) = &unk_286EA5938;
  *(a1 + 1056) = &unk_286EA59B8;
  return a1;
}

void anonymous namespace::StaticizeDynamicCallPass::~StaticizeDynamicCallPass(_anonymous_namespace_::StaticizeDynamicCallPass *this)
{
  *this = &unk_286EA5880;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(this + 816);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 576);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA5880;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(this + 816);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 576);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t anonymous namespace::StaticizeDynamicCallPass::runOnOperation(_anonymous_namespace_::StaticizeDynamicCallPass *this, uint64_t a2, const llvm::Twine *a3)
{
  v89[23] = *MEMORY[0x277D85DE8];
  v4 = (*(this + 5) & 0xFFFFFFFFFFFFFFF8);
  mlir::SymbolTable::SymbolTable(v73, v4, a3);
  v69 = v4 + 16;
  v70 = v4;
  v5 = *(&v4[8 * v4[10] + 18 + 4 * ((v4[11] >> 23) & 1)] + ((v4[11] >> 21) & 0x7F8));
  if (v5)
  {
    v6 = v5 - 8;
  }

  else
  {
    v6 = 0;
  }

  v71 = *(***(*((*(v6 + 24) & 0xFFFFFFFFFFFFFFF8) + 16) + 24) + 32);
  v72 = *(v6 + 40);
  v7 = *(this + 117);
  v8 = *(this + 118);
  if (v8 - v7 < 1)
  {
    v12 = 0;
LABEL_10:
  }

  else
  {
    v9 = MEMORY[0x277D826F0];
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v8 - v7) >> 3);
    while (1)
    {
      v11 = operator new(56 * v10, v9);
      if (v11)
      {
        break;
      }

      v12 = v10 >> 1;
      v13 = v10 > 1;
      v10 >>= 1;
      if (!v13)
      {
        goto LABEL_10;
      }
    }

    v14 = v11;
    operator delete(v14);
  }

  v77[0] = v78;
  v77[1] = 0x600000000;
  v15 = *(this + 117);
  v68 = *(this + 118);
  if (v15 == v68)
  {
    LOWORD(v76[0]) = 257;
    mlir::Operation::emitError(&v82, v70, v75);
    if (v82)
    {
      mlir::Diagnostic::operator<<<64ul>(&v82 + 8, "must provide an existing graph to anchor on for signature types");
    }
  }

  else
  {
    v16 = 0;
    while (1)
    {
      v17 = *(v15 + 55);
      if (v17 < 0)
      {
        if (*(v15 + 40))
        {
LABEL_16:
          v18 = *(v70 + 3);
          if (v17 >= 0)
          {
            v20 = *(v15 + 55);
          }

          else
          {
            v19 = *(v15 + 32);
            v20 = *(v15 + 40);
          }

          v21 = *(v15 + 31);
          if (v21 < 0)
          {
            v22 = *(v15 + 8);
          }

          if (v21 < 0)
          {
            v23 = *(v15 + 16);
          }

          v24 = *(*(v16 + 16 * ((*(v16 + 44) >> 23) & 1) + 80) + 8);
          v25 = *(((&v69[4 * ((*(v70 + 11) >> 23) & 1)] + ((*(v70 + 11) >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v70 + 10) + 8);
          if (v25)
          {
            v26 = v25 - 8;
          }

          else
          {
            v26 = 0;
          }

          v73[5] = v26;
          v73[6] = v24;
          v27 = *(**v18 + 32);
          memset(v75, 0, sizeof(v75));
          v76[0] = v76;
          v76[1] = v76;
          memset(&v76[2], 0, 24);
          *&v82 = v27;
          BYTE8(v82) = 1;
          v83[0] = 0;
          v83[1] = 0;
          LODWORD(v84) = 0;
          v85 = 0;
          v86 = v88;
          v87 = 0x600000000;
          v88[6] = v89;
          v88[7] = 0x600000000;
          mlir::parseSourceFile();
        }
      }

      else if (*(v15 + 55))
      {
        goto LABEL_16;
      }

      v28 = *(v15 + 31);
      v29 = v28 >= 0 ? v15 + 8 : *(v15 + 8);
      v30 = *(v15 + 16);
      v31 = v28 >= 0 ? *(v15 + 31) : *(v15 + 16);
      v32 = mlir::SymbolTable::lookup(v73, v29, v31);
      if (!v32)
      {
        break;
      }

      v16 = v32;
      if (*(*(v32 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
      {
        break;
      }

      v34 = mlir::SymbolRefAttr::get(*(v32 + 16 * ((*(v32 + 44) >> 23) & 1) + 120), 0, 0, v33);
      llvm::SmallVectorTemplateBase<mlir::SymbolRefAttr,true>::push_back(v77, v34);
      v15 += 56;
      if (v15 == v68)
      {
        v35 = *(this + 479);
        if (v35 >= 0)
        {
          v36 = this + 456;
        }

        else
        {
          v36 = *(this + 57);
        }

        if (v35 >= 0)
        {
          v37 = *(this + 479);
        }

        else
        {
          v37 = *(this + 58);
        }

        v38 = mlir::SymbolTable::lookup(v73, v36, v37);
        if (v38)
        {
          if (*(*(v38 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
          {
            v39 = v38;
          }

          else
          {
            v39 = 0;
          }
        }

        else
        {
          v39 = 0;
        }

        v42 = *(*(v39 + 64 + 16 * ((*(v39 + 44) >> 23) & 1) + 16) + 8);
        v43 = *(v42 + 16);
        v44 = &v43[8 * *(v42 + 8)];
        v79 = v81;
        v80 = 0x600000000;
        llvm::SmallVectorImpl<mlir::Type>::append<mlir::Type const*,void>(&v79, v43, v44);
        v45 = mlir::IntegerType::get(v71, 32, 1);
        v82 = 0uLL;
        *v75 = v45;
        v74.__r_.__value_.__r.__words[0] = 0;
        v46 = mlir::detail::TypeUniquer::get<mlir::RankedTensorType,llvm::ArrayRef<long long> &,mlir::Type &,mlir::Attribute &>(*(**v45 + 32), &v82, v75, &v74);
        llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(&v79, v46);
        v47 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
        v48 = *(*(v39 + 64 + 16 * ((*(v39 + 44) >> 23) & 1) + 16) + 8);
        v49 = *(v48 + 16);
        v51 = *(v48 + 8);
        v50 = *(v48 + 12);
        *&v82 = v79 & 0xFFFFFFFFFFFFFFF9 | 2;
        *(&v82 + 1) = v80;
        *v75 = (v49 + 8 * v51) & 0xFFFFFFFFFFFFFFF9 | 2;
        *&v75[8] = v50;
        v52 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v47, &v82, v75);
        *(v39 + 64 + 16 * ((*(v39 + 44) >> 23) & 1) + 16) = mlir::TypeAttr::get(v52);
        Attr = mlir::Operation::getAttr(v39, "inputs", 6uLL);
        if (Attr && *(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
        {
          v54 = Attr[1];
          v55 = &v54[8 * Attr[2]];
          *&v82 = v83;
          *(&v82 + 1) = 0x600000000;
          llvm::SmallVectorImpl<mlir::Attribute>::append<mlir::Attribute const*,void>(&v82, v54, v55);
          v57 = (this + 696);
          if (*(this + 719) < 0)
          {
            v58 = *(this + 88);
            if (!v58)
            {
              goto LABEL_65;
            }

            std::string::__init_copy_ctor_external(&v74, *v57, v58);
          }

          else
          {
            if (*(this + 719))
            {
              *&v74.__r_.__value_.__l.__data_ = *v57;
              v74.__r_.__value_.__r.__words[2] = *(this + 89);
              goto LABEL_67;
            }

LABEL_65:
            std::to_string(v75, DWORD2(v82));
            v59 = std::string::insert(v75, 0, "arg");
            v60 = v59->__r_.__value_.__r.__words[2];
            *&v74.__r_.__value_.__l.__data_ = *&v59->__r_.__value_.__l.__data_;
            v74.__r_.__value_.__r.__words[2] = v60;
            v59->__r_.__value_.__l.__size_ = 0;
            v59->__r_.__value_.__r.__words[2] = 0;
            v59->__r_.__value_.__r.__words[0] = 0;
            if ((v75[23] & 0x80000000) != 0)
            {
              operator delete(*v75);
            }
          }

LABEL_67:
          v61 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
          LOWORD(v76[0]) = 260;
          *v75 = &v74;
          v62 = mlir::StringAttr::get(v61, v75, v56);
          llvm::SmallVectorTemplateBase<mlir::Attribute,true>::push_back(&v82, v62);
          v63 = mlir::ArrayAttr::get(*(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32), v82, DWORD2(v82));
          mlir::Operation::setAttr(v39, "inputs", 6, v63);
          if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v74.__r_.__value_.__l.__data_);
          }

          if (v82 != v83)
          {
            free(v82);
          }
        }

        v64 = *(v79 + v80 - 1);
        v65 = *(v70 + 3);
        v66 = *(((v39 + 64 + 16 * ((*(v39 + 44) >> 23) & 1) + ((*(v39 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v39 + 40) + 8);
        if (v66)
        {
          v67 = v66 - 8;
        }

        else
        {
          v67 = 0;
        }

        mlir::Block::addArgument(v67);
      }
    }

    v81[8] = 257;
    mlir::Operation::emitError(&v82, v70, &v79);
    if (v82)
    {
      mlir::Diagnostic::operator<<<46ul>(&v82 + 8, "could not find an existing graph with name '@");
      if (v82)
      {
        LOWORD(v76[0]) = 260;
        *v75 = v15 + 8;
        mlir::Diagnostic::operator<<(&v82 + 8, v75);
        if (v82)
        {
          mlir::Diagnostic::operator<<<2ul>(&v82 + 8, "'");
        }
      }
    }
  }

  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v82);
  *(this + 5) |= 4uLL;
  if (v77[0] != v78)
  {
    free(v77[0]);
  }

  result = MEMORY[0x25F891030](v73[1], 8);
  v41 = *MEMORY[0x277D85DE8];
  return result;
}

llvm::cl::Option *mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::initializer<char [5]>>(llvm::cl::Option *a1, const void *a2, uint64_t a3, uint64_t a4, _OWORD *a5, char **a6)
{
  v13[4] = *MEMORY[0x277D85DE8];
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a2;
  v11[1] = 0;
  v8 = llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<char [5]>>(a1, v12, v11, a5, a6);
  *(v8 + 232) = 0;
  *v8 = &unk_286E75DD0;
  *(v8 + 28) = &unk_286E75E50;
  v11[0] = v8 + 224;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100](a2 + 160, v11);
  v13[0] = &unk_286EA58F0;
  v13[1] = a1;
  v13[3] = v13;
  std::function<void ()(std::string const&)>::operator=(a1 + 24, v13);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:nn200100](v13);
  v9 = *MEMORY[0x277D85DE8];
  return a1;
}

llvm::cl::Option *llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<char [5]>>(llvm::cl::Option *a1, uint64_t *a2, const void **a3, _OWORD *a4, char **a5)
{
  v10 = llvm::cl::Option::Option(a1, 0, 0);
  *(v10 + 120) = 0;
  *(v10 + 128) = 0;
  *(v10 + 160) = 0;
  *(v10 + 168) = 0;
  *(v10 + 152) = 0;
  *(v10 + 176) = 0;
  *(v10 + 136) = 0;
  *(v10 + 144) = &unk_286E79070;
  *v10 = &unk_286E792E0;
  *(v10 + 184) = &unk_286E791E0;
  *(v10 + 192) = &unk_286E75EB0;
  *(v10 + 216) = v10 + 192;
  llvm::cl::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<char [5]>>(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

void llvm::cl::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<char [5]>>(uint64_t a1, uint64_t *a2, const void **a3, _OWORD *a4, char **a5)
{
  llvm::cl::Option::setArgStr(a1, *a2, a2[1]);
  llvm::cl::sub::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>>(a3, a1);
  *(a1 + 32) = *a4;

  llvm::cl::initializer<char [5]>::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>>(a5, a1);
}

void llvm::cl::initializer<char [5]>::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>>(char **a1, uint64_t a2)
{
  std::string::basic_string[abi:nn200100]<0>(&__str, *a1);
  std::string::operator=((a2 + 120), &__str);
  *(a2 + 176) = 1;
  std::string::operator=((a2 + 152), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descENSD_11initializerIA5_cEEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISU_EEFvRKSB_EE7__cloneEPNS0_6__baseISY_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA58F0;
  a2[1] = v2;
  return result;
}

uint64_t mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::ListOption<llvm::cl::desc>(uint64_t a1, char *a2, _OWORD *a3)
{
  v6 = llvm::cl::Option::Option(a1, 1, 0);
  *(v6 + 168) = 0;
  *(v6 + 152) = 0u;
  *(v6 + 136) = 0u;
  *(v6 + 120) = 0u;
  *v6 = &unk_286EA5AB8;
  *(v6 + 184) = 0;
  *(v6 + 192) = 0;
  *(v6 + 176) = 0;
  *(v6 + 200) = &unk_286EA5B68;
  *(v6 + 208) = &unk_286EA5B20;
  *(v6 + 232) = v6 + 208;
  llvm::cl::Option::setArgStr(v6, "mappings", 8);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v8);
  *(a1 + 32) = *a3;
  llvm::cl::Option::addArgument(a1);
  *(a1 + 248) = 0;
  *a1 = &unk_286EA59F8;
  *(a1 + 240) = &unk_286EA5A78;
  *(a1 + 256) = &unk_286EA5B68;
  if ((*(a1 + 168) & 1) == 0)
  {
    *(a1 + 168) = 1;
  }

  v8[0] = a1 + 240;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100]((a2 + 160), v8);
  return a1;
}

BOOL mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    v12 = *(a1 + 120);
    for (i = *(a1 + 128); i != v12; std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](i))
    {
      i -= 56;
    }

    *(a1 + 128) = v12;
    *(a1 + 168) = 0;
  }

  *(a1 + 248) = 1;
  v14 = a1;
  v15[0] = a1 + 256;
  v16[0] = a3;
  v16[1] = a4;
  v15[1] = a1;
  v15[2] = v16;
  v15[3] = &v14;
  return (mlir::detail::pass_options::parseCommaSeparatedList(a1, a3, a4, a5, a6, llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::ImportMapping const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping> &,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::ImportMapping const&)#1} &&)::{lambda(llvm::StringRef)#1}>, v15) & 1) == 0;
}

void mlir::Pass::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::list<mlir::ODIE::Compiler::ImportMapping,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::setDefault(void *a1)
{
  a1[23] = a1[22];
  v3 = a1[15];
  for (i = a1[16]; i != v3; std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](i))
  {
    i -= 56;
  }

  a1[16] = v3;
}

llvm::raw_ostream *mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  v3 = result;
  if (*(result + 168) != 1 || (*(result + 16) == *(result + 15) ? (v4 = (*(result + 19) - *(result + 18)) >> 3 == 0x6DB6DB6DB6DB6DB7 * ((*(result + 16) - *(result + 15)) >> 3)) : (v4 = 0), !v4))
  {
    result = llvm::raw_ostream::operator<<(this, *(result + 2), *(result + 3));
    v5 = *(result + 4);
    if (*(result + 3) - v5 > 1uLL)
    {
      *v5 = 31549;
      *(result + 4) += 2;
    }

    else
    {
      result = llvm::raw_ostream::write(result, "={", 2uLL);
    }

    v6 = *(v3 + 15);
    v7 = *(v3 + 16);
    if (v6 != v7)
    {
      result = llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::print(this, *(v3 + 15));
      for (i = v6 + 14; i != v7; i += 14)
      {
        v9 = *(this + 4);
        if (*(this + 3) == v9)
        {
          llvm::raw_ostream::write(this, ",", 1uLL);
        }

        else
        {
          *v9 = 44;
          ++*(this + 4);
        }

        result = llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::print(this, i);
      }
    }

    v10 = *(this + 4);
    if (*(this + 3) == v10)
    {

      return llvm::raw_ostream::write(this, "}", 1uLL);
    }

    else
    {
      *v10 = 125;
      ++*(this + 4);
    }
  }

  return result;
}

void mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::vector<mlir::ODIE::Compiler::ImportMapping>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*>((a1 + 120), *(a2 - 120), *(a2 - 112), 0x6DB6DB6DB6DB6DB7 * ((*(a2 - 112) - *(a2 - 120)) >> 3));
  *(a1 + 248) = 1;
  *(a1 + 248) = *(a2 + 8);
}

void non-virtual thunk tomlir::Pass::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::vector<mlir::ODIE::Compiler::ImportMapping>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*>((a1 - 120), *(a2 - 120), *(a2 - 112), 0x6DB6DB6DB6DB6DB7 * ((*(a2 - 112) - *(a2 - 120)) >> 3));
  *(a1 + 8) = 1;
  *(a1 + 8) = *(a2 + 8);
}

void mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

{
  *a1 = &unk_286EA5AB8;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::ImportMapping const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::ImportMapping>::__destroy_vector::operator()[abi:nn200100](&v4);

  llvm::cl::Option::~Option(a1);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::list<mlir::ODIE::Compiler::ImportMapping,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v32 = 0;
  v30 = 0u;
  *__p = 0u;
  *v29 = 0u;
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    v11 = *(a1 + 120);
    for (i = *(a1 + 128); i != v11; std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](i))
    {
      i -= 56;
    }

    *(a1 + 128) = v11;
    *(a1 + 168) = 0;
  }

  v12 = llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::parse(a1, a5, a6, v29);
  if ((v12 & 1) == 0)
  {
    std::vector<mlir::ODIE::Compiler::ImportMapping>::push_back[abi:nn200100]((a1 + 120), v29);
    *(a1 + 12) = a2;
    v14 = *(a1 + 184);
    v13 = *(a1 + 192);
    if (v14 >= v13)
    {
      v16 = *(a1 + 176);
      v17 = v14 - v16;
      v18 = (v14 - v16) >> 2;
      v19 = v18 + 1;
      if ((v18 + 1) >> 62)
      {
        goto LABEL_26;
      }

      v20 = v13 - v16;
      if (v20 >> 1 > v19)
      {
        v19 = v20 >> 1;
      }

      v21 = v20 >= 0x7FFFFFFFFFFFFFFCLL;
      v22 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v21)
      {
        v22 = v19;
      }

      if (v22)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(a1 + 176, v22);
      }

      v23 = (v14 - v16) >> 2;
      v24 = (4 * v18);
      v25 = (4 * v18 - 4 * v23);
      *v24 = a2;
      v15 = v24 + 1;
      memcpy(v25, v16, v17);
      v26 = *(a1 + 176);
      *(a1 + 176) = v25;
      *(a1 + 184) = v15;
      *(a1 + 192) = 0;
      if (v26)
      {
        operator delete(v26);
      }
    }

    else
    {
      *v14 = a2;
      v15 = v14 + 4;
    }

    *(a1 + 184) = v15;
    v27 = *(a1 + 232);
    if (v27)
    {
      (*(*v27 + 48))(v27, v29);
      goto LABEL_20;
    }

    std::__throw_bad_function_call[abi:nn200100]();
LABEL_26:
    std::vector<unsigned int>::__throw_length_error[abi:nn200100]();
  }

LABEL_20:
  if (SHIBYTE(v32) < 0)
  {
    operator delete(__p[0]);
  }

  if (SHIBYTE(v30) < 0)
  {
    operator delete(v29[1]);
  }

  return v12;
}

void llvm::cl::list<mlir::ODIE::Compiler::ImportMapping,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::~list(uint64_t a1)
{
  *a1 = &unk_286EA5AB8;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::ImportMapping const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::ImportMapping>::__destroy_vector::operator()[abi:nn200100](&v4);

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA5AB8;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::ImportMapping const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::ImportMapping>::__destroy_vector::operator()[abi:nn200100](&v4);
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::parse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *&v30 = a2;
  *(&v30 + 1) = a3;
  v21 = 0;
  first_not_of = llvm::consumeSignedInteger(&v30, 0xA, &v21, a4);
  if ((first_not_of & 1) != 0 || (v7 = v21, v21 != v21))
  {
    v29 = 1283;
    *&v27 = "'";
    v28 = v30;
    v17 = "' is invalid - expected an integer selector";
LABEL_20:
    v21 = &v27;
    *(&__p + 1) = v17;
    LOWORD(v24) = 770;
    v18 = llvm::errs(first_not_of);
    return llvm::cl::Option::error(a1, &v21, 0, 0, v18);
  }

  v8 = *(&v30 + 1);
  first_not_of = llvm::StringRef::find_first_not_of(&v30, " \t\n\v\f\r", 6, 0);
  if (first_not_of >= v8)
  {
    v9 = v8;
  }

  else
  {
    v9 = first_not_of;
  }

  v10 = v8 - v9;
  v11 = (v30 + v9);
  *&v30 = v11;
  *(&v30 + 1) = v10;
  if (first_not_of >= v8 || *v11 != 58)
  {
    v29 = 1283;
    *&v27 = "'";
    *&v28 = v11;
    *(&v28 + 1) = v10;
    goto LABEL_20;
  }

  v12 = v11 + 1;
  v13 = (v10 - 1);
  *&v30 = v12;
  *(&v30 + 1) = v13;
  if (v13)
  {
    v14 = 0;
    while (*(v12 + v14) != 58)
    {
      if (v13 == ++v14)
      {
        goto LABEL_12;
      }
    }
  }

  else
  {
LABEL_12:
    v14 = -1;
  }

  if (v13 >= v14)
  {
    v15 = v14;
  }

  else
  {
    v15 = v13;
  }

  v26[0] = v12;
  v26[1] = v15;
  v16 = &v15[v12];
  *&v30 = v16;
  *(&v30 + 1) = v13 - v15;
  if (v13 <= v14)
  {
    LODWORD(v21) = v7;
    llvm::StringRef::str(v26, &__p);
    std::string::basic_string[abi:nn200100]<0>(&v24, &byte_25D0A27DF);
    goto LABEL_24;
  }

  if (*v16 != 58)
  {
    v29 = 1283;
    *&v27 = "'";
    *&v28 = v16;
    *(&v28 + 1) = v13 - v15;
    goto LABEL_20;
  }

  *&v30 = v16 + 1;
  *(&v30 + 1) = v13 - v15 - 1;
  v27 = v30;
  LODWORD(v21) = v7;
  llvm::StringRef::str(v26, &__p);
  llvm::StringRef::str(&v27, &v24);
LABEL_24:
  *a4 = v21;
  if (*(a4 + 31) < 0)
  {
    operator delete(*(a4 + 8));
  }

  *(a4 + 8) = __p;
  *(a4 + 24) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(__p) = 0;
  if (*(a4 + 55) < 0)
  {
    operator delete(*(a4 + 32));
    v20 = SHIBYTE(v23);
    *(a4 + 32) = v24;
    *(a4 + 48) = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    if (v20 < 0)
    {
      operator delete(__p);
    }
  }

  else
  {
    *(a4 + 32) = v24;
    *(a4 + 48) = v25;
  }

  return 0;
}

void std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](uint64_t a1)
{
  if (*(a1 + 55) < 0)
  {
    operator delete(*(a1 + 32));
  }

  if (*(a1 + 31) < 0)
  {
    v2 = *(a1 + 8);

    operator delete(v2);
  }
}

void std::vector<mlir::ODIE::Compiler::ImportMapping>::push_back[abi:nn200100](uint64_t *a1, uint64_t a2)
{
  v4 = a1[1];
  v3 = a1[2];
  if (v4 >= v3)
  {
    v6 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3);
    if ((v6 + 1) > 0x492492492492492)
    {
      std::vector<mlir::ODIE::Compiler::ImportMapping>::__throw_length_error[abi:nn200100]();
    }

    v7 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
    v8 = 2 * v7;
    if (2 * v7 <= v6 + 1)
    {
      v8 = v6 + 1;
    }

    if (v7 >= 0x249249249249249)
    {
      v9 = 0x492492492492492;
    }

    else
    {
      v9 = v8;
    }

    if (v9)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::ImportMapping>>(v9);
    }

    v10 = 56 * v6;
    std::allocator_traits<std::allocator<mlir::ODIE::Compiler::ImportMapping>>::construct[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping,mlir::ODIE::Compiler::ImportMapping const&,0>(v10, a2);
    v5 = v10 + 56;
    v11 = *a1;
    v12 = a1[1];
    v13 = v10 + *a1 - v12;
    if (v12 != *a1)
    {
      v14 = *a1;
      v15 = v13;
      do
      {
        *v15 = *v14;
        v16 = *(v14 + 8);
        *(v15 + 24) = *(v14 + 3);
        *(v15 + 8) = v16;
        *(v14 + 2) = 0;
        *(v14 + 3) = 0;
        *(v14 + 1) = 0;
        v17 = *(v14 + 2);
        *(v15 + 48) = *(v14 + 6);
        *(v15 + 32) = v17;
        *(v14 + 5) = 0;
        *(v14 + 6) = 0;
        *(v14 + 4) = 0;
        v14 += 56;
        v15 += 56;
      }

      while (v14 != v12);
      do
      {
        std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](v11);
        v11 += 56;
      }

      while (v11 != v12);
      v11 = *a1;
    }

    *a1 = v13;
    a1[1] = v5;
    a1[2] = 0;
    if (v11)
    {
      operator delete(v11);
    }
  }

  else
  {
    std::allocator_traits<std::allocator<mlir::ODIE::Compiler::ImportMapping>>::construct[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping,mlir::ODIE::Compiler::ImportMapping const&,0>(a1[1], a2);
    v5 = v4 + 56;
  }

  a1[1] = v5;
}

void std::allocator_traits<std::allocator<mlir::ODIE::Compiler::ImportMapping>>::construct[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping,mlir::ODIE::Compiler::ImportMapping const&,0>(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = (a1 + 8);
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(a2 + 8), *(a2 + 16));
  }

  else
  {
    v5 = *(a2 + 8);
    v4->__r_.__value_.__r.__words[2] = *(a2 + 24);
    *&v4->__r_.__value_.__l.__data_ = v5;
  }

  if (*(a2 + 55) < 0)
  {
    v7 = *(a2 + 32);
    v8 = *(a2 + 40);

    std::string::__init_copy_ctor_external((a1 + 32), v7, v8);
  }

  else
  {
    v6 = *(a2 + 32);
    *(a1 + 48) = *(a2 + 48);
    *(a1 + 32) = v6;
  }
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::ImportMapping>>(unint64_t a1)
{
  if (a1 < 0x492492492492493)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t std::__function::__value_func<void ()(mlir::ODIE::Compiler::ImportMapping const&)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void std::vector<mlir::ODIE::Compiler::ImportMapping>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::ImportMapping const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping> &,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::ImportMapping,llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::ImportMapping const&)#1} &&)::{lambda(llvm::StringRef)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = 0;
  *v7 = 0u;
  *__p = 0u;
  v9 = 0u;
  v4 = 0;
  if ((llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::parse(*(a1 + 8), a2, a3, &v6) & 1) == 0)
  {
    std::vector<mlir::ODIE::Compiler::ImportMapping>::push_back[abi:nn200100]((**(a1 + 24) + 120), &v6);
    v4 = 1;
  }

  if (SHIBYTE(v9) < 0)
  {
    operator delete(__p[1]);
  }

  if (SHIBYTE(__p[0]) < 0)
  {
    operator delete(v7[0]);
  }

  return v4;
}

llvm::raw_ostream *llvm::cl::parser<mlir::ODIE::Compiler::ImportMapping>::print(llvm::raw_ostream *a1, int *a2)
{
  v3 = a1;
  llvm::write_integer(a1, *a2, 0, 0);
  v4 = *(v3 + 4);
  if (*(v3 + 3) == v4)
  {
    v3 = llvm::raw_ostream::write(v3, ":", 1uLL);
  }

  else
  {
    *v4 = 58;
    ++*(v3 + 4);
  }

  v5 = *(a2 + 31);
  if (v5 >= 0)
  {
    v6 = (a2 + 2);
  }

  else
  {
    v6 = *(a2 + 1);
  }

  if (v5 >= 0)
  {
    v7 = *(a2 + 31);
  }

  else
  {
    v7 = *(a2 + 2);
  }

  v8 = llvm::raw_ostream::write(v3, v6, v7);
  v9 = *(v8 + 4);
  if (*(v8 + 3) == v9)
  {
    v8 = llvm::raw_ostream::write(v8, ":", 1uLL);
  }

  else
  {
    *v9 = 58;
    ++*(v8 + 4);
  }

  v12 = *(a2 + 4);
  v11 = a2 + 8;
  v10 = v12;
  v13 = *(v11 + 23);
  if (v13 >= 0)
  {
    v14 = v11;
  }

  else
  {
    v14 = v10;
  }

  if (v13 >= 0)
  {
    v15 = *(v11 + 23);
  }

  else
  {
    v15 = *(v11 + 1);
  }

  return llvm::raw_ostream::write(v8, v14, v15);
}

void std::vector<mlir::ODIE::Compiler::ImportMapping>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v7 = a1[2];
  v8 = *a1;
  if (0x6DB6DB6DB6DB6DB7 * ((v7 - *a1) >> 3) < a4)
  {
    if (v8)
    {
      v9 = a1[1];
      v10 = *a1;
      if (v9 != v8)
      {
        do
        {
          v9 -= 56;
          std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](v9);
        }

        while (v9 != v8);
        v10 = *a1;
      }

      a1[1] = v8;
      operator delete(v10);
      v7 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }

    if (a4 <= 0x492492492492492)
    {
      v11 = 0x6DB6DB6DB6DB6DB7 * (v7 >> 3);
      v12 = 2 * v11;
      if (2 * v11 <= a4)
      {
        v12 = a4;
      }

      if (v11 >= 0x249249249249249)
      {
        v13 = 0x492492492492492;
      }

      else
      {
        v13 = v12;
      }

      if (v13 <= 0x492492492492492)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::ImportMapping>>(v13);
      }
    }

    std::vector<mlir::ODIE::Compiler::ImportMapping>::__throw_length_error[abi:nn200100]();
  }

  v14 = a1[1] - v8;
  if (0x6DB6DB6DB6DB6DB7 * (v14 >> 3) >= a4)
  {
    v18 = std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping*>(a2, a3, v8);
    for (i = a1[1]; i != v18; std::allocator<mlir::ODIE::Compiler::ImportMapping>::destroy[abi:nn200100](i))
    {
      i -= 56;
    }

    a1[1] = v18;
  }

  else
  {
    v15 = a2 + v14;
    std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping*>(a2, a2 + v14, v8);
    v16 = a1[1];
    if (v15 != a3)
    {
      v17 = a1[1];
      do
      {
        std::allocator_traits<std::allocator<mlir::ODIE::Compiler::ImportMapping>>::construct[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping,mlir::ODIE::Compiler::ImportMapping const&,0>(v17, v15);
        v15 += 56;
        v17 += 56;
        v16 += 56;
      }

      while (v15 != a3);
    }

    a1[1] = v16;
  }
}

uint64_t std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping const*,mlir::ODIE::Compiler::ImportMapping*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      *a3 = *v5;
      std::string::operator=((a3 + 8), (v5 + 8));
      std::string::operator=((a3 + 32), (v5 + 32));
      a3 += 56;
      v5 += 56;
    }

    while (v5 != a2);
  }

  return a3;
}

void std::__stable_sort<std::_ClassicAlgPolicy,anonymous namespace::StaticizeDynamicCallPass::runOnOperation(void)::$_0 &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *>>(uint64_t a1, int *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  v62 = *MEMORY[0x277D85DE8];
  if (a3 < 2)
  {
    goto LABEL_2;
  }

  if (a3 == 2)
  {
    v8 = a2 - 14;
    v9 = *(a2 - 1);
    if ((v9 & 0x80u) != 0)
    {
      v9 = *(a2 - 2);
    }

    if (v9)
    {
      v10 = *(a1 + 55);
      if ((v10 & 0x80u) != 0)
      {
        v10 = *(a1 + 40);
      }

      if (!v10 || *v8 >= *a1)
      {
        goto LABEL_2;
      }
    }

    v11 = *MEMORY[0x277D85DE8];

    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(a1, v8);
    return;
  }

  if (a3 <= 0)
  {
    if (a1 == a2)
    {
      goto LABEL_2;
    }

    v19 = (a1 + 56);
    if ((a1 + 56) == a2)
    {
      goto LABEL_2;
    }

    v20 = 0;
    v21 = a1;
    while (1)
    {
      v22 = v21;
      v21 = v19;
      v23 = *(v22 + 111);
      v24 = *(v22 + 12);
      if (v23 >= 0)
      {
        v25 = *(v22 + 111);
      }

      else
      {
        v25 = *(v22 + 12);
      }

      if (v25)
      {
        v26 = *(v22 + 55);
        if ((v26 & 0x80u) != 0)
        {
          v26 = *(v22 + 5);
        }

        if (!v26)
        {
          goto LABEL_50;
        }

        v27 = *v21;
        if (*v21 >= *v22)
        {
          goto LABEL_50;
        }
      }

      else
      {
        v27 = *v19;
      }

      v28 = *(v22 + 8);
      *&v61 = *(v22 + 9);
      *(&v61 + 7) = *(v22 + 79);
      v57 = *(v22 + 87);
      *(v22 + 8) = 0;
      *(v22 + 9) = 0;
      v58 = v28;
      v59 = *(v22 + 11);
      LODWORD(v60) = v22[26];
      *(&v60 + 3) = *(v22 + 107);
      *(v22 + 10) = 0;
      *(v22 + 11) = 0;
      v29 = v20;
      *(v22 + 12) = 0;
      *(v22 + 13) = 0;
      while (1)
      {
        v30 = a1 + v29;
        *(a1 + v29 + 56) = *(a1 + v29);
        if (*(a1 + v29 + 87) < 0)
        {
          operator delete(*(v30 + 64));
        }

        *(v30 + 64) = *(v30 + 8);
        *(v30 + 80) = *(v30 + 24);
        *(v30 + 31) = 0;
        *(v30 + 8) = 0;
        if (*(v30 + 111) < 0)
        {
          operator delete(*(v30 + 88));
        }

        v31 = a1 + v29;
        v32 = *(a1 + v29 + 32);
        *(v30 + 104) = *(a1 + v29 + 48);
        *(v30 + 88) = v32;
        *(v31 + 55) = 0;
        *(v31 + 32) = 0;
        if (!v29)
        {
          break;
        }

        if (v25)
        {
          v33 = a1 + v29;
          v34 = *(a1 + v29 - 1);
          if ((v34 & 0x80u) != 0)
          {
            v34 = *(a1 + v29 - 16);
          }

          if (!v34 || v27 >= *(v31 - 56))
          {
            goto LABEL_45;
          }
        }

        v29 -= 56;
      }

      v33 = a1;
LABEL_45:
      *v33 = v27;
      if (*(v33 + 31) < 0)
      {
        operator delete(*(v31 + 8));
      }

      *(v31 + 8) = v58;
      *(v33 + 16) = v61;
      *(v33 + 23) = *(&v61 + 7);
      *(v33 + 31) = v57;
      if (*(v33 + 55) < 0)
      {
        operator delete(*(v31 + 32));
      }

      *(v31 + 32) = v59;
      *(v33 + 40) = v24;
      *(v33 + 48) = v60;
      *(v33 + 51) = *(&v60 + 3);
      *(v33 + 55) = v23;
LABEL_50:
      v19 = v21 + 14;
      v20 += 56;
      if (v21 + 14 == a2)
      {
        goto LABEL_2;
      }
    }
  }

  v14 = a4;
  v15 = a3 >> 1;
  v16 = (a1 + 56 * (a3 >> 1));
  if (a3 > a5)
  {
    v17 = a3 - v15;
    v18 = *MEMORY[0x277D85DE8];

    return;
  }

  v60 = 0;
  *&v61 = a4;
  *(&v61 + 1) = &v60;
  v60 = a3 >> 1;
  v35 = a3 - v15;
  v36 = v14 + 56 * v15;
  v60 = a3;
  v37 = v14 + 56 * a3;
  v38 = (a1 + 31);
  v39 = v36;
  while (v39 != v37)
  {
    v40 = *(v39 + 55);
    if ((v40 & 0x80u) != 0)
    {
      v40 = *(v39 + 40);
    }

    if (!v40)
    {
      v43 = *v39;
LABEL_68:
      *(v38 - 31) = v43;
      v47 = (v38 - 23);
      if (*v38 < 0)
      {
        operator delete(*v47);
      }

      v48 = *(v39 + 8);
      *(v38 - 7) = *(v39 + 24);
      *v47 = v48;
      *(v39 + 31) = 0;
      *(v39 + 8) = 0;
      if (v38[24] < 0)
      {
        operator delete(*(v38 + 1));
      }

      v49 = *(v39 + 32);
      *(v38 + 17) = *(v39 + 48);
      *(v38 + 1) = v49;
      *(v39 + 55) = 0;
      *(v39 + 32) = 0;
      v39 += 56;
      goto LABEL_73;
    }

    if (*(v14 + 55) >= 0)
    {
      v41 = *(v14 + 55);
    }

    else
    {
      v41 = *(v14 + 40);
    }

    v42 = *v14;
    if (v41)
    {
      v43 = *v39;
      if (*v39 < v42)
      {
        goto LABEL_68;
      }
    }

    *(v38 - 31) = v42;
    v44 = (v38 - 23);
    if (*v38 < 0)
    {
      operator delete(*v44);
    }

    v45 = *(v14 + 8);
    *(v38 - 7) = *(v14 + 24);
    *v44 = v45;
    *(v14 + 31) = 0;
    *(v14 + 8) = 0;
    if (v38[24] < 0)
    {
      operator delete(*(v38 + 1));
    }

    v46 = *(v14 + 32);
    *(v38 + 17) = *(v14 + 48);
    *(v38 + 1) = v46;
    *(v14 + 55) = 0;
    *(v14 + 32) = 0;
    v14 += 56;
LABEL_73:
    v38 += 56;
    if (v14 == v36)
    {
      while (v39 != v37)
      {
        *(v38 - 31) = *v39;
        if (*v38 < 0)
        {
          operator delete(*(v38 - 23));
        }

        v53 = v38 - 23;
        v54 = *(v39 + 8);
        *(v53 + 2) = *(v39 + 24);
        *v53 = v54;
        *(v39 + 31) = 0;
        *(v39 + 8) = 0;
        if (v38[24] < 0)
        {
          operator delete(*(v38 + 1));
        }

        v55 = *(v39 + 32);
        *(v38 + 17) = *(v39 + 48);
        *(v38 + 1) = v55;
        *(v39 + 55) = 0;
        *(v39 + 32) = 0;
        v39 += 56;
        v38 += 56;
      }

      goto LABEL_88;
    }
  }

  while (v14 != v36)
  {
    *(v38 - 31) = *v14;
    v50 = (v38 - 23);
    if (*v38 < 0)
    {
      operator delete(*v50);
    }

    v51 = *(v14 + 8);
    *(v38 - 7) = *(v14 + 24);
    *v50 = v51;
    *(v14 + 31) = 0;
    *(v14 + 8) = 0;
    if (v38[24] < 0)
    {
      operator delete(*(v38 + 1));
    }

    v52 = *(v14 + 32);
    *(v38 + 17) = *(v14 + 48);
    *(v38 + 1) = v52;
    *(v14 + 55) = 0;
    *(v14 + 32) = 0;
    v14 += 56;
    v38 += 56;
  }

LABEL_88:
  std::unique_ptr<mlir::ODIE::Compiler::ImportMapping,std::__destruct_n &>::~unique_ptr[abi:nn200100](&v61);
LABEL_2:
  v5 = *MEMORY[0x277D85DE8];
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(int *a1, int *a2)
{
  v15 = *MEMORY[0x277D85DE8];
  v3 = *a1;
  v4 = *(a1 + 1);
  *v14 = *(a1 + 2);
  *&v14[7] = *(a1 + 23);
  v5 = *(a1 + 31);
  *(a1 + 2) = 0;
  *(a1 + 3) = 0;
  v7 = a1 + 8;
  v6 = *(a1 + 4);
  *(a1 + 1) = 0;
  *v13 = *(a1 + 5);
  *&v13[7] = *(a1 + 47);
  v8 = *(a1 + 55);
  *(a1 + 4) = 0;
  *(a1 + 5) = 0;
  *(a1 + 6) = 0;
  *a1 = *a2;
  v9 = *(a2 + 2);
  *(a1 + 3) = *(a2 + 3);
  *(a1 + 2) = v9;
  *(a2 + 31) = 0;
  *(a2 + 8) = 0;
  if (*(a1 + 55) < 0)
  {
    operator delete(*v7);
  }

  v10 = *(a2 + 2);
  *(v7 + 2) = *(a2 + 6);
  *v7 = v10;
  *(a2 + 55) = 0;
  *(a2 + 32) = 0;
  *a2 = v3;
  if (*(a2 + 31) < 0)
  {
    operator delete(*(a2 + 1));
    v11 = *(a2 + 55);
    *(a2 + 1) = v4;
    *(a2 + 2) = *v14;
    *(a2 + 23) = *&v14[7];
    *(a2 + 31) = v5;
    if (v11 < 0)
    {
      operator delete(*(a2 + 4));
    }
  }

  else
  {
    *(a2 + 1) = v4;
    *(a2 + 2) = *v14;
    *(a2 + 23) = *&v14[7];
    *(a2 + 31) = v5;
  }

  *(a2 + 4) = v6;
  *(a2 + 5) = *v13;
  *(a2 + 47) = *&v13[7];
  *(a2 + 55) = v8;
  v12 = *MEMORY[0x277D85DE8];
}

uint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,anonymous namespace::StaticizeDynamicCallPass::runOnOperation(void)::$_0 &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *>>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (!a3)
  {
    return result;
  }

  v4 = a4;
  v7 = result;
  if (a3 == 2)
  {
    v68 = &v69;
    v10 = *(a2 - 1);
    if ((v10 & 0x80u) != 0)
    {
      v10 = *(a2 - 2);
    }

    if (v10)
    {
      if (*(result + 55) >= 0)
      {
        v11 = *(result + 55);
      }

      else
      {
        v11 = result[5];
      }

      v12 = *result;
      if (!v11 || (v13 = *(a2 - 14), v13 >= v12))
      {
        *a4 = v12;
        v14 = *(result + 1);
        *(a4 + 24) = result[3];
        *(a4 + 8) = v14;
        result[2] = 0;
        result[3] = 0;
        result[1] = 0;
        v15 = *(result + 2);
        *(a4 + 48) = result[6];
        *(a4 + 32) = v15;
        result[5] = 0;
        result[6] = 0;
        result[4] = 0;
        v69 = 1;
        *(a4 + 56) = *(a2 - 14);
        v16 = *(a2 - 3);
        *(a4 + 80) = *(a2 - 4);
        *(a4 + 64) = v16;
        *(a2 - 5) = 0;
        *(a2 - 4) = 0;
        *(a2 - 6) = 0;
        v17 = a2 - 3;
        v18 = *(a2 - 3);
        *(a4 + 104) = *(a2 - 1);
        *(a4 + 88) = v18;
LABEL_72:
        *v17 = 0;
        v17[1] = 0;
        v17[2] = 0;
        goto LABEL_77;
      }
    }

    else
    {
      v13 = *(a2 - 14);
    }

    *a4 = v13;
    v58 = *(a2 - 3);
    *(a4 + 24) = *(a2 - 4);
    *(a4 + 8) = v58;
    *(a2 - 5) = 0;
    *(a2 - 4) = 0;
    *(a2 - 6) = 0;
    v59 = *(a2 - 3);
    *(a4 + 48) = *(a2 - 1);
    *(a4 + 32) = v59;
    *(a2 - 2) = 0;
    *(a2 - 1) = 0;
    *(a2 - 3) = 0;
    v69 = 1;
    *(a4 + 56) = *result;
    v60 = *(result + 1);
    *(a4 + 80) = result[3];
    *(a4 + 64) = v60;
    result[2] = 0;
    result[3] = 0;
    result[1] = 0;
    v17 = result + 4;
    v61 = result[6];
    *(a4 + 88) = *(result + 2);
    *(a4 + 104) = v61;
    goto LABEL_72;
  }

  if (a3 == 1)
  {
    *a4 = *result;
    v8 = *(result + 1);
    *(a4 + 24) = result[3];
    *(a4 + 8) = v8;
    result[2] = 0;
    result[3] = 0;
    result[1] = 0;
    v9 = *(result + 2);
    *(a4 + 48) = result[6];
    *(a4 + 32) = v9;
    result[5] = 0;
    result[6] = 0;
    result[4] = 0;
    return result;
  }

  if (a3 <= 8)
  {
    if (result == a2)
    {
      return result;
    }

    v68 = &v69;
    *a4 = *result;
    v19 = *(result + 1);
    *(a4 + 24) = result[3];
    *(a4 + 8) = v19;
    result[2] = 0;
    result[3] = 0;
    result[1] = 0;
    v20 = *(result + 2);
    *(a4 + 48) = result[6];
    *(a4 + 32) = v20;
    result[5] = 0;
    result[6] = 0;
    result[4] = 0;
    v69 = 1;
    v21 = result + 7;
    if (result + 7 == a2)
    {
      goto LABEL_77;
    }

    v22 = 0;
    v23 = a4;
    while (1)
    {
      v24 = v21;
      v25 = *(v7 + 111);
      if ((v25 & 0x80u) != 0)
      {
        v25 = v7[12];
      }

      if (!v25)
      {
        break;
      }

      if (*(v23 + 55) >= 0)
      {
        v26 = *(v23 + 55);
      }

      else
      {
        v26 = *(v23 + 40);
      }

      v27 = *v24;
      if (v26)
      {
        v28 = *v23;
        if (v27 < *v23)
        {
          goto LABEL_28;
        }
      }

      *(v23 + 56) = v27;
      v29 = *(v7 + 4);
      *(v23 + 80) = v7[10];
      *(v23 + 64) = v29;
      v7[9] = 0;
      v7[10] = 0;
      v7[8] = 0;
      v30 = *(v7 + 11);
      *(v23 + 104) = v7[13];
      *(v23 + 88) = v30;
      v7[12] = 0;
      v7[13] = 0;
      v7[11] = 0;
      ++v69;
LABEL_50:
      v23 += 56;
      v21 = v24 + 7;
      v22 += 56;
      v7 = v24;
      if (v24 + 7 == a2)
      {
        goto LABEL_77;
      }
    }

    v28 = *v23;
LABEL_28:
    *(v23 + 56) = v28;
    *(v23 + 64) = *(v23 + 8);
    *(v23 + 80) = *(v23 + 24);
    *(v23 + 8) = 0;
    *(v23 + 16) = 0;
    *(v23 + 88) = *(v23 + 32);
    *(v23 + 104) = *(v23 + 48);
    *(v23 + 24) = 0;
    *(v23 + 32) = 0;
    ++v69;
    v31 = v4;
    *(v23 + 40) = 0;
    *(v23 + 48) = 0;
    if (v23 != v4)
    {
      v32 = v22;
      v31 = v23;
      do
      {
        v33 = v4 + v32;
        v34 = *(v7 + 111);
        if ((v34 & 0x80u) != 0)
        {
          v34 = v7[12];
        }

        if (v34)
        {
          v35 = *(v33 - 1);
          if ((v35 & 0x80u) != 0)
          {
            v35 = *(v33 - 16);
          }

          if (!v35)
          {
            goto LABEL_45;
          }

          v36 = *(v33 - 56);
          if (*v24 >= v36)
          {
            v31 = v4 + v32;
            goto LABEL_45;
          }
        }

        else
        {
          v36 = *(v33 - 56);
        }

        v37 = v4 + v32;
        *(v4 + v32) = v36;
        if (*(v4 + v32 + 31) < 0)
        {
          operator delete(*(v37 + 8));
        }

        *(v37 + 8) = *(v37 - 48);
        *(v37 + 24) = *(v37 - 32);
        *(v37 - 25) = 0;
        *(v37 - 48) = 0;
        if (*(v37 + 55) < 0)
        {
          operator delete(*(v37 + 32));
        }

        v31 -= 56;
        v38 = v4 + v32;
        *(v37 + 32) = *(v4 + v32 - 24);
        *(v37 + 48) = *(v4 + v32 - 8);
        *(v38 - 1) = 0;
        *(v38 - 24) = 0;
        v32 -= 56;
      }

      while (v32);
      v31 = v4;
    }

LABEL_45:
    *v31 = *v24;
    if (*(v31 + 31) < 0)
    {
      operator delete(*(v31 + 8));
    }

    v39 = *(v7 + 4);
    *(v31 + 24) = v7[10];
    *(v31 + 8) = v39;
    *(v7 + 87) = 0;
    *(v7 + 64) = 0;
    if (*(v31 + 55) < 0)
    {
      operator delete(*(v31 + 32));
    }

    v40 = *(v7 + 11);
    *(v31 + 48) = v7[13];
    *(v31 + 32) = v40;
    *(v7 + 111) = 0;
    *(v7 + 88) = 0;
    goto LABEL_50;
  }

  v41 = 7 * (a3 >> 1);
  v42 = &result[v41];
  v43 = 0;
  v67 = v4;
  v68 = &v69;
  v69 = 0;
  v44 = &v7[v41];
  while (v44 != a2)
  {
    v45 = *(v44 + 55);
    if ((v45 & 0x80u) != 0)
    {
      v45 = v44[5];
    }

    if (!v45)
    {
      v48 = *v44;
LABEL_64:
      *v4 = v48;
      v51 = *(v44 + 1);
      *(v4 + 24) = v44[3];
      *(v4 + 8) = v51;
      v44[2] = 0;
      v44[3] = 0;
      v44[1] = 0;
      v52 = *(v44 + 2);
      *(v4 + 48) = v44[6];
      *(v4 + 32) = v52;
      v44[5] = 0;
      v44[6] = 0;
      v44[4] = 0;
      v69 = ++v43;
      v44 += 7;
      goto LABEL_65;
    }

    if (*(v7 + 55) >= 0)
    {
      v46 = *(v7 + 55);
    }

    else
    {
      v46 = v7[5];
    }

    v47 = *v7;
    if (v46)
    {
      v48 = *v44;
      if (*v44 < v47)
      {
        goto LABEL_64;
      }
    }

    *v4 = v47;
    v49 = *(v7 + 1);
    *(v4 + 24) = v7[3];
    *(v4 + 8) = v49;
    v7[2] = 0;
    v7[3] = 0;
    v7[1] = 0;
    v50 = *(v7 + 2);
    *(v4 + 48) = v7[6];
    *(v4 + 32) = v50;
    v7[5] = 0;
    v7[6] = 0;
    v7[4] = 0;
    v69 = ++v43;
    v7 += 7;
LABEL_65:
    v4 += 56;
    if (v7 == v42)
    {
      if (v44 == a2)
      {
        goto LABEL_77;
      }

      v53 = 0;
      do
      {
        v54 = &v44[v53];
        v55 = v4 + v53 * 8;
        *v55 = v44[v53];
        v56 = *&v44[v53 + 1];
        *(v55 + 24) = v44[v53 + 3];
        *(v55 + 8) = v56;
        v54[2] = 0;
        v54[3] = 0;
        v54[1] = 0;
        v57 = *&v44[v53 + 4];
        *(v55 + 48) = v44[v53 + 6];
        *(v55 + 32) = v57;
        v54[5] = 0;
        v54[6] = 0;
        v54[4] = 0;
        ++v43;
        v53 += 7;
      }

      while (v54 + 7 != a2);
      goto LABEL_76;
    }
  }

  if (v7 == v42)
  {
    goto LABEL_77;
  }

  v62 = 0;
  do
  {
    v63 = v4 + v62 * 8;
    v64 = &v7[v62];
    *v63 = v7[v62];
    v65 = *&v7[v62 + 1];
    *(v63 + 24) = v7[v62 + 3];
    *(v63 + 8) = v65;
    v64[2] = 0;
    v64[3] = 0;
    v64[1] = 0;
    v66 = *&v7[v62 + 4];
    *(v63 + 48) = v7[v62 + 6];
    *(v63 + 32) = v66;
    v64[5] = 0;
    v64[6] = 0;
    v64[4] = 0;
    ++v43;
    v62 += 7;
  }

  while (v64 + 7 != v42);
LABEL_76:
  v69 = v43;
LABEL_77:
  v67 = 0;
  return std::unique_ptr<mlir::ODIE::Compiler::ImportMapping,std::__destruct_n &>::~unique_ptr[abi:nn200100](&v67);
}

void std::__inplace_merge<std::_ClassicAlgPolicy,anonymous namespace::StaticizeDynamicCallPass::runOnOperation(void)::$_0 &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *>>(uint64_t a1, int *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a5)
  {
    return;
  }

  v8 = a5;
  while (a4 > a7 && v8 > a7)
  {
    if (!a4)
    {
      return;
    }

    v12 = *(a2 + 55);
    if ((v12 & 0x80u) != 0)
    {
      v12 = *(a2 + 5);
    }

    if (v12)
    {
      while (1)
      {
        v13 = *(a1 + 55);
        if ((v13 & 0x80u) != 0)
        {
          v13 = *(a1 + 40);
        }

        if (v13 && *a2 < *a1)
        {
          break;
        }

        a1 += 56;
        if (!--a4)
        {
          return;
        }
      }
    }

    if (a4 >= v8)
    {
      if (a4 == 1)
      {

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(a1, a2);
        return;
      }

      v22 = a4 / 2;
      v16 = a1 + 56 * (a4 / 2);
      if (a3 == a2)
      {
        v15 = a3;
      }

      else
      {
        v23 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
        v24 = *(v16 + 55);
        if ((v24 & 0x80u) != 0)
        {
          v24 = *(v16 + 40);
        }

        v15 = a2;
        do
        {
          v25 = v23 >> 1;
          v26 = &v15[14 * (v23 >> 1)];
          v27 = *(v26 + 55);
          if ((v27 & 0x80u) != 0)
          {
            v27 = *(v26 + 5);
          }

          if (!v27 || v24 && *v26 < *v16)
          {
            v15 = v26 + 14;
            v25 = v23 + ~v25;
          }

          v23 = v25;
        }

        while (v25);
      }

      v14 = 0x6DB6DB6DB6DB6DB7 * ((v15 - a2) >> 3);
    }

    else
    {
      v14 = v8 / 2;
      v15 = &a2[14 * (v8 / 2)];
      v16 = a2;
      if (a2 != a1)
      {
        v17 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
        v18 = *(v15 + 55);
        if ((v18 & 0x80u) != 0)
        {
          v18 = *(v15 + 5);
        }

        v16 = a1;
        do
        {
          v19 = v17 >> 1;
          if (v18)
          {
            v20 = v16 + 56 * v19;
            v21 = *(v20 + 55);
            if ((v21 & 0x80u) != 0)
            {
              v21 = *(v20 + 40);
            }

            if (!v21 || *v15 >= *v20)
            {
              v16 = v20 + 56;
              v19 = v17 + ~v19;
            }
          }

          v17 = v19;
        }

        while (v19);
      }

      v22 = 0x6DB6DB6DB6DB6DB7 * ((v16 - a1) >> 3);
    }

    v28 = v15;
    if (v16 != a2)
    {
      v28 = v16;
      if (v15 != a2)
      {
        v79 = v14;
        v80 = v22;
        v29 = a3;
        v81 = a7;
        v82 = a6;
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(v16, a2);
        v28 = (v16 + 56);
        v30 = a2 + 14;
        for (i = v29; v30 != v15; v30 += 14)
        {
          if (v28 == a2)
          {
            a2 = v30;
          }

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(v28, v30);
          v28 += 14;
        }

        if (v28 != a2)
        {
          v31 = v28;
          v32 = a2;
          do
          {
            while (1)
            {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &,std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *> &>(v31, a2);
              v31 += 14;
              a2 += 14;
              if (a2 == v15)
              {
                break;
              }

              if (v31 == v32)
              {
                v32 = a2;
              }
            }

            a2 = v32;
          }

          while (v31 != v32);
        }

        a6 = v82;
        a3 = i;
        v22 = v80;
        a7 = v81;
        v14 = v79;
      }
    }

    a4 -= v22;
    v8 -= v14;
    if (v22 + v14 >= a4 + v8)
    {
      v37 = v22;
      v38 = a4;
      v39 = v14;
      v34 = a6;
      v40 = a6;
      v36 = a7;
      v15 = v16;
      v8 = v39;
      a4 = v37;
      a3 = v28;
    }

    else
    {
      v33 = a3;
      v34 = a6;
      v35 = a6;
      v36 = a7;
      a3 = v33;
      a1 = v28;
    }

    a2 = v15;
    a7 = v36;
    a6 = v34;
    if (!v8)
    {
      return;
    }
  }

  v85[0] = a6;
  v85[1] = &v86;
  v86 = 0;
  if (a4 > v8)
  {
    v84 = a3;
    if (a3 == a2)
    {
      goto LABEL_121;
    }

    v41 = 0;
    v42 = 0;
    v43 = a6;
    v44 = a3;
    do
    {
      v45 = a6 + v41 * 4;
      v46 = &a2[v41];
      *v45 = a2[v41];
      v47 = *&a2[v41 + 2];
      *(v45 + 24) = *&a2[v41 + 6];
      *(v45 + 8) = v47;
      *(v46 + 2) = 0;
      *(v46 + 3) = 0;
      *(v46 + 1) = 0;
      v48 = *&a2[v41 + 8];
      *(v45 + 48) = *&a2[v41 + 12];
      *(v45 + 32) = v48;
      *(v46 + 5) = 0;
      *(v46 + 6) = 0;
      *(v46 + 4) = 0;
      ++v42;
      v43 += 56;
      v41 += 14;
    }

    while (v46 + 14 != a3);
    v86 = v42;
    v49 = a3 - 25;
    v50 = a6 + v41 * 4;
    while (1)
    {
      if (a2 == a1)
      {
        std::__move_impl<std::_ClassicAlgPolicy>::operator()[abi:nn200100]<std::reverse_iterator<mlir::ODIE::Compiler::ImportMapping *>,std::reverse_iterator<mlir::ODIE::Compiler::ImportMapping *>,std::reverse_iterator<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *>>>(v87, v43, v50, a6, a6, v84, v44);
        goto LABEL_121;
      }

      v51 = a6;
      v52 = a2 - 14;
      v54 = (v50 - 1);
      v53 = *(v50 - 1);
      if ((v53 & 0x80u) != 0)
      {
        v53 = *(v50 - 16);
      }

      if (!v53)
      {
        break;
      }

      if (*(a2 - 1) >= 0)
      {
        v55 = *(a2 - 1);
      }

      else
      {
        v55 = *(a2 - 2);
      }

      v56 = *(v50 - 56);
      if (v55)
      {
        v57 = *v52;
        if (v56 < *v52)
        {
          goto LABEL_83;
        }
      }

      *(v49 - 31) = v56;
      v58 = (v49 - 23);
      if (*v49 < 0)
      {
        operator delete(*v58);
      }

      v59 = *(v50 - 48);
      *(v49 - 7) = *(v50 - 32);
      *v58 = v59;
      *(v50 - 25) = 0;
      *(v50 - 48) = 0;
      if (v49[24] < 0)
      {
        operator delete(*(v49 + 1));
      }

      v60 = (v50 - 24);
      v61 = *(v50 - 24);
      *(v49 + 17) = *(v50 - 8);
      *(v49 + 1) = v61;
      v50 -= 56;
LABEL_88:
      a6 = v51;
      *v54 = 0;
      *v60 = 0;
      v44 -= 56;
      v49 -= 56;
      if (v50 == v51)
      {
        goto LABEL_121;
      }
    }

    v57 = *v52;
LABEL_83:
    *(v49 - 31) = v57;
    v62 = (v49 - 23);
    if (*v49 < 0)
    {
      operator delete(*v62);
    }

    v63 = *(a2 - 3);
    *(v49 - 7) = *(a2 - 4);
    *v62 = v63;
    *(a2 - 25) = 0;
    *(a2 - 48) = 0;
    if (v49[24] < 0)
    {
      operator delete(*(v49 + 1));
    }

    v60 = a2 - 6;
    v54 = a2 - 1;
    v64 = *(a2 - 6);
    *(v49 + 17) = *(a2 - 1);
    *(v49 + 1) = v64;
    a2 -= 14;
    goto LABEL_88;
  }

  if (a1 == a2)
  {
    goto LABEL_121;
  }

  v65 = a3;
  v66 = 0;
  v67 = a6;
  v68 = a1;
  do
  {
    *v67 = *v68;
    v69 = *(v68 + 8);
    *(v67 + 24) = *(v68 + 24);
    *(v67 + 8) = v69;
    *(v68 + 16) = 0;
    *(v68 + 24) = 0;
    *(v68 + 8) = 0;
    v70 = *(v68 + 32);
    *(v67 + 48) = *(v68 + 48);
    *(v67 + 32) = v70;
    *(v68 + 40) = 0;
    *(v68 + 48) = 0;
    *(v68 + 32) = 0;
    ++v66;
    v68 += 56;
    v67 += 56;
  }

  while (v68 != a2);
  v86 = v66;
  while (a2 != v65)
  {
    v71 = *(a2 + 55);
    if ((v71 & 0x80u) != 0)
    {
      v71 = *(a2 + 5);
    }

    if (!v71)
    {
      v74 = *a2;
LABEL_109:
      *a1 = v74;
      if (*(a1 + 31) < 0)
      {
        operator delete(*(a1 + 8));
      }

      v77 = *(a2 + 2);
      *(a1 + 24) = *(a2 + 3);
      *(a1 + 8) = v77;
      *(a2 + 31) = 0;
      *(a2 + 8) = 0;
      if (*(a1 + 55) < 0)
      {
        operator delete(*(a1 + 32));
      }

      v78 = *(a2 + 2);
      *(a1 + 48) = *(a2 + 6);
      *(a1 + 32) = v78;
      *(a2 + 55) = 0;
      *(a2 + 32) = 0;
      a2 += 14;
      goto LABEL_114;
    }

    if (*(a6 + 55) >= 0)
    {
      v72 = *(a6 + 55);
    }

    else
    {
      v72 = *(a6 + 40);
    }

    v73 = *a6;
    if (v72)
    {
      v74 = *a2;
      if (*a2 < v73)
      {
        goto LABEL_109;
      }
    }

    *a1 = v73;
    if (*(a1 + 31) < 0)
    {
      operator delete(*(a1 + 8));
    }

    v75 = *(a6 + 8);
    *(a1 + 24) = *(a6 + 24);
    *(a1 + 8) = v75;
    *(a6 + 31) = 0;
    *(a6 + 8) = 0;
    if (*(a1 + 55) < 0)
    {
      operator delete(*(a1 + 32));
    }

    v76 = *(a6 + 32);
    *(a1 + 48) = *(a6 + 48);
    *(a1 + 32) = v76;
    *(a6 + 55) = 0;
    *(a6 + 32) = 0;
    a6 += 56;
LABEL_114:
    a1 += 56;
    if (v67 == a6)
    {
      goto LABEL_121;
    }
  }

  std::__move_impl<std::_ClassicAlgPolicy>::operator()[abi:nn200100]<mlir::ODIE::Compiler::ImportMapping *,mlir::ODIE::Compiler::ImportMapping *,mlir::ODIE::Compiler::ImportMapping *>(a6, v67, a1);
LABEL_121:
  std::unique_ptr<mlir::ODIE::Compiler::ImportMapping,std::__destruct_n &>::~unique_ptr[abi:nn200100](v85);
}

uint64_t *std::unique_ptr<mlir::ODIE::Compiler::ImportMapping,std::__destruct_n &>::~unique_ptr[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = a1[1];
    if (*v3)
    {
      v4 = 0;
      v5 = (v2 + 31);
      do
      {
        if (v5[24] < 0)
        {
          operator delete(*(v5 + 1));
        }

        if (*v5 < 0)
        {
          operator delete(*(v5 - 23));
        }

        ++v4;
        v5 += 56;
      }

      while (v4 < *v3);
    }
  }

  return a1;
}

void std::__move_impl<std::_ClassicAlgPolicy>::operator()[abi:nn200100]<std::reverse_iterator<mlir::ODIE::Compiler::ImportMapping *>,std::reverse_iterator<mlir::ODIE::Compiler::ImportMapping *>,std::reverse_iterator<std::__wrap_iter<mlir::ODIE::Compiler::ImportMapping *>>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v9 = a3;
  if (a3 != a5)
  {
    v13 = 0;
    do
    {
      v14 = v9 + v13;
      v15 = a7 + v13;
      *(a7 + v13 - 56) = *(v9 + v13 - 56);
      v16 = (a7 + v13 - 48);
      if (*(a7 + v13 - 25) < 0)
      {
        operator delete(*v16);
      }

      v17 = *(v14 - 48);
      *(a7 + v13 - 32) = *(v14 - 32);
      *v16 = v17;
      *(v14 - 25) = 0;
      *(v14 - 48) = 0;
      v18 = (v15 - 24);
      if (*(v15 - 1) < 0)
      {
        operator delete(*v18);
      }

      v19 = v9 + v13;
      v20 = *(v9 + v13 - 24);
      *(v15 - 8) = *(v9 + v13 - 8);
      *v18 = v20;
      *(v19 - 1) = 0;
      *(v19 - 24) = 0;
      v13 -= 56;
    }

    while (v9 + v13 != a5);
    a7 += v13;
    v9 += v13;
  }

  *a1 = a2;
  a1[1] = v9;
  a1[2] = a6;
  a1[3] = a7;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZL20spliceGraphsFromFileNS1_8LocationENS_9StringRefERNS1_11SymbolTableESD_NS1_12FunctionTypeEPNS1_5BlockEE3__1NS1_4ODIE8Compiler6CoreML7GraphOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionESI_EE5valuesr3std7is_sameIT3_S2_EE5valueESU_E4typeES4_OT1_EUlS4_E_EES2_lS4_(const void ****a1, uint64_t a2)
{
  v45 = *MEMORY[0x277D85DE8];
  result = 1;
  if (!a2 || *(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
  {
    goto LABEL_32;
  }

  v5 = *a1;
  Attr = mlir::Operation::getAttr(a2, "sym_name", 8uLL);
  if (*(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    v7 = Attr;
  }

  else
  {
    v7 = 0;
  }

  v8 = *(v7 + 24);
  if (v8 == (*v5)[1] && (!v8 || !memcmp(*(v7 + 16), **v5, v8)) && *v5[1] != *(*(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1) + 16) + 8))
  {
    v38 = 257;
    mlir::Operation::emitError(&v41, a2, v37);
    if (v41)
    {
      mlir::Diagnostic::operator<<<11ul>(v42, "expected @");
    }

    v9 = mlir::Operation::getAttr(a2, "sym_name", 8uLL);
    if (v9)
    {
      if (*(*v9 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        v10 = v9;
      }

      else
      {
        v10 = 0;
      }
    }

    else
    {
      v10 = 0;
    }

    if (v41)
    {
      v39 = 0;
      v40 = v10;
      v26 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v43, &v39, 1);
      v27 = v43 + 24 * v44;
      v28 = *v26;
      *(v27 + 16) = *(v26 + 16);
      *v27 = v28;
      ++v44;
      if (v41)
      {
        mlir::Diagnostic::operator<<<21ul>(v42, " signature to match ");
        if (v41)
        {
          v29 = *v5[1];
          v39 = 4;
          v40 = v29;
          v30 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v43, &v39, 1);
          v31 = v43 + 24 * v44;
          v32 = *v30;
          *(v31 + 16) = *(v30 + 16);
          *v31 = v32;
          ++v44;
          if (v41)
          {
            mlir::Diagnostic::operator<<<10ul>(v42, " but got ");
            if (v41)
            {
              v33 = *(*(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1) + 16) + 8);
              v39 = 4;
              v40 = v33;
              v34 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v43, &v39, 1);
              v35 = v43 + 24 * v44;
              v36 = *v34;
              *(v35 + 16) = *(v34 + 16);
              *v35 = v36;
              ++v44;
            }
          }
        }
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v41);
    result = 0;
    goto LABEL_32;
  }

  v11 = mlir::Operation::clone(a2, 3);
  v12 = v11;
  if (*(v11 + 2))
  {
    *(v11 + 2) = 0;
    v14 = *v11;
    v13 = *(v11 + 1);
    *v13 = *v11;
    *(v14 + 8) = v13;
    *v11 = 0;
    *(v11 + 1) = 0;
  }

  v15 = mlir::Operation::getAttr(v11, "sym_name", 8uLL);
  if (v15)
  {
    if (*(*v15 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    {
      v16 = v15;
    }

    else
    {
      v16 = 0;
    }
  }

  else
  {
    v16 = 0;
  }

  v17 = mlir::SymbolTable::insert(v5[3], v12, *(*v5[4] + 5));
  v18 = v5[2];
  v37[0] = 0;
  v19 = llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::LookupBucketFor<mlir::StringAttr>(*v18, *(v18 + 16), v16, v37);
  v20 = v37[0];
  if ((v19 & 1) == 0)
  {
    v41 = v37[0];
    v21 = *(v18 + 8);
    v22 = *(v18 + 16);
    if (4 * v21 + 4 >= 3 * v22)
    {
      v22 *= 2;
    }

    else if (v22 + ~v21 - *(v18 + 12) > v22 >> 3)
    {
LABEL_26:
      *(v18 + 8) = v21 + 1;
      if (*v20 != -4096)
      {
        --*(v18 + 12);
      }

      *v20 = v16;
      v20[1] = 0;
      goto LABEL_29;
    }

    llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::grow(v18, v22);
    llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::LookupBucketFor<mlir::StringAttr>(*v18, *(v18 + 16), v16, &v41);
    v21 = *(v18 + 8);
    v20 = v41;
    goto LABEL_26;
  }

LABEL_29:
  v20[1] = v17;
  *(v12 + 16 * ((*(v12 + 44) >> 23) & 1) + 104) = *(**(***(v12 + 24) + 32) + 608);
  v23 = v5[5];
  v24 = *(v23 + 2);
  if (v24 >= *(v23 + 3))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v5[5], v23 + 2, v24 + 1, 8);
    LODWORD(v24) = *(v23 + 2);
  }

  *(*v23 + v24) = v12;
  ++*(v23 + 2);
  result = 1;
LABEL_32:
  v25 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::LookupBucketFor<mlir::StringAttr>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::LookupBucketFor<mlir::StringAttr>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          v21[1] = v19[1];
          ++*(a1 + 8);
        }

        v19 += 2;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZL20spliceGraphsFromFileNS2_8LocationEN4llvm9StringRefERNS2_11SymbolTableESA_NS2_12FunctionTypeEPNS2_5BlockEE3__0NS2_17FlatSymbolRefAttrENS2_9AttributeESH_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISL_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSI_E_NS_9allocatorISW_EEFNSN_INSO_ISI_SP_EEEESI_EE7__cloneEPNS0_6__baseIS11_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA5B98;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZL20spliceGraphsFromFileNS2_8LocationEN4llvm9StringRefERNS2_11SymbolTableESA_NS2_12FunctionTypeEPNS2_5BlockEE3__0NS2_17FlatSymbolRefAttrENS2_9AttributeESH_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISL_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSI_E_NS_9allocatorISW_EEFNSN_INSO_ISI_SP_EEEESI_EEclEOSI_@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  v4 = *a2;
  if (*(**a2 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id && !*(v4 + 24))
  {
    v6 = *(result + 8);
    v7 = *v6;
    v8 = *(v6 + 16);
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::doFind<mlir::StringAttr>(*v6, *(v6 + 16), *(v4 + 8));
    if (result)
    {
      v10 = result == v7 + 16 * v8;
    }

    else
    {
      v10 = 1;
    }

    if (!v10)
    {
      result = mlir::SymbolRefAttr::get(*(result + 8), 0, 0, v9);
      v4 = result;
    }

    *a3 = v4;
    v5 = 1;
    *(a3 + 8) = 1;
  }

  else
  {
    v5 = 0;
    *a3 = 0;
  }

  *(a3 + 16) = v5;
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>,mlir::StringAttr,mlir::StringAttr,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,mlir::StringAttr>>::doFind<mlir::StringAttr>(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    v3 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v4 = *(a1 + 16 * v3);
    if (v4 == a3)
    {
      return a1 + 16 * v3;
    }

    v6 = 1;
    while (v4 != -4096)
    {
      v7 = v3 + v6++;
      v3 = v7 & (a2 - 1);
      v4 = *(a1 + 16 * v3);
      if (v4 == a3)
      {
        return a1 + 16 * v3;
      }
    }
  }

  return 0;
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::TypePropagation>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::TypePropagation::~TypePropagation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::TypePropagation *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::TypePropagation::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::TypePropagation *this)
{
  v26 = *MEMORY[0x277D85DE8];
  v2 = (*(this + 5) & 0xFFFFFFFFFFFFFFF8);
  v8[0] = 0;
  v8[1] = 0;
  v9 = 0;
  mlir::SymbolTableCollection::getSymbolTable(v8, v2);
  v6[0] = 0;
  v6[1] = 0;
  v7 = 0;
  v11 = &__src + 8;
  *&__src = 0x600000000;
  v10[0] = &v11;
  v10[1] = v8;
  v10[2] = v6;
  if (v11 != &__src + 8)
  {
    free(v11);
  }

  v3 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v4 = *(***(v3 + 24) + 32);
  __src = 0u;
  v13 = 0u;
  v11 = v4;
  v14 = v16;
  v15 = 0x600000000;
  v16[6] = 0;
  v16[7] = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 40;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 40;
  v5 = *(***(v3 + 24) + 32);
  operator new();
}

uint64_t *llvm::function_ref<void ()(mlir::Operation *,BOOL)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::SymbolUserMap::SymbolUserMap(mlir::SymbolTableCollection &,mlir::Operation *)::{lambda(mlir::Operation *,BOOL)#1}>(uint64_t *result, uint64_t a2)
{
  v2 = (((a2 + 16 * ((*(a2 + 44) >> 23) & 1) + ((*(a2 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40));
  if (*v2 != v2)
  {
    v4 = result;
    for (i = v2[1]; i != v2; i = i[1])
    {
      v6 = i - 1;
      if (!i)
      {
        v6 = 0;
      }

      if (v6[4] != v6 + 4)
      {
        break;
      }
    }

    if (i != v2)
    {
      v7 = result[2];
      v8 = i - 1;
      if (!i)
      {
        v8 = 0;
      }

      result = v8[5];
      v23[0] = ((a2 + 16 * ((*(a2 + 44) >> 23) & 1) + ((*(a2 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40);
      v23[1] = i;
      for (j = result; j; result = j)
      {
        mlir::SymbolTable::getSymbolUses(result, &__p);
        v9 = __p;
        v10 = v21;
        while (v9 != v10)
        {
          v12 = *v4;
          v11 = v4[1];
          *(v12 + 8) = 0;
          mlir::SymbolTableCollection::lookupSymbolIn(v11, a2, v9[1], v12);
          v13 = *(*v4 + 8);
          if (v13)
          {
            v14 = **v4;
            v15 = 8 * v13;
            do
            {
              v16 = *v14++;
              v19 = v16;
              v17 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::operator[](v7, &v19);
              v18 = *v9;
              llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>::insert(v17, &v18);
              v15 -= 8;
            }

            while (v15);
          }

          v9 += 2;
        }

        if (v22 == 1 && __p)
        {
          v21 = __p;
          operator delete(__p);
        }

        mlir::Region::OpIterator::operator++(v23);
      }
    }
  }

  return result;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::InferrableTypeUsingCastOpPattern::~InferrableTypeUsingCastOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InferrableTypeUsingCastOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::InferrableTypeUsingCastOpPattern::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InferrableTypeUsingCastOpPattern *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v22 = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x7FFFFF) != 0)
  {
    v5 = "Operations with regions are not supported";
    goto LABEL_3;
  }

  if (!mlir::OpInterface<mlir::InferShapedTypeOpInterface,mlir::detail::InferShapedTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2) && !mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2) && !mlir::OpInterface<mlir::ODIE::Compiler::CoreML::KernelTypeInference,mlir::ODIE::Compiler::CoreML::detail::KernelTypeInferenceInterfaceTraits>::getInterfaceFor(a2) && !mlir::OpInterface<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,mlir::ODIE::Compiler::CoreML::detail::InferTypeAndAttributeOpInferfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    v5 = "Not a supported op type";
LABEL_3:
    v18 = v5;
    v20[8] = 259;
    v13[0] = &v18;
    v6 = *(a3 + 2);
    if (v6 && v6[2] == 1)
    {
      (*(*v6 + 88))(v6, *(a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v13);
    }

    v7 = 0;
    goto LABEL_21;
  }

  v7 = v21;
  if (v21 == 1)
  {
    v8 = *(a2 + 9);
    v9 = a2 - 16;
    if (!v8)
    {
      v9 = 0;
    }

    v13[0] = v9;
    v13[1] = 0;
    v13[2] = v9;
    v13[3] = v8;
    mlir::TypeRange::TypeRange<mlir::ResultRange>(v17, v13);
    v14 = v16;
    v15 = 0x600000000;
    if (v19)
    {
      llvm::SmallVectorImpl<mlir::Value>::operator=(&v14, &v18);
    }

    AttrDictionary = mlir::Operation::getAttrDictionary(a2);
    if (v14 != v16)
    {
      free(v14);
    }
  }

  if (v21 == 1 && v18 != v20)
  {
    free(v18);
  }

LABEL_21:
  v11 = *MEMORY[0x277D85DE8];
  return v7;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::UsesShapeCastOpPattern::matchCastInputs(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::UsesShapeCastOpPattern *this, mlir::Operation *a2)
{
  v42 = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v4 = *(a2 + 9);
    v5 = *(a2 + 17);
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  v37 = v39;
  v38 = 0x600000000;
  llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v37, v4, 0, v4, v5);
  v6 = v37;
  if (!v38)
  {
    if ((*(a2 + 46) & 0x80) == 0)
    {
      goto LABEL_43;
    }

    v26 = 0;
LABEL_34:
    v27 = *(a2 + 17);
    if (v26 == v27)
    {
      v28 = *(a2 + 9);
      v40 = v6 & 0xFFFFFFFFFFFFFFF9;
      v41 = 0;
      if (!v27)
      {
        goto LABEL_43;
      }

      v29 = (v28 + 24);
      v30 = 1;
      while (*v29 == mlir::ValueRange::dereference_iterator(&v40, v30 - 1))
      {
        v41 = v30;
        v31 = v30 + 1;
        v29 += 4;
        if (v26 == v30++)
        {
          v33 = v31 - 1;
          v34 = v33;
          goto LABEL_44;
        }
      }
    }

    goto LABEL_47;
  }

  v7 = v37 + 8 * v38;
  do
  {
    v8 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((*(*v6 + 8) & 0xFFFFFFFFFFFFFFF8));
    if (v8)
    {
      v10 = v8;
      v11 = v9;
      if ((*(v9 + 16))(v9, v8))
      {
        v12 = (*(v11 + 24))(v11, v10);
        if (!v13)
        {
          goto LABEL_29;
        }

        v14 = 8 * v13;
        while (*v12 != 0x8000000000000000)
        {
          ++v12;
          v14 -= 8;
          if (!v14)
          {
            goto LABEL_29;
          }
        }
      }
    }

    v15 = *v6;
    if ((~*(*v6 + 8) & 7) == 0)
    {
      v15 = 0;
    }

    if (v15)
    {
      v16 = *(v15 + 8) & 7;
      if (v16 == 6)
      {
        v17 = v15 + 24 * *(v15 + 16);
        v18 = v17 + 120;
        if (v17 == -120)
        {
          goto LABEL_29;
        }
      }

      else
      {
        v18 = v15 + 16 * v16 + 16;
      }

      if (*(*(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TransformCastOp,void>::id)
      {
        v19 = (*(*(*(v18 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v19)
        {
          v20 = *v19;
          v21 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
          v22 = mlir::detail::InterfaceMap::lookup(v20 + 8, v21);
        }

        else
        {
          v22 = 0;
        }

        if ((*(v22 + 16))(v22, v19))
        {
          v23 = (*(v22 + 24))(v22, v19);
          if (v24)
          {
            v25 = 8 * v24;
            while (*v23 != 0x8000000000000000)
            {
              ++v23;
              v25 -= 8;
              if (!v25)
              {
                goto LABEL_28;
              }
            }
          }

          else
          {
LABEL_28:
            *v6 = *(*(v18 + 72) + 24);
          }
        }
      }
    }

LABEL_29:
    v6 += 8;
  }

  while (v6 != v7);
  v26 = v38;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v6 = v37;
    goto LABEL_34;
  }

  if (!v38)
  {
LABEL_43:
    v26 = 0;
    v33 = 0;
    v34 = 0;
LABEL_44:
    if (v34 == v26 && v33 == v26)
    {
      v35 = 0;
      *this = 0;
      goto LABEL_50;
    }
  }

LABEL_47:
  *this = this + 16;
  *(this + 1) = 0x600000000;
  if (v38)
  {
    llvm::SmallVectorImpl<mlir::Value>::operator=(this, &v37);
  }

  v35 = 1;
LABEL_50:
  *(this + 64) = v35;
  if (v37 != v39)
  {
    free(v37);
  }

  v36 = *MEMORY[0x277D85DE8];
}

unsigned int *mlir::ODIE::Compiler::Transforms::anonymous namespace::replaceWithCloneTypedOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, __int128 *a6, uint64_t a7, void (***a8)(void, uint64_t, unint64_t, uint64_t))
{
  v38[38] = *MEMORY[0x277D85DE8];
  v10 = *(a1 + 40);
  if (v10)
  {
    v11 = (a1 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8;
  }

  else
  {
    v11 = 0;
  }

  mlir::OperationState::OperationState(v38, *(a1 + 24), *(a1 + 48), a4 & 0xFFFFFFFFFFFFFFF9, a5, a2, a3, a8, a6, a7, v11, v10, 0, 0);
  v12 = mlir::Operation::create(v38);
  mlir::OpBuilder::insert((a8 + 1), v12);
  v35 = v37;
  v36 = 0x600000000;
  v13 = v12[9];
  if (v13)
  {
    v14 = (v12 - 4);
  }

  else
  {
    v14 = 0;
  }

  if (v13)
  {
    v32 = v14;
    v15 = 0;
    v16 = a1 - 96;
    v17 = a1 - 16;
    while (1)
    {
      if (!v15)
      {
        v23 = *(v12 - 1) & 0xFFFFFFFFFFFFFFF8;
        v22 = (v12 - 4);
LABEL_18:
        v25 = v17;
        if (v23 != (*(v17 + 8) & 0xFFFFFFFFFFFFFFF8))
        {
          goto LABEL_19;
        }

        goto LABEL_20;
      }

      v18 = *(v12 - 1) & 7;
      v19 = v12 - 4;
      v20 = v15;
      if (v18 != 6)
      {
        v21 = (5 - v18);
        v22 = v14;
        v20 = v15 - v21;
        if (v15 <= v21)
        {
          goto LABEL_14;
        }

        v19 = &v32[-16 * v21];
      }

      v22 = &v19[-6 * v20];
LABEL_14:
      v23 = *(v22 + 1) & 0xFFFFFFFFFFFFFFF8;
      if (v15 <= 5)
      {
        goto LABEL_18;
      }

      v24 = (v15 - 5);
      if (v23 != (*(v16 - 24 * v24 + 8) & 0xFFFFFFFFFFFFFFF8))
      {
        v25 = v16 - 24 * v24;
LABEL_19:
        v26 = *(a1 + 24);
        v27 = *(v25 + 8) & 0xFFFFFFFFFFFFFFF8;
        v33 = v22;
        v34 = v27;
        v22 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::TransformCastOp,mlir::Type &,mlir::Value &>((a8 + 1), v26, &v34, &v33) - 16;
      }

LABEL_20:
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v35, v22);
      ++v15;
      v14 -= 16;
      v17 -= 16;
      if (v13 == v15)
      {
        v28 = v35;
        v29 = v36;
        goto LABEL_23;
      }
    }
  }

  v29 = 0;
  v28 = v37;
LABEL_23:
  (**a8)(a8, a1, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v35 != v37)
  {
    free(v35);
  }

  mlir::OperationState::~OperationState(v38);
  v30 = *MEMORY[0x277D85DE8];
  return v12;
}

uint64_t mlir::OpInterface<mlir::InferShapedTypeOpInterface,mlir::detail::InferShapedTypeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (*(v1 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11 = *(*(v1 + 8) + 32);
    if (!v11)
    {
      return 0;
    }

    v7 = mlir::detail::TypeIDResolver<mlir::InferShapedTypeOpInterface,void>::resolveTypeID();
    v8 = *(*v11 + 104);
    v9 = v11;
    v10 = v1;
  }

  else
  {
    v3 = mlir::detail::TypeIDResolver<mlir::InferShapedTypeOpInterface,void>::resolveTypeID();
    result = mlir::detail::InterfaceMap::lookup(v1 + 32, v3);
    if (result)
    {
      return result;
    }

    v5 = *(v1 + 24);
    v6 = *(a1 + 48);
    v7 = mlir::detail::TypeIDResolver<mlir::InferShapedTypeOpInterface,void>::resolveTypeID();
    v8 = *(*v5 + 104);
    v9 = v5;
    v10 = v6;
  }

  return v8(v9, v7, v10);
}

uint64_t mlir::OpInterface<mlir::ODIE::Compiler::CoreML::KernelTypeInference,mlir::ODIE::Compiler::CoreML::detail::KernelTypeInferenceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (*(v1 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11 = *(*(v1 + 8) + 32);
    if (!v11)
    {
      return 0;
    }

    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::KernelTypeInference,void>::resolveTypeID();
    v8 = *(*v11 + 104);
    v9 = v11;
    v10 = v1;
  }

  else
  {
    v3 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::KernelTypeInference,void>::resolveTypeID();
    result = mlir::detail::InterfaceMap::lookup(v1 + 32, v3);
    if (result)
    {
      return result;
    }

    v5 = *(v1 + 24);
    v6 = *(a1 + 48);
    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::KernelTypeInference,void>::resolveTypeID();
    v8 = *(*v5 + 104);
    v9 = v5;
    v10 = v6;
  }

  return v8(v9, v7, v10);
}

uint64_t mlir::OpInterface<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,mlir::ODIE::Compiler::CoreML::detail::InferTypeAndAttributeOpInferfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (*(v1 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11 = *(*(v1 + 8) + 32);
    if (!v11)
    {
      return 0;
    }

    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,void>::resolveTypeID();
    v8 = *(*v11 + 104);
    v9 = v11;
    v10 = v1;
  }

  else
  {
    v3 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,void>::resolveTypeID();
    result = mlir::detail::InterfaceMap::lookup(v1 + 32, v3);
    if (result)
    {
      return result;
    }

    v5 = *(v1 + 24);
    v6 = *(a1 + 48);
    v7 = mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,void>::resolveTypeID();
    v8 = *(*v5 + 104);
    v9 = v5;
    v10 = v6;
  }

  return v8(v9, v7, v10);
}

uint64_t mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,void>::resolveTypeID()
{
  if ((atomic_load_explicit(&qword_27FC25898, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC25898))
  {
    v1 = llvm::getTypeName<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>();
    _MergedGlobals_66 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v1, v2);
    __cxa_guard_release(&qword_27FC25898);
  }

  return _MergedGlobals_66;
}

uint64_t llvm::getTypeName<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>()
{
  if ((atomic_load_explicit(&qword_27FC258B0, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC258B0))
  {
    qword_27FC258A0 = llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>();
    *algn_27FC258A8 = v1;
    __cxa_guard_release(&qword_27FC258B0);
  }

  return qword_27FC258A0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface]";
  v6 = 124;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::TransformCastOp,mlir::Type &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::TransformCastOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::TransformCastOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TransformCastOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::InferrableTypeUsingCastOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::InferrableTypeUsingCastOpPattern]";
  v6 = 151;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OutputOpUsingCastOpPattern::~OutputOpUsingCastOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OutputOpUsingCastOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OutputOpUsingCastOpPattern::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OutputOpUsingCastOpPattern *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v47 = *MEMORY[0x277D85DE8];
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OutputOp,void>::id)
  {
    v42 = v44;
    v43 = 0x600000000;
    if (v41 == 1)
    {
      llvm::SmallVectorImpl<mlir::Value>::operator=(&v42, &v38);
      if ((v41 & 1) != 0 && v38 != &v39)
      {
        free(v38);
      }

      v7 = a2;
      while (1)
      {
        v8 = *(v7 + 2);
        if (!v8)
        {
          break;
        }

        v9 = *(v8 + 24) & 0xFFFFFFFFFFFFFFF8;
        if (!v9)
        {
          break;
        }

        v7 = *(v9 + 16);
        if (!v7 || *(*(v7 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
        {
          goto LABEL_15;
        }
      }

      v7 = 0;
LABEL_15:
      v10 = *(*(v7 + 2 * ((*(v7 + 11) >> 23) & 1) + 10) + 8);
      v11 = *(v10 + 8);
      v12 = *(a3 + 1);
      v13 = *(v10 + 16) & 0xFFFFFFFFFFFFFFF9 | 2;
      *&v38 = v42 & 0xFFFFFFFFFFFFFFF9;
      *(&v38 + 1) = 0;
      v39 = v42 & 0xFFFFFFFFFFFFFFF9;
      v40 = v43;
      mlir::TypeRange::TypeRange<mlir::ValueRange>(&v45, &v38);
      *&v38 = v13;
      *(&v38 + 1) = v11;
      v46 = v45;
      v14 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v12, &v38, &v46);
      *(v7 + 2 * ((*(v7 + 11) >> 23) & 1) + 10) = mlir::TypeAttr::get(v14);
      v15 = *(this + 12);
      *&v38 = v7;
      v16 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::doFind<mlir::Operation const*>(v15, &v38);
      if (v16)
      {
        if (v16 != (*v15 + 48 * *(v15 + 16)))
        {
          v17 = *(v16 + 10);
          if (v17)
          {
            v18 = v16[4];
            v19 = 8 * v17;
            do
            {
              v20 = *v18;
              if (*v18)
              {
                v31 = *(a3 + 24);
                *(a3 + 3) = *(v20 + 16);
                *(a3 + 4) = v20;
                *&v38 = v42 & 0xFFFFFFFFFFFFFFF9;
                *(&v38 + 1) = 0;
                v39 = v42 & 0xFFFFFFFFFFFFFFF9;
                v40 = v43;
                mlir::TypeRange::TypeRange<mlir::ValueRange>(&v46, &v38);
                if ((*(v20 + 46) & 0x80) != 0)
                {
                  v21 = *(v20 + 68);
                  v22 = *(v20 + 72);
                }

                else
                {
                  v22 = 0;
                  v21 = 0;
                }

                v35 = v37;
                v36 = 0x600000000;
                llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v35, v22, 0, v22, v21);
                AttrDictionary = mlir::Operation::getAttrDictionary(v20);
                if (v35 != v37)
                {
                  free(v35);
                }

                *&v45 = v24;
                v25 = *(this + 12);
                *&v38 = v20;
                if (v31)
                {
                  *(a3 + 24) = v31;
                }

                else
                {
                  *(a3 + 3) = 0;
                  *(a3 + 4) = 0;
                }
              }

              ++v18;
              v19 -= 8;
            }

            while (v19);
          }
        }
      }

      v26 = *(a2 + 9);
      v27 = a2 - 16;
      if (!v26)
      {
        v27 = 0;
      }

      v38 = v27;
      v39 = v27;
      v40 = v26;
      mlir::TypeRange::TypeRange<mlir::ResultRange>(&v46, &v38);
      v32 = v34;
      v33 = 0x600000000;
      if (v43)
      {
        llvm::SmallVectorImpl<mlir::Value>::operator=(&v32, &v42);
      }

      v28 = mlir::Operation::getAttrDictionary(a2);
      if (v32 != v34)
      {
        free(v32);
      }

      v3 = 1;
    }

    else
    {
      v3 = 0;
    }

    if (v42 != v44)
    {
      free(v42);
    }
  }

  else
  {
    v3 = 0;
  }

  v29 = *MEMORY[0x277D85DE8];
  return v3;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SymbolUserMap::addSymbolUsers(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v11 = a2;
  result = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::operator[](a1, &v11);
  if (a4)
  {
    v7 = result;
    v8 = 8 * a4;
    do
    {
      v9 = *a3++;
      v10 = v9;
      result = llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>::insert(v7, &v10);
      v8 -= 8;
    }

    while (v8);
  }

  return result;
}

uint64_t *mlir::ODIE::Compiler::Transforms::anonymous namespace::SymbolUserMap::removeSymbolUsers(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v13 = a2;
  result = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>,mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::operator[](a1, &v13);
  if (a4)
  {
    v7 = result;
    v8 = &a3[a4];
    do
    {
      v12 = *a3;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>,mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>::doFind<mlir::Operation *>(v7, &v12);
      if (result)
      {
        *result = -8192;
        v7[1] = vadd_s32(v7[1], 0x1FFFFFFFFLL);
        result = v7[3];
        v9 = *(v7 + 8);
        v10 = &result[v9];
        if (v9)
        {
          v11 = 8 * v9;
          while (*result != v12)
          {
            ++result;
            v11 -= 8;
            if (!v11)
            {
              result = v10;
              break;
            }
          }
        }

        if (v10 != result + 1)
        {
          result = memmove(result, result + 1, v10 - (result + 1));
          LODWORD(v9) = *(v7 + 8);
        }

        *(v7 + 8) = v9 - 1;
      }

      ++a3;
    }

    while (a3 != v8);
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OutputOpUsingCastOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OutputOpUsingCastOpPattern]";
  v6 = 145;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::InvokeOpUsingCastOpPattern::~InvokeOpUsingCastOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InvokeOpUsingCastOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::InvokeOpUsingCastOpPattern::matchAndRewrite(mlir::SymbolTableCollection **this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v79 = *MEMORY[0x277D85DE8];
  if (*(*(a2 + 6) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
  {
    v3 = 0;
    goto LABEL_15;
  }

  v75 = v77;
  v76 = 0x600000000;
  if (v74 == 1)
  {
    llvm::SmallVectorImpl<mlir::Value>::operator=(&v75, v70);
    if ((v74 & 1) != 0 && v70[0] != &v71)
    {
      free(v70[0]);
    }

    v64 = a2;
    v7 = mlir::ODIE::Compiler::CoreML::InvokeOp::resolveCallee(&v64, this[12]);
    v63 = *(this + 6);
    v8 = v64;
    v70[0] = (v75 & 0xFFFFFFFFFFFFFFF9);
    v70[1] = 0;
    v71 = v75 & 0xFFFFFFFFFFFFFFF9;
    v72 = v76;
    mlir::TypeRange::TypeRange<mlir::ValueRange>(v69, v70);
    v10 = v69[0];
    v9 = v69[1];
    v65 = v8;
    v11 = mlir::ODIE::Compiler::CoreML::InvokeOp::resolveCallee(&v65, v63);
    if (v11)
    {
      v12 = v11;
      if (*(v11[6] + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
      {
        v16 = v11 + 8;
        v17 = (((&v11[2 * ((*(v11 + 11) >> 23) & 1) + 8] + ((*(v11 + 11) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v11 + 10));
        if (*v17 != v17)
        {
          v62 = v7;
          v18 = *(a3 + 1);
          v58 = *(a3 + 24);
          v59 = (a3 + 24);
          *(a3 + 3) = *(v12 + 16);
          *(a3 + 4) = v12;
          v19 = *(v16[2 * ((*(v12 + 44) >> 23) & 1) + 2] + 8);
          v20 = *(v19 + 16);
          v56 = v19;
          v21 = *(v19 + 8);
          v22 = *(v19 + 12);
          v70[0] = v10;
          v70[1] = v9;
          *&v78 = (v20 + 8 * v21) & 0xFFFFFFFFFFFFFFF9 | 2;
          *(&v78 + 1) = v22;
          v60 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v18, v70, &v78);
          v23 = mlir::Operation::cloneWithoutRegions(v12);
          mlir::OpBuilder::insert((a3 + 8), v23);
          v24 = mlir::Operation::getParentWithTrait<mlir::OpTrait::SymbolTable>(v12);
          SymbolTable = mlir::SymbolTableCollection::getSymbolTable(v63, v24);
          mlir::SymbolTable::insert(SymbolTable, v23, v12);
          v26 = mlir::TypeAttr::get(v60);
          v28 = v23[10];
          v27 = v23[11];
          v29 = &v23[4 * ((v27 >> 23) & 1) + 16];
          *(v29 + 16) = v26;
          v30 = ((v29 + ((v27 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v28;
          mlir::OpBuilder::cloneRegionBefore(a3 + 8, (((v12 + 64 + 16 * ((*(v12 + 44) >> 23) & 1) + ((*(v12 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v12 + 40)), v30, v30);
          v61 = v23;
          v57 = v23 + 16;
          v31 = *(((&v23[4 * ((v23[11] >> 23) & 1) + 17] + ((v23[11] >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * v23[10] + 8);
          if (v31)
          {
            v32 = (v31 - 8);
          }

          else
          {
            v32 = 0;
          }

          v33 = v32[6];
          v34 = v32[7];
          v35 = v33 == v34 || v9 == 0;
          if (!v35)
          {
            v36 = 0;
            v37 = v9 - 1;
            v38 = v33 + 8;
            do
            {
              *(*(v38 - 8) + 8) = *(*(v38 - 8) + 8) & 7 | mlir::TypeRange::dereference_iterator(v10, v36);
              if (v38 == v34)
              {
                break;
              }

              v38 += 8;
              v35 = v37 == v36++;
            }

            while (!v35);
          }

          v39 = v32[5];
          *(a3 + 3) = v32;
          *(a3 + 4) = v39;
          v40 = *(v56 + 8);
          if (v40)
          {
            v41 = v32[6];
            v42 = v32[7];
            if (v41 != v42)
            {
              v43 = *(v56 + 16);
              v44 = 8 * v40 - 8;
              v45 = v41 + 8;
              do
              {
                v46 = *(v45 - 8);
                if (*v43 != (*(v46 + 8) & 0xFFFFFFFFFFFFFFF8))
                {
                  v47 = *(v46 + 32);
                  v70[0] = *v43;
                  *&v78 = v46;
                  v48 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::TransformCastOp,mlir::Type &,mlir::Value &>((a3 + 8), v47, v70, &v78);
                  v49 = *(v45 - 8);
                  v70[0] = v48;
                  *&v78 = v70;
                  mlir::RewriterBase::replaceUsesWithIf(a3, v49, v48 - 2, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v78, 0);
                }

                if (!v44)
                {
                  break;
                }

                ++v43;
                v44 -= 8;
                v35 = v45 == v42;
                v45 += 8;
              }

              while (!v35);
            }
          }

          *v70 = v63;
          *&v78 = v70;
          mlir::detail::walk<mlir::ForwardIterator>(v61, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_117cloneInvokedGraphERNS1_21SymbolTableCollectionERNSE_13SymbolUserMapENSC_6CoreML8InvokeOpENS1_9TypeRangeERNS1_15PatternRewriterEE3__0SK_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESW_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v78, 1);
          v50 = &v57[4 * ((*(v61 + 44) >> 23) & 1)];
          if (!*(v50 + 1))
          {
            *(v50 + 5) = *(**(***(v61 + 24) + 32) + 608);
          }

          if (v58)
          {
            *v59 = v58;
          }

          else
          {
            *v59 = 0;
            *(a3 + 4) = 0;
          }

          v51 = *(a2 + 9);
          v52 = a2 - 16;
          if (!v51)
          {
            v52 = 0;
          }

          v70[0] = v52;
          v70[1] = 0;
          v71 = v52;
          v72 = v51;
          mlir::TypeRange::TypeRange<mlir::ResultRange>(&v78, v70);
          v66 = v68;
          v67 = 0x600000000;
          if (v76)
          {
            llvm::SmallVectorImpl<mlir::Value>::operator=(&v66, &v75);
          }

          AttrDictionary = mlir::Operation::getAttrDictionary(a2);
          if (v66 != v68)
          {
            free(v66);
          }

          mlir::ODIE::Compiler::CoreML::InvokeOp::setCalleeFromCallable(v70, v61);
          v54 = this[13];
          *&v78 = v70[0];
          v3 = 1;
          v55 = this[13];
          *&v78 = a2;
          goto LABEL_13;
        }
      }
    }

    v70[0] = "Can't propagate types over invoke";
    v73 = 259;
    *&v78 = v70;
    v13 = *(a3 + 2);
    if (v13 && v13[2] == 1)
    {
      (*(*v13 + 88))(v13, *(a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v78);
    }
  }

  v3 = 0;
LABEL_13:
  if (v75 != v77)
  {
    free(v75);
  }

LABEL_15:
  v14 = *MEMORY[0x277D85DE8];
  return v3;
}

uint64_t *_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_117cloneInvokedGraphERNS1_21SymbolTableCollectionERNSE_13SymbolUserMapENSC_6CoreML8InvokeOpENS1_9TypeRangeERNS1_15PatternRewriterEE3__0SK_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESW_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *result, uint64_t a2)
{
  v7[1] = *MEMORY[0x277D85DE8];
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
  {
    v2 = *result;
    v6 = a2;
    v3 = mlir::ODIE::Compiler::CoreML::InvokeOp::resolveCallee(&v6, *v2);
    v4 = *(v2 + 8);
    v7[0] = v6;
  }

  v5 = *MEMORY[0x277D85DE8];
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::InvokeOpUsingCastOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::InvokeOpUsingCastOpPattern]";
  v6 = 145;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::InferShapedTypeOpPattern::~InferShapedTypeOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InferShapedTypeOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferShapedTypeOpInterface>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferShapedTypeOpInterface,mlir::detail::InferShapedTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 48);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferShapedTypeOpInterface>::match(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferShapedTypeOpInterface,mlir::detail::InferShapedTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v5 = *(*a1 + 56);

  return v5(a1, a2, InterfaceFor);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferShapedTypeOpInterface>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferShapedTypeOpInterface,mlir::detail::InferShapedTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 64);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::InferShapedTypeOpPattern::matchAndRewrite(int a1, mlir::ODIE::Compiler::Transforms::_anonymous_namespace_ *this, mlir::PatternRewriter *a3, uint64_t a4)
{
  v61[8] = *MEMORY[0x277D85DE8];
  {
    v15 = 0;
    goto LABEL_54;
  }

  v59 = v61;
  v60 = 0x100000000;
  v7 = *(this + 3);
  v8 = *(**v7 + 32);
  if ((*(this + 46) & 0x80) != 0)
  {
    v9 = *(this + 17);
    v10 = *(this + 9) & 0xFFFFFFFFFFFFFFF9 | 2;
  }

  else
  {
    v9 = 0;
    v10 = 2;
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v12 = *(this + 11);
  if (HIBYTE(*(this + 11)))
  {
    v13 = this + 16 * ((v12 >> 23) & 1) + 64;
  }

  else
  {
    v13 = 0;
  }

  if ((v12 & 0x7FFFFF) != 0)
  {
    v14 = ((this + 16 * ((v12 >> 23) & 1) + ((v12 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(this + 10);
  }

  else
  {
    v14 = 0;
  }

  v16 = *a3;
  v55 = v10;
  v56 = v9;
  v57[0] = 0;
  v58 = 0;
  if ((v16(v8, v7, 1, &v55, AttrDictionary, v13, v14) & 1) == 0)
  {
    v55 = "Failed to inferReturnTypeComponents";
    LOWORD(v58) = 259;
    *&v48[0] = &v55;
    v41 = *(a4 + 16);
    if (v41 && v41[2] == 1)
    {
      (*(*v41 + 88))(v41, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::InferShapedTypeOpInterface &>(mlir::InferShapedTypeOpInterface &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v48);
    }

    v15 = 0;
    goto LABEL_46;
  }

  v55 = v57;
  v56 = 0x600000000;
  v17 = *(this + 9);
  if (v17 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(&v55, v57, v17, 8);
  }

  if (!v60)
  {
LABEL_29:
    {
      v36 = v56;
      v37 = v55 & 0xFFFFFFFFFFFFFFF9;
      if ((*(this + 46) & 0x80) != 0)
      {
        v38 = *(this + 9);
        v39 = *(this + 17);
      }

      else
      {
        v38 = 0;
        v39 = 0;
      }

      v52 = v54;
      v53 = 0x600000000;
      llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v52, v38, 0, v38, v39);
      v40 = mlir::Operation::getAttrDictionary(this);
      if (v52 != v54)
      {
        free(v52);
      }

      v15 = 1;
    }

    else
    {
      v15 = 0;
    }

    goto LABEL_44;
  }

  v18 = 0;
  v19 = v60 << 6;
  v20 = v59 + 7;
  v21 = this - 16;
  while (*v20 == 1)
  {
    v22 = *(v20 - 2);
    if (!v22)
    {
      v23 = *(this + 9);
      if (v23)
      {
        v24 = this - 16;
      }

      else
      {
        v24 = 0;
      }

      if (v18)
      {
        v25 = this - 16;
        v26 = v18;
        if (!v23 || (v27 = *(v24 + 1) & 7, v25 = this - 16, v26 = v18, v27 == 6))
        {
LABEL_26:
          v24 = &v25[-24 * v26];
        }

        else
        {
          v28 = (5 - v27);
          v24 = v21;
          v26 = v18 - v28;
          if (v18 > v28)
          {
            v25 = this - 16 * v28 - 16;
            goto LABEL_26;
          }
        }
      }

      v29 = (*(v24 + 1) & 0xFFFFFFFFFFFFFFF8);
      v30 = *v29;
      v31 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
      v32 = mlir::detail::InterfaceMap::lookup(v30 + 8, v31);
      v22 = (*(v32 + 8))(v32, v29);
    }

    v33 = *(v20 - 12);
    v34 = *(v20 - 1);
    *&v48[0] = *(v20 - 7);
    *(&v48[0] + 1) = v33;
    v50 = v34;
    v51 = v22;
    v35 = mlir::detail::TypeUniquer::get<mlir::RankedTensorType,llvm::ArrayRef<long long> &,mlir::Type &,mlir::Attribute &>(*(**v22 + 32), v48, &v51, &v50);
    llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(&v55, v35);
    ++v18;
    v21 -= 16;
    v20 += 64;
    v19 -= 64;
    if (!v19)
    {
      goto LABEL_29;
    }
  }

  *&v48[0] = "Cannot match unranked tensor";
  v49 = 259;
  v51 = v48;
  v42 = *(a4 + 16);
  if (v42 && v42[2] == 1)
  {
    (*(*v42 + 88))(v42, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::InferShapedTypeOpInterface &>(mlir::InferShapedTypeOpInterface &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v51);
  }

  v15 = 0;
LABEL_44:
  if (v55 != v57)
  {
    free(v55);
  }

LABEL_46:
  v43 = v59;
  if (v60)
  {
    v44 = &v59[8 * v60 - 8];
    v45 = -64 * v60;
    do
    {
      if (v44 + 2 != *v44)
      {
        free(*v44);
      }

      v44 -= 8;
      v45 += 64;
    }

    while (v45);
    v43 = v59;
  }

  if (v43 != v61)
  {
    free(v43);
  }

LABEL_54:
  v46 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::matchOpAndInputs(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_ *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v3 = *(this + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = "Operations with regions are not supported";
    goto LABEL_3;
  }

  if (*(*(this + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
  {
    v4 = "Invoke op is not supported";
    goto LABEL_3;
  }

  v7 = *(this + 9);
  if (v7)
  {
    v8 = this - 16;
  }

  else
  {
    v8 = 0;
  }

  if (!v7)
  {
LABEL_42:
    v4 = "All results are static";
    goto LABEL_3;
  }

  v9 = 0;
  while (1)
  {
    v10 = v8;
    if (v9)
    {
      v11 = *(this - 1) & 7;
      v12 = v8;
      v13 = v9;
      if (v11 != 6)
      {
        v14 = (5 - v11);
        v13 = v9 - v14;
        if (v9 <= v14)
        {
          v10 = &v8[-16 * v9];
          goto LABEL_20;
        }

        v12 = &v8[-16 * v14];
      }

      v10 = &v12[-24 * v13];
    }

LABEL_20:
    v15 = (*(v10 + 1) & 0xFFFFFFFFFFFFFFF8);
    if (*(*v15 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v16 = v15[2];
      if (v16)
      {
        break;
      }
    }

LABEL_21:
    if (++v9 == v7)
    {
      goto LABEL_42;
    }
  }

  v17 = v15[1];
  v18 = 8 * v16;
  while (*v17 != 0x8000000000000000)
  {
    ++v17;
    v18 -= 8;
    if (!v18)
    {
      goto LABEL_21;
    }
  }

  if ((v3 & 0x800000) == 0)
  {
    goto LABEL_45;
  }

  v19 = *(this + 17);
  if (!v19)
  {
    goto LABEL_45;
  }

  LOBYTE(v5) = 0;
  v20 = 0;
  while (2)
  {
    while (1)
    {
      v21 = (*(*(*(this + 9) + 32 * v20 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (*(*v21 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        break;
      }

      v22 = v21[2];
      if (v22)
      {
        v23 = v21[1];
        v24 = 8 * v22;
        while (*v23 != 0x8000000000000000)
        {
          ++v23;
          v24 -= 8;
          if (!v24)
          {
            LOBYTE(v5) = 1;
            goto LABEL_33;
          }
        }

        break;
      }

      ++v20;
      v5 = 1;
      if (v20 == v19)
      {
        return v5;
      }
    }

LABEL_33:
    if (++v20 != v19)
    {
      continue;
    }

    break;
  }

  if (v5)
  {
    return 1;
  }

LABEL_45:
  v4 = "No shape propagation opportunities found";
LABEL_3:
  v25 = v4;
  v26 = 259;
  v27 = &v25;
  if (a2 && *(a2 + 2) == 1)
  {
    (*(*a2 + 88))(a2, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v27);
  }

  return 0;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::allTypesStatic(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    return 1;
  }

  v4 = 0;
  while (1)
  {
    v5 = mlir::TypeRange::dereference_iterator(a1, v4);
    if (*(*v5 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      return 0;
    }

    v6 = v5[2];
    if (v6)
    {
      v7 = v5[1];
      v8 = 8 * v6;
      while (*v7 != 0x8000000000000000)
      {
        ++v7;
        v8 -= 8;
        if (!v8)
        {
          goto LABEL_8;
        }
      }

      return 0;
    }

LABEL_8:
    if (++v4 == a2)
    {
      return 1;
    }
  }
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::InferShapedTypeOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::InferShapedTypeOpPattern]";
  v6 = 143;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeOpPattern::~InferTypeOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InferTypeOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferTypeOpInterface>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 48);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferTypeOpInterface>::match(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v5 = *(*a1 + 56);

  return v5(a1, a2, InterfaceFor);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::InferTypeOpInterface>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::InferTypeOpInterface,mlir::detail::InferTypeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 64);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeOpPattern::matchAndRewrite(int a1, mlir::ODIE::Compiler::Transforms::_anonymous_namespace_ *this, mlir::PatternRewriter *a3, uint64_t a4)
{
  v32[6] = *MEMORY[0x277D85DE8];
  {
    v15 = 0;
    goto LABEL_23;
  }

  v30 = v32;
  v31 = 0x600000000;
  v7 = *(this + 3);
  v8 = *(**v7 + 32);
  if ((*(this + 46) & 0x80) != 0)
  {
    v9 = *(this + 17);
    v10 = *(this + 9) & 0xFFFFFFFFFFFFFFF9 | 2;
  }

  else
  {
    v9 = 0;
    v10 = 2;
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v12 = *(this + 11);
  if (HIBYTE(*(this + 11)))
  {
    v13 = this + 16 * ((v12 >> 23) & 1) + 64;
  }

  else
  {
    v13 = 0;
  }

  if ((v12 & 0x7FFFFF) != 0)
  {
    v14 = ((this + 16 * ((v12 >> 23) & 1) + ((v12 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(this + 10);
  }

  if ((*a3)(v8, v7, 1, v10, v9, AttrDictionary, v13))
  {
    {
      v16 = v31;
      v17 = v30 & 0xFFFFFFFFFFFFFFF9;
      if ((*(this + 46) & 0x80) != 0)
      {
        v18 = *(this + 9);
        v19 = *(this + 17);
      }

      else
      {
        v18 = 0;
        v19 = 0;
      }

      v27 = v29;
      v28 = 0x600000000;
      llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v27, v18, 0, v18, v19);
      v20 = mlir::Operation::getAttrDictionary(this);
      if (v27 != v29)
      {
        free(v27);
      }

      v15 = 1;
      goto LABEL_21;
    }
  }

  else
  {
    v24 = "Failed to inferReturnTypes";
    v25 = 259;
    v26 = &v24;
    v21 = *(a4 + 16);
    if (v21 && v21[2] == 1)
    {
      (*(*v21 + 88))(v21, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::InferTypeOpInterface &>(mlir::InferTypeOpInterface &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v26);
    }
  }

  v15 = 0;
LABEL_21:
  if (v30 != v32)
  {
    free(v30);
  }

LABEL_23:
  v22 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::InferTypeOpPattern]";
  v6 = 137;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::KernelTypeInferenceOpPattern::~KernelTypeInferenceOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::KernelTypeInferenceOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::KernelTypeInference>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::KernelTypeInference,mlir::ODIE::Compiler::CoreML::detail::KernelTypeInferenceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 48);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::KernelTypeInference>::match(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::KernelTypeInference,mlir::ODIE::Compiler::CoreML::detail::KernelTypeInferenceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v5 = *(*a1 + 56);

  return v5(a1, a2, InterfaceFor);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::KernelTypeInference>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::KernelTypeInference,mlir::ODIE::Compiler::CoreML::detail::KernelTypeInferenceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 64);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::KernelTypeInferenceOpPattern::matchAndRewrite(int a1, mlir::ODIE::Compiler::Transforms::_anonymous_namespace_ *this, mlir::PatternRewriter *a3, uint64_t a4)
{
  v25[6] = *MEMORY[0x277D85DE8];
  if ((matched & 1) == 0)
  {
    v13 = 0;
    goto LABEL_16;
  }

  v23 = v25;
  v24 = 0x600000000;
  KernelRegistry = mlir::ODIE::Compiler::CoreML::getKernelRegistry(matched);
  if (ODIE::Compiler::Utils::CoreKernelsTypeBridges::resolveOutputTypes(this, KernelRegistry, &v23, 0, 0))
  {
    {
      v8 = v24;
      v9 = v23 & 0xFFFFFFFFFFFFFFF9;
      if ((*(this + 46) & 0x80) != 0)
      {
        v10 = *(this + 9);
        v11 = *(this + 17);
      }

      else
      {
        v10 = 0;
        v11 = 0;
      }

      v20 = v22;
      v21 = 0x600000000;
      llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v20, v10, 0, v10, v11);
      AttrDictionary = mlir::Operation::getAttrDictionary(this);
      if (v20 != v22)
      {
        free(v20);
      }

      v13 = 1;
      goto LABEL_14;
    }
  }

  else
  {
    v17 = "Failed to inferReturnTypes for KernelTypeInference.";
    v18 = 259;
    v19 = &v17;
    v14 = *(a4 + 16);
    if (v14 && v14[2] == 1)
    {
      (*(*v14 + 88))(v14, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreML::KernelTypeInference &>(mlir::ODIE::Compiler::CoreML::KernelTypeInference &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v19);
    }
  }

  v13 = 0;
LABEL_14:
  if (v23 != v25)
  {
    free(v23);
  }

LABEL_16:
  v15 = *MEMORY[0x277D85DE8];
  return v13;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::KernelTypeInferenceOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::KernelTypeInferenceOpPattern]";
  v6 = 147;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeAndAttributesOpPattern::~InferTypeAndAttributesOpPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::InferTypeAndAttributesOpPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,mlir::ODIE::Compiler::CoreML::detail::InferTypeAndAttributeOpInferfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 48);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>::match(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,mlir::ODIE::Compiler::CoreML::detail::InferTypeAndAttributeOpInferfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v5 = *(*a1 + 56);

  return v5(a1, a2, InterfaceFor);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    InterfaceFor = mlir::OpInterface<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface,mlir::ODIE::Compiler::CoreML::detail::InferTypeAndAttributeOpInferfaceInterfaceTraits>::getInterfaceFor(a2);
  }

  else
  {
    InterfaceFor = 0;
  }

  v7 = *(*a1 + 64);

  return v7(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeAndAttributesOpPattern::matchAndRewrite(int a1, mlir::ODIE::Compiler::Transforms::_anonymous_namespace_ *this, mlir::PatternRewriter *a3, uint64_t a4)
{
  v34[6] = *MEMORY[0x277D85DE8];
  {
    v15 = 0;
    goto LABEL_25;
  }

  v32 = v34;
  v33 = 0x600000000;
  v29 = v31;
  v30 = 0x300000000;
  v7 = *(this + 3);
  v8 = *(**v7 + 32);
  if ((*(this + 46) & 0x80) != 0)
  {
    v9 = *(this + 17);
    v10 = *(this + 9) & 0xFFFFFFFFFFFFFFF9 | 2;
  }

  else
  {
    v9 = 0;
    v10 = 2;
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v12 = *(this + 11);
  if (HIBYTE(*(this + 11)))
  {
    v13 = this + 16 * ((v12 >> 23) & 1) + 64;
  }

  else
  {
    v13 = 0;
  }

  if ((v12 & 0x7FFFFF) != 0)
  {
    v14 = ((this + 16 * ((v12 >> 23) & 1) + ((v12 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(this + 10);
  }

  if ((*a3)(v8, v7, 1, v10, v9, AttrDictionary, v13))
  {
    {
      v16 = v33;
      v17 = v32 & 0xFFFFFFFFFFFFFFF9;
      if ((*(this + 46) & 0x80) != 0)
      {
        v18 = *(this + 9);
        v19 = *(this + 17);
      }

      else
      {
        v18 = 0;
        v19 = 0;
      }

      v26 = v28;
      v27 = 0x600000000;
      llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v26, v18, 0, v18, v19);
      if (v26 != v28)
      {
        free(v26);
      }

      v15 = 1;
      goto LABEL_21;
    }
  }

  else
  {
    v23 = "Failed to inferReturnTypes";
    v24 = 259;
    v25 = &v23;
    v20 = *(a4 + 16);
    if (v20 && v20[2] == 1)
    {
      (*(*v20 + 88))(v20, *(this + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface &>(mlir::ODIE::Compiler::CoreML::InferTypeAndAttributeOpInferface &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v25);
    }
  }

  v15 = 0;
LABEL_21:
  if (v29 != v31)
  {
    free(v29);
  }

  if (v32 != v34)
  {
    free(v32);
  }

LABEL_25:
  v21 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::InferTypeAndAttributesOpPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::InferTypeAndAttributesOpPattern]";
  v6 = 150;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::TransformCastPattern::~TransformCastPattern(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::TransformCastPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::TransformCastPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 36);
  v6 = a2 - 16;
  if (!v5)
  {
    v6 = 0;
  }

  v12 = v6;
  v13 = v6;
  v14 = v5;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v7 = *(a2 + 72);
    v8 = *(a2 + 68);
  }

  else
  {
    v7 = 0;
    v8 = 0;
  }

  v11[0] = v7;
  v11[1] = v8;
  v9 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::CastOp,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>((a3 + 8), *(a2 + 24), &v12, v11);
  (*(*a3 + 8))(a3, a2, v9);
  return 1;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::TransformCastPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::TransformCastPattern]";
  v6 = 139;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void anonymous namespace::UnflattenTorchModulesPass::~UnflattenTorchModulesPass(_anonymous_namespace_::UnflattenTorchModulesPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t anonymous namespace::UnflattenTorchModulesPass::runOnOperation(_anonymous_namespace_::UnflattenTorchModulesPass *this)
{
  v263 = *MEMORY[0x277D85DE8];
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v214[0] = *(***(v2 + 24) + 32);
  v214[1] = 0;
  v215 = 0;
  v216 = 0;
  v212[0] = 0;
  v212[1] = 0;
  v213 = 0;
  mlir::SymbolTableCollection::getSymbolTable(v212, v2);
  v210 = 0u;
  v211 = 0u;
  *v209 = 0u;
  v196 = v2;
  v193 = v2 + 64;
  mlir::Region::getOps<mlir::FunctionOpInterface>(__dst, (v2 + 64 + 16 * ((*(v2 + 44) >> 23) & 1) + ((*(v2 + 44) >> 21) & 0x7F8) + 32 * *(v2 + 40)));
  v238 = *__dst;
  v239 = *&__dst[16];
  v240 = v243;
  v241 = v244;
  v3 = v247[0];
  if (*&__dst[16] == v247[0])
  {
    v4 = 0;
  }

  else
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    do
    {
      if (v7 == v6)
      {
        v1 = 0;
      }

      else
      {
        v1 = 32 * (v7 - v6) - 1;
      }

      v8 = (*(&v241 + 1))();
      v10 = v9;
      v11 = v4 + v5;
      if (v1 == v4 + v5)
      {
        std::deque<mlir::FunctionOpInterface>::__add_back_capacity(v209);
        v6 = v209[1];
        v7 = v210;
        v4 = *(&v211 + 1);
        v5 = v211;
        v11 = *(&v211 + 1) + v211;
      }

      v12 = (*&v6[(v11 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v11);
      *v12 = v8;
      v12[1] = v10;
      *(&v211 + 1) = ++v4;
      mlir::Region::OpIterator::operator++(&v238);
      llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v238);
    }

    while (v239 != v3);
  }

  Attr = mlir::Operation::getAttr(v196, "TorchImport.module_metadata", 0x1BuLL);
  if (Attr)
  {
    if (*(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    {
      v14 = Attr;
    }

    else
    {
      v14 = 0;
    }
  }

  else
  {
    v14 = 0;
  }

  v208 = v14;
  if (!v4)
  {
LABEL_230:
    v139 = *(v196 + 40);
    v138 = *(v196 + 44);
    *&v228 = &v229;
    *(&v228 + 1) = 0x300000000;
    mlir::Region::getOps<mlir::FunctionOpInterface>(__dst, (((v193 + 16 * ((v138 >> 23) & 1) + ((v138 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8) + 32 * v139));
    v238 = *__dst;
    v239 = *&__dst[16];
    v240 = v243;
    v241 = v244;
    v140 = v247[0];
    if (*&__dst[16] != v247[0])
    {
      do
      {
        v141 = (*(&v241 + 1))();
        v143 = v142;
        if (mlir::Operation::hasAttr(v141, "unflatten.belongsInModule", 0x19uLL))
        {
          v144 = DWORD2(v228);
          if (DWORD2(v228) >= HIDWORD(v228))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&v228, &v229, DWORD2(v228) + 1, 16);
            v144 = DWORD2(v228);
          }

          v145 = (v228 + 16 * v144);
          *v145 = v141;
          v145[1] = v143;
          ++DWORD2(v228);
        }

        mlir::Region::OpIterator::operator++(&v238);
        llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v238);
      }

      while (v239 != v140);
    }

    v146 = v228;
    v198 = v228 + 16 * DWORD2(v228);
    while (v146 != v198)
    {
      v147 = *v146;
      v199 = v146[1];
      v200 = v146;
      v205 = v196;
      v148 = mlir::Operation::getAttr(v147, "unflatten.belongsInModule", 0x19uLL);
      if (*(*v148 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        v149 = v148;
      }

      else
      {
        v149 = 0;
      }

      *&v238 = &v239;
      *(&v238 + 1) = 0x300000000;
      *__dst = v149[1];
      llvm::StringRef::split(__dst, &v238, ".", 1uLL, -1, 0);
      *&v233 = &v234;
      *(&v233 + 1) = 0x600000000;
      llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::resizeImpl<false>(&v233, DWORD2(v238));
      v152 = v233;
      if (DWORD2(v238))
      {
        v153 = v238;
        v154 = (v238 + 16 * DWORD2(v238));
        do
        {
          v155 = *v153;
          v156 = v153[1];
          v153 += 2;
          v157 = *(**v149 + 32);
          LOWORD(v243) = 261;
          *__dst = v155;
          *&__dst[8] = v156;
          v158 = mlir::StringAttr::get(v157, __dst, v150);
          *v152 = mlir::SymbolRefAttr::get(v158, 0, 0, v159);
          v152 += 2;
        }

        while (v153 != v154);
        v152 = v233;
      }

      v160 = DWORD2(v233);
      if (DWORD2(v233))
      {
        v161 = v196;
        do
        {
          v162 = mlir::SymbolTableCollection::lookupSymbolIn(v212, v161, *v152);
          if (!v162 || *(*(v162 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuleOp,void>::id)
          {
            v201[0] = *(***(v205 + 24) + 32);
            v202 = 0;
            v203 = 0;
            v201[1] = 0;
            v163 = *(v147 + 24);
            v164 = *(*v152 + 8);
            v165 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuleOp,void>::id, *(**v163 + 32));
            if (v166)
            {
              *__dst = v163;
              *&__dst[8] = v165;
              *&__dst[16] = &v243;
              *&__dst[24] = 0x400000000;
              v245 = v247;
              v246 = 0x400000000;
              v248 = v250;
              v249 = 0x400000000;
              v251 = 4;
              v252 = &v254;
              v253 = 0x100000000;
              v255 = &v257;
              v256 = 0x100000000;
              v258 = 0;
              v259 = 0;
              v260 = &mlir::detail::TypeIDResolver<void,void>::id;
              v261 = 0;
              v262 = 0;
              mlir::ODIE::Compiler::CoreML::ModuleOp::build(v201, __dst, *(v164 + 16), *(v164 + 24), 0, 0);
            }

            v222 = 1283;
            v220 = "coreml.module";
            v221 = 13;
            v218 = 259;
            llvm::operator+(&__p, v217, &v223);
            llvm::report_fatal_error(&v223, 1);
          }

          v152 += 2;
          v161 = v162;
          --v160;
        }

        while (v160);
        v152 = v233;
        v167 = v205;
        v168 = DWORD2(v233) - 1;
      }

      else
      {
        v168 = -1;
        v167 = v196;
      }

      v169 = mlir::SymbolRefAttr::get(*(*v152 + 8), v152 + 2, v168, v151);
      v170 = mlir::SymbolTableCollection::lookupSymbolIn(v212, v167, v169);
      if (v170)
      {
        if (*(*(v170 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuleOp,void>::id)
        {
          v171 = v170;
        }

        else
        {
          v171 = 0;
        }
      }

      else
      {
        v171 = 0;
      }

      v217[0] = v171;
      buffer = llvm::allocate_buffer(0x28, 8uLL);
      *__dst = buffer;
      *&__dst[8] = xmmword_25D0A0920;
      *buffer = &v205;
      buffer[1] = &v233;
      buffer[2] = v217;
      buffer[3] = v212;
      buffer[4] = __dst;
      *&__dst[24] = &llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::FunctionOpInterface>::CallbacksHolder<moveIntoModule(mlir::SymbolTableCollection &,mlir::ModuleOp,mlir::FunctionOpInterface)::$_1,moveIntoModule(mlir::SymbolTableCollection &,mlir::ModuleOp,mlir::FunctionOpInterface)::$_1,void>::Callbacks;
      if (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::FunctionOpInterface>::CallbacksHolder<moveIntoModule(mlir::SymbolTableCollection &,mlir::ModuleOp,mlir::FunctionOpInterface)::$_1,moveIntoModule(mlir::SymbolTableCollection &,mlir::ModuleOp,mlir::FunctionOpInterface)::$_1,void>::Callbacks(buffer, v147, v199))
      {
        v223 = v217;
        v224 = &v205;
        v225 = v212;
        *&__p = &v223;
        v174 = 1;
        if (mlir::detail::walk<mlir::ForwardIterator>(v205, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEE3__2NS1_15CallOpInterfaceES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &__p, 1))
        {
          mlir::Operation::removeAttr(v147, "unflatten.belongsInModule", 0x19);
          v174 = 0;
        }
      }

      else
      {
        v174 = 1;
      }

      v175 = __dst[24];
      if (*&__dst[24] >= 8uLL)
      {
        if ((__dst[24] & 4) != 0)
        {
          if ((__dst[24] & 2) != 0)
          {
            v176 = __dst;
          }

          else
          {
            v176 = *__dst;
          }

          (*((*&__dst[24] & 0xFFFFFFFFFFFFFFF8) + 16))(v176, v173);
        }

        if ((v175 & 2) == 0)
        {
          MEMORY[0x25F891030](*__dst, *&__dst[16]);
        }
      }

      if (v233 != &v234)
      {
        free(v233);
      }

      if (v238 != &v239)
      {
        free(v238);
      }

      v146 = v200 + 2;
      if (v174)
      {
        *(this + 5) |= 4uLL;
        goto LABEL_300;
      }
    }

    *__dst = &v208;
    *&__dst[8] = this;
    *&v238 = __dst;
    mlir::detail::walk<mlir::ForwardIterator>(v196, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_125UnflattenTorchModulesPass14runOnOperationEvE3__3NS1_4ODIE8Compiler6CoreML8ModuleOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v238, 1);
    mlir::Operation::removeAttr(v196, "TorchImport.module_metadata", 0x1B);
LABEL_300:
    if (v228 != &v229)
    {
      free(v228);
    }

    goto LABEL_302;
  }

  while (1)
  {
    v15 = v209[1];
    v16 = v211;
    v197 = *(*(v209[1] + ((v211 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v211);
    *&v211 = v211 + 1;
    *(&v211 + 1) = v4 - 1;
    if (v211 >= 0x200)
    {
      operator delete(*v209[1]);
      v209[1] = v15 + 8;
      *&v211 = v16 - 255;
    }

    v223 = this;
    v238 = v197;
    *(&v233 + 1) = &v223;
    v205 = 0;
    v206 = 0;
    v207 = 0x3000000000;
    if (v197)
    {
      InterfaceFor = mlir::OpInterface<mlir::SymbolOpInterface,mlir::detail::SymbolOpInterfaceInterfaceTraits>::getInterfaceFor(v197);
    }

    else
    {
      InterfaceFor = 0;
    }

    *&v228 = v197;
    *(&v228 + 1) = InterfaceFor;
    *__dst = &v238;
    *&__dst[8] = &v233;
    *&__dst[16] = &v228;
    *&__dst[24] = &v205;
    mlir::detail::walk<mlir::ForwardIterator>(v197, llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<buildModuleMap(mlir::FunctionOpInterface,llvm::function_ref<mlir::InFlightDiagnostic ()(mlir::Operation *)>)::$_0>, __dst, 0);
    v239 = 0u;
    v240 = 0u;
    v238 = 0u;
    if (v206)
    {
        ;
      }
    }

    else
    {
      i = v205;
    }

    v20 = (v205 + 8 * v206);
    if (i == v20)
    {
      v29 = 0;
    }

    else
    {
      v1 = *i;
      do
      {
        v21 = *v1;
        if (*v1 >= 0x7FFFFFFFFFFFFFF8uLL)
        {
          std::string::__throw_length_error[abi:nn200100]();
        }

        if (v21 >= 0x17)
        {
          operator new();
        }

        __dst[23] = *v1;
        if (v21)
        {
          memmove(__dst, (v1 + 48), v21);
        }

        __dst[v21] = 0;
        v22 = *(&v238 + 1);
        if (v239 == *(&v238 + 1))
        {
          v23 = 0;
        }

        else
        {
          v23 = 8 * (v239 - *(&v238 + 1)) - 1;
        }

        v24 = *(&v240 + 1);
        v25 = *(&v240 + 1) + v240;
        if (v23 == *(&v240 + 1) + v240)
        {
          std::deque<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::__add_back_capacity(&v238);
          v22 = *(&v238 + 1);
          v24 = *(&v240 + 1);
          v25 = *(&v240 + 1) + v240;
        }

        v26 = *(v22 + ((v25 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v25 & 0x3F) << 6);
        *(v26 + 16) = *&__dst[16];
        *v26 = *__dst;
        memset(__dst, 0, 24);
        *(v26 + 24) = 0;
        *(v26 + 32) = 0;
        *(v26 + 40) = 0;
        *(v26 + 24) = *(v1 + 8);
        *(v1 + 8) = 0;
        *(v26 + 32) = *(v1 + 16);
        *(v1 + 16) = 0;
        *(v26 + 48) = v26 + 64;
        v27 = *(v26 + 36);
        *(v26 + 36) = *(v1 + 20);
        *(v1 + 20) = v27;
        v28 = *(v26 + 40);
        *(v26 + 40) = *(v1 + 24);
        *(v1 + 24) = v28;
        *(v26 + 56) = 0;
        if (*(v1 + 40))
        {
          llvm::SmallVectorImpl<mlir::Operation *>::operator=(v26 + 48, v1 + 32);
          v24 = *(&v240 + 1);
        }

        v29 = v24 + 1;
        *(&v240 + 1) = v24 + 1;
        if ((__dst[23] & 0x80000000) != 0)
        {
          operator delete(*__dst);
        }

        do
        {
          v30 = i[1];
          ++i;
          v1 = v30;
          if (v30)
          {
            v31 = v1 == -8;
          }

          else
          {
            v31 = 1;
          }
        }

        while (v31);
      }

      while (i != v20);
    }

    if (HIDWORD(v206))
    {
      if (v206)
      {
        v32 = 0;
        v33 = 8 * v206;
        do
        {
          v34 = v205;
          v35 = *(v205 + v32);
          if (v35 != -8 && v35 != 0)
          {
            llvm::StringMapEntry<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>::Destroy<llvm::MallocAllocator>(v35);
          }

          *(v34 + v32) = 0;
          v32 += 8;
        }

        while (v33 != v32);
      }

      LODWORD(v207) = 0;
      HIDWORD(v206) = 0;
    }

    if (v29)
    {
      v37 = 0;
      do
      {
        while (1)
        {
          v38 = *(&v238 + 1);
          v39 = v240;
          v40 = v240 >> 6;
          v41 = v240 & 0x3F;
          v42 = *(*(&v238 + 1) + 8 * (v240 >> 6)) + (v41 << 6);
          v43 = *(v42 + 16);
          *__dst = *v42;
          *&__dst[16] = v43;
          *(v42 + 8) = 0;
          *(v42 + 16) = 0;
          *v42 = 0;
          *&__dst[24] = 0;
          *&v243 = 0;
          DWORD2(v243) = 0;
          *&__dst[24] = *(v42 + 24);
          *(v42 + 24) = 0;
          LODWORD(v243) = *(v42 + 32);
          *(v42 + 32) = 0;
          LODWORD(v43) = DWORD1(v243);
          DWORD1(v243) = *(v42 + 36);
          *(v42 + 36) = v43;
          LODWORD(v43) = DWORD2(v243);
          DWORD2(v243) = *(v42 + 40);
          *(v42 + 40) = v43;
          *&v244 = &v245;
          *(&v244 + 1) = 0;
          if (*(v42 + 56))
          {
            llvm::SmallVectorImpl<mlir::Operation *>::operator=(&v244, v42 + 48);
          }

          v44 = v38[v40] + 64 * v41;
          v45 = *(v44 + 6);
          if (v45 != v44 + 64)
          {
            free(v45);
          }

          MEMORY[0x25F891030](*(v44 + 3), 8);
          if (v44[23] < 0)
          {
            operator delete(*v44);
          }

          --v29;
          v47 = v39 + 1;
          *(&v240 + 1) = v29;
          *&v240 = v39 + 1;
          if ((v39 + 1) >= 0x80)
          {
            v48 = *v38++;
            operator delete(v48);
            v47 = v39 - 63;
            *(&v238 + 1) = v38;
            *&v240 = v39 - 63;
          }

          if (__dst[23] >= 0)
          {
            v49 = __dst;
          }

          else
          {
            v49 = *__dst;
          }

          if (__dst[23] >= 0)
          {
            v50 = __dst[23];
          }

          else
          {
            v50 = *&__dst[8];
          }

          v51 = v244;
          v52 = v244;
          if (DWORD2(v244))
          {
            v53 = *v244;
            v54 = *(*v244 + 16) + 32;
            v52 = v244;
            if (*v244 != v54)
            {
              v55 = 8 * DWORD2(v244) - 8;
              v52 = v244;
              do
              {
                if (*v52 != v53)
                {
                  break;
                }

                ++v52;
                if (!v55)
                {
                  break;
                }

                v53 = *(v53 + 8);
                v55 -= 8;
              }

              while (v53 != v54);
            }
          }

          if (v52 == (v244 + 8 * DWORD2(v244)))
          {
            v63 = llvm::xxh3_64bits(v49, v50, v46);
            v64 = *llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::try_emplace_with_hash<>(&v205, v49, v50, v63);
            v65 = v64 + 1;
            MEMORY[0x25F891030](*v65, 8);
            v64[2] = 0;
            *v65 = 0;
            *(v64 + 6) = 0;
            *v65 = *&__dst[24];
            *&__dst[24] = 0;
            *(v64 + 4) = v243;
            LODWORD(v243) = 0;
            v66 = *(v64 + 5);
            *(v64 + 5) = DWORD1(v243);
            DWORD1(v243) = v66;
            v67 = *(v64 + 6);
            *(v64 + 6) = DWORD2(v243);
            DWORD2(v243) = v67;
            if (v65 != &__dst[24])
            {
              v68 = DWORD2(v244);
              if (DWORD2(v244))
              {
                v69 = v64[4];
                if (v69 != v64 + 6)
                {
                  free(v69);
                  v68 = DWORD2(v244);
                }

                v64[4] = v244;
                *(v64 + 10) = v68;
                *(v64 + 11) = HIDWORD(v244);
                *&v244 = &v245;
                *(&v244 + 1) = 0;
              }

              else
              {
                *(v64 + 10) = 0;
              }
            }
          }

          else
          {
            v234 = 0;
            v233 = 0u;
            v235 = v237;
            v236 = 0;
            while (v51 != v52)
            {
              llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>::insert(&v233, v51++);
            }

            v56 = llvm::xxh3_64bits(v49, v50, v46);
            v57 = *llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::try_emplace_with_hash<>(&v205, v49, v50, v56);
            v58 = (v57 + 1);
            MEMORY[0x25F891030](*v58, 8);
            *v58 = v233;
            *&v233 = 0;
            v57[2] = *(&v233 + 1);
            *(&v233 + 1) = 0;
            *(v57 + 6) = v234;
            v234 = 0;
            if (v58 != &v233)
            {
              v59 = v236;
              if (v236)
              {
                v60 = v57[4];
                if (v60 != v57 + 6)
                {
                  free(v60);
                  v59 = v236;
                }

                v57[4] = v235;
                v61 = HIDWORD(v236);
                *(v57 + 10) = v59;
                *(v57 + 11) = v61;
                v235 = v237;
                HIDWORD(v236) = 0;
                v62 = &v236;
              }

              else
              {
                v62 = (v57 + 5);
              }

              *v62 = 0;
            }

            LOWORD(v227) = 773;
            v223 = v49;
            v224 = v50;
            v225 = "$";
            v1 = v1 & 0xFFFFFFFF00000000 | v37;
            *&v228 = &v223;
            v229 = v1;
            LOWORD(v231) = 2306;
            llvm::Twine::str(&v228, &__p);
            v70 = v244 + 8 * DWORD2(v244);
            v228 = 0uLL;
            LODWORD(v229) = 0;
            v230 = v232;
            v231 = 0;
            if (v52 != v70)
            {
              do
              {
                llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>::insert(&v228, v52++);
              }

              while (v52 != v70);
              v38 = *(&v238 + 1);
              v29 = *(&v240 + 1);
              v47 = v240;
            }

            v71 = v239;
            v72 = 8 * (v239 - v38) - 1;
            if (v239 == v38)
            {
              v72 = 0;
            }

            if (v72 == v29 + v47)
            {
              std::deque<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::__add_back_capacity(&v238);
              v38 = *(&v238 + 1);
              v71 = v239;
            }

            if (v71 == v38)
            {
              v73 = 0;
            }

            else
            {
              v73 = (*(v38 + (((*(&v240 + 1) + v240) >> 3) & 0x1FFFFFFFFFFFFFF8)) + 64 * ((*(&v240 + 1) + v240) & 0x3F));
            }

            if (SHIBYTE(v220) < 0)
            {
              std::string::__init_copy_ctor_external(v73, __p, *(&__p + 1));
            }

            else
            {
              v74 = __p;
              v73->__r_.__value_.__r.__words[2] = v220;
              *&v73->__r_.__value_.__l.__data_ = v74;
            }

            *&v74 = 0;
            v75 = v228;
            v73[2].__r_.__value_.__r.__words[0] = &v73[2].__r_.__value_.__r.__words[2];
            v76 = &v73[2];
            *(v76 - 24) = v75;
            v77 = *(&v228 + 1);
            v228 = v74;
            *(v76 - 16) = v77;
            v78 = v231;
            *(v76 - 8) = v229;
            LODWORD(v229) = 0;
            *(v76 + 8) = 0;
            if (v78)
            {
              llvm::SmallVectorImpl<mlir::Operation *>::operator=(v76, &v230);
            }

            v29 = ++*(&v240 + 1);
            if (v230 != v232)
            {
              free(v230);
            }

            MEMORY[0x25F891030](v228, 8);
            if (SHIBYTE(v220) < 0)
            {
              operator delete(__p);
            }

            if (v235 != v237)
            {
              free(v235);
            }

            ++v37;
            MEMORY[0x25F891030](v233, 8);
          }

          if (v244 != &v245)
          {
            free(v244);
          }

          MEMORY[0x25F891030](*&__dst[24], 8);
          if ((__dst[23] & 0x80000000) != 0)
          {
            break;
          }

          if (!v29)
          {
            goto LABEL_134;
          }
        }

        operator delete(*__dst);
      }

      while (v29);
    }

LABEL_134:
    v79 = *(&v238 + 1);
    v80 = v239;
    v81 = v239 - *(&v238 + 1);
    if (v239 - *(&v238 + 1) >= 0x11uLL)
    {
      do
      {
        v82 = *v79++;
        operator delete(v82);
        v81 -= 8;
      }

      while (v81 > 0x10);
    }

    while (v79 != v80)
    {
      v83 = *v79++;
      operator delete(v83);
    }

    if (v238)
    {
      operator delete(v238);
    }

    v194 = v208;
    if (v208)
    {
      v84 = (**(*(&v197 + 1) + 40))();
      v85 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(v194 + 8), *(v194 + 8) + 16 * *(v194 + 16), *(v84 + 16), *(v84 + 24));
      if (v86)
      {
        v87 = *(v85 + 8);
        if (v87)
        {
          if (*(*v87 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
          {
            mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v87[1], v87[1] + 16 * v87[2], "module_name", 0xBuLL);
            if (v88)
            {
              v89 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v87[1], v87[1] + 16 * v87[2], "module_name", 0xBuLL);
              if ((v90 & 1) != 0 && (v91 = *(v89 + 8)) != 0)
              {
                if (*(*v91 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
                {
                  v92 = *(v89 + 8);
                }

                else
                {
                  v92 = 0;
                }
              }

              else
              {
                v92 = 0;
              }

              mlir::Operation::setAttr(v197, "unflatten.belongsInModule", 0x19, v92);
            }

            mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v87[1], v87[1] + 16 * v87[2], "parameters", 0xAuLL);
            if (v93)
            {
              v192 = *(v197 + 24);
              LOWORD(v240) = 257;
              emitDiag(v192, 2, &v238, __dst);
              if (*__dst)
              {
                mlir::Diagnostic::operator<<<78ul>(&__dst[8], "setting parameters on a graph being unflattened-from is currently unsupported");
              }

              mlir::InFlightDiagnostic::~InFlightDiagnostic(__dst);
              *(this + 5) |= 4uLL;
              goto LABEL_298;
            }
          }
        }
      }
    }

    if (v206)
    {
        ;
      }
    }

    else
    {
      j = v205;
    }

    if (j != (v205 + 8 * v206))
    {
      break;
    }

    llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::~StringMap(&v205);
    v4 = *(&v211 + 1);
    if (!*(&v211 + 1))
    {
      goto LABEL_230;
    }
  }

  v96 = *j;
  v97 = **j;
  v215 = 0;
  v216 = 0;
  v234 = 0;
  v233 = 0u;
  v235 = v237;
  v236 = 0;
  LODWORD(v229) = 0;
  v228 = 0u;
  v230 = v232;
  v231 = 0;
  LODWORD(v239) = 0;
  v238 = 0u;
  *(&v239 + 1) = &v240 + 8;
  *&v240 = 0;
  v98 = *(v96 + 10);
  if (v98)
  {
    v99 = v96[4];
    v100 = 8 * v98;
    do
    {
      v101 = *v99++;
      *__dst = &v238;
      mlir::detail::walk<mlir::ForwardIterator>(v101, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<isolateRegionIO(llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u> const&,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &)::$_0>, __dst, 1);
      v100 -= 8;
    }

    while (v100);
  }

  mlir::ODIE::Compiler::Transforms::getValuesNotUsedByOps(&v238, __dst);
  if (*&__dst[8])
  {
    v102 = *__dst;
    v103 = 8 * *&__dst[8];
    do
    {
      llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>::insert(&v228, v102++);
      v103 -= 8;
    }

    while (v103);
  }

  v104 = *(v96 + 10);
  if (v104)
  {
    v105 = v96[4];
    v106 = 8 * v104;
    do
    {
      v107 = *v105++;
      v223 = &v238;
      v224 = &v233;
      mlir::detail::walk<mlir::ForwardIterator>(v107, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<isolateRegionIO(llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u> const&,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &)::$_1>, &v223, 1);
      v106 -= 8;
    }

    while (v106);
  }

  if (*__dst != &__dst[16])
  {
    free(*__dst);
  }

  if (*(&v239 + 1) != (&v240 + 8))
  {
    free(*(&v239 + 1));
  }

  MEMORY[0x25F891030](v238, 8);
  v108 = v236;
  if (v236 >= v231)
  {
    v109 = v230;
    v110 = &v233;
    v108 = v231;
  }

  else
  {
    v109 = v235;
    v110 = &v228;
  }

  llvm::set_intersection_impl<llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>>(&v223, v109, v108, v110);
  if (!v227)
  {
    v111 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
    v112 = v235 & 0xFFFFFFFFFFFFFFF8;
    if (!v236)
    {
      v112 = 0;
    }

    v113 = v230 & 0xFFFFFFFFFFFFFFF8;
    if (!v231)
    {
      v113 = 0;
    }

    *__dst = v112;
    *&__dst[8] = v236;
    *&v238 = v113;
    *(&v238 + 1) = v231;
    v114 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v111, __dst, &v238);
    if (v97)
    {
      v115 = 0;
      while (*(v96 + v115 + 48) != 36)
      {
        if (v97 == ++v115)
        {
          goto LABEL_188;
        }
      }
    }

    else
    {
LABEL_188:
      v115 = -1;
    }

    if (!v194)
    {
      goto LABEL_196;
    }

    v116 = v97 >= v115 ? v115 : v97;
    v117 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(v194 + 8), *(v194 + 8) + 16 * *(v194 + 16), v96 + 6, v116);
    if ((v118 & 1) == 0)
    {
      goto LABEL_196;
    }

    v119 = *(v117 + 8);
    if (v119)
    {
      if (*(*v119 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
LABEL_196:
        v120 = 0;
        v121 = 0;
        goto LABEL_197;
      }

      mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "noinline", 8uLL);
      v121 = v124;
      mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "externalize", 0xBuLL);
      v120 = v125;
      if ((v125 & 1) == 0 || ((v126 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "externalize", 0xBuLL), (v127 & 1) == 0) || (v128 = *(v126 + 8)) == 0 ? (v129 = 0) : *(*v128 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id ? (v129 = 0) : (v129 = *(v126 + 8)), *(v129 + 24) == 4 && **(v129 + 16) == 1702195796))
      {
        v129 = 0;
      }

      mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "module_name", 0xBuLL);
      if (v130)
      {
        if (v129)
        {
          v131 = *(v197 + 24);
          LOWORD(v240) = 257;
          emitDiag(v131, 1, &v238, __dst);
          v204 = 1283;
          v202 = "module_name";
          v203 = 11;
          v217[0] = v201;
          v218 = 770;
          *&__p = v217;
          v220 = "module_name";
          v221 = 11;
          v222 = 1538;
          *&v238 = &__p;
          LOWORD(v240) = 770;
          if (*__dst)
          {
            mlir::Diagnostic::operator<<(&__dst[8], &v238);
          }

          mlir::InFlightDiagnostic::~InFlightDiagnostic(__dst);
        }

        else
        {
          v132 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "module_name", 0xBuLL);
          if (v133)
          {
            v134 = *(v132 + 8);
            if (v134)
            {
              if (*(*v134 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
              {
                v135 = *(v132 + 8);
              }
            }
          }
        }
      }

      mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v119[1], v119[1] + 16 * v119[2], "parameters", 0xAuLL);
      if (v136)
      {
        v137 = *(v197 + 24);
        LOWORD(v240) = 257;
        emitDiag(v137, 2, &v238, __dst);
        if (*__dst)
        {
          mlir::Diagnostic::operator<<<73ul>(&__dst[8], "setting parameters on a graph to be unflattened is currently unsupported");
        }

        mlir::InFlightDiagnostic::~InFlightDiagnostic(__dst);
        *(this + 5) |= 4uLL;
        if (v226 != &v228)
        {
          free(v226);
        }

        MEMORY[0x25F891030](v223, 8);
        if (v230 != v232)
        {
          free(v230);
        }

        MEMORY[0x25F891030](v228, 8);
        if (v235 != v237)
        {
          free(v235);
        }

        goto LABEL_297;
      }
    }

    else
    {
      v120 = 0;
      v121 = 0;
    }

LABEL_197:
    v122 = *(v197 + 24);
    v123 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::GraphOp>(v214, *(**v122 + 32));
    *__dst = v122;
    *&__dst[8] = v123;
    *&__dst[16] = &v243;
    *&__dst[24] = 0x400000000;
    v245 = v247;
    v246 = 0x400000000;
    v248 = v250;
    v249 = 0x400000000;
    v251 = 4;
    v252 = &v254;
    v253 = 0x100000000;
    v255 = &v257;
    v256 = 0x100000000;
    v258 = 0;
    v259 = 0;
    v260 = &mlir::detail::TypeIDResolver<void,void>::id;
    v261 = 0;
    v262 = 0;
    mlir::ODIE::Compiler::CoreML::GraphOp::build(v214, __dst, (v96 + 6), v97, v114, 0, 0, (v120 & 1) == 0, v120 & 1, v121 & 1, 0, 0);
  }

  v177 = v226;
  v178 = 8 * v227;
  do
  {
    if ((~*(*v177 + 8) & 7) != 0)
    {
      v179 = *v177;
    }

    else
    {
      v179 = 0;
    }

    if (v179)
    {
      v180 = *(v179 + 8) & 7;
      if (v180 != 6)
      {
        v181 = v179 + 16 * v180 + 16;
LABEL_286:
        v182 = (v181 + 24);
        goto LABEL_287;
      }

      v181 = v179 + 24 * *(v179 + 16) + 120;
      if (v181)
      {
        goto LABEL_286;
      }
    }

    v182 = (*v177 + 32);
LABEL_287:
    v183 = *v182;
    LOWORD(v240) = 257;
    emitDiag(v183, 2, &v238, __dst);
    if (*__dst)
    {
      mlir::Diagnostic::operator<<<42ul>(&__dst[8], "value is both input and output to module ");
      if (*__dst)
      {
        LOWORD(v240) = 261;
        *&v238 = v96 + 6;
        *(&v238 + 1) = v97;
        mlir::Diagnostic::operator<<(&__dst[8], &v238);
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(__dst);
    v177 += 8;
    v178 -= 8;
  }

  while (v178);
  v184 = v226;
  *(this + 5) |= 4uLL;
  if (v184 != &v228)
  {
    free(v184);
  }

  MEMORY[0x25F891030](v223, 8);
  if (v230 != v232)
  {
    free(v230);
  }

  MEMORY[0x25F891030](v228, 8);
  if (v235 != v237)
  {
    free(v235);
  }

LABEL_297:
  MEMORY[0x25F891030](v233, 8);
LABEL_298:
  llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::~StringMap(&v205);
LABEL_302:
  v185 = v209[1];
  v186 = v210;
  v187 = v210 - v209[1];
  if (v210 - v209[1] >= 0x11)
  {
    do
    {
      v188 = *v185++;
      operator delete(v188);
      v187 -= 8;
    }

    while (v187 > 0x10);
  }

  while (v185 != v186)
  {
    v189 = *v185++;
    operator delete(v189);
  }

  if (v209[0])
  {
    operator delete(v209[0]);
  }

  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v212);
  result = MEMORY[0x25F891030](v212[0], 8);
  v191 = *MEMORY[0x277D85DE8];
  return result;
}

double mlir::Region::getOps<mlir::FunctionOpInterface>(uint64_t a1, void *a2)
{
  v4 = a2[1];
  if (*a2 == a2)
  {
    goto LABEL_11;
  }

  while (v4 != a2)
  {
    v5 = v4 - 1;
    if (!v4)
    {
      v5 = 0;
    }

    if (v5[4] != v5 + 4)
    {
      break;
    }

    v4 = v4[1];
  }

  if (v4 == a2)
  {
LABEL_11:
    v7 = 0;
  }

  else
  {
    v6 = v4 - 1;
    if (!v4)
    {
      v6 = 0;
    }

    v7 = v6[5];
  }

  v14 = a2;
  *&v12 = a2;
  *(&v12 + 1) = v4;
  *&v13 = v7;
  *(&v13 + 1) = a2;
  v15 = mlir::detail::op_filter_iterator<mlir::FunctionOpInterface,mlir::Region::OpIterator>::filter;
  llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v12);
  v8 = v13;
  *a1 = v12;
  *(a1 + 16) = v8;
  *(a1 + 32) = v14;
  *(a1 + 48) = v15;
  *&v12 = a2;
  *(&v12 + 1) = a2;
  *&v13 = 0;
  *(&v13 + 1) = a2;
  v14 = a2;
  v15 = mlir::detail::op_filter_iterator<mlir::FunctionOpInterface,mlir::Region::OpIterator>::filter;
  llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v12);
  v9 = v13;
  *(a1 + 64) = v12;
  *(a1 + 80) = v9;
  result = *&v14;
  *(a1 + 96) = v14;
  v11 = v15;
  *(a1 + 56) = mlir::detail::op_iterator<mlir::FunctionOpInterface,mlir::Region::OpIterator>::unwrap;
  *(a1 + 112) = v11;
  *(a1 + 120) = mlir::detail::op_iterator<mlir::FunctionOpInterface,mlir::Region::OpIterator>::unwrap;
  return result;
}

void *std::deque<mlir::FunctionOpInterface>::__add_back_capacity(void *a1)
{
  v1 = a1[4];
  v2 = v1 >= 0x100;
  v3 = v1 - 256;
  if (!v2)
  {
    v6 = a1[3];
    v7 = v6 - *a1;
    if (a1[2] - a1[1] < v7)
    {
      operator new();
    }

    v8 = v7 >> 2;
    if (v6 == *a1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8;
    }

    std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::FunctionOpInterface *>>(v9);
  }

  a1[4] = v3;
  v4 = a1[1];
  v10 = *v4;
  a1[1] = v4 + 1;
  return std::__split_buffer<mlir::FunctionOpInterface *>::emplace_back<mlir::FunctionOpInterface *&>(a1, &v10);
}

void *std::__split_buffer<mlir::FunctionOpInterface *>::emplace_back<mlir::FunctionOpInterface *&>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      if (v4 == *result)
      {
        v11 = 1;
      }

      else
      {
        v11 = &v4[-*result] >> 2;
      }

      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::FunctionOpInterface *>>(v11);
    }

    v7 = ((v6 >> 3) + 1) / -2;
    v8 = ((v6 >> 3) + 1) / 2;
    v9 = &v5[-8 * v8];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v8], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v7];
    v3[2] = &v9[v10];
  }

  *v4 = *a2;
  v3[2] += 8;
  return result;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::FunctionOpInterface *>>(unint64_t a1)
{
  if (!(a1 >> 61))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<buildModuleMap(mlir::FunctionOpInterface,llvm::function_ref<mlir::InFlightDiagnostic ()(mlir::Operation *)>)::$_0>(uint64_t a1, uint64_t a2)
{
  v14 = *MEMORY[0x277D85DE8];
  v8 = a2;
  if (**a1 != a2)
  {
    v7 = 0;
    v2 = *(a2 + 24);
    v3 = *(a1 + 8);
    v4 = *(a1 + 16);
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    operator new();
  }

  result = 1;
  v6 = *MEMORY[0x277D85DE8];
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZZL14buildModuleMapNS2_19FunctionOpInterfaceEN4llvm12function_refIFNS2_18InFlightDiagnosticEPNS2_9OperationEEEEENK3__0clESD_EUlNS2_8FusedLocEE_SH_NS2_9AttributeESJ_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISM_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSJ_E_NS_9allocatorISX_EEFNSO_INSP_ISJ_SQ_EEEESJ_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_286EA5F38;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZZL14buildModuleMapNS2_19FunctionOpInterfaceEN4llvm12function_refIFNS2_18InFlightDiagnosticEPNS2_9OperationEEEEENK3__0clESD_EUlNS2_8FusedLocEE_SH_NS2_9AttributeESJ_EENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISM_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSJ_E_NS_9allocatorISX_EEFNSO_INSP_ISJ_SQ_EEEESJ_EEclEOSJ_@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  v4 = *a2;
  if (*(**a2 + 136) == &mlir::detail::TypeIDResolver<mlir::FusedLoc,void>::id)
  {
    v6 = *(v4 + 24);
    if (!v6 || (v7 = *v6, (*v6)[17] != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr,void>::id) || (v8 = v6[2]) == 0)
    {
LABEL_20:
      *a3 = v4;
      v5 = 1;
      *(a3 + 8) = 1;
      goto LABEL_21;
    }

    v9 = result;
    v10 = v6[1];
    v11 = (v10 + 1);
    v12 = 1 - v8;
    while (1)
    {
      v14 = *v10++;
      v13 = v14;
      if (*(v14 + 24))
      {
        break;
      }

      v11 += 8;
      if (++v12 == 1)
      {
        v15 = 0;
        goto LABEL_16;
      }
    }

    if (v12)
    {
      v19 = *(result + 8);
      v15 = mlir::detail::StorageUserBase<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr,mlir::Attribute,mlir::ODIE::Compiler::CoreML::detail::TorchLocationExtrasAttrStorage,mlir::detail::AttributeUniquer,mlir::ODIE::Compiler::KeywordPrintableAttr::Trait>::getChecked<llvm::ArrayRef<mlir::StringAttr>>(llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<buildModuleMap(mlir::FunctionOpInterface,llvm::function_ref<mlir::InFlightDiagnostic ()(mlir::Operation *)>)::$_0::operator() const(mlir::Operation *)::{lambda(mlir::FusedLoc)#1}::operator() const(mlir::FusedLoc)::{lambda(void)#1}>, &v19, *(*v7 + 32), v11, -v12);
      if (!*(v13 + 24))
      {
LABEL_16:
        v18 = **v6;
        if (v15)
        {
          result = mlir::FusedLoc::get(*(v18 + 32), *(v4 + 8), *(v4 + 16), v15);
        }

        else
        {
          result = mlir::FusedLoc::get(*(v4 + 8), *(v4 + 16), 0, *(v18 + 32));
        }

        v4 = result;
        goto LABEL_20;
      }
    }

    else
    {
      v15 = 0;
    }

    v16 = *(v9 + 24);
    v17 = *v16;
    if ((*v16[1])() != v13)
    {
      **(v9 + 32) = v13;
    }

    goto LABEL_16;
  }

  v5 = 0;
  *a3 = 0;
LABEL_21:
  *(a3 + 16) = v5;
  return result;
}

size_t **llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::try_emplace_with_hash<>(llvm::StringMapImpl *a1, const void *a2, size_t a3, int a4)
{
  v7 = llvm::StringMapImpl::LookupBucketFor(a1, a2, a3, a4);
  i = (*a1 + 8 * v7);
  v9 = *i;
  if (*i == -8)
  {
    --*(a1 + 4);
  }

  else if (v9)
  {
    while (!v9 || v9 == -8)
    {
      v10 = i[1];
      ++i;
      v9 = v10;
    }

    return i;
  }

  buffer = llvm::allocate_buffer((a3 + 49), 8uLL);
  v13 = buffer;
  v14 = (buffer + 6);
  if (a3)
  {
    memcpy(buffer + 6, a2, a3);
  }

  v14[a3] = 0;
  *v13 = a3;
  v13[1] = 0;
  v13[2] = 0;
  v13[3] = 0;
  v13[4] = v14;
  v13[5] = 0;
  *i = v13;
  ++*(a1 + 3);
    ;
  }

  return i;
}

__n128 _ZNKSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZZL14buildModuleMapNS2_19FunctionOpInterfaceEN4llvm12function_refIFNS2_18InFlightDiagnosticEPNS2_9OperationEEEEENK3__0clESD_EUlNS2_8FusedLocEE0_SH_NS2_9AttributeENS2_8LocationEEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISN_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSJ_E_NS_9allocatorISY_EEFNSP_INSQ_ISJ_SR_EEEESJ_EE7__cloneEPNS0_6__baseIS13_EE(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_286EA5F80;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail20AttrTypeReplacerBaseINS2_16AttrTypeReplacerEE14addReplacementIZZL14buildModuleMapNS2_19FunctionOpInterfaceEN4llvm12function_refIFNS2_18InFlightDiagnosticEPNS2_9OperationEEEEENK3__0clESD_EUlNS2_8FusedLocEE0_SH_NS2_9AttributeENS2_8LocationEEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Entsr3stdE16is_convertible_vIT2_NS_8optionalINS_4pairISN_NS2_10WalkResultEEEEEEEvE4typeEOT_EUlSJ_E_NS_9allocatorISY_EEFNSP_INSQ_ISJ_SR_EEEESJ_EEclEOSJ_@<X0>(uint64_t result@<X0>, void ****a2@<X1>, uint64_t a3@<X8>)
{
  v4 = *a2;
  v5 = **a2;
  if (v5[17] == &mlir::detail::TypeIDResolver<mlir::FusedLoc,void>::id)
  {
    v7 = v4[3];
    if (v7)
    {
      v8 = *v7;
      if (*(*v7 + 17) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr,void>::id)
      {
        v9 = v7[1];
        v10 = v7[2];
        v11 = **(result + 8);
        v12 = *v9 == v11;
        if (v10 == v12)
        {
          v14 = 0;
        }

        else
        {
          if (*v9 == v11)
          {
            v13 = (v9 + 1);
          }

          else
          {
            v13 = v7[1];
          }

          v15 = *(result + 16);
          v14 = mlir::detail::StorageUserBase<mlir::ODIE::Compiler::CoreML::TorchLocationExtrasAttr,mlir::Attribute,mlir::ODIE::Compiler::CoreML::detail::TorchLocationExtrasAttrStorage,mlir::detail::AttributeUniquer,mlir::ODIE::Compiler::KeywordPrintableAttr::Trait>::getChecked<llvm::ArrayRef<mlir::StringAttr>>(llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<buildModuleMap(mlir::FunctionOpInterface,llvm::function_ref<mlir::InFlightDiagnostic ()(mlir::Operation *)>)::$_0::operator() const(mlir::Operation *)::{lambda(mlir::FusedLoc)#2}::operator() const(mlir::FusedLoc)::{lambda(void)#1}>, &v15, *(*v8 + 32), v13, v10 - v12);
          v5 = *v4;
        }

        result = mlir::FusedLoc::get(*(*v5 + 4), v4[1], v4[2], v14);
        v4 = result;
      }
    }

    *a3 = v4;
    v6 = 1;
    *(a3 + 8) = 1;
  }

  else
  {
    v6 = 0;
    *a3 = 0;
  }

  *(a3 + 16) = v6;
  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(mlir::Operation *)>::callback_fn<anonymous namespace::UnflattenTorchModulesPass::runOnOperation(void)::$_1>(mlir::Operation *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  *(*a2 + 40) |= 4uLL;
  v4 = 257;
  mlir::Operation::emitOpError(this, v3, a3);
}

void *std::deque<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>>::__add_back_capacity(void *a1)
{
  v1 = a1[4];
  v2 = v1 >= 0x40;
  v3 = v1 - 64;
  if (!v2)
  {
    v6 = a1[3];
    v7 = v6 - *a1;
    if (a1[2] - a1[1] < v7)
    {
      operator new();
    }

    v8 = v7 >> 2;
    if (v6 == *a1)
    {
      v9 = 1;
    }

    else
    {
      v9 = v8;
    }

    std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *>>(v9);
  }

  a1[4] = v3;
  v4 = a1[1];
  v10 = *v4;
  a1[1] = v4 + 1;
  return std::__split_buffer<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *,std::allocator<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *>>::emplace_back<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *&>(a1, &v10);
}

void *std::__split_buffer<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *,std::allocator<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *>>::emplace_back<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *&>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      if (v4 == *result)
      {
        v11 = 1;
      }

      else
      {
        v11 = &v4[-*result] >> 2;
      }

      std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *>>(v11);
    }

    v7 = ((v6 >> 3) + 1) / -2;
    v8 = ((v6 >> 3) + 1) / 2;
    v9 = &v5[-8 * v8];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v8], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v7];
    v3[2] = &v9[v10];
  }

  *v4 = *a2;
  v3[2] += 8;
  return result;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<std::string,llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>> *>>(unint64_t a1)
{
  if (!(a1 >> 61))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void llvm::StringMapEntry<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>::Destroy<llvm::MallocAllocator>(void *a1)
{
  v2 = a1[4];
  if (v2 != a1 + 6)
  {
    free(v2);
  }

  MEMORY[0x25F891030](a1[1], 8);

  JUMPOUT(0x25F891030);
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<isolateRegionIO(llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u> const&,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &)::$_0>(uint64_t *a1, uint64_t a2)
{
  v6 = a2;
  v4 = mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID();
  result = (*(**(a2 + 48) + 32))(*(a2 + 48), v4);
  if ((result & 1) == 0)
  {
    return llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>::insert(*a1, &v6);
  }

  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<isolateRegionIO(llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u> const&,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u> &)::$_1>(uint64_t result, uint64_t a2)
{
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v3 = result;
      v4 = (*(a2 + 72) + 24);
      do
      {
        v5 = *v4;
        v9 = v5;
        if ((~*(v5 + 8) & 7) == 0)
        {
          v5 = 0;
        }

        if (v5)
        {
          v6 = *(v5 + 8) & 7;
          if (v6 != 6)
          {
            v7 = v5 + 16 * v6 + 16;
LABEL_11:
            v8 = *v3;
            v10 = v7;
            result = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>,mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>::doFind<mlir::Operation const*>(v8, &v10);
            if (result && result != *v8 + 8 * *(v8 + 16))
            {
              goto LABEL_14;
            }

            goto LABEL_13;
          }

          v7 = v5 + 24 * *(v5 + 16) + 120;
          if (v7)
          {
            goto LABEL_11;
          }
        }

LABEL_13:
        result = llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>::insert(v3[1], &v9);
LABEL_14:
        v4 += 4;
        --v2;
      }

      while (v2);
    }
  }

  return result;
}

uint64_t llvm::set_intersection_impl<llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>,llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>>(uint64_t result, uint64_t *a2, unsigned int a3, uint64_t *a4)
{
  *(result + 16) = 0;
  *result = 0u;
  *(result + 24) = result + 40;
  *(result + 32) = 0;
  if (a3)
  {
    v6 = result;
    v7 = 8 * a3;
    do
    {
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::doFind<mlir::Value>(a4, a2);
      if (result)
      {
        result = llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,0u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,0u>::insert(v6, a2);
      }

      ++a2;
      v7 -= 8;
    }

    while (v7);
  }

  return result;
}

size_t llvm::filter_iterator_base<mlir::NamedAttribute const*,anonymous namespace::UnflattenTorchModulesPass::runOnOperation(void)::$_0,std::bidirectional_iterator_tag>::findNextValid(size_t result)
{
  v1 = *result;
  v2 = *(result + 8);
  if (*result != v2)
  {
    v3 = result;
    do
    {
      v4 = 0;
      v5 = *v1;
      while (1)
      {
        v6 = off_2799BED70[v4];
        if (v6)
        {
          break;
        }

        if (!*(v5 + 24))
        {
          goto LABEL_12;
        }

LABEL_10:
        if (++v4 == 4)
        {
          return result;
        }
      }

      result = strlen(off_2799BED70[v4]);
      if (*(v5 + 24) != result)
      {
        goto LABEL_10;
      }

      if (result)
      {
        result = memcmp(*(v5 + 16), v6, result);
        if (result)
        {
          goto LABEL_10;
        }
      }

LABEL_12:
      v1 += 2;
      *v3 = v1;
    }

    while (v1 != v2);
  }

  return result;
}

uint64_t llvm::StringMap<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>,llvm::MallocAllocator>::~StringMap(uint64_t a1)
{
  if (*(a1 + 12))
  {
    v2 = *(a1 + 8);
    if (v2)
    {
      v3 = 0;
      v4 = 8 * v2;
      do
      {
        v5 = *(*a1 + v3);
        if (v5 != -8 && v5 != 0)
        {
          llvm::StringMapEntry<llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,0u>,llvm::DenseSet<mlir::Operation *,llvm::DenseMapInfo<mlir::Operation *,void>>,0u>>::Destroy<llvm::MallocAllocator>(v5);
        }

        v3 += 8;
      }

      while (v4 != v3);
    }
  }

  free(*a1);
  return a1;
}

BOOL llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::FunctionOpInterface>::CallImpl<moveIntoModule(mlir::SymbolTableCollection &,mlir::ModuleOp,mlir::FunctionOpInterface)::$_1>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v24[0] = a2;
  v24[1] = a3;
  v4 = *(a2 + 16);
  if (v4)
  {
    v4 = *(v4 + 24) & 0xFFFFFFFFFFFFFFF8;
    if (v4)
    {
      v4 = *(v4 + 16);
    }
  }

  if (v4 != **a1)
  {
    return 1;
  }

  v6 = *(a1 + 8);
  v7 = (**(a3 + 40))();
  v9 = mlir::SymbolRefAttr::get(v7, 0, 0, v8);
  llvm::SmallVectorTemplateBase<mlir::FlatSymbolRefAttr,true>::push_back(v6, v9);
  v11 = mlir::SymbolRefAttr::get(*(***(a1 + 8) + 8), (**(a1 + 8) + 8), *(*(a1 + 8) + 8) - 1, v10);
  --*(*(a1 + 8) + 8);
  v12 = *a1;
  v20 = *(a1 + 16);
  v21 = v24;
  v22 = &v23;
  v23 = v11;
  v13 = *v12;
  v25 = &v20;
  mlir::detail::walk<mlir::ForwardIterator>(v13, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEENK3__1clESE_EUlNS1_15CallOpInterfaceEE_SG_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v25, 1);
  v19 = mlir::Operation::getParentWithTrait<mlir::OpTrait::SymbolTable>(v24[0]);
  v14 = v24[0];
  if (*(v24[0] + 16))
  {
    *(v24[0] + 16) = 0;
    v16 = *v14;
    v15 = v14[1];
    *v15 = *v14;
    *(v16 + 8) = v15;
    *v14 = 0;
    v14[1] = 0;
  }

  SymbolTable = mlir::SymbolTableCollection::getSymbolTable(*(a1 + 24), **(a1 + 16));
  mlir::SymbolTable::insert(SymbolTable, v24[0], 0);
  v18 = *(a1 + 32);
  v20 = *(a1 + 24);
  v21 = &v19;
  v22 = v18;
  v25 = &v20;
  return mlir::detail::walk<mlir::ForwardIterator>(v24[0], _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEENK3__1clESF_EUlNS1_15CallOpInterfaceEE0_SH_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v25, 1) != 0;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEENK3__1clESE_EUlNS1_15CallOpInterfaceEE_SG_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t ***a1, uint64_t a2)
{
  result = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (result)
  {
    v5 = result;
    v6 = *a1;
    v7 = **v6;
    if (v7 != result)
    {
      v8 = v4;
      v9 = result;
      while (1)
      {
        v10 = *(v9 + 16);
        if (!v10)
        {
          break;
        }

        v11 = *(v10 + 24) & 0xFFFFFFFFFFFFFFF8;
        if (!v11)
        {
          break;
        }

        v9 = *(v11 + 16);
        if (v9 == v7 || v9 == 0)
        {
          if (v9)
          {
            return result;
          }

          break;
        }
      }

      result = (*v4)(v4, result);
      v13 = (result & 0xFFFFFFFFFFFFFFF8);
      if ((result & 4) != 0)
      {
        v13 = 0;
      }

      if (v13)
      {
        v14 = v13[3];
        if (v14)
        {
          v13 = *(v13[2] + 8 * v14 - 8);
        }

        v15 = v13[1];
        v16 = v6[1];
        v17 = *v16;
        result = (**(v16[1] + 40))();
        if (result == v15)
        {
          v18 = v8[1];
          v19 = *v6[2] & 0xFFFFFFFFFFFFFFFBLL;

          return (v18)(v8, v5, v19);
        }
      }
    }
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEENK3__1clESF_EUlNS1_15CallOpInterfaceEE0_SH_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESQ_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t *a1, uint64_t a2)
{
  v18[26] = *MEMORY[0x277D85DE8];
  v3 = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (!v3)
  {
    result = 1;
    goto LABEL_13;
  }

  v5 = v3;
  v6 = *a1;
  v7 = (*v4)(v4, v3);
  if ((v7 & 4) != 0 || (v7 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v14 = "could not resolve the callee to a static symbol ref";
LABEL_12:
    v16 = v14;
    v17 = 259;
    mlir::Operation::emitError(v18, v5, &v16);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v18);
    result = 0;
    goto LABEL_13;
  }

  v8 = mlir::SymbolTableCollection::lookupSymbolIn(*v6, **(v6 + 8), (v7 & 0xFFFFFFFFFFFFFFF8));
  if (!v8 || (v10 = llvm::DefaultDoCastIfPossible<mlir::FunctionOpInterface,mlir::Operation *,llvm::CastInfo<mlir::FunctionOpInterface,mlir::Operation *,void>>::doCastIfPossible(v8)) == 0)
  {
    v14 = "could not resolve callee to a graph";
    goto LABEL_12;
  }

  v11 = *(v6 + 16);
  v12 = v11[3];
  if ((v12 & 2) == 0)
  {
    v11 = *v11;
  }

  result = (*(v12 & 0xFFFFFFFFFFFFFFF8))(v11, v10, v9) & 1;
LABEL_13:
  v15 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZL14moveIntoModuleRNS1_21SymbolTableCollectionENS1_8ModuleOpENS1_19FunctionOpInterfaceEE3__2NS1_15CallOpInterfaceES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t *a1, uint64_t a2)
{
  v48[6] = *MEMORY[0x277D85DE8];
  v3 = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (!v3)
  {
    v10 = 1;
    goto LABEL_41;
  }

  v5 = v3;
  v6 = v4;
  v7 = *a1;
  v8 = (*v4)(v4, v3);
  v10 = 1;
  if ((v8 & 4) == 0)
  {
    v11 = v8 & 0xFFFFFFFFFFFFFFF8;
    if ((v8 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      __src = mlir::SymbolRefAttr::get(*(v11 + 8), 0, 0, v9);
      v46 = v48;
      v47 = 0x600000000;
      llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::append<mlir::FlatSymbolRefAttr const*,void>(&v46, &__src, v43);
      llvm::SmallVectorImpl<mlir::FlatSymbolRefAttr>::append<mlir::FlatSymbolRefAttr const*,void>(&v46, *(v11 + 16), (*(v11 + 16) + 8 * *(v11 + 24)));
      Attr = mlir::Operation::getAttr(**v7, "sym_name", 8uLL);
      if (Attr && *(*Attr + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        Attr = 0;
      }

      v14 = mlir::SymbolRefAttr::get(Attr, 0, 0, v13);
      v16 = v46;
      v17 = v47;
      v18 = v46;
      if (v47)
      {
        v19 = 8 * v47;
        v18 = v46;
        while (*v18 != v14)
        {
          v18 += 8;
          v19 -= 8;
          if (!v19)
          {
            goto LABEL_38;
          }
        }
      }

      v20 = &v46[8 * v47];
      if (v18 != v20)
      {
        v21 = v20 - 8;
        if (v46 != v20 - 8)
        {
          v22 = 0;
          v23 = **(v7 + 8);
          while (1)
          {
            v24 = *v16;
            v25 = mlir::SymbolTableCollection::lookupSymbolIn(*(v7 + 16), v23, *v16);
            if (!v25)
            {
              break;
            }

            v23 = v25;
            v26 = mlir::detail::TypeIDResolver<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>,void>::resolveTypeID();
            if (((*(**(v23 + 48) + 32))(*(v23 + 48), v26) & 1) == 0)
            {
              break;
            }

            if (v23 == v5)
            {
LABEL_28:
              ++v22;
            }

            else
            {
              v27 = v5;
              while (1)
              {
                v28 = v27[2];
                if (!v28)
                {
                  break;
                }

                v29 = v28[3] & 0xFFFFFFFFFFFFFFF8;
                if (!v29)
                {
                  break;
                }

                v27 = *(v29 + 16);
                if (v27 == v23 || v27 == 0)
                {
                  if (!v27)
                  {
                    break;
                  }

                  goto LABEL_28;
                }
              }
            }

            v16 += 8;
            if (v16 == v21)
            {
              v16 = v46;
              v17 = v47;
              v31 = v22;
              goto LABEL_37;
            }
          }

          v39 = 257;
          mlir::Operation::emitError(&__src, v5, v38);
          if (__src)
          {
            mlir::Diagnostic::operator<<<52ul>(v43, "could not resolve symbol table component of callee ");
            if (__src)
            {
              v40 = 0;
              v41 = v24;
              v32 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v44, &v40, 1);
              v33 = v44 + 24 * v45;
              v34 = *v32;
              *(v33 + 16) = *(v32 + 16);
              *v33 = v34;
              ++v45;
              if (__src)
              {
                mlir::Diagnostic::operator<<<2ul>(v43, "\n");
              }
            }
          }

          mlir::InFlightDiagnostic::~InFlightDiagnostic(&__src);
          v10 = 0;
          goto LABEL_39;
        }

        v31 = 0;
LABEL_37:
        v35 = mlir::SymbolRefAttr::get(*(*&v16[8 * v31] + 8), &v16[8 * v31 + 8], v17 + ~v31, v15);
        (v6[1])(v6, v5, v35 & 0xFFFFFFFFFFFFFFFBLL);
      }

LABEL_38:
      v10 = 1;
LABEL_39:
      if (v46 != v48)
      {
        free(v46);
      }
    }
  }

LABEL_41:
  v36 = *MEMORY[0x277D85DE8];
  return v10;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZN12_GLOBAL__N_125UnflattenTorchModulesPass14runOnOperationEvE3__3NS1_4ODIE8Compiler6CoreML8ModuleOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, uint64_t a2)
{
  v44[6] = *MEMORY[0x277D85DE8];
  if (a2)
  {
    if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuleOp,void>::id)
    {
      v3 = **a1;
      if (*v3)
      {
        v4 = (*a1)[1];
        Attr = mlir::Operation::getAttr(a2, "sym_name", 8uLL);
        v6 = *(*Attr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id ? Attr : 0;
        v7 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(*v3 + 8), *(*v3 + 8) + 16 * *(*v3 + 16), *(v6 + 16), *(v6 + 24));
        if (v8)
        {
          v9 = *(v7 + 8);
          if (v9)
          {
            if (*(*v9 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
            {
              v10 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v9[1], v9[1] + 16 * v9[2], "parameters", 0xAuLL);
              if (v11)
              {
                v12 = *(v10 + 8);
                if (v12)
                {
                  if (*(*v12 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
                  {
                    v36 = v38;
                    v37 = 0x600000000;
                    v13 = *(a2 + 24);
                    v42 = v44;
                    v43 = 0x300000000;
                    v39[0] = v12[1];
                    llvm::StringRef::split(v39, &v42, 44, -1, 1);
                    if (v43)
                    {
                      v30 = v13;
                      v15 = v42;
                      v16 = 16 * v43;
                      while (1)
                      {
                        v33 = *v15;
                        *&v39[0] = llvm::StringRef::trim(&v33, " \t\n\v\f\r", 6);
                        *(&v39[0] + 1) = v17;
                        llvm::StringRef::split(v39, ":", 1uLL, v31);
                        v18 = llvm::StringRef::trim(v32, " \t\n\v\f\r", 6);
                        v20 = mlir::parseType(v18, v19, *(**v12 + 32), 0, 0);
                        if (!v20)
                        {
                          break;
                        }

                        v21 = v20;
                        v22 = *(**v12 + 32);
                        v23 = llvm::StringRef::trim(v31, " \t\n\v\f\r", 6);
                        v40 = 261;
                        *&v39[0] = v23;
                        *(&v39[0] + 1) = v24;
                        v26 = mlir::StringAttr::get(v22, v39, v25);
                        v27 = mlir::ODIE::Compiler::CoreML::ParamDeclAttr::get(v26, v21);
                        llvm::SmallVectorTemplateBase<mlir::ODIE::Compiler::CoreML::ParamDeclAttr,true>::push_back(&v36, v27);
                        v15 += 2;
                        v16 -= 16;
                        if (!v16)
                        {
                          v28 = 0;
                          goto LABEL_24;
                        }
                      }

                      v35 = 257;
                      emitDiag(v30, 2, v34, v39);
                      if (*&v39[0])
                      {
                        if (*&v39[0])
                        {
                          v35 = 261;
                          v34[0] = v32[0];
                          v34[1] = v32[1];
                          mlir::Diagnostic::operator<<(v39 + 8, v34);
                          if (*&v39[0])
                          {
                          }
                        }
                      }

                      v28 = v41;
                      mlir::InFlightDiagnostic::~InFlightDiagnostic(v39);
                    }

                    else
                    {
                      v28 = 0;
                    }

LABEL_24:
                    if (v42 != v44)
                    {
                      free(v42);
                    }

                    if (v28)
                    {
                      *(v4 + 40) |= 4uLL;
                    }

                    else
                    {
                      *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64) = mlir::ODIE::Compiler::CoreML::ParamDeclArrayAttr::get(*(***(a2 + 24) + 32), v36, v37, v14);
                      v42 = &v36;
                      *&v39[0] = &v42;
                      mlir::detail::walk<mlir::ForwardIterator>(a2, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZN12_GLOBAL__N_125UnflattenTorchModulesPass14runOnOperationEvENK3__3clENS1_4ODIE8Compiler6CoreML8ModuleOpEEUlNSG_8InvokeOpEE_SI_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, v39, 1);
                    }

                    if (v36 != v38)
                    {
                      free(v36);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  v29 = *MEMORY[0x277D85DE8];
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZN12_GLOBAL__N_125UnflattenTorchModulesPass14runOnOperationEvENK3__3clENS1_4ODIE8Compiler6CoreML8ModuleOpEEUlNSG_8InvokeOpEE_SI_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(void ***a1, uint64_t a2)
{
  v29[6] = *MEMORY[0x277D85DE8];
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
  {
    v3 = *a1;
    v4 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1) + 8);
    if (v4)
    {
      v5 = *v4;
      v6 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
      v7 = mlir::detail::InterfaceMap::lookup(v5 + 8, v6);
    }

    else
    {
      v7 = 0;
    }

    v27 = v29;
    v28 = 0x300000000;
    v8 = *(*v3 + 2);
    if (v8)
    {
      v9 = **v3;
      v10 = 8 * v8;
      do
      {
        v11 = mlir::ODIE::Compiler::CoreML::ParamRefAttr::get(*v9);
        v12 = v11;
        if (v11)
        {
          v13 = *v11;
          v14 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
          v15 = mlir::detail::InterfaceMap::lookup(v13 + 8, v14);
        }

        else
        {
          v15 = 0;
        }

        llvm::SmallVectorTemplateBase<mlir::TypedAttr,true>::push_back(&v27, v12, v15);
        ++v9;
        v10 -= 8;
      }

      while (v10);
      v16 = v27;
      v17 = v28;
    }

    else
    {
      v17 = 0;
      v16 = v29;
    }

    v18 = (*v7)(v7, v4);
    v19 = mlir::ODIE::Compiler::CoreML::ParamBindAttr::get(*(**v4 + 32), v4, v18, v16, v17);
    if (*(*v4 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ParamBindAttr,void>::id)
    {
      v21 = v4[3];
      v22 = v4[4];
      v23 = v28;
      v24 = v28 + ((16 * v22) >> 4);
      if (v24 > HIDWORD(v28))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(&v27, v29, v24, 16);
        v23 = v28;
      }

      if (v22)
      {
        memcpy(v27 + 16 * v23, v21, 16 * v22);
        v23 = v28;
      }

      LODWORD(v28) = v23 + v22;
      v19 = mlir::ODIE::Compiler::CoreML::ParamBindAttr::get(*(**v4[1] + 32), v4[1], v4[2], v27, v23 + v22);
    }

    v25 = a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1);
    *(v25 + 8) = v19;
    *(v25 + 16) = v20;
    if (v27 != v29)
    {
      free(v27);
    }
  }

  v26 = *MEMORY[0x277D85DE8];
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<anonymous namespace::UnflattenTorchModulesPass::runOnOperation(void)::$_4>(uint64_t a1, mlir::Operation *a2)
{
  v3 = mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID();
  if ((*(**(a2 + 6) + 32))(*(a2 + 6), v3))
  {
    v4 = *(a2 + 9);
    if (v4)
    {
      v5 = (a2 - 16);
    }

    else
    {
      v5 = 0;
    }

    if (v4)
    {
      v6 = 0;
      v7 = (a2 - 16);
      while (1)
      {
        v8 = v5;
        if (v6)
        {
          v9 = *(a2 - 1) & 7;
          v10 = a2 - 16;
          v11 = v6;
          if (v9 == 6)
          {
            goto LABEL_11;
          }

          v12 = (5 - v9);
          v8 = v7;
          v11 = v6 - v12;
          if (v6 > v12)
          {
            break;
          }
        }

LABEL_12:
        if (*v8)
        {
          return;
        }

        ++v6;
        v7 -= 2;
        if (v4 == v6)
        {
          goto LABEL_14;
        }
      }

      v10 = a2 - 16 * v12 - 16;
LABEL_11:
      v8 = (v10 - 24 * v11);
      goto LABEL_12;
    }

LABEL_14:
    if (*(a2 + 2))
    {
      *(a2 + 2) = 0;
      v14 = *a2;
      v13 = *(a2 + 1);
      *v13 = *a2;
      *(v14 + 8) = v13;
      *a2 = 0;
      *(a2 + 1) = 0;
    }

    mlir::Operation::destroy(a2);
  }
}

void llvm::SmallVectorTemplateBase<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,false>::destroy_range(void **a1, void **a2)
{
  if (a2 != a1)
  {
    v6[3] = v2;
    v6[4] = v3;
    v5 = a2 - 3;
    do
    {
      v6[0] = v5;
      std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__destroy_vector::operator()[abi:nn200100](v6);
      if (*(v5 - 1) < 0)
      {
        operator delete(*(v5 - 3));
      }

      v5 -= 6;
    }

    while (v5 + 3 != a1);
  }
}

void std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>::destroy[abi:nn200100](uint64_t a1, uint64_t a2)
{
  if (*(a2 + 47) < 0)
  {
    operator delete(*(a2 + 24));
  }

  if (*(a2 + 23) < 0)
  {
    v3 = *a2;

    operator delete(v3);
  }
}

void std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>::destroy[abi:nn200100](v1, v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t llvm::SmallVector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,1u>::~SmallVector(uint64_t a1)
{
  llvm::SmallVectorTemplateBase<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,false>::destroy_range(*a1, (*a1 + 48 * *(a1 + 8)));
  if (*a1 != a1 + 16)
  {
    free(*a1);
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::UpdateSignatureToHandlesBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass>::UpdateSignatureToHandlesBase(uint64_t a1, uint64_t a2)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA6068;
  *&v5 = "Maps a function name to a list of input-output pairs where the output represents a mutation of the input. These IO pairs will be updated by the pass to have handle type.";
  *(&v5 + 1) = 169;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::ListOption<llvm::cl::desc>(a1 + 336, a1 + 144, &v5);
  *(a1 + 336) = &unk_286EA60D8;
  *(a1 + 576) = &unk_286EA6158;
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*>(a1 + 456, *a2, (*a2 + 48 * *(a2 + 8)), *(a2 + 8));
  *(a1 + 584) = 1;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass::~UpdateSignatureToHandlesPass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::UpdateSignatureToHandlesPass *this)
{
  *this = &unk_286EA6068;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA6068;
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::UpdateSignatureToHandlesBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass>::getDependentDialects(uint64_t a1, uint64_t a2)
{
  mlir::DialectRegistry::insert<mlir::ODIE::Compiler::TorchImport::TorchImportDialect>(a2);

  return mlir::DialectRegistry::insert<mlir::ODIE::Compiler::CoreML::CoreMLDialect>(a2);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::UpdateSignatureToHandlesPass *this)
{
  v98[8] = *MEMORY[0x277D85DE8];
  v1 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v2 = *(***(v1 + 24) + 32);
  v80[0] = 0;
  v80[1] = 0;
  v81 = 0;
  v78[0] = v2;
  v78[1] = 0;
  v79 = 0uLL;
  v77 = &unk_286E81468;
  v90 = this;
  v91 = &v77;
  v85 = &v90;
  mlir::detail::walk<mlir::ForwardIterator>(v1, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_128UpdateSignatureToHandlesPass14runOnOperationEvE3__0NS1_19FunctionOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v85, 1);
  v74 = 0;
  v73 = 0u;
  v3 = &v77;
  v75 = &v77;
  v76 = 0;
  v90 = v80;
  v91 = &v73;
  v85 = &v90;
  mlir::detail::walk<mlir::ForwardIterator>(v1, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_128UpdateSignatureToHandlesPass14runOnOperationEvE3__1NSC_6CoreML8InvokeOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v85, 1);
  v4 = v75;
  if (!v76)
  {
    goto LABEL_92;
  }

  v68 = &v89;
  v69 = v75 + 80 * v76;
  v5 = v87;
  v6 = v84;
  v64 = v95;
  v65 = v94;
  v62 = v97;
  v63 = v96;
  v60 = &v77;
  v61 = v98;
  v66 = v84;
  v67 = v87;
  do
  {
    v7 = *v4;
    if (*v4)
    {
      InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(*v4);
    }

    else
    {
      InterfaceFor = 0;
    }

    if (v88[0] != v68)
    {
      free(v88[0]);
    }

    v9 = v4[9];
    v85 = v5;
    v86 = 0x600000000;
    v82 = v6;
    v83 = 0x600000000;
    if ((*(v9 + 46) & 0x80) != 0)
    {
      v10 = *(v9 + 68);
      if (v10)
      {
        v11 = *(v9 + 72) + 24;
        do
        {
          v12 = *v11;
          if ((~*(*v11 + 8) & 7) != 0)
          {
            v13 = *v11;
          }

          else
          {
            v13 = 0;
          }

          if (v13)
          {
            v14 = *(v13 + 8) & 7;
            if (v14 != 6)
            {
              v16 = v13 + 16 * v14 + 16;
LABEL_19:
              if (*(*(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReadHandleOp,void>::id)
              {
                v12 = *(*(v16 + 72) + 24);
                v17 = v86;
                if (v86 >= HIDWORD(v86))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod(&v85, v5, v86 + 1, 8);
                  v17 = v86;
                }

                *(v85 + v17) = v16;
                LODWORD(v86) = v86 + 1;
              }

              goto LABEL_23;
            }

            v15 = v13 + 24 * *(v13 + 16);
            v16 = v15 + 120;
            if (v15 != -120)
            {
              goto LABEL_19;
            }
          }

LABEL_23:
          llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v82, v12);
          v11 += 32;
          --v10;
        }

        while (v10);
      }
    }

    v79 = vextq_s8(*(v9 + 8), *(v9 + 8), 8uLL);
    v18 = *(v9 + 24);
    v19 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::InvokeOp>(v78, *(**v18 + 32));
    v90 = v18;
    v91 = v19;
    v92 = v65;
    v93 = 0x400000000;
    v94[4] = v64;
    v94[5] = 0x400000000;
    v95[4] = v63;
    v95[5] = 0x400000000;
    v96[8] = 4;
    v96[9] = v62;
    v96[10] = 0x100000000;
    v97[1] = v61;
    v97[2] = 0x100000000;
    v98[1] = 0;
    v98[2] = 0;
    v98[3] = &mlir::detail::TypeIDResolver<void,void>::id;
    v98[4] = 0;
    v98[6] = 0;
    v70 = v4;
    mlir::ODIE::Compiler::CoreML::InvokeOp::build(v78, &v90, *v4, v82 & 0xFFFFFFFFFFFFFFF9, v83);
    v20 = mlir::Operation::create(&v90);
    mlir::OpBuilder::insert(v78, v20);
    v21 = *(*(v20 + 6) + 16);
    mlir::OperationState::~OperationState(&v90);
    if (v21 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
    {
      v22 = v20;
    }

    else
    {
      v22 = 0;
    }

    v72 = v22;
    v23 = *(v9 + 36);
    v24 = v9 - 16;
    if (v23)
    {
      v25 = (v9 - 16);
    }

    else
    {
      v25 = 0;
    }

    if (v23)
    {
      v26 = 0;
      v71 = v72 - 96;
      do
      {
        v27 = v25;
        if (v26)
        {
          v28 = *(v9 - 8) & 7;
          v29 = v24;
          v30 = v26;
          if (v28 != 6)
          {
            v31 = (5 - v28);
            v30 = v26 - v31;
            if (v26 <= v31)
            {
              v27 = &v25[-2 * v26];
              goto LABEL_38;
            }

            v29 = &v25[-2 * v31];
          }

          v27 = &v29[-3 * v30];
        }

LABEL_38:
        v32 = *v27;
        if (*v27)
        {
          v33 = v9;
          v34 = v26 + 1;
          if (v26 >= 6)
          {
            v35 = &v71[-24 * (v26 - 5)];
          }

          else
          {
            v35 = &v72[-16 * ((v26 + 1) & 0xF)];
          }

          do
          {
            while (1)
            {
              v36 = v32[2];
              v32 = *v32;
              if (v36 && v36[6][2] == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::WriteHandleOp,void>::id)
              {
                break;
              }

              mlir::RewriterBase::replaceAllUsesWith(&v77, v27, v35);
              if (!v32)
              {
                goto LABEL_51;
              }
            }

            mlir::RewriterBase::replaceAllUsesWith(&v77, v36 - 2, v35);
            if (v36[2])
            {
              v36[2] = 0;
              v39 = *v36;
              v38 = v36[1];
              *v38 = *v36;
              v39[1] = v38;
              *v36 = 0;
              v36[1] = 0;
            }

            mlir::Operation::destroy(v36);
          }

          while (v32);
LABEL_51:
          v9 = v33;
        }

        else
        {
          v34 = v26 + 1;
        }

        v26 = v34;
      }

      while (v34 != v23);
    }

    if (*(v9 + 16))
    {
      *(v9 + 16) = 0;
      v41 = *v9;
      v40 = *(v9 + 8);
      *v40 = *v9;
      *(v41 + 8) = v40;
      *v9 = 0;
      *(v9 + 8) = 0;
    }

    mlir::Operation::destroy(v9);
    v6 = v66;
    v5 = v67;
    if (v86)
    {
      v42 = v85;
      v43 = 8 * v86;
      do
      {
        v44 = *v42;
        v45 = *(*v42 + 36);
        v46 = *v42 - 16;
        if (!v45)
        {
          v46 = 0;
        }

        v90 = v46;
        v91 = 0;
        v92 = v46;
        v93 = v45;
        v94[0] = 0;
        if (!v45 || (mlir::ResultRange::UseIterator::skipOverResultsWithNoUsers(&v90), !v94[0]))
        {
          v47 = *(*(v44 + 9) + 56);
          if ((~*(v47 + 8) & 7) == 0)
          {
            v47 = 0;
          }

          if (v47)
          {
            v48 = *(v47 + 8) & 7;
            if (v48 == 6)
            {
              v49 = v47 + 24 * *(v47 + 16) + 120;
            }

            else
            {
              v49 = v47 + 16 * v48 + 16;
            }
          }

          else
          {
            v49 = 0;
          }

          if (*(v44 + 2))
          {
            *(v44 + 2) = 0;
            v51 = *v44;
            v50 = *(v44 + 1);
            *v50 = *v44;
            *(v51 + 8) = v50;
            *v44 = 0;
            *(v44 + 1) = 0;
          }

          mlir::Operation::destroy(v44);
          if (v49)
          {
            v52 = *(v49 + 36);
            v53 = (v49 - 16);
            if (!v52)
            {
              v53 = 0;
            }

            v90 = v53;
            v91 = 0;
            v92 = v53;
            v93 = v52;
            v94[0] = 0;
            if (!v52 || (mlir::ResultRange::UseIterator::skipOverResultsWithNoUsers(&v90), !v94[0]))
            {
              if (*(v49 + 16))
              {
                *(v49 + 16) = 0;
                v55 = *v49;
                v54 = *(v49 + 8);
                *v54 = *v49;
                *(v55 + 8) = v54;
                *v49 = 0;
                *(v49 + 8) = 0;
              }

              mlir::Operation::destroy(v49);
            }
          }
        }

        v42 += 8;
        v43 -= 8;
      }

      while (v43);
    }

    if (v82 != v6)
    {
      free(v82);
    }

    if (v85 != v5)
    {
      free(v85);
    }

    v4 = v70 + 10;
  }

  while (v70 + 10 != v69);
  v4 = v75;
  if (v76)
  {
    v56 = (v75 + 80 * v76 - 72);
    v57 = -80 * v76;
    v3 = v60;
    do
    {
      if (v56 + 2 != *v56)
      {
        free(*v56);
      }

      v56 -= 10;
      v57 += 80;
    }

    while (v57);
    v4 = v75;
  }

  else
  {
    v3 = v60;
  }

LABEL_92:
  if (v4 != v3)
  {
    free(v4);
  }

  MEMORY[0x25F891030](v73, 8);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>,mlir::Operation *,std::unique_ptr<mlir::SymbolTable>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::unique_ptr<mlir::SymbolTable>>>::destroyAll(v80);
  result = MEMORY[0x25F891030](v80[0], 8);
  v59 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::ListOption<llvm::cl::desc>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  v6 = llvm::cl::Option::Option(a1, 1, 0);
  *(v6 + 168) = 0;
  *(v6 + 152) = 0u;
  *(v6 + 136) = 0u;
  *(v6 + 120) = 0u;
  *v6 = &unk_286EA6258;
  *(v6 + 184) = 0;
  *(v6 + 192) = 0;
  *(v6 + 176) = 0;
  *(v6 + 200) = &unk_286EA5FC8;
  *(v6 + 208) = &unk_286EA62C0;
  *(v6 + 232) = v6 + 208;
  llvm::cl::Option::setArgStr(v6, "function-io-aliases", 19);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v22);
  *(a1 + 32) = *a3;
  llvm::cl::Option::addArgument(a1);
  v7 = a1 + 240;
  *(a1 + 248) = 0;
  *a1 = &unk_286EA6198;
  *(a1 + 240) = &unk_286EA6218;
  *(a1 + 256) = &unk_286EA5FC8;
  if ((*(a1 + 168) & 1) == 0)
  {
    *(a1 + 168) = 1;
  }

  v9 = *(a2 + 168);
  v8 = *(a2 + 176);
  if (v9 >= v8)
  {
    v11 = *(a2 + 160);
    v12 = (v9 - v11) >> 3;
    if ((v12 + 1) >> 61)
    {
      std::vector<mlir::detail::PassOptions::OptionBase *>::__throw_length_error[abi:nn200100]();
    }

    v13 = v8 - v11;
    v14 = v13 >> 2;
    if (v13 >> 2 <= (v12 + 1))
    {
      v14 = v12 + 1;
    }

    if (v13 >= 0x7FFFFFFFFFFFFFF8)
    {
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v14;
    }

    if (v15)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::detail::PassOptions::OptionBase *>>(a2 + 160, v15);
    }

    v16 = (8 * v12);
    *v16 = v7;
    v10 = 8 * v12 + 8;
    v17 = *(a2 + 160);
    v18 = *(a2 + 168) - v17;
    v19 = v16 - v18;
    memcpy(v16 - v18, v17, v18);
    v20 = *(a2 + 160);
    *(a2 + 160) = v19;
    *(a2 + 168) = v10;
    *(a2 + 176) = 0;
    if (v20)
    {
      operator delete(v20);
    }
  }

  else
  {
    *v9 = v7;
    v10 = (v9 + 1);
  }

  *(a2 + 168) = v10;
  return a1;
}

BOOL mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    v12 = *(a1 + 120);
    for (i = *(a1 + 128); i != v12; std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](i))
    {
      i -= 48;
    }

    *(a1 + 128) = v12;
    *(a1 + 168) = 0;
  }

  *(a1 + 248) = 1;
  v14 = a1;
  v15[0] = a1 + 256;
  v16[0] = a3;
  v16[1] = a4;
  v15[1] = a1;
  v15[2] = v16;
  v15[3] = &v14;
  return (mlir::detail::pass_options::parseCommaSeparatedList(a1, a3, a4, a5, a6, llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases> &,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)#1} &&)::{lambda(llvm::StringRef)#1}>, v15) & 1) == 0;
}

void mlir::Pass::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::list<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::setDefault(void *a1)
{
  a1[23] = a1[22];
  v3 = a1[15];
  for (i = a1[16]; i != v3; std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](i))
  {
    i -= 48;
  }

  a1[16] = v3;
}

llvm::raw_ostream *mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  v3 = result;
  if (*(result + 168) != 1 || (*(result + 16) == *(result + 15) ? (v4 = (*(result + 19) - *(result + 18)) >> 3 == 0xAAAAAAAAAAAAAAABLL * ((*(result + 16) - *(result + 15)) >> 4)) : (v4 = 0), !v4))
  {
    result = llvm::raw_ostream::operator<<(this, *(result + 2), *(result + 3));
    v5 = *(result + 4);
    if (*(result + 3) - v5 > 1uLL)
    {
      *v5 = 31549;
      *(result + 4) += 2;
    }

    else
    {
      result = llvm::raw_ostream::write(result, "={", 2uLL);
    }

    v6 = *(v3 + 15);
    v7 = *(v3 + 16);
    if (v6 != v7)
    {
      result = llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::print(this, *(v3 + 15));
      for (i = v6 + 48; i != v7; i += 48)
      {
        v9 = *(this + 4);
        if (*(this + 3) == v9)
        {
          llvm::raw_ostream::write(this, ",", 1uLL);
        }

        else
        {
          *v9 = 44;
          ++*(this + 4);
        }

        result = llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::print(this, i);
      }
    }

    v10 = *(this + 4);
    if (*(this + 3) == v10)
    {

      return llvm::raw_ostream::write(this, "}", 1uLL);
    }

    else
    {
      *v10 = 125;
      ++*(this + 4);
    }
  }

  return result;
}

void mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*>(a1 + 120, *(a2 - 120), *(a2 - 112), 0xAAAAAAAAAAAAAAABLL * ((*(a2 - 112) - *(a2 - 120)) >> 4));
  *(a1 + 248) = 1;
  *(a1 + 248) = *(a2 + 8);
}

void non-virtual thunk tomlir::Pass::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*>(a1 - 120, *(a2 - 120), *(a2 - 112), 0xAAAAAAAAAAAAAAABLL * ((*(a2 - 112) - *(a2 - 120)) >> 4));
  *(a1 + 8) = 1;
  *(a1 + 8) = *(a2 + 8);
}

void mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1);

  JUMPOUT(0x25F891040);
}

{
  *a1 = &unk_286EA6258;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__destroy_vector::operator()[abi:nn200100](&v4);

  llvm::cl::Option::~Option(a1);
}

void non-virtual thunk tomlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(uint64_t a1)
{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1 - 240);
}

{
  mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~ListOption(a1 - 240);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::list<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  memset(v30, 0, sizeof(v30));
  *__p = 0u;
  if (*(a1 + 168) == 1)
  {
    *(a1 + 184) = *(a1 + 176);
    v11 = *(a1 + 120);
    for (i = *(a1 + 128); i != v11; std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](i))
    {
      i -= 48;
    }

    *(a1 + 128) = v11;
    *(a1 + 168) = 0;
  }

  v12 = llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::parse(a1, a5, a6, __p);
  if ((v12 & 1) == 0)
  {
    std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::push_back[abi:nn200100]((a1 + 120), __p);
    *(a1 + 12) = a2;
    v14 = *(a1 + 184);
    v13 = *(a1 + 192);
    if (v14 >= v13)
    {
      v16 = *(a1 + 176);
      v17 = v14 - v16;
      v18 = (v14 - v16) >> 2;
      v19 = v18 + 1;
      if ((v18 + 1) >> 62)
      {
        goto LABEL_24;
      }

      v20 = v13 - v16;
      if (v20 >> 1 > v19)
      {
        v19 = v20 >> 1;
      }

      v21 = v20 >= 0x7FFFFFFFFFFFFFFCLL;
      v22 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v21)
      {
        v22 = v19;
      }

      if (v22)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(a1 + 176, v22);
      }

      v23 = (v14 - v16) >> 2;
      v24 = (4 * v18);
      v25 = (4 * v18 - 4 * v23);
      *v24 = a2;
      v15 = v24 + 1;
      memcpy(v25, v16, v17);
      v26 = *(a1 + 176);
      *(a1 + 176) = v25;
      *(a1 + 184) = v15;
      *(a1 + 192) = 0;
      if (v26)
      {
        operator delete(v26);
      }
    }

    else
    {
      *v14 = a2;
      v15 = v14 + 4;
    }

    *(a1 + 184) = v15;
    v27 = *(a1 + 232);
    if (v27)
    {
      (*(*v27 + 48))(v27, __p);
      goto LABEL_20;
    }

    std::__throw_bad_function_call[abi:nn200100]();
LABEL_24:
    std::vector<unsigned int>::__throw_length_error[abi:nn200100]();
  }

LABEL_20:
  v31 = v30 + 1;
  std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__destroy_vector::operator()[abi:nn200100](&v31);
  if (SBYTE7(v30[0]) < 0)
  {
    operator delete(__p[0]);
  }

  return v12;
}

void llvm::cl::list<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,BOOL,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::~list(uint64_t a1)
{
  *a1 = &unk_286EA6258;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__destroy_vector::operator()[abi:nn200100](&v4);

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA6258;
  std::__function::__value_func<void ()(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)>::~__value_func[abi:nn200100](a1 + 208);
  v2 = *(a1 + 176);
  if (v2)
  {
    *(a1 + 184) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 144);
  if (v3)
  {
    *(a1 + 152) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 120);
  std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__destroy_vector::operator()[abi:nn200100](&v4);
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

uint64_t llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::parse(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v44 = a2;
  v45 = a3;
  v7 = llvm::StringRef::split(&v44, ":", 1uLL, v42);
  if (v42[1] && (v6 = MEMORY[0x25F890B30](a4, v42[0], v7), *(&v43 + 1)))
  {
    v51 = 0uLL;
    v52 = v43;
    *&v53 = ";";
    *(&v53 + 1) = 1;
    llvm::StringRef::split(&v52, ";", 1uLL, v36);
    v51 = *v36;
    v52 = *&v36[16];
    v48 = 0u;
    v47 = 0u;
    *&v49 = ";";
    *(&v49 + 1) = 1;
    llvm::StringRef::split(&v48, ";", 1uLL, v36);
    v47 = *v36;
    v48 = *&v36[16];
    v36[0] = v50;
    *&v36[8] = v51;
    *&v36[24] = v52;
    v37 = v53;
    if (v53 == &v50)
    {
      *&v37 = v36;
      *(&v37 + 1) = 1;
    }

    v38 = v46;
    v39 = v47;
    v40 = v48;
    v41 = v49;
    if (v49 == &v46)
    {
      *&v41 = &v38;
      *(&v41 + 1) = 1;
    }

    v51 = *&v36[8];
    v52 = *&v36[24];
    v53 = v37;
    if (v37 == v36)
    {
      *&v53 = &v50;
      *(&v53 + 1) = 1;
    }

    v47 = v39;
    v48 = v40;
    v49 = v41;
    if (v41 == &v38)
    {
      *&v49 = &v46;
      *(&v49 + 1) = 1;
    }

    if (v51 != v47)
    {
      do
      {
        v35 = v51;
        llvm::StringRef::split(&v35, "|", 1uLL, &__src);
        v8 = __len;
        if (__len > 0x7FFFFFFFFFFFFFF7)
        {
          goto LABEL_44;
        }

        if (__len >= 0x17)
        {
          operator new();
        }

        v29[7] = __len;
        if (__len)
        {
          memmove(&v28, __src, __len);
        }

        v29[v8 - 16] = 0;
        v9 = v34;
        if (v34 > 0x7FFFFFFFFFFFFFF7)
        {
LABEL_44:
          std::string::__throw_length_error[abi:nn200100]();
        }

        if (v34 >= 0x17)
        {
          operator new();
        }

        HIBYTE(v30) = v34;
        if (v34)
        {
          memmove(&v29[8], v33, v34);
        }

        v29[v9 + 8] = 0;
        v10 = a4[4];
        v11 = a4[5];
        if (v10 >= v11)
        {
          v13 = a4[3];
          v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v13) >> 4);
          v15 = v14 + 1;
          if (v14 + 1 > 0x555555555555555)
          {
            std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__throw_length_error[abi:nn200100]();
          }

          v16 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v13) >> 4);
          if (2 * v16 > v15)
          {
            v15 = 2 * v16;
          }

          if (v16 >= 0x2AAAAAAAAAAAAAALL)
          {
            v17 = 0x555555555555555;
          }

          else
          {
            v17 = v15;
          }

          if (v17)
          {
            std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>>(v17);
          }

          v18 = 48 * v14;
          *(v18 + 16) = *v29;
          *v18 = v28;
          *(v18 + 24) = *&v29[8];
          *(v18 + 40) = v30;
          v20 = a4[3];
          v19 = a4[4];
          v21 = (v18 + v20 - v19);
          if (v20 != v19)
          {
            v22 = a4[3];
            v23 = (v18 + v20 - v19);
            do
            {
              v24 = *v22;
              *(v23 + 2) = *(v22 + 2);
              *v23 = v24;
              *(v22 + 1) = 0;
              *(v22 + 2) = 0;
              *v22 = 0;
              v25 = *(v22 + 24);
              *(v23 + 5) = *(v22 + 5);
              *(v23 + 24) = v25;
              *(v22 + 4) = 0;
              *(v22 + 5) = 0;
              *(v22 + 3) = 0;
              v22 += 48;
              v23 += 48;
            }

            while (v22 != v19);
            do
            {
              std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>::destroy[abi:nn200100]((a4 + 3), v20);
              v20 += 48;
            }

            while (v20 != v19);
            v20 = a4[3];
          }

          v12 = v18 + 48;
          a4[3] = v21;
          a4[4] = v18 + 48;
          a4[5] = 0;
          if (v20)
          {
            operator delete(v20);
          }
        }

        else
        {
          *v10 = v28;
          *(v10 + 16) = *v29;
          *(v10 + 24) = *&v29[8];
          *(v10 + 40) = v30;
          v12 = v10 + 48;
        }

        a4[4] = v12;
        llvm::StringRef::split(&v52, v53, *(&v53 + 1), &v28);
        v51 = v28;
        v52 = *v29;
      }

      while (v28 != v47);
    }

    return 0;
  }

  else
  {
    WORD4(v52) = 1283;
    v50 = "'";
    *(&v51 + 1) = v44;
    *&v52 = v45;
    *v36 = &v50;
    *&v36[16] = "' is an invalid FunctionIOAliases option!";
    *&v36[32] = 770;
    v27 = llvm::errs(v6);
    return llvm::cl::Option::error(a1, v36, 0, 0, v27);
  }
}

void std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](uint64_t a1)
{
  v2 = (a1 + 24);
  std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__destroy_vector::operator()[abi:nn200100](&v2);
  if (*(a1 + 23) < 0)
  {
    operator delete(*a1);
  }
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>>(unint64_t a1)
{
  if (a1 < 0x555555555555556)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::push_back[abi:nn200100](char **a1, __int128 *a2)
{
  v4 = a1[1];
  v3 = a1[2];
  if (v4 >= v3)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4);
    if (v6 + 1 > 0x555555555555555)
    {
      std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__throw_length_error[abi:nn200100]();
    }

    v7 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
    v8 = 2 * v7;
    if (2 * v7 <= v6 + 1)
    {
      v8 = v6 + 1;
    }

    if (v7 >= 0x2AAAAAAAAAAAAAALL)
    {
      v9 = 0x555555555555555;
    }

    else
    {
      v9 = v8;
    }

    if (v9)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>(v9);
    }

    v10 = (48 * v6);
    std::allocator_traits<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::construct[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&,0>(v10, a2);
    v5 = v10 + 2;
    v11 = *a1;
    v12 = a1[1];
    v13 = v10 + *a1 - v12;
    if (v12 != *a1)
    {
      v14 = *a1;
      v15 = v13;
      do
      {
        v16 = *v14;
        *(v15 + 2) = *(v14 + 2);
        *v15 = v16;
        *(v14 + 1) = 0;
        *(v14 + 2) = 0;
        *v14 = 0;
        *(v15 + 3) = 0;
        *(v15 + 4) = 0;
        *(v15 + 5) = 0;
        *(v15 + 24) = *(v14 + 24);
        *(v15 + 5) = *(v14 + 5);
        *(v14 + 3) = 0;
        *(v14 + 4) = 0;
        *(v14 + 5) = 0;
        v14 += 48;
        v15 += 48;
      }

      while (v14 != v12);
      do
      {
        std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](v11);
        v11 += 48;
      }

      while (v11 != v12);
      v11 = *a1;
    }

    *a1 = v13;
    a1[1] = v5;
    a1[2] = 0;
    if (v11)
    {
      operator delete(v11);
    }
  }

  else
  {
    std::allocator_traits<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::construct[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&,0>(a1[1], a2);
    v5 = v4 + 2;
  }

  a1[1] = v5;
}

std::string *std::allocator_traits<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::construct[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&,0>(std::string *this, __int128 *a2)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v4;
  }

  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  result = this + 1;
  this[1].__r_.__value_.__r.__words[2] = 0;
  v7 = *(a2 + 3);
  v6 = *(a2 + 4);
  if (v6 != v7)
  {
    std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__vallocate[abi:nn200100](result, 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4));
  }

  return result;
}

void std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__vallocate[abi:nn200100](uint64_t a1, unint64_t a2)
{
  if (a2 < 0x555555555555556)
  {
    std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>>(a2);
  }

  std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__throw_length_error[abi:nn200100]();
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>,mlir::ODIE::Compiler::Transforms::IOAlias*,mlir::ODIE::Compiler::Transforms::IOAlias*,mlir::ODIE::Compiler::Transforms::IOAlias*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      v7 = (a3 + v6);
      v8 = (a1 + v6);
      if (*(a1 + v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *v8, *(v8 + 1));
      }

      else
      {
        v9 = *v8;
        v7->__r_.__value_.__r.__words[2] = *(v8 + 2);
        *&v7->__r_.__value_.__l.__data_ = v9;
      }

      v10 = (a3 + v6);
      v11 = a1 + v6;
      if (*(a1 + v6 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v10 + 1, *(v11 + 24), *(v11 + 32));
      }

      else
      {
        v12 = *(v11 + 24);
        v10[1].__r_.__value_.__r.__words[2] = *(v11 + 40);
        *&v10[1].__r_.__value_.__l.__data_ = v12;
      }

      v6 += 48;
    }

    while (a1 + v6 != a2);
    a3 += v6;
  }

  return a3;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>(unint64_t a1)
{
  if (a1 < 0x555555555555556)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t std::__function::__value_func<void ()(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t llvm::function_ref<llvm::LogicalResult ()(llvm::StringRef)>::callback_fn<llvm::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases> &,mlir::detail::PassOptions::ListOption<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&)#1} &&)::{lambda(llvm::StringRef)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v7, 0, sizeof(v7));
  *__p = 0u;
  if (llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::parse(*(a1 + 8), a2, a3, __p))
  {
    v4 = 0;
  }

  else
  {
    std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::push_back[abi:nn200100]((**(a1 + 24) + 120), __p);
    v4 = 1;
  }

  v8 = v7 + 1;
  std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__destroy_vector::operator()[abi:nn200100](&v8);
  if (SBYTE7(v7[0]) < 0)
  {
    operator delete(__p[0]);
  }

  return v4;
}

llvm::raw_ostream *llvm::cl::parser<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::print(llvm::raw_ostream *a1, const char *a2)
{
  v2 = a2;
  v4 = *(a2 + 1);
  if (a2[23] >= 0)
  {
    v5 = *(a2 + 23);
  }

  else
  {
    a2 = *a2;
    v5 = v4;
  }

  result = llvm::raw_ostream::write(a1, a2, v5);
  v7 = *(result + 4);
  if (*(result + 3) == v7)
  {
    result = llvm::raw_ostream::write(result, ":", 1uLL);
  }

  else
  {
    *v7 = 58;
    ++*(result + 4);
  }

  v8 = *(v2 + 3);
  v9 = *(v2 + 4);
  if (v8 != v9)
  {
    v10 = 1;
    do
    {
      if (v10)
      {
        v11 = 0;
      }

      else
      {
        v11 = ";";
      }

      llvm::raw_ostream::operator<<(a1, v11, (v10 & 1) == 0);
      v12 = *(v8 + 23);
      if (v12 >= 0)
      {
        v13 = v8;
      }

      else
      {
        v13 = *v8;
      }

      if (v12 >= 0)
      {
        v14 = *(v8 + 23);
      }

      else
      {
        v14 = *(v8 + 8);
      }

      v15 = llvm::raw_ostream::write(a1, v13, v14);
      v16 = *(v15 + 4);
      if (*(v15 + 3) == v16)
      {
        v15 = llvm::raw_ostream::write(v15, "|", 1uLL);
      }

      else
      {
        *v16 = 124;
        ++*(v15 + 4);
      }

      v19 = *(v8 + 24);
      v18 = v8 + 24;
      v17 = v19;
      v20 = *(v18 + 23);
      if (v20 >= 0)
      {
        v21 = v18;
      }

      else
      {
        v21 = v17;
      }

      if (v20 >= 0)
      {
        v22 = *(v18 + 23);
      }

      else
      {
        v22 = *(v18 + 8);
      }

      result = llvm::raw_ostream::write(v15, v21, v22);
      v10 = 0;
      v8 = v18 + 24;
    }

    while (v8 != v9);
  }

  return result;
}

void std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__assign_with_size[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*>(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  v7 = *(a1 + 16);
  v8 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 4) < a4)
  {
    if (v8)
    {
      v9 = *(a1 + 8);
      v10 = *a1;
      if (v9 != v8)
      {
        do
        {
          v9 -= 48;
          std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](v9);
        }

        while (v9 != v8);
        v10 = *a1;
      }

      *(a1 + 8) = v8;
      operator delete(v10);
      v7 = 0;
      *a1 = 0;
      *(a1 + 8) = 0;
      *(a1 + 16) = 0;
    }

    if (a4 <= 0x555555555555555)
    {
      v11 = 0xAAAAAAAAAAAAAAABLL * (v7 >> 4);
      v12 = 2 * v11;
      if (2 * v11 <= a4)
      {
        v12 = a4;
      }

      if (v11 >= 0x2AAAAAAAAAAAAAALL)
      {
        v13 = 0x555555555555555;
      }

      else
      {
        v13 = v12;
      }

      if (v13 <= 0x555555555555555)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>(v13);
      }
    }

    std::vector<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::__throw_length_error[abi:nn200100]();
  }

  v14 = *(a1 + 8) - v8;
  if (0xAAAAAAAAAAAAAAABLL * (v14 >> 4) >= a4)
  {
    v18 = std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases*>(__str, a3, v8);
    for (i = *(a1 + 8); i != v18; std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>::destroy[abi:nn200100](i))
    {
      i -= 48;
    }

    *(a1 + 8) = v18;
  }

  else
  {
    v15 = (__str + v14);
    std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases*>(__str, (__str + v14), v8);
    v16 = *(a1 + 8);
    if (v15 != a3)
    {
      v17 = *(a1 + 8);
      do
      {
        std::allocator_traits<std::allocator<mlir::ODIE::Compiler::Transforms::FunctionIOAliases>>::construct[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const&,0>(v17, v15);
        v15 += 3;
        v17 += 2;
        v16 += 48;
      }

      while (v15 != a3);
    }

    *(a1 + 8) = v16;
  }
}

std::string *std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases const*,mlir::ODIE::Compiler::Transforms::FunctionIOAliases*>(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      if (this != v5)
      {
        v6 = this + 1;
        data = this[1].__r_.__value_.__l.__data_;
        v9 = v5[1].__r_.__value_.__l.__data_;
        size = v5[1].__r_.__value_.__l.__size_;
        v10 = size - v9;
        v11 = this[1].__r_.__value_.__r.__words[2];
        if (v11 - data < (size - v9))
        {
          if (data)
          {
            v12 = this[1].__r_.__value_.__l.__size_;
            v13 = this[1].__r_.__value_.__l.__data_;
            if (v12 != data)
            {
              do
              {
                v12 -= 48;
                std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>::destroy[abi:nn200100](&this[1], v12);
              }

              while (v12 != data);
              v13 = v6->__r_.__value_.__r.__words[0];
            }

            this[1].__r_.__value_.__l.__size_ = data;
            operator delete(v13);
            v11 = 0;
            v6->__r_.__value_.__r.__words[0] = 0;
            this[1].__r_.__value_.__l.__size_ = 0;
            this[1].__r_.__value_.__r.__words[2] = 0;
          }

          v14 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 4);
          if (v14 <= 0x555555555555555)
          {
            v15 = 0xAAAAAAAAAAAAAAABLL * (v11 >> 4);
            if (2 * v15 > v14)
            {
              v14 = 2 * v15;
            }

            if (v15 >= 0x2AAAAAAAAAAAAAALL)
            {
              v16 = 0x555555555555555;
            }

            else
            {
              v16 = v14;
            }

            std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__vallocate[abi:nn200100](&this[1], v16);
          }

          std::vector<mlir::ODIE::Compiler::Transforms::IOAlias>::__throw_length_error[abi:nn200100]();
        }

        v17 = this[1].__r_.__value_.__l.__size_ - data;
        if (v17 >= v10)
        {
          v18 = std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *>(v5[1].__r_.__value_.__l.__data_, v5[1].__r_.__value_.__l.__size_, this[1].__r_.__value_.__l.__data_);
          for (i = this[1].__r_.__value_.__l.__size_; i != v18; std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>::destroy[abi:nn200100](&this[1], i))
          {
            i -= 48;
          }

          this[1].__r_.__value_.__l.__size_ = v18;
        }

        else
        {
          std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *>(v5[1].__r_.__value_.__l.__data_, &v9[v17], this[1].__r_.__value_.__l.__data_);
          this[1].__r_.__value_.__l.__size_ = std::__uninitialized_allocator_copy_impl[abi:nn200100]<std::allocator<mlir::ODIE::Compiler::Transforms::IOAlias>,mlir::ODIE::Compiler::Transforms::IOAlias*,mlir::ODIE::Compiler::Transforms::IOAlias*,mlir::ODIE::Compiler::Transforms::IOAlias*>(&v9[v17], size, this[1].__r_.__value_.__l.__size_);
        }
      }

      v5 += 2;
      this += 2;
    }

    while (v5 != a2);
  }

  return this;
}

std::string *std::__copy_impl::operator()[abi:nn200100]<mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *,mlir::ODIE::Compiler::Transforms::IOAlias *>(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      std::string::operator=(this + 1, v5 + 1);
      this += 2;
      v5 += 2;
    }

    while (v5 != a2);
  }

  return this;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::updateFunctionSignature(uint64_t a1, uint64_t a2, unsigned int *a3, void *a4)
{
  v72 = *MEMORY[0x277D85DE8];
  v41 = a1 + 64;
  v6 = *(((a1 + 64 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 8);
  if (v6)
  {
    v7 = v6 - 8;
  }

  else
  {
    v7 = 0;
  }

  v8 = *(v7 + 32);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v9 = *(v8 + 72);
    v10 = *(v8 + 68);
  }

  else
  {
    v9 = 0;
    v10 = 0;
  }

  v46 = v48;
  v47 = 0x600000000;
  llvm::SmallVectorImpl<mlir::Type>::append<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void>(&v46, v9, 0, v9, v10);
  (*(*(a2 + 48) + 8))();
  v40 = a2;
  if (v11)
  {
    if (((8 * v11) & 0x8000000000000000) == 0)
    {
      operator new();
    }

    std::vector<mlir::Type>::__throw_length_error[abi:nn200100]();
  }

  v12 = a3[2];
  if (v12)
  {
    v13 = 16 * v12;
    v14 = (*a3 + 8);
    do
    {
      v44 = v13;
      v15 = *(8 * *(v14 - 1));
      v16 = a4[1];
      *&v50 = v15;
      v17 = mlir::detail::TypeUniquer::get<mlir::ODIE::Compiler::CoreML::HandleType,mlir::Type>(v16, &v50);
      v18 = *(v14 - 1);
      *(8 * v18) = v17;
      v19 = *(((v41 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 8);
      if (v19)
      {
        v20 = v19 - 8;
      }

      else
      {
        v20 = 0;
      }

      v21 = *(*(v20 + 48) + 8 * v18);
      *(v21 + 8) = *(v21 + 8) & 7 | v17;
      v22 = *(((v41 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 8);
      if (v22)
      {
        v23 = v22 - 8;
      }

      else
      {
        v23 = 0;
      }

      v24 = *(v23 + 40);
      a4[3] = v23;
      a4[4] = v24;
      v25 = *(*(((v41 + 16 * ((*(a1 + 44) >> 23) & 1) + ((*(a1 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a1 + 40) + 16) + 24);
      Token = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::CreateTokenOp>((a4 + 1), v25);
      *&v49 = v15;
      *(&v49 + 1) = *(Token - 1) & 0xFFFFFFFFFFFFFFF8;
      v45[0] = v21;
      v45[1] = Token - 16;
      Handle = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::ReadHandleOp>((a4 + 1), *(**v25 + 32));
      *&v50 = v25;
      *(&v50 + 1) = Handle;
      v51 = v53;
      v52 = 0x400000000;
      v54 = v56;
      v55 = 0x400000000;
      v57 = v59;
      v58 = 0x400000000;
      v60 = 4;
      v61 = &v63;
      v62 = 0x100000000;
      v64 = &v66;
      v65 = 0x100000000;
      v67 = 0;
      v68 = 0;
      v69 = &mlir::detail::TypeIDResolver<void,void>::id;
      v70 = 0;
      v71 = 0;
      mlir::ODIE::Compiler::CoreML::ReadHandleOp::build((a4 + 1), &v50, &v49 + 2, 2, v45, 2, 0, 0);
      v28 = mlir::Operation::create(&v50);
      mlir::OpBuilder::insert((a4 + 1), v28);
      v29 = *(*(v28 + 6) + 16);
      mlir::OperationState::~OperationState(&v50);
      if (v29 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReadHandleOp,void>::id)
      {
        v30 = v28;
      }

      else
      {
        v30 = 0;
      }

      *&v50 = v30;
      *&v49 = &v50;
      mlir::RewriterBase::replaceUsesWithIf(a4, v21, v30 - 2, llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::RewriterBase::replaceAllUsesExcept(mlir::Value,mlir::Value,mlir::Operation *)::{lambda(mlir::OpOperand &)#1}>, &v49, 0);
      a4[3] = *(v8 + 16);
      a4[4] = v8;
      v31 = *(*(v8 + 72) + 32 * *v14 + 24);
      v32 = *(v8 + 24);
      v33 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::WriteHandleOp>((a4 + 1), *(**v32 + 32));
      *&v50 = v32;
      *(&v50 + 1) = v33;
      v51 = v53;
      v52 = 0x400000000;
      v54 = v56;
      v55 = 0x400000000;
      v57 = v59;
      v58 = 0x400000000;
      v60 = 4;
      v61 = &v63;
      v62 = 0x100000000;
      v64 = &v66;
      v65 = 0x100000000;
      v67 = 0;
      v68 = 0;
      v69 = &mlir::detail::TypeIDResolver<void,void>::id;
      v70 = 0;
      v71 = 0;
      mlir::ODIE::Compiler::CoreML::WriteHandleOp::build(a4 + 1, &v50, v21, v31, (v30 - 32));
      v34 = mlir::Operation::create(&v50);
      mlir::OpBuilder::insert((a4 + 1), v34);
      v35 = *(*(v34 + 6) + 16);
      mlir::OperationState::~OperationState(&v50);
      if (v35 != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::WriteHandleOp,void>::id)
      {
        v34 = 0;
      }

      mlir::detail::OperandStorage::eraseOperands((v8 + 64), *v14, 1u);
      v36 = *v14;
      *&v50 = v34 - 16;
      if ((*(v8 + 46) & 0x80) != 0)
      {
        mlir::detail::OperandStorage::setOperands((v8 + 64), v8, v36, 0, &v50, 1);
        v36 = *v14;
      }

      *(v46 + v36) = *(v34 - 1) & 0xFFFFFFFFFFFFFFF8;
      v14 += 4;
      v13 = v44 - 16;
    }

    while (v44 != 16);
  }

  (*(*a4 + 40))(a4, a1);
  v37 = *(***(a1 + 24) + 32);
  v50 = 2uLL;
  *&v49 = v46 & 0xFFFFFFFFFFFFFFF9 | 2;
  *(&v49 + 1) = v47;
  v38 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v37, &v50, &v49);
  mlir::function_interface_impl::setFunctionType(a1, v40, v38);
  (*(*a4 + 48))(a4, a1);
  if (v46 != v48)
  {
    free(v46);
  }

  v39 = *MEMORY[0x277D85DE8];
}

void *llvm::SmallVector<mlir::ODIE::Compiler::Transforms::anonymous namespace::MutationAttrInfo,3u>::SmallVector(void *a1, uint64_t a2)
{
  v3 = a1 + 2;
  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  if (a1 != a2)
  {
    v5 = *(a2 + 8);
    if (v5)
    {
      if (v5 < 4)
      {
        v6 = *(a2 + 8);
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 2, v5, 16);
        v6 = *(a2 + 8);
        if (!v6)
        {
LABEL_8:
          *(a1 + 2) = v5;
          return a1;
        }

        v3 = *a1;
      }

      memcpy(v3, *a2, 16 * v6);
      goto LABEL_8;
    }
  }

  return a1;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_128UpdateSignatureToHandlesPass14runOnOperationEvE3__0NS1_19FunctionOpInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESP_E4typeES3_OT1_EUlS3_E_EEvlS3_(void **a1, uint64_t a2)
{
  v69 = *MEMORY[0x277D85DE8];
  v3 = llvm::DefaultDoCastIfPossible<mlir::FunctionOpInterface,mlir::Operation *,llvm::CastInfo<mlir::FunctionOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (!v3)
  {
    goto LABEL_75;
  }

  v5 = v3;
  v6 = v4;
  v7 = *a1;
  v8 = **a1;
  v48[0] = v3;
  v48[1] = v4;
  AttrDictionary = mlir::Operation::getAttrDictionary(v3);
  p_AttrDictionary = &AttrDictionary;
  v46 = *v48;
  if (v68 != 1)
  {
    LOBYTE(v51[0]) = 0;
    v53 = 0;
    goto LABEL_67;
  }

  if ((v62 & 1) == 0)
  {
    LOBYTE(v51[0]) = 0;
    v53 = 0;
    goto LABEL_57;
  }

  v12 = v8[57];
  v11 = v8[58];
  if (v12 != v11)
  {
    while (1)
    {
      v13 = *(v12 + 23);
      v14 = v13 >= 0 ? v12 : *v12;
      v15 = v13 >= 0 ? *(v12 + 23) : *(v12 + 8);
      v16 = (**(v48[1] + 5))();
      if (*(v16 + 24) == v15 && (!v15 || !memcmp(*(v16 + 16), v14, v15)))
      {
        break;
      }

      v12 += 48;
      if (v12 == v11)
      {
        v12 = v11;
        break;
      }
    }

    v11 = v8[58];
  }

  if (v12 != v11)
  {
    v54 = v56;
    v55 = 0x300000000;
    v17 = *(v12 + 24);
    v18 = *(v12 + 32);
    if (v17 == v18)
    {
      v51[0] = v52;
      v51[1] = 0x300000000;
    }

    else
    {
      do
      {
        v19 = *(v17 + 23);
        v20 = *v17;
        if (v19 >= 0)
        {
          v20 = v17;
        }

        if (v19 < 0)
        {
          v19 = *(v17 + 8);
        }

        v51[0] = v20;
        v51[1] = v19;
        v21 = llvm::MapVector<llvm::StringRef,unsigned long,llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::SmallVector<std::pair<llvm::StringRef,unsigned long>,4u>>::find(v57, v51, v9, v10);
        if (v21 == v59 + 24 * v60)
        {
          v44 = 257;
          mlir::Operation::emitError(v51, v48[0], v43);
          if (v51[0])
          {
            mlir::Diagnostic::operator<<<23ul>(&v51[1], "Invalid pass option: '");
            if (v51[0])
            {
              v50 = 260;
              v49[0] = v17;
              mlir::Diagnostic::operator<<(&v51[1], v49);
              if (v51[0])
              {
                mlir::Diagnostic::operator<<<27ul>(&v51[1], "' does not name an input.\n");
              }
            }
          }

          goto LABEL_54;
        }

        v24 = v21;
        v25 = *(v17 + 24);
        v26 = *(v17 + 47);
        if (v26 >= 0)
        {
          v25 = (v17 + 24);
        }

        v27 = *(v17 + 32);
        if (v26 >= 0)
        {
          v27 = *(v17 + 47);
        }

        v51[0] = v25;
        v51[1] = v27;
        v28 = llvm::MapVector<llvm::StringRef,unsigned long,llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::SmallVector<std::pair<llvm::StringRef,unsigned long>,4u>>::find(v63, v51, v22, v23);
        if (v28 == (v65 + 24 * v66))
        {
          v44 = 257;
          mlir::Operation::emitError(v51, v48[0], v43);
          if (v51[0])
          {
            mlir::Diagnostic::operator<<<23ul>(&v51[1], "Invalid pass option: '");
            if (v51[0])
            {
              v50 = 260;
              v49[0] = v17 + 24;
              mlir::Diagnostic::operator<<(&v51[1], v49);
              if (v51[0])
              {
                mlir::Diagnostic::operator<<<28ul>(&v51[1], "' does not name an output.\n");
              }
            }
          }

LABEL_54:
          mlir::InFlightDiagnostic::~InFlightDiagnostic(v51);
          v36 = 0;
          LOBYTE(v51[0]) = 0;
          goto LABEL_55;
        }

        v17 += 48;
      }

      while (v17 != v18);
      v51[0] = v52;
      v51[1] = 0x300000000;
      if (v55)
      {
      }
    }

    v36 = 1;
LABEL_55:
    v53 = v36;
    v37 = v54;
    if (v54 == v56)
    {
      goto LABEL_57;
    }

LABEL_56:
    free(v37);
    goto LABEL_57;
  }

  v54 = v56;
  v55 = 0x300000000;
  (*(*(v48[1] + 6) + 8))();
  if (!v29)
  {
LABEL_41:
    v51[0] = v52;
    v51[1] = 0x300000000;
    if (v55)
    {
    }

    v53 = 1;
    goto LABEL_89;
  }

  v30 = 0;
  while (1)
  {
    ArgAttr = mlir::FunctionOpInterface::getArgAttr(v48, v30, "MutableBuffers.buffer_mutation", 0x1EuLL);
    v43[0] = ArgAttr;
    if (!ArgAttr)
    {
      goto LABEL_40;
    }

    if (*(*ArgAttr + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    {
      break;
    }

    *v51 = ArgAttr[1];
    v34 = llvm::MapVector<llvm::StringRef,unsigned long,llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::SmallVector<std::pair<llvm::StringRef,unsigned long>,4u>>::find(v63, v51, v32, v33);
    if (v34 == (v65 + 24 * v66))
    {
      v50 = 257;
      mlir::Operation::emitError(v51, v48[0], v49);
      if (v51[0])
      {
        mlir::Diagnostic::operator<<<19ul>(&v51[1], "Invalid attr for '");
      }

      v41 = mlir::InFlightDiagnostic::append<llvm::StringRef const&>(v51, &mlir::ODIE::Compiler::TorchImport::TorchImportDialect::kBufferMutationArgAttrId);
      if (*v41)
      {
        v42 = v41;
        mlir::Diagnostic::operator<<<4ul>((v41 + 1), "': ");
        if (*v42)
        {
          mlir::Diagnostic::operator<<<mlir::Attribute &>((v42 + 1), v43);
          if (*v42)
          {
            mlir::Diagnostic::operator<<<31ul>((v42 + 1), "; expected to name an output.\n");
          }
        }
      }

      goto LABEL_88;
    }

LABEL_40:
    ++v30;
    (*(*(v48[1] + 6) + 8))(*(v48[1] + 6));
    if (v30 >= v35)
    {
      goto LABEL_41;
    }
  }

  v50 = 257;
  mlir::Operation::emitError(v51, v48[0], v49);
  if (v51[0])
  {
    mlir::Diagnostic::operator<<<19ul>(&v51[1], "Invalid attr for '");
  }

  v39 = mlir::InFlightDiagnostic::append<llvm::StringRef const&>(v51, &mlir::ODIE::Compiler::TorchImport::TorchImportDialect::kBufferMutationArgAttrId);
  if (*v39)
  {
    v40 = v39;
    mlir::Diagnostic::operator<<<4ul>((v39 + 1), "': ");
    if (*v40)
    {
      mlir::Diagnostic::operator<<<mlir::Attribute &>((v40 + 1), v43);
      if (*v40)
      {
        mlir::Diagnostic::operator<<<24ul>((v40 + 1), "; expected StringAttr.\n");
      }
    }
  }

LABEL_88:
  mlir::InFlightDiagnostic::~InFlightDiagnostic(v51);
  LOBYTE(v51[0]) = 0;
  v53 = 0;
LABEL_89:
  v37 = v54;
  if (v54 != v56)
  {
    goto LABEL_56;
  }

LABEL_57:
  if (v62 == 1)
  {
    if (v59 != &v61)
    {
      free(v59);
    }

    if ((v57[0] & 1) == 0)
    {
      MEMORY[0x25F891030](v57[1], 8);
    }
  }

  if (v68)
  {
    if (v65 != &v67)
    {
      free(v65);
    }

    if ((v63[0] & 1) == 0)
    {
      MEMORY[0x25F891030](v63[1], 8);
    }
  }

LABEL_67:
  if (v53)
  {
    if (LODWORD(v51[1]))
    {
      if (v63[0] != &v64)
      {
        free(v63[0]);
      }
    }
  }

  else
  {
    v57[0] = "Invalid imported mutable buffer attributes.\n";
    v58 = 259;
    mlir::Operation::emitError(v63, v5, v57);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v63);
    v8[5] |= 4uLL;
  }

  if (v53 == 1 && v51[0] != v52)
  {
    free(v51[0]);
  }

LABEL_75:
  v38 = *MEMORY[0x277D85DE8];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass::getMutationInfoForFunc(mlir::FunctionOpInterface)const::$_1::operator()(uint64_t a1, void *a2, const void *a3, size_t a4)
{
  v67[12] = *MEMORY[0x277D85DE8];
  v60 = 1;
  v61 = xmmword_25D0A05E0;
  *&v62[8] = xmmword_25D0A05E0;
  v63 = xmmword_25D0A05E0;
  v64 = xmmword_25D0A05E0;
  __src = v67;
  v66 = 0x400000000;
  v8 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(**a2 + 8), *(**a2 + 8) + 16 * *(**a2 + 16), a3, a4);
  if (v10)
  {
    v11 = *(v8 + 8);
    if (v11)
    {
      v12 = *(*v11 + 136);
      v13 = v12 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id ? *(v8 + 8) : 0;
      if (v12 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id && v11[2])
      {
        v34 = 0;
        while (1)
        {
          v35 = *(v11[1] + 8 * v34);
          if (!v35 || *(*v35 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
          {
            v46 = a2[1];
            v51 = 257;
            mlir::Operation::emitError(&v56, v46, v50);
            if (v56)
            {
              mlir::Diagnostic::operator<<<19ul>(&v56 + 8, "Invalid attr for '");
              if (v56)
              {
                v54 = 261;
                *&v52 = a3;
                *(&v52 + 1) = a4;
                mlir::Diagnostic::operator<<(&v56 + 8, &v52);
                if (v56)
                {
                  mlir::Diagnostic::operator<<<4ul>(&v56 + 8, "': ");
                  if (v56)
                  {
                    LODWORD(v52) = 0;
                    *(&v52 + 1) = v13;
                    v47 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v58, &v52, 1);
                    v48 = v58 + 24 * v59;
                    v49 = *v47;
                    *(v48 + 16) = *(v47 + 16);
                    *v48 = v49;
                    ++v59;
                    if (v56)
                    {
                      mlir::Diagnostic::operator<<<33ul>(&v56 + 8, "; expected array of StringAttr.\n");
                    }
                  }
                }
              }
            }

            mlir::InFlightDiagnostic::~InFlightDiagnostic(&v56);
            v30 = 0;
            *a1 = 0;
            goto LABEL_56;
          }

          v52 = v35[1];
          v53 = v34;
          v56 = v52;
          v57 = 0;
          v55[0] = 0;
          if (!llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(&v60, &v56, v55, v9))
          {
            break;
          }

LABEL_47:
          if (++v34 >= v11[2])
          {
            goto LABEL_7;
          }
        }

        v37 = v55[0];
        v50[0] = v55[0];
        v38 = v60;
        v39 = v60 >> 1;
        v40 = v60 & 1;
        if (v60)
        {
          v41 = 4;
        }

        else
        {
          v41 = DWORD2(v61);
        }

        if (4 * v39 + 4 >= 3 * v41)
        {
          v41 *= 2;
        }

        else if (v41 + ~v39 - HIDWORD(v60) > v41 >> 3)
        {
LABEL_43:
          LODWORD(v60) = (v38 & 0xFFFFFFFE) + v40 + 2;
          if (*v37 != -1)
          {
            --HIDWORD(v60);
          }

          *v37 = v52;
          *(v37 + 16) = 0;
          v42 = v66;
          *(v37 + 16) = v66;
          if (v42 >= HIDWORD(v66))
          {
            llvm::SmallVectorTemplateBase<std::pair<llvm::StringRef,unsigned long>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::StringRef&&>,std::tuple<unsigned long &&>>(&__src, &v52, v34);
          }

          else
          {
            v43 = __src + 24 * v42;
            *v43 = v52;
            *(v43 + 2) = v34;
            LODWORD(v66) = v66 + 1;
          }

          goto LABEL_47;
        }

        llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::grow(&v60, v41, v36, v9);
        llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(&v60, &v56, v50, v44);
        v38 = v60;
        v37 = v50[0];
        v40 = v60 & 1;
        goto LABEL_43;
      }
    }
  }

LABEL_7:
  v14 = (a1 + 8);
  *(a1 + 8) = xmmword_25D0A05E0;
  *(a1 + 32) = xmmword_25D0A05E0;
  *(a1 + 56) = xmmword_25D0A05E0;
  *(a1 + 80) = xmmword_25D0A05E0;
  v15 = HIDWORD(v60);
  v16 = v60 & 1;
  *a1 = v60 | 1;
  *(a1 + 4) = v15;
  v60 = v16;
  if (v16)
  {
    v18 = v62;
    v19 = (a1 + 24);
    v20 = 4;
    while (1)
    {
      v21 = (v19 - 4);
      v22 = *(v19 - 2);
      v23 = (v18 - 4);
      v24 = *(v18 - 2);
      if (v24 == -1)
      {
        v27 = *v21;
        *v21 = *v23;
        *v23 = v27;
        if (v22 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          goto LABEL_24;
        }
      }

      else
      {
        if (v22 > 0xFFFFFFFFFFFFFFFDLL || v24 == -2)
        {
          v26 = *v21;
          *v21 = *v23;
          *v23 = v26;
          if (v22 > 0xFFFFFFFFFFFFFFFDLL)
          {
            if (v24 != -2)
            {
              *v19 = *v18;
            }

            goto LABEL_25;
          }

LABEL_24:
          *v18 = *v19;
          goto LABEL_25;
        }

        v28 = *v21;
        v29 = *v19;
        *v21 = *v23;
        *v19 = *v18;
        *v23 = v28;
        *v18 = v29;
      }

LABEL_25:
      v18 += 6;
      v19 += 6;
      if (!--v20)
      {
        goto LABEL_26;
      }
    }
  }

  v17 = 0;
  v56 = v61;
  LODWORD(v60) = 1;
  do
  {
    *&v62[v17 - 16] = *(v14 + v17);
    if (*&v62[v17 - 16] <= 0xFFFFFFFFFFFFFFFDLL)
    {
      *&v62[v17] = *(v14 + v17 + 16);
    }

    v17 += 24;
  }

  while (v17 != 96);
  *a1 &= ~1u;
  *v14 = v56;
LABEL_26:
  *(a1 + 104) = a1 + 120;
  *(a1 + 112) = 0x400000000;
  v30 = 1;
  if (&v60 != a1)
  {
    v31 = v66;
    if (v66)
    {
      if (__src != v67)
      {
        *(a1 + 104) = __src;
        v32 = HIDWORD(v66);
        *(a1 + 112) = v31;
        *(a1 + 116) = v32;
        __src = v67;
        HIDWORD(v66) = 0;
LABEL_55:
        LODWORD(v66) = 0;
        v30 = 1;
        goto LABEL_56;
      }

      if (v66 < 5)
      {
        v33 = v66;
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 104, (a1 + 120), v66, 24);
        v33 = v66;
        if (!v66)
        {
          goto LABEL_54;
        }
      }

      memcpy(*(a1 + 104), __src, 24 * v33);
LABEL_54:
      *(a1 + 112) = v31;
      goto LABEL_55;
    }
  }

LABEL_56:
  *(a1 + 216) = v30;
  if (__src != v67)
  {
    free(__src);
  }

  if ((v60 & 1) == 0)
  {
    MEMORY[0x25F891030](v61, 8);
  }

  v45 = *MEMORY[0x277D85DE8];
}

uint64_t llvm::MapVector<llvm::StringRef,unsigned long,llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::SmallVector<std::pair<llvm::StringRef,unsigned long>,4u>>::find(int *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  v7 = a1 + 2;
  v6 = *a1;
  if (*a1)
  {
    v8 = 4;
  }

  else
  {
    v8 = a1[4];
    if (!v8)
    {
LABEL_19:
      if (v6)
      {
        v11 = (a1 + 26);
      }

      else
      {
        v11 = *(a1 + 1) + 24 * a1[4];
      }

      goto LABEL_7;
    }

    v7 = *(a1 + 1);
  }

  v9 = v8 - 1;
  v10 = (v8 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(*a2, *a2 + *(a2 + 8), a3, a4);
  v11 = &v7[6 * v10];
  if (!llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a2, *(a2 + 8), *v11, *(v11 + 8)))
  {
    v15 = 1;
    while (*v11 != -1)
    {
      v16 = v15 + 1;
      v10 = (v10 + v15) & v9;
      v11 = &v7[6 * v10];
      isEqual = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a2, *(a2 + 8), *v11, *(v11 + 8));
      v15 = v16;
      if (isEqual)
      {
        goto LABEL_6;
      }
    }

    v6 = *a1;
    goto LABEL_19;
  }

LABEL_6:
  v6 = *a1;
LABEL_7:
  if (v6)
  {
    v12 = (a1 + 26);
  }

  else
  {
    v12 = *(a1 + 1) + 24 * a1[4];
  }

  if (v12 == v11)
  {
    v13 = (a1 + 28);
  }

  else
  {
    v13 = (v11 + 16);
  }

  return *(a1 + 13) + 24 * *v13;
}

void llvm::SmallVectorTemplateBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::MutationAttrInfo,true>::push_back(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 8);
  if (v6 >= *(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v6 + 1, 16);
    LODWORD(v6) = *(a1 + 8);
  }

  v7 = (*a1 + 16 * v6);
  *v7 = a2;
  v7[1] = a3;
  ++*(a1 + 8);
}

uint64_t llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  v6 = a1 + 8;
  if (*a1)
  {
    v7 = 4;
  }

  else
  {
    v7 = *(a1 + 16);
    if (!v7)
    {
      v10 = 0;
      result = 0;
      goto LABEL_7;
    }

    v6 = *(a1 + 8);
  }

  v8 = v7 - 1;
  v9 = (v7 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(*a2, *a2 + *(a2 + 8), a3, a4);
  v10 = v6 + 24 * v9;
  if (llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a2, *(a2 + 8), *v10, *(v10 + 8)))
  {
    result = 1;
  }

  else
  {
    v12 = 0;
    v13 = 1;
    while (*v10 != -1)
    {
      if (v12)
      {
        v14 = 0;
      }

      else
      {
        v14 = *v10 == -2;
      }

      if (v14)
      {
        v12 = v10;
      }

      v18 = v12;
      v15 = v13 + 1;
      v9 = (v9 + v13) & v8;
      v10 = v6 + 24 * v9;
      isEqual = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a2, *(a2 + 8), *v10, *(v10 + 8));
      v12 = v18;
      v17 = isEqual;
      result = 1;
      v13 = v15;
      if (v17)
      {
        goto LABEL_7;
      }
    }

    result = 0;
    if (v12)
    {
      v10 = v12;
    }
  }

LABEL_7:
  *a3 = v10;
  return result;
}

uint64_t llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::grow(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t *a4)
{
  v18 = *MEMORY[0x277D85DE8];
  if (a2 >= 5)
  {
    v5 = (a2 - 1) | ((a2 - 1) >> 1);
    v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
    v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
    if ((v7 + 1) > 0x40)
    {
      a2 = v7 + 1;
    }

    else
    {
      a2 = 64;
    }
  }

  if ((*a1 & 1) == 0)
  {
    v8 = *(a1 + 8);
    v9 = *(a1 + 16);
    if (a2 > 4)
    {
      v15 = a2;
      *(a1 + 8) = llvm::allocate_buffer((24 * a2), 8uLL);
      *(a1 + 16) = v15;
    }

    else
    {
      *a1 |= 1u;
    }

    llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::moveFromOldBuckets(a1, v8, v8 + 24 * v9, a4);
    v16 = *MEMORY[0x277D85DE8];

    JUMPOUT(0x25F891030);
  }

  v10 = 0;
  v11 = v17;
  do
  {
    if (*(a1 + v10 + 8) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      *v11 = *(a1 + v10 + 8);
      *(v11 + 4) = *(a1 + v10 + 24);
      v11 += 24;
    }

    v10 += 24;
  }

  while (v10 != 96);
  if (a2 > 4)
  {
    *a1 &= ~1u;
    v12 = a2;
    *(a1 + 8) = llvm::allocate_buffer((24 * a2), 8uLL);
    *(a1 + 16) = v12;
  }

  result = llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::moveFromOldBuckets(a1, v17, v11, a4);
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::moveFromOldBuckets(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  v6 = result;
  v7 = *result;
  *result = *result & 1;
  if (v7)
  {
    v9 = (result + 8);
    v10 = (result + 104);
  }

  else
  {
    v8 = *(result + 16);
    if (!v8)
    {
      goto LABEL_10;
    }

    v9 = *(result + 8);
    v10 = (v9 + 24 * v8);
  }

  do
  {
    *v9 = xmmword_25D0A05E0;
    v9 = (v9 + 24);
  }

  while (v9 != v10);
LABEL_10:
  while (a2 != a3)
  {
    if (*a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v12 = 0;
      result = llvm::DenseMapBase<llvm::SmallDenseMap<llvm::StringRef,unsigned int,4u,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(v6, a2, &v12, a4);
      v11 = v12;
      *v12 = *a2;
      *(v11 + 4) = *(a2 + 16);
      *v6 += 2;
    }

    a2 += 24;
  }

  return result;
}

__n128 llvm::SmallVectorTemplateBase<std::pair<llvm::StringRef,unsigned long>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::StringRef&&>,std::tuple<unsigned long &&>>(uint64_t a1, __int128 *a2, uint64_t a3)
{
  v10 = *a2;
  v11 = a3;
  v4 = *(a1 + 8);
  v5 = *a1;
  v6 = &v10;
  if (v4 >= *(a1 + 12))
  {
    if (v5 <= &v10 && v5 + 24 * v4 > &v10)
    {
      v9 = &v10 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v9[*a1];
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v10;
    }
  }

  v7 = (v5 + 24 * *(a1 + 8));
  result = *v6;
  v7[1].n128_u64[0] = v6[1].n128_u64[0];
  *v7 = result;
  ++*(a1 + 8);
  return result;
}

uint64_t llvm::SmallVectorImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MutationAttrInfo>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v5 = (a2 + 16);
    v4 = *a2;
    if (v4 != v5)
    {
      v6 = *a1;
      if (*a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }

      *a1 = v4;
      v7 = (a2 + 8);
      *(a1 + 8) = *(a2 + 8);
      *a2 = v5;
      *(a2 + 12) = 0;
      goto LABEL_17;
    }

    v7 = (a2 + 8);
    v8 = *(a2 + 8);
    v9 = *(a1 + 8);
    if (v9 >= v8)
    {
      if (v8)
      {
        memmove(*a1, v4, 16 * v8);
      }

      goto LABEL_16;
    }

    if (*(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*a1, v4, 16 * v9);
        goto LABEL_14;
      }
    }

    else
    {
      *(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v8, 16);
    }

    v9 = 0;
LABEL_14:
    v10 = *v7 - v9;
    if (v10)
    {
      memcpy((*a1 + 16 * v9), (*a2 + 16 * v9), 16 * v10);
    }

LABEL_16:
    *(a1 + 8) = v8;
LABEL_17:
    *v7 = 0;
  }

  return a1;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_128UpdateSignatureToHandlesPass14runOnOperationEvE3__1NSC_6CoreML8InvokeOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, uint64_t a2)
{
  v77[5] = *MEMORY[0x277D85DE8];
  if (!a2 || *(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::InvokeOp,void>::id)
  {
    goto LABEL_51;
  }

  v61 = *a1;
  v62 = a2;
  LODWORD(v74) = 0;
  v73 = 0u;
  v75 = v77;
  v76 = 0;
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v3 = *(a2 + 68);
    if (v3)
    {
      v4 = 0;
      v5 = *(a2 + 72) + 24;
      while (1)
      {
        v6 = *v5;
        if ((~*(*v5 + 8) & 7) == 0)
        {
          v6 = 0;
        }

        if (!v6)
        {
          goto LABEL_15;
        }

        v7 = *(v6 + 8) & 7;
        if (v7 != 6)
        {
          break;
        }

        v8 = v6 + 24 * *(v6 + 16) + 120;
        if (v8)
        {
          goto LABEL_13;
        }

LABEL_15:
        ++v4;
        v5 += 32;
        if (v3 == v4)
        {
          goto LABEL_16;
        }
      }

      v8 = v6 + 16 * v7 + 16;
LABEL_13:
      if (*(*(v8 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReadHandleOp,void>::id)
      {
        v69[0] = *(*(v8 + 72) + 24);
        *llvm::MapVector<mlir::Value,unsigned long,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,unsigned long>,0u>>::operator[](&v73, v69) = v4;
      }

      goto LABEL_15;
    }
  }

LABEL_16:
  LODWORD(v70[0]) = 0;
  *v69 = 0u;
  v70[1] = v71 + 8;
  *&v71[0] = 0;
  v9 = *(a2 + 36);
  if (v9)
  {
    v10 = (a2 - 16);
  }

  else
  {
    v10 = 0;
  }

  if (v9)
  {
    v11 = 0;
    v12 = (a2 - 16);
    do
    {
      v13 = v10;
      if (!v11)
      {
        goto LABEL_26;
      }

      v14 = *(a2 - 8) & 7;
      v15 = a2 - 16;
      v16 = v11;
      if (v14 != 6)
      {
        v17 = (5 - v14);
        v13 = v12;
        v16 = v11 - v17;
        if (v11 <= v17)
        {
          goto LABEL_26;
        }

        v15 = a2 - 16 - 16 * v17;
      }

      v13 = (v15 - 24 * v16);
LABEL_26:
      v18 = *v13;
      if (*v13)
      {
        if (!*v18)
        {
          v19 = v18[2];
          if (v19)
          {
            if (*(*(v19 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::WriteHandleOp,void>::id)
            {
              v63[0] = *(*(v19 + 72) + 24);
              *llvm::MapVector<mlir::Value,unsigned long,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,unsigned long>,0u>>::operator[](v69, v63) = v11;
            }
          }
        }
      }

      ++v11;
      v12 -= 2;
    }

    while (v9 != v11);
  }

  v66 = v68;
  v67 = 0x300000000;
  if (v76)
  {
    v20 = v75;
    v21 = 16 * v76;
    do
    {
      v22 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::doFind<mlir::Value>(v69, v20);
      v23 = v22 == v69[0] + 16 * LODWORD(v70[0]) || v22 == 0;
      v24 = (v22 + 8);
      if (v23)
      {
        v24 = v71;
      }

      v25 = *v24;
      if (v25 != LODWORD(v71[0]))
      {
      }

      v20 += 2;
      v21 -= 16;
    }

    while (v21);
  }

  if (v70[1] != v71 + 8)
  {
    free(v70[1]);
  }

  MEMORY[0x25F891030](v69[0], 8);
  if (v75 != v77)
  {
    free(v75);
  }

  MEMORY[0x25F891030](v73, 8);
  v26 = mlir::detail::CallOpInterfaceTrait<mlir::ODIE::Compiler::CoreML::InvokeOp>::resolveCallableInTable(&v62, *v61);
  if (v26)
  {
    v27 = v26;
    if (*(*(v26 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GraphOp,void>::id)
    {
      v29 = v61[1];
      v30 = *v29;
      v31 = *(v29 + 16);
      v32 = llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::doFind<mlir::ODIE::Compiler::CoreML::GraphOp>(*v29, *(v29 + 16), v26);
      v33 = v32 == v30 + 16 * v31 || v32 == 0;
      v34 = (v32 + 8);
      v35 = *(v29 + 32);
      if (v33)
      {
        v34 = (v29 + 32);
      }

      v36 = *v34;
      if (v36 != v35)
      {
        v41 = *(v29 + 24);
        v42 = (v41 + 80 * v36);
        v43 = llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::doFind<mlir::ODIE::Compiler::CoreML::GraphOp>(v30, v31, *v42);
        if (v43)
        {
          *v43 = -8192;
          *(v29 + 8) = vadd_s32(*(v29 + 8), 0x1FFFFFFFFLL);
          v41 = *(v29 + 24);
          v35 = *(v29 + 32);
        }

        v44 = v42 + 10;
        v45 = (v41 + 80 * v35);
        if (v42 + 10 != v45)
        {
          do
          {
            *(v44 - 10) = *v44;
            *(v44 - 1) = v44[9];
            v44 += 10;
          }

          while (v44 != v45);
          v35 = *(v29 + 32);
          v41 = *(v29 + 24);
        }

        v46 = v35 - 1;
        *(v29 + 32) = v35 - 1;
        v47 = v41 + 80 * (v35 - 1);
        v48 = *(v47 + 8);
        if (v48 != (v47 + 24))
        {
          free(v48);
          v41 = *(v29 + 24);
          v46 = *(v29 + 32);
        }

        if ((v41 + 80 * v46) != v42 && *(v29 + 8))
        {
          v49 = *(v29 + 16);
          if (v49)
          {
            v50 = 16 * v49;
            v51 = *v29;
            while ((*v51 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              v51 += 16;
              v50 -= 16;
              if (!v50)
              {
                goto LABEL_49;
              }
            }
          }

          else
          {
            v51 = *v29;
          }

          v58 = *v29 + 16 * v49;
          if (v51 != v58)
          {
LABEL_89:
            v59 = *(v51 + 8);
            if (0xCCCCCCCCCCCCCCCDLL * ((v42 - v41) >> 4) < v59)
            {
              *(v51 + 8) = v59 - 1;
            }

            while (1)
            {
              v51 += 16;
              if (v51 == v58)
              {
                break;
              }

              if ((*v51 | 0x1000) != 0xFFFFFFFFFFFFF000)
              {
                if (v51 != v58)
                {
                  goto LABEL_89;
                }

                goto LABEL_49;
              }
            }
          }
        }

        goto LABEL_49;
      }

      if (v67)
      {
        v65 = v62;
        v37 = v61[1];
        v69[0] = 0;
        v38 = llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::CoreML::GraphOp>(*v37, *(v37 + 16), v27, v69);
        v39 = v69[0];
        if (v38)
        {
          v40 = *(v69[0] + 2);
LABEL_85:
          v57 = *(v37 + 24) + 80 * v40;
          *(v57 + 72) = v65;
          if (v63[0] != &v64)
          {
            free(v63[0]);
          }

          goto LABEL_49;
        }

        *&v73 = v69[0];
        v52 = *(v37 + 8);
        v53 = *(v37 + 16);
        if (4 * v52 + 4 >= 3 * v53)
        {
          v53 *= 2;
        }

        else if (v53 + ~v52 - *(v37 + 12) > v53 >> 3)
        {
LABEL_77:
          *(v37 + 8) = v52 + 1;
          if (*v39 != -4096)
          {
            --*(v37 + 12);
          }

          *v39 = v27;
          v39[2] = 0;
          memset(v71, 0, sizeof(v71));
          *v70 = 0u;
          v77[4] = 0;
          v54 = *(v37 + 24);
          v69[0] = v70;
          v69[1] = 0x300000000;
          v72 = 0;
          v55 = &v73;
          *&v73 = v27;
          *(&v73 + 1) = &v75;
          v74 = 0x300000000;
          v56 = *(v37 + 32);
          if (v56 >= *(v37 + 36))
          {
            if (v54 <= &v73 && v54 + 80 * v56 > &v73)
            {
              v60 = &v73 - v54;
              v54 = *(v37 + 24);
              v55 = &v60[v54];
            }

            else
            {
              v54 = *(v37 + 24);
              v55 = &v73;
            }
          }

          ++*(v37 + 32);
          if (*(&v73 + 1) != &v75)
          {
            free(*(&v73 + 1));
          }

          if (v69[0] != v70)
          {
            free(v69[0]);
          }

          v40 = *(v37 + 32) - 1;
          v39[2] = v40;
          goto LABEL_85;
        }

        llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::grow(v37, v53);
        llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::CoreML::GraphOp>(*v37, *(v37 + 16), v27, &v73);
        v52 = *(v37 + 8);
        v39 = v73;
        goto LABEL_77;
      }
    }
  }

LABEL_49:
  if (v66 != v68)
  {
    free(v66);
  }

LABEL_51:
  v28 = *MEMORY[0x277D85DE8];
}

uint64_t llvm::MapVector<mlir::Value,unsigned long,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,unsigned long>,0u>>::operator[](uint64_t a1, uint64_t *a2)
{
  v12 = *a2;
  v13 = 0;
  llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::try_emplace<unsigned int const&>(a1, &v12, &v13, &v10);
  v4 = v10;
  if (v11)
  {
    v5 = *a2;
    v6 = *(a1 + 32);
    if (v6 >= *(a1 + 36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (a1 + 40), v6 + 1, 16);
      LODWORD(v6) = *(a1 + 32);
    }

    v7 = (*(a1 + 24) + 16 * v6);
    *v7 = v5;
    v7[1] = 0;
    v8 = *(a1 + 32);
    *(a1 + 32) = v8 + 1;
    *(v4 + 8) = v8;
  }

  else
  {
    v8 = *(v10 + 8);
  }

  return *(a1 + 24) + 16 * v8 + 8;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::doFind<mlir::ODIE::Compiler::CoreML::GraphOp>(uint64_t a1, int a2, unint64_t a3)
{
  if (a2)
  {
    v3 = 0x9DDFEA08EB382D69 * ((8 * a3 - 0xAE502812AA7333) ^ HIDWORD(a3));
    v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v3 >> 47) ^ v3);
    v5 = (-348639895 * ((v4 >> 47) ^ v4)) & (a2 - 1);
    v6 = *(a1 + 16 * v5);
    if (v6 == a3)
    {
      return a1 + 16 * v5;
    }

    v8 = 1;
    while (v6 != -4096)
    {
      v9 = v5 + v8++;
      v5 = v9 & (a2 - 1);
      v6 = *(a1 + 16 * v5);
      if (v6 == a3)
      {
        return a1 + 16 * v5;
      }
    }
  }

  return 0;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::CoreML::GraphOp>(uint64_t a1, int a2, unint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = 0x9DDFEA08EB382D69 * ((8 * a3 - 0xAE502812AA7333) ^ HIDWORD(a3));
    v5 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v4 >> 47) ^ v4);
    v6 = a2 - 1;
    v7 = (-348639895 * ((v5 >> 47) ^ v5)) & (a2 - 1);
    v8 = (a1 + 16 * v7);
    v9 = *v8;
    if (*v8 == a3)
    {
      v10 = 1;
    }

    else
    {
      v12 = 0;
      v13 = 1;
      while (v9 != -4096)
      {
        if (v12)
        {
          v14 = 0;
        }

        else
        {
          v14 = v9 == -8192;
        }

        if (v14)
        {
          v12 = v8;
        }

        v15 = v7 + v13++;
        v7 = v15 & v6;
        v8 = (a1 + 16 * (v15 & v6));
        v9 = *v8;
        v10 = 1;
        if (*v8 == a3)
        {
          goto LABEL_5;
        }
      }

      v10 = 0;
      if (v12)
      {
        v8 = v12;
      }
    }
  }

  else
  {
    v8 = 0;
    v10 = 0;
  }

LABEL_5:
  *a4 = v8;
  return v10;
}

char *llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>,mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::CoreML::GraphOp,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::CoreML::GraphOp,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::CoreML::GraphOp>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          *(v21 + 2) = *(v19 + 8);
          ++*(a1 + 8);
        }

        v19 += 16;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

void *std::pair<mlir::ODIE::Compiler::CoreML::GraphOp,mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass::runOnOperation(void)::SubGraphInfo>::pair[abi:nn200100](void *a1, uint64_t a2)
{
  *a1 = *a2;
  a1[1] = a1 + 3;
  v4 = (a1 + 1);
  a1[2] = 0x300000000;
  if (*(a2 + 16))
  {
  }

  a1[9] = *(a2 + 72);
  return a1;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::ODIE::Compiler::CoreML::GraphOp,mlir::ODIE::Compiler::Transforms::anonymous namespace::UpdateSignatureToHandlesPass::runOnOperation(void)::SubGraphInfo>,false>::grow(uint64_t a1, unint64_t a2)
{
  v13 = 0;
  v3 = (a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (a1 + 16), a2, 80, &v13);
  v5 = v4;
  v6 = *a1;
  v7 = *(a1 + 8);
  if (v7)
  {
    v8 = 80 * v7;
    do
    {
      v6 += 80;
      v8 -= 80;
    }

    while (v8);
    v6 = *a1;
    v9 = *(a1 + 8);
    if (v9)
    {
      v10 = &v6[80 * v9 - 72];
      v11 = -80 * v9;
      do
      {
        if (v10 + 2 != *v10)
        {
          free(*v10);
        }

        v10 -= 10;
        v11 += 80;
      }

      while (v11);
      v6 = *a1;
    }
  }

  v12 = v13;
  if (v6 != v3)
  {
    free(v6);
  }

  *a1 = v5;
  *(a1 + 12) = v12;
}

void mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents::runOnOperation(mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents *this)
{
  v45 = *MEMORY[0x277D85DE8];
  v2 = *(this + 479);
  v3 = *(this + 58);
  if (v2 >= 0)
  {
    v4 = (this + 456);
  }

  else
  {
    v4 = *(this + 57);
  }

  if (v2 >= 0)
  {
    v5 = v2;
  }

  else
  {
    v5 = v3;
  }

  v6 = mlir::ODIE::Compiler::CoreML::symbolizeIntent(v4, v5);
  if (v7)
  {
    v8 = v6;
    mlir::Region::getOps<mlir::ODIE::Compiler::CoreML::GraphOp>(((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 16 * ((*((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 44) >> 23) & 1) + ((*((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 44) >> 21) & 0x7F8) + 32 * *((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 40) + 64), &v35);
    v31 = v35;
    v32 = v36;
    v33 = v37;
    v34 = v38;
    v30 = v39;
    while (v32 != v30)
    {
      v9 = (*(&v34 + 1))();
      v10 = *(v9 + 44);
      v11 = (v10 >> 23) & 1;
      if (!*(v9 + 16 * v11 + 104))
      {
        v12 = v9;
        v13 = v9 + 80;
        v14 = *(*(v9 + 80 + 16 * v11) + 8);
        if (*(v14 + 12))
        {
          v15 = 0;
          do
          {
            v16 = *(**(*(v14 + 16) + 8 * *(v14 + 8) + 8 * v15) + 136);
            if (v16 != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::HandleType,void>::id && v16 != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
            {
              v18 = mlir::ODIE::Compiler::CoreML::IntentAttr::get(*(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32), v8);
              v19 = *(***(v12 + 24) + 32);
              v41 = 261;
              v40[0] = "coreml.intent";
              v40[1] = 13;
              v21 = mlir::StringAttr::get(v19, v40, v20);
              InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v12);
              v23 = (*(*(InterfaceFor + 48) + 32))();
              if (v23)
              {
                v24 = *(*(v23 + 8) + 8 * v15);
              }

              else
              {
                v24 = 0;
              }

              v25 = mlir::NamedAttrList::NamedAttrList(v43, v24);
              if (mlir::NamedAttrList::set(v25, v21, v18) != v18)
              {
                Dictionary = mlir::NamedAttrList::getDictionary(v43, *(**v18 + 32));
                v27 = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v12);
                mlir::function_interface_impl::setResultAttrs(v12, v27, v15, Dictionary);
              }

              if (v43[0] != v44)
              {
                free(v43[0]);
              }

              LODWORD(v10) = *(v12 + 44);
            }

            ++v15;
            v14 = *(*(v13 + 16 * ((v10 >> 23) & 1)) + 8);
          }

          while (v15 < *(v14 + 12));
        }
      }

      mlir::Region::OpIterator::operator++(&v31);
      llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v31);
    }
  }

  else
  {
    v28 = *((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24);
    std::operator+<char>();
    LOWORD(v37) = 260;
    *&v35 = v43;
    emitDiag(v28, 1, &v35, v42);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v42);
    if ((v44[7] & 0x80000000) != 0)
    {
      operator delete(v43[0]);
    }
  }

  v29 = *MEMORY[0x277D85DE8];
}

void mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents::~DefineGraphOutputIntents(mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents *this)
{
  *this = &unk_286EA6378;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA6378;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA6378;
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 336);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::DefineGraphOutputIntentsBase<mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents>::DefineGraphOutputIntentsBase(uint64_t a1)
{
  *(a1 + 8) = &mlir::ODIE::Compiler::Transforms::impl::DefineGraphOutputIntentsBase<mlir::ODIE::Compiler::Transforms::DefineGraphOutputIntents>::resolveTypeID(void)::id;
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA6378;
  *&v4 = "Selected intent";
  *(&v4 + 1) = 15;
  v3 = "return";
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::initializer<char [7]>>((a1 + 336), (a1 + 144), "intent", 6, &v4, &v3);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  return a1;
}

void ***std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveConstants>::~unique_ptr[abi:nn200100](void ***a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA6458;
    v2[119] = &unk_286E798D8;
    std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((v2 + 139));
    llvm::cl::Option::~Option(v2 + 119);
    v2[94] = &unk_286E79348;
    std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100]((v2 + 113));
    llvm::cl::Option::~Option(v2 + 94);
    v2[68] = &unk_286EA6810;
    std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((v2 + 88));
    llvm::cl::Option::~Option(v2 + 68);
    v2[42] = &unk_286E798D8;
    std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((v2 + 62));
    llvm::cl::Option::~Option(v2 + 42);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::RemoveConstantsBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveConstants>::RemoveConstantsBase(uint64_t a1)
{
  *(a1 + 16) = "coreml.graph";
  *(a1 + 24) = 12;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA6458;
  v5.n128_u64[0] = "Constants larger than specified number of elements will be replaced";
  v5.n128_u64[1] = 67;
  v3 = 10;
  v4 = &v3;
  mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((a1 + 336), (a1 + 144), "size", 4, &v5, &v4);
  *(a1 + 336) = &unk_286EA64C8;
  *(a1 + 528) = &unk_286EA6548;
  v5.n128_u64[0] = "Float value to use as a replacement. This value will be casted to a target type of the constant";
  v5.n128_u64[1] = 95;
  v3 = 1;
  v4 = &v3;
  mlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(a1 + 544, (a1 + 144), &v5, &v4);
  *(a1 + 544) = &unk_286EA6690;
  *(a1 + 736) = &unk_286EA6710;
  v5.n128_u64[1] = 67;
  LOBYTE(v3) = 0;
  v4 = &v3;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((a1 + 752), (a1 + 144), "random", 6, &v5, &v4);
  *(a1 + 752) = &unk_286E76DD0;
  *(a1 + 936) = &unk_286E76E50;
  v5.n128_u64[0] = "Seed for the random generator";
  v5.n128_u64[1] = 29;
  v3 = 1000;
  v4 = &v3;
  mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((a1 + 952), (a1 + 144), "seed", 4, &v5, &v4);
  *(a1 + 952) = &unk_286EA64C8;
  *(a1 + 1144) = &unk_286EA6548;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveConstants::~RemoveConstants(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::RemoveConstants *this)
{
  *this = &unk_286EA6458;
  v2 = (this + 952);
  *(this + 119) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 1112);
  llvm::cl::Option::~Option(v2);
  *(this + 94) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 904);
  llvm::cl::Option::~Option(this + 94);
  *(this + 68) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](this + 704);
  llvm::cl::Option::~Option(this + 68);
  *(this + 42) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 496);
  llvm::cl::Option::~Option(this + 42);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA6458;
  v2 = (this + 952);
  *(this + 119) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 1112);
  llvm::cl::Option::~Option(v2);
  *(this + 94) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 904);
  llvm::cl::Option::~Option(this + 94);
  *(this + 68) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](this + 704);
  llvm::cl::Option::~Option(this + 68);
  *(this + 42) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 496);
  llvm::cl::Option::~Option(this + 42);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::RemoveConstants::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::RemoveConstants *this)
{
  v3 = *(this + 268);
  *(this + 290) = v3;
  v4 = 1;
  for (i = 291; i != 914; ++i)
  {
    v6 = 1812433253 * (v3 ^ (v3 >> 30));
    v3 = v6 + v4;
    *(this + i) = i + v6 - 290;
    ++v4;
  }

  v11[1] = v1;
  v11[2] = v2;
  *(this + 457) = 0;
  v7 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v10[1] = *(***(v7 + 24) + 32);
  v10[2] = 0;
  v10[3] = *(v7 + 16);
  v10[4] = v7;
  v9[1] = this;
  v10[0] = &unk_286E76228;
  v9[0] = v10;
  v11[0] = v9;
  return mlir::detail::walk<mlir::ForwardIterator>(v7, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_115RemoveConstants14runOnOperationEvEUlNSD_6CoreML10ConstantOpEE_SI_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_, v11, 1);
}

llvm::cl::Option *mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(llvm::cl::Option *a1, const void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6)
{
  v13[4] = *MEMORY[0x277D85DE8];
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a2;
  v11[1] = 0;
  v8 = llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(a1, v12, v11, a5, a6);
  *(v8 + 200) = 0;
  *v8 = &unk_286EA6588;
  *(v8 + 24) = &unk_286EA6608;
  v11[0] = v8 + 192;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100](a2 + 160, v11);
  v13[0] = &unk_286EA6648;
  v13[1] = a1;
  v13[3] = v13;
  std::function<void ()(unsigned long long const&)>::operator=(a1 + 20, v13);
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](v13);
  v9 = *MEMORY[0x277D85DE8];
  return a1;
}

void mlir::Pass::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::~Option(void **a1)
{
  *a1 = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((a1 + 20));

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((a1 + 20));
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  v4 = llvm::raw_ostream::operator<<(this, *(a1 + 16), *(a1 + 24));
  v5 = *(v4 + 4);
  if (v5 >= *(v4 + 3))
  {
    llvm::raw_ostream::write(v4, 61);
  }

  else
  {
    *(v4 + 4) = v5 + 1;
    *v5 = 61;
  }

  v6 = *(a1 + 120);

  return write_unsigned<unsigned long long>(this, v6, 0, 0, 0);
}

uint64_t mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(result + 120) = *(a2 - 72);
  *(result + 200) = *(a2 + 8);
  return result;
}

void non-virtual thunk tomlir::Pass::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::~Option(uint64_t a1)
{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](a1 - 32);

  llvm::cl::Option::~Option(v1);
}

{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](a1 - 32);
  llvm::cl::Option::~Option(v1);

  JUMPOUT(0x25F891040);
}

uint64_t non-virtual thunk tomlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(result - 72) = *(a2 - 72);
  *(result + 8) = *(a2 + 8);
  return result;
}

llvm::cl::Option *llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(llvm::cl::Option *a1, uint64_t *a2, const void **a3, __n128 *a4, int **a5)
{
  v10 = llvm::cl::Option::Option(a1, 0, 0);
  *(v10 + 120) = 0u;
  *(v10 + 136) = 0u;
  *(v10 + 128) = &unk_286E79940;
  *v10 = &unk_286E798D8;
  *(v10 + 152) = &unk_286E79180;
  *(v10 + 160) = &unk_286E79960;
  *(v10 + 184) = v10 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

void mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::~Option(void **a1)
{
  *a1 = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((a1 + 20));

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((a1 + 20));
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

void non-virtual thunk tomlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::~Option(uint64_t a1)
{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](a1 - 32);

  llvm::cl::Option::~Option(v1);
}

{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](a1 - 32);
  llvm::cl::Option::~Option(v1);

  JUMPOUT(0x25F891040);
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t *a2, const void **a3, __n128 *a4, int **a5)
{
  llvm::cl::Option::setArgStr(a1, *a2, a2[1]);
  llvm::cl::sub::apply<llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>>(a3, a1);
  result = *a4;
  *(a1 + 32) = *a4;
  v10 = **a5;
  *(a1 + 120) = v10;
  *(a1 + 144) = 1;
  *(a1 + 136) = v10;
  return result;
}

const void **llvm::cl::sub::apply<llvm::cl::opt<unsigned long long,false,llvm::cl::parser<unsigned long long>>>(const void **result, uint64_t a2)
{
  if (*result)
  {
    return llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a2 + 88), *result, v8);
  }

  v3 = result[1];
  if (v3)
  {
    v4 = *(v3 + 2);
    if (v4)
    {
      v5 = *v3;
      v6 = 8 * v4;
      do
      {
        v7 = *v5++;
        result = llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a2 + 88), v7, v8);
        v6 -= 8;
      }

      while (v6);
    }
  }

  return result;
}

void *std::function<void ()(unsigned long long const&)>::operator=(void *a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  std::__function::__value_func<void ()(unsigned long long const&)>::__value_func[abi:nn200100](v5, a2);
  std::__function::__value_func<void ()(unsigned long long const&)>::swap[abi:nn200100](v5, a1);
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](v5);
  v3 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t std::__function::__value_func<void ()(unsigned long long const&)>::__value_func[abi:nn200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void *std::__function::__value_func<void ()(unsigned long long const&)>::swap[abi:nn200100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x277D85DE8];
  if (a2 != result)
  {
    v3 = result;
    result = result[3];
    v4 = a2[3];
    if (result == v3)
    {
      if (v4 == a2)
      {
        (*(*result + 24))(result, v6);
        (*(*v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(*a2[3] + 24))(a2[3], v3);
        (*(*a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(v6[0] + 24))(v6, a2);
        result = (*(v6[0] + 32))(v6);
      }

      else
      {
        (*(*result + 24))(result, a2);
        result = (*(*v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v4 == a2)
    {
      (*(*v4 + 24))(a2[3], v3);
      result = (*(*a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      v3[3] = v4;
      a2[3] = result;
    }
  }

  v5 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIyN4llvm2cl6parserIyEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKyEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA6648;
  a2[1] = v2;
  return result;
}

uint64_t mlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, char *a2, _OWORD *a3, int **a4)
{
  v17[3] = *MEMORY[0x277D85DE8];
  v8 = llvm::cl::Option::Option(a1, 0, 0);
  *(v8 + 120) = 0u;
  *(v8 + 136) = 0u;
  *(v8 + 128) = &unk_286EA6878;
  *v8 = &unk_286EA6810;
  *(v8 + 152) = &unk_286E791B0;
  v9 = (v8 + 160);
  *(v8 + 160) = &unk_286EA6898;
  *(v8 + 184) = v8 + 160;
  llvm::cl::Option::setArgStr(v8, "value", 5);
  llvm::SmallPtrSetImpl<llvm::cl::SubCommand *>::insert((a1 + 88), a2, v15);
  *(a1 + 32) = *a3;
  v10 = **a4;
  *(a1 + 120) = v10;
  *(a1 + 144) = 1;
  *(a1 + 136) = v10;
  llvm::cl::Option::addArgument(a1);
  *(a1 + 200) = 0;
  *a1 = &unk_286EA6750;
  *(a1 + 192) = &unk_286EA67D0;
  v15[0] = a1 + 192;
  std::vector<mlir::detail::PassOptions::OptionBase *>::push_back[abi:nn200100]((a2 + 160), v15);
  v14[0] = &unk_286EA68E0;
  v14[1] = a1;
  v16 = v15;
  v14[3] = v14;
  v15[0] = &unk_286EA68E0;
  v15[1] = a1;
  if (v15 != v9)
  {
    v11 = *(a1 + 184);
    if (v11 == v9)
    {
      v17[0] = &unk_286EA68E0;
      v17[1] = a1;
      v16 = 0;
      (*(*v11 + 24))(v11, v15);
      (*(**(a1 + 184) + 32))(*(a1 + 184));
      *(a1 + 184) = 0;
      v16 = v15;
      (*(v17[0] + 24))(v17, v9);
      (*(v17[0] + 32))(v17);
    }

    else
    {
      *(a1 + 160) = &unk_286EA68E0;
      *(a1 + 168) = a1;
      v16 = v11;
    }

    *(a1 + 184) = v9;
  }

  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](v15);
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](v14);
  v12 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t llvm::cl::opt<double,false,llvm::cl::parser<double>>::handleOccurrence(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v11 = 0;
  v8 = parseDouble(a1, a5, a6, &v11);
  if (v8)
  {
    return v8;
  }

  *(a1 + 120) = v11;
  *(a1 + 12) = a2;
  v9 = *(a1 + 184);
  if (v9)
  {
    (*(*v9 + 48))(v9, &v11);
    return v8;
  }

  std::__throw_bad_function_call[abi:nn200100]();
  return llvm::cl::opt<double,false,llvm::cl::parser<double>>::getValueExpectedFlagDefault();
}

void mlir::Pass::Option<double,llvm::cl::parser<double>>::~Option(void **a1)
{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::opt<double,false,llvm::cl::parser<double>>::printOptionValue(uint64_t a1, int a2, char a3)
{
  if ((a3 & 1) != 0 || *(a1 + 144) != 1 || *(a1 + 136) != *(a1 + 120))
  {
    v9 = v3;
    v10 = v4;
    v5 = *(a1 + 120);
    v6 = *(a1 + 136);
    v8 = *(a1 + 144);
    v7[0] = &unk_286EA6878;
    v7[1] = v6;
    llvm::cl::parser<double>::printOptionDiff((a1 + 152), a1, v7, a2, v5);
  }
}

uint64_t llvm::cl::opt<double,false,llvm::cl::parser<double>>::setDefault(uint64_t result)
{
  v1 = 0;
  if (*(result + 144) == 1)
  {
    v1 = *(result + 136);
  }

  *(result + 120) = v1;
  return result;
}

void mlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  v4 = llvm::raw_ostream::operator<<(this, *(a1 + 16), *(a1 + 24));
  v5 = *(v4 + 4);
  if (v5 >= *(v4 + 3))
  {
    llvm::raw_ostream::write(v4, 61);
  }

  else
  {
    *(v4 + 4) = v5 + 1;
    *v5 = 61;
  }

  v6 = *(a1 + 120);

  llvm::write_double(this, 0, 0, 0, v6);
}

double mlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = *(a2 - 72);
  *(a1 + 120) = result;
  *(a1 + 200) = *(a2 + 8);
  return result;
}

void non-virtual thunk tomlir::Pass::Option<double,llvm::cl::parser<double>>::~Option(uint64_t a1)
{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](a1 - 32);

  llvm::cl::Option::~Option(v1);
}

{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](a1 - 32);
  llvm::cl::Option::~Option(v1);

  JUMPOUT(0x25F891040);
}

double non-virtual thunk tomlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  result = *(a2 - 72);
  *(a1 - 72) = result;
  *(a1 + 8) = *(a2 + 8);
  return result;
}

void mlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::~Option(void **a1)
{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

void non-virtual thunk tomlir::detail::PassOptions::Option<double,llvm::cl::parser<double>>::~Option(uint64_t a1)
{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](a1 - 32);

  llvm::cl::Option::~Option(v1);
}

{
  v1 = (a1 - 192);
  *(a1 - 192) = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](a1 - 32);
  llvm::cl::Option::~Option(v1);

  JUMPOUT(0x25F891040);
}

void llvm::cl::opt<double,false,llvm::cl::parser<double>>::~opt(void **a1)
{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));

  llvm::cl::Option::~Option(a1);
}

{
  *a1 = &unk_286EA6810;
  std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100]((a1 + 20));
  llvm::cl::Option::~Option(a1);

  JUMPOUT(0x25F891040);
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIdN4llvm2cl6parserIdEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKdEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_286EA68E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__value_func<void ()(double const&)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_115RemoveConstants14runOnOperationEvEUlNSD_6CoreML10ConstantOpEE_SI_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_(void **a1, uint64_t a2)
{
  v48 = *MEMORY[0x277D85DE8];
  result = 1;
  if (!a2 || *(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    goto LABEL_36;
  }

  v4 = *a1;
  v41 = a2;
  v5 = v4[1];
  ValueAttr = mlir::ODIE::Compiler::CoreML::ConstantOp::getValueAttr(&v41);
  v8 = (*v7)(v7, ValueAttr);
  v9 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(v8);
  if (!v9)
  {
    v18 = *v4;
    v19 = "Unshaped attribute";
    goto LABEL_32;
  }

  v11 = v9;
  v12 = v10;
  v13 = (*(v10 + 24))(v10, v9);
  if (v14)
  {
    v15 = 8 * v14;
    v16 = 1;
    do
    {
      v17 = *v13++;
      v16 *= v17;
      v15 -= 8;
    }

    while (v15);
  }

  else
  {
    v16 = 1;
  }

  if (v16 <= *(v5 + 456))
  {
    result = 2;
    goto LABEL_36;
  }

  v20 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type,llvm::CastInfo<mlir::ShapedType,mlir::Type,void>>::doCastIfPossible(v11);
  v22 = v11;
  if (v20)
  {
    v22 = (*(v21 + 8))(v21, v20);
  }

  if (*(*v22 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (*(v5 + 872) == 1)
    {
      LOBYTE(v29) = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()((v5 + 1160));
    }

    else
    {
      v29 = *(v5 + 664);
    }

    v46 = 64;
    v45 = v29;
    llvm::APInt::sextOrTrunc(&v45, v22[1] & 0x3FFFFFFF, &v43);
    if (v46 >= 0x41 && v45)
    {
      MEMORY[0x25F891010](v45, 0x1000C8000313F17);
    }

    v45 = v43;
    v46 = v44;
    v43 = mlir::DenseElementsAttr::get(v11, v12, &v45, 1);
    v31 = mlir::DenseElementsAttr::operator mlir::ElementsAttr(&v43);
    v33 = v34;
    if (v46 >= 0x41 && v45)
    {
      MEMORY[0x25F891010](v45, 0x1000C8000313F17);
    }

LABEL_29:
    if (v31)
    {
      v35 = *v4;
      v36 = v41;
      (*(**v4 + 40))(*v4, v41);
      v37 = *(v33 + 24);
      v38 = v41 + 16 * ((*(v41 + 44) >> 23) & 1);
      *(v38 + 64) = v31;
      *(v38 + 72) = v37;
      (*(*v35 + 48))(v35, v36);
      result = 1;
      goto LABEL_36;
    }

    goto LABEL_31;
  }

  v23 = llvm::DefaultDoCastIfPossible<mlir::FloatType,mlir::Type,llvm::CastInfo<mlir::FloatType,mlir::Type,void>>::doCastIfPossible(v22);
  if (v23)
  {
    v25 = v23;
    v26 = v24;
    if (*(v5 + 872) == 1)
    {
      v27 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()((v5 + 1160));
      v28 = (v27 + std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()((v5 + 1160)) * 4294967300.0) * 5.42101086e-20 * 2.0 + -1.0;
    }

    else
    {
      v28 = *(v5 + 664);
    }

    llvm::APFloat::APFloat(&v45, v28);
    v30 = (*v26)(v26, v25);
    llvm::APFloat::convert(&v45, v30, 1, &v42);
    v43 = mlir::DenseElementsAttr::get(v11, v12, &v45, 1);
    v31 = mlir::DenseElementsAttr::operator mlir::ElementsAttr(&v43);
    v33 = v32;
    llvm::APFloat::Storage::~Storage(&v45);
    goto LABEL_29;
  }

LABEL_31:
  v18 = *v4;
  v19 = "Unknown origin attribute";
LABEL_32:
  v45 = v19;
  v47 = 259;
  v43 = &v45;
  v39 = *(v18 + 16);
  if (v39 && v39[2] == 1)
  {
    (*(*v39 + 88))(v39, *(v41 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::CoreML::ConstantOp &>(mlir::ODIE::Compiler::CoreML::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v43);
  }

  result = 0;
LABEL_36:
  v40 = *MEMORY[0x277D85DE8];
  return result;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  i = this->__i_;
  v2 = (i + 1) % 0x270;
  v3 = this->__x_[v2];
  if (v3)
  {
    v4 = -1727483681;
  }

  else
  {
    v4 = 0;
  }

  v5 = v4 ^ this->__x_[(i + 397) % 0x270] ^ ((v3 & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1);
  this->__x_[i] = v5;
  this->__i_ = v2;
  v6 = ((v5 ^ (v5 >> 11)) << 7) & 0x9D2C5680 ^ v5 ^ (v5 >> 11);
  return (v6 << 15) & 0xEFC60000 ^ v6 ^ (((v6 << 15) & 0xEFC60000 ^ v6) >> 18);
}

void ***std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::BisectGraph>::~unique_ptr[abi:nn200100](void ***a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA6998;
    v2[123] = &unk_286E79348;
    std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100]((v2 + 142));
    llvm::cl::Option::~Option(v2 + 123);
    v2[98] = &unk_286E79348;
    std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100]((v2 + 117));
    llvm::cl::Option::~Option(v2 + 98);
    v2[72] = &unk_286E798D8;
    std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100]((v2 + 92));
    llvm::cl::Option::~Option(v2 + 72);
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((v2 + 42));
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::BisectGraphBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::BisectGraph>::BisectGraphBase(uint64_t a1)
{
  *(a1 + 16) = "coreml.graph";
  *(a1 + 24) = 12;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA6998;
  v5.n128_u64[0] = "Select graph with a name to bisect.";
  v5.n128_u64[1] = 35;
  v4 = "main";
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::initializer<char [5]>>((a1 + 336), (a1 + 144), "name", 4, &v5, &v4);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  v5.n128_u64[0] = "A point of bisection.";
  v5.n128_u64[1] = 21;
  v3 = 0;
  v4 = &v3;
  mlir::detail::PassOptions::Option<unsigned long long,llvm::cl::parser<unsigned long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((a1 + 576), (a1 + 144), "num", 3, &v5, &v4);
  *(a1 + 576) = &unk_286EA64C8;
  *(a1 + 768) = &unk_286EA6548;
  v5.n128_u64[0] = "Keep a section before or after a point of bisection.";
  v5.n128_u64[1] = 52;
  LOBYTE(v3) = 0;
  v4 = &v3;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((a1 + 784), (a1 + 144), "after", 5, &v5, &v4);
  *(a1 + 784) = &unk_286E76DD0;
  *(a1 + 968) = &unk_286E76E50;
  v5.n128_u64[0] = "Reattach constants to cuts.";
  v5.n128_u64[1] = 27;
  LOBYTE(v3) = 1;
  v4 = &v3;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((a1 + 984), (a1 + 144), "healConstants", 13, &v5, &v4);
  *(a1 + 984) = &unk_286E76DD0;
  *(a1 + 1168) = &unk_286E76E50;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BisectGraph::~BisectGraph(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BisectGraph *this)
{
  *this = &unk_286EA6998;
  v2 = (this + 984);
  *(this + 123) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 1136);
  llvm::cl::Option::~Option(v2);
  *(this + 98) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 936);
  llvm::cl::Option::~Option(this + 98);
  *(this + 72) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 736);
  llvm::cl::Option::~Option(this + 72);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA6998;
  v2 = (this + 984);
  *(this + 123) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 1136);
  llvm::cl::Option::~Option(v2);
  *(this + 98) = &unk_286E79348;
  std::__function::__value_func<void ()(BOOL const&)>::~__value_func[abi:nn200100](this + 936);
  llvm::cl::Option::~Option(this + 98);
  *(this + 72) = &unk_286E798D8;
  std::__function::__value_func<void ()(unsigned long long const&)>::~__value_func[abi:nn200100](this + 736);
  llvm::cl::Option::~Option(this + 72);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BisectGraph::runOnOperation(uint64_t this)
{
  v24[18] = *MEMORY[0x277D85DE8];
  v1 = *(this + 40) & 0xFFFFFFFFFFFFFFF8;
  v2 = *(v1 + 44);
  v3 = v1 + 64 + 16 * ((v2 >> 23) & 1);
  v4 = *(v3 + 56);
  v5 = *(this + 479);
  if (v5 >= 0)
  {
    v6 = (this + 456);
  }

  else
  {
    v6 = *(this + 456);
  }

  v7 = *(v4 + 24);
  if (v5 >= 0)
  {
    v8 = *(this + 479);
  }

  else
  {
    v8 = *(this + 464);
  }

  if (v7 != v8 || (v9 = this, v7) && (this = memcmp(*(v4 + 16), v6, v7), this) || (v10 = (((v3 + ((v2 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v1 + 40)), *v10 == v10))
  {
    v22 = *MEMORY[0x277D85DE8];
  }

  else
  {
    v11 = v10[1];
    if (v11)
    {
      v12 = v11 - 8;
    }

    else
    {
      v12 = 0;
    }

    v13 = (v12 + 32);
    v14 = *(v12 + 40);
    if (v14 == (v12 + 32))
    {
      v18 = -1;
    }

    else
    {
      v15 = *(v9 + 696);
      v16 = -1;
      v17 = *(v12 + 40);
      do
      {
        v17 = v17[1];
        ++v16;
      }

      while (v17 != v13);
      if (v15 <= v16)
      {
LABEL_24:
        if ((v15 & 0x8000000000000000) != 0)
        {
          do
          {
            v14 = *v14;
          }

          while (!__CFADD__(v15++, 1));
        }

        else if (v15)
        {
          v20 = v15 + 1;
          do
          {
            v14 = v14[1];
            --v20;
          }

          while (v20 > 1);
        }

        mlir::Block::splitBlock();
      }

      v18 = -1;
      do
      {
        v14 = v14[1];
        ++v18;
      }

      while (v14 != v13);
    }

    *(v9 + 696) = v18;
    v24[0] = v18;
    v19 = *(v9 + 760);
    if (v19)
    {
      (*(*v19 + 48))(v19, v24);
      v14 = *(v12 + 40);
      v15 = *(v9 + 696);
      goto LABEL_24;
    }

    v23 = std::__throw_bad_function_call[abi:nn200100]();
  }

  return this;
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::LoadResourcesFromFilePass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EA6A78;
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 336);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::LoadResourcesFromFileBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::LoadResourcesFromFilePass>::LoadResourcesFromFileBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EA6A78;
  *&v3 = "The directory in which to find resource files.";
  *(&v3 + 1) = 46;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 336), (a1 + 144), "resources-dir", 13, &v3);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::LoadResourcesFromFilePass::~LoadResourcesFromFilePass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::LoadResourcesFromFilePass *this)
{
  *this = &unk_286EA6A78;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EA6A78;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::LoadResourcesFromFilePass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::LoadResourcesFromFilePass *this)
{
  v1 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v12[0] = *(***(v1 + 24) + 32);
  memset(&v12[1], 0, 24);
  v9 = 0;
  v10 = 0;
  v11 = 0x24800000000;
  v8[0] = this;
  v8[1] = &v9;
  v8[2] = v12;
  v13 = v8;
  mlir::detail::walk<mlir::ForwardIterator>(v1, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_125LoadResourcesFromFilePass14runOnOperationEvE3__0NSD_6CoreML10ConstantOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v13, 1);
  if (HIDWORD(v10) && v10)
  {
    v2 = 0;
    v3 = *MEMORY[0x277D82808];
    v4 = *(MEMORY[0x277D82808] + 24);
    v5 = 8 * v10;
    do
    {
      v6 = *(v9 + v2);
      if (v6 != -8 && v6 != 0)
      {
        *(v6 + 8) = v3;
        *(v6 + 8 + *(v3 - 24)) = v4;
        MEMORY[0x25F890BE0](v6 + 24);
        std::istream::~istream();
        MEMORY[0x25F890F80](v6 + 432);
        MEMORY[0x25F891030](v6, 8);
      }

      v2 += 8;
    }

    while (v5 != v2);
  }

  free(v9);
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_125LoadResourcesFromFilePass14runOnOperationEvE3__0NSD_6CoreML10ConstantOpES2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, uint64_t a2)
{
  v82 = *MEMORY[0x277D85DE8];
  if (a2 && *(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    v2 = *a1;
    v71 = a2;
    v3 = *v2;
    ValueAttr = mlir::ODIE::Compiler::CoreML::ConstantOp::getValueAttr(&v71);
    if (*(*(*(v71 - 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v5 = (*(v71 - 8) & 0xFFFFFFFFFFFFFFF8);
    }

    else
    {
      v5 = 0;
    }

    v70 = v5;
    if (!v5)
    {
      v12 = *(v71 + 24);
      __p.__r_.__value_.__r.__words[0] = "Expect ranked tensors in constant op";
      v73[4] = 259;
      emitDiag(v12, 2, &__p, v75);
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v75);
      goto LABEL_69;
    }

    v6 = ValueAttr;
    if (*(*ValueAttr + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FileResourceAttr,void>::id)
    {
      v7 = *(ValueAttr[3] + 16);
      v8 = (v3 + 456);
      if (*(v3 + 479) < 0 && (v8 = *v8) == 0)
      {
        v9 = 0;
      }

      else
      {
        v9 = strlen(v8);
        v7 = *(v6[3] + 16);
      }

      v10 = v2[1];
      *v67 = v7;
      v66.__r_.__value_.__r.__words[0] = v8;
      v66.__r_.__value_.__l.__size_ = v9;
      llvm::StringRef::str(&v66.__r_.__value_.__l.__data_, v75);
      llvm::StringRef::str(v67, &__p);
      std::__fs::filesystem::path::append[abi:nn200100]<std::string>(v75, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v75[0].__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v75[0].__r_.__value_.__l.__data_, v75[0].__r_.__value_.__l.__size_);
      }

      else
      {
        __p = v75[0];
      }

      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p.__r_.__value_.__r.__words[0];
      }

      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = __p.__r_.__value_.__l.__size_;
      }

      v15 = llvm::xxh3_64bits(p_p, size, v11);
      Key = llvm::StringMapImpl::FindKey(v10, p_p, size, v15);
      if (Key == -1 || Key == *(v10 + 8))
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v18 = &__p;
        }

        else
        {
          v18 = __p.__r_.__value_.__r.__words[0];
        }

        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v19 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v19 = __p.__r_.__value_.__l.__size_;
        }

        v20 = llvm::xxh3_64bits(v18, v19, v17);
        v21 = llvm::StringMapImpl::LookupBucketFor(v10, v18, v19, v20);
        v22 = *v10;
        v23 = *(*v10 + 8 * v21);
        if (v23 == -8)
        {
          --*(v10 + 16);
        }

        else if (v23)
        {
          goto LABEL_35;
        }

        v63 = v21;
        buffer = llvm::allocate_buffer((v19 + 585), 8uLL);
        v54 = buffer;
        v55 = (buffer + 73);
        if (v19)
        {
          memcpy(buffer + 73, v18, v19);
        }

        v55[v19] = 0;
        *v54 = v19;
        v54[60] = 0;
        v56 = MEMORY[0x277D82858] + 24;
        v57 = MEMORY[0x277D82858] + 64;
        v54[54] = MEMORY[0x277D82858] + 64;
        v58 = *(MEMORY[0x277D82808] + 16);
        v59 = *(MEMORY[0x277D82808] + 8);
        v54[1] = v59;
        *(v54 + *(v59 - 24) + 8) = v58;
        v54[2] = 0;
        v60 = (v54 + *(v54[1] - 24) + 8);
        std::ios_base::init(v60, v54 + 3);
        v60[1].__vftable = 0;
        v60[1].__fmtflags_ = -1;
        v54[1] = v56;
        v54[54] = v57;
        MEMORY[0x25F890BD0](v54 + 3);
        if (!std::filebuf::open())
        {
          std::ios_base::clear((v54 + *(v54[1] - 24) + 8), *(v54 + *(v54[1] - 24) + 40) | 4);
        }

        *(v22 + 8 * v63) = v54;
        ++*(v10 + 12);
          ;
        }

        goto LABEL_35;
      }

      v24 = *(*v10 + 8 * Key);
LABEL_35:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v75[0].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v75[0].__r_.__value_.__l.__data_);
      }

      __p.__r_.__value_.__r.__words[0] = v6[4];
      UInt = mlir::IntegerAttr::getUInt(&__p);
      memset(v75, 0, sizeof(v75));
      v76 = 0u;
      v77 = 0u;
      v78 = 0u;
      v79 = 0u;
      v80 = 0u;
      v81 = UInt;
      std::istream::seekg();
      __p.__r_.__value_.__r.__words[0] = v5;
      v75[0].__r_.__value_.__r.__words[0] = v5[3];
      IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth(v75);
      v27 = mlir::TensorType::operator mlir::ShapedType(&__p);
      if (!mlir::ODIE::Compiler::CoreML::isSubByteElementType(v27, v28))
      {
        v75[0].__r_.__value_.__r.__words[0] = *(__p.__r_.__value_.__r.__words[0] + 24);
        if (mlir::Type::getIntOrFloatBitWidth(v75) == 1)
        {
          IntOrFloatBitWidth = 8;
        }
      }

      v29 = *(__p.__r_.__value_.__r.__words[0] + 16);
      if (v29)
      {
        v30 = *(__p.__r_.__value_.__r.__words[0] + 8);
        v31 = 8 * v29;
        v32 = 1;
        do
        {
          v33 = *v30++;
          v32 *= v33;
          v31 -= 8;
        }

        while (v31);
      }

      else
      {
        v32 = 1;
      }

      v34 = v32 * IntOrFloatBitWidth;
      v35 = v34 - (v34 != 0);
      if (v34)
      {
        v36 = ((v35 >> 3) + 1);
      }

      else
      {
        v36 = (v35 >> 3);
      }

      v69[0] = 0;
      std::istream::read();
      mlir::HeapAsmResourceBlob::allocate(v36, v69[0], 1, v75);
      std::istream::read();
      v37 = mlir::TensorType::operator mlir::ShapedType(&v70);
      v39 = v38;
      *&__p.__r_.__value_.__l.__data_ = *(v6[3] + 16);
      llvm::StringRef::str(&__p.__r_.__value_.__l.__data_, &v66);
      v64 = v6[4];
      v40 = mlir::IntegerAttr::getUInt(&v64);
      std::to_string(&v65, v40);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v41 = &v65;
      }

      else
      {
        v41 = v65.__r_.__value_.__r.__words[0];
      }

      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v42 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v42 = v65.__r_.__value_.__l.__size_;
      }

      v43 = std::string::append(&v66, v41, v42);
      v44 = v43->__r_.__value_.__r.__words[2];
      *v67 = *&v43->__r_.__value_.__l.__data_;
      v68 = v44;
      v43->__r_.__value_.__l.__size_ = 0;
      v43->__r_.__value_.__r.__words[2] = 0;
      v43->__r_.__value_.__r.__words[0] = 0;
      if (v68 >= 0)
      {
        v45 = v67;
      }

      else
      {
        v45 = v67[0];
      }

      if (v68 >= 0)
      {
        v46 = SHIBYTE(v68);
      }

      else
      {
        v46 = v67[1];
      }

      __p = v75[0];
      llvm::detail::UniqueFunctionBase<void,void *,unsigned long,unsigned long>::UniqueFunctionBase(v73, &v75[1]);
      v74 = BYTE8(v76);
      *&v69[1] = mlir::DenseResourceElementsAttr::get(v37, v39, v45, v46, &__p);
      mlir::AsmResourceBlob::~AsmResourceBlob(&__p);
      if (SHIBYTE(v68) < 0)
      {
        operator delete(v67[0]);
      }

      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v65.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      v47 = v2[2];
      v48 = v71;
      *(v47 + 16) = *(v71 + 16);
      *(v47 + 24) = v48;
      v49 = v2[2];
      v50 = *(v48 + 24);
      v67[0] = (*(v48 - 8) & 0xFFFFFFFFFFFFFFF8);
      v67[0] = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ConstantOp,mlir::Type,mlir::DenseResourceElementsAttr &>(v49, v50, v67, &v69[1]) - 16;
      mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith<mlir::Value &>((v71 - 16), v67);
      mlir::AsmResourceBlob::~AsmResourceBlob(v75);
    }
  }

LABEL_69:
  v51 = *MEMORY[0x277D85DE8];
  return 1;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ConstantOp,mlir::Type,mlir::DenseResourceElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t **a4)
{
  v26[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::ConstantOp>(a1, *(**a2 + 32));
  v20[0] = a2;
  v20[1] = v8;
  v20[2] = &v21;
  v20[3] = 0x400000000;
  v22[0] = v23;
  v22[1] = 0x400000000;
  v23[4] = v24;
  v23[5] = 0x400000000;
  v24[8] = 4;
  v24[9] = v25;
  v24[10] = 0x100000000;
  v25[1] = v26;
  v25[2] = 0x100000000;
  v26[1] = 0;
  v26[2] = 0;
  v26[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v26[4] = 0;
  v26[6] = 0;
  v9 = *a3;
  v10 = *a4;
  if (*a4)
  {
    v11 = *v10;
    v12 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
    v13 = mlir::detail::InterfaceMap::lookup(v11 + 8, v12);
  }

  else
  {
    v13 = 0;
  }

  v19 = v9;
  v14 = mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>(v20);
  *v14 = v10;
  v14[1] = v13;
  llvm::SmallVectorImpl<mlir::Type>::append<mlir::Type const*,void>(v22, &v19, v20);
  v15 = mlir::Operation::create(v20);
  mlir::OpBuilder::insert(a1, v15);
  if (*(*(v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  mlir::OperationState::~OperationState(v20);
  v17 = *MEMORY[0x277D85DE8];
  return v16;
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::VerifyUniqueDebugInfoRecordOps>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::VerifyUniqueDebugInfoRecordOps::~VerifyUniqueDebugInfoRecordOps(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::VerifyUniqueDebugInfoRecordOps *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::VerifyUniqueDebugInfoRecordOps::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::VerifyUniqueDebugInfoRecordOps *this)
{
  v5[0] = 0;
  v5[1] = 0;
  v6 = 0;
  v2 = *(this + 5);
  v4 = v5;
  v7 = &v4;
  if (!mlir::detail::walk<mlir::ForwardIterator>(v2 & 0xFFFFFFFFFFFFFFF8, _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_130VerifyUniqueDebugInfoRecordOps14runOnOperationEvEUlNSC_9DebugInfo8RecordOpEE_SI_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_, &v7, 1))
  {
    *(this + 5) |= 4uLL;
  }

  return MEMORY[0x25F891030](v5[0], 8);
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_130VerifyUniqueDebugInfoRecordOps14runOnOperationEvEUlNSC_9DebugInfo8RecordOpEE_SI_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESR_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, uint64_t a2)
{
  v24[25] = *MEMORY[0x277D85DE8];
  result = 1;
  if (!a2 || *(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::RecordOp,void>::id)
  {
    goto LABEL_13;
  }

  v5 = *a1;
  v18 = a2;
  Id = mlir::ODIE::DebugInfo::RecordOp::getId(&v18);
  v7 = *v5;
  v19 = 0;
  v8 = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>,unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::LookupBucketFor<unsigned long long>(*v7, *(v7 + 16), Id, &v19);
  v9 = v19;
  if (v8)
  {
    v17 = 257;
    mlir::Operation::emitError(&v19, a2, v16);
    if (v19)
    {
      mlir::Diagnostic::operator<<<24ul>(&v20, "Duplicate RecordOp id: ");
      if (v19)
      {
        LODWORD(v23) = 5;
        v24[0] = Id;
        v10 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v21, &v23, 1);
        v11 = v21 + 24 * v22;
        v12 = *v10;
        *(v11 + 16) = *(v10 + 16);
        *v11 = v12;
        ++v22;
      }
    }

    mlir::InFlightDiagnostic::InFlightDiagnostic(&v23, &v19);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v19);
    mlir::Diagnostic::attachNote(v24, *(v9[1] + 24), 1);
  }

  v23 = v19;
  v13 = *(v7 + 8);
  v14 = *(v7 + 16);
  if (4 * v13 + 4 >= 3 * v14)
  {
    v14 *= 2;
    goto LABEL_15;
  }

  if (v14 + ~v13 - *(v7 + 12) <= v14 >> 3)
  {
LABEL_15:
    llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::grow(v7, v14);
    llvm::DenseMapBase<llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>,unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::LookupBucketFor<unsigned long long>(*v7, *(v7 + 16), Id, &v23);
    v13 = *(v7 + 8);
    v9 = v23;
  }

  *(v7 + 8) = v13 + 1;
  if (*v9 != -1)
  {
    --*(v7 + 12);
  }

  *v9 = Id;
  v9[1] = a2;
  result = 1;
LABEL_13:
  v15 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>,unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::LookupBucketFor<unsigned long long>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = (a2 - 1) & (((0xBF58476D1CE4E5B9 * a3) >> 31) ^ (484763065 * a3));
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -2;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -1;
        }

        if (v17.i8[4])
        {
          *v16 = -1;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if (*v19 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>,unsigned long long,mlir::ODIE::DebugInfo::RecordOp,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,mlir::ODIE::DebugInfo::RecordOp>>::LookupBucketFor<unsigned long long>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          v21[1] = v19[1];
          ++*(a1 + 8);
        }

        v19 += 2;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -1;
      }

      if (v29.i8[4])
      {
        *v28 = -1;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::deduplicateConstants(uint64_t a1)
{
  v7[0] = *(***(a1 + 24) + 32);
  memset(&v7[1], 0, 24);
  v2 = *(mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>::getManagerInterface(v7[0]) + 24);
  v5[0] = 0;
  v5[1] = 0;
  v6 = 0;
  v4[0] = v5;
  v4[1] = v7;
  v4[2] = v7[0];
  v4[3] = v2;
  v8 = v4;
  mlir::detail::walk<mlir::ForwardIterator>(a1, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler20deduplicateConstantsENS1_8ModuleOpEE3__0NSC_6CoreML10ConstantOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_, &v8, 1);
  return MEMORY[0x25F891030](v5[0], 8);
}

uint64_t _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler20deduplicateConstantsENS1_8ModuleOpEE3__0NSC_6CoreML10ConstantOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t result, uint64_t a2)
{
  if (!a2)
  {
    return result;
  }

  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    return result;
  }

  v45[7] = v2;
  v45[8] = v3;
  v4 = *result;
  v44 = a2;
  result = mlir::ODIE::Compiler::CoreML::ConstantOp::getValueAttr(&v44);
  if (*(*result + 136) != &mlir::detail::TypeIDResolver<mlir::DenseResourceElementsAttr,void>::id)
  {
    return result;
  }

  v7 = result;
  v8 = *(result + 24);
  if (*(v8 + 80))
  {
    v9 = v8 + 16;
  }

  else
  {
    v9 = 0;
  }

  v10 = llvm::hashing::detail::hash_combine_range_impl<unsigned char const>(*v9, *v9 + *(v9 + 8), v5, v6);
  v11 = *v4;
  result = **v4;
  v12 = *(*v4 + 16);
  if (!v12)
  {
LABEL_28:
    v36 = v7[3];
    v37 = *v36;
    v38 = v36[1];
    v45[0] = 0;
    result = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>,unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::LookupBucketFor<unsigned long long>(result, v12, v10, v45);
    v39 = v45[0];
    if (result)
    {
LABEL_34:
      v39[1] = v37;
      v39[2] = v38;
      return result;
    }

    *&v42 = v45[0];
    v40 = *(v11 + 2);
    v41 = *(v11 + 4);
    if (4 * v40 + 4 >= 3 * v41)
    {
      v41 *= 2;
    }

    else if (v41 + ~v40 - *(v11 + 3) > v41 >> 3)
    {
LABEL_31:
      *(v11 + 2) = v40 + 1;
      if (*v39 != -1)
      {
        --*(v11 + 3);
      }

      v39[1] = 0;
      v39[2] = 0;
      *v39 = v10;
      goto LABEL_34;
    }

    llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::grow(v11, v41);
    result = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>,unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::LookupBucketFor<unsigned long long>(*v11, *(v11 + 4), v10, &v42);
    v40 = *(v11 + 2);
    v39 = v42;
    goto LABEL_31;
  }

  v13 = (v12 - 1) & (((0xBF58476D1CE4E5B9 * v10) >> 31) ^ (484763065 * v10));
  v14 = result + 24 * v13;
  v15 = *v14;
  if (*v14 != v10)
  {
    v34 = 1;
    while (v15 != -1)
    {
      v35 = v13 + v34++;
      v13 = v35 & (v12 - 1);
      v14 = result + 24 * v13;
      v15 = *v14;
      if (*v14 == v10)
      {
        goto LABEL_9;
      }
    }

    goto LABEL_28;
  }

LABEL_9:
  if (v14 == result + 24 * v12)
  {
    goto LABEL_28;
  }

  v16 = *(v14 + 16);
  v17 = v7[3];
  if (v16 != *(v17 + 8) || v16 && (result = memcmp(*(v14 + 8), *v17, v16), result))
  {
    v18 = *(v4 + 8);
    v19 = v44;
    *(v18 + 16) = *(v44 + 16);
    *(v18 + 24) = v19;
    v20 = mlir::DialectResourceBlobManager::lookup(*(v4 + 24), *(v14 + 8), *(v14 + 16));
    result = mlir::MLIRContext::getLoadedDialect(*(v4 + 16), "builtin", 7, v21);
    v22 = result;
    v23 = v20 + 16;
    if (!*(v20 + 80))
    {
      v23 = 0;
    }

    v24 = *(v23 + 8);
    v25 = v7[3];
    if (*(v25 + 80) == 1)
    {
      v26 = *(v25 + 16);
      v27 = *(v25 + 24);
    }

    else
    {
      v27 = 0;
      v26 = 0;
    }

    if (v24 == v27)
    {
      result = memcmp(*v23, v26, v24);
      if (!result)
      {
        v29 = v7[1];
        v28 = v7[2];
        *&v42 = v20;
        *(&v42 + 1) = mlir::detail::TypeIDResolver<mlir::DialectResourceBlobHandle<mlir::BuiltinDialect>,void>::resolveTypeID();
        v43 = v22;
        v45[0] = mlir::DenseResourceElementsAttr::get(v29, v28, &v42);
        v30 = *(v4 + 8);
        v31 = *(v44 + 24);
        *&v42 = *(v44 - 8) & 0xFFFFFFFFFFFFFFF8;
        v32 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ConstantOp,mlir::Type,mlir::DenseResourceElementsAttr &>(v30, v31, &v42, v45);
        if (*(v32 + 9))
        {
          v33 = v32 - 16;
        }

        else
        {
          v33 = 0;
        }

        *&v42 = v33;
        return mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith<mlir::Value &>((v44 - 16), &v42);
      }
    }
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>,unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::LookupBucketFor<unsigned long long>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = (a2 - 1) & (((0xBF58476D1CE4E5B9 * a3) >> 31) ^ (484763065 * a3));
    v6 = (a1 + 24 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -2;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 24 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

void *llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((24 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = 24 * v10 - 24;
      v13 = vdupq_n_s64(v12 / 0x18);
      do
      {
        v14 = vmovn_s64(vcgeq_u64(v13, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v14.i8[0])
        {
          *result = -1;
        }

        if (v14.i8[4])
        {
          result[3] = -1;
        }

        v11 += 2;
        result += 6;
      }

      while (((v12 / 0x18 + 2) & 0x1FFFFFFFFFFFFFFELL) != v11);
    }

    if (v3)
    {
      v15 = 24 * v3;
      v16 = v4;
      do
      {
        v17 = *v16;
        if (*v16 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v24 = 0;
          llvm::DenseMapBase<llvm::DenseMap<unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>,unsigned long long,llvm::StringRef,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,llvm::StringRef>>::LookupBucketFor<unsigned long long>(*a1, *(a1 + 16), v17, &v24);
          v18 = v24;
          *v24 = *v16;
          *(v18 + 1) = *(v16 + 8);
          ++*(a1 + 8);
        }

        v16 += 24;
        v15 -= 24;
      }

      while (v15);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v19 = *(a1 + 16);
  if (v19)
  {
    v20 = 0;
    v21 = 24 * v19 - 24;
    v22 = vdupq_n_s64(v21 / 0x18);
    do
    {
      v23 = vmovn_s64(vcgeq_u64(v22, vorrq_s8(vdupq_n_s64(v20), xmmword_25D0A0500)));
      if (v23.i8[0])
      {
        *result = -1;
      }

      if (v23.i8[4])
      {
        result[3] = -1;
      }

      v20 += 2;
      result += 6;
    }

    while (((v21 / 0x18 + 2) & 0x1FFFFFFFFFFFFFFELL) != v20);
  }

  return result;
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::ElideBroadcastPass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::ElideBroadcastPass::~ElideBroadcastPass(mlir::ODIE::Compiler::Transforms::ElideBroadcastPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::ElideBroadcastPass::runOnOperation(mlir::ODIE::Compiler::Transforms::ElideBroadcastPass *this)
{
  v17 = *MEMORY[0x277D85DE8];
  v2 = *(this + 5);
  if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v2 & 0xFFFFFFFFFFFFFFF8);
    v3 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  }

  else
  {
    v3 = 0;
  }

  v4 = *(***(v3 + 24) + 32);
  v5 = 0u;
  *v6 = 0u;
  v7 = v9;
  v8 = 0x600000000;
  v9[6] = 0;
  v9[7] = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0x2800000000;
  v14 = 0;
  v15 = 0;
  v16 = 0x2800000000;
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet();
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp::~AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_1(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_0(_DWORD *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReshapeOp,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  if (v7)
  {
    *a4 = v7;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v8 = *(v7 + 72);
    }

    else
    {
      v8 = 0;
    }

    *a5 = v8;
    a5[1] = 1;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v9 = *(v7 + 72);
    }

    else
    {
      v9 = 0;
    }

    result = 1;
    *a3 = v9 + 32;
    a3[1] = 1;
  }

  else
  {
    if (a1 && a1[2] == 1)
    {
      *&v11[1] = v5;
      v12 = v6;
    }

    return 0;
  }

  return result;
}

{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReshapeOp,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  if (v7)
  {
    *a4 = v7;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v8 = *(v7 + 72);
    }

    else
    {
      v8 = 0;
    }

    *a5 = v8;
    a5[1] = 1;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v9 = *(v7 + 72);
    }

    else
    {
      v9 = 0;
    }

    result = 1;
    *a3 = v9 + 32;
    a3[1] = 1;
  }

  else
  {
    if (a1 && a1[2] == 1)
    {
      *&v11[1] = v5;
      v12 = v6;
    }

    return 0;
  }

  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::ODIE::Compiler::CoreML::ReshapeOp &,mlir::OperandRange &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "castedOp1 is not ::mlir::ODIE::Compiler::CoreML::ReshapeOp type");
}

{
  return mlir::Diagnostic::operator<<<64ul>(a2, "castedOp1 is not ::mlir::ODIE::Compiler::CoreML::ReshapeOp type");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpDropRerankFirstCOREML_AddOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp::~AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_3(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_2(_DWORD *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReshapeOp,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  if (v7)
  {
    *a5 = v7;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v8 = *(v7 + 72);
    }

    else
    {
      v8 = 0;
    }

    *a3 = v8;
    a3[1] = 1;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v9 = *(v7 + 72);
    }

    else
    {
      v9 = 0;
    }

    result = 1;
    *a4 = v9 + 32;
    a4[1] = 1;
  }

  else
  {
    if (a1 && a1[2] == 1)
    {
      *&v11[1] = v5;
      v12 = v6;
    }

    return 0;
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpDropRerankFirstCOREML_AddOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp::~AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpDropRerankSecondCOREML_AddOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp::~AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpDropRerankSecondCOREML_AddOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveFirstRankingReshapeOp::~AddOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveSecondRankingReshapeOp::~AddOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastInDimsOp::~AddOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_4(_DWORD *a1, uint64_t a2, void *a3)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BroadcastInDimsOp,void>::id)
  {
    if ((*(a2 + 46) & 0x80) != 0)
    {
      v6 = *(a2 + 72);
    }

    else
    {
      v6 = 0;
    }

    result = 1;
    *a3 = v6;
    a3[1] = 1;
  }

  else
  {
    if (a1)
    {
      if (a1[2] == 1)
      {
        *&v7[1] = v3;
        v8 = v4;
      }
    }

    return 0;
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastToOp::~AddOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_5(_DWORD *a1, uint64_t a2, void *a3)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BroadcastToOp,void>::id)
  {
    if ((*(a2 + 46) & 0x80) != 0)
    {
      v6 = *(a2 + 72);
    }

    else
    {
      v6 = 0;
    }

    result = 1;
    *a3 = v6;
    a3[1] = 1;
  }

  else
  {
    if (a1)
    {
      if (a1[2] == 1)
      {
        *&v7[1] = v3;
        v8 = v4;
      }
    }

    return 0;
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastInDimsOp::~AddOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_6(_DWORD *a1, uint64_t a2, void *a3)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BroadcastInDimsOp,void>::id)
  {
    if ((*(a2 + 46) & 0x80) != 0)
    {
      v6 = *(a2 + 72);
    }

    else
    {
      v6 = 0;
    }

    result = 1;
    *a3 = v6;
    a3[1] = 1;
  }

  else
  {
    if (a1)
    {
      if (a1[2] == 1)
      {
        *&v7[1] = v3;
        v8 = v4;
      }
    }

    return 0;
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastToOp::~AddOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AddOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AddOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AddOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_7(_DWORD *a1, uint64_t a2, void *a3)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BroadcastToOp,void>::id)
  {
    if ((*(a2 + 46) & 0x80) != 0)
    {
      v6 = *(a2 + 72);
    }

    else
    {
      v6 = 0;
    }

    result = 1;
    *a3 = v6;
    a3[1] = 1;
  }

  else
  {
    if (a1)
    {
      if (a1[2] == 1)
      {
        *&v7[1] = v3;
        v8 = v4;
      }
    }

    return 0;
  }

  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AddOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AddOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp::~AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpDropRerankFirstCOREML_AndOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp::~AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_9(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpDropRerankFirstCOREML_AndOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp::~AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpDropRerankSecondCOREML_AndOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp::~AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpDropRerankSecondCOREML_AndOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveFirstRankingReshapeOp::~AndOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveSecondRankingReshapeOp::~AndOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastInDimsOp::~AndOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastToOp::~AndOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastInDimsOp::~AndOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastToOp::~AndOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::AndOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::AndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::AndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::AndOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::AndOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp::~BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_10(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::BitwiseAndOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::BitwiseAndOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp]";
  v6 = 193;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp::~BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_11(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpDropRerankFirstCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp]";
  v6 = 194;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp::~BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveFirstRankingReshapeOp]";
  v6 = 194;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp::~BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpDropRerankSecondCOREML_BitwiseAndOp_RemoveSecondRankingReshapeOp]";
  v6 = 195;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp::~BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp::~BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp::~BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 166;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp::~BitwiseAndOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp::~BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp::~BitwiseAndOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseAndOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseAndOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp::~BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_12(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::BitwiseOrOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::BitwiseOrOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp]";
  v6 = 191;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp::~BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_13(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpDropRerankFirstCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp]";
  v6 = 192;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp::~BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveFirstRankingReshapeOp]";
  v6 = 192;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp::~BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpDropRerankSecondCOREML_BitwiseOrOp_RemoveSecondRankingReshapeOp]";
  v6 = 193;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp::~BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 170;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 170;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp::~BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp::~BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp::~BitwiseOrOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 161;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp::~BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 166;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp::~BitwiseOrOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseOrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseOrOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp::~BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_14(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::BitwiseXorOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::BitwiseXorOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp]";
  v6 = 193;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp::~BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_15(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpDropRerankFirstCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp]";
  v6 = 194;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp::~BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveFirstRankingReshapeOp]";
  v6 = 194;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp::~BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpDropRerankSecondCOREML_BitwiseXorOp_RemoveSecondRankingReshapeOp]";
  v6 = 195;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp::~BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 171;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp::~BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp::~BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 166;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp::~BitwiseXorOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp::~BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp::~BitwiseXorOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::BitwiseXorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::BitwiseXorOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp::~DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_16(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpDropRerankFirstCOREML_DivideOp_RemoveFirstRankingReshapeOp]";
  v6 = 185;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp::~DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_17(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpDropRerankFirstCOREML_DivideOp_RemoveSecondRankingReshapeOp]";
  v6 = 186;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp::~DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpDropRerankSecondCOREML_DivideOp_RemoveFirstRankingReshapeOp]";
  v6 = 186;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp::~DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpDropRerankSecondCOREML_DivideOp_RemoveSecondRankingReshapeOp]";
  v6 = 187;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp::~DivideOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp::~DivideOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastInDimsOp::~DivideOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastToOp::~DivideOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 158;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastInDimsOp::~DivideOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastToOp::~DivideOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::DivideOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::DivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::DivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::DivideOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::DivideOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp::~EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_18(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::EqualOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::EqualOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpDropRerankFirstCOREML_EqualOp_RemoveFirstRankingReshapeOp]";
  v6 = 183;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp::~EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_19(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpDropRerankFirstCOREML_EqualOp_RemoveSecondRankingReshapeOp]";
  v6 = 184;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp::~EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpDropRerankSecondCOREML_EqualOp_RemoveFirstRankingReshapeOp]";
  v6 = 184;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp::~EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpDropRerankSecondCOREML_EqualOp_RemoveSecondRankingReshapeOp]";
  v6 = 185;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp::~EqualOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 166;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 166;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp::~EqualOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastInDimsOp::~EqualOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 161;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastToOp::~EqualOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 157;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastInDimsOp::~EqualOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastToOp::~EqualOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::EqualOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::EqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::EqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::EqualOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::EqualOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 158;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp::~FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_20(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::FloorDivideOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::FloorDivideOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp]";
  v6 = 195;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp::~FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_21(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpDropRerankFirstCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp]";
  v6 = 196;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp::~FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveFirstRankingReshapeOp]";
  v6 = 196;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp::~FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpDropRerankSecondCOREML_FloorDivideOp_RemoveSecondRankingReshapeOp]";
  v6 = 197;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp::~FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 172;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp::~FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 173;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 173;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp::~FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastToOp::~FloorDivideOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp::~FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastToOp::~FloorDivideOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::FloorDivideOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::FloorDivideOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::FloorDivideOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::FloorDivideOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::FloorDivideOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp::~GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_22(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::GreaterOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::GreaterOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveFirstRankingReshapeOp]";
  v6 = 187;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp::~GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_23(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpDropRerankFirstCOREML_GreaterOp_RemoveSecondRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp::~GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveFirstRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp::~GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpDropRerankSecondCOREML_GreaterOp_RemoveSecondRankingReshapeOp]";
  v6 = 189;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp::~GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp::~GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp::~GreaterOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastToOp::~GreaterOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp::~GreaterOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastToOp::~GreaterOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::GreaterOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::GreaterOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::GreaterOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::GreaterOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::GreaterOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp::~MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_24(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveFirstRankingReshapeOp]";
  v6 = 187;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp::~MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_25(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpDropRerankFirstCOREML_MaximumOp_RemoveSecondRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp::~MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveFirstRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp::~MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpDropRerankSecondCOREML_MaximumOp_RemoveSecondRankingReshapeOp]";
  v6 = 189;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp::~MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp::~MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp::~MaximumOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastToOp::~MaximumOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp::~MaximumOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastToOp::~MaximumOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MaximumOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MaximumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MaximumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MaximumOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MaximumOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp::~MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_26(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveFirstRankingReshapeOp]";
  v6 = 187;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp::~MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_27(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpDropRerankFirstCOREML_MinimumOp_RemoveSecondRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp::~MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveFirstRankingReshapeOp]";
  v6 = 188;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp::~MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpDropRerankSecondCOREML_MinimumOp_RemoveSecondRankingReshapeOp]";
  v6 = 189;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp::~MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp::~MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp::~MinimumOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastToOp::~MinimumOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp::~MinimumOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastToOp::~MinimumOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MinimumOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MinimumOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MinimumOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MinimumOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MinimumOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp::~ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_28(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveFirstRankingReshapeOp]";
  v6 = 185;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp::~ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_29(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpDropRerankFirstCOREML_ModuloOp_RemoveSecondRankingReshapeOp]";
  v6 = 186;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp::~ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveFirstRankingReshapeOp]";
  v6 = 186;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp::~ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpDropRerankSecondCOREML_ModuloOp_RemoveSecondRankingReshapeOp]";
  v6 = 187;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp::~ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 167;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp::~ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 168;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp::~ModuloOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 162;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastToOp::~ModuloOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 158;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp::~ModuloOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastToOp::~ModuloOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::ModuloOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ModuloOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::ModuloOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::ModuloOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::ModuloOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp::~MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_30(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpDropRerankFirstCOREML_MulOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp::~MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_31(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpDropRerankFirstCOREML_MulOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp::~MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpDropRerankSecondCOREML_MulOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp::~MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpDropRerankSecondCOREML_MulOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveFirstRankingReshapeOp::~MulOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveSecondRankingReshapeOp::~MulOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastInDimsOp::~MulOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastToOp::~MulOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastInDimsOp::~MulOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastToOp::~MulOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::MulOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::MulOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::MulOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::MulOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::MulOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp::~NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_32(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::NotEqualOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::NotEqualOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveFirstRankingReshapeOp]";
  v6 = 189;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp::~NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_33(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpDropRerankFirstCOREML_NotEqualOp_RemoveSecondRankingReshapeOp]";
  v6 = 190;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp::~NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveFirstRankingReshapeOp]";
  v6 = 190;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp::~NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpDropRerankSecondCOREML_NotEqualOp_RemoveSecondRankingReshapeOp]";
  v6 = 191;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp::~NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 169;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp::~NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 170;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 170;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp::~NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastToOp::~NotEqualOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp::~NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastToOp::~NotEqualOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::NotEqualOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::NotEqualOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::NotEqualOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::NotEqualOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::NotEqualOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 161;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp::~OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_34(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::OrOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::OrOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpDropRerankFirstCOREML_OrOp_RemoveFirstRankingReshapeOp]";
  v6 = 177;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp::~OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_35(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpDropRerankFirstCOREML_OrOp_RemoveSecondRankingReshapeOp]";
  v6 = 178;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp::~OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpDropRerankSecondCOREML_OrOp_RemoveFirstRankingReshapeOp]";
  v6 = 178;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp::~OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpDropRerankSecondCOREML_OrOp_RemoveSecondRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveFirstRankingReshapeOp::~OrOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 163;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveSecondRankingReshapeOp::~OrOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastInDimsOp::~OrOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 158;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastToOp::~OrOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 154;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastInDimsOp::~OrOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastToOp::~OrOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::OrOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::OrOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::OrOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::OrOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::OrOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp::~PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_36(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpDropRerankFirstCOREML_PowOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp::~PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_37(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpDropRerankFirstCOREML_PowOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp::~PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpDropRerankSecondCOREML_PowOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp::~PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpDropRerankSecondCOREML_PowOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveFirstRankingReshapeOp::~PowOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveSecondRankingReshapeOp::~PowOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastInDimsOp::~PowOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastToOp::~PowOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastInDimsOp::~PowOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastToOp::~PowOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::PowOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::PowOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::PowOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::PowOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::PowOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp::~SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_38(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpDropRerankFirstCOREML_SubOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp::~SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_39(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpDropRerankFirstCOREML_SubOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp::~SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpDropRerankSecondCOREML_SubOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp::~SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpDropRerankSecondCOREML_SubOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveFirstRankingReshapeOp::~SubOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveSecondRankingReshapeOp::~SubOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastInDimsOp::~SubOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastToOp::~SubOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastInDimsOp::~SubOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastToOp::~SubOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::SubOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::SubOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::SubOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::SubOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::SubOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp::~XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_40(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_16:
    v17();
    return 0;
  }

  *a7 = v8;
  v9 = *(*(v8 + 72) + 24);
  if ((~*(v9 + 8) & 7) == 0)
  {
    v9 = 0;
  }

  if (!v9)
  {
LABEL_10:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_16;
  }

  v12 = *(v9 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v9 + 24 * *(v9 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_10;
    }
  }

  else
  {
    v14 = v9 + 16 * v12 + 16;
  }

  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v20 = *(v8 + 72);
  }

  else
  {
    v20 = 0;
  }

  result = 1;
  *a5 = v20 + 32;
  a5[1] = 1;
  return result;
}

char *mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v18[8] = *MEMORY[0x277D85DE8];
  v8 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::XorOp>(a1, *(**a2 + 32));
  v13[0] = a2;
  v13[1] = v8;
  v13[2] = v14;
  v13[3] = 0x400000000;
  v14[4] = v15;
  v14[5] = 0x400000000;
  v15[4] = v16;
  v15[5] = 0x400000000;
  v16[8] = 4;
  v16[9] = v17;
  v16[10] = 0x100000000;
  v17[1] = v18;
  v17[2] = 0x100000000;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v18[4] = 0;
  v18[6] = 0;
  mlir::ODIE::Compiler::CoreML::XorOp::build(a1, v13, *a3, *a4);
  v9 = mlir::Operation::create(v13);
  mlir::OpBuilder::insert(a1, v9);
  if (*(*(v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  mlir::OperationState::~OperationState(v13);
  v11 = *MEMORY[0x277D85DE8];
  return v10;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpDropRerankFirstCOREML_XorOp_RemoveFirstRankingReshapeOp]";
  v6 = 179;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp::~XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_41(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v8 = a2;
  }

  else
  {
    v8 = 0;
  }

  if (!v8)
  {
    v18 = *(a1 + 16);
    if (!v18 || v18[2] != 1)
    {
      return 0;
    }

    v19 = *(a2 + 24);
    v17 = *(*v18 + 88);
LABEL_18:
    v17();
    return 0;
  }

  *a7 = v8;
  if ((*(v8 + 46) & 0x80) != 0)
  {
    v10 = *(v8 + 72);
  }

  else
  {
    v10 = 0;
  }

  *a8 = v10;
  a8[1] = 1;
  v11 = *(*(v8 + 72) + 56);
  if ((~*(v11 + 8) & 7) == 0)
  {
    v11 = 0;
  }

  if (!v11)
  {
LABEL_12:
    v15 = *(a1 + 16);
    if (!v15 || v15[2] != 1)
    {
      return 0;
    }

    v16 = *(v8 + 24);
    v17 = *(*v15 + 88);
    goto LABEL_18;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 120;
    if (v13 == -120)
    {
      goto LABEL_12;
    }
  }

  else
  {
    v14 = v11 + 16 * v12 + 16;
  }

  {
    llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(a3, v14);
    return 1;
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpDropRerankFirstCOREML_XorOp_RemoveSecondRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp::~XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpDropRerankSecondCOREML_XorOp_RemoveFirstRankingReshapeOp]";
  v6 = 180;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp::~XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpDropRerankSecondCOREML_XorOp_RemoveSecondRankingReshapeOp]";
  v6 = 181;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveFirstRankingReshapeOp::~XorOpRemoveRerank_RemoveFirstRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpRemoveRerank_RemoveFirstRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpRemoveRerank_RemoveFirstRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v22 = v5;
  v20 = 0;
  v21 = v5;
  v19 = 0;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v19 + 36))
  {
    v6 = v19 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v21;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v21 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v22 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v27 = 0;
  v28 = v5;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (!v11 || v11[2] != 1)
      {
        goto LABEL_38;
      }

      v12 = *(v6 + 3);
      goto LABEL_37;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_38:
    v24 = 0;
    goto LABEL_39;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v14 = *(v6 + 9);
  }

  else
  {
    v14 = 0;
  }

  v15 = v28;
  if (*(v27 + 36))
  {
    v16 = v27 - 16;
  }

  else
  {
    v16 = 0;
  }

  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v16, *(v28 + 24)))
  {
    v11 = *(a3 + 2);
    if (!v11 || v11[2] != 1)
    {
      goto LABEL_38;
    }

    v12 = *(a2 + 3);
LABEL_37:
    (*(*v11 + 88))(v11, v12, v13, &v34);
    goto LABEL_38;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v15 + 24);
  __src = *(v14 + 56);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_39:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveFirstRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_0' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 0 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveFirstRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpRemoveRerank_RemoveFirstRankingReshapeOp]";
  v6 = 164;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveSecondRankingReshapeOp::~XorOpRemoveRerank_RemoveSecondRankingReshapeOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpRemoveRerank_RemoveSecondRankingReshapeOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOpRemoveRerank_RemoveSecondRankingReshapeOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v20 = 0;
  v21 = 0;
  v19 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  {
LABEL_23:
    v15 = 0;
    goto LABEL_24;
  }

  if (*(v21 + 36))
  {
    v6 = v21 - 16;
  }

  else
  {
    v6 = 0;
  }

  v7 = v23;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v6, *(v23 + 24)))
  {
    v16 = *(a3 + 2);
    if (v16 && v16[2] == 1)
    {
    }

    goto LABEL_23;
  }

  v8 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v8;
  v9 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v19 + 24);
  __src = *(v7 + 24);
  v28 = v30;
  v10 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v9, &v24, &__src) - 16;
  if (*(v20 + 36))
  {
    v11 = v20 - 16;
  }

  else
  {
    v11 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v10, v11);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v12 = v24;
  if (v25)
  {
    v13 = 8 * v25;
    do
    {
      v14 = *v12++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v14);
      v13 -= 8;
    }

    while (v13);
    v12 = v24;
  }

  if (v12 != v26)
  {
    free(v12);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v15 = 1;
LABEL_24:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v17 = *MEMORY[0x277D85DE8];
  return v15;
}

{
  v38[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v29 = v5;
  v27 = 0;
  v37[0] = v38;
  v37[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (!v12 || v12[2] != 1)
      {
        goto LABEL_36;
      }

      v13 = *(v6 + 3);
      goto LABEL_35;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v37, v11);
  if (*(v27 + 36))
  {
    v15 = v27 - 16;
  }

  else
  {
    v15 = 0;
  }

  v16 = v29;
  if (!mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v15, *(v29 + 24)))
  {
    v12 = *(a3 + 2);
    if (!v12 || v12[2] != 1)
    {
      goto LABEL_36;
    }

    v13 = *(a2 + 3);
LABEL_35:
    (*(*v12 + 88))(v12, v13, v14, &v34);
    goto LABEL_36;
  }

  v17 = *(*(v37[0] + 1) + 24);
  v34 = *(*v37[0] + 24);
  v35 = v17;
  v18 = mlir::FusedLoc::get(&v34, 2, 0, *(a3 + 1));
  v35 = 0x400000000;
  v30 = *(v7 + 24);
  __src = *(v16 + 24);
  v34 = v36;
  v19 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v18, &v30, &__src) - 16;
  if (*(v6 + 9))
  {
    v20 = v6 - 16;
  }

  else
  {
    v20 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v19, v20);
  v30 = v32;
  v31 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v30, &__src, &v34);
  v21 = v30;
  if (v31)
  {
    v22 = 8 * v31;
    do
    {
      v23 = *v21++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v34, v23);
      v22 -= 8;
    }

    while (v22);
    v21 = v30;
  }

  if (v21 != v32)
  {
    free(v21);
  }

  (**a3)(a3, a2, v34 & 0xFFFFFFFFFFFFFFF9, v35);
  if (v34 != v36)
  {
    free(v34);
  }

  v24 = 1;
LABEL_37:
  if (v37[0] != v38)
  {
    free(v37[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveSecondRankingReshapeOp::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<<64ul>(a2, "entities 'reshape_op, input_1' failed to satisfy constraint: ''");
}

{
  return mlir::Diagnostic::operator<<<57ul>(a2, "There's no operation that defines operand 1 of castedOp0");
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOpRemoveRerank_RemoveSecondRankingReshapeOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOpRemoveRerank_RemoveSecondRankingReshapeOp]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastInDimsOp::~XorOp_RemoveFirstBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveFirstBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveFirstBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOp_RemoveFirstBinaryBroadcastInDimsOp]";
  v6 = 159;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastToOp::~XorOp_RemoveFirstBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveFirstBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveFirstBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 11) & 0x800000) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(*(v6 + 9) + 24);
  if ((~*(v7 + 8) & 7) == 0)
  {
    v7 = 0;
  }

  if (!v7)
  {
    goto LABEL_11;
  }

  v8 = *(v7 + 8) & 7;
  if (v8 == 6)
  {
    v9 = v7 + 24 * *(v7 + 16);
    v10 = v9 + 120;
    if (v9 == -120)
    {
LABEL_11:
      v11 = *(a3 + 2);
      if (v11 && v11[2] == 1)
      {
      }

      goto LABEL_30;
    }
  }

  else
  {
    v10 = v7 + 16 * v8 + 16;
  }

  {
LABEL_30:
    v20 = 0;
    goto LABEL_31;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v10);
  if ((*(v6 + 46) & 0x80) != 0)
  {
    v12 = *(v6 + 9);
  }

  else
  {
    v12 = 0;
  }

  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v23 + 24);
  __src = *(v12 + 56);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_31:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveFirstBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOp_RemoveFirstBinaryBroadcastToOp]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastInDimsOp::~XorOp_RemoveSecondBinaryBroadcastInDimsOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveSecondBinaryBroadcastInDimsOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastInDimsOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveSecondBinaryBroadcastInDimsOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastInDimsOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOp_RemoveSecondBinaryBroadcastInDimsOp]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastToOp::~XorOp_RemoveSecondBinaryBroadcastToOp(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveSecondBinaryBroadcastToOp *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastToOp::matchAndRewrite(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::XorOp_RemoveSecondBinaryBroadcastToOp *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  v32[4] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 9);
  }

  else
  {
    v5 = 0;
  }

  v23 = v5;
  v31[0] = v32;
  v31[1] = 0x400000000;
  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, a2);
  if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::XorOp,void>::id)
  {
    v6 = a2;
  }

  else
  {
    v6 = 0;
  }

  v7 = *(v6 + 9);
  v8 = *(v7 + 56);
  if ((~*(v8 + 8) & 7) == 0)
  {
    v8 = 0;
  }

  if (!v8)
  {
    goto LABEL_11;
  }

  v9 = *(v8 + 8) & 7;
  if (v9 == 6)
  {
    v10 = v8 + 24 * *(v8 + 16);
    v11 = v10 + 120;
    if (v10 == -120)
    {
LABEL_11:
      v12 = *(a3 + 2);
      if (v12 && v12[2] == 1)
      {
      }

      goto LABEL_28;
    }
  }

  else
  {
    v11 = v8 + 16 * v9 + 16;
  }

  {
LABEL_28:
    v20 = 0;
    goto LABEL_29;
  }

  llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(v31, v11);
  v13 = *(*(v31[0] + 1) + 24);
  v28 = *(*v31[0] + 24);
  v29 = v13;
  v14 = mlir::FusedLoc::get(&v28, 2, 0, *(a3 + 1));
  v29 = 0x400000000;
  v24 = *(v7 + 24);
  __src = *(v23 + 24);
  v28 = v30;
  v15 = mlir::OpBuilder::create<mlir::ODIE::Compiler::CoreML::XorOp,mlir::Value &,mlir::Value &>((a3 + 8), v14, &v24, &__src) - 16;
  if (*(v6 + 9))
  {
    v16 = v6 - 16;
  }

  else
  {
    v16 = 0;
  }

  __src = mlir::ODIE::Compiler::Transforms::setResultType(a3, v15, v16);
  v24 = v26;
  v25 = 0x400000000;
  llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value const*,void>(&v24, &__src, &v28);
  v17 = v24;
  if (v25)
  {
    v18 = 8 * v25;
    do
    {
      v19 = *v17++;
      llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(&v28, v19);
      v18 -= 8;
    }

    while (v18);
    v17 = v24;
  }

  if (v17 != v26)
  {
    free(v17);
  }

  (**a3)(a3, a2, v28 & 0xFFFFFFFFFFFFFFF9, v29);
  if (v28 != v30)
  {
    free(v28);
  }

  v20 = 1;
LABEL_29:
  if (v31[0] != v32)
  {
    free(v31[0]);
  }

  v21 = *MEMORY[0x277D85DE8];
  return v20;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::Transforms::anonymous namespace::XorOp_RemoveSecondBinaryBroadcastToOp>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::Transforms::(anonymous namespace)::XorOp_RemoveSecondBinaryBroadcastToOp]";
  v6 = 156;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::ElideRerankingPass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

void mlir::ODIE::Compiler::Transforms::ElideRerankingPass::~ElideRerankingPass(mlir::ODIE::Compiler::Transforms::ElideRerankingPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::ElideRerankingPass::runOnOperation(mlir::ODIE::Compiler::Transforms::ElideRerankingPass *this)
{
  v17 = *MEMORY[0x277D85DE8];
  v2 = *(this + 5);
  if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v2 & 0xFFFFFFFFFFFFFFF8);
    v3 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  }

  else
  {
    v3 = 0;
  }

  v4 = *(***(v3 + 24) + 32);
  v5 = 0u;
  *v6 = 0u;
  v7 = v9;
  v8 = 0x600000000;
  v9[6] = 0;
  v9[7] = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0x2800000000;
  v14 = 0;
  v15 = 0;
  v16 = 0x2800000000;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::populateWithGenerated(uint64_t *a1)
{
  v2 = *MEMORY[0x277D85DE8];
  v1 = *a1;
  operator new();
}

uint64_t mlir::ODIE::Compiler::Transforms::anonymous namespace::static_dag_matcher_1(_DWORD *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  if (*(*(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ReshapeOp,void>::id)
  {
    v7 = a2;
  }

  else
  {
    v7 = 0;
  }

  if (v7)
  {
    *a5 = v7;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v8 = *(v7 + 72);
    }

    else
    {
      v8 = 0;
    }

    *a3 = v8;
    a3[1] = 1;
    if ((*(v7 + 46) & 0x80) != 0)
    {
      v9 = *(v7 + 72);
    }

    else
    {
      v9 = 0;
    }

    result = 1;
    *a4 = v9 + 32;
    a4[1] = 1;
  }

  else
  {
    if (a1 && a1[2] == 1)
    {
      *&v11[1] = v5;
      v12 = v6;
    }

    return 0;
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::Transforms::setResultType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v53[25] = *MEMORY[0x277D85DE8];
  v5 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((*(a3 + 8) & 0xFFFFFFFFFFFFFFF8));
  v7 = v6;
  v8 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((*(a2 + 8) & 0xFFFFFFFFFFFFFFF8));
  v10 = v9;
  if ((~*(a2 + 8) & 7) != 0)
  {
    v11 = a2;
  }

  else
  {
    v11 = 0;
  }

  v12 = *(v11 + 8) & 7;
  if (v12 == 6)
  {
    v13 = v11 + 24 * *(v11 + 16);
    v14 = v13 + 192;
    v15 = v13 + 120;
  }

  else
  {
    v16 = v11 + 16 * v12;
    v14 = v16 + 88;
    v15 = v16 + 16;
  }

  v17 = *(*(v15 + 72) + 56);
  v18 = (*(*(*v14 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v18)
  {
    v19 = *v18;
    v20 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
    mlir::detail::InterfaceMap::lookup(v19 + 8, v20);
  }

  v21 = (*(v17 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v21)
  {
    v22 = *v21;
    v23 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
    mlir::detail::InterfaceMap::lookup(v22 + 8, v23);
  }

  v24 = (*(v10 + 8))(v10, v8);
  BroadcastedType = mlir::OpTrait::util::getBroadcastedType(v18, v21, v24);
  v26 = BroadcastedType;
  if (BroadcastedType)
  {
    v27 = *BroadcastedType;
    v28 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
    mlir::detail::InterfaceMap::lookup(v27 + 8, v28);
  }

  v29 = *(a2 + 8) & 7 | v26;
  *(a2 + 8) = v29;
  if ((~v29 & 7) != 0)
  {
    v30 = a2;
  }

  else
  {
    v30 = 0;
  }

  if (!v30)
  {
    goto LABEL_19;
  }

  v31 = *(v30 + 8) & 7;
  if (v31 == 6)
  {
    v32 = v30 + 24 * *(v30 + 16) + 120;
    if (!v32)
    {
LABEL_19:
      v33 = (a2 + 32);
      goto LABEL_22;
    }
  }

  else
  {
    v32 = v30 + 16 * v31 + 16;
  }

  v33 = (v32 + 24);
LABEL_22:
  v34 = *v33;
  v35 = *(a1 + 24);
  v48[0] = *(a1 + 8);
  v48[1] = v35;
  v49 = v34;
  v36 = (*(v7 + 24))(v7, v5);
  result = mlir::ODIE::Compiler::broadcastIfNeeded(a2, v36, v37, v48);
  if (v39)
  {
    v40 = *MEMORY[0x277D85DE8];
    return result;
  }

  if ((~*(a2 + 8) & 7) != 0)
  {
    v41 = a2;
  }

  else
  {
    v41 = 0;
  }

  if (!v41)
  {
    goto LABEL_28;
  }

  v43 = *(v41 + 8) & 7;
  if (v43 != 6)
  {
    v44 = v41 + 16 * v43 + 16;
LABEL_33:
    v42 = (v44 + 24);
    goto LABEL_34;
  }

  v44 = v41 + 24 * *(v41 + 16) + 120;
  if (v44)
  {
    goto LABEL_33;
  }

LABEL_28:
  v42 = (a2 + 32);
LABEL_34:
  v45 = *v42;
  v51 = 257;
  emitDiag(v45, 2, v50, &v52);
  if (v52)
  {
    mlir::Diagnostic::operator<<<28ul>(v53, "Failed to broadcast output\n");
  }

  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v52);
  v46 = std::__throw_bad_optional_access[abi:nn200100]();
  return mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(v46, v47);
}

BOOL mlir::ODIE::Compiler::Transforms::isRankingReshapeOp(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
  v3 = *(a1 + 8) & 0xFFFFFFFFFFFFFFF8;
  v4 = *(v2 + 8);
  v5 = *(v2 + 16);
  v6 = 8 * *(v3 + 16);
  v7 = *(v3 + 8) - 8;
  v8 = v4 - 8;
  v9 = 8 * v5;
  while (v9)
  {
    if (v6)
    {
      v10 = *(v8 + v9);
      v11 = *(v7 + v6);
      v6 -= 8;
      v9 -= 8;
      if (v10 == v11)
      {
        continue;
      }
    }

    return 0;
  }

  do
  {
    result = v6 == 0;
    if (!v6)
    {
      break;
    }

    v13 = *(v7 + v6);
    v6 -= 8;
  }

  while (v13 == 1);
  return result;
}

void mlir::ODIE::Compiler::Serialization::BytecodeExporter::exportProgram(mlir::ODIE::Compiler::Serialization::BytecodeExporter *this)
{
  v2 = *MEMORY[0x277D85DE8];
  v1 = *(***(*(this + 1) + 24) + 32);
  operator new();
}

void mlir::ODIE::Compiler::Serialization::BytecodeExporter::create(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, int a5@<W4>, const void *a6@<X5>, const void *a7@<X6>, _BYTE *a8@<X8>)
{
  if (a1 && a2)
  {
    if (a4)
    {
      if (a7)
      {
LABEL_5:
        v20[0] = a6;
        v20[1] = a7;
        v10[0] = &unk_286EAA238;
        v10[1] = a1;
        v9 = *a3;
        *a3 = 0;
        v10[2] = a2;
        v10[3] = v9;
        v11 = a4;
        v12 = a5;
        v14 = 0;
        v15 = 0;
        v13 = 0;
        llvm::StringRef::str(v20, &v18);
        v16 = v18;
        v17 = v19;
        mlir::ODIE::Compiler::Serialization::BytecodeExporter::BytecodeExporter(a8, v10);
        a8[88] = 1;
        mlir::ODIE::Compiler::Serialization::BytecodeExporter::~BytecodeExporter(v10);
        return;
      }
    }

    else if (!a5)
    {
      goto LABEL_5;
    }
  }

  *a8 = 0;
  a8[88] = 0;
}

uint64_t mlir::ODIE::Compiler::Serialization::BytecodeExporter::BytecodeExporter(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_286EAA238;
  *(a1 + 8) = *(a2 + 8);
  v3 = *(a2 + 16);
  *(a2 + 24) = 0;
  *(a1 + 16) = v3;
  *(a1 + 32) = *(a2 + 32);
  v4 = *(a2 + 40);
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 40) = v4;
  *(a2 + 48) = 0;
  *(a2 + 56) = 0;
  *(a2 + 40) = 0;
  if (*(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 64), *(a2 + 64), *(a2 + 72));
  }

  else
  {
    v5 = *(a2 + 64);
    *(a1 + 80) = *(a2 + 80);
    *(a1 + 64) = v5;
  }

  return a1;
}

void mlir::ODIE::Compiler::Serialization::BytecodeExporter::~BytecodeExporter(mlir::ODIE::Compiler::Serialization::BytecodeExporter *this)
{
  mlir::ODIE::Compiler::Serialization::BytecodeExporter::~BytecodeExporter(this);

  JUMPOUT(0x25F891040);
}

{
  *this = &unk_286EAA238;
  if (*(this + 87) < 0)
  {
    operator delete(*(this + 8));
  }

  if (*(this + 63) < 0)
  {
    operator delete(*(this + 5));
  }

  mlir::BytecodeWriterConfig::~BytecodeWriterConfig(this + 3);
}

void mlir::ODIE::Compiler::Serialization::rewriteModuleWithFxn(uint64_t a1)
{
  v2 = *MEMORY[0x277D85DE8];
  v1 = a1;
  mlir::BytecodeWriterConfig::BytecodeWriterConfig();
}

void llvm::function_ref<void ()(llvm::Twine const&)>::callback_fn<mlir::ODIE::Compiler::Serialization::invokeRewriter(mlir::ModuleOp,std::function<std::unique_ptr<llvm::MemoryBuffer> ()(std::unique_ptr<llvm::MemoryBuffer>&&,std::__fs::filesystem::path const&,llvm::function_ref<void ()(llvm::Twine const&)>)> const&,std::__fs::filesystem::path const)::$_0>(void ****a1, const llvm::Twine *a2)
{
  v3[26] = *MEMORY[0x277D85DE8];
  mlir::Operation::emitError(v3, **a1, a2);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(v3);
  v2 = *MEMORY[0x277D85DE8];
}

void mlir::ODIE::Compiler::Serialization::serializeModule(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  v11 = 0;
  v16 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = 0;
  v10 = &unk_286EAA260;
  v17[0] = 0;
  v17[1] = 0;
  mlir::ODIE::Compiler::Serialization::BytecodeExporter::create(a1, &v10, a2, 0, 0, &str_68, 0, v8);
  v4 = (*v8[0])(v8);
  if (v4)
  {
    v10[10](&v10);
    operator new();
  }

  v5 = llvm::errs(v4);
  v6 = *(v5 + 4);
  if (*(v5 + 3) - v6 > 0x26uLL)
  {
    qmemcpy(v6, "Failed to serialize module to bytecode.", 39);
    *(v5 + 4) += 39;
  }

  else
  {
    llvm::raw_ostream::write(v5, "Failed to serialize module to bytecode.", 0x27uLL);
  }

  *a3 = 0;
  if (v9 == 1)
  {
    mlir::ODIE::Compiler::Serialization::BytecodeExporter::~BytecodeExporter(v8);
  }

  v7 = v17[0];
  v17[0] = 0;
  if (v7)
  {
    std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](v17, v7);
  }

  llvm::raw_ostream::~raw_ostream(&v10);
}

void mlir::ODIE::Compiler::Serialization::anonymous namespace::MMapOstream::~MMapOstream(mlir::ODIE::Compiler::Serialization::_anonymous_namespace_::MMapOstream *this)
{
  v4 = *(this + 6);
  v2 = (this + 48);
  v3 = v4;
  *v2 = 0;
  if (v4)
  {
    std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](v2, v3);
  }

  llvm::raw_ostream::~raw_ostream(this);
}

{
  v4 = *(this + 6);
  v2 = (this + 48);
  v3 = v4;
  *v2 = 0;
  if (v4)
  {
    std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](v2, v3);
  }

  llvm::raw_ostream::~raw_ostream(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Serialization::anonymous namespace::MMapOstream::reserveExtraSpace(mlir::ODIE::Compiler::Serialization::_anonymous_namespace_::MMapOstream *this, uint64_t a2)
{
  if (!*(this + 6))
  {
    v4.__val_ = 0;
    v4.__cat_ = std::system_category();
    llvm::sys::Memory::allocateMappedMemory(a2, 0, 0x2000000, &v4, &v3);
    operator new();
  }

  llvm::report_fatal_error("Allocating over existing output buffer", 1);
}

void *mlir::ODIE::Compiler::Serialization::anonymous namespace::MMapOstream::write_impl(mlir::ODIE::Compiler::Serialization::_anonymous_namespace_::MMapOstream *this, const char *a2, size_t a3)
{
  v4 = *(this + 6);
  v3 = *(this + 7);
  if (v3 + a3 > v4[1])
  {
    llvm::report_fatal_error("Attempted to write past end of buffer when serializing bytecode.", 1);
  }

  result = memcpy((*v4 + v3), a2, a3);
  *(this + 7) += a3;
  return result;
}

void std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](uint64_t a1, void *a2)
{
  if (a2)
  {
    if (*a2)
    {
      llvm::sys::Memory::releaseMappedMemory(a2);
    }

    JUMPOUT(0x25F891040);
  }
}

void mlir::ODIE::Compiler::Serialization::anonymous namespace::MMapMemoryBuffer::~MMapMemoryBuffer(mlir::ODIE::Compiler::Serialization::_anonymous_namespace_::MMapMemoryBuffer *this)
{
  v3 = *(this + 3);
  v1 = (this + 24);
  v2 = v3;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](v1, v2);
  }
}

{
  v3 = *(this + 3);
  v1 = (this + 24);
  v2 = v3;
  *v1 = 0;
  if (v3)
  {
    std::default_delete<llvm::sys::OwningMemoryBlock>::operator()[abi:nn200100](v1, v2);
  }

  JUMPOUT(0x25F891040);
}

void mlir::BytecodeWriterConfig::~BytecodeWriterConfig(char ***this)
{
  v1 = *this;
  *this = 0;
  if (v1)
  {
    llvm::SmallVector<std::unique_ptr<mlir::AsmResourcePrinter>,6u>::~SmallVector(v1 + 23);
    llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeWriter<mlir::Type>>,6u>::~SmallVector(v1 + 15);
    llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeWriter<mlir::Attribute>>,6u>::~SmallVector(v1 + 7);
    llvm::StringMap<std::unique_ptr<mlir::DialectVersion>,llvm::MallocAllocator>::~StringMap((v1 + 2));
    MEMORY[0x25F891040](v1, 0x10D0C40F9939493);
  }
}

uint64_t mlir::writeBytecodeToFile(mlir *this, mlir::Operation *a2, llvm::raw_ostream *a3, const mlir::BytecodeWriterConfig *a4)
{
  v226 = *MEMORY[0x277D85DE8];
  v174 = 0;
  v173 = 0u;
  v175 = v177;
  v176 = 0;
  v7 = mlir::bytecode::detail::IRNumberingState::IRNumberingState(v177, this, a3);
  v201 = *a3;
  v203 = 0u;
  v202 = 0;
  v204 = v206;
  v205 = xmmword_25D0A0550;
  v207 = 0u;
  v208 = 0;
  v148 = v7;
  v209 = v7;
  v210 = &v173;
  v211 = v201;
  memset(v152, 0, sizeof(v152));
  *v150 = 0u;
  v151 = 0u;
  *__dst = 0u;
  v153 = 1;
  std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(__dst, 0, "ML\xEF\x52unsupported version requested ", "\x00unsupported version requested ", 4);
  if (*v201 >= 7uLL)
  {
    LOWORD(v223) = 257;
    mlir::Operation::emitError(v212, this, &v219);
    if (v212[0])
    {
      mlir::Diagnostic::operator<<<31ul>(&v212[1], "unsupported version requested ");
      if (v212[0])
      {
        v8 = *v201;
        LODWORD(v164[0]) = 2;
        v164[1] = v8;
        v9 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v213 + 8, v164, 1);
        v10 = *(&v213 + 1) + 24 * v214;
        v11 = *v9;
        *(v10 + 16) = *(v9 + 16);
        *v10 = v11;
        LODWORD(v214) = v214 + 1;
        if (v212[0])
        {
          mlir::Diagnostic::operator<<<21ul>(&v212[1], ", must be in range [");
        }
      }
    }

    v154 = 0;
    v12 = mlir::InFlightDiagnostic::operator<<<long long>(v212, &v154);
    v13 = v12;
    if (*v12)
    {
      mlir::Diagnostic::operator<<<3ul>((v12 + 1), ", ");
    }

    v160 = 6;
    v14 = mlir::InFlightDiagnostic::operator<<<long long>(v13, &v160);
    v15 = v14;
    if (*v14)
    {
      LOWORD(v166) = 264;
      LOBYTE(v164[0]) = 93;
      mlir::Diagnostic::operator<<((v14 + 1), v164);
    }

    v16 = *(v15 + 200);
    goto LABEL_159;
  }

  v146 = this;
  v147 = a2;
  std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(__dst, __dst[1], *(v201 + 40), (*(v201 + 40) + *(v201 + 48)), *(v201 + 48));
  LOBYTE(v212[0]) = 0;
  std::vector<unsigned char>::push_back[abi:nn200100](__dst, v212);
  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  *v212 = 0u;
  v217 = 1;
  v17 = v178;
  v18 = v179;
  if (v18)
  {
    v20 = 24 * v18;
    v21 = (v17 + 16);
    do
    {
      v22 = *v21;
      if (*v201 <= 0)
      {
      }

      else
      {
        v167 = 0u;
        v168 = 0u;
        *__p = 0u;
        v166 = 0u;
        *v164 = 0u;
        v169 = 1;
        if (v22[3])
        {
          v24 = *v201;
          v219 = &unk_286EAA310;
          v220 = v24;
          v221 = v164;
          v222 = v148;
          v223 = &v173;
          v224 = v201 + 16;
          (*(*v22[3] + 48))(v22[3], &v219);
          v25 = v164[0];
          v26 = v164[1] + *(&v168 + 1);
        }

        else
        {
          v25 = 0;
          v26 = 0;
        }

        if (v26 != v25)
        {
        }

        v219 = &v167;
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v219);
        if (__p[1])
        {
          *&v166 = __p[1];
          operator delete(__p[1]);
        }

        if (v164[0])
        {
          v164[1] = v164[0];
          operator delete(v164[0]);
        }
      }

      v21 += 3;
      v20 -= 24;
    }

    while (v20);
  }

  if (*v201 > 3)
  {
  }

  v27 = v182;
  v28 = v183;
  if (v182 != v183)
  {
    do
    {
      v29 = v27;
      v30 = *v27++;
      v31 = *v30;
      if (v27 != v28)
      {
        while (**v27 == v31)
        {
          if (++v27 == v28)
          {
            v27 = v28;
            break;
          }
        }
      }

      for (; v29 != v27; ++v29)
      {
        v32 = *v29;
        v33 = mlir::OperationName::stripDialect((*v29 + 1));
        v36 = v35;
        if (*v201 >= 5)
        {
          v36 = (*(v32[1] + 16) != &mlir::detail::TypeIDResolver<void,void>::id) | (2 * v35);
        }
      }
    }

    while (v27 != v28);
  }

  v164[0] = &v215;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
  if (*(&v213 + 1))
  {
    *&v214 = *(&v213 + 1);
    operator delete(*(&v213 + 1));
  }

  if (v212[0])
  {
    v212[1] = v212[0];
    operator delete(v212[0]);
  }

  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  *v212 = 0u;
  v217 = 1;
  v167 = 0u;
  v168 = 0u;
  *__p = 0u;
  v166 = 0u;
  *v164 = 0u;
  v169 = 1;
  v37 = v180;
  v38 = v181;
  if (v180 != v181)
  {
    v39 = 0;
    while (1)
    {
      v40 = v37;
      v41 = *v37++;
      v42 = *(v41 + 16);
      if (v37 != v38)
      {
        while (*(*v37 + 16) == v42)
        {
          if (++v37 == v38)
          {
            v37 = v38;
            break;
          }
        }
      }

      if (v37 != v40)
      {
        break;
      }

      v50 = v39;
LABEL_65:
      v39 = v50;
      if (v37 == v38)
      {
        goto LABEL_68;
      }
    }

    while (1)
    {
      v43 = *v40;
      *&v172 = **v40 & 0xFFFFFFFFFFFFFFF8;
      v44 = *v172;
      v45 = (*v172 + 72);
      v46 = mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID();
      v47 = *(v44 + 96);
      if ((v47 & 2) == 0)
      {
        v45 = *v45;
      }

      if (((*(v47 & 0xFFFFFFFFFFFFFFF8))(v45, v46) & 1) != 0 || mlir::Attribute::hasTrait<mlir::AttributeTrait::IsMutable>(&v172))
      {
        LODWORD(v220) = 0;
        LOBYTE(v224) = 0;
        HIDWORD(v224) = 1;
        v222 = 0;
        v223 = 0;
        v221 = 0;
        v219 = &unk_286EAA398;
        v225 = v212;
        llvm::raw_ostream::SetUnbuffered(&v219);
        v154 = v172;
        v48 = &v154;
      }

      else
      {
        v51 = *v201;
        v154 = &unk_286EAA310;
        v155 = v51;
        v156 = v212;
        v157 = v148;
        v158 = &v173;
        v159 = v201 + 16;
        v52 = *(v201 + 64);
        if (v52)
        {
          v53 = *(v201 + 56);
          v54 = 8 * v52;
          while (1)
          {
            v55 = *v53;
            LOBYTE(v219) = 0;
            LOBYTE(v221) = 0;
            if ((*(*v55 + 16))(v55, v172, &v219, &v154))
            {
              break;
            }

            ++v53;
            v54 -= 8;
            if (!v54)
            {
              goto LABEL_60;
            }
          }

LABEL_62:
          v49 = 1;
          goto LABEL_54;
        }

LABEL_60:
        v56 = *(v43[2] + 24);
        if (v56 && ((*(*v56 + 32))(v56, v172, &v154) & 1) != 0)
        {
          goto LABEL_62;
        }

        LODWORD(v220) = 0;
        LOBYTE(v224) = 0;
        HIDWORD(v224) = 1;
        v222 = 0;
        v223 = 0;
        v221 = 0;
        v219 = &unk_286EAA398;
        v225 = v212;
        llvm::raw_ostream::SetUnbuffered(&v219);
        v160 = v172;
        v48 = &v160;
      }

      mlir::Attribute::print(v48, &v219);
      llvm::raw_ostream::~raw_ostream(&v219);
      LOBYTE(v219) = 0;
      std::vector<unsigned char>::push_back[abi:nn200100](v212, &v219);
      v49 = 0;
LABEL_54:
      v50 = v212[1] + *(&v216 + 1) - v212[0];
      ++v40;
      v39 = v50;
      if (v40 == v37)
      {
        goto LABEL_65;
      }
    }
  }

  v50 = 0;
LABEL_68:
  v57 = v184;
  v58 = v185;
  if (v184 != v185)
  {
    while (1)
    {
      v59 = v57;
      v60 = *v57++;
      v61 = *(v60 + 16);
      if (v57 != v58)
      {
        while (*(*v57 + 16) == v61)
        {
          if (++v57 == v58)
          {
            v57 = v58;
            break;
          }
        }
      }

      if (v57 != v59)
      {
        break;
      }

      v69 = v50;
LABEL_91:
      v50 = v69;
      if (v57 == v58)
      {
        goto LABEL_92;
      }
    }

    while (1)
    {
      v62 = *v59;
      *&v172 = **v59 & 0xFFFFFFFFFFFFFFF8;
      if (mlir::Type::hasTrait<mlir::TypeTrait::IsMutable>(&v172))
      {
        goto LABEL_78;
      }

      v63 = *v172;
      v64 = (*v172 + 72);
      v65 = mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::AttributeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID();
      v66 = *(v63 + 96);
      if ((v66 & 2) == 0)
      {
        v64 = *v64;
      }

      if ((*(v66 & 0xFFFFFFFFFFFFFFF8))(v64, v65))
      {
LABEL_78:
        LODWORD(v220) = 0;
        LOBYTE(v224) = 0;
        HIDWORD(v224) = 1;
        v222 = 0;
        v223 = 0;
        v221 = 0;
        v219 = &unk_286EAA398;
        v225 = v212;
        llvm::raw_ostream::SetUnbuffered(&v219);
        v154 = v172;
        v67 = &v154;
      }

      else
      {
        v70 = *v201;
        v154 = &unk_286EAA310;
        v155 = v70;
        v156 = v212;
        v157 = v148;
        v158 = &v173;
        v159 = v201 + 16;
        v71 = *(v201 + 128);
        if (v71)
        {
          v72 = *(v201 + 120);
          v73 = 8 * v71;
          while (1)
          {
            v74 = *v72;
            LOBYTE(v219) = 0;
            LOBYTE(v221) = 0;
            if ((*(*v74 + 16))(v74, v172, &v219, &v154))
            {
              break;
            }

            ++v72;
            v73 -= 8;
            if (!v73)
            {
              goto LABEL_86;
            }
          }

LABEL_88:
          v68 = 1;
          goto LABEL_80;
        }

LABEL_86:
        v75 = *(v62[2] + 24);
        if (v75 && ((*(*v75 + 40))(v75, v172, &v154) & 1) != 0)
        {
          goto LABEL_88;
        }

        LODWORD(v220) = 0;
        LOBYTE(v224) = 0;
        HIDWORD(v224) = 1;
        v222 = 0;
        v223 = 0;
        v221 = 0;
        v219 = &unk_286EAA398;
        v225 = v212;
        llvm::raw_ostream::SetUnbuffered(&v219);
        v160 = v172;
        v67 = &v160;
      }

      mlir::Type::print(v67, &v219);
      llvm::raw_ostream::~raw_ostream(&v219);
      LOBYTE(v219) = 0;
      std::vector<unsigned char>::push_back[abi:nn200100](v212, &v219);
      v68 = 0;
LABEL_80:
      v69 = v212[1] + *(&v216 + 1) - v212[0];
      ++v59;
      v50 = v69;
      if (v59 == v57)
      {
        goto LABEL_91;
      }
    }
  }

LABEL_92:
  v219 = &v167;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v219);
  if (__p[1])
  {
    *&v166 = __p[1];
    operator delete(__p[1]);
  }

  if (v164[0])
  {
    v164[1] = v164[0];
    operator delete(v164[0]);
  }

  v164[0] = &v215;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
  if (*(&v213 + 1))
  {
    *&v214 = *(&v213 + 1);
    operator delete(*(&v213 + 1));
  }

  if (v212[0])
  {
    v212[1] = v212[0];
    operator delete(v212[0]);
  }

  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  *v212 = 0u;
  v217 = 1;
  LOBYTE(v164[0]) = 5;
  std::vector<unsigned char>::push_back[abi:nn200100](v212, v164);
  v164[0] = &v215;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
  if (*(&v213 + 1))
  {
    *&v214 = *(&v213 + 1);
    operator delete(*(&v213 + 1));
  }

  if (v212[0])
  {
    v212[1] = v212[0];
    operator delete(v212[0]);
  }

  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  *v212 = 0u;
  v217 = 1;
  v167 = 0u;
  v168 = 0u;
  *__p = 0u;
  v166 = 0u;
  *v164 = 0u;
  v169 = 1;
  v219 = &v221;
  v220 = 0x100000000;
  v160 = v212;
  v161 = &v219;
  v162 = &v163;
  v163 = 0;
  v76 = *(v201 + 8);
  v154 = &unk_286EAA410;
  v155 = v212;
  v156 = &v173;
  v158 = &v160;
  LOBYTE(v159) = v76;
  v77 = *(v201 + 192);
  if (v77)
  {
    v78 = *(v201 + 184);
    v79 = &v78[v77];
    do
    {
      LODWORD(v220) = 0;
      (*(**v78 + 16))(*v78, v146, &v154);
      v81 = *(*v78 + 31);
      if (v81 >= 0)
      {
        v82 = (*v78 + 8);
      }

      else
      {
        v82 = *(*v78 + 8);
      }

      v83 = *(*v78 + 16);
      if (v81 >= 0)
      {
        v84 = *(*v78 + 31);
      }

      else
      {
        v84 = *(*v78 + 16);
      }

      if (v220)
      {
        v87 = v219;
        v88 = &v219[4 * v220];
        do
        {
          v89 = *(v87 + 4);
          v90 = v87[3];
          LOBYTE(v172) = v89;
          std::vector<unsigned char>::push_back[abi:nn200100](v164, &v172);
          v87 += 4;
        }

        while (v87 != v88);
      }

      ++v78;
    }

    while (v78 != v79);
  }

  if (v179)
  {
    v92 = v178;
    v93 = v178 + 24 * v179;
    do
    {
      v94 = *(v92 + 2);
      v95 = *(v94 + 32);
      if (v95)
      {
        LODWORD(v220) = 0;
        (*(*v95 + 56))(v95, v146, v94 + 40, &v154);
        v96 = *(v94 + 112);
        if (v96)
        {
          v97 = *(v94 + 104) + 16;
          v98 = 24 * v96;
          do
          {
            if (*(*v97 + 28) == 1)
            {
              v172 = *(v97 - 16);
              v171 = 0;
              v99 = *(v160 + 72) + *(v160 + 8) - *v160;
              v170 = v99 - *v162;
              llvm::SmallVectorImpl<std::tuple<llvm::StringRef,mlir::AsmResourceEntryKind,unsigned long long>>::emplace_back<llvm::StringRef&,mlir::AsmResourceEntryKind&,unsigned long long>(v161, &v172, &v171, &v170);
              *v162 = v99;
            }

            v97 += 24;
            v98 -= 24;
          }

          while (v98);
        }

        if (v220)
        {
          if (v220)
          {
            v101 = v219;
            v102 = &v219[4 * v220];
            do
            {
              v103 = *(v101 + 4);
              v104 = v101[3];
              LOBYTE(v172) = v103;
              std::vector<unsigned char>::push_back[abi:nn200100](v164, &v172);
              v101 += 4;
            }

            while (v101 != v102);
          }
        }
      }

      v92 += 24;
    }

    while (v92 != v93);
  }

  if (v164[1] + *(&v168 + 1) != v164[0])
  {
  }

  if (v219 != &v221)
  {
    free(v219);
  }

  v219 = &v167;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v219);
  if (__p[1])
  {
    *&v166 = __p[1];
    operator delete(__p[1]);
  }

  if (v164[0])
  {
    v164[1] = v164[0];
    operator delete(v164[0]);
  }

  v164[0] = &v215;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
  if (*(&v213 + 1))
  {
    *&v214 = *(&v213 + 1);
    operator delete(*(&v213 + 1));
  }

  if (v212[0])
  {
    v212[1] = v212[0];
    operator delete(v212[0]);
  }

  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  *v212 = 0u;
  v217 = 1;
  if (v176)
  {
    v106 = v175 - 16;
    v107 = 24 * v176;
    do
    {
      v107 -= 24;
    }

    while (v107);
    if (v176)
    {
      v108 = v175;
      v109 = v175 + 24 * v176;
      do
      {
        std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(v212, v212[1], *v108, (*v108 + *(v108 + 2)), *(v108 + 2));
        LOBYTE(v164[0]) = 0;
        std::vector<unsigned char>::push_back[abi:nn200100](v212, v164);
        v108 += 24;
      }

      while (v108 != v109);
    }
  }

  v164[0] = &v215;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
  if (*(&v213 + 1))
  {
    *&v214 = *(&v213 + 1);
    operator delete(*(&v213 + 1));
  }

  if (v212[0])
  {
    v212[1] = v212[0];
    operator delete(v212[0]);
  }

  if (*v201 < 5)
  {
    if (v202 != v203)
    {
      v164[0] = "unexpected properties emitted incompatible with bytecode <5";
      LOWORD(v166) = 259;
      mlir::Operation::emitError(v212, v146, v164);
      v16 = v218;
LABEL_159:
      v113 = v16 ^ 1;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v212);
      goto LABEL_165;
    }
  }

  else
  {
    v216 = 0u;
    v215 = 0u;
    v214 = 0u;
    v213 = 0u;
    *v212 = 0u;
    v217 = 1;
    v110 = v203;
    for (i = v202; i != v110; i += 24)
    {
      v112 = *(i + 1);
      if (*i != v112)
      {
        std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(v212, v212[1], *i, v112, &v112[-*i]);
      }
    }

    v164[0] = &v215;
    std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v164);
    if (*(&v213 + 1))
    {
      *&v214 = *(&v213 + 1);
      operator delete(*(&v213 + 1));
    }

    if (v212[0])
    {
      v212[1] = v212[0];
      operator delete(v212[0]);
    }
  }

  v113 = 1;
LABEL_165:
  v212[0] = v152;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](v212);
  if (v150[1])
  {
    *&v151 = v150[1];
    operator delete(v150[1]);
  }

  if (__dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }

  MEMORY[0x25F891030](v207, 8);
  if (v204 != v206)
  {
    free(v204);
  }

  v114 = v202;
  if (v202)
  {
    v115 = v203;
    v116 = v202;
    if (v203 != v202)
    {
      v117 = v203;
      do
      {
        v119 = *(v117 - 3);
        v117 -= 24;
        v118 = v119;
        if (v119)
        {
          *(v115 - 2) = v118;
          operator delete(v118);
        }

        v115 = v117;
      }

      while (v117 != v114);
      v116 = v202;
    }

    *&v203 = v114;
    operator delete(v116);
  }

  MEMORY[0x25F891030](v200[21], 8);
  MEMORY[0x25F891030](v200[18], 8);
  MEMORY[0x25F891030](v200[15], 8);
  MEMORY[0x25F891030](v200[12], 8);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v200);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v200);
  if (v197)
  {
    v120 = v196;
    v121 = &v196[8 * v197];
    do
    {
      v122 = *v120;
      if (*v120 == *&v196[8 * v197 - 8])
      {
        v124 = v195[0];
      }

      else
      {
        v123 = ((v120 - v196) >> 10) & 0x1FFFFFF;
        if (v123 >= 0x1E)
        {
          LOBYTE(v123) = 30;
        }

        v124 = v122 + (4096 << v123);
      }

      for (j = ((v122 + 7) & 0xFFFFFFFFFFFFFFF8) + 32; j <= v124; j += 32)
      {
        if (*(j - 9) < 0)
        {
          operator delete(*(j - 32));
        }
      }

      v120 += 8;
    }

    while (v120 != v121);
  }

  if (v199)
  {
    v126 = v198;
    v127 = &v198[2 * v199];
    do
    {
      v128 = *v126 + v126[1];
      for (k = ((*v126 + 7) & 0xFFFFFFFFFFFFFFF8) + 32; k <= v128; k += 32)
      {
        if (*(k - 9) < 0)
        {
          operator delete(*(k - 32));
        }
      }

      v126 += 2;
    }

    while (v126 != v127);
  }

  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v195);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v195);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v194);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v194);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v193);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v193);
  if (v190)
  {
    v130 = v189;
    v131 = &v189[8 * v190];
    do
    {
      v132 = *v130;
      if (*v130 == *&v189[8 * v190 - 8])
      {
        v134 = v188[0];
      }

      else
      {
        v133 = ((v130 - v189) >> 10) & 0x1FFFFFF;
        if (v133 >= 0x1E)
        {
          LOBYTE(v133) = 30;
        }

        v134 = v132 + (4096 << v133);
      }

      for (m = ((v132 + 7) & 0xFFFFFFFFFFFFFFF8) + 120; m <= v134; m += 120)
      {
        v136 = *(m - 16);
        if (m != v136)
        {
          free(v136);
        }

        MEMORY[0x25F891030](*(m - 40), 8);
        v137 = *(m - 56);
        if ((m - 40) != v137)
        {
          free(v137);
        }

        MEMORY[0x25F891030](*(m - 80), 8);
      }

      v130 += 8;
    }

    while (v130 != v131);
  }

  if (v192)
  {
    v138 = v191;
    v139 = &v191[2 * v192];
    do
    {
      v140 = *v138 + v138[1];
      for (n = ((*v138 + 7) & 0xFFFFFFFFFFFFFFF8) + 120; n <= v140; n += 120)
      {
        v142 = *(n - 16);
        if (n != v142)
        {
          free(v142);
        }

        MEMORY[0x25F891030](*(n - 40), 8);
        v143 = *(n - 56);
        if ((n - 40) != v143)
        {
          free(v143);
        }

        MEMORY[0x25F891030](*(n - 80), 8);
      }

      v138 += 2;
    }

    while (v138 != v139);
  }

  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v188);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v188);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Reset(v187);
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v187);
  MEMORY[0x25F891030](v186, 8);
  if (v184)
  {
    v185 = v184;
    operator delete(v184);
  }

  if (v182)
  {
    v183 = v182;
    operator delete(v182);
  }

  if (v180)
  {
    v181 = v180;
    operator delete(v180);
  }

  if (v178 != &v180)
  {
    free(v178);
  }

  MEMORY[0x25F891030](v177[15], 8);
  MEMORY[0x25F891030](v177[12], 8);
  MEMORY[0x25F891030](v177[9], 8);
  MEMORY[0x25F891030](v177[6], 8);
  MEMORY[0x25F891030](v177[3], 8);
  MEMORY[0x25F891030](v177[0], 8);
  if (v175 != v148)
  {
    free(v175);
  }

  MEMORY[0x25F891030](v173, 8);
  v144 = *MEMORY[0x277D85DE8];
  return v113 & 1;
}

void anonymous namespace::EncodingEmitter::emitVarInt(uint64_t a1, unint64_t a2)
{
  if (a2 > 0x7F)
  {
  }

  else
  {
    v5 = v2;
    v6 = v3;
    v4 = (2 * a2) | 1;
    std::vector<unsigned char>::push_back[abi:nn200100](a1, &v4);
  }
}

llvm::raw_ostream *anonymous namespace::EncodingEmitter::writeTo(_anonymous_namespace_::EncodingEmitter *this, llvm::raw_ostream *a2)
{
  (*(*a2 + 16))(a2, *(this + 9) + *(this + 1) - *this);
  v4 = *(this + 3);
  v5 = *(this + 4);
  while (v4 != v5)
  {
    v6 = *v4;
    v7 = *(v4 + 8);
    v4 += 16;
    llvm::raw_ostream::write(a2, v6, v7);
  }

  v8 = *this;
  v9 = *(this + 1) - *this;

  return llvm::raw_ostream::write(a2, v8, v9);
}

void std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(uint64_t a1, const void *__dst, _BYTE *__src, char *a4, int64_t a5)
{
  if (a5 < 1)
  {
    return;
  }

  v10 = *(a1 + 8);
  v9 = *(a1 + 16);
  if (v9 - v10 >= a5)
  {
    v16 = v10 - __dst;
    if (v10 - __dst >= a5)
    {
      v21 = __dst + a5;
      v22 = &v10[-a5];
      v23 = *(a1 + 8);
      if (v10 >= a5)
      {
        do
        {
          v24 = *v22++;
          *v23++ = v24;
        }

        while (v22 != v10);
      }

      *(a1 + 8) = v23;
      if (v10 != v21)
      {
        memmove(__dst + a5, __dst, v10 - v21);
      }

      v25 = __dst;
      v26 = __src;
      v27 = a5;
    }

    else
    {
      v17 = &__src[v16];
      if (&__src[v16] == a4)
      {
        v18 = *(a1 + 8);
        v19 = v18;
      }

      else
      {
        v18 = &a4[__dst] - __src;
        v19 = *(a1 + 8);
        do
        {
          v20 = *v17++;
          *v19++ = v20;
        }

        while (v17 != a4);
      }

      *(a1 + 8) = v18;
      if (v16 < 1)
      {
        return;
      }

      v32 = __dst + a5;
      v33 = (v18 - a5);
      v34 = v18;
      if (v18 - a5 < v10)
      {
        do
        {
          v35 = *v33++;
          *v34++ = v35;
        }

        while (v33 != v10);
      }

      *(a1 + 8) = v34;
      if (v19 != v32)
      {
        memmove(__dst + a5, __dst, v18 - v32);
      }

      v25 = __dst;
      v26 = __src;
      v27 = v10 - __dst;
    }

    memmove(v25, v26, v27);
  }

  else
  {
    v11 = *a1;
    v12 = &v10[a5 - *a1];
    if (v12 < 0)
    {
      std::vector<unsigned char>::__throw_length_error[abi:nn200100]();
    }

    v13 = (__dst - v11);
    v14 = v9 - v11;
    if (2 * v14 > v12)
    {
      v12 = 2 * v14;
    }

    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v12;
    }

    if (v15)
    {
      operator new();
    }

    v28 = (__dst - v11);
    memcpy(v13, __src, a5);
    v29 = &v13[a5];
    v30 = v10 - __dst;
    memcpy(v29, __dst, v10 - __dst);
    *(a1 + 8) = __dst;
    v31 = &v13[v11 - __dst];
    memcpy(v31, v11, v28);
    *a1 = v31;
    *(a1 + 8) = &v29[v30];
    *(a1 + 16) = 0;
    if (v11)
    {

      operator delete(v11);
    }
  }
}

void anonymous namespace::EncodingEmitter::emitMultiByteVarInt(uint64_t a1, uint64_t a2)
{
  v3 = a1;
  v10 = *MEMORY[0x277D85DE8];
  v4 = 2;
  v5 = a2;
  while (v5 >> 14)
  {
    v5 >>= 7;
    if (++v4 == 9)
    {
      LOBYTE(v9) = 0;
      std::vector<unsigned char>::push_back[abi:nn200100](a1, &v9);
      v9 = a2;
      v6 = *(v3 + 8);
      v7 = &v10;
      a1 = v3;
      v4 = 8;
      goto LABEL_5;
    }
  }

  v9 = ((2 * a2) | 1) << (v4 - 1);
  v6 = *(a1 + 8);
  v7 = &v9 + v4;
LABEL_5:
  std::vector<unsigned char>::__insert_with_size[abi:nn200100]<unsigned char const*,unsigned char const*>(a1, v6, &v9, v7, v4);
  v8 = *MEMORY[0x277D85DE8];
}

void std::vector<unsigned char>::push_back[abi:nn200100](uint64_t a1, _BYTE *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = &v4[-*a1];
    v8 = (v7 + 1);
    if ((v7 + 1) < 0)
    {
      std::vector<unsigned char>::__throw_length_error[abi:nn200100]();
    }

    v9 = v3 - v6;
    if (2 * v9 > v8)
    {
      v8 = 2 * v9;
    }

    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      operator new();
    }

    v11 = &v4[-*a1];
    *v7 = *a2;
    v5 = v7 + 1;
    memcpy(0, v6, v11);
    *a1 = 0;
    *(a1 + 8) = v7 + 1;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = v4 + 1;
  }

  *(a1 + 8) = v5;
}

uint64_t anonymous namespace::anonymous namespace::StringSectionBuilder::insert(uint64_t a1, llvm::hashing::detail::hash_state *a2, uint64_t a3, unint64_t *a4)
{
  v4 = a3;
  v7 = llvm::hashing::detail::hash_combine_range_impl<char const>(a2, a2 + a3, a3, a4);
  v8 = *(a1 + 32);
  *&v19 = a2;
  *(&v19 + 1) = __PAIR64__(v7, v4);
  v20 = v8;
  v21 = v19;
  v22 = 0;
  v23 = 0;
  v9 = llvm::DenseMapBase<llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>,llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::LookupBucketFor<llvm::CachedHashStringRef>(*a1, *(a1 + 16), &v21, &v23);
  v10 = v23;
  if (v9)
  {
    v11 = *(a1 + 24) + 24 * *(v23 + 16);
    return *(v11 + 16);
  }

  v24 = v23;
  v12 = *(a1 + 8);
  v13 = *(a1 + 16);
  if (4 * v12 + 4 >= 3 * v13)
  {
    v13 *= 2;
  }

  else if (v13 + ~v12 - *(a1 + 12) > v13 >> 3)
  {
    goto LABEL_5;
  }

  llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::grow(a1, v13);
  llvm::DenseMapBase<llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>,llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::LookupBucketFor<llvm::CachedHashStringRef>(*a1, *(a1 + 16), &v21, &v24);
  v12 = *(a1 + 8);
  v10 = v24;
LABEL_5:
  *(a1 + 8) = v12 + 1;
  if (*(v10 + 12) || *v10 != -1)
  {
    --*(a1 + 12);
  }

  *v10 = v19;
  *(v10 + 16) = 0;
  v14 = *(a1 + 32);
  v15 = *(a1 + 36);
  *(v10 + 16) = v14;
  if (v14 >= v15)
  {
    llvm::SmallVectorTemplateBase<std::pair<llvm::CachedHashStringRef,unsigned long>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::CachedHashStringRef&&>,std::tuple<unsigned long &&>>(a1 + 24, &v19, v8);
    v17 = *(a1 + 32);
  }

  else
  {
    v16 = *(a1 + 24) + 24 * v14;
    *v16 = v19;
    *(v16 + 16) = v8;
    v17 = *(a1 + 32) + 1;
    *(a1 + 32) = v17;
  }

  v11 = *(a1 + 24) + 24 * v17 - 24;
  return *(v11 + 16);
}

void anonymous namespace::EncodingEmitter::emitSection(uint64_t a1, char a2, uint64_t a3)
{
  v6 = *a1;
  v5 = *(a1 + 8);
  v32 = a2;
  std::vector<unsigned char>::push_back[abi:nn200100](a1, &v32);
  v7 = *(a3 + 80);
  if (v7 >= 2)
  {
    if (((*(a1 + 72) + *(a1 + 8) - *a1) & (*(a3 + 80) - 1)) != 0)
    {
      *(*a1 + v5 - v6) |= 0x80u;
    }

    else
    {
      v8 = *(a1 + 80);
      if (v8 <= v7)
      {
        v8 = *(a3 + 80);
      }

      *(a1 + 80) = v8;
    }
  }

  v9 = *(a3 + 48);
  v10 = *(a3 + 56);
  while (v9 != v10)
  {
    std::vector<std::vector<unsigned char>>::emplace_back<std::vector<unsigned char>>(a1 + 48, v9);
    v9 += 24;
  }

  v12 = *(a3 + 24);
  v11 = *(a3 + 32);
  v13 = v11 - v12;
  v14 = (v11 - v12) >> 4;
  if (v14 >= 1)
  {
    v16 = *(a1 + 32);
    v15 = *(a1 + 40);
    if (v15 - v16 >= v13)
    {
      if (v12 != v11)
      {
        memmove(*(a1 + 32), *(a3 + 24), v11 - v12);
      }

      *(a1 + 32) = &v16[v13];
    }

    else
    {
      v17 = *(a1 + 24);
      v18 = v14 + (&v16[-v17] >> 4);
      if (v18 >> 60)
      {
        std::vector<llvm::ArrayRef<unsigned char>>::__throw_length_error[abi:nn200100]();
      }

      v19 = &v16[-v17] >> 4;
      v20 = v15 - v17;
      v21 = (v15 - v17) >> 3;
      if (v21 > v18)
      {
        v18 = v21;
      }

      if (v20 >= 0x7FFFFFFFFFFFFFF0)
      {
        v22 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v22 = v18;
      }

      if (v22)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<llvm::ArrayRef<unsigned char>>>(v22);
      }

      v23 = 16 * v19;
      v24 = (16 * v19 + v13);
      v25 = v23;
      do
      {
        v26 = *v12;
        v12 += 16;
        *v25++ = v26;
        v13 -= 16;
      }

      while (v13);
      memcpy(v24, v16, *(a1 + 32) - v16);
      v27 = *(a1 + 24);
      v28 = &v24[*(a1 + 32) - v16];
      *(a1 + 32) = v16;
      v29 = v16 - v27;
      v30 = (v23 - (v16 - v27));
      memcpy(v30, v27, v29);
      v31 = *(a1 + 24);
      *(a1 + 24) = v30;
      *(a1 + 32) = v28;
      *(a1 + 40) = 0;
      if (v31)
      {
        operator delete(v31);
      }
    }
  }

  *(a1 + 72) += *(a3 + 72);
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>,llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::LookupBucketFor<llvm::CachedHashStringRef>(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    v14 = xmmword_25D0A0930;
    v15 = xmmword_25D0A05E0;
    v7 = a2 - 1;
    v8 = *(a3 + 12) & (a2 - 1);
    v9 = a1 + 24 * v8;
    if (llvm::DenseMapInfo<llvm::CachedHashStringRef,void>::isEqual(a3, v9))
    {
      result = 1;
    }

    else
    {
      v11 = 0;
      v12 = 1;
      while (!llvm::DenseMapInfo<llvm::CachedHashStringRef,void>::isEqual(v9, &v15))
      {
        if (llvm::DenseMapInfo<llvm::CachedHashStringRef,void>::isEqual(v9, &v14) && v11 == 0)
        {
          v11 = v9;
        }

        v8 = (v8 + v12) & v7;
        v9 = a1 + 24 * v8;
        isEqual = llvm::DenseMapInfo<llvm::CachedHashStringRef,void>::isEqual(a3, v9);
        result = 1;
        ++v12;
        if (isEqual)
        {
          goto LABEL_4;
        }
      }

      result = 0;
      if (v11)
      {
        v9 = v11;
      }
    }

LABEL_4:
    *a4 = v9;
  }

  else
  {
    result = 0;
    *a4 = 0;
  }

  return result;
}

_OWORD *llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((24 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 24 * v10;
      do
      {
        *result = xmmword_25D0A05E0;
        result = (result + 24);
        v11 -= 24;
      }

      while (v11);
    }

    if (!v3)
    {
LABEL_18:

      JUMPOUT(0x25F891030);
    }

    v12 = 24 * v3;
    v13 = v4;
    while (1)
    {
      v14 = *(v13 + 12);
      if (v14 == 1)
      {
        if (*v13 == -2)
        {
          goto LABEL_14;
        }
      }

      else if (!v14 && *v13 == -1)
      {
        goto LABEL_14;
      }

      v18 = 0;
      llvm::DenseMapBase<llvm::DenseMap<llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>,llvm::CachedHashStringRef,unsigned int,llvm::DenseMapInfo<llvm::CachedHashStringRef,void>,llvm::detail::DenseMapPair<llvm::CachedHashStringRef,unsigned int>>::LookupBucketFor<llvm::CachedHashStringRef>(*a1, *(a1 + 16), v13, &v18);
      v15 = v18;
      *v18 = *v13;
      *(v15 + 4) = *(v13 + 16);
      ++*(a1 + 8);
LABEL_14:
      v13 += 24;
      v12 -= 24;
      if (!v12)
      {
        goto LABEL_18;
      }
    }
  }

  *(a1 + 8) = 0;
  v16 = *(a1 + 16);
  if (v16)
  {
    v17 = 24 * v16;
    do
    {
      *result = xmmword_25D0A05E0;
      result = (result + 24);
      v17 -= 24;
    }

    while (v17);
  }

  return result;
}

__n128 llvm::SmallVectorTemplateBase<std::pair<llvm::CachedHashStringRef,unsigned long>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::CachedHashStringRef&&>,std::tuple<unsigned long &&>>(uint64_t a1, __int128 *a2, uint64_t a3)
{
  v10 = *a2;
  v11 = a3;
  v4 = *(a1 + 8);
  v5 = *a1;
  v6 = &v10;
  if (v4 >= *(a1 + 12))
  {
    if (v5 <= &v10 && v5 + 24 * v4 > &v10)
    {
      v9 = &v10 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v9[*a1];
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v10;
    }
  }

  v7 = (v5 + 24 * *(a1 + 8));
  result = *v6;
  v7[1].n128_u64[0] = v6[1].n128_u64[0];
  *v7 = result;
  ++*(a1 + 8);
  return result;
}

void anonymous namespace::DialectWriter::writeAttribute(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 16);
  v2 = *(a1 + 24);
  v5 = a2;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[](v2, &v5);
}

void anonymous namespace::DialectWriter::writeOptionalAttribute(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    v3 = *(a1 + 16);
    v2 = *(a1 + 24);
    v7 = a2;
    v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[](v2, &v7);
  }

  else
  {
    v5 = *(a1 + 16);
    v6 = 1;
    std::vector<unsigned char>::push_back[abi:nn200100](v5, &v6);
  }
}

void anonymous namespace::DialectWriter::writeType(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 16);
  v2 = *(a1 + 24);
  v5 = a2;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::operator[]((v2 + 72), &v5);
}

void anonymous namespace::DialectWriter::writeResourceHandle(uint64_t a1, void *a2)
{
  v3 = *(a1 + 16);
  v4 = *(a1 + 24);
  v6 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::LookupBucketFor<mlir::AsmDialectResourceHandle>((v4 + 232), a2, &v6))
  {
    v5 = *(v6[3] + 24);
  }

  else
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::InsertIntoBucketImpl<mlir::AsmDialectResourceHandle>(v4 + 232, a2, v6);
    __break(1u);
  }
}

void anonymous namespace::DialectWriter::writeAPIntWithKnownWidth(_anonymous_namespace_::DialectWriter *this, const llvm::APInt *a2)
{
  v2 = a2;
  v4 = *(a2 + 2);
  if (v4 > 8)
  {
    if (v4 > 0x40)
    {
      v8 = llvm::APInt::countLeadingZerosSlowCase(a2);
      if (v4 == v8)
      {
        v9 = 1;
      }

      else
      {
        v9 = ((v4 + ~v8) >> 6) + 1;
      }

      if (*(v2 + 2) >= 0x41u)
      {
        v2 = *v2;
      }

      do
      {
        v10 = *v2;
        v2 = (v2 + 8);
        --v9;
      }

      while (v9);
    }

    else
    {
      v6 = *(this + 2);
      LimitedValue = llvm::APInt::getLimitedValue(a2, 0xFFFFFFFFFFFFFFFFLL);
    }
  }

  else
  {
    v5 = *(this + 2);
    v11 = llvm::APInt::getLimitedValue(a2, 0xFFFFFFFFFFFFFFFFLL);
    std::vector<unsigned char>::push_back[abi:nn200100](v5, &v11);
  }
}

uint64_t anonymous namespace::DialectWriter::writeAPFloatWithKnownSemantics(_anonymous_namespace_::DialectWriter *this, const llvm::APFloat *a2)
{
  llvm::APFloat::bitcastToAPInt(a2, &v4);
  result = (*(*this + 64))(this, &v4);
  if (v5 >= 0x41)
  {
    result = v4;
    if (v4)
    {
      return MEMORY[0x25F891010](v4, 0x1000C8000313F17);
    }
  }

  return result;
}

void anonymous namespace::DialectWriter::writeOwnedString(uint64_t a1, llvm::hashing::detail::hash_state *a2, uint64_t a3, unint64_t *a4)
{
  v4 = *(a1 + 16);
}

void anonymous namespace::DialectWriter::writeOwnedBlob(uint64_t a1, uint64_t a2, unint64_t a3)
{
  v6 = *(a1 + 16);
}

void anonymous namespace::DialectWriter::writeOwnedBool(_anonymous_namespace_::DialectWriter *this, char a2)
{
  v2 = *(this + 2);
  v3 = a2;
  std::vector<unsigned char>::push_back[abi:nn200100](v2, &v3);
}

uint64_t anonymous namespace::DialectWriter::getDialectVersion(uint64_t a1, unsigned __int8 *a2, const unsigned __int8 *a3)
{
  v6 = *(a1 + 40);
  v7 = llvm::xxh3_64bits(a2, a3, a3);
  Key = llvm::StringMapImpl::FindKey(v6, a2, a3, v7);
  if (Key == -1)
  {
    v9 = *(v6 + 8);
  }

  else
  {
    v9 = Key;
  }

  v10 = *v6 + 8 * v9;
  if (**(a1 + 40) + 8 * *(*(a1 + 40) + 8) == v10)
  {
    return 0;
  }

  else
  {
    return *(*v10 + 8);
  }
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[](uint64_t *a1, void *a2)
{
  v7 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::LookupBucketFor<mlir::Attribute>(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::InsertIntoBucketImpl<mlir::Attribute>(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }

  return v5 + 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::LookupBucketFor<mlir::Attribute>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 16 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 16 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::InsertIntoBucketImpl<mlir::Attribute>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::LookupBucketFor<mlir::Attribute>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

char *llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::moveFromOldBuckets(a1, v4, &v4[2 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = 0;
    v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
    v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
    v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
    v15 = vdupq_n_s64(v13);
    v16 = result + 16;
    do
    {
      v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
      if (v17.i8[0])
      {
        *(v16 - 2) = -4096;
      }

      if (v17.i8[4])
      {
        *v16 = -4096;
      }

      v11 += 2;
      v16 += 4;
    }

    while (v14 != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = 0;
    v8 = v6 + 0xFFFFFFFFFFFFFFFLL;
    v9 = v8 & 0xFFFFFFFFFFFFFFFLL;
    v10 = (v8 & 0xFFFFFFFFFFFFFFFLL) - (v8 & 1) + 2;
    v11 = vdupq_n_s64(v9);
    v12 = (*result + 16);
    do
    {
      v13 = vmovn_s64(vcgeq_u64(v11, vorrq_s8(vdupq_n_s64(v7), xmmword_25D0A0500)));
      if (v13.i8[0])
      {
        *(v12 - 2) = -4096;
      }

      if (v13.i8[4])
      {
        *v12 = -4096;
      }

      v7 += 2;
      v12 += 4;
    }

    while (v10 != v7);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::LookupBucketFor<mlir::Attribute>(v5, a2, &v14);
      *v14 = *a2;
      v14[1] = a2[1];
      ++*(v5 + 8);
    }

    a2 += 2;
  }

  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::operator[](uint64_t *a1, void *a2)
{
  v7 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::LookupBucketFor<mlir::Type>(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::InsertIntoBucketImpl<mlir::Type>(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }

  return v5 + 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::LookupBucketFor<mlir::Type>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 16 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 16 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::InsertIntoBucketImpl<mlir::Type>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::LookupBucketFor<mlir::Type>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

char *llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::moveFromOldBuckets(a1, v4, &v4[2 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = 0;
    v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
    v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
    v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
    v15 = vdupq_n_s64(v13);
    v16 = result + 16;
    do
    {
      v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
      if (v17.i8[0])
      {
        *(v16 - 2) = -4096;
      }

      if (v17.i8[4])
      {
        *v16 = -4096;
      }

      v11 += 2;
      v16 += 4;
    }

    while (v14 != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = 0;
    v8 = v6 + 0xFFFFFFFFFFFFFFFLL;
    v9 = v8 & 0xFFFFFFFFFFFFFFFLL;
    v10 = (v8 & 0xFFFFFFFFFFFFFFFLL) - (v8 & 1) + 2;
    v11 = vdupq_n_s64(v9);
    v12 = (*result + 16);
    do
    {
      v13 = vmovn_s64(vcgeq_u64(v11, vorrq_s8(vdupq_n_s64(v7), xmmword_25D0A0500)));
      if (v13.i8[0])
      {
        *(v12 - 2) = -4096;
      }

      if (v13.i8[4])
      {
        *v12 = -4096;
      }

      v7 += 2;
      v12 += 4;
    }

    while (v10 != v7);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::LookupBucketFor<mlir::Type>(v5, a2, &v14);
      *v14 = *a2;
      v14[1] = a2[1];
      ++*(v5 + 8);
    }

    a2 += 2;
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::LookupBucketFor<mlir::AsmDialectResourceHandle>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 32 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 32 * v6);
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::InsertIntoBucketImpl<mlir::AsmDialectResourceHandle>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::LookupBucketFor<mlir::AsmDialectResourceHandle>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

void *llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((32 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::moveFromOldBuckets(a1, v4, &v4[4 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = &result[4 * v10];
    do
    {
      *result = -4096;
      result[1] = -4096;
      result[2] = 0;
      result += 4;
    }

    while (result != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = *result;
    v8 = *result + 32 * v6;
    do
    {
      *v7 = -4096;
      v7[1] = -4096;
      v7[2] = 0;
      v7 += 4;
    }

    while (v7 != v8);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::LookupBucketFor<mlir::AsmDialectResourceHandle>(v5, a2, &v11);
      v9 = v11;
      v10 = *a2;
      *(v11 + 16) = a2[2];
      *v9 = v10;
      *(v9 + 24) = a2[3];
      ++*(v5 + 8);
    }

    a2 += 4;
  }

  return result;
}

void anonymous namespace::EncodingEmitter::appendResult(void *a1, void *a2)
{
  if (*a2 != a2[1])
  {
    std::vector<std::vector<unsigned char>>::emplace_back<std::vector<unsigned char>>((a1 + 6), a2);
    v4 = a1[7];
    v5 = *(v4 - 24);
    v6 = *(v4 - 16) - v5;
  }
}

void anonymous namespace::EncodingEmitter::appendOwnedResult(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    a1[9] += a3;
    v5 = a1[4];
    v4 = a1[5];
    if (v5 >= v4)
    {
      v7 = a1[3];
      v8 = (v5 - v7) >> 4;
      v9 = v8 + 1;
      if ((v8 + 1) >> 60)
      {
        std::vector<llvm::ArrayRef<unsigned char>>::__throw_length_error[abi:nn200100]();
      }

      v10 = v4 - v7;
      if (v10 >> 3 > v9)
      {
        v9 = v10 >> 3;
      }

      if (v10 >= 0x7FFFFFFFFFFFFFF0)
      {
        v11 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v11 = v9;
      }

      if (v11)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<llvm::ArrayRef<unsigned char>>>(v11);
      }

      v12 = (16 * v8);
      *v12 = a2;
      v12[1] = a3;
      v6 = 16 * v8 + 16;
      v13 = a1[3];
      v14 = a1[4] - v13;
      v15 = (16 * v8 - v14);
      memcpy(v15, v13, v14);
      v16 = a1[3];
      a1[3] = v15;
      a1[4] = v6;
      a1[5] = 0;
      if (v16)
      {
        operator delete(v16);
      }
    }

    else
    {
      *v5 = a2;
      v5[1] = a3;
      v6 = (v5 + 2);
    }

    a1[4] = v6;
  }
}

void std::vector<std::vector<unsigned char>>::emplace_back<std::vector<unsigned char>>(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (v3 >= v4)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
    v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      std::vector<std::vector<unsigned char>>::__throw_length_error[abi:nn200100]();
    }

    v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
    if (2 * v8 > v7)
    {
      v7 = 2 * v8;
    }

    if (v8 >= 0x555555555555555)
    {
      v9 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v9 = v7;
    }

    if (v9)
    {
      if (v9 <= 0xAAAAAAAAAAAAAAALL)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v10 = 24 * v6;
    *v10 = *a2;
    *(v10 + 16) = *(a2 + 16);
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    *a2 = 0;
    v5 = 24 * v6 + 24;
    v11 = *a1;
    v12 = *(a1 + 8) - *a1;
    v13 = 24 * v6 - v12;
    memcpy((v10 - v12), *a1, v12);
    *a1 = v13;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v11)
    {
      operator delete(v11);
    }
  }

  else
  {
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = *a2;
    v3[2] = *(a2 + 16);
    *a2 = 0;
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    v5 = (v3 + 3);
  }

  *(a1 + 8) = v5;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<llvm::ArrayRef<unsigned char>>>(unint64_t a1)
{
  if (!(a1 >> 60))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void anonymous namespace::EncodingEmitter::alignTo(_anonymous_namespace_::EncodingEmitter *this, unsigned int a2)
{
  if (a2 >= 2)
  {
    v13 = v2;
    v14 = v3;
    v6 = *(this + 9) + *(this + 1);
    v7 = v6 != *this;
    v8 = v6 - *this;
    v9 = (v8 - v7) / a2;
    if (v8)
    {
      ++v9;
    }

    for (i = v9 * a2 - v8; i; --i)
    {
      v12 = -53;
      std::vector<unsigned char>::push_back[abi:nn200100](this, &v12);
    }

    v11 = *(this + 20);
    if (v11 <= a2)
    {
      v11 = a2;
    }

    *(this + 20) = v11;
  }
}

void anonymous namespace::RawEmitterOstream::~RawEmitterOstream(_anonymous_namespace_::RawEmitterOstream *this)
{
  llvm::raw_ostream::~raw_ostream(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::Type::hasTrait<mlir::TypeTrait::IsMutable>(uint64_t **a1)
{
  v1 = **a1;
  v2 = (v1 + 72);
  v3 = mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID();
  v4 = *(v1 + 96);
  v5 = *(v4 & 0xFFFFFFFFFFFFFFF8);
  if ((v4 & 2) == 0)
  {
    v2 = *v2;
  }

  return v5(v2, v3);
}

void anonymous namespace::BytecodeWriter::writeOp(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *&v79 = *(a3 + 48);
  v6 = llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::operator[]((a1 + 88), &v79);
  v7 = a2[9];
  v8 = *a2;
  v9 = a2[1];
  v61 = 0;
  LOBYTE(v79) = 0;
  std::vector<unsigned char>::push_back[abi:nn200100](a2, &v79);
  *&v79 = *(a3 + 24);
  v10 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[]((a1 + 40), &v79);
  DiscardableAttrDictionary = mlir::Operation::getDiscardableAttrDictionary(a3);
  if (**(a1 + 984) < 5 || !*(a3 + 47))
  {
    DiscardableAttrDictionary = mlir::Operation::getAttrDictionary(a3);
  }

  if (*(DiscardableAttrDictionary + 16))
  {
    v12 = 1;
    v61 = 1;
    *&v79 = DiscardableAttrDictionary;
    v13 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[]((a1 + 40), &v79);
  }

  else
  {
    v12 = 0;
  }

  if (**(a1 + 984) >= 5)
  {
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    v84 = 1;
    v59 = v12;
    if (HIBYTE(*(a3 + 44)))
    {
      if (*(*(a3 + 48) + 16) != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v76 = 0uLL;
        v77 = 0uLL;
        v75 = 0uLL;
        *__p = 0uLL;
        v74 = 0uLL;
        v78 = 1;
        v17 = *(a1 + 1120);
        v18 = *v17;
        v62[0] = &unk_286EAA310;
        v62[1] = v18;
        v62[2] = __p;
        v63 = *(a1 + 1104);
        v64 = v17 + 2;
        InterfaceFor = mlir::OpInterface<mlir::BytecodeOpInterface,mlir::detail::BytecodeOpInterfaceInterfaceTraits>::getInterfaceFor(a3);
        (*(InterfaceFor + 8))(InterfaceFor, a3, v62);
        *(a1 + 1024) = 0;
        v66 = 2;
        v70 = 0;
        v71 = 1;
        v68 = 0;
        v69 = 0;
        v67 = 0;
        v65 = &unk_286E79DA0;
        v72 = a1 + 1016;
        llvm::raw_ostream::SetUnbuffered(&v65);
        llvm::raw_ostream::~raw_ostream(&v65);
        v65 = &v76;
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v65);
        if (*(&v74 + 1))
        {
          *&v75 = *(&v74 + 1);
          operator delete(*(&v74 + 1));
        }

        v16 = v14 & 0xFFFFFFFFFFFFFF00;
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }

        v15 = 1;
        goto LABEL_22;
      }

      v20 = *(a3 + 16 * ((*(a3 + 44) >> 23) & 1) + 64);
      if (v20)
      {
        v76 = 0uLL;
        v77 = 0uLL;
        v75 = 0uLL;
        *__p = 0uLL;
        v74 = 0uLL;
        v78 = 1;
        v21 = *(a1 + 1104);
        v65 = v20;
        v22 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[](v21, &v65);
        *(a1 + 1024) = 0;
        v66 = 2;
        v70 = 0;
        v71 = 1;
        v68 = 0;
        v69 = 0;
        v67 = 0;
        v65 = &unk_286E79DA0;
        v72 = a1 + 1016;
        llvm::raw_ostream::SetUnbuffered(&v65);
        llvm::raw_ostream::~raw_ostream(&v65);
        v65 = &v76;
        std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v65);
        if (*(&v74 + 1))
        {
          *&v75 = *(&v74 + 1);
          operator delete(*(&v74 + 1));
        }

        v16 = v14 & 0xFFFFFFFFFFFFFF00;
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }

        v15 = 1;
        goto LABEL_22;
      }
    }

    LOBYTE(v14) = 0;
    v15 = 0;
    v16 = 0;
LABEL_22:
    __p[0] = &v82;
    std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](__p);
    if (*(&v80 + 1))
    {
      *&v81 = *(&v80 + 1);
      operator delete(*(&v80 + 1));
    }

    if (v79)
    {
      *(&v79 + 1) = v79;
      operator delete(v79);
    }

    if (v15)
    {
      v61 = v59 | 0x40;
      v23 = v16 | v14;
      v12 = v59 | 0x40;
    }

    else
    {
      v12 = v59;
    }
  }

  v24 = *(a3 + 36);
  if (v24)
  {
    v58 = v9;
    v12 |= 2u;
    v61 = v12;
    v25 = *(a3 + 36);
    if (v25)
    {
      v26 = a3 - 16;
    }

    else
    {
      v26 = 0;
    }

    if (!v25)
    {
      v9 = v58;
      goto LABEL_43;
    }

    v60 = v12;
    v27 = 0;
    v28 = v26;
    while (1)
    {
      v29 = v26;
      if (v27)
      {
        v30 = *(a3 - 8) & 7;
        v31 = v26;
        v32 = v27;
        if (v30 == 6)
        {
          goto LABEL_39;
        }

        v33 = (5 - v30);
        v29 = v28;
        v32 = v27 - v33;
        if (v27 > v33)
        {
          break;
        }
      }

LABEL_40:
      *&v79 = *(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
      v34 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::operator[]((a1 + 112), &v79);
      ++v27;
      v28 -= 16;
      if (v25 == v27)
      {
        v9 = v58;
        v12 = v60;
        goto LABEL_43;
      }
    }

    v31 = v26 - 16 * v33;
LABEL_39:
    v29 = v31 - 24 * v32;
    goto LABEL_40;
  }

LABEL_43:
  if ((*(a3 + 46) & 0x80) != 0)
  {
    v35 = *(a3 + 68);
    if (v35)
    {
      v12 |= 4u;
      v61 = v12;
      if ((*(a3 + 46) & 0x80) != 0)
      {
        v36 = *(a3 + 68);
        if (v36)
        {
          v37 = (*(a3 + 72) + 24);
          do
          {
            v38 = *v37;
            v37 += 4;
            *&v79 = v38;
            v39 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::operator[]((a1 + 896), &v79);
            --v36;
          }

          while (v36);
        }
      }
    }
  }

  v40 = *(a3 + 40);
  if (v40)
  {
    v12 |= 8u;
    v61 = v12;
    v41 = *(a3 + 40);
    if (v41)
    {
      v42 = (((a3 + 16 * ((*(a3 + 44) >> 23) & 1) + ((*(a3 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
      do
      {
        v43 = *v42;
        v42 += 4;
        *&v79 = v43;
        v44 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::operator[]((a1 + 872), &v79);
        --v41;
      }

      while (v41);
    }
  }

  if (**(a1 + 984) >= 3)
  {
    v45 = *(a3 + 36);
    if (v45)
    {
      v46 = (a3 - 16) & 0xFFFFFFFFFFFFFFF9 | 4;
    }

    else
    {
      v46 = 4;
    }

    v12 = v61;
  }

  v47 = v7 + v9 - v8;
  v48 = *(a3 + 44);
  v49 = *&v48 & 0x7FFFFFLL;
  if ((v48 & 0x7FFFFF) == 0)
  {
    *(*a2 + v47 - a2[9]) = v12;
    return;
  }

  *(*a2 + v47 - a2[9]) = v12 | 0x10;
  *&v79 = a3;
  v50 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[]((a1 + 64), &v79);
  if (*(*v50 + 5))
  {
    v51 = *(*v50 + 4);
    if (v51 == 1 && **(a1 + 984) >= 2)
    {
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      v79 = 0u;
      v84 = 1;
      v52 = *(a3 + 44);
      v53 = v52 & 0x7FFFFF;
      if ((v52 & 0x7FFFFF) != 0)
      {
        v54 = (((a3 + 16 * ((v52 >> 23) & 1) + ((v52 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a3 + 40));
      }

      else
      {
        v54 = 0;
        v53 = 0;
      }

      __p[0] = a1;
      __p[1] = &v79;
      __p[0] = &v82;
      std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](__p);
      if (*(&v80 + 1))
      {
        *&v81 = *(&v80 + 1);
        operator delete(*(&v80 + 1));
      }

      if (v79)
      {
        *(&v79 + 1) = v79;
        operator delete(v79);
      }

      return;
    }
  }

  else
  {
  }

  v55 = *(a3 + 44);
  v56 = v55 & 0x7FFFFF;
  if ((v55 & 0x7FFFFF) != 0)
  {
    v57 = (((a3 + 16 * ((v55 >> 23) & 1) + ((v55 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a3 + 40));
  }

  else
  {
    v57 = 0;
    v56 = 0;
  }

  *&v79 = a1;
  *(&v79 + 1) = a2;
}

uint64_t anonymous namespace::BytecodeWriter::writeUseListOrders(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  v74 = *MEMORY[0x277D85DE8];
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v71 = 0;
  v72 = a4;
  v73 = 0;
  if (!a5)
  {
    goto LABEL_75;
  }

  v6 = a5;
  v8 = 0;
  for (i = 0; i != v6; v73 = i)
  {
    v10 = mlir::ValueRange::dereference_iterator(&v72, i);
    v11 = *v10;
    if (!*v10 || !*v11)
    {
      goto LABEL_34;
    }

    v12 = v10;
    v68 = v11[2];
    v13 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[]((a1 + 64), &v68);
    v14 = v11[2];
    if ((*(v14 + 46) & 0x80) != 0)
    {
      v15 = *(v14 + 72);
    }

    else
    {
      v15 = 0;
    }

    v16 = (**v13 << 32) | ((v11 - v15) >> 5);
    LODWORD(__src[0]) = 0;
    __src[1] = v16;
    v68 = v70;
    v69 = 0x300000000;
    llvm::SmallVectorImpl<std::pair<unsigned int,unsigned long long>>::append<std::pair<unsigned int,unsigned long long> const*,void>(&v68, __src, &v68);
    v17 = **v12;
    if (v17)
    {
      v18 = v6;
      v19 = v5 & 0xFFFFFFFF00000000;
      v20 = 1;
      v21 = 1;
      do
      {
        __src[0] = v17[2];
        v22 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[]((a1 + 64), __src);
        v23 = v17[2];
        if ((*(v23 + 46) & 0x80) != 0)
        {
          v24 = *(v23 + 72);
        }

        else
        {
          v24 = 0;
        }

        v25 = (**v22 << 32) | ((v17 - v24) >> 5);
        v20 &= v16 > v25;
        v5 = v21 | v19;
        llvm::SmallVectorTemplateBase<std::pair<unsigned int,unsigned long long>,true>::push_back(&v68, v5, v25);
        ++v21;
        v17 = *v17;
        v16 = v25;
      }

      while (v17);
      v6 = v18;
      if ((v20 & 1) == 0)
      {
        v26 = 126 - 2 * __clz(v69);
        v27 = v69 ? v26 : 0;
        v28 = v68;
        v29 = v69;
        v66 = 0;
        v30 = v65;
        if ((llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>,unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::LookupBucketFor<unsigned int>(v63, v65, v8, &v66) & 1) == 0)
        {
          v31 = v66;
          __src[0] = v66;
          v32 = v64;
          if (4 * v64 + 4 >= 3 * v30)
          {
            v30 *= 2;
          }

          else if (v30 + ~v64 - HIDWORD(v64) > v30 >> 3)
          {
            goto LABEL_21;
          }

          llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::grow(&v63, v30);
          llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>,unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::LookupBucketFor<unsigned int>(v63, v65, v8, __src);
          v32 = v64;
          v31 = __src[0];
LABEL_21:
          LODWORD(v64) = v32 + 1;
          if (*v31 != -1)
          {
            --HIDWORD(v64);
          }

          *v31 = v8;
          v33 = (v31 + 24);
          *(v31 + 8) = v31 + 24;
          *(v31 + 16) = 0xC00000000;
          if (v29 < 0xD)
          {
            if (!v29)
            {
              v38 = 0;
LABEL_30:
              *(v31 + 16) = v38 + v29;
              goto LABEL_31;
            }

            v34 = 0;
          }

          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(v31 + 8, v33, v29, 4);
            v34 = *(v31 + 16);
            v33 = *(v31 + 8);
          }

          v35 = 16 * v29;
          v36 = &v33[4 * v34];
          do
          {
            v37 = *v28;
            v28 += 2;
            *v36 = v37;
            v36 += 4;
            v35 -= 16;
          }

          while (v35);
          v38 = *(v31 + 16);
          goto LABEL_30;
        }
      }
    }

LABEL_31:
    if (v68 != v70)
    {
      free(v68);
    }

    v8 = v71;
    i = v73;
LABEL_34:
    ++v8;
    ++i;
    v71 = v8;
  }

  v39 = v64;
  if (v64)
  {
    *a3 |= 0x20u;
    if (v6 != 1)
    {
    }

    if (v65)
    {
      v40 = 72 * v65;
      v41 = v63;
      while (*v41 >= 0xFFFFFFFE)
      {
        v41 += 18;
        v40 -= 72;
        if (!v40)
        {
          goto LABEL_75;
        }
      }
    }

    else
    {
      v41 = v63;
    }

    v42 = &v63[18 * v65];
    if (v41 != v42)
    {
LABEL_50:
      v43 = *v41;
      v68 = v70;
      v69 = 0xC00000000;
      if (v41[4] && (llvm::SmallVectorImpl<unsigned int>::operator=(&v68, (v41 + 2)), v69))
      {
        v44 = 0;
        v45 = 0;
        v46 = 4 * v69;
        do
        {
          if (v45 != *(v68 + v45))
          {
            ++v44;
          }

          ++v45;
          v46 -= 4;
        }

        while (v46);
        v47 = v69 >> 1;
      }

      else
      {
        v47 = 0;
        v44 = 0;
      }

      if (v6 != 1)
      {
      }

      if (v44 >= v47)
      {
        if (v69)
        {
          v52 = v68;
          v53 = 4 * v69;
          do
          {
            v54 = *v52++;
            v53 -= 4;
          }

          while (v53);
        }
      }

      else
      {
        if (v69)
        {
          v48 = 0;
          v49 = v68;
          v50 = 4 * v69;
          do
          {
            v51 = v49[v48];
            if (v48 != v51)
            {
            }

            ++v48;
            v50 -= 4;
          }

          while (v50);
        }
      }

      if (v68 != v70)
      {
        free(v68);
      }

      while (1)
      {
        v41 += 18;
        if (v41 == v42)
        {
          break;
        }

        if (*v41 < 0xFFFFFFFE)
        {
          if (v41 != v42)
          {
            goto LABEL_50;
          }

          break;
        }
      }
    }
  }

LABEL_75:
  v55 = v63;
  if (v65)
  {
    v56 = 72 * v65;
    v57 = v63 + 6;
    do
    {
      if (*(v57 - 6) <= 0xFFFFFFFD)
      {
        v58 = *(v57 - 2);
        if (v57 != v58)
        {
          free(v58);
        }
      }

      v57 += 9;
      v56 -= 72;
    }

    while (v56);
  }

  result = MEMORY[0x25F891030](v55, 8);
  v60 = *MEMORY[0x277D85DE8];
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::operator[](uint64_t *a1, void *a2)
{
  v7 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::LookupBucketFor<mlir::OperationName>(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::InsertIntoBucketImpl<mlir::OperationName>(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }

  return v5 + 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::LookupBucketFor<mlir::OperationName>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 16 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 16 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::InsertIntoBucketImpl<mlir::OperationName>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::LookupBucketFor<mlir::OperationName>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

char *llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::moveFromOldBuckets(a1, v4, &v4[2 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = 0;
    v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
    v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
    v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
    v15 = vdupq_n_s64(v13);
    v16 = result + 16;
    do
    {
      v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
      if (v17.i8[0])
      {
        *(v16 - 2) = -4096;
      }

      if (v17.i8[4])
      {
        *v16 = -4096;
      }

      v11 += 2;
      v16 += 4;
    }

    while (v14 != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = 0;
    v8 = v6 + 0xFFFFFFFFFFFFFFFLL;
    v9 = v8 & 0xFFFFFFFFFFFFFFFLL;
    v10 = (v8 & 0xFFFFFFFFFFFFFFFLL) - (v8 & 1) + 2;
    v11 = vdupq_n_s64(v9);
    v12 = (*result + 16);
    do
    {
      v13 = vmovn_s64(vcgeq_u64(v11, vorrq_s8(vdupq_n_s64(v7), xmmword_25D0A0500)));
      if (v13.i8[0])
      {
        *(v12 - 2) = -4096;
      }

      if (v13.i8[4])
      {
        *v12 = -4096;
      }

      v7 += 2;
      v12 += 4;
    }

    while (v10 != v7);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::LookupBucketFor<mlir::OperationName>(v5, a2, &v14);
      *v14 = *a2;
      v14[1] = a2[1];
      ++*(v5 + 8);
    }

    a2 += 2;
  }

  return result;
}

unint64_t anonymous namespace::anonymous namespace::PropertiesSectionBuilder::emit(uint64_t a1, char *a2, unint64_t a3)
{
  v3 = a3;
  v63[5] = *MEMORY[0x277D85DE8];
  v61 = v63;
  v62 = xmmword_25D0A0550;
  memset(v58, 0, sizeof(v58));
  *__p = 0u;
  v57 = 0u;
  *v55 = 0u;
  v59 = 1;
  v48 = 2;
  v52 = 0;
  v53 = 1;
  v50 = 0;
  v51 = 0;
  v49 = 0;
  v47 = &unk_286E79DA0;
  v54 = &v61;
  llvm::raw_ostream::SetUnbuffered(&v47);
  llvm::raw_ostream::~raw_ostream(&v47);
  v47 = v58;
  std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](&v47);
  if (__p[1])
  {
    *&v57 = __p[1];
    operator delete(__p[1]);
  }

  if (v55[0])
  {
    v55[1] = v55[0];
    operator delete(v55[0]);
  }

  v7 = *a1;
  v6 = *(a1 + 8);
  v8 = v6 - *a1;
  v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
  v10 = *(a1 + 16);
  if (v6 >= v10)
  {
    v12 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      std::vector<std::vector<char>>::__throw_length_error[abi:nn200100]();
    }

    v13 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v7) >> 3);
    if (2 * v13 > v12)
    {
      v12 = 2 * v13;
    }

    if (v13 >= 0x555555555555555)
    {
      v14 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v14 = v12;
    }

    if (v14)
    {
      if (v14 <= 0xAAAAAAAAAAAAAAALL)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v15 = (8 * (v8 >> 3));
    *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
    v11 = (v15 + 3);
    v16 = v15 - v8;
    memcpy(v15 - v8, v7, v8);
    *a1 = v16;
    *(a1 + 8) = v11;
    *(a1 + 16) = 0;
    if (v7)
    {
      operator delete(v7);
    }
  }

  else
  {
    *v6 = 0;
    v6[1] = 0;
    v11 = (v6 + 3);
    v6[2] = 0;
  }

  *(a1 + 8) = v11;
  v17 = *(v11 - 3);
  if (*(v11 - 1) - v17 < (v62 + v3))
  {
    if (((v62 + v3) & 0x8000000000000000) == 0)
    {
      v18 = *(v11 - 2) - v17;
      operator new();
    }

LABEL_65:
    std::vector<char>::__throw_length_error[abi:nn200100]();
  }

  v19 = *(v11 - 2);
  v20 = v62;
  if (v62 >= 1)
  {
    v21 = *(v11 - 1);
    if (v21 - v19 >= v62)
    {
      memmove(v19, v61, v62);
      v19 += v20;
      *(v11 - 2) = v19;
    }

    else
    {
      v22 = (v19 - v17);
      v23 = v19 - v17 + v62;
      if (v23 < 0)
      {
        goto LABEL_65;
      }

      v24 = v21 - v17;
      if (2 * v24 > v23)
      {
        v23 = 2 * v24;
      }

      if (v24 >= 0x3FFFFFFFFFFFFFFFLL)
      {
        v25 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v25 = v23;
      }

      if (v25)
      {
        operator new();
      }

      memcpy(v22, v61, v62);
      v26 = &v22[v20];
      *(v11 - 2) = v19;
      memcpy(0, v17, v19 - v17);
      *(v11 - 3) = 0;
      *(v11 - 2) = v26;
      *(v11 - 1) = 0;
      if (v17)
      {
        operator delete(v17);
        v19 = *(v11 - 2);
      }

      else
      {
        v19 = v26;
      }
    }
  }

  if (v3 >= 1)
  {
    v27 = *(v11 - 1);
    if (v27 - v19 >= v3)
    {
      v33 = &v19[v3];
      do
      {
        v34 = *a2++;
        *v19++ = v34;
        --v3;
      }

      while (v3);
      v19 = v33;
      *(v11 - 2) = v33;
    }

    else
    {
      v28 = *(v11 - 3);
      v29 = (v19 - v28);
      v30 = v19 - v28 + v3;
      if (v30 < 0)
      {
        goto LABEL_65;
      }

      v31 = v27 - v28;
      if (2 * v31 > v30)
      {
        v30 = 2 * v31;
      }

      if (v31 >= 0x3FFFFFFFFFFFFFFFLL)
      {
        v32 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v32 = v30;
      }

      if (v32)
      {
        operator new();
      }

      memcpy(v29, a2, v3);
      v35 = &v29[v3];
      *(v11 - 2) = v19;
      memcpy(0, v28, v19 - v28);
      *(v11 - 3) = 0;
      *(v11 - 2) = v35;
      *(v11 - 1) = 0;
      if (v28)
      {
        operator delete(v28);
        v19 = *(v11 - 2);
      }

      else
      {
        v19 = v35;
      }
    }
  }

  v55[0] = *(v11 - 3);
  v55[1] = (v19 - v55[0]);
  __p[0] = v9;
  v36 = *(a1 + 88);
  v60 = 0;
  v37 = llvm::DenseMapBase<llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>,llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::LookupBucketFor<llvm::ArrayRef<char>>(v36, *(a1 + 104), v55, &v60);
  v38 = v60;
  if (v37)
  {
    v39 = *(a1 + 8);
    v42 = *(v39 - 24);
    v41 = v39 - 24;
    v40 = v42;
    if (v42)
    {
      *(*(a1 + 8) - 16) = v40;
      operator delete(v40);
    }

    *(a1 + 8) = v41;
    v9 = v38[2];
    goto LABEL_60;
  }

  v47 = v60;
  v43 = *(a1 + 96);
  v44 = *(a1 + 104);
  if (4 * v43 + 4 >= 3 * v44)
  {
    v44 *= 2;
    goto LABEL_64;
  }

  if (v44 + ~v43 - *(a1 + 100) <= v44 >> 3)
  {
LABEL_64:
    llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::grow(a1 + 88, v44);
    llvm::DenseMapBase<llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>,llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::LookupBucketFor<llvm::ArrayRef<char>>(*(a1 + 88), *(a1 + 104), v55, &v47);
    v43 = *(a1 + 96);
    v38 = v47;
  }

  *(a1 + 96) = v43 + 1;
  if (*v38 != -1)
  {
    --*(a1 + 100);
  }

  *v38 = *v55;
  v38[2] = v9;
LABEL_60:
  if (v61 != v63)
  {
    free(v61);
  }

  v45 = *MEMORY[0x277D85DE8];
  return v9;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>,llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::LookupBucketFor<llvm::ArrayRef<char>>(uint64_t a1, int a2, uint64_t a3, unint64_t *a4)
{
  if (!a2)
  {
    v13 = 0;
    result = 0;
    goto LABEL_17;
  }

  v7 = 0;
  v8 = a2 - 1;
  v9 = (a2 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(*a3, *a3 + *(a3 + 8), a3, a4);
  v10 = *a3;
  v11 = *(a3 + 8);
  for (i = 1; ; ++i)
  {
    v13 = a1 + 24 * v9;
    v14 = *v13;
    if (*v13 == -2)
    {
      if (v10 == -2)
      {
        goto LABEL_15;
      }

      goto LABEL_9;
    }

    if (v14 == -1)
    {
      break;
    }

    if (v11 == *(v13 + 8) && !memcmp(v10, *v13, v11))
    {
LABEL_15:
      result = 1;
      goto LABEL_17;
    }

LABEL_9:
    if (v7)
    {
      v15 = 0;
    }

    else
    {
      v15 = v14 + 2 == 0;
    }

    if (v15)
    {
      v7 = a1 + 24 * v9;
    }

    v16 = v9 + i;
    v9 = v16 & v8;
  }

  if (v7)
  {
    v18 = v7;
  }

  else
  {
    v18 = a1 + 24 * v9;
  }

  if (v10 == -1)
  {
    result = 1;
  }

  else
  {
    v13 = v18;
    result = 0;
  }

LABEL_17:
  *a4 = v13;
  return result;
}

_OWORD *llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((24 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 24 * v10;
      do
      {
        *result = xmmword_25D0A05E0;
        result = (result + 24);
        v11 -= 24;
      }

      while (v11);
    }

    if (v3)
    {
      v12 = 24 * v3;
      v13 = v4;
      do
      {
        if (*v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v17 = 0;
          llvm::DenseMapBase<llvm::DenseMap<llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>,llvm::ArrayRef<char>,long long,llvm::DenseMapInfo<llvm::ArrayRef<char>,void>,llvm::detail::DenseMapPair<llvm::ArrayRef<char>,long long>>::LookupBucketFor<llvm::ArrayRef<char>>(*a1, *(a1 + 16), v13, &v17);
          v14 = v17;
          *v17 = *v13;
          *(v14 + 2) = *(v13 + 16);
          ++*(a1 + 8);
        }

        v13 += 24;
        v12 -= 24;
      }

      while (v12);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v15 = *(a1 + 16);
  if (v15)
  {
    v16 = 24 * v15;
    do
    {
      *result = xmmword_25D0A05E0;
      result = (result + 24);
      v16 -= 24;
    }

    while (v16);
  }

  return result;
}

uint64_t mlir::OpInterface<mlir::BytecodeOpInterface,mlir::detail::BytecodeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  v1 = *(a1 + 48);
  if (*(v1 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11 = *(*(v1 + 8) + 32);
    if (!v11)
    {
      return 0;
    }

    v7 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();
    v8 = *(*v11 + 104);
    v9 = v11;
    v10 = v1;
  }

  else
  {
    v3 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();
    result = mlir::detail::InterfaceMap::lookup(v1 + 32, v3);
    if (result)
    {
      return result;
    }

    v5 = *(v1 + 24);
    v6 = *(a1 + 48);
    v7 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();
    v8 = *(*v5 + 104);
    v9 = v5;
    v10 = v6;
  }

  return v8(v9, v7, v10);
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[](uint64_t *a1, void *a2)
{
  v7 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::LookupBucketFor<mlir::Operation *>(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::InsertIntoBucketImpl<mlir::Operation *>(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }

  return v5 + 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::LookupBucketFor<mlir::Operation *>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 16 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 16 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::InsertIntoBucketImpl<mlir::Operation *>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::LookupBucketFor<mlir::Operation *>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

char *llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::moveFromOldBuckets(a1, v4, &v4[2 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = 0;
    v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
    v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
    v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
    v15 = vdupq_n_s64(v13);
    v16 = result + 16;
    do
    {
      v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
      if (v17.i8[0])
      {
        *(v16 - 2) = -4096;
      }

      if (v17.i8[4])
      {
        *v16 = -4096;
      }

      v11 += 2;
      v16 += 4;
    }

    while (v14 != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = 0;
    v8 = v6 + 0xFFFFFFFFFFFFFFFLL;
    v9 = v8 & 0xFFFFFFFFFFFFFFFLL;
    v10 = (v8 & 0xFFFFFFFFFFFFFFFLL) - (v8 & 1) + 2;
    v11 = vdupq_n_s64(v9);
    v12 = (*result + 16);
    do
    {
      v13 = vmovn_s64(vcgeq_u64(v11, vorrq_s8(vdupq_n_s64(v7), xmmword_25D0A0500)));
      if (v13.i8[0])
      {
        *(v12 - 2) = -4096;
      }

      if (v13.i8[4])
      {
        *v12 = -4096;
      }

      v7 += 2;
      v12 += 4;
    }

    while (v10 != v7);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::LookupBucketFor<mlir::Operation *>(v5, a2, &v14);
      *v14 = *a2;
      v14[1] = a2[1];
      ++*(v5 + 8);
    }

    a2 += 2;
  }

  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace::BytecodeWriter::writeUseListOrders(anonymous namespace::EncodingEmitter &,unsigned char &,mlir::ValueRange)::$_2 &,std::pair<unsigned int,unsigned long long> *,false>(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  v7 = result;
LABEL_2:
  v8 = v7;
  while (1)
  {
    v7 = v8;
    v9 = (a2 - v8) >> 4;
    if (v9 <= 2)
    {
      if (v9 < 2)
      {
        return result;
      }

      if (v9 == 2)
      {
        v82 = *(a2 - 8);
        v83 = *(v8 + 8);
        if (v82 > v83)
        {
          v84 = *v8;
          *v8 = *(a2 - 16);
          *(a2 - 16) = v84;
          *(v8 + 8) = v82;
          *(a2 - 8) = v83;
        }

        return result;
      }

      goto LABEL_10;
    }

    if (v9 == 3)
    {
      break;
    }

    if (v9 == 4)
    {
      v89 = (v8 + 24);
      v90 = *(v8 + 24);
      v92 = (v8 + 8);
      v91 = *(v8 + 8);
      v93 = *(v8 + 40);
      if (v90 <= v91)
      {
        if (v93 > v90)
        {
          v140 = *(v8 + 16);
          v141 = *(v8 + 32);
          *(v8 + 16) = v141;
          *(v8 + 32) = v140;
          *(v8 + 24) = v93;
          *(v8 + 40) = v90;
          if (v93 > v91)
          {
            v142 = *v8;
            *v8 = v141;
            *(v8 + 16) = v142;
            goto LABEL_187;
          }

LABEL_188:
          v93 = v90;
        }
      }

      else
      {
        v94 = *v8;
        if (v93 > v90)
        {
          *v8 = *(v8 + 32);
          *(v8 + 32) = v94;
          goto LABEL_186;
        }

        *v8 = *(v8 + 16);
        *(v8 + 16) = v94;
        *(v8 + 8) = v90;
        *(v8 + 24) = v91;
        if (v93 > v91)
        {
          *(v8 + 16) = *(v8 + 32);
          *(v8 + 32) = v94;
          v92 = (v8 + 24);
LABEL_186:
          v89 = (v8 + 40);
          v90 = v91;
LABEL_187:
          *v92 = v93;
          *v89 = v91;
          goto LABEL_188;
        }
      }

      v151 = *(a2 - 8);
      if (v151 > v93)
      {
        v152 = *(v8 + 32);
        *(v8 + 32) = *(a2 - 16);
        *(a2 - 16) = v152;
        *(v8 + 40) = v151;
        *(a2 - 8) = v93;
        v153 = *(v8 + 40);
        v154 = *(v8 + 24);
        if (v153 > v154)
        {
          v155 = *(v8 + 16);
          v156 = *(v8 + 32);
          *(v8 + 16) = v156;
          *(v8 + 32) = v155;
          *(v8 + 24) = v153;
          *(v8 + 40) = v154;
          v157 = *(v8 + 8);
          if (v153 > v157)
          {
            v158 = *v8;
            *v8 = v156;
            *(v8 + 16) = v158;
            *(v8 + 8) = v153;
            *(v8 + 24) = v157;
          }
        }
      }

      return result;
    }

    if (v9 == 5)
    {
    }

LABEL_10:
    if (v9 <= 23)
    {
      v95 = (v8 + 16);
      v97 = v8 == a2 || v95 == a2;
      if (a4)
      {
        if (!v97)
        {
          v98 = 0;
          v99 = v8;
          do
          {
            v100 = *(v99 + 3);
            v101 = *(v99 + 1);
            v99 = v95;
            if (v100 > v101)
            {
              v102 = *v95;
              v103 = v98;
              while (1)
              {
                v104 = v8 + v103;
                *(v104 + 16) = *(v8 + v103);
                *(v104 + 24) = *(v8 + v103 + 8);
                if (!v103)
                {
                  break;
                }

                v103 -= 16;
                if (v100 <= *(v104 - 8))
                {
                  v105 = v8 + v103 + 16;
                  goto LABEL_131;
                }
              }

              v105 = v8;
LABEL_131:
              *v105 = v102;
              *(v105 + 8) = v100;
            }

            v95 = v99 + 4;
            v98 += 16;
          }

          while (v99 + 4 != a2);
        }
      }

      else if (!v97)
      {
        v143 = (v8 + 24);
        do
        {
          v144 = *(v7 + 24);
          v145 = *(v7 + 8);
          v7 = v95;
          if (v144 > v145)
          {
            v146 = *v95;
            v147 = v143;
            do
            {
              v148 = v147;
              *(v147 - 2) = *(v147 - 6);
              v149 = *(v147 - 2);
              v147 -= 2;
              *v148 = v149;
            }

            while (v144 > *(v148 - 4));
            *(v147 - 2) = v146;
            *v147 = v144;
          }

          v95 = (v7 + 16);
          v143 += 2;
        }

        while (v7 + 16 != a2);
      }

      return result;
    }

    if (!a3)
    {
      if (v8 != a2)
      {
        v106 = (v9 - 2) >> 1;
        v107 = v106;
        do
        {
          v108 = v107;
          if (v106 >= v107)
          {
            v109 = (2 * v107) | 1;
            v110 = v8 + 16 * v109;
            if (2 * v108 + 2 < v9)
            {
              v111 = *(v110 + 8) > *(v110 + 24);
              v110 += 16 * v111;
              if (v111)
              {
                v109 = 2 * v108 + 2;
              }
            }

            v112 = v8 + 16 * v108;
            v113 = *(v110 + 8);
            v114 = *(v112 + 8);
            if (v113 <= v114)
            {
              v115 = *v112;
              do
              {
                v116 = v112;
                v112 = v110;
                *v116 = *v110;
                *(v116 + 8) = v113;
                if (v106 < v109)
                {
                  break;
                }

                v117 = (2 * v109) | 1;
                v110 = v8 + 16 * v117;
                v118 = 2 * v109 + 2;
                if (v118 < v9)
                {
                  result = *(v110 + 24);
                  v111 = *(v110 + 8) > result;
                  v110 += 16 * v111;
                  if (v111)
                  {
                    v117 = v118;
                  }
                }

                v113 = *(v110 + 8);
                v109 = v117;
              }

              while (v113 <= v114);
              *v112 = v115;
              *(v112 + 8) = v114;
            }
          }

          v107 = v108 - 1;
        }

        while (v108);
        do
        {
          v119 = 0;
          v120 = *v8;
          v121 = *(v8 + 8);
          v122 = v8;
          do
          {
            v123 = v122 + 16 * v119;
            v124 = v123 + 16;
            v125 = (2 * v119) | 1;
            v119 = 2 * v119 + 2;
            if (v119 >= v9)
            {
              v119 = v125;
            }

            else
            {
              v126 = *(v123 + 24);
              result = *(v123 + 40);
              v127 = v123 + 32;
              if (v126 <= result)
              {
                v119 = v125;
              }

              else
              {
                v124 = v127;
              }
            }

            *v122 = *v124;
            *(v122 + 8) = *(v124 + 8);
            v122 = v124;
          }

          while (v119 <= ((v9 - 2) >> 1));
          if (v124 == a2 - 16)
          {
            *v124 = v120;
            *(v124 + 8) = v121;
          }

          else
          {
            *v124 = *(a2 - 16);
            *(v124 + 8) = *(a2 - 8);
            *(a2 - 16) = v120;
            *(a2 - 8) = v121;
            v128 = (v124 - v8 + 16) >> 4;
            v111 = v128 < 2;
            v129 = v128 - 2;
            if (!v111)
            {
              v130 = v129 >> 1;
              v131 = v8 + 16 * (v129 >> 1);
              v132 = *(v131 + 8);
              v133 = *(v124 + 8);
              if (v132 > v133)
              {
                v134 = *v124;
                do
                {
                  v135 = v124;
                  v124 = v131;
                  *v135 = *v131;
                  *(v135 + 8) = v132;
                  if (!v130)
                  {
                    break;
                  }

                  v130 = (v130 - 1) >> 1;
                  v131 = v8 + 16 * v130;
                  v132 = *(v131 + 8);
                }

                while (v132 > v133);
                *v124 = v134;
                *(v124 + 8) = v133;
              }
            }
          }

          a2 -= 16;
          v111 = v9-- <= 2;
        }

        while (!v111);
      }

      return result;
    }

    v10 = v8 + 16 * (v9 >> 1);
    v11 = *(a2 - 8);
    if (v9 >= 0x81)
    {
      v12 = *(v10 + 8);
      v13 = *(v8 + 8);
      if (v12 <= v13)
      {
        if (v11 > v12)
        {
          v18 = *v10;
          *v10 = *(a2 - 16);
          *(a2 - 16) = v18;
          *(v10 + 8) = v11;
          *(a2 - 8) = v12;
          v19 = *(v10 + 8);
          v20 = *(v8 + 8);
          if (v19 > v20)
          {
            v21 = *v8;
            *v8 = *v10;
            *v10 = v21;
            *(v8 + 8) = v19;
            *(v10 + 8) = v20;
          }
        }
      }

      else
      {
        v14 = *v8;
        if (v11 > v12)
        {
          *v8 = *(a2 - 16);
          *(a2 - 16) = v14;
          *(v8 + 8) = v11;
          goto LABEL_27;
        }

        *v8 = *v10;
        *v10 = v14;
        *(v8 + 8) = v12;
        *(v10 + 8) = v13;
        v26 = *(a2 - 8);
        if (v26 > v13)
        {
          *v10 = *(a2 - 16);
          *(a2 - 16) = v14;
          *(v10 + 8) = v26;
LABEL_27:
          *(a2 - 8) = v13;
        }
      }

      v27 = (v10 - 16);
      v28 = *(v10 - 8);
      v29 = *(v8 + 24);
      v30 = *(a2 - 24);
      if (v28 <= v29)
      {
        if (v30 > v28)
        {
          v32 = *v27;
          *v27 = *(a2 - 32);
          *(a2 - 32) = v32;
          *(v10 - 8) = v30;
          *(a2 - 24) = v28;
          v33 = *(v10 - 8);
          v34 = *(v8 + 24);
          if (v33 > v34)
          {
            v35 = *(v8 + 16);
            *(v8 + 16) = *v27;
            *v27 = v35;
            *(v8 + 24) = v33;
            *(v10 - 8) = v34;
          }
        }
      }

      else
      {
        v31 = *(v8 + 16);
        if (v30 > v28)
        {
          *(v8 + 16) = *(a2 - 32);
          *(a2 - 32) = v31;
          *(v8 + 24) = v30;
          goto LABEL_39;
        }

        *(v8 + 16) = *v27;
        *v27 = v31;
        *(v8 + 24) = v28;
        *(v10 - 8) = v29;
        v37 = *(a2 - 24);
        if (v37 > v29)
        {
          *v27 = *(a2 - 32);
          *(a2 - 32) = v31;
          *(v10 - 8) = v37;
LABEL_39:
          *(a2 - 24) = v29;
        }
      }

      v38 = *(v10 + 24);
      v39 = *(v8 + 40);
      v40 = *(a2 - 40);
      if (v38 <= v39)
      {
        if (v40 > v38)
        {
          v42 = *(v10 + 16);
          *(v10 + 16) = *(a2 - 48);
          *(a2 - 48) = v42;
          *(v10 + 24) = v40;
          *(a2 - 40) = v38;
          v43 = *(v10 + 24);
          v44 = *(v8 + 40);
          if (v43 > v44)
          {
            v45 = *(v8 + 32);
            *(v8 + 32) = *(v10 + 16);
            *(v10 + 16) = v45;
            *(v8 + 40) = v43;
            *(v10 + 24) = v44;
          }
        }
      }

      else
      {
        v41 = *(v8 + 32);
        if (v40 > v38)
        {
          *(v8 + 32) = *(a2 - 48);
          *(a2 - 48) = v41;
          *(v8 + 40) = v40;
          goto LABEL_48;
        }

        *(v8 + 32) = *(v10 + 16);
        *(v10 + 16) = v41;
        *(v8 + 40) = v38;
        *(v10 + 24) = v39;
        v46 = *(a2 - 40);
        if (v46 > v39)
        {
          *(v10 + 16) = *(a2 - 48);
          *(a2 - 48) = v41;
          *(v10 + 24) = v46;
LABEL_48:
          *(a2 - 40) = v39;
        }
      }

      v47 = *(v10 + 8);
      v48 = *(v10 - 8);
      v49 = *(v10 + 24);
      if (v47 <= v48)
      {
        v50 = *v10;
        if (v49 <= v47)
        {
LABEL_55:
          v48 = v47;
        }

        else
        {
          v51 = *(v10 + 16);
          *v10 = v51;
          *(v10 + 16) = v50;
          *(v10 + 8) = v49;
          *(v10 + 24) = v47;
          if (v49 <= v48)
          {
            v48 = v49;
            v50 = v51;
          }

          else
          {
            v50 = *v27;
            *v27 = v51;
            *v10 = v50;
            *(v10 - 8) = v49;
            *(v10 + 8) = v48;
          }
        }
      }

      else
      {
        v50 = *v27;
        if (v49 > v47)
        {
          *v27 = *(v10 + 16);
          *(v10 + 16) = v50;
          *(v10 - 8) = v49;
          *(v10 + 24) = v48;
          v50 = *v10;
          goto LABEL_55;
        }

        *v27 = *v10;
        *v10 = v50;
        *(v10 - 8) = v47;
        *(v10 + 8) = v48;
        if (v49 > v48)
        {
          v70 = *(v10 + 16);
          *v10 = v70;
          *(v10 + 16) = v50;
          *(v10 + 8) = v49;
          *(v10 + 24) = v48;
          v48 = v49;
          v50 = v70;
        }
      }

      v52 = *v8;
      *v8 = v50;
      *v10 = v52;
      v53 = *(v8 + 8);
      *(v8 + 8) = v48;
      *(v10 + 8) = v53;
      goto LABEL_57;
    }

    v15 = *(v8 + 8);
    v16 = *(v10 + 8);
    if (v15 <= v16)
    {
      if (v11 > v15)
      {
        v22 = *v8;
        *v8 = *(a2 - 16);
        *(a2 - 16) = v22;
        *(v8 + 8) = v11;
        *(a2 - 8) = v15;
        v23 = *(v8 + 8);
        v24 = *(v10 + 8);
        if (v23 > v24)
        {
          v25 = *v10;
          *v10 = *v8;
          *v8 = v25;
          *(v10 + 8) = v23;
          *(v8 + 8) = v24;
        }
      }

      goto LABEL_57;
    }

    v17 = *v10;
    if (v11 > v15)
    {
      *v10 = *(a2 - 16);
      *(a2 - 16) = v17;
      *(v10 + 8) = v11;
LABEL_36:
      *(a2 - 8) = v16;
      goto LABEL_57;
    }

    *v10 = *v8;
    *v8 = v17;
    *(v10 + 8) = v15;
    *(v8 + 8) = v16;
    v36 = *(a2 - 8);
    if (v36 > v16)
    {
      *v8 = *(a2 - 16);
      *(a2 - 16) = v17;
      *(v8 + 8) = v36;
      goto LABEL_36;
    }

LABEL_57:
    --a3;
    v54 = *v8;
    if (a4)
    {
      v55 = *(v8 + 8);
LABEL_60:
      v56 = 0;
      do
      {
        v57 = *(v8 + v56 + 24);
        v56 += 16;
      }

      while (v57 > v55);
      v58 = v8 + v56;
      v59 = a2;
      if (v56 == 16)
      {
        v62 = a2;
        while (v58 < v62)
        {
          v60 = v62 - 16;
          v63 = *(v62 - 8);
          v62 -= 16;
          if (v63 > v55)
          {
            goto LABEL_70;
          }
        }

        v60 = v62;
      }

      else
      {
        do
        {
          v60 = v59 - 16;
          v61 = *(v59 - 8);
          v59 -= 16;
        }

        while (v61 <= v55);
      }

LABEL_70:
      v8 = v58;
      if (v58 < v60)
      {
        v64 = v60;
        do
        {
          v65 = *v8;
          *v8 = *v64;
          *v64 = v65;
          v66 = *(v8 + 8);
          *(v8 + 8) = *(v64 + 8);
          *(v64 + 8) = v66;
          do
          {
            v67 = *(v8 + 24);
            v8 += 16;
          }

          while (v67 > v55);
          do
          {
            v68 = *(v64 - 8);
            v64 -= 16;
          }

          while (v68 <= v55);
        }

        while (v8 < v64);
      }

      if (v8 - 16 != v7)
      {
        *v7 = *(v8 - 16);
        *(v7 + 8) = *(v8 - 8);
      }

      *(v8 - 16) = v54;
      *(v8 - 8) = v55;
      if (v58 < v60)
      {
        goto LABEL_81;
      }

      if (result)
      {
        a2 = v8 - 16;
        if (!v69)
        {
          goto LABEL_2;
        }

        return result;
      }

      if (!v69)
      {
LABEL_81:
        a4 = 0;
      }
    }

    else
    {
      v55 = *(v8 + 8);
      if (*(v8 - 8) > v55)
      {
        goto LABEL_60;
      }

      if (v55 <= *(a2 - 8))
      {
        v73 = v8 + 16;
        do
        {
          v8 = v73;
          if (v73 >= a2)
          {
            break;
          }

          v74 = *(v73 + 8);
          v73 += 16;
        }

        while (v55 <= v74);
      }

      else
      {
        v71 = v8;
        do
        {
          v8 = v71 + 16;
          v72 = *(v71 + 24);
          v71 += 16;
        }

        while (v55 <= v72);
      }

      v75 = a2;
      if (v8 < a2)
      {
        v76 = a2;
        do
        {
          v75 = v76 - 16;
          v77 = *(v76 - 8);
          v76 -= 16;
        }

        while (v55 > v77);
      }

      while (v8 < v75)
      {
        v78 = *v8;
        *v8 = *v75;
        *v75 = v78;
        v79 = *(v8 + 8);
        *(v8 + 8) = *(v75 + 8);
        *(v75 + 8) = v79;
        do
        {
          v80 = *(v8 + 24);
          v8 += 16;
        }

        while (v55 <= v80);
        do
        {
          v81 = *(v75 - 8);
          v75 -= 16;
        }

        while (v55 > v81);
      }

      if (v8 - 16 != v7)
      {
        *v7 = *(v8 - 16);
        *(v7 + 8) = *(v8 - 8);
      }

      a4 = 0;
      *(v8 - 16) = v54;
      *(v8 - 8) = v55;
    }
  }

  v85 = *(v8 + 24);
  v86 = *(v8 + 8);
  v87 = *(a2 - 8);
  if (v85 <= v86)
  {
    if (v87 > v85)
    {
      v136 = *(v8 + 16);
      *(v8 + 16) = *(a2 - 16);
      *(a2 - 16) = v136;
      *(v8 + 24) = v87;
      *(a2 - 8) = v85;
      v137 = *(v8 + 24);
      v138 = *(v8 + 8);
      if (v137 > v138)
      {
        v139 = *v8;
        *v8 = *(v8 + 16);
        *(v8 + 16) = v139;
        *(v8 + 8) = v137;
        *(v8 + 24) = v138;
      }
    }
  }

  else
  {
    v88 = *v8;
    if (v87 <= v85)
    {
      *v8 = *(v8 + 16);
      *(v8 + 16) = v88;
      *(v8 + 8) = v85;
      *(v8 + 24) = v86;
      v150 = *(a2 - 8);
      if (v150 <= v86)
      {
        return result;
      }

      *(v8 + 16) = *(a2 - 16);
      *(a2 - 16) = v88;
      *(v8 + 24) = v150;
    }

    else
    {
      *v8 = *(a2 - 16);
      *(a2 - 16) = v88;
      *(v8 + 8) = v87;
    }

    *(a2 - 8) = v86;
  }

  return result;
}

int *std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::BytecodeWriter::writeUseListOrders(anonymous namespace::EncodingEmitter &,unsigned char &,mlir::ValueRange)::$_2 &,std::pair<unsigned int,unsigned long long> *,0>(int *result, int *a2, int *a3, int *a4, int *a5)
{
  v5 = *(a2 + 1);
  v6 = *(result + 1);
  v7 = *(a3 + 1);
  if (v5 <= v6)
  {
    if (v7 <= v5)
    {
      v5 = *(a3 + 1);
    }

    else
    {
      v9 = *a2;
      *a2 = *a3;
      *a3 = v9;
      *(a2 + 1) = v7;
      *(a3 + 1) = v5;
      v10 = *(a2 + 1);
      v11 = *(result + 1);
      if (v10 > v11)
      {
        v12 = *result;
        *result = *a2;
        *a2 = v12;
        *(result + 1) = v10;
        *(a2 + 1) = v11;
        v5 = *(a3 + 1);
      }
    }
  }

  else
  {
    v8 = *result;
    if (v7 > v5)
    {
      *result = *a3;
      *a3 = v8;
      *(result + 1) = v7;
LABEL_9:
      *(a3 + 1) = v6;
      v5 = v6;
      goto LABEL_11;
    }

    *result = *a2;
    *a2 = v8;
    *(result + 1) = v5;
    *(a2 + 1) = v6;
    v5 = *(a3 + 1);
    if (v5 > v6)
    {
      *a2 = *a3;
      *a3 = v8;
      *(a2 + 1) = v5;
      goto LABEL_9;
    }
  }

LABEL_11:
  v13 = *(a4 + 1);
  if (v13 > v5)
  {
    v14 = *a3;
    *a3 = *a4;
    *a4 = v14;
    *(a3 + 1) = v13;
    *(a4 + 1) = v5;
    v15 = *(a3 + 1);
    v16 = *(a2 + 1);
    if (v15 > v16)
    {
      v17 = *a2;
      *a2 = *a3;
      *a3 = v17;
      *(a2 + 1) = v15;
      *(a3 + 1) = v16;
      v18 = *(a2 + 1);
      v19 = *(result + 1);
      if (v18 > v19)
      {
        v20 = *result;
        *result = *a2;
        *a2 = v20;
        *(result + 1) = v18;
        *(a2 + 1) = v19;
      }
    }
  }

  v21 = *(a5 + 1);
  v22 = *(a4 + 1);
  if (v21 > v22)
  {
    v23 = *a4;
    *a4 = *a5;
    *a5 = v23;
    *(a4 + 1) = v21;
    *(a5 + 1) = v22;
    v24 = *(a4 + 1);
    v25 = *(a3 + 1);
    if (v24 > v25)
    {
      v26 = *a3;
      *a3 = *a4;
      *a4 = v26;
      *(a3 + 1) = v24;
      *(a4 + 1) = v25;
      v27 = *(a3 + 1);
      v28 = *(a2 + 1);
      if (v27 > v28)
      {
        v29 = *a2;
        *a2 = *a3;
        *a3 = v29;
        *(a2 + 1) = v27;
        *(a3 + 1) = v28;
        v30 = *(a2 + 1);
        v31 = *(result + 1);
        if (v30 > v31)
        {
          v32 = *result;
          *result = *a2;
          *a2 = v32;
          *(result + 1) = v30;
          *(a2 + 1) = v31;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,anonymous namespace::BytecodeWriter::writeUseListOrders(anonymous namespace::EncodingEmitter &,unsigned char &,mlir::ValueRange)::$_2 &,std::pair<unsigned int,unsigned long long> *>(uint64_t a1, uint64_t a2)
{
  v2 = (a2 - a1) >> 4;
  if (v2 > 2)
  {
    if (v2 == 3)
    {
      v6 = *(a1 + 24);
      v7 = *(a1 + 8);
      v8 = *(a2 - 8);
      if (v6 <= v7)
      {
        if (v8 > v6)
        {
          v22 = *(a1 + 16);
          *(a1 + 16) = *(a2 - 16);
          *(a2 - 16) = v22;
          *(a1 + 24) = v8;
          *(a2 - 8) = v6;
          v23 = *(a1 + 24);
          v24 = *(a1 + 8);
          if (v23 > v24)
          {
            v25 = *a1;
            *a1 = *(a1 + 16);
            *(a1 + 16) = v25;
            *(a1 + 8) = v23;
            *(a1 + 24) = v24;
          }
        }

        return 1;
      }

      v9 = *a1;
      if (v8 <= v6)
      {
        *a1 = *(a1 + 16);
        *(a1 + 16) = v9;
        *(a1 + 8) = v6;
        *(a1 + 24) = v7;
        v32 = *(a2 - 8);
        if (v32 <= v7)
        {
          return 1;
        }

        *(a1 + 16) = *(a2 - 16);
        *(a2 - 16) = v9;
        *(a1 + 24) = v32;
      }

      else
      {
        *a1 = *(a2 - 16);
        *(a2 - 16) = v9;
        *(a1 + 8) = v8;
      }

      *(a2 - 8) = v7;
      return 1;
    }

    if (v2 != 4)
    {
      if (v2 != 5)
      {
        goto LABEL_13;
      }

      return 1;
    }

    v16 = (a1 + 24);
    v17 = *(a1 + 24);
    v19 = (a1 + 8);
    v18 = *(a1 + 8);
    v20 = *(a1 + 40);
    if (v17 <= v18)
    {
      if (v20 > v17)
      {
        v29 = *(a1 + 16);
        v30 = *(a1 + 32);
        *(a1 + 16) = v30;
        *(a1 + 32) = v29;
        *(a1 + 24) = v20;
        *(a1 + 40) = v17;
        if (v20 <= v18)
        {
LABEL_49:
          v20 = v17;
          goto LABEL_50;
        }

        v31 = *a1;
        *a1 = v30;
        *(a1 + 16) = v31;
LABEL_48:
        *v19 = v20;
        *v16 = v18;
        goto LABEL_49;
      }
    }

    else
    {
      v21 = *a1;
      if (v20 > v17)
      {
        *a1 = *(a1 + 32);
        *(a1 + 32) = v21;
LABEL_47:
        v16 = (a1 + 40);
        v17 = v18;
        goto LABEL_48;
      }

      *a1 = *(a1 + 16);
      *(a1 + 16) = v21;
      *(a1 + 8) = v17;
      *(a1 + 24) = v18;
      if (v20 > v18)
      {
        *(a1 + 16) = *(a1 + 32);
        *(a1 + 32) = v21;
        v19 = (a1 + 24);
        goto LABEL_47;
      }
    }

LABEL_50:
    v42 = *(a2 - 8);
    if (v42 > v20)
    {
      v43 = *(a1 + 32);
      *(a1 + 32) = *(a2 - 16);
      *(a2 - 16) = v43;
      *(a1 + 40) = v42;
      *(a2 - 8) = v20;
      v44 = *(a1 + 40);
      v45 = *(a1 + 24);
      if (v44 > v45)
      {
        v46 = *(a1 + 16);
        v47 = *(a1 + 32);
        *(a1 + 16) = v47;
        *(a1 + 32) = v46;
        *(a1 + 24) = v44;
        *(a1 + 40) = v45;
        v48 = *(a1 + 8);
        if (v44 > v48)
        {
          v49 = *a1;
          *a1 = v47;
          *(a1 + 16) = v49;
          *(a1 + 8) = v44;
          *(a1 + 24) = v48;
        }
      }
    }

    return 1;
  }

  if (v2 < 2)
  {
    return 1;
  }

  if (v2 == 2)
  {
    v3 = *(a2 - 8);
    v4 = *(a1 + 8);
    if (v3 > v4)
    {
      v5 = *a1;
      *a1 = *(a2 - 16);
      *(a2 - 16) = v5;
      *(a1 + 8) = v3;
      *(a2 - 8) = v4;
    }

    return 1;
  }

LABEL_13:
  v10 = *(a1 + 24);
  v12 = (a1 + 8);
  v11 = *(a1 + 8);
  v14 = (a1 + 40);
  v13 = *(a1 + 40);
  if (v10 > v11)
  {
    v15 = *a1;
    if (v13 <= v10)
    {
      *a1 = *(a1 + 16);
      *(a1 + 16) = v15;
      *(a1 + 8) = v10;
      *(a1 + 24) = v11;
      if (v13 <= v11)
      {
        goto LABEL_34;
      }

      *(a1 + 16) = *(a1 + 32);
      *(a1 + 32) = v15;
      v12 = (a1 + 24);
    }

    else
    {
      *a1 = *(a1 + 32);
      *(a1 + 32) = v15;
    }

    goto LABEL_33;
  }

  if (v13 > v10)
  {
    v26 = *(a1 + 16);
    v27 = *(a1 + 32);
    *(a1 + 16) = v27;
    *(a1 + 32) = v26;
    *(a1 + 24) = v13;
    *(a1 + 40) = v10;
    if (v13 > v11)
    {
      v28 = *a1;
      *a1 = v27;
      *(a1 + 16) = v28;
      v14 = (a1 + 24);
LABEL_33:
      *v12 = v13;
      *v14 = v11;
    }
  }

LABEL_34:
  v33 = a1 + 48;
  if (a1 + 48 == a2)
  {
    return 1;
  }

  v34 = 0;
  v35 = 0;
  v36 = a1 + 32;
  while (1)
  {
    v37 = *(v33 + 8);
    if (v37 > *(v36 + 8))
    {
      v38 = *v33;
      v39 = v34;
      while (1)
      {
        v40 = a1 + v39;
        *(v40 + 48) = *(a1 + v39 + 32);
        *(v40 + 56) = *(a1 + v39 + 40);
        if (v39 == -32)
        {
          break;
        }

        v39 -= 16;
        if (v37 <= *(v40 + 24))
        {
          v41 = a1 + v39 + 48;
          goto LABEL_42;
        }
      }

      v41 = a1;
LABEL_42:
      *v41 = v38;
      *(v41 + 8) = v37;
      if (++v35 == 8)
      {
        return v33 + 16 == a2;
      }
    }

    v36 = v33;
    v34 += 16;
    v33 += 16;
    if (v33 == a2)
    {
      return 1;
    }
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>,unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::LookupBucketFor<unsigned int>(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (a1 + 72 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -2;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 72 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((72 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = 72 * v10 - 72;
      v13 = vdupq_n_s64(v12 / 0x48);
      v14 = result + 144;
      do
      {
        v15 = vdupq_n_s64(v11);
        v16 = vmovn_s64(vcgeq_u64(v13, vorrq_s8(v15, xmmword_25D0A0500)));
        if (vuzp1_s16(v16, *v13.i8).u8[0])
        {
          *(v14 - 36) = -1;
        }

        if (vuzp1_s16(v16, *&v13).i8[2])
        {
          *(v14 - 18) = -1;
        }

        if (vuzp1_s16(*&v13, vmovn_s64(vcgeq_u64(v13, vorrq_s8(v15, xmmword_25D0A04F0)))).i32[1])
        {
          *v14 = -1;
          v14[18] = -1;
        }

        v11 += 4;
        v14 += 72;
      }

      while (((v12 / 0x48 + 4) & 0x7FFFFFFFFFFFFFCLL) != v11);
    }

    if (v3)
    {
      v17 = 72 * v3;
      v18 = (v4 + 24);
      do
      {
        v19 = *(v18 - 6);
        if (v19 <= 0xFFFFFFFD)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>,unsigned int,llvm::SmallVector<unsigned int,12u>,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,llvm::SmallVector<unsigned int,12u>>>::LookupBucketFor<unsigned int>(*a1, *(a1 + 16), v19, &v30);
          v20 = v30;
          *v30 = *(v18 - 6);
          *(v20 + 2) = 0xC00000000;
          *(v20 + 1) = v20 + 6;
          v21 = (v20 + 2);
          if (*(v18 - 2))
          {
            llvm::SmallVectorImpl<unsigned int>::operator=(v21, (v18 - 4));
          }

          ++*(a1 + 8);
          v22 = *(v18 - 2);
          if (v18 != v22)
          {
            free(v22);
          }
        }

        v18 += 18;
        v17 -= 72;
      }

      while (v17);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v23 = *(a1 + 16);
  if (v23)
  {
    v24 = 0;
    v25 = 72 * v23 - 72;
    v26 = vdupq_n_s64(v25 / 0x48);
    v27 = result + 144;
    do
    {
      v28 = vdupq_n_s64(v24);
      v29 = vmovn_s64(vcgeq_u64(v26, vorrq_s8(v28, xmmword_25D0A0500)));
      if (vuzp1_s16(v29, *v26.i8).u8[0])
      {
        *(v27 - 36) = -1;
      }

      if (vuzp1_s16(v29, *&v26).i8[2])
      {
        *(v27 - 18) = -1;
      }

      if (vuzp1_s16(*&v26, vmovn_s64(vcgeq_u64(v26, vorrq_s8(v28, xmmword_25D0A04F0)))).i32[1])
      {
        *v27 = -1;
        v27[18] = -1;
      }

      v24 += 4;
      v27 += 72;
    }

    while (((v25 / 0x48 + 4) & 0x7FFFFFFFFFFFFFCLL) != v24);
  }

  return result;
}

void std::__all_of[abi:nn200100]<mlir::Region *,mlir::Region *,std::__identity,anonymous namespace::BytecodeWriter::writeRegions(anonymous namespace::EncodingEmitter &,llvm::MutableArrayRef<mlir::Region>)::{lambda(mlir::Region&)#1}>(void *a1, void *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    v3 = a1;
    v27 = a3;
    while (1)
    {
      v4 = a3[1];
      if (*v3 == v3)
      {
        LOBYTE(v31) = 1;
        std::vector<unsigned char>::push_back[abi:nn200100](v4, &v31);
        goto LABEL_29;
      }

      v5 = *a3;
      v30 = v3;
      v31 = 0;
      v6 = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::LookupBucketFor<mlir::Region *>((v5 + 944), &v30, &v31);
      v7 = v31;
      if ((v6 & 1) == 0)
      {
        v7 = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::InsertIntoBucketImpl<mlir::Region *>(v5 + 944, &v30, v31);
        *v7 = v30;
        v7[1] = 0;
      }

      v8 = v7[1];
      v9 = HIDWORD(v8);
      v10 = v3[1];
      if (v10 != v3)
      {
        break;
      }

LABEL_29:
      v3 += 3;
      a3 = v27;
      if (v3 == a2)
      {
        return;
      }
    }

    v29 = v3;
LABEL_8:
    if (v10)
    {
      v11 = v10 - 1;
    }

    else
    {
      v11 = 0;
    }

    v12 = v11[6];
    v13 = v11[7];
    v31 = v11;
    v14 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::operator[]((v5 + 920), &v31);
    v15 = v13 - v12;
    if (v13 == v12)
    {
      goto LABEL_23;
    }

    v16 = v15 >> 3;
    v17 = v12;
    while (1)
    {
      v18 = *(*v17 + 32);
      v19 = *(*v17 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (**(v5 + 984) < 4)
      {
        v31 = (*(*v17 + 8) & 0xFFFFFFFFFFFFFFF8);
        v21 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::operator[]((v5 + 112), &v31);
      }

      else
      {
        v31 = (*(*v17 + 8) & 0xFFFFFFFFFFFFFFF8);
        v20 = *(*llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::operator[]((v5 + 112), &v31) + 8);
        if (*(*v18 + 136) == &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
        {
          goto LABEL_18;
        }
      }

      v31 = v18;
      v22 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::operator[]((v5 + 40), &v31);
LABEL_18:
      v17 += 8;
      if (v17 == v13)
      {
        v3 = v29;
        if (**(v5 + 984) > 2)
        {
          v23 = v4[9];
          v25 = *v4;
          v24 = v4[1];
          LOBYTE(v30) = 0;
          LOBYTE(v31) = 0;
          std::vector<unsigned char>::push_back[abi:nn200100](v4, &v31);
          if (v30)
          {
            *(*v4 + v23 + v24 - (v4[9] + v25)) = v30;
          }

          v3 = v29;
        }

LABEL_23:
        for (i = v11[5]; i != v11 + 4; i = i[1])
        {
        }

        v10 = v10[1];
        if (v10 == v3)
        {
          goto LABEL_29;
        }

        goto LABEL_8;
      }
    }
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::LookupBucketFor<mlir::Region *>(uint64_t *a1, void *a2, void *a3)
{
  v3 = *(a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (*a1 + 16 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v8 == -8192;
        }

        if (v12)
        {
          v10 = v7;
        }

        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (v4 + 16 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v10)
      {
        v7 = v10;
      }
    }
  }

  else
  {
    v7 = 0;
    result = 0;
  }

LABEL_5:
  *a3 = v7;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::InsertIntoBucketImpl<mlir::Region *>(uint64_t a1, void *a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::LookupBucketFor<mlir::Region *>(a1, a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -4096)
  {
    --*(a1 + 12);
  }

  return a3;
}

char *llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::moveFromOldBuckets(a1, v4, &v4[2 * v3]);

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v10 = *(a1 + 16);
  if (v10)
  {
    v11 = 0;
    v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
    v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
    v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
    v15 = vdupq_n_s64(v13);
    v16 = result + 16;
    do
    {
      v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
      if (v17.i8[0])
      {
        *(v16 - 2) = -4096;
      }

      if (v17.i8[4])
      {
        *v16 = -4096;
      }

      v11 += 2;
      v16 += 4;
    }

    while (v14 != v11);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::moveFromOldBuckets(uint64_t result, void *a2, void *a3)
{
  v5 = result;
  *(result + 8) = 0;
  v6 = *(result + 16);
  if (v6)
  {
    v7 = 0;
    v8 = v6 + 0xFFFFFFFFFFFFFFFLL;
    v9 = v8 & 0xFFFFFFFFFFFFFFFLL;
    v10 = (v8 & 0xFFFFFFFFFFFFFFFLL) - (v8 & 1) + 2;
    v11 = vdupq_n_s64(v9);
    v12 = (*result + 16);
    do
    {
      v13 = vmovn_s64(vcgeq_u64(v11, vorrq_s8(vdupq_n_s64(v7), xmmword_25D0A0500)));
      if (v13.i8[0])
      {
        *(v12 - 2) = -4096;
      }

      if (v13.i8[4])
      {
        *v12 = -4096;
      }

      v7 += 2;
      v12 += 4;
    }

    while (v10 != v7);
  }

  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::LookupBucketFor<mlir::Region *>(v5, a2, &v14);
      *v14 = *a2;
      v14[1] = a2[1];
      ++*(v5 + 8);
    }

    a2 += 2;
  }

  return result;
}

uint64_t llvm::function_ref<void ()(llvm::StringRef,mlir::AsmResourceEntryKind)>::callback_fn<anonymous namespace::BytecodeWriter::writeResourceSection(mlir::Operation *,anonymous namespace::EncodingEmitter &)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *&v11 = a2;
  *(&v11 + 1) = a3;
  v10 = a4;
  v6 = *a1;
  v5 = *(a1 + 8);
  v7 = v6[9] + v6[1] - *v6;
  v9 = v7 - **(a1 + 16);
  result = llvm::SmallVectorImpl<std::tuple<llvm::StringRef,mlir::AsmResourceEntryKind,unsigned long long>>::emplace_back<llvm::StringRef&,mlir::AsmResourceEntryKind&,unsigned long long>(v5, &v11, &v10, &v9);
  **(a1 + 16) = v7;
  return result;
}

uint64_t anonymous namespace::ResourceBuilder::buildBool(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if ((*(a1 + 40) & 1) == 0)
  {
    v7 = *(a1 + 8);
    v11 = a4;
    std::vector<unsigned char>::push_back[abi:nn200100](v7, &v11);
  }

  v9 = *(a1 + 24);
  v8 = *(a1 + 32);

  return v9(v8, a2, a3, 1);
}

uint64_t anonymous namespace::ResourceBuilder::buildString(uint64_t a1, uint64_t a2, uint64_t a3, llvm::hashing::detail::hash_state *a4, uint64_t a5)
{
  if ((*(a1 + 40) & 1) == 0)
  {
    v8 = *(a1 + 8);
  }

  v11 = *(a1 + 24);
  v10 = *(a1 + 32);

  return v11(v10, a2, a3, 2);
}

uint64_t anonymous namespace::ResourceBuilder::buildBlob(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  if ((*(a1 + 40) & 1) == 0)
  {
    v12 = *(a1 + 8);
  }

  v14 = *(a1 + 24);
  v13 = *(a1 + 32);

  return v14(v13, a2, a3, 0);
}

uint64_t llvm::SmallVectorImpl<std::tuple<llvm::StringRef,mlir::AsmResourceEntryKind,unsigned long long>>::emplace_back<llvm::StringRef&,mlir::AsmResourceEntryKind&,unsigned long long>(uint64_t result, __int128 *a2, int *a3, uint64_t *a4)
{
  v4 = *(result + 8);
  if (v4 >= *(result + 12))
  {
    return llvm::SmallVectorTemplateBase<std::tuple<llvm::StringRef,mlir::AsmResourceEntryKind,unsigned long long>,true>::growAndEmplaceBack<llvm::StringRef&,mlir::AsmResourceEntryKind&,unsigned long long>(result, a2, *a3, *a4);
  }

  v5 = *result + 32 * v4;
  *v5 = *a2;
  *(v5 + 16) = *a3;
  *(v5 + 24) = *a4;
  ++*(result + 8);
  return result;
}

uint64_t llvm::SmallVectorTemplateBase<std::tuple<llvm::StringRef,mlir::AsmResourceEntryKind,unsigned long long>,true>::growAndEmplaceBack<llvm::StringRef&,mlir::AsmResourceEntryKind&,unsigned long long>(uint64_t a1, __int128 *a2, int a3, uint64_t a4)
{
  v13 = *a2;
  v14 = a3;
  v15 = a4;
  v5 = *(a1 + 8);
  v6 = *a1;
  v7 = &v13;
  if (v5 >= *(a1 + 12))
  {
    if (v6 <= &v13 && v6 + 32 * v5 > &v13)
    {
      v12 = &v13 - v6;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v5 + 1, 32);
      v6 = *a1;
      v7 = &v12[*a1];
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v5 + 1, 32);
      v6 = *a1;
      v7 = &v13;
    }
  }

  v8 = (v6 + 32 * *(a1 + 8));
  v9 = *(v7 + 1);
  *v8 = *v7;
  v8[1] = v9;
  v10 = (*(a1 + 8) + 1);
  *(a1 + 8) = v10;
  return *a1 + 32 * v10 - 32;
}

void std::vector<std::vector<unsigned char>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v1[1];
      do
      {
        v8 = *(v6 - 3);
        v6 -= 24;
        v7 = v8;
        if (v8)
        {
          *(v4 - 2) = v7;
          operator delete(v7);
        }

        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

char **llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeWriter<mlir::Type>>,6u>::~SmallVector(char **a1)
{
  v2 = *a1;
  v3 = *(a1 + 2);
  if (v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *&v5[v4];
      *&v5[v4] = 0;
      if (v6)
      {
        (*(*v6 + 8))(v6);
      }

      v4 -= 8;
    }

    while (v4);
    v2 = *a1;
  }

  if (v2 != (a1 + 2))
  {
    free(v2);
  }

  return a1;
}

char **llvm::SmallVector<std::unique_ptr<mlir::AttrTypeBytecodeWriter<mlir::Attribute>>,6u>::~SmallVector(char **a1)
{
  v2 = *a1;
  v3 = *(a1 + 2);
  if (v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *&v5[v4];
      *&v5[v4] = 0;
      if (v6)
      {
        (*(*v6 + 8))(v6);
      }

      v4 -= 8;
    }

    while (v4);
    v2 = *a1;
  }

  if (v2 != (a1 + 2))
  {
    free(v2);
  }

  return a1;
}

uint64_t llvm::StringMap<std::unique_ptr<mlir::DialectVersion>,llvm::MallocAllocator>::~StringMap(uint64_t a1)
{
  if (*(a1 + 12))
  {
    v2 = *(a1 + 8);
    if (v2)
    {
      v3 = 0;
      v4 = 8 * v2;
      do
      {
        v5 = *(*a1 + v3);
        if (v5 != -8 && v5 != 0)
        {
          llvm::StringMapEntry<std::unique_ptr<mlir::DialectVersion>>::Destroy<llvm::MallocAllocator>(v5);
        }

        v3 += 8;
      }

      while (v4 != v3);
    }
  }

  free(*a1);
  return a1;
}

void llvm::StringMapEntry<std::unique_ptr<mlir::DialectVersion>>::Destroy<llvm::MallocAllocator>(uint64_t a1)
{
  v2 = *(a1 + 8);
  *(a1 + 8) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  JUMPOUT(0x25F891030);
}

mlir::bytecode::detail::IRNumberingState *mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::bytecode::detail::IRNumberingState *this, mlir::Operation *a2, const mlir::BytecodeWriterConfig *a3)
{
  v140[16] = *MEMORY[0x277D85DE8];
  *(this + 4) = 0;
  *this = 0u;
  *(this + 24) = 0u;
  v4 = (this + 24);
  *(this + 10) = 0;
  *(this + 3) = 0u;
  *(this + 16) = 0;
  *(this + 72) = 0u;
  *(this + 22) = 0;
  *(this + 6) = 0u;
  *(this + 28) = 0;
  *(this + 34) = 0;
  *(this + 120) = 0u;
  *(this + 18) = this + 160;
  *(this + 16) = 0u;
  *(this + 62) = 0;
  *(this + 232) = 0u;
  *(this + 216) = 0u;
  *(this + 200) = 0u;
  *(this + 184) = 0u;
  *(this + 168) = 0u;
  *(this + 152) = 0u;
  *(this + 34) = this + 288;
  *(this + 35) = 0x400000000;
  *(this + 40) = this + 336;
  *(this + 328) = 0u;
  *(this + 344) = 0u;
  *(this + 45) = 0;
  *(this + 46) = this + 384;
  *(this + 47) = 0x400000000;
  *(this + 52) = this + 432;
  *(this + 424) = 0u;
  *(this + 440) = 0u;
  *(this + 57) = 0;
  *(this + 58) = this + 480;
  *(this + 59) = 0x400000000;
  *(this + 64) = this + 528;
  *(this + 69) = 0;
  *(this + 520) = 0u;
  *(this + 536) = 0u;
  *(this + 70) = this + 576;
  *(this + 71) = 0x400000000;
  *(this + 76) = this + 624;
  *(this + 81) = 0;
  *(this + 616) = 0u;
  *(this + 632) = 0u;
  *(this + 82) = this + 672;
  *(this + 83) = 0x400000000;
  *(this + 88) = this + 720;
  *(this + 93) = 0;
  *(this + 712) = 0u;
  *(this + 728) = 0u;
  *(this + 94) = this + 768;
  *(this + 95) = 0x400000000;
  *(this + 100) = this + 816;
  v5 = this + 856;
  *(this + 218) = 0;
  *(this + 856) = 0u;
  *(this + 224) = 0;
  *(this + 55) = 0u;
  *(this + 230) = 0;
  v129 = (this + 904);
  *(this + 904) = 0u;
  *(this + 232) = 0;
  *(this + 836) = 0u;
  *(this + 808) = 0u;
  *(this + 824) = 0u;
  *(this + 117) = a3;
  LODWORD(v134) = 0;
  v139 = 0x200000000;
  v135 = &v138;
  v136 = this;
  k = &v134;
  v138 = v140;
  mlir::detail::walk(a2, llvm::function_ref<void ()(mlir::Operation *,mlir::WalkStage const&)>::callback_fn<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::$_0>, &v135);
  if (v138 != v140)
  {
    free(v138);
  }

  mlir::bytecode::detail::IRNumberingState::number(this, a2);
  v138 = v140;
  v139 = 0x800000000;
  v6 = *(a2 + 11);
  v7 = v6 & 0x7FFFFF;
  if ((v6 & 0x7FFFFF) != 0)
  {
    v8 = ((a2 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 10);
    v135 = a2;
    v9 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[](v4, &v135);
    if (*(*v9 + 5) & 1) != 0 && (*(*v9 + 4))
    {
      v10 = 0;
    }

    else
    {
      v10 = *(this + 232);
    }

    v11 = 24 * v7;
    do
    {
      llvm::SmallVectorImpl<std::pair<mlir::Region *,unsigned int>>::emplace_back<mlir::Region *,unsigned int &>(&v138, v8, v10);
      v8 += 24;
      v11 -= 24;
    }

    while (v11);
    while (v139)
    {
      v12 = v138 + 16 * v139;
      v13 = *(v12 - 2);
      v14 = *(v12 - 2);
      LODWORD(v139) = v139 - 1;
      *(this + 232) = v14;
      if (*v13 != v13)
      {
        v15 = v13[1];
        if (v15 == v13)
        {
          v16 = 0;
          v27 = v14;
        }

        else
        {
          v16 = 0;
          do
          {
            if (v15)
            {
              v17 = v15 - 1;
            }

            else
            {
              v17 = 0;
            }

            v134 = v17;
            v135 = 0;
            if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::LookupBucketFor<mlir::Block *>(this + 104, &v134, &v135) & 1) == 0)
            {
              v18 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::InsertIntoBucketImpl<mlir::Block *>(this + 832, &v134, v135);
              *v18 = v134;
              *(v18 + 2) = v16;
            }

            v20 = v17[6];
            v19 = v17[7];
            while (v20 != v19)
            {
              v21 = *v20++;
              v134 = v21;
              v22 = *(this + 232);
              *(this + 232) = v22 + 1;
              v133 = v22;
              llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::try_emplace<unsigned int>(&v135, v5, &v134, &v133);
              mlir::bytecode::detail::IRNumberingState::number(this, v134[4]);
              mlir::bytecode::detail::IRNumberingState::number(this, (v134[1] & 0xFFFFFFFFFFFFFFF8));
            }

            v134 = v17;
            v135 = 0;
            v23 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::LookupBucketFor<mlir::Block *>(this + 110, &v134, &v135);
            v24 = v135;
            if ((v23 & 1) == 0)
            {
              v24 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>,mlir::Block *,unsigned int,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,unsigned int>>::InsertIntoBucketImpl<mlir::Block *>(this + 880, &v134, v135);
              *v24 = v134;
              *(v24 + 2) = 0;
            }

            v25 = (v17 + 4);
            for (i = v17[5]; i != v25; i = *(i + 1))
            {
              mlir::bytecode::detail::IRNumberingState::number(this, i);
              ++*(v24 + 2);
            }

            ++v16;
            v15 = v15[1];
          }

          while (v15 != v13);
          v27 = *(this + 232);
        }

        v134 = v13;
        v135 = 0;
        if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::LookupBucketFor<mlir::Region *>(v129, &v134, &v135) & 1) == 0)
        {
          v28 = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>,mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::InsertIntoBucketImpl<mlir::Region *>(v129, &v134, v135);
          *v28 = v134;
          *(v28 + 2) = v16;
          *(v28 + 3) = v27 - v14;
        }

        if (*v13 != v13)
        {
          for (j = v13[1]; j != v13; j = j[1])
          {
            v30 = j - 1;
            if (!j)
            {
              v30 = 0;
            }

            if (v30[4] != v30 + 4)
            {
              break;
            }
          }

          if (j != v13)
          {
            v31 = j - 1;
            if (!j)
            {
              v31 = 0;
            }

            v32 = v31[5];
            v135 = v13;
            v136 = j;
            for (k = v32; k; v32 = k)
            {
              v33 = *(v32 + 11);
              if ((v33 & 0x7FFFFF) != 0)
              {
                v34 = *(v32 + 10);
                v134 = v32;
                v35 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::operator[](v4, &v134);
                if (*(*v35 + 5) & 1) != 0 && (*(*v35 + 4))
                {
                  v36 = 0;
                }

                else
                {
                  v36 = *(this + 232);
                }

                v37 = &(&v32[4 * v34])[2 * ((v33 >> 23) & 1) + 8] + ((v33 >> 21) & 0x7F8);
                v38 = 24 * (v33 & 0x7FFFFF);
                do
                {
                  llvm::SmallVectorImpl<std::pair<mlir::Region *,unsigned int>>::emplace_back<mlir::Region *,unsigned int &>(&v138, v37, v36);
                  v37 += 24;
                  v38 -= 24;
                }

                while (v38);
              }

              mlir::Region::OpIterator::operator++(&v135);
            }
          }
        }
      }
    }
  }

  v39 = *(this + 38);
  if (v39)
  {
    v40 = 0;
    v41 = 24 * v39;
    v42 = (*(this + 18) + 16);
    do
    {
      v43 = *v42;
      v42 += 3;
      *(v43 + 16) = v40++;
      v41 -= 24;
    }

    while (v41);
  }

  v44 = *(this + 20);
  v45 = *(this + 21);
  if ((v45 - v44) >> 3 < 129)
  {
    v49 = 0;
LABEL_61:
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v44, v45, (v45 - v44) >> 3, 0, v49);
  }

  else
  {
    v46 = MEMORY[0x277D826F0];
    v47 = (v45 - v44) >> 3;
    while (1)
    {
      v48 = operator new(8 * v47, v46);
      if (v48)
      {
        break;
      }

      v49 = v47 >> 1;
      v50 = v47 > 1;
      v47 >>= 1;
      if (!v50)
      {
        goto LABEL_61;
      }
    }

    v51 = v48;
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v44, v45, (v45 - v44) >> 3, v48, v47);
    operator delete(v51);
  }

  v52 = *(this + 23);
  v53 = *(this + 24);
  if ((v53 - v52) >> 3 < 129)
  {
    v57 = 0;
LABEL_69:
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v52, v53, (v53 - v52) >> 3, 0, v57);
  }

  else
  {
    v54 = MEMORY[0x277D826F0];
    v55 = (v53 - v52) >> 3;
    while (1)
    {
      v56 = operator new(8 * v55, v54);
      if (v56)
      {
        break;
      }

      v57 = v55 >> 1;
      v50 = v55 > 1;
      v55 >>= 1;
      if (!v50)
      {
        goto LABEL_69;
      }
    }

    v58 = v56;
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v52, v53, (v53 - v52) >> 3, v56, v55);
    operator delete(v58);
  }

  v59 = *(this + 26);
  v60 = *(this + 27);
  if ((v60 - v59) >> 3 < 129)
  {
    v64 = 0;
LABEL_77:
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v59, v60, (v60 - v59) >> 3, 0, v64);
  }

  else
  {
    v61 = MEMORY[0x277D826F0];
    v62 = (v60 - v59) >> 3;
    while (1)
    {
      v63 = operator new(8 * v62, v61);
      if (v63)
      {
        break;
      }

      v64 = v62 >> 1;
      v50 = v62 > 1;
      v62 >>= 1;
      if (!v50)
      {
        goto LABEL_77;
      }
    }

    v65 = v63;
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v59, v60, (v60 - v59) >> 3, v63, v62);
    operator delete(v65);
  }

  v67 = *(this + 20);
  v66 = *(this + 21);
  v68 = v66 - v67;
  if (v66 != v67)
  {
    v125 = *(this + 21);
    v69 = 0;
    v70 = v68 >> 3;
    LODWORD(v134) = 0;
    v71 = MEMORY[0x277D826F0];
    v72 = 1;
    v73 = v67;
    do
    {
      v74 = (1 << (7 * v72)) - v69;
      v130 = v74;
      if (v70 >= v74)
      {
        v75 = v74;
      }

      else
      {
        v75 = v70;
      }

      v135 = &v133;
      v136 = &v134;
      if (v75 < 129)
      {
        v78 = 0;
LABEL_90:
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v73, &v73[8 * v75], &v135, v75, 0, v78);
      }

      else
      {
        v76 = v75;
        while (1)
        {
          v77 = operator new(8 * v76, v71);
          if (v77)
          {
            break;
          }

          v78 = v76 >> 1;
          v50 = v76 > 1;
          v76 >>= 1;
          if (!v50)
          {
            goto LABEL_90;
          }
        }

        v79 = v77;
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v73, &v73[8 * v75], &v135, v75, v77, v76);
        operator delete(v79);
      }

      LODWORD(v134) = *(*(*&v73[8 * v75 - 8] + 16) + 16);
      v70 -= v75;
      v69 = v130;
      if (!v70)
      {
        break;
      }

      ++v72;
      v73 += 8 * v75;
    }

    while (v72 != 9);
    v80 = 0;
    do
    {
      v81 = *v67;
      v67 += 8;
      *(v81 + 8) = v80++;
    }

    while (v67 != v125);
  }

  v83 = *(this + 23);
  v82 = *(this + 24);
  v84 = v82 - v83;
  if (v82 != v83)
  {
    v126 = *(this + 24);
    v85 = 0;
    v86 = v84 >> 3;
    LODWORD(v134) = 0;
    v87 = MEMORY[0x277D826F0];
    v88 = 1;
    v89 = v83;
    do
    {
      v90 = (1 << (7 * v88)) - v85;
      v131 = v90;
      if (v86 >= v90)
      {
        v91 = v90;
      }

      else
      {
        v91 = v86;
      }

      v135 = &v133;
      v136 = &v134;
      if (v91 < 129)
      {
        v94 = 0;
LABEL_107:
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v89, &v89[8 * v91], &v135, v91, 0, v94);
      }

      else
      {
        v92 = v91;
        while (1)
        {
          v93 = operator new(8 * v92, v87);
          if (v93)
          {
            break;
          }

          v94 = v92 >> 1;
          v50 = v92 > 1;
          v92 >>= 1;
          if (!v50)
          {
            goto LABEL_107;
          }
        }

        v95 = v93;
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v89, &v89[8 * v91], &v135, v91, v93, v92);
        operator delete(v95);
      }

      LODWORD(v134) = *(**&v89[8 * v91 - 8] + 16);
      v86 -= v91;
      v85 = v131;
      if (!v86)
      {
        break;
      }

      ++v88;
      v89 += 8 * v91;
    }

    while (v88 != 9);
    v96 = 0;
    do
    {
      v97 = *v83;
      v83 += 8;
      *(v97 + 16) = v96++;
    }

    while (v83 != v126);
  }

  v99 = *(this + 26);
  v98 = *(this + 27);
  v100 = v98 - v99;
  if (v98 != v99)
  {
    v127 = *(this + 27);
    v101 = 0;
    v102 = v100 >> 3;
    LODWORD(v134) = 0;
    v103 = MEMORY[0x277D826F0];
    v104 = 1;
    v105 = v99;
    do
    {
      v106 = (1 << (7 * v104)) - v101;
      v132 = v106;
      if (v102 >= v106)
      {
        v107 = v106;
      }

      else
      {
        v107 = v102;
      }

      v135 = &v133;
      v136 = &v134;
      if (v107 < 129)
      {
        v110 = 0;
LABEL_124:
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v105, &v105[8 * v107], &v135, v107, 0, v110);
      }

      else
      {
        v108 = v107;
        while (1)
        {
          v109 = operator new(8 * v108, v103);
          if (v109)
          {
            break;
          }

          v110 = v108 >> 1;
          v50 = v108 > 1;
          v108 >>= 1;
          if (!v50)
          {
            goto LABEL_124;
          }
        }

        v111 = v109;
        _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v105, &v105[8 * v107], &v135, v107, v109, v108);
        operator delete(v111);
      }

      LODWORD(v134) = *(*(*&v105[8 * v107 - 8] + 16) + 16);
      v102 -= v107;
      v101 = v132;
      if (!v102)
      {
        break;
      }

      ++v104;
      v105 += 8 * v107;
    }

    while (v104 != 9);
    v112 = 0;
    do
    {
      v113 = *v99;
      v99 += 8;
      *(v113 + 8) = v112++;
    }

    while (v99 != v127);
  }

  v114 = *(this + 18);
  v115 = *(this + 38);
  LODWORD(v134) = 0;
  if (v115)
  {
    v116 = v114 + 24 * v115;
    do
    {
      v117 = *(v114 + 16);
      v118 = *(v117 + 32);
      if (v118)
      {
        v135 = &unk_286EAA4D0;
        v136 = v117;
        k = &v134;
        (*(*v118 + 56))(v118, a2, v117 + 40, &v135);
        v119 = *(v117 + 112);
        if (v119)
        {
          v120 = v134;
          v121 = 24 * v119;
          v122 = *(v117 + 104) + 16;
          do
          {
            if (*(*v122 + 28) == 1)
            {
              *(*v122 + 24) = v120++;
              LODWORD(v134) = v120;
            }

            v122 += 24;
            v121 -= 24;
          }

          while (v121);
        }
      }

      v114 += 24;
    }

    while (v114 != v116);
  }

  if (v138 != v140)
  {
    free(v138);
  }

  v123 = *MEMORY[0x277D85DE8];
  return this;
}

void mlir::bytecode::detail::IRNumberingState::number(mlir::bytecode::detail::IRNumberingState *this, mlir::Operation *a2)
{
  v39[0] = *(a2 + 6);
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>,mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,mlir::bytecode::detail::OpNameNumbering *>>::operator[](this + 6, v39);
  if (*v4)
  {
    ++*(*v4 + 20);
  }

  else
  {
    v5 = v4;
    if (*(v39[0] + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v6 = (*(v39[0] + 8) + 32);
    }

    else
    {
      v6 = (v39[0] + 24);
    }

    if (*v6)
    {
      v7 = mlir::bytecode::detail::IRNumberingState::numberDialect(this, *v6);
    }

    else
    {
      DialectNamespace = mlir::OperationName::getDialectNamespace(v39);
      mlir::bytecode::detail::IRNumberingState::numberDialect(this, DialectNamespace, v9);
    }

    v10 = v7;
    v11 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(this + 68, 24, 3);
    v12 = v39[0];
    *v11 = v10;
    v11[1] = v12;
    v11[2] = 0x100000000;
    *v5 = v11;
    v14 = *(this + 24);
    v13 = *(this + 25);
    if (v14 >= v13)
    {
      v16 = *(this + 23);
      v17 = v14 - v16;
      v18 = (v14 - v16) >> 3;
      v19 = v18 + 1;
      if ((v18 + 1) >> 61)
      {
        std::vector<mlir::bytecode::detail::OpNameNumbering *>::__throw_length_error[abi:nn200100]();
      }

      v20 = v13 - v16;
      if (v20 >> 2 > v19)
      {
        v19 = v20 >> 2;
      }

      if (v20 >= 0x7FFFFFFFFFFFFFF8)
      {
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v21 = v19;
      }

      if (v21)
      {
        if (!(v21 >> 61))
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v22 = v18;
      v23 = (8 * v18);
      v24 = &v23[-v22];
      *v23 = v11;
      v15 = v23 + 1;
      memcpy(v24, v16, v17);
      *(this + 23) = v24;
      *(this + 24) = v15;
      *(this + 25) = 0;
      if (v16)
      {
        operator delete(v16);
      }
    }

    else
    {
      *v14 = v11;
      v15 = v14 + 8;
    }

    *(this + 24) = v15;
  }

  v25 = *(a2 + 9);
  if (v25)
  {
    v26 = a2 - 16;
  }

  else
  {
    v26 = 0;
  }

  if (v25)
  {
    v27 = 0;
    v28 = v26;
    while (1)
    {
      v29 = v26;
      if (v27)
      {
        v30 = *(a2 - 1) & 7;
        v31 = a2 - 16;
        v32 = v27;
        if (v30 == 6)
        {
          goto LABEL_32;
        }

        v33 = (5 - v30);
        v29 = v28;
        v32 = v27 - v33;
        if (v27 > v33)
        {
          break;
        }
      }

LABEL_33:
      v41 = v29;
      v34 = *(this + 232);
      *(this + 232) = v34 + 1;
      v40 = v34;
      llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::try_emplace<unsigned int>(v39, this + 856, &v41, &v40);
      mlir::bytecode::detail::IRNumberingState::number(this, (*(v41 + 1) & 0xFFFFFFFFFFFFFFF8));
      ++v27;
      v28 -= 16;
      if (v25 == v27)
      {
        goto LABEL_34;
      }
    }

    v31 = &v26[-16 * v33];
LABEL_32:
    v29 = &v31[-24 * v32];
    goto LABEL_33;
  }

LABEL_34:
  if (***(this + 117) <= 4)
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(a2);
  }

  else
  {
    AttrDictionary = *(a2 + 7);
  }

  if (AttrDictionary[2])
  {
    mlir::bytecode::detail::IRNumberingState::number(this, AttrDictionary);
  }

  if (***(this + 117) >= 5 && HIBYTE(*(a2 + 11)))
  {
    if (*(*(a2 + 6) + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v38 = *(a2 + 2 * ((*(a2 + 11) >> 23) & 1) + 8);
      if (v38)
      {
        mlir::bytecode::detail::IRNumberingState::number(this, v38);
      }
    }

    else
    {
      InterfaceFor = mlir::OpInterface<mlir::BytecodeOpInterface,mlir::detail::BytecodeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
      v37 = **(this + 117) + 16;
      v39[0] = &unk_286EAA448;
      v39[1] = this;
      v39[2] = v37;
      (*(InterfaceFor + 8))(InterfaceFor, a2, v39);
    }
  }

  mlir::bytecode::detail::IRNumberingState::number(this, *(a2 + 3));
}

void mlir::bytecode::detail::IRNumberingState::number(uint64_t a1, uint64_t *a2)
{
  v33 = a2;
  v34 = a2;
  v35 = 0;
  v31[0] = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::LookupBucketFor<mlir::Attribute>(a1, &v34, v31))
  {
    ++*(v31[0][1] + 12);
    return;
  }

  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>,mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,mlir::bytecode::detail::AttributeNumbering *>>::InsertIntoBucketImpl<mlir::Attribute>(a1, &v34, v31[0]);
  *v4 = v34;
  v4[1] = v35;
  v5 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((a1 + 256), 24, 3);
  v6 = v5;
  *v5 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  v5[1] = 0x100000000;
  v5[2] = 0;
  v4[1] = v5;
  v8 = *(a1 + 168);
  v7 = *(a1 + 176);
  if (v8 >= v7)
  {
    v10 = *(a1 + 160);
    v11 = v8 - v10;
    v12 = (v8 - v10) >> 3;
    v13 = v12 + 1;
    if ((v12 + 1) >> 61)
    {
      std::vector<mlir::bytecode::detail::AttributeNumbering *>::__throw_length_error[abi:nn200100]();
    }

    v14 = v7 - v10;
    if (v14 >> 2 > v13)
    {
      v13 = v14 >> 2;
    }

    if (v14 >= 0x7FFFFFFFFFFFFFF8)
    {
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v13;
    }

    if (v15)
    {
      if (!(v15 >> 61))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v16 = (v8 - v10) >> 3;
    v17 = (8 * v12);
    v18 = (8 * v12 - 8 * v16);
    *v17 = v5;
    v9 = v17 + 1;
    memcpy(v18, v10, v11);
    *(a1 + 160) = v18;
    *(a1 + 168) = v9;
    *(a1 + 176) = 0;
    if (v10)
    {
      operator delete(v10);
    }
  }

  else
  {
    *v8 = v5;
    v9 = v8 + 8;
  }

  *(a1 + 168) = v9;
  if (*(*a2 + 136) == &mlir::detail::TypeIDResolver<mlir::OpaqueAttr,void>::id)
  {
    v27 = a2[1];
    v28 = *(v27 + 16);
    v29 = *(v27 + 24);
LABEL_26:
    mlir::bytecode::detail::IRNumberingState::numberDialect(a1, v28, v29);
    v6[2] = v30;
    return;
  }

  v6[2] = mlir::bytecode::detail::IRNumberingState::numberDialect(a1, **a2);
  if (mlir::Attribute::hasTrait<mlir::AttributeTrait::IsMutable>(&v33))
  {
    goto LABEL_24;
  }

  v19 = **(a1 + 936);
  v20 = *(v19 + 64);
  if (!v20)
  {
LABEL_22:
    v24 = *(v6[2] + 24);
    if (v24)
    {
      v25 = **(a1 + 936) + 16;
      v34 = &unk_286EAA448;
      v35 = a1;
      *&v36 = v25;
      if ((*(*v24 + 32))(v24, v33, &v34))
      {
        return;
      }
    }

LABEL_24:
    v26 = *(**v33 + 32);
    mlir::OpPrintingFlags::OpPrintingFlags(&v34);
    operator new();
  }

  v21 = *(v19 + 56);
  v22 = 8 * v20;
  while (1)
  {
    v23 = **(a1 + 936) + 16;
    v34 = &unk_286EAA448;
    v35 = a1;
    *&v36 = v23;
    LOBYTE(v31[0]) = 0;
    LOBYTE(v32) = 0;
    if ((*(**v21 + 16))(*v21, v33, v31, &v34))
    {
      break;
    }

    ++v21;
    v22 -= 8;
    if (!v22)
    {
      goto LABEL_22;
    }
  }

  if (v32 == 1)
  {
    v28 = v31[0];
    v29 = v31[1];
    goto LABEL_26;
  }
}

{
  v33 = a2;
  v34 = a2;
  v35 = 0;
  v31[0] = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::LookupBucketFor<mlir::Type>((a1 + 72), &v34, v31))
  {
    ++*(v31[0][1] + 12);
    return;
  }

  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>,mlir::Type,mlir::bytecode::detail::TypeNumbering *,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::bytecode::detail::TypeNumbering *>>::InsertIntoBucketImpl<mlir::Type>(a1 + 72, &v34, v31[0]);
  *v4 = v34;
  v4[1] = v35;
  v5 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((a1 + 736), 24, 3);
  v6 = v5;
  *v5 = a2 | 4;
  v5[1] = 0x100000000;
  v5[2] = 0;
  v4[1] = v5;
  v8 = *(a1 + 216);
  v7 = *(a1 + 224);
  if (v8 >= v7)
  {
    v10 = *(a1 + 208);
    v11 = v8 - v10;
    v12 = (v8 - v10) >> 3;
    v13 = v12 + 1;
    if ((v12 + 1) >> 61)
    {
      std::vector<mlir::bytecode::detail::TypeNumbering *>::__throw_length_error[abi:nn200100]();
    }

    v14 = v7 - v10;
    if (v14 >> 2 > v13)
    {
      v13 = v14 >> 2;
    }

    if (v14 >= 0x7FFFFFFFFFFFFFF8)
    {
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v13;
    }

    if (v15)
    {
      if (!(v15 >> 61))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v16 = (v8 - v10) >> 3;
    v17 = (8 * v12);
    v18 = (8 * v12 - 8 * v16);
    *v17 = v5;
    v9 = v17 + 1;
    memcpy(v18, v10, v11);
    *(a1 + 208) = v18;
    *(a1 + 216) = v9;
    *(a1 + 224) = 0;
    if (v10)
    {
      operator delete(v10);
    }
  }

  else
  {
    *v8 = v5;
    v9 = v8 + 8;
  }

  *(a1 + 216) = v9;
  if (*(*a2 + 136) == &mlir::detail::TypeIDResolver<mlir::OpaqueType,void>::id)
  {
    v27 = a2[1];
    v28 = *(v27 + 16);
    v29 = *(v27 + 24);
LABEL_26:
    mlir::bytecode::detail::IRNumberingState::numberDialect(a1, v28, v29);
    v6[2] = v30;
    return;
  }

  v6[2] = mlir::bytecode::detail::IRNumberingState::numberDialect(a1, **a2);
  if (mlir::Type::hasTrait<mlir::TypeTrait::IsMutable>(&v33))
  {
    goto LABEL_24;
  }

  v19 = **(a1 + 936);
  v20 = *(v19 + 128);
  if (!v20)
  {
LABEL_22:
    v24 = *(v6[2] + 24);
    if (v24)
    {
      v25 = **(a1 + 936) + 16;
      v34 = &unk_286EAA448;
      v35 = a1;
      *&v36 = v25;
      if ((*(*v24 + 40))(v24, v33, &v34))
      {
        return;
      }
    }

LABEL_24:
    v26 = *(**v33 + 32);
    mlir::OpPrintingFlags::OpPrintingFlags(&v34);
    operator new();
  }

  v21 = *(v19 + 120);
  v22 = 8 * v20;
  while (1)
  {
    v23 = **(a1 + 936) + 16;
    v34 = &unk_286EAA448;
    v35 = a1;
    *&v36 = v23;
    LOBYTE(v31[0]) = 0;
    LOBYTE(v32) = 0;
    if ((*(**v21 + 16))(*v21, v33, v31, &v34))
    {
      break;
    }

    ++v21;
    v22 -= 8;
    if (!v22)
    {
      goto LABEL_22;
    }
  }

  if (v32 == 1)
  {
    v28 = v31[0];
    v29 = v31[1];
    goto LABEL_26;
  }
}

double mlir::bytecode::detail::IRNumberingState::numberDialect(uint64_t a1, void *a2, void *a3)
{
  *&v24 = a2;
  *(&v24 + 1) = a3;
  v25 = 0;
  v7 = a1 + 120;
  v6 = *(a1 + 120);
  v23[0] = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(v6, *(v7 + 16), &v24, v23))
  {
    v9 = *(v23[0] + 4);
  }

  else
  {
    v10 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::InsertIntoBucketImpl<llvm::StringRef>(v7, &v24, v23[0]);
    *v10 = v24;
    *(v10 + 4) = 0;
    v11 = a1 + 144;
    v12 = *(a1 + 144);
    v23[0] = a2;
    v23[1] = a3;
    v23[2] = 0;
    v13 = *(a1 + 152);
    v14 = v23;
    if (v13 >= *(a1 + 156))
    {
      if (v12 <= v23 && v12 + 24 * v13 > v23)
      {
        v21 = v23 - v12;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (a1 + 160), v13 + 1, 24);
        v12 = *(a1 + 144);
        v14 = &v21[v12];
      }

      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (a1 + 160), v13 + 1, 24);
        v12 = *(a1 + 144);
        v14 = v23;
      }
    }

    v15 = v12 + 24 * *(a1 + 152);
    v8 = *v14;
    *(v15 + 16) = *(v14 + 2);
    *v15 = v8;
    v9 = *(a1 + 152);
    *(a1 + 152) = v9 + 1;
    *(v10 + 4) = v9;
  }

  v16 = *(a1 + 144) + 24 * v9;
  v18 = *(v16 + 16);
  v17 = (v16 + 16);
  if (!v18)
  {
    v19 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((a1 + 352), 120, 3);
    v20 = *(a1 + 152) - 1;
    *v19 = a2;
    *(v19 + 8) = a3;
    *(v19 + 16) = v20;
    *(v19 + 56) = 0;
    *&v8 = 0;
    *(v19 + 40) = 0u;
    *(v19 + 24) = 0u;
    *(v19 + 80) = 0;
    *(v19 + 96) = 0;
    *(v19 + 88) = 0;
    *(v19 + 64) = v19 + 80;
    *(v19 + 72) = 0;
    *(v19 + 104) = v19 + 120;
    *(v19 + 112) = 0;
    *v17 = v19;
  }

  return *&v8;
}

uint64_t mlir::bytecode::detail::IRNumberingState::numberDialect(mlir::bytecode::detail::IRNumberingState *this, mlir::Dialect *a2)
{
  v5 = this + 96;
  v4 = *(this + 12);
  v14 = 0;
  v6 = llvm::DenseMapBase<llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>,mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::LookupBucketFor<mlir::Dialect *>(v4, *(v5 + 4), a2, &v14);
  v7 = v14;
  if (v6)
  {
    result = v14[1];
    if (result)
    {
      return result;
    }

    goto LABEL_9;
  }

  v15 = v14;
  v9 = *(this + 26);
  v10 = *(this + 28);
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
    goto LABEL_16;
  }

  if (v10 + ~v9 - *(this + 27) <= v10 >> 3)
  {
LABEL_16:
    llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::grow(v5, v10);
    llvm::DenseMapBase<llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>,mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::LookupBucketFor<mlir::Dialect *>(*(this + 12), *(this + 28), a2, &v15);
    v9 = *(this + 26);
    v7 = v15;
  }

  *(this + 26) = v9 + 1;
  if (*v7 != -4096)
  {
    --*(this + 27);
  }

  *v7 = a2;
  v7[1] = 0;
LABEL_9:
  mlir::bytecode::detail::IRNumberingState::numberDialect(this, *(a2 + 1), *(a2 + 2));
  v7[1] = v11;
  v12 = mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>(a2);
  if (v12)
  {
    v12 = mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>(a2);
  }

  *(v7[1] + 24) = v12;
  v13 = mlir::Dialect::getRegisteredInterface<mlir::OpAsmDialectInterface>(a2);
  if (v13)
  {
    v13 = mlir::Dialect::getRegisteredInterface<mlir::OpAsmDialectInterface>(a2);
  }

  *(v7[1] + 32) = v13;
  return v7[1];
}

uint64_t mlir::bytecode::detail::IRNumberingState::number(uint64_t a1, mlir::Dialect *a2, void *a3, uint64_t a4)
{
  result = mlir::bytecode::detail::IRNumberingState::numberDialect(a1, a2);
  if (a4)
  {
    v8 = result;
    v9 = 24 * a4;
    do
    {
      result = llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>::insert(v8 + 40, a3);
      if (!result)
      {
        break;
      }

      v10 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((a1 + 640), 32, 3);
      (*(**(v8 + 32) + 40))(&v20);
      v11 = v20;
      *(v10 + 16) = v21;
      *v10 = v11;
      v21 = 0;
      v19 = v10;
      v20 = 0uLL;
      *(v10 + 24) = 0;
      *(v10 + 28) = 1;
      v12 = *(v10 + 23);
      v13 = *v10;
      if (v12 >= 0)
      {
        v13 = v10;
      }

      if (v12 < 0)
      {
        v12 = *(v10 + 8);
      }

      *&v18 = v13;
      *(&v18 + 1) = v12;
      v22 = v18;
      v23 = 0;
      v24 = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(*(v8 + 80), *(v8 + 96), &v22, &v24) & 1) == 0)
      {
        v14 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::InsertIntoBucketImpl<llvm::StringRef>(v8 + 80, &v22, v24);
        *v14 = v18;
        *(v14 + 4) = 0;
        v15 = *(v8 + 112);
        *(v14 + 4) = v15;
        if (v15 >= *(v8 + 116))
        {
          llvm::SmallVectorTemplateBase<std::pair<llvm::StringRef,mlir::bytecode::detail::DialectResourceNumbering *>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::StringRef&&>,std::tuple<mlir::bytecode::detail::DialectResourceNumbering *&&>>(v8 + 104, &v18, v10);
        }

        else
        {
          v16 = *(v8 + 104) + 24 * v15;
          *v16 = v18;
          *(v16 + 16) = v10;
          ++*(v8 + 112);
        }
      }

      *&v22 = 0;
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::LookupBucketFor<mlir::AsmDialectResourceHandle>((a1 + 232), a3, &v22);
      if ((result & 1) == 0)
      {
        result = llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>,mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseMapPair<mlir::AsmDialectResourceHandle,mlir::bytecode::detail::DialectResourceNumbering *>>::InsertIntoBucketImpl<mlir::AsmDialectResourceHandle>(a1 + 232, a3, v22);
        v17 = a3[2];
        *result = *a3;
        *(result + 16) = v17;
        *(result + 24) = v10;
      }

      a3 += 3;
      v9 -= 24;
    }

    while (v9);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::try_emplace<unsigned int>(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  v12 = 0;
  result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a2, a3, &v12);
  v9 = v12;
  if (result)
  {
    v10 = 0;
  }

  else
  {
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::InsertIntoBucketImpl<mlir::Value>(a2, a3, v12);
    v9 = result;
    *result = *a3;
    *(result + 8) = *a4;
    v10 = 1;
  }

  v11 = *a2 + 16 * *(a2 + 16);
  *a1 = v9;
  *(a1 + 8) = v11;
  *(a1 + 16) = v10;
  return result;
}

void llvm::SmallVectorImpl<std::pair<mlir::Region *,unsigned int>>::emplace_back<mlir::Region *,unsigned int &>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v3 = *(a1 + 8);
  if (v3 >= *(a1 + 12))
  {
    llvm::SmallVectorTemplateBase<std::pair<mlir::Region *,unsigned int>,true>::push_back(a1, a2, a3);
  }

  else
  {
    v4 = *a1 + 16 * v3;
    *v4 = a2;
    *(v4 + 8) = a3;
    *(a1 + 8) = v3 + 1;
  }
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::Region *,unsigned int>,true>::push_back(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 8);
  if (v6 >= *(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v6 + 1, 16);
    LODWORD(v6) = *(a1 + 8);
  }

  v7 = (*a1 + 16 * v6);
  *v7 = a2;
  v7[1] = a3;
  ++*(a1 + 8);
}

void mlir::bytecode::detail::IRNumberingState::NumberingDialectWriter::writeOptionalAttribute(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    mlir::bytecode::detail::IRNumberingState::number(*(a1 + 8), a2);
  }
}

uint64_t mlir::bytecode::detail::IRNumberingState::NumberingDialectWriter::getDialectVersion(uint64_t a1, unsigned __int8 *a2, const unsigned __int8 *a3)
{
  v6 = *(a1 + 16);
  v7 = llvm::xxh3_64bits(a2, a3, a3);
  Key = llvm::StringMapImpl::FindKey(v6, a2, a3, v7);
  if (Key == -1)
  {
    v9 = *(v6 + 8);
  }

  else
  {
    v9 = Key;
  }

  v10 = *v6 + 8 * v9;
  if (**(a1 + 16) + 8 * *(*(a1 + 16) + 8) == v10)
  {
    return 0;
  }

  else
  {
    return *(*v10 + 8);
  }
}

uint64_t anonymous namespace::NumberingResourceBuilder::numberEntry(uint64_t result, llvm::hashing::detail::hash_state *a2, size_t a3, unint64_t *a4)
{
  v4 = result;
  v5 = *(result + 8);
  v6 = *(v5 + 96);
  if (v6)
  {
    v9 = *(v5 + 80);
    v10 = v6 - 1;
    v11 = (v6 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(a2, a2 + a3, a3, a4);
    v12 = v9 + 24 * v11;
    result = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(a2, a3, *v12, *(v12 + 8));
    if (result)
    {
      goto LABEL_8;
    }

    v13 = 1;
    while (*v12 != -1)
    {
      v14 = v13 + 1;
      v11 = (v11 + v13) & v10;
      v12 = v9 + 24 * v11;
      result = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(a2, a3, *v12, *(v12 + 8));
      v13 = v14;
      if (result)
      {
        goto LABEL_8;
      }
    }
  }

  v12 = 0;
LABEL_8:
  v15 = v12 == *(v5 + 80) + 24 * *(v5 + 96) || v12 == 0;
  v16 = (v12 + 16);
  if (v15)
  {
    v16 = (v5 + 112);
  }

  v17 = *(v5 + 104) + 24 * *v16;
  if (v17 != *(*(v4 + 8) + 104) + 24 * *(*(v4 + 8) + 112))
  {
    v18 = *(v4 + 16);
    v19 = (*v18)++;
    v20 = *(v17 + 16);
    *(v20 + 24) = v19;
    *(v20 + 28) = 0;
  }

  return result;
}

char *std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    v6 = result;
    if (a3 == 2)
    {
      v7 = *(a2 - 1);
      v8 = *result;
      if (*(v7 + 12) > *(*result + 12))
      {
        *result = v7;
        *(a2 - 1) = v8;
      }
    }

    else if (a3 > 128)
    {
      v19 = a4;
      v20 = a3 >> 1;
      v21 = &result[8 * (a3 >> 1)];
      v22 = a3 >> 1;
      if (a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(result, v21, v22, a4);
        v23 = (v19 + 8 * v20);
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        v24 = v19 + 8 * a3;
        v25 = v23;
        while (v25 != v24)
        {
          v26 = *v25;
          v27 = *(*v25 + 12);
          v28 = *(*v19 + 12);
          v29 = v27 > v28;
          v30 = v27 <= v28;
          v31 = v29;
          if (!v29)
          {
            v26 = *v19;
          }

          v19 += 8 * v30;
          v25 += v31;
          *v6 = v26;
          v6 += 8;
          if (v19 == v23)
          {
            while (v25 != v24)
            {
              v33 = *v25++;
              *v6 = v33;
              v6 += 8;
            }

            return result;
          }
        }

        while (v19 != v23)
        {
          v32 = *v19;
          v19 += 8;
          *v6 = v32;
          v6 += 8;
        }
      }

      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(result, v21, v22, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);

        return std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }

    else if (result != a2)
    {
      v10 = result + 8;
      if (result + 8 != a2)
      {
        v11 = 0;
        v12 = result;
        do
        {
          v13 = *v12;
          v12 = v10;
          v14 = *v10;
          v15 = *(v14 + 12);
          if (v15 > *(v13 + 12))
          {
            v16 = v11;
            while (1)
            {
              *&result[v16 + 8] = v13;
              if (!v16)
              {
                break;
              }

              v13 = *&result[v16 - 8];
              v16 -= 8;
              if (v15 <= *(v13 + 12))
              {
                v17 = &result[v16 + 8];
                goto LABEL_16;
              }
            }

            v17 = result;
LABEL_16:
            *v17 = v14;
          }

          v10 = v12 + 8;
          v11 += 8;
        }

        while (v12 + 8 != a2);
      }
    }
  }

  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *v4 = *v6;
      return result;
    }

    if (a3 == 2)
    {
      v8 = *(a2 - 8);
      v9 = *(v8 + 12);
      v10 = *(*result + 12);
      if (v9 <= v10)
      {
        v8 = *result;
      }

      *a4 = v8;
      v4 = a4 + 1;
      if (v9 <= v10)
      {
        v6 = a2 - 8;
      }

      goto LABEL_8;
    }

    if (a3 > 8)
    {
      v20 = result + 8 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(result, v20, a3 >> 1, a4, a3 >> 1);
      result = std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v21 = v6 + 8 * (a3 >> 1);
      while (v21 != a2)
      {
        v22 = *v21;
        v23 = *(*v21 + 12);
        v24 = *(*v6 + 12);
        v25 = v23 > v24;
        v26 = v23 <= v24;
        v27 = v25;
        if (!v25)
        {
          v22 = *v6;
        }

        v21 += 8 * v27;
        v6 += 8 * v26;
        *v4++ = v22;
        if (v6 == v20)
        {
          while (v21 != a2)
          {
            v29 = *v21;
            v21 += 8;
            *v4++ = v29;
          }

          return result;
        }
      }

      while (v6 != v20)
      {
        v28 = *v6;
        v6 += 8;
        *v4++ = v28;
      }
    }

    else if (result != a2)
    {
      v11 = result + 8;
      *a4 = *result;
      if (result + 8 != a2)
      {
        v12 = 0;
        v13 = a4;
        v14 = a4;
        do
        {
          v16 = *v14++;
          v15 = v16;
          if (*(*v11 + 12) <= *(v16 + 12))
          {
            *v14 = *v11;
          }

          else
          {
            v13[1] = v15;
            v17 = a4;
            if (v13 != a4)
            {
              v18 = v12;
              while (1)
              {
                v17 = (a4 + v18);
                v19 = *(a4 + v18 - 8);
                if (*(*v11 + 12) <= *(v19 + 12))
                {
                  break;
                }

                *v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  v17 = a4;
                  break;
                }
              }
            }

            *v17 = *v11;
          }

          v11 += 8;
          v12 += 8;
          v13 = v14;
        }

        while (v11 != a2);
      }
    }
  }

  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a5)
  {
    v7 = a5;
    v10 = result;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4)
      {
        return result;
      }

      v11 = 0;
      v12 = -a4;
      while (1)
      {
        v13 = *&v10[v11];
        if (*(*a2 + 12) > *(v13 + 12))
        {
          break;
        }

        v11 += 8;
        if (__CFADD__(v12++, 1))
        {
          return result;
        }
      }

      v15 = -v12;
      v16 = &v10[v11];
      if (-v12 >= v7)
      {
        if (v12 == -1)
        {
          *&v10[v11] = *a2;
          *a2 = v13;
          return result;
        }

        v25 = v15 / 2;
        v26 = &v10[8 * (v15 / 2)];
        v18 = a2;
        if (a2 != a3)
        {
          v27 = (a3 - a2) >> 3;
          v18 = a2;
          do
          {
            v28 = v27 >> 1;
            v29 = &v18[8 * (v27 >> 1)];
            v31 = *v29;
            v30 = v29 + 8;
            v27 += ~(v27 >> 1);
            if (*(v31 + 12) > *(*&v26[v11] + 12))
            {
              v18 = v30;
            }

            else
            {
              v27 = v28;
            }
          }

          while (v27);
        }

        v17 = (v18 - a2) >> 3;
        v19 = &v26[v11];
      }

      else
      {
        v17 = v7 / 2;
        v18 = &a2[8 * (v7 / 2)];
        v19 = a2;
        if (a2 - v10 != v11)
        {
          v20 = (a2 - v10 - v11) >> 3;
          v19 = &v10[v11];
          do
          {
            v21 = v20 >> 1;
            v22 = &v19[8 * (v20 >> 1)];
            v24 = *v22;
            v23 = v22 + 8;
            v20 += ~(v20 >> 1);
            if (*(*v18 + 12) > *(v24 + 12))
            {
              v20 = v21;
            }

            else
            {
              v19 = v23;
            }
          }

          while (v20);
        }

        v25 = (v19 - v10 - v11) >> 3;
      }

      v32 = v18;
      v33 = a2 - v19;
      if (a2 != v19)
      {
        v32 = v19;
        v34 = v18 - a2;
        if (v18 != a2)
        {
          if (v19 + 8 == a2)
          {
            v80 = *v19;
            v81 = v17;
            v83 = a7;
            v85 = a6;
            v35 = a3;
            v36 = v25;
            memmove(v19, a2, v18 - a2);
            v25 = v36;
            v17 = v81;
            a7 = v83;
            v16 = &v10[v11];
            a3 = v35;
            a6 = v85;
            v32 = &v19[v34];
            *&v19[v34] = v80;
          }

          else if (a2 + 8 == v18)
          {
            v37 = *(v18 - 1);
            v32 = v19 + 8;
            if (v18 - 8 != v19)
            {
              v84 = a7;
              v86 = a6;
              v38 = a3;
              v82 = v17;
              v39 = v25;
              memmove(v19 + 8, v19, v18 - 8 - v19);
              v25 = v39;
              v16 = &v10[v11];
              v17 = v82;
              a7 = v84;
              a6 = v86;
              a3 = v38;
            }

            *v19 = v37;
          }

          else
          {
            v40 = v33 >> 3;
            if (v33 >> 3 == v34 >> 3)
            {
              v41 = v19 + 8;
              v42 = a2 + 8;
              do
              {
                v43 = *(v41 - 1);
                *(v41 - 1) = *(v42 - 1);
                *(v42 - 1) = v43;
                if (v41 == a2)
                {
                  break;
                }

                v41 += 8;
                v44 = v42 == v18;
                v42 += 8;
              }

              while (!v44);
              v32 = a2;
            }

            else
            {
              v45 = v34 >> 3;
              v46 = v33 >> 3;
              do
              {
                v47 = v46;
                v46 = v45;
                v45 = v47 % v45;
              }

              while (v45);
              v48 = &v19[8 * v46];
              do
              {
                v50 = *(v48 - 1);
                v48 -= 8;
                v49 = v50;
                v51 = &v48[v33];
                v52 = v48;
                do
                {
                  v53 = v51;
                  *v52 = *v51;
                  v54 = &v51[8 * v40];
                  v55 = __OFSUB__(v40, (v18 - v51) >> 3);
                  v56 = v40 - ((v18 - v51) >> 3);
                  v75 = (v56 < 0) ^ v55;
                  v51 = &v19[8 * v56];
                  if (v75)
                  {
                    v51 = v54;
                  }

                  v52 = v53;
                }

                while (v51 != v48);
                *v53 = v49;
              }

              while (v48 != v19);
              v32 = &v19[v34];
            }
          }
        }
      }

      a4 = -(v25 + v12);
      v57 = v7 - v17;
      if (v25 + v17 >= v7 - (v25 + v17) - v12)
      {
        v62 = v25;
        v63 = -(v25 + v12);
        v64 = v17;
        v59 = a6;
        v60 = a7;
        v10 = v16;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v32, v18, a3, v63, v57);
        v18 = v19;
        v57 = v64;
        a4 = v62;
        a3 = v32;
      }

      else
      {
        v58 = &v10[v11];
        v59 = a6;
        v60 = a7;
        v61 = a3;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::AttributeNumbering **>>(v58, v19, v32, v25, v17);
        a3 = v61;
        v10 = v32;
      }

      v7 = v57;
      a2 = v18;
      a6 = v59;
      a7 = v60;
      if (!v57)
      {
        return result;
      }
    }

    if (a4 <= v7)
    {
      if (a2 != v10)
      {
        v68 = -a6;
        v69 = a6;
        v70 = v10;
        do
        {
          v71 = *v70;
          v70 += 8;
          *v69++ = v71;
          v68 -= 8;
        }

        while (v70 != a2);
        while (a2 != a3)
        {
          v72 = *a2;
          v73 = *(*a2 + 12);
          v74 = *(*a6 + 12);
          v75 = v73 > v74;
          v76 = v73 <= v74;
          if (v75)
          {
            v77 = 1;
          }

          else
          {
            v77 = 0;
          }

          if (!v75)
          {
            v72 = *a6;
          }

          a2 += 8 * v77;
          a6 += 8 * v76;
          *v10 = v72;
          v10 += 8;
          if (v69 == a6)
          {
            return result;
          }
        }

        return memmove(v10, a6, -(a6 + v68));
      }
    }

    else if (a2 != a3)
    {
      v65 = 0;
      do
      {
        *(a6 + v65) = *&a2[v65];
        v65 += 8;
      }

      while (&a2[v65] != a3);
      v66 = (a6 + v65);
      while (a2 != v10)
      {
        v67 = *(v66 - 1);
        if (*(v67 + 12) <= *(*(a2 - 1) + 12))
        {
          v66 -= 8;
        }

        else
        {
          v67 = *(a2 - 1);
          a2 -= 8;
        }

        *(a3 - 1) = v67;
        a3 -= 8;
        if (v66 == a6)
        {
          return result;
        }
      }

      if (v66 != a6)
      {
        v78 = -8;
        do
        {
          v79 = *(v66 - 1);
          v66 -= 8;
          *&a3[v78] = v79;
          v78 -= 8;
        }

        while (v66 != a6);
      }
    }
  }

  return result;
}

char *std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    v6 = result;
    if (a3 == 2)
    {
      v7 = *(a2 - 1);
      v8 = *result;
      if (*(v7 + 20) > *(*result + 20))
      {
        *result = v7;
        *(a2 - 1) = v8;
      }
    }

    else if (a3 > 128)
    {
      v19 = a4;
      v20 = a3 >> 1;
      v21 = &result[8 * (a3 >> 1)];
      v22 = a3 >> 1;
      if (a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(result, v21, v22, a4);
        v23 = (v19 + 8 * v20);
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        v24 = v19 + 8 * a3;
        v25 = v23;
        while (v25 != v24)
        {
          v26 = *v25;
          v27 = *(*v25 + 20);
          v28 = *(*v19 + 20);
          v29 = v27 > v28;
          v30 = v27 <= v28;
          v31 = v29;
          if (!v29)
          {
            v26 = *v19;
          }

          v19 += 8 * v30;
          v25 += v31;
          *v6 = v26;
          v6 += 8;
          if (v19 == v23)
          {
            while (v25 != v24)
            {
              v33 = *v25++;
              *v6 = v33;
              v6 += 8;
            }

            return result;
          }
        }

        while (v19 != v23)
        {
          v32 = *v19;
          v19 += 8;
          *v6 = v32;
          v6 += 8;
        }
      }

      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(result, v21, v22, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);

        return std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }

    else if (result != a2)
    {
      v10 = result + 8;
      if (result + 8 != a2)
      {
        v11 = 0;
        v12 = result;
        do
        {
          v13 = *v12;
          v12 = v10;
          v14 = *v10;
          v15 = *(v14 + 20);
          if (v15 > *(v13 + 20))
          {
            v16 = v11;
            while (1)
            {
              *&result[v16 + 8] = v13;
              if (!v16)
              {
                break;
              }

              v13 = *&result[v16 - 8];
              v16 -= 8;
              if (v15 <= *(v13 + 20))
              {
                v17 = &result[v16 + 8];
                goto LABEL_16;
              }
            }

            v17 = result;
LABEL_16:
            *v17 = v14;
          }

          v10 = v12 + 8;
          v11 += 8;
        }

        while (v12 + 8 != a2);
      }
    }
  }

  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *v4 = *v6;
      return result;
    }

    if (a3 == 2)
    {
      v8 = *(a2 - 8);
      v9 = *(v8 + 20);
      v10 = *(*result + 20);
      if (v9 <= v10)
      {
        v8 = *result;
      }

      *a4 = v8;
      v4 = a4 + 1;
      if (v9 <= v10)
      {
        v6 = a2 - 8;
      }

      goto LABEL_8;
    }

    if (a3 > 8)
    {
      v20 = result + 8 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(result, v20, a3 >> 1, a4, a3 >> 1);
      result = std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v21 = v6 + 8 * (a3 >> 1);
      while (v21 != a2)
      {
        v22 = *v21;
        v23 = *(*v21 + 20);
        v24 = *(*v6 + 20);
        v25 = v23 > v24;
        v26 = v23 <= v24;
        v27 = v25;
        if (!v25)
        {
          v22 = *v6;
        }

        v21 += 8 * v27;
        v6 += 8 * v26;
        *v4++ = v22;
        if (v6 == v20)
        {
          while (v21 != a2)
          {
            v29 = *v21;
            v21 += 8;
            *v4++ = v29;
          }

          return result;
        }
      }

      while (v6 != v20)
      {
        v28 = *v6;
        v6 += 8;
        *v4++ = v28;
      }
    }

    else if (result != a2)
    {
      v11 = result + 8;
      *a4 = *result;
      if (result + 8 != a2)
      {
        v12 = 0;
        v13 = a4;
        v14 = a4;
        do
        {
          v16 = *v14++;
          v15 = v16;
          if (*(*v11 + 20) <= *(v16 + 20))
          {
            *v14 = *v11;
          }

          else
          {
            v13[1] = v15;
            v17 = a4;
            if (v13 != a4)
            {
              v18 = v12;
              while (1)
              {
                v17 = (a4 + v18);
                v19 = *(a4 + v18 - 8);
                if (*(*v11 + 20) <= *(v19 + 20))
                {
                  break;
                }

                *v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  v17 = a4;
                  break;
                }
              }
            }

            *v17 = *v11;
          }

          v11 += 8;
          v12 += 8;
          v13 = v14;
        }

        while (v11 != a2);
      }
    }
  }

  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a5)
  {
    v7 = a5;
    v10 = result;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4)
      {
        return result;
      }

      v11 = 0;
      v12 = -a4;
      while (1)
      {
        v13 = *&v10[v11];
        if (*(*a2 + 20) > *(v13 + 20))
        {
          break;
        }

        v11 += 8;
        if (__CFADD__(v12++, 1))
        {
          return result;
        }
      }

      v15 = -v12;
      v16 = &v10[v11];
      if (-v12 >= v7)
      {
        if (v12 == -1)
        {
          *&v10[v11] = *a2;
          *a2 = v13;
          return result;
        }

        v25 = v15 / 2;
        v26 = &v10[8 * (v15 / 2)];
        v18 = a2;
        if (a2 != a3)
        {
          v27 = (a3 - a2) >> 3;
          v18 = a2;
          do
          {
            v28 = v27 >> 1;
            v29 = &v18[8 * (v27 >> 1)];
            v31 = *v29;
            v30 = v29 + 8;
            v27 += ~(v27 >> 1);
            if (*(v31 + 20) > *(*&v26[v11] + 20))
            {
              v18 = v30;
            }

            else
            {
              v27 = v28;
            }
          }

          while (v27);
        }

        v17 = (v18 - a2) >> 3;
        v19 = &v26[v11];
      }

      else
      {
        v17 = v7 / 2;
        v18 = &a2[8 * (v7 / 2)];
        v19 = a2;
        if (a2 - v10 != v11)
        {
          v20 = (a2 - v10 - v11) >> 3;
          v19 = &v10[v11];
          do
          {
            v21 = v20 >> 1;
            v22 = &v19[8 * (v20 >> 1)];
            v24 = *v22;
            v23 = v22 + 8;
            v20 += ~(v20 >> 1);
            if (*(*v18 + 20) > *(v24 + 20))
            {
              v20 = v21;
            }

            else
            {
              v19 = v23;
            }
          }

          while (v20);
        }

        v25 = (v19 - v10 - v11) >> 3;
      }

      v32 = v18;
      v33 = a2 - v19;
      if (a2 != v19)
      {
        v32 = v19;
        v34 = v18 - a2;
        if (v18 != a2)
        {
          if (v19 + 8 == a2)
          {
            v80 = *v19;
            v81 = v17;
            v83 = a7;
            v85 = a6;
            v35 = a3;
            v36 = v25;
            memmove(v19, a2, v18 - a2);
            v25 = v36;
            v17 = v81;
            a7 = v83;
            v16 = &v10[v11];
            a3 = v35;
            a6 = v85;
            v32 = &v19[v34];
            *&v19[v34] = v80;
          }

          else if (a2 + 8 == v18)
          {
            v37 = *(v18 - 1);
            v32 = v19 + 8;
            if (v18 - 8 != v19)
            {
              v84 = a7;
              v86 = a6;
              v38 = a3;
              v82 = v17;
              v39 = v25;
              memmove(v19 + 8, v19, v18 - 8 - v19);
              v25 = v39;
              v16 = &v10[v11];
              v17 = v82;
              a7 = v84;
              a6 = v86;
              a3 = v38;
            }

            *v19 = v37;
          }

          else
          {
            v40 = v33 >> 3;
            if (v33 >> 3 == v34 >> 3)
            {
              v41 = v19 + 8;
              v42 = a2 + 8;
              do
              {
                v43 = *(v41 - 1);
                *(v41 - 1) = *(v42 - 1);
                *(v42 - 1) = v43;
                if (v41 == a2)
                {
                  break;
                }

                v41 += 8;
                v44 = v42 == v18;
                v42 += 8;
              }

              while (!v44);
              v32 = a2;
            }

            else
            {
              v45 = v34 >> 3;
              v46 = v33 >> 3;
              do
              {
                v47 = v46;
                v46 = v45;
                v45 = v47 % v45;
              }

              while (v45);
              v48 = &v19[8 * v46];
              do
              {
                v50 = *(v48 - 1);
                v48 -= 8;
                v49 = v50;
                v51 = &v48[v33];
                v52 = v48;
                do
                {
                  v53 = v51;
                  *v52 = *v51;
                  v54 = &v51[8 * v40];
                  v55 = __OFSUB__(v40, (v18 - v51) >> 3);
                  v56 = v40 - ((v18 - v51) >> 3);
                  v75 = (v56 < 0) ^ v55;
                  v51 = &v19[8 * v56];
                  if (v75)
                  {
                    v51 = v54;
                  }

                  v52 = v53;
                }

                while (v51 != v48);
                *v53 = v49;
              }

              while (v48 != v19);
              v32 = &v19[v34];
            }
          }
        }
      }

      a4 = -(v25 + v12);
      v57 = v7 - v17;
      if (v25 + v17 >= v7 - (v25 + v17) - v12)
      {
        v62 = v25;
        v63 = -(v25 + v12);
        v64 = v17;
        v59 = a6;
        v60 = a7;
        v10 = v16;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v32, v18, a3, v63, v57);
        v18 = v19;
        v57 = v64;
        a4 = v62;
        a3 = v32;
      }

      else
      {
        v58 = &v10[v11];
        v59 = a6;
        v60 = a7;
        v61 = a3;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::OpNameNumbering **>>(v58, v19, v32, v25, v17);
        a3 = v61;
        v10 = v32;
      }

      v7 = v57;
      a2 = v18;
      a6 = v59;
      a7 = v60;
      if (!v57)
      {
        return result;
      }
    }

    if (a4 <= v7)
    {
      if (a2 != v10)
      {
        v68 = -a6;
        v69 = a6;
        v70 = v10;
        do
        {
          v71 = *v70;
          v70 += 8;
          *v69++ = v71;
          v68 -= 8;
        }

        while (v70 != a2);
        while (a2 != a3)
        {
          v72 = *a2;
          v73 = *(*a2 + 20);
          v74 = *(*a6 + 20);
          v75 = v73 > v74;
          v76 = v73 <= v74;
          if (v75)
          {
            v77 = 1;
          }

          else
          {
            v77 = 0;
          }

          if (!v75)
          {
            v72 = *a6;
          }

          a2 += 8 * v77;
          a6 += 8 * v76;
          *v10 = v72;
          v10 += 8;
          if (v69 == a6)
          {
            return result;
          }
        }

        return memmove(v10, a6, -(a6 + v68));
      }
    }

    else if (a2 != a3)
    {
      v65 = 0;
      do
      {
        *(a6 + v65) = *&a2[v65];
        v65 += 8;
      }

      while (&a2[v65] != a3);
      v66 = (a6 + v65);
      while (a2 != v10)
      {
        v67 = *(v66 - 1);
        if (*(v67 + 20) <= *(*(a2 - 1) + 20))
        {
          v66 -= 8;
        }

        else
        {
          v67 = *(a2 - 1);
          a2 -= 8;
        }

        *(a3 - 1) = v67;
        a3 -= 8;
        if (v66 == a6)
        {
          return result;
        }
      }

      if (v66 != a6)
      {
        v78 = -8;
        do
        {
          v79 = *(v66 - 1);
          v66 -= 8;
          *&a3[v78] = v79;
          v78 -= 8;
        }

        while (v66 != a6);
      }
    }
  }

  return result;
}

char *std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    v6 = result;
    if (a3 == 2)
    {
      v7 = *(a2 - 1);
      v8 = *result;
      if (*(v7 + 12) > *(*result + 12))
      {
        *result = v7;
        *(a2 - 1) = v8;
      }
    }

    else if (a3 > 128)
    {
      v19 = a4;
      v20 = a3 >> 1;
      v21 = &result[8 * (a3 >> 1)];
      v22 = a3 >> 1;
      if (a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(result, v21, v22, a4);
        v23 = (v19 + 8 * v20);
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        v24 = v19 + 8 * a3;
        v25 = v23;
        while (v25 != v24)
        {
          v26 = *v25;
          v27 = *(*v25 + 12);
          v28 = *(*v19 + 12);
          v29 = v27 > v28;
          v30 = v27 <= v28;
          v31 = v29;
          if (!v29)
          {
            v26 = *v19;
          }

          v19 += 8 * v30;
          v25 += v31;
          *v6 = v26;
          v6 += 8;
          if (v19 == v23)
          {
            while (v25 != v24)
            {
              v33 = *v25++;
              *v6 = v33;
              v6 += 8;
            }

            return result;
          }
        }

        while (v19 != v23)
        {
          v32 = *v19;
          v19 += 8;
          *v6 = v32;
          v6 += 8;
        }
      }

      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(result, v21, v22, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);

        return std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }

    else if (result != a2)
    {
      v10 = result + 8;
      if (result + 8 != a2)
      {
        v11 = 0;
        v12 = result;
        do
        {
          v13 = *v12;
          v12 = v10;
          v14 = *v10;
          v15 = *(v14 + 12);
          if (v15 > *(v13 + 12))
          {
            v16 = v11;
            while (1)
            {
              *&result[v16 + 8] = v13;
              if (!v16)
              {
                break;
              }

              v13 = *&result[v16 - 8];
              v16 -= 8;
              if (v15 <= *(v13 + 12))
              {
                v17 = &result[v16 + 8];
                goto LABEL_16;
              }
            }

            v17 = result;
LABEL_16:
            *v17 = v14;
          }

          v10 = v12 + 8;
          v11 += 8;
        }

        while (v12 + 8 != a2);
      }
    }
  }

  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *v4 = *v6;
      return result;
    }

    if (a3 == 2)
    {
      v8 = *(a2 - 8);
      v9 = *(v8 + 12);
      v10 = *(*result + 12);
      if (v9 <= v10)
      {
        v8 = *result;
      }

      *a4 = v8;
      v4 = a4 + 1;
      if (v9 <= v10)
      {
        v6 = a2 - 8;
      }

      goto LABEL_8;
    }

    if (a3 > 8)
    {
      v20 = result + 8 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(result, v20, a3 >> 1, a4, a3 >> 1);
      result = std::__stable_sort<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v21 = v6 + 8 * (a3 >> 1);
      while (v21 != a2)
      {
        v22 = *v21;
        v23 = *(*v21 + 12);
        v24 = *(*v6 + 12);
        v25 = v23 > v24;
        v26 = v23 <= v24;
        v27 = v25;
        if (!v25)
        {
          v22 = *v6;
        }

        v21 += 8 * v27;
        v6 += 8 * v26;
        *v4++ = v22;
        if (v6 == v20)
        {
          while (v21 != a2)
          {
            v29 = *v21;
            v21 += 8;
            *v4++ = v29;
          }

          return result;
        }
      }

      while (v6 != v20)
      {
        v28 = *v6;
        v6 += 8;
        *v4++ = v28;
      }
    }

    else if (result != a2)
    {
      v11 = result + 8;
      *a4 = *result;
      if (result + 8 != a2)
      {
        v12 = 0;
        v13 = a4;
        v14 = a4;
        do
        {
          v16 = *v14++;
          v15 = v16;
          if (*(*v11 + 12) <= *(v16 + 12))
          {
            *v14 = *v11;
          }

          else
          {
            v13[1] = v15;
            v17 = a4;
            if (v13 != a4)
            {
              v18 = v12;
              while (1)
              {
                v17 = (a4 + v18);
                v19 = *(a4 + v18 - 8);
                if (*(*v11 + 12) <= *(v19 + 12))
                {
                  break;
                }

                *v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  v17 = a4;
                  break;
                }
              }
            }

            *v17 = *v11;
          }

          v11 += 8;
          v12 += 8;
          v13 = v14;
        }

        while (v11 != a2);
      }
    }
  }

  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a5)
  {
    v7 = a5;
    v10 = result;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4)
      {
        return result;
      }

      v11 = 0;
      v12 = -a4;
      while (1)
      {
        v13 = *&v10[v11];
        if (*(*a2 + 12) > *(v13 + 12))
        {
          break;
        }

        v11 += 8;
        if (__CFADD__(v12++, 1))
        {
          return result;
        }
      }

      v15 = -v12;
      v16 = &v10[v11];
      if (-v12 >= v7)
      {
        if (v12 == -1)
        {
          *&v10[v11] = *a2;
          *a2 = v13;
          return result;
        }

        v25 = v15 / 2;
        v26 = &v10[8 * (v15 / 2)];
        v18 = a2;
        if (a2 != a3)
        {
          v27 = (a3 - a2) >> 3;
          v18 = a2;
          do
          {
            v28 = v27 >> 1;
            v29 = &v18[8 * (v27 >> 1)];
            v31 = *v29;
            v30 = v29 + 8;
            v27 += ~(v27 >> 1);
            if (*(v31 + 12) > *(*&v26[v11] + 12))
            {
              v18 = v30;
            }

            else
            {
              v27 = v28;
            }
          }

          while (v27);
        }

        v17 = (v18 - a2) >> 3;
        v19 = &v26[v11];
      }

      else
      {
        v17 = v7 / 2;
        v18 = &a2[8 * (v7 / 2)];
        v19 = a2;
        if (a2 - v10 != v11)
        {
          v20 = (a2 - v10 - v11) >> 3;
          v19 = &v10[v11];
          do
          {
            v21 = v20 >> 1;
            v22 = &v19[8 * (v20 >> 1)];
            v24 = *v22;
            v23 = v22 + 8;
            v20 += ~(v20 >> 1);
            if (*(*v18 + 12) > *(v24 + 12))
            {
              v20 = v21;
            }

            else
            {
              v19 = v23;
            }
          }

          while (v20);
        }

        v25 = (v19 - v10 - v11) >> 3;
      }

      v32 = v18;
      v33 = a2 - v19;
      if (a2 != v19)
      {
        v32 = v19;
        v34 = v18 - a2;
        if (v18 != a2)
        {
          if (v19 + 8 == a2)
          {
            v80 = *v19;
            v81 = v17;
            v83 = a7;
            v85 = a6;
            v35 = a3;
            v36 = v25;
            memmove(v19, a2, v18 - a2);
            v25 = v36;
            v17 = v81;
            a7 = v83;
            v16 = &v10[v11];
            a3 = v35;
            a6 = v85;
            v32 = &v19[v34];
            *&v19[v34] = v80;
          }

          else if (a2 + 8 == v18)
          {
            v37 = *(v18 - 1);
            v32 = v19 + 8;
            if (v18 - 8 != v19)
            {
              v84 = a7;
              v86 = a6;
              v38 = a3;
              v82 = v17;
              v39 = v25;
              memmove(v19 + 8, v19, v18 - 8 - v19);
              v25 = v39;
              v16 = &v10[v11];
              v17 = v82;
              a7 = v84;
              a6 = v86;
              a3 = v38;
            }

            *v19 = v37;
          }

          else
          {
            v40 = v33 >> 3;
            if (v33 >> 3 == v34 >> 3)
            {
              v41 = v19 + 8;
              v42 = a2 + 8;
              do
              {
                v43 = *(v41 - 1);
                *(v41 - 1) = *(v42 - 1);
                *(v42 - 1) = v43;
                if (v41 == a2)
                {
                  break;
                }

                v41 += 8;
                v44 = v42 == v18;
                v42 += 8;
              }

              while (!v44);
              v32 = a2;
            }

            else
            {
              v45 = v34 >> 3;
              v46 = v33 >> 3;
              do
              {
                v47 = v46;
                v46 = v45;
                v45 = v47 % v45;
              }

              while (v45);
              v48 = &v19[8 * v46];
              do
              {
                v50 = *(v48 - 1);
                v48 -= 8;
                v49 = v50;
                v51 = &v48[v33];
                v52 = v48;
                do
                {
                  v53 = v51;
                  *v52 = *v51;
                  v54 = &v51[8 * v40];
                  v55 = __OFSUB__(v40, (v18 - v51) >> 3);
                  v56 = v40 - ((v18 - v51) >> 3);
                  v75 = (v56 < 0) ^ v55;
                  v51 = &v19[8 * v56];
                  if (v75)
                  {
                    v51 = v54;
                  }

                  v52 = v53;
                }

                while (v51 != v48);
                *v53 = v49;
              }

              while (v48 != v19);
              v32 = &v19[v34];
            }
          }
        }
      }

      a4 = -(v25 + v12);
      v57 = v7 - v17;
      if (v25 + v17 >= v7 - (v25 + v17) - v12)
      {
        v62 = v25;
        v63 = -(v25 + v12);
        v64 = v17;
        v59 = a6;
        v60 = a7;
        v10 = v16;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v32, v18, a3, v63, v57);
        v18 = v19;
        v57 = v64;
        a4 = v62;
        a3 = v32;
      }

      else
      {
        v58 = &v10[v11];
        v59 = a6;
        v60 = a7;
        v61 = a3;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::bytecode::detail::IRNumberingState::IRNumberingState(mlir::Operation *,mlir::BytecodeWriterConfig const&)::$_1 &,std::__wrap_iter<mlir::bytecode::detail::TypeNumbering **>>(v58, v19, v32, v25, v17);
        a3 = v61;
        v10 = v32;
      }

      v7 = v57;
      a2 = v18;
      a6 = v59;
      a7 = v60;
      if (!v57)
      {
        return result;
      }
    }

    if (a4 <= v7)
    {
      if (a2 != v10)
      {
        v68 = -a6;
        v69 = a6;
        v70 = v10;
        do
        {
          v71 = *v70;
          v70 += 8;
          *v69++ = v71;
          v68 -= 8;
        }

        while (v70 != a2);
        while (a2 != a3)
        {
          v72 = *a2;
          v73 = *(*a2 + 12);
          v74 = *(*a6 + 12);
          v75 = v73 > v74;
          v76 = v73 <= v74;
          if (v75)
          {
            v77 = 1;
          }

          else
          {
            v77 = 0;
          }

          if (!v75)
          {
            v72 = *a6;
          }

          a2 += 8 * v77;
          a6 += 8 * v76;
          *v10 = v72;
          v10 += 8;
          if (v69 == a6)
          {
            return result;
          }
        }

        return memmove(v10, a6, -(a6 + v68));
      }
    }

    else if (a2 != a3)
    {
      v65 = 0;
      do
      {
        *(a6 + v65) = *&a2[v65];
        v65 += 8;
      }

      while (&a2[v65] != a3);
      v66 = (a6 + v65);
      while (a2 != v10)
      {
        v67 = *(v66 - 1);
        if (*(v67 + 12) <= *(*(a2 - 1) + 12))
        {
          v66 -= 8;
        }

        else
        {
          v67 = *(a2 - 1);
          a2 -= 8;
        }

        *(a3 - 1) = v67;
        a3 -= 8;
        if (v66 == a6)
        {
          return result;
        }
      }

      if (v66 != a6)
      {
        v78 = -8;
        do
        {
          v79 = *(v66 - 1);
          v66 -= 8;
          *&a3[v78] = v79;
          v78 -= 8;
        }

        while (v66 != a6);
      }
    }
  }

  return result;
}

char *_ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(char *result, char *a2, uint64_t a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 < 2)
  {
    return result;
  }

  v8 = result;
  if (a4 == 2)
  {
    v9 = **(a3 + 8);
    v10 = *(a2 - 1);
    v11 = *(*(v10 + 16) + 16);
    v12 = *result;
    v13 = *(*(*result + 16) + 16);
    if (v11 == v9)
    {
      if (v13 == v9)
      {
        return result;
      }
    }

    else if (v13 == v9 || v11 >= v13)
    {
      return result;
    }

    *result = v10;
    *(a2 - 1) = v12;
    return result;
  }

  if (a4 > 128)
  {
    v33 = a5;
    v34 = a4 >> 1;
    v35 = &result[8 * (a4 >> 1)];
    v36 = a4 >> 1;
    if (a4 > a6)
    {
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v35, a3, v36, a5, a6);
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v33, a6);

      return _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v8, &v8[8 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), v33, a6);
    }

    _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(result, v35, a3, v36, a5);
    v37 = (v33 + 8 * v34);
    result = _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v37);
    v38 = v33 + 8 * a4;
    v39 = v37;
    while (1)
    {
      if (v39 == v38)
      {
        while (v33 != v37)
        {
          v44 = *v33;
          v33 += 8;
          *v8 = v44;
          v8 += 8;
        }

        return result;
      }

      v40 = **(a3 + 8);
      v41 = *(*(*v39 + 16) + 16);
      v42 = *(*(*v33 + 16) + 16);
      if (v41 == v40)
      {
        if (v42 == v40)
        {
          goto LABEL_52;
        }
      }

      else if (v42 == v40 || v41 >= v42)
      {
LABEL_52:
        *v8 = *v33;
        v33 += 8;
        goto LABEL_53;
      }

      *v8 = *v39++;
LABEL_53:
      v8 += 8;
      if (v33 == v37)
      {
        while (v39 != v38)
        {
          v45 = *v39++;
          *v8 = v45;
          v8 += 8;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v15 = result + 8;
  if (result + 8 == a2)
  {
    return result;
  }

  v16 = 0;
  v17 = result;
  do
  {
    v18 = v17;
    v17 = v15;
    v19 = **(a3 + 8);
    v20 = *(v18 + 1);
    v21 = *(*(v20 + 16) + 16);
    v22 = *(*(*v18 + 16) + 16);
    if (v21 == v19)
    {
      if (v22 == v19)
      {
        goto LABEL_31;
      }
    }

    else if (v22 == v19 || v21 >= v22)
    {
      goto LABEL_31;
    }

    *(v18 + 1) = *v18;
    v24 = result;
    if (v18 == result)
    {
      goto LABEL_30;
    }

    v25 = v16;
    while (1)
    {
      v26 = **(a3 + 8);
      v27 = *(*(v20 + 16) + 16);
      v28 = *&result[v25 - 8];
      v29 = *(*(v28 + 16) + 16);
      if (v27 == v26)
      {
        if (v29 == v26)
        {
          v24 = &result[v25];
          goto LABEL_30;
        }

        goto LABEL_27;
      }

      if (v29 == v26 || v27 >= v29)
      {
        break;
      }

LABEL_27:
      v18 -= 8;
      *&result[v25] = v28;
      v25 -= 8;
      if (!v25)
      {
        v24 = result;
        goto LABEL_30;
      }
    }

    v24 = v18;
LABEL_30:
    *v24 = v20;
LABEL_31:
    v15 = v17 + 8;
    v16 += 8;
  }

  while (v17 + 8 != a2);
  return result;
}

uint64_t _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  if (!a4)
  {
    return result;
  }

  v5 = a5;
  v7 = result;
  if (a4 == 1)
  {
LABEL_38:
    *v5 = *v7;
    return result;
  }

  if (a4 == 2)
  {
    v10 = *(a2 - 8);
    v11 = **(a3 + 8);
    v12 = *(*(v10 + 16) + 16);
    v13 = *(*(*result + 16) + 16);
    if (v12 == v11)
    {
      if (v13 != v11)
      {
        goto LABEL_37;
      }
    }

    else if (v13 != v11 && v12 < v13)
    {
      goto LABEL_37;
    }

    v10 = *result;
    v7 = a2 - 8;
LABEL_37:
    *a5 = v10;
    v5 = a5 + 1;
    goto LABEL_38;
  }

  if (a4 > 8)
  {
    v31 = result + 8 * (a4 >> 1);
    _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v31, a3, a4 >> 1, a5, a4 >> 1);
    result = _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v7 + 8 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
    v32 = v7 + 8 * (a4 >> 1);
    while (1)
    {
      if (v32 == a2)
      {
        while (v7 != v31)
        {
          v37 = *v7;
          v7 += 8;
          *v5++ = v37;
        }

        return result;
      }

      v33 = **(a3 + 8);
      v34 = *(*(*v32 + 16) + 16);
      v35 = *(*(*v7 + 16) + 16);
      if (v34 == v33)
      {
        if (v35 == v33)
        {
          goto LABEL_50;
        }
      }

      else if (v35 == v33 || v34 >= v35)
      {
LABEL_50:
        *v5 = *v7;
        v7 += 8;
        goto LABEL_51;
      }

      *v5 = *v32;
      v32 += 8;
LABEL_51:
      ++v5;
      if (v7 == v31)
      {
        while (v32 != a2)
        {
          v38 = *v32;
          v32 += 8;
          *v5++ = v38;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v14 = result + 8;
  *a5 = *result;
  if (result + 8 == a2)
  {
    return result;
  }

  v15 = 0;
  v16 = a5;
  v17 = a5;
  do
  {
    v19 = *v17++;
    v18 = v19;
    v20 = **(a3 + 8);
    v21 = *(*(*v14 + 16) + 16);
    v22 = *(*(v19 + 16) + 16);
    if (v21 == v20)
    {
      if (v22 == v20)
      {
        goto LABEL_29;
      }
    }

    else if (v22 == v20 || v21 >= v22)
    {
LABEL_29:
      *v17 = *v14;
      goto LABEL_32;
    }

    v16[1] = v18;
    v23 = a5;
    if (v16 == a5)
    {
      goto LABEL_31;
    }

    v24 = v15;
    while (1)
    {
      v25 = **(a3 + 8);
      v26 = *(*(*v14 + 16) + 16);
      v27 = *(a5 + v24 - 8);
      v28 = *(*(v27 + 16) + 16);
      if (v26 == v25)
      {
        if (v28 == v25)
        {
          v23 = (a5 + v24);
          goto LABEL_31;
        }

        goto LABEL_22;
      }

      if (v28 == v25 || v26 >= v28)
      {
        break;
      }

LABEL_22:
      --v16;
      *(a5 + v24) = v27;
      v24 -= 8;
      if (!v24)
      {
        v23 = a5;
        goto LABEL_31;
      }
    }

    v23 = v16;
LABEL_31:
    *v23 = *v14;
LABEL_32:
    v14 += 8;
    v15 += 8;
    v16 = v17;
  }

  while (v14 != a2);
  return result;
}

char *_ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a6)
  {
    return result;
  }

  v10 = a6;
  v13 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5)
    {
      return result;
    }

    v14 = **(a4 + 8);
    v15 = *(*(*a2 + 16) + 16);
    while (1)
    {
      v16 = *v13;
      v17 = *(*(*v13 + 16) + 16);
      if (v15 == v14)
      {
        if (v17 != v14)
        {
          break;
        }

        goto LABEL_15;
      }

      if (v17 != v14 && v15 < v17)
      {
        break;
      }

LABEL_15:
      v13 += 8;
      if (!--a5)
      {
        return result;
      }
    }

    __len = a7;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        *v13 = *a2;
        *a2 = v16;
        return result;
      }

      v28 = a5 / 2;
      v23 = &v13[8 * (a5 / 2)];
      v20 = 0;
      if (a3 == a2)
      {
        v34 = a2;
LABEL_45:
        v19 = (v34 - a2) >> 3;
        goto LABEL_46;
      }

      v29 = (a3 - a2) >> 3;
      v30 = *(*(*v23 + 16) + 16);
      while (2)
      {
        v31 = v29 >> 1;
        v32 = v20 + 8 * (v29 >> 1);
        v33 = *(*(*&a2[v32] + 16) + 16);
        if (v33 == v14)
        {
          if (v30 == v14)
          {
            goto LABEL_40;
          }
        }

        else if (v30 == v14 || v33 >= v30)
        {
LABEL_40:
          v29 = v31;
          if (!v31)
          {
            v34 = &a2[v20];
            goto LABEL_45;
          }

          continue;
        }

        break;
      }

      v20 = v32 + 8;
      v31 = v29 + ~v31;
      goto LABEL_40;
    }

    v19 = v10 / 2;
    v20 = 8 * (v10 / 2);
    if (v13 != a2)
    {
      v21 = (a2 - v13) >> 3;
      v22 = *(*(*&a2[v20] + 16) + 16);
      v23 = v13;
      while (1)
      {
        v24 = v21 >> 1;
        v25 = &v23[8 * (v21 >> 1)];
        v26 = *(*(*v25 + 16) + 16);
        if (v22 == v14)
        {
          if (v26 != v14)
          {
            goto LABEL_29;
          }
        }

        else if (v26 != v14 && v22 < v26)
        {
          goto LABEL_29;
        }

        v23 = v25 + 8;
        v24 = v21 + ~v24;
LABEL_29:
        v21 = v24;
        if (!v24)
        {
          goto LABEL_43;
        }
      }
    }

    v23 = v13;
LABEL_43:
    v28 = (v23 - v13) >> 3;
LABEL_46:
    v35 = &a2[v20];
    v36 = &a2[v20];
    if (v23 != a2)
    {
      v36 = v23;
      if (v20)
      {
        v37 = v23 + 8;
        if (v23 + 8 == a2)
        {
          v87 = *v23;
          v89 = a8;
          v43 = a3;
          v44 = a4;
          v45 = v28;
          v46 = v19;
          memmove(v23, v23 + 8, v20);
          v19 = v46;
          v28 = v45;
          a8 = v89;
          a4 = v44;
          a3 = v43;
          v36 = &v23[v20];
          *&v23[v20] = v87;
        }

        else
        {
          v38 = v20 - 8;
          if (v20 == 8)
          {
            v39 = *(v35 - 1);
            v36 = v23 + 8;
            if (v35 - 8 != v23)
            {
              v86 = a3;
              v88 = a8;
              v40 = a4;
              v41 = v28;
              v42 = v19;
              memmove(v23 + 8, v23, v35 - 8 - v23);
              v19 = v42;
              v28 = v41;
              a3 = v86;
              a8 = v88;
              a4 = v40;
            }

            *v23 = v39;
          }

          else
          {
            v47 = a2 - v23;
            v48 = (a2 - v23) >> 3;
            if (v48 == v20 >> 3)
            {
              v49 = a2;
              do
              {
                v50 = *(v37 - 1);
                *(v37 - 1) = *v49;
                *v49 = v50;
                v49 += 8;
                if (v37 == a2)
                {
                  break;
                }

                v51 = v38;
                v38 -= 8;
                v37 += 8;
              }

              while (v51);
              v36 = a2;
            }

            else
            {
              v52 = v20 >> 3;
              v53 = (a2 - v23) >> 3;
              do
              {
                v54 = v53;
                v53 = v52;
                v52 = v54 % v52;
              }

              while (v52);
              v55 = &v23[8 * v53];
              do
              {
                v57 = *(v55 - 1);
                v55 -= 8;
                v56 = v57;
                v58 = &v55[v47];
                v59 = v55;
                do
                {
                  v60 = v59;
                  v59 = v58;
                  *v60 = *v58;
                  v61 = __OFSUB__(v48, (v35 - v58) >> 3);
                  v63 = v48 - ((v35 - v58) >> 3);
                  v62 = (v63 < 0) ^ v61;
                  v58 = &v23[8 * v63];
                  if (v62)
                  {
                    v58 = v59 + v47;
                  }
                }

                while (v58 != v55);
                *v59 = v56;
              }

              while (v55 != v23);
              v36 = &v23[v20];
            }
          }
        }
      }
    }

    a5 -= v28;
    v10 -= v19;
    if (v28 + v19 >= a5 + v10)
    {
      v65 = a4;
      v67 = v19;
      a7 = __len;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v36, v35, a3);
      v35 = v23;
      v10 = v67;
      a5 = v28;
      a3 = v36;
    }

    else
    {
      v64 = v23;
      v65 = a4;
      a7 = __len;
      v66 = a3;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail18AttributeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v13, v64, v36);
      a3 = v66;
      v13 = v36;
    }

    a2 = v35;
    a4 = v65;
    if (!v10)
    {
      return result;
    }
  }

  if (a5 > v10)
  {
    if (a2 == a3)
    {
      return result;
    }

    v68 = 0;
    do
    {
      *(a7 + v68) = *&a2[v68];
      v68 += 8;
    }

    while (&a2[v68] != a3);
    v69 = (a7 + v68);
    while (1)
    {
      if (a2 == v13)
      {
        if (v69 != a7)
        {
          v84 = -8;
          do
          {
            v85 = *(v69 - 1);
            v69 -= 8;
            *&a3[v84] = v85;
            v84 -= 8;
          }

          while (v69 != a7);
        }

        return result;
      }

      v70 = a2 - 8;
      v71 = *(a2 - 1);
      v72 = **(a4 + 8);
      v73 = *(*(*(v69 - 1) + 16) + 16);
      v74 = *(*(v71 + 16) + 16);
      if (v73 == v72)
      {
        if (v74 != v72)
        {
          goto LABEL_88;
        }
      }

      else if (v74 != v72 && v73 < v74)
      {
        goto LABEL_88;
      }

      v71 = *(v69 - 1);
      v70 = a2;
      v69 -= 8;
LABEL_88:
      *(a3 - 1) = v71;
      a3 -= 8;
      a2 = v70;
      if (v69 == a7)
      {
        return result;
      }
    }
  }

  if (v13 == a2)
  {
    return result;
  }

  v76 = -a7;
  v77 = a7;
  v78 = v13;
  do
  {
    v79 = *v78;
    v78 += 8;
    *v77++ = v79;
    v76 -= 8;
  }

  while (v78 != a2);
  while (a2 != a3)
  {
    v80 = **(a4 + 8);
    v81 = *(*(*a2 + 16) + 16);
    v82 = *(*(*a7 + 16) + 16);
    if (v81 == v80)
    {
      if (v82 == v80)
      {
        goto LABEL_102;
      }
    }

    else if (v82 == v80 || v81 >= v82)
    {
LABEL_102:
      *v13 = *a7;
      a7 += 8;
      goto LABEL_103;
    }

    *v13 = *a2;
    a2 += 8;
LABEL_103:
    v13 += 8;
    if (v77 == a7)
    {
      return result;
    }
  }

  return memmove(v13, a7, -(a7 + v76));
}

char *_ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(char *result, char *a2, uint64_t a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 < 2)
  {
    return result;
  }

  v8 = result;
  if (a4 == 2)
  {
    v9 = **(a3 + 8);
    v10 = *(a2 - 1);
    v11 = *(*v10 + 16);
    v12 = *result;
    v13 = *(**result + 16);
    if (v11 == v9)
    {
      if (v13 == v9)
      {
        return result;
      }
    }

    else if (v13 == v9 || v11 >= v13)
    {
      return result;
    }

    *result = v10;
    *(a2 - 1) = v12;
    return result;
  }

  if (a4 > 128)
  {
    v33 = a5;
    v34 = a4 >> 1;
    v35 = &result[8 * (a4 >> 1)];
    v36 = a4 >> 1;
    if (a4 > a6)
    {
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v35, a3, v36, a5, a6);
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v33, a6);

      return _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v8, &v8[8 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), v33, a6);
    }

    _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(result, v35, a3, v36, a5);
    v37 = (v33 + 8 * v34);
    result = _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v37);
    v38 = v33 + 8 * a4;
    v39 = v37;
    while (1)
    {
      if (v39 == v38)
      {
        while (v33 != v37)
        {
          v44 = *v33;
          v33 += 8;
          *v8 = v44;
          v8 += 8;
        }

        return result;
      }

      v40 = **(a3 + 8);
      v41 = *(**v39 + 16);
      v42 = *(**v33 + 16);
      if (v41 == v40)
      {
        if (v42 == v40)
        {
          goto LABEL_52;
        }
      }

      else if (v42 == v40 || v41 >= v42)
      {
LABEL_52:
        *v8 = *v33;
        v33 += 8;
        goto LABEL_53;
      }

      *v8 = *v39++;
LABEL_53:
      v8 += 8;
      if (v33 == v37)
      {
        while (v39 != v38)
        {
          v45 = *v39++;
          *v8 = v45;
          v8 += 8;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v15 = result + 8;
  if (result + 8 == a2)
  {
    return result;
  }

  v16 = 0;
  v17 = result;
  do
  {
    v18 = v17;
    v17 = v15;
    v19 = **(a3 + 8);
    v20 = *(v18 + 1);
    v21 = *(*v20 + 16);
    v22 = *(**v18 + 16);
    if (v21 == v19)
    {
      if (v22 == v19)
      {
        goto LABEL_31;
      }
    }

    else if (v22 == v19 || v21 >= v22)
    {
      goto LABEL_31;
    }

    *(v18 + 1) = *v18;
    v24 = result;
    if (v18 == result)
    {
      goto LABEL_30;
    }

    v25 = v16;
    while (1)
    {
      v26 = **(a3 + 8);
      v27 = *(*v20 + 16);
      v28 = *&result[v25 - 8];
      v29 = *(*v28 + 16);
      if (v27 == v26)
      {
        if (v29 == v26)
        {
          v24 = &result[v25];
          goto LABEL_30;
        }

        goto LABEL_27;
      }

      if (v29 == v26 || v27 >= v29)
      {
        break;
      }

LABEL_27:
      v18 -= 8;
      *&result[v25] = v28;
      v25 -= 8;
      if (!v25)
      {
        v24 = result;
        goto LABEL_30;
      }
    }

    v24 = v18;
LABEL_30:
    *v24 = v20;
LABEL_31:
    v15 = v17 + 8;
    v16 += 8;
  }

  while (v17 + 8 != a2);
  return result;
}

uint64_t _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  if (!a4)
  {
    return result;
  }

  v5 = a5;
  v7 = result;
  if (a4 == 1)
  {
LABEL_38:
    *v5 = *v7;
    return result;
  }

  if (a4 == 2)
  {
    v10 = *(a2 - 8);
    v11 = **(a3 + 8);
    v12 = *(*v10 + 16);
    v13 = *(**result + 16);
    if (v12 == v11)
    {
      if (v13 != v11)
      {
        goto LABEL_37;
      }
    }

    else if (v13 != v11 && v12 < v13)
    {
      goto LABEL_37;
    }

    v10 = *result;
    v7 = a2 - 8;
LABEL_37:
    *a5 = v10;
    v5 = a5 + 1;
    goto LABEL_38;
  }

  if (a4 > 8)
  {
    v31 = result + 8 * (a4 >> 1);
    _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v31, a3, a4 >> 1, a5, a4 >> 1);
    result = _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v7 + 8 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
    v32 = v7 + 8 * (a4 >> 1);
    while (1)
    {
      if (v32 == a2)
      {
        while (v7 != v31)
        {
          v37 = *v7;
          v7 += 8;
          *v5++ = v37;
        }

        return result;
      }

      v33 = **(a3 + 8);
      v34 = *(**v32 + 16);
      v35 = *(**v7 + 16);
      if (v34 == v33)
      {
        if (v35 == v33)
        {
          goto LABEL_50;
        }
      }

      else if (v35 == v33 || v34 >= v35)
      {
LABEL_50:
        *v5 = *v7;
        v7 += 8;
        goto LABEL_51;
      }

      *v5 = *v32;
      v32 += 8;
LABEL_51:
      ++v5;
      if (v7 == v31)
      {
        while (v32 != a2)
        {
          v38 = *v32;
          v32 += 8;
          *v5++ = v38;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v14 = result + 8;
  *a5 = *result;
  if (result + 8 == a2)
  {
    return result;
  }

  v15 = 0;
  v16 = a5;
  v17 = a5;
  do
  {
    v19 = *v17++;
    v18 = v19;
    v20 = **(a3 + 8);
    v21 = *(**v14 + 16);
    v22 = *(*v19 + 16);
    if (v21 == v20)
    {
      if (v22 == v20)
      {
        goto LABEL_29;
      }
    }

    else if (v22 == v20 || v21 >= v22)
    {
LABEL_29:
      *v17 = *v14;
      goto LABEL_32;
    }

    v16[1] = v18;
    v23 = a5;
    if (v16 == a5)
    {
      goto LABEL_31;
    }

    v24 = v15;
    while (1)
    {
      v25 = **(a3 + 8);
      v26 = *(**v14 + 16);
      v27 = *(a5 + v24 - 8);
      v28 = *(*v27 + 16);
      if (v26 == v25)
      {
        if (v28 == v25)
        {
          v23 = (a5 + v24);
          goto LABEL_31;
        }

        goto LABEL_22;
      }

      if (v28 == v25 || v26 >= v28)
      {
        break;
      }

LABEL_22:
      --v16;
      *(a5 + v24) = v27;
      v24 -= 8;
      if (!v24)
      {
        v23 = a5;
        goto LABEL_31;
      }
    }

    v23 = v16;
LABEL_31:
    *v23 = *v14;
LABEL_32:
    v14 += 8;
    v15 += 8;
    v16 = v17;
  }

  while (v14 != a2);
  return result;
}

char *_ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a6)
  {
    return result;
  }

  v10 = a6;
  v13 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5)
    {
      return result;
    }

    v14 = **(a4 + 8);
    v15 = *(**a2 + 16);
    while (1)
    {
      v16 = *v13;
      v17 = *(**v13 + 16);
      if (v15 == v14)
      {
        if (v17 != v14)
        {
          break;
        }

        goto LABEL_15;
      }

      if (v17 != v14 && v15 < v17)
      {
        break;
      }

LABEL_15:
      v13 += 8;
      if (!--a5)
      {
        return result;
      }
    }

    __len = a7;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        *v13 = *a2;
        *a2 = v16;
        return result;
      }

      v28 = a5 / 2;
      v23 = &v13[8 * (a5 / 2)];
      v20 = 0;
      if (a3 == a2)
      {
        v34 = a2;
LABEL_45:
        v19 = (v34 - a2) >> 3;
        goto LABEL_46;
      }

      v29 = (a3 - a2) >> 3;
      v30 = *(**v23 + 16);
      while (2)
      {
        v31 = v29 >> 1;
        v32 = v20 + 8 * (v29 >> 1);
        v33 = *(**&a2[v32] + 16);
        if (v33 == v14)
        {
          if (v30 == v14)
          {
            goto LABEL_40;
          }
        }

        else if (v30 == v14 || v33 >= v30)
        {
LABEL_40:
          v29 = v31;
          if (!v31)
          {
            v34 = &a2[v20];
            goto LABEL_45;
          }

          continue;
        }

        break;
      }

      v20 = v32 + 8;
      v31 = v29 + ~v31;
      goto LABEL_40;
    }

    v19 = v10 / 2;
    v20 = 8 * (v10 / 2);
    if (v13 != a2)
    {
      v21 = (a2 - v13) >> 3;
      v22 = *(**&a2[v20] + 16);
      v23 = v13;
      while (1)
      {
        v24 = v21 >> 1;
        v25 = &v23[8 * (v21 >> 1)];
        v26 = *(**v25 + 16);
        if (v22 == v14)
        {
          if (v26 != v14)
          {
            goto LABEL_29;
          }
        }

        else if (v26 != v14 && v22 < v26)
        {
          goto LABEL_29;
        }

        v23 = v25 + 8;
        v24 = v21 + ~v24;
LABEL_29:
        v21 = v24;
        if (!v24)
        {
          goto LABEL_43;
        }
      }
    }

    v23 = v13;
LABEL_43:
    v28 = (v23 - v13) >> 3;
LABEL_46:
    v35 = &a2[v20];
    v36 = &a2[v20];
    if (v23 != a2)
    {
      v36 = v23;
      if (v20)
      {
        v37 = v23 + 8;
        if (v23 + 8 == a2)
        {
          v87 = *v23;
          v89 = a8;
          v43 = a3;
          v44 = a4;
          v45 = v28;
          v46 = v19;
          memmove(v23, v23 + 8, v20);
          v19 = v46;
          v28 = v45;
          a8 = v89;
          a4 = v44;
          a3 = v43;
          v36 = &v23[v20];
          *&v23[v20] = v87;
        }

        else
        {
          v38 = v20 - 8;
          if (v20 == 8)
          {
            v39 = *(v35 - 1);
            v36 = v23 + 8;
            if (v35 - 8 != v23)
            {
              v86 = a3;
              v88 = a8;
              v40 = a4;
              v41 = v28;
              v42 = v19;
              memmove(v23 + 8, v23, v35 - 8 - v23);
              v19 = v42;
              v28 = v41;
              a3 = v86;
              a8 = v88;
              a4 = v40;
            }

            *v23 = v39;
          }

          else
          {
            v47 = a2 - v23;
            v48 = (a2 - v23) >> 3;
            if (v48 == v20 >> 3)
            {
              v49 = a2;
              do
              {
                v50 = *(v37 - 1);
                *(v37 - 1) = *v49;
                *v49 = v50;
                v49 += 8;
                if (v37 == a2)
                {
                  break;
                }

                v51 = v38;
                v38 -= 8;
                v37 += 8;
              }

              while (v51);
              v36 = a2;
            }

            else
            {
              v52 = v20 >> 3;
              v53 = (a2 - v23) >> 3;
              do
              {
                v54 = v53;
                v53 = v52;
                v52 = v54 % v52;
              }

              while (v52);
              v55 = &v23[8 * v53];
              do
              {
                v57 = *(v55 - 1);
                v55 -= 8;
                v56 = v57;
                v58 = &v55[v47];
                v59 = v55;
                do
                {
                  v60 = v59;
                  v59 = v58;
                  *v60 = *v58;
                  v61 = __OFSUB__(v48, (v35 - v58) >> 3);
                  v63 = v48 - ((v35 - v58) >> 3);
                  v62 = (v63 < 0) ^ v61;
                  v58 = &v23[8 * v63];
                  if (v62)
                  {
                    v58 = v59 + v47;
                  }
                }

                while (v58 != v55);
                *v59 = v56;
              }

              while (v55 != v23);
              v36 = &v23[v20];
            }
          }
        }
      }
    }

    a5 -= v28;
    v10 -= v19;
    if (v28 + v19 >= a5 + v10)
    {
      v65 = a4;
      v67 = v19;
      a7 = __len;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v36, v35, a3);
      v35 = v23;
      v10 = v67;
      a5 = v28;
      a3 = v36;
    }

    else
    {
      v64 = v23;
      v65 = a4;
      a7 = __len;
      v66 = a3;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail15OpNameNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v13, v64, v36);
      a3 = v66;
      v13 = v36;
    }

    a2 = v35;
    a4 = v65;
    if (!v10)
    {
      return result;
    }
  }

  if (a5 > v10)
  {
    if (a2 == a3)
    {
      return result;
    }

    v68 = 0;
    do
    {
      *(a7 + v68) = *&a2[v68];
      v68 += 8;
    }

    while (&a2[v68] != a3);
    v69 = (a7 + v68);
    while (1)
    {
      if (a2 == v13)
      {
        if (v69 != a7)
        {
          v84 = -8;
          do
          {
            v85 = *(v69 - 1);
            v69 -= 8;
            *&a3[v84] = v85;
            v84 -= 8;
          }

          while (v69 != a7);
        }

        return result;
      }

      v70 = a2 - 8;
      v71 = *(a2 - 1);
      v72 = **(a4 + 8);
      v73 = *(**(v69 - 1) + 16);
      v74 = *(*v71 + 16);
      if (v73 == v72)
      {
        if (v74 != v72)
        {
          goto LABEL_88;
        }
      }

      else if (v74 != v72 && v73 < v74)
      {
        goto LABEL_88;
      }

      v71 = *(v69 - 1);
      v70 = a2;
      v69 -= 8;
LABEL_88:
      *(a3 - 1) = v71;
      a3 -= 8;
      a2 = v70;
      if (v69 == a7)
      {
        return result;
      }
    }
  }

  if (v13 == a2)
  {
    return result;
  }

  v76 = -a7;
  v77 = a7;
  v78 = v13;
  do
  {
    v79 = *v78;
    v78 += 8;
    *v77++ = v79;
    v76 -= 8;
  }

  while (v78 != a2);
  while (a2 != a3)
  {
    v80 = **(a4 + 8);
    v81 = *(**a2 + 16);
    v82 = *(**a7 + 16);
    if (v81 == v80)
    {
      if (v82 == v80)
      {
        goto LABEL_102;
      }
    }

    else if (v82 == v80 || v81 >= v82)
    {
LABEL_102:
      *v13 = *a7;
      a7 += 8;
      goto LABEL_103;
    }

    *v13 = *a2;
    a2 += 8;
LABEL_103:
    v13 += 8;
    if (v77 == a7)
    {
      return result;
    }
  }

  return memmove(v13, a7, -(a7 + v76));
}

char *_ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(char *result, char *a2, uint64_t a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 < 2)
  {
    return result;
  }

  v8 = result;
  if (a4 == 2)
  {
    v9 = **(a3 + 8);
    v10 = *(a2 - 1);
    v11 = *(*(v10 + 16) + 16);
    v12 = *result;
    v13 = *(*(*result + 16) + 16);
    if (v11 == v9)
    {
      if (v13 == v9)
      {
        return result;
      }
    }

    else if (v13 == v9 || v11 >= v13)
    {
      return result;
    }

    *result = v10;
    *(a2 - 1) = v12;
    return result;
  }

  if (a4 > 128)
  {
    v33 = a5;
    v34 = a4 >> 1;
    v35 = &result[8 * (a4 >> 1)];
    v36 = a4 >> 1;
    if (a4 > a6)
    {
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v35, a3, v36, a5, a6);
      _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v33, a6);

      return _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v8, &v8[8 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), v33, a6);
    }

    _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(result, v35, a3, v36, a5);
    v37 = (v33 + 8 * v34);
    result = _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v37);
    v38 = v33 + 8 * a4;
    v39 = v37;
    while (1)
    {
      if (v39 == v38)
      {
        while (v33 != v37)
        {
          v44 = *v33;
          v33 += 8;
          *v8 = v44;
          v8 += 8;
        }

        return result;
      }

      v40 = **(a3 + 8);
      v41 = *(*(*v39 + 16) + 16);
      v42 = *(*(*v33 + 16) + 16);
      if (v41 == v40)
      {
        if (v42 == v40)
        {
          goto LABEL_52;
        }
      }

      else if (v42 == v40 || v41 >= v42)
      {
LABEL_52:
        *v8 = *v33;
        v33 += 8;
        goto LABEL_53;
      }

      *v8 = *v39++;
LABEL_53:
      v8 += 8;
      if (v33 == v37)
      {
        while (v39 != v38)
        {
          v45 = *v39++;
          *v8 = v45;
          v8 += 8;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v15 = result + 8;
  if (result + 8 == a2)
  {
    return result;
  }

  v16 = 0;
  v17 = result;
  do
  {
    v18 = v17;
    v17 = v15;
    v19 = **(a3 + 8);
    v20 = *(v18 + 1);
    v21 = *(*(v20 + 16) + 16);
    v22 = *(*(*v18 + 16) + 16);
    if (v21 == v19)
    {
      if (v22 == v19)
      {
        goto LABEL_31;
      }
    }

    else if (v22 == v19 || v21 >= v22)
    {
      goto LABEL_31;
    }

    *(v18 + 1) = *v18;
    v24 = result;
    if (v18 == result)
    {
      goto LABEL_30;
    }

    v25 = v16;
    while (1)
    {
      v26 = **(a3 + 8);
      v27 = *(*(v20 + 16) + 16);
      v28 = *&result[v25 - 8];
      v29 = *(*(v28 + 16) + 16);
      if (v27 == v26)
      {
        if (v29 == v26)
        {
          v24 = &result[v25];
          goto LABEL_30;
        }

        goto LABEL_27;
      }

      if (v29 == v26 || v27 >= v29)
      {
        break;
      }

LABEL_27:
      v18 -= 8;
      *&result[v25] = v28;
      v25 -= 8;
      if (!v25)
      {
        v24 = result;
        goto LABEL_30;
      }
    }

    v24 = v18;
LABEL_30:
    *v24 = v20;
LABEL_31:
    v15 = v17 + 8;
    v16 += 8;
  }

  while (v17 + 8 != a2);
  return result;
}

uint64_t _ZNSt3__118__stable_sort_moveINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeE(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  if (!a4)
  {
    return result;
  }

  v5 = a5;
  v7 = result;
  if (a4 == 1)
  {
LABEL_38:
    *v5 = *v7;
    return result;
  }

  if (a4 == 2)
  {
    v10 = *(a2 - 8);
    v11 = **(a3 + 8);
    v12 = *(*(v10 + 16) + 16);
    v13 = *(*(*result + 16) + 16);
    if (v12 == v11)
    {
      if (v13 != v11)
      {
        goto LABEL_37;
      }
    }

    else if (v13 != v11 && v12 < v13)
    {
      goto LABEL_37;
    }

    v10 = *result;
    v7 = a2 - 8;
LABEL_37:
    *a5 = v10;
    v5 = a5 + 1;
    goto LABEL_38;
  }

  if (a4 > 8)
  {
    v31 = result + 8 * (a4 >> 1);
    _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(result, v31, a3, a4 >> 1, a5, a4 >> 1);
    result = _ZNSt3__113__stable_sortINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SE_NS_15iterator_traitsISK_E15difference_typeEPNSM_10value_typeEl(v7 + 8 * (a4 >> 1), a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
    v32 = v7 + 8 * (a4 >> 1);
    while (1)
    {
      if (v32 == a2)
      {
        while (v7 != v31)
        {
          v37 = *v7;
          v7 += 8;
          *v5++ = v37;
        }

        return result;
      }

      v33 = **(a3 + 8);
      v34 = *(*(*v32 + 16) + 16);
      v35 = *(*(*v7 + 16) + 16);
      if (v34 == v33)
      {
        if (v35 == v33)
        {
          goto LABEL_50;
        }
      }

      else if (v35 == v33 || v34 >= v35)
      {
LABEL_50:
        *v5 = *v7;
        v7 += 8;
        goto LABEL_51;
      }

      *v5 = *v32;
      v32 += 8;
LABEL_51:
      ++v5;
      if (v7 == v31)
      {
        while (v32 != a2)
        {
          v38 = *v32;
          v32 += 8;
          *v5++ = v38;
        }

        return result;
      }
    }
  }

  if (result == a2)
  {
    return result;
  }

  v14 = result + 8;
  *a5 = *result;
  if (result + 8 == a2)
  {
    return result;
  }

  v15 = 0;
  v16 = a5;
  v17 = a5;
  do
  {
    v19 = *v17++;
    v18 = v19;
    v20 = **(a3 + 8);
    v21 = *(*(*v14 + 16) + 16);
    v22 = *(*(v19 + 16) + 16);
    if (v21 == v20)
    {
      if (v22 == v20)
      {
        goto LABEL_29;
      }
    }

    else if (v22 == v20 || v21 >= v22)
    {
LABEL_29:
      *v17 = *v14;
      goto LABEL_32;
    }

    v16[1] = v18;
    v23 = a5;
    if (v16 == a5)
    {
      goto LABEL_31;
    }

    v24 = v15;
    while (1)
    {
      v25 = **(a3 + 8);
      v26 = *(*(*v14 + 16) + 16);
      v27 = *(a5 + v24 - 8);
      v28 = *(*(v27 + 16) + 16);
      if (v26 == v25)
      {
        if (v28 == v25)
        {
          v23 = (a5 + v24);
          goto LABEL_31;
        }

        goto LABEL_22;
      }

      if (v28 == v25 || v26 >= v28)
      {
        break;
      }

LABEL_22:
      --v16;
      *(a5 + v24) = v27;
      v24 -= 8;
      if (!v24)
      {
        v23 = a5;
        goto LABEL_31;
      }
    }

    v23 = v16;
LABEL_31:
    *v23 = *v14;
LABEL_32:
    v14 += 8;
    v15 += 8;
    v16 = v17;
  }

  while (v14 != a2);
  return result;
}

char *_ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a6)
  {
    return result;
  }

  v10 = a6;
  v13 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5)
    {
      return result;
    }

    v14 = **(a4 + 8);
    v15 = *(*(*a2 + 16) + 16);
    while (1)
    {
      v16 = *v13;
      v17 = *(*(*v13 + 16) + 16);
      if (v15 == v14)
      {
        if (v17 != v14)
        {
          break;
        }

        goto LABEL_15;
      }

      if (v17 != v14 && v15 < v17)
      {
        break;
      }

LABEL_15:
      v13 += 8;
      if (!--a5)
      {
        return result;
      }
    }

    __len = a7;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        *v13 = *a2;
        *a2 = v16;
        return result;
      }

      v28 = a5 / 2;
      v23 = &v13[8 * (a5 / 2)];
      v20 = 0;
      if (a3 == a2)
      {
        v34 = a2;
LABEL_45:
        v19 = (v34 - a2) >> 3;
        goto LABEL_46;
      }

      v29 = (a3 - a2) >> 3;
      v30 = *(*(*v23 + 16) + 16);
      while (2)
      {
        v31 = v29 >> 1;
        v32 = v20 + 8 * (v29 >> 1);
        v33 = *(*(*&a2[v32] + 16) + 16);
        if (v33 == v14)
        {
          if (v30 == v14)
          {
            goto LABEL_40;
          }
        }

        else if (v30 == v14 || v33 >= v30)
        {
LABEL_40:
          v29 = v31;
          if (!v31)
          {
            v34 = &a2[v20];
            goto LABEL_45;
          }

          continue;
        }

        break;
      }

      v20 = v32 + 8;
      v31 = v29 + ~v31;
      goto LABEL_40;
    }

    v19 = v10 / 2;
    v20 = 8 * (v10 / 2);
    if (v13 != a2)
    {
      v21 = (a2 - v13) >> 3;
      v22 = *(*(*&a2[v20] + 16) + 16);
      v23 = v13;
      while (1)
      {
        v24 = v21 >> 1;
        v25 = &v23[8 * (v21 >> 1)];
        v26 = *(*(*v25 + 16) + 16);
        if (v22 == v14)
        {
          if (v26 != v14)
          {
            goto LABEL_29;
          }
        }

        else if (v26 != v14 && v22 < v26)
        {
          goto LABEL_29;
        }

        v23 = v25 + 8;
        v24 = v21 + ~v24;
LABEL_29:
        v21 = v24;
        if (!v24)
        {
          goto LABEL_43;
        }
      }
    }

    v23 = v13;
LABEL_43:
    v28 = (v23 - v13) >> 3;
LABEL_46:
    v35 = &a2[v20];
    v36 = &a2[v20];
    if (v23 != a2)
    {
      v36 = v23;
      if (v20)
      {
        v37 = v23 + 8;
        if (v23 + 8 == a2)
        {
          v87 = *v23;
          v89 = a8;
          v43 = a3;
          v44 = a4;
          v45 = v28;
          v46 = v19;
          memmove(v23, v23 + 8, v20);
          v19 = v46;
          v28 = v45;
          a8 = v89;
          a4 = v44;
          a3 = v43;
          v36 = &v23[v20];
          *&v23[v20] = v87;
        }

        else
        {
          v38 = v20 - 8;
          if (v20 == 8)
          {
            v39 = *(v35 - 1);
            v36 = v23 + 8;
            if (v35 - 8 != v23)
            {
              v86 = a3;
              v88 = a8;
              v40 = a4;
              v41 = v28;
              v42 = v19;
              memmove(v23 + 8, v23, v35 - 8 - v23);
              v19 = v42;
              v28 = v41;
              a3 = v86;
              a8 = v88;
              a4 = v40;
            }

            *v23 = v39;
          }

          else
          {
            v47 = a2 - v23;
            v48 = (a2 - v23) >> 3;
            if (v48 == v20 >> 3)
            {
              v49 = a2;
              do
              {
                v50 = *(v37 - 1);
                *(v37 - 1) = *v49;
                *v49 = v50;
                v49 += 8;
                if (v37 == a2)
                {
                  break;
                }

                v51 = v38;
                v38 -= 8;
                v37 += 8;
              }

              while (v51);
              v36 = a2;
            }

            else
            {
              v52 = v20 >> 3;
              v53 = (a2 - v23) >> 3;
              do
              {
                v54 = v53;
                v53 = v52;
                v52 = v54 % v52;
              }

              while (v52);
              v55 = &v23[8 * v53];
              do
              {
                v57 = *(v55 - 1);
                v55 -= 8;
                v56 = v57;
                v58 = &v55[v47];
                v59 = v55;
                do
                {
                  v60 = v59;
                  v59 = v58;
                  *v60 = *v58;
                  v61 = __OFSUB__(v48, (v35 - v58) >> 3);
                  v63 = v48 - ((v35 - v58) >> 3);
                  v62 = (v63 < 0) ^ v61;
                  v58 = &v23[8 * v63];
                  if (v62)
                  {
                    v58 = v59 + v47;
                  }
                }

                while (v58 != v55);
                *v59 = v56;
              }

              while (v55 != v23);
              v36 = &v23[v20];
            }
          }
        }
      }
    }

    a5 -= v28;
    v10 -= v19;
    if (v28 + v19 >= a5 + v10)
    {
      v65 = a4;
      v67 = v19;
      a7 = __len;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v36, v35, a3);
      v35 = v23;
      v10 = v67;
      a5 = v28;
      a3 = v36;
    }

    else
    {
      v64 = v23;
      v65 = a4;
      a7 = __len;
      v66 = a3;
      result = _ZNSt3__115__inplace_mergeINS_17_ClassicAlgPolicyERZL21groupByDialectPerByteIN4llvm15MutableArrayRefIPN4mlir8bytecode6detail13TypeNumberingEEEEvT_EUlRKSB_RKT0_E_PS9_EEvT1_SK_SK_OSE_NS_15iterator_traitsISK_E15difference_typeESO_PNSN_10value_typeEl(v13, v64, v36);
      a3 = v66;
      v13 = v36;
    }

    a2 = v35;
    a4 = v65;
    if (!v10)
    {
      return result;
    }
  }

  if (a5 > v10)
  {
    if (a2 == a3)
    {
      return result;
    }

    v68 = 0;
    do
    {
      *(a7 + v68) = *&a2[v68];
      v68 += 8;
    }

    while (&a2[v68] != a3);
    v69 = (a7 + v68);
    while (1)
    {
      if (a2 == v13)
      {
        if (v69 != a7)
        {
          v84 = -8;
          do
          {
            v85 = *(v69 - 1);
            v69 -= 8;
            *&a3[v84] = v85;
            v84 -= 8;
          }

          while (v69 != a7);
        }

        return result;
      }

      v70 = a2 - 8;
      v71 = *(a2 - 1);
      v72 = **(a4 + 8);
      v73 = *(*(*(v69 - 1) + 16) + 16);
      v74 = *(*(v71 + 16) + 16);
      if (v73 == v72)
      {
        if (v74 != v72)
        {
          goto LABEL_88;
        }
      }

      else if (v74 != v72 && v73 < v74)
      {
        goto LABEL_88;
      }

      v71 = *(v69 - 1);
      v70 = a2;
      v69 -= 8;
LABEL_88:
      *(a3 - 1) = v71;
      a3 -= 8;
      a2 = v70;
      if (v69 == a7)
      {
        return result;
      }
    }
  }

  if (v13 == a2)
  {
    return result;
  }

  v76 = -a7;
  v77 = a7;
  v78 = v13;
  do
  {
    v79 = *v78;
    v78 += 8;
    *v77++ = v79;
    v76 -= 8;
  }

  while (v78 != a2);
  while (a2 != a3)
  {
    v80 = **(a4 + 8);
    v81 = *(*(*a2 + 16) + 16);
    v82 = *(*(*a7 + 16) + 16);
    if (v81 == v80)
    {
      if (v82 == v80)
      {
        goto LABEL_102;
      }
    }

    else if (v82 == v80 || v81 >= v82)
    {
LABEL_102:
      *v13 = *a7;
      a7 += 8;
      goto LABEL_103;
    }

    *v13 = *a2;
    a2 += 8;
LABEL_103:
    v13 += 8;
    if (v77 == a7)
    {
      return result;
    }
  }

  return memmove(v13, a7, -(a7 + v76));
}

double llvm::function_ref<void ()(mlir::Operation *,mlir::WalkStage const&)>::callback_fn<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::$_0>(uint64_t **a1, uint64_t a2, _DWORD *a3)
{
  v36 = a2;
  v4 = *(a2 + 44);
  v5 = a3[1];
  if ((v4 & 0x7FFFFF) != 0 && v5 == *a3)
  {
    v12 = *(*a1 + 2);
    v13 = *(**a1 + 24 * v12 - 16);
    *(*a1 + 2) = v12 - 1;
    if ((*(v13 + 5) & 1) == 0)
    {
      *(v13 + 4) = 257;
    }
  }

  else if (!v5)
  {
    v8 = a1[1];
    v9 = *(*a1 + 2);
    if (v9 && *(**a1 + 24 * v9 - 8) == 1)
    {
      v10 = *(a2 + 16);
      v11 = v10 ? *(v10 + 24) & 0xFFFFFFFFFFFFFFF8 : 0;
      if ((v4 & 0x800000) != 0)
      {
        v14 = *(a2 + 68);
        if (v14)
        {
          v15 = 0;
          v16 = *(a2 + 72);
          do
          {
            *&v34 = *(v16 + 32 * v15 + 24);
            ParentRegion = mlir::Value::getParentRegion(&v34);
            if (ParentRegion != v11)
            {
              v18 = **a1;
              v19 = v18 + 24 * *(*a1 + 2);
              v20 = 24 * *(*a1 + 2);
              v21 = v19;
              while (1)
              {
                if (!v20)
                {
                  v22 = **a1;
                  goto LABEL_24;
                }

                v22 = v21;
                if (*(v18 + v20 - 8) != 1)
                {
                  break;
                }

                v21 -= 24;
                v23 = *(v18 + v20 - 24);
                v20 -= 24;
                if (v23 == *(ParentRegion + 16))
                {
                  goto LABEL_24;
                }
              }

              v22 = v18 + v20;
LABEL_24:
              while (v19 != v22)
              {
                *(v19 - 8) = *(v22 - 8);
                *(*(v19 - 16) + 4) = 256;
                v19 -= 24;
              }
            }

            ++v15;
          }

          while (v15 != v14);
        }
      }
    }

    v24 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(v8 + 56, 8, 2);
    v25 = a1[2];
    v26 = (*v25)++;
    *v24 = v26;
    *(v24 + 4) = 0;
    v27 = mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID();
    if ((*(**(a2 + 48) + 32))(*(a2 + 48), v27))
    {
      *(v24 + 4) = 257;
    }

    *&v34 = 0;
    if (llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::LookupBucketFor<mlir::Operation *>(v8 + 3, &v36, &v34))
    {
      v29 = v36;
    }

    else
    {
      v30 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>,mlir::Operation *,mlir::bytecode::detail::OperationNumbering *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::bytecode::detail::OperationNumbering *>>::InsertIntoBucketImpl<mlir::Operation *>((v8 + 3), &v36, v34);
      v29 = v36;
      *v30 = v36;
      v30[1] = v24;
    }

    if ((*(v29 + 44) & 0x7FFFFF) != 0)
    {
      v31 = *a1;
      *&v34 = v29;
      *(&v34 + 1) = v24;
      LOBYTE(v35) = *(v24 + 5) ^ 1;
      v32 = *(v31 + 2);
      if (v32 >= *(v31 + 3))
      {
        *&result = llvm::SmallVectorTemplateBase<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::StackState,true>::growAndEmplaceBack<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::StackState>(v31, &v34).n128_u64[0];
      }

      else
      {
        v33 = *v31 + 24 * v32;
        result = *&v34;
        *v33 = v34;
        *(v33 + 16) = v35;
        ++*(v31 + 2);
      }
    }
  }

  return result;
}

__n128 llvm::SmallVectorTemplateBase<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::StackState,true>::growAndEmplaceBack<mlir::bytecode::detail::IRNumberingState::computeGlobalNumberingState(mlir::Operation *)::StackState>(uint64_t a1, __int128 *a2)
{
  v9 = *a2;
  v10 = *(a2 + 2);
  v3 = *(a1 + 8);
  v4 = *a1;
  v5 = &v9;
  if (v3 >= *(a1 + 12))
  {
    if (v4 <= &v9 && v4 + 24 * v3 > &v9)
    {
      v8 = &v9 - v4;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v3 + 1, 24);
      v4 = *a1;
      v5 = &v8[*a1];
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v3 + 1, 24);
      v4 = *a1;
      v5 = &v9;
    }
  }

  v6 = (v4 + 24 * *(a1 + 8));
  result = *v5;
  v6[1].n128_u64[0] = v5[1].n128_u64[0];
  *v6 = result;
  ++*(a1 + 8);
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>,mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::LookupBucketFor<mlir::Dialect *>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>,mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,mlir::bytecode::detail::DialectNumbering *>>::LookupBucketFor<mlir::Dialect *>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          v21[1] = v19[1];
          ++*(a1 + 8);
        }

        v19 += 2;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(uint64_t a1, int a2, uint64_t a3, unint64_t *a4)
{
  if (a2)
  {
    v7 = a2 - 1;
    v8 = (a2 - 1) & llvm::hashing::detail::hash_combine_range_impl<char const>(*a3, *a3 + *(a3 + 8), a3, a4);
    v9 = a1 + 24 * v8;
    if (llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a3, *(a3 + 8), *v9, *(v9 + 8)))
    {
      result = 1;
    }

    else
    {
      v11 = 0;
      v12 = 1;
      while (*v9 != -1)
      {
        if (v11)
        {
          v13 = 0;
        }

        else
        {
          v13 = *v9 == -2;
        }

        if (v13)
        {
          v11 = v9;
        }

        v17 = v11;
        v14 = v12 + 1;
        v8 = (v8 + v12) & v7;
        v9 = a1 + 24 * v8;
        isEqual = llvm::DenseMapInfo<llvm::StringRef,void>::isEqual(*a3, *(a3 + 8), *v9, *(v9 + 8));
        v11 = v17;
        v16 = isEqual;
        result = 1;
        v12 = v14;
        if (v16)
        {
          goto LABEL_5;
        }
      }

      result = 0;
      if (v11)
      {
        v9 = v11;
      }
    }
  }

  else
  {
    v9 = 0;
    result = 0;
  }

LABEL_5:
  *a4 = v9;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::InsertIntoBucketImpl<llvm::StringRef>(uint64_t a1, uint64_t a2, void *a3)
{
  v8 = a3;
  v5 = *(a1 + 8);
  v6 = *(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }

  else if (v6 + ~v5 - *(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }

  llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::grow(a1, v6);
  llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(*a1, *(a1 + 16), a2, &v8);
  v5 = *(a1 + 8);
  a3 = v8;
LABEL_3:
  *(a1 + 8) = v5 + 1;
  if (*a3 != -1)
  {
    --*(a1 + 12);
  }

  return a3;
}

_OWORD *llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((24 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 24 * v10;
      do
      {
        *result = xmmword_25D0A05E0;
        result = (result + 24);
        v11 -= 24;
      }

      while (v11);
    }

    if (v3)
    {
      v12 = 24 * v3;
      v13 = v4;
      do
      {
        if (*v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v17 = 0;
          llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>,llvm::StringRef,unsigned int,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,unsigned int>>::LookupBucketFor<llvm::StringRef>(*a1, *(a1 + 16), v13, &v17);
          v14 = v17;
          *v17 = *v13;
          *(v14 + 4) = *(v13 + 16);
          ++*(a1 + 8);
        }

        v13 += 24;
        v12 -= 24;
      }

      while (v12);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v15 = *(a1 + 16);
  if (v15)
  {
    v16 = 24 * v15;
    do
    {
      *result = xmmword_25D0A05E0;
      result = (result + 24);
      v16 -= 24;
    }

    while (v16);
  }

  return result;
}

__n128 llvm::SmallVectorTemplateBase<std::pair<llvm::StringRef,mlir::bytecode::detail::DialectResourceNumbering *>,true>::growAndEmplaceBack<std::piecewise_construct_t const&,std::tuple<llvm::StringRef&&>,std::tuple<mlir::bytecode::detail::DialectResourceNumbering *&&>>(uint64_t a1, __int128 *a2, uint64_t a3)
{
  v10 = *a2;
  v11 = a3;
  v4 = *(a1 + 8);
  v5 = *a1;
  v6 = &v10;
  if (v4 >= *(a1 + 12))
  {
    if (v5 <= &v10 && v5 + 24 * v4 > &v10)
    {
      v9 = &v10 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v9[*a1];
    }

    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v4 + 1, 24);
      v5 = *a1;
      v6 = &v10;
    }
  }

  v7 = (v5 + 24 * *(a1 + 8));
  result = *v6;
  v7[1].n128_u64[0] = v6[1].n128_u64[0];
  *v7 = result;
  ++*(a1 + 8);
  return result;
}

void mlir::ODIE::Compiler::Transforms::createWriteResourcesToFile(uint64_t a1)
{
  *__p = *a1;
  v2 = *(a1 + 16);
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = 0;
  mlir::ODIE::Compiler::Transforms::impl::createWriteResourcesToFile();
}

mlir::Pass **std::unique_ptr<mlir::ODIE::Compiler::Transforms::anonymous namespace::WriteResourcesToFilePass>::~unique_ptr[abi:nn200100](mlir::Pass **a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    *v2 = &unk_286EAA578;
    mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(v2 + 336);
    mlir::Pass::~Pass(v2);
    MEMORY[0x25F891040]();
  }

  return a1;
}

uint64_t mlir::ODIE::Compiler::Transforms::impl::WriteResourcesToFileBase<mlir::ODIE::Compiler::Transforms::anonymous namespace::WriteResourcesToFilePass>::WriteResourcesToFileBase(uint64_t a1)
{
  *(a1 + 16) = "builtin.module";
  *(a1 + 24) = 14;
  *(a1 + 32) = 1;
  *(a1 + 40) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0u;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0;
  *(a1 + 176) = a1 + 192;
  *(a1 + 184) = 0x400000000;
  *(a1 + 224) = a1 + 240;
  *(a1 + 232) = 0x400000000;
  *(a1 + 272) = 0;
  *(a1 + 280) = 0;
  *(a1 + 288) = 0x1000000000;
  *(a1 + 328) = 0;
  *(a1 + 296) = 0u;
  *(a1 + 312) = 0u;
  *a1 = &unk_286EAA578;
  *&v3 = "The directory in which to write resource files.";
  *(&v3 + 1) = 47;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((a1 + 336), (a1 + 144), "resources-dir", 13, &v3);
  *(a1 + 336) = &unk_286E98FD0;
  *(a1 + 560) = &unk_286E99050;
  return a1;
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::WriteResourcesToFilePass::~WriteResourcesToFilePass(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::WriteResourcesToFilePass *this)
{
  *this = &unk_286EAA578;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);

  mlir::Pass::~Pass(this);
}

{
  *this = &unk_286EAA578;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(this + 336);
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::Transforms::anonymous namespace::WriteResourcesToFilePass::runOnOperation(mlir::ODIE::Compiler::Transforms::_anonymous_namespace_::WriteResourcesToFilePass *this)
{
  v49[2] = *MEMORY[0x277D85DE8];
  v2 = *(this + 5) & 0xFFFFFFFFFFFFFFF8;
  v43[0] = *(***(v2 + 24) + 32);
  memset(&v43[1], 0, 24);
  std::__fs::filesystem::__current_path(&v42, 0);
  if (*(this + 568) == 1)
  {
    memset(__p, 0, 24);
    v3 = *(this + 479);
    if (v3 >= 0)
    {
      v4 = (this + 456);
    }

    else
    {
      v4 = *(this + 57);
    }

    if (v3 >= 0)
    {
      v5 = *(this + 479);
    }

    else
    {
      v5 = *(this + 58);
    }

    std::string::append[abi:nn200100]<char const*,0>(__p, v4, (v4 + v5));
    if (SHIBYTE(v42.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__pn_.__r_.__value_.__l.__data_);
    }

    v42 = __p[0];
  }

  std::string::basic_string[abi:nn200100]<0>(__p, "data");
  v6 = mlir::ODIE::Compiler::Transforms::getUniqueFileName(std::__fs::filesystem::path const&)::$_1::operator()(&v42, __p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }

  if (v6)
  {
    for (i = 0; ; ++i)
    {
      std::string::basic_string[abi:nn200100]<0>(&v44, "data");
      std::to_string(&v38, i);
      v8 = std::string::insert(&v38, 0, "_");
      v9 = v8->__r_.__value_.__r.__words[2];
      *&__p[0].__r_.__value_.__l.__data_ = *&v8->__r_.__value_.__l.__data_;
      __p[0].__r_.__value_.__r.__words[2] = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v10 = __p;
      }

      else
      {
        v10 = __p[0].__r_.__value_.__r.__words[0];
      }

      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = __p[0].__r_.__value_.__l.__size_;
      }

      std::string::append(&v44, v10, size);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v38.__r_.__value_.__l.__data_);
      }

      if ((mlir::ODIE::Compiler::Transforms::getUniqueFileName(std::__fs::filesystem::path const&)::$_1::operator()(&v42, &v44) & 1) == 0)
      {
        break;
      }

      if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v44.__r_.__value_.__l.__data_);
      }
    }
  }

  else
  {
    std::string::basic_string[abi:nn200100]<0>(&v44, "data");
  }

  if (SHIBYTE(v42.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&pn, v42.__pn_.__r_.__value_.__l.__data_, v42.__pn_.__r_.__value_.__l.__size_);
  }

  else
  {
    pn = v42.__pn_;
  }

  v12 = std::string::append(&pn, "/");
  v13 = v12->__r_.__value_.__r.__words[2];
  *&v38.__r_.__value_.__l.__data_ = *&v12->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__r.__words[2] = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v14 = &v44;
  }

  else
  {
    v14 = v44.__r_.__value_.__r.__words[0];
  }

  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v15 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v15 = v44.__r_.__value_.__l.__size_;
  }

  v16 = std::string::append(&v38, v14, v15);
  v17 = v16->__r_.__value_.__r.__words[2];
  *&__p[0].__r_.__value_.__l.__data_ = *&v16->__r_.__value_.__l.__data_;
  __p[0].__r_.__value_.__r.__words[2] = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = std::string::append(__p, ".bin");
  v19 = v18->__r_.__value_.__r.__words[0];
  v49[0] = v18->__r_.__value_.__l.__size_;
  *(v49 + 7) = *(&v18->__r_.__value_.__r.__words[1] + 7);
  v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v38.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(pn.__r_.__value_.__l.__data_);
  }

  pn.__r_.__value_.__r.__words[0] = v19;
  pn.__r_.__value_.__l.__size_ = v49[0];
  *(&pn.__r_.__value_.__r.__words[1] + 7) = *(v49 + 7);
  *(&pn.__r_.__value_.__s + 23) = v20;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v44.__r_.__value_.__l.__data_);
  }

  v48[6] = 0;
  v21 = MEMORY[0x277D82860] + 24;
  v22 = MEMORY[0x277D82860] + 64;
  v48[0] = MEMORY[0x277D82860] + 64;
  v23 = MEMORY[0x277D82810];
  v24 = *(MEMORY[0x277D82810] + 16);
  __p[0].__r_.__value_.__r.__words[0] = *(MEMORY[0x277D82810] + 8);
  *(__p[0].__r_.__value_.__r.__words + *(__p[0].__r_.__value_.__r.__words[0] - 24)) = v24;
  v25 = (__p + *(__p[0].__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v25, &__p[0].__r_.__value_.__r.__words[1]);
  v25[1].__vftable = 0;
  v25[1].__fmtflags_ = -1;
  __p[0].__r_.__value_.__r.__words[0] = v21;
  v48[0] = v22;
  MEMORY[0x25F890BD0](&__p[0].__r_.__value_.__r.__words[1]);
  v26 = std::filebuf::open();
  if (!v26)
  {
    std::ios_base::clear((__p + *(__p[0].__r_.__value_.__r.__words[0] - 24)), *(&__p[1].__r_.__value_.__r.__words[1] + *(__p[0].__r_.__value_.__r.__words[0] - 24)) | 4);
  }

  if (v47)
  {
    v27 = *(***(v2 + 24) + 32);
    *&v44.__r_.__value_.__l.__data_ = 0uLL;
    v44.__r_.__value_.__r.__words[2] = 0x1000000000;
    v38.__r_.__value_.__r.__words[0] = &v44;
    v38.__r_.__value_.__l.__size_ = __p;
    v38.__r_.__value_.__r.__words[2] = &pn;
    v39 = &v41;
    v40 = v43;
    v41 = v27;
    v49[0] = &v38;
    mlir::detail::walk<mlir::ForwardIterator>(v2, _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_124WriteResourcesToFilePass14runOnOperationEvE3__0NSC_6CoreML10ConstantOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, v49, 1);
    if (HIDWORD(v44.__r_.__value_.__r.__words[1]) && LODWORD(v44.__r_.__value_.__r.__words[1]))
    {
      v28 = 0;
      v29 = 8 * LODWORD(v44.__r_.__value_.__r.__words[1]);
      do
      {
        v30 = *(v44.__r_.__value_.__r.__words[0] + v28);
        if (v30 != -8 && v30 != 0)
        {
          MEMORY[0x25F891030]();
        }

        v28 += 8;
      }

      while (v29 != v28);
    }

    free(v44.__r_.__value_.__l.__data_);
  }

  else
  {
    v32 = llvm::errs(v26);
    v33 = v32;
    v34 = *(v32 + 4);
    if (*(v32 + 3) - v34 > 0x14uLL)
    {
      qmemcpy(v34, "Failed to open file: ", 21);
      *(v32 + 4) += 21;
    }

    else
    {
      v33 = llvm::raw_ostream::write(v32, "Failed to open file: ", 0x15uLL);
    }

    v35 = __error();
    llvm::write_integer(v33, *v35, 0, 0);
    v36 = *(v33 + 4);
    if (*(v33 + 3) == v36)
    {
      llvm::raw_ostream::write(v33, "\n", 1uLL);
    }

    else
    {
      *v36 = 10;
      ++*(v33 + 4);
    }

    *(this + 5) |= 4uLL;
  }

  __p[0].__r_.__value_.__r.__words[0] = *v23;
  *(__p[0].__r_.__value_.__r.__words + *(__p[0].__r_.__value_.__r.__words[0] - 24)) = v23[3];
  MEMORY[0x25F890BE0](&__p[0].__r_.__value_.__r.__words[1]);
  std::ostream::~ostream();
  MEMORY[0x25F890F80](v48);
  if (SHIBYTE(pn.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(pn.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v42.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v42.__pn_.__r_.__value_.__l.__data_);
  }

  v37 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::Compiler::Transforms::getUniqueFileName(std::__fs::filesystem::path const&)::$_1::operator()(uint64_t a1, uint64_t a2)
{
  v20[2] = *MEMORY[0x277D85DE8];
  if (*(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *a1, *(a1 + 8));
  }

  else
  {
    __p = *a1;
  }

  v3 = std::string::append(&__p, "/");
  v4 = v3->__r_.__value_.__r.__words[2];
  *&v18.__r_.__value_.__l.__data_ = *&v3->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = *(a2 + 23);
  if (v5 >= 0)
  {
    v6 = a2;
  }

  else
  {
    v6 = *a2;
  }

  if (v5 >= 0)
  {
    v7 = *(a2 + 23);
  }

  else
  {
    v7 = *(a2 + 8);
  }

  v8 = std::string::append(&v18, v6, v7);
  v9 = v8->__r_.__value_.__r.__words[2];
  *&v19.__r_.__value_.__l.__data_ = *&v8->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v19, ".bin");
  v11 = v10->__r_.__value_.__r.__words[0];
  v20[0] = v10->__r_.__value_.__l.__size_;
  *(v20 + 7) = *(&v10->__r_.__value_.__r.__words[1] + 7);
  v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v19.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v19.__r_.__value_.__r.__words[0] = v11;
  v19.__r_.__value_.__l.__size_ = v20[0];
  *(&v19.__r_.__value_.__r.__words[1] + 7) = *(v20 + 7);
  *(&v19.__r_.__value_.__s + 23) = v12;
  std::__fs::filesystem::__status(&v19, 0);
  v13 = v18.__r_.__value_.__s.__data_[0];
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v19.__r_.__value_.__l.__data_);
  }

  if (v13)
  {
    v14 = v13 == 255;
  }

  else
  {
    v14 = 1;
  }

  result = !v14;
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void *_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4ODIE8Compiler10Transforms12_GLOBAL__N_124WriteResourcesToFilePass14runOnOperationEvE3__0NSC_6CoreML10ConstantOpEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(void *result, uint64_t a2)
{
  v78[8] = *MEMORY[0x277D85DE8];
  if (!a2)
  {
    goto LABEL_51;
  }

  if (*(*(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    goto LABEL_51;
  }

  v2 = *result;
  v66 = a2;
  result = mlir::ODIE::Compiler::CoreML::ConstantOp::getValueAttr(&v66);
  if (*(*result + 136) != &mlir::detail::TypeIDResolver<mlir::DenseResourceElementsAttr,void>::id)
  {
    goto LABEL_51;
  }

  v4 = result;
  v5 = *v2;
  v6 = result[3];
  v7 = *v6;
  v8 = *(v6 + 8);
  v9 = llvm::xxh3_64bits(*v6, v8, v3);
  Key = llvm::StringMapImpl::FindKey(v5, v7, v8, v9);
  if (Key == -1)
  {
    v11 = *(v5 + 2);
  }

  else
  {
    v11 = Key;
  }

  v12 = *v5 + 8 * v11;
  if (**v2 + 8 * *(*v2 + 8) != v12)
  {
    v13 = **(v2 + 24);
    v14 = (*(v66 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (v14)
    {
      v15 = *v14;
      v16 = mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID();
      v17 = mlir::detail::InterfaceMap::lookup(v15 + 8, v16);
    }

    else
    {
      v17 = 0;
    }

    v26 = mlir::ODIE::Compiler::CoreML::FileResourceAttr::get(v13, v14, v17, *(*(*v12 + 8) + 24), *(*(*v12 + 8) + 32));
    goto LABEL_44;
  }

  v18 = *(v2 + 8);
  v19 = *(v2 + 16);
  v20 = v4[3];
  if (*(v20 + 80))
  {
    v21 = (v20 + 16);
  }

  else
  {
    v21 = 0;
  }

  v22 = v21[1];
  v69 = v21[2];
  v23 = *v21;
  v24 = v18 + *(*v18 - 24);
  if ((v24[32] & 5) != 0)
  {
    v25 = -1;
  }

  else
  {
    (*(**(v24 + 5) + 32))(&__dst);
    v25 = v76[0];
  }

  std::ostream::write();
  std::ostream::write();
  v27 = v4[1];
  v28 = *(**v4 + 32);
  v29 = v4[2];
  v31 = std::__fs::filesystem::path::__filename(v19);
  if (v31.__size_ >= 0x7FFFFFFFFFFFFFF8)
  {
    std::string::__throw_length_error[abi:nn200100]();
  }

  if (v31.__size_ >= 0x17)
  {
    operator new();
  }

  HIBYTE(v71) = v31.__size_;
  if (v31.__size_)
  {
    memmove(&__dst, v31.__data_, v31.__size_);
  }

  *(&__dst + v31.__size_) = 0;
  *__p = __dst;
  v68 = v71;
  v32 = __dst;
  if (SHIBYTE(v71) >= 0)
  {
    v32 = __p;
  }

  v33 = 1;
  v73[1] = 1;
  if (*v32)
  {
    *&__dst = v32;
    v33 = 3;
  }

  v73[0] = v33;
  v34 = mlir::StringAttr::get(v28, &__dst, v30);
  v35 = mlir::IntegerType::get(v28, 64, 2);
  v36 = mlir::IntegerAttr::get(v35, v25);
  v26 = mlir::ODIE::Compiler::CoreML::FileResourceAttr::get(v28, v27, v29, v34, v36);
  if (SHIBYTE(v68) < 0)
  {
    operator delete(__p[0]);
  }

  v38 = *v2;
  v39 = v4[3];
  v41 = *v39;
  v40 = *(v39 + 8);
  v42 = llvm::xxh3_64bits(*v39, v40, v37);
  v43 = llvm::StringMapImpl::LookupBucketFor(v38, v41, v40, v42);
  v44 = *v38;
  v45 = v43;
  v46 = *(*v38 + 8 * v43);
  if (v46 == -8)
  {
    --*(v38 + 4);
    goto LABEL_34;
  }

  if (!v46)
  {
LABEL_34:
    buffer = llvm::allocate_buffer((v40 + 17), 8uLL);
    v48 = buffer;
    v49 = (buffer + 2);
    if (v40)
    {
      memcpy(buffer + 2, v41, v40);
    }

    v49[v40] = 0;
    *v48 = v40;
    v48[1] = 0;
    *(v44 + 8 * v45) = v48;
    ++*(v38 + 3);
    for (i = (*v38 + 8 * llvm::StringMapImpl::RehashTable(v38, v45)); ; ++i)
    {
      v46 = *i;
      if (*i && v46 != -8)
      {
        break;
      }
    }
  }

  *(v46 + 8) = v26;
LABEL_44:
  v52 = *(v2 + 32);
  v53 = v66;
  *(v52 + 16) = *(v66 + 16);
  *(v52 + 24) = v53;
  v54 = *(v2 + 32);
  v55 = *(v53 + 24);
  v56 = (*(v53 - 8) & 0xFFFFFFFFFFFFFFF8);
  v57 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::ConstantOp>(v54, *(**v55 + 32));
  *&__dst = v55;
  *(&__dst + 1) = v57;
  v71 = v73;
  v72 = 0x400000000;
  v74[0] = v75;
  v74[1] = 0x400000000;
  v75[4] = v76;
  v75[5] = 0x400000000;
  v76[8] = 4;
  v76[9] = v77;
  v76[10] = 0x100000000;
  v77[1] = v78;
  v77[2] = 0x100000000;
  v78[1] = 0;
  v78[2] = 0;
  v78[3] = &mlir::detail::TypeIDResolver<void,void>::id;
  v78[4] = 0;
  v78[6] = 0;
  if (v26)
  {
    v58 = *v26;
    v59 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
    v60 = mlir::detail::InterfaceMap::lookup(v58 + 8, v59);
  }

  else
  {
    v60 = 0;
  }

  __p[0] = v56;
  v61 = mlir::OperationState::getOrAddProperties<mlir::ODIE::Compiler::CoreML::detail::ConstantOpGenericAdaptorBase::Properties>(&__dst);
  *v61 = v26;
  v61[1] = v60;
  llvm::SmallVectorImpl<mlir::Type>::append<mlir::Type const*,void>(v74, __p, &__p[1]);
  v62 = mlir::Operation::create(&__dst);
  mlir::OpBuilder::insert(v54, v62);
  v63 = *(*(v62 + 6) + 16);
  mlir::OperationState::~OperationState(&__dst);
  if (v63 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::ConstantOp,void>::id)
  {
    v64 = v62;
  }

  else
  {
    v64 = 0;
  }

  *&__dst = v64 - 16;
  result = mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith<mlir::Value &>((v66 - 16), &__dst);
LABEL_51:
  v65 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::ODIE::Compiler::Transforms::getValuesNotUsedByOps(uint64_t a1@<X0>, void *a2@<X8>)
{
  v3 = *(a1 + 24);
  v4 = *(a1 + 32);
  *a2 = a2 + 2;
  a2[1] = 0x600000000;
  if (v4)
  {
    v23 = &v3[v4];
    while (1)
    {
      v6 = *v3;
      v7 = *(*v3 + 36);
      v8 = *v3 - 16;
      v9 = v7 ? *v3 - 16 : 0;
      if (v7)
      {
        break;
      }

LABEL_27:
      if (++v3 == v23)
      {
        return;
      }
    }

    v10 = 0;
    while (1)
    {
      v11 = v9;
      if (!v10)
      {
        goto LABEL_14;
      }

      v12 = *(v6 - 8) & 7;
      v13 = v8;
      v14 = v10;
      if (v12 == 6)
      {
        goto LABEL_12;
      }

      v15 = (5 - v12);
      v14 = v10 - v15;
      if (v10 > v15)
      {
        break;
      }

      v11 = (v8 - 16 * v10);
LABEL_14:
      v16 = *v11;
      if (*v11)
      {
        while (1)
        {
          v24 = v16[2];
          v17 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>,mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>::doFind<mlir::Operation const*>(a1, &v24);
          if (!v17 || v17 == *a1 + 8 * *(a1 + 16))
          {
            break;
          }

          v16 = *v16;
          if (!v16)
          {
            goto LABEL_26;
          }
        }

        v18 = v9;
        if (v10)
        {
          v19 = *(v6 - 8) & 7;
          v20 = v8;
          v21 = v10;
          if (v19 == 6)
          {
            goto LABEL_23;
          }

          v22 = (5 - v19);
          v21 = v10 - v22;
          if (v10 <= v22)
          {
            v18 = v8 - 16 * v10;
          }

          else
          {
            v20 = v8 - 16 * v22;
LABEL_23:
            v18 = v20 - 24 * v21;
          }
        }

        llvm::SmallVectorTemplateBase<mlir::Value,true>::push_back(a2, v18);
      }

LABEL_26:
      if (++v10 == v7)
      {
        goto LABEL_27;
      }
    }

    v13 = v8 - 16 * v15;
LABEL_12:
    v11 = (v13 - 24 * v14);
    goto LABEL_14;
  }
}

uint64_t mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v55[6] = *MEMORY[0x277D85DE8];
  v50[0] = a3;
  v50[1] = a4;
  v5 = a1 + 64;
  v7 = *(a1 + 40);
  v6 = *(a1 + 44);
  v8 = (v6 >> 23) & 1;
  v9 = (v6 >> 21) & 0x7F8;
  v10 = (((a1 + 64 + 16 * v8 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v7);
  if (*v10 != v10)
  {
    v13 = 32 * v7;
    v53 = v55;
    v54 = 0x600000000;
    v14 = v10[1];
    if (v14)
    {
      v15 = v14 - 8;
    }

    else
    {
      v15 = 0;
    }

    v16 = *(v15 + 40);
    v17 = (v15 + 32);
    if (v16 == v17 || (v18 = *v17, v16 == *v17))
    {
      v21 = 0;
      v20 = v55;
    }

    else
    {
      do
      {
        llvm::SmallVectorTemplateBase<mlir::Operation *,true>::push_back(&v53, v16);
        v16 = *(v16 + 8);
      }

      while (v16 != v18);
      v19 = *(a1 + 44);
      v20 = v53;
      v21 = v54;
      v8 = (v19 >> 23) & 1;
      v9 = (v19 >> 21) & 0x7F8;
      v13 = 32 * *(a1 + 40);
    }

    v49 = 0;
    v41[0] = 0;
    v41[1] = 0;
    v42 = 0;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v51[0] = v52;
    v51[1] = 0x600000000;
    v40[0] = a5;
    v40[1] = &v49;
    v40[2] = v41;
    v40[3] = v51;
    v22 = *(a1 + 24);
    v40[4] = v50;
    v40[5] = v22;
    v39[0] = a5;
    v39[1] = v41;
    v38[0] = a5;
    v38[1] = &v49;
    v23 = *(((v5 + 16 * v8 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) + v13 + 8);
    if (v23)
    {
      v24 = v23 - 8;
    }

    else
    {
      v24 = 0;
    }

    v38[2] = v24;
    v38[3] = v41;
    v38[4] = v51;
    if (v21)
    {
      v25 = 8 * v21;
      do
      {
        v26 = *v20;
        if (*v20)
        {
          v27 = *(*(*v20 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id;
        }

        else
        {
          v27 = 0;
        }

        if (v27)
        {
          mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_1::operator()(v40, *v20);
        }

        else
        {
          v28 = mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID();
          if (((*(**(v26 + 48) + 32))(*(v26 + 48), v28) & 1) == 0)
          {
            v29 = v49;
            if (!v49)
            {
              v31 = *(a1 + 40);
              v30 = *(a1 + 44);
              mlir::OpBuilder::createBlock();
            }

            v37 = *(a5 + 24);
            *(a5 + 24) = v49;
            *(a5 + 32) = v29 + 32;
            mlir::detail::walk<mlir::ForwardIterator>(v26, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_3 const>, v38, 0);
            mlir::RewriterBase::moveOpBefore(a5, v26, v49, (v49 + 32));
            mlir::detail::walk<mlir::ForwardIterator>(v26, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_2 const>, v39, 0);
            if (v37)
            {
              *(a5 + 24) = v37;
            }

            else
            {
              *(a5 + 24) = 0;
              *(a5 + 32) = 0;
            }
          }
        }

        ++v20;
        v25 -= 8;
      }

      while (v25);
      v32 = *(a1 + 44);
      v8 = (v32 >> 23) & 1;
      v9 = (v32 >> 21) & 0x7F8;
      v13 = 32 * *(a1 + 40);
    }

    v33 = *(((v5 + 16 * v8 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) + v13 + 8);
    if (v33)
    {
      v34 = v33 - 8;
    }

    else
    {
      v34 = 0;
    }

    mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_1::operator()(v40, *(v34 + 32));
    if (v51[0] != v52)
    {
      free(v51[0]);
    }

    MEMORY[0x25F891030](v46, 8);
    MEMORY[0x25F891030](v43, 8);
    MEMORY[0x25F891030](v41[0], 8);
    if (v53 != v55)
    {
      free(v53);
    }
  }

  v35 = *MEMORY[0x277D85DE8];
  return 1;
}

uint64_t *mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_1::operator()(uint64_t *result, uint64_t a2)
{
  v90 = *MEMORY[0x277D85DE8];
  v2 = *result[1];
  if (v2)
  {
    v3 = v2 + 4;
    if (v2[4] != v2 + 4)
    {
      v5 = *result;
      v6 = result[4];
      v51 = result[5];
      v7 = result[3];
      v49 = *(v6 + 8);
      v50 = *v6;
      v56 = 0;
      v55 = 0u;
      v57 = &v59;
      v58 = 0;
      __src = &v55;
      v8 = v2[5];
      if (v8 != v3)
      {
        do
        {
          v9 = *(v8 + 8);
          mlir::detail::walk<mlir::ForwardIterator>(v8, llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::createIsolatedGroupOp(mlir::RewriterBase &,mlir::Location,mlir::Operation&,mlir::Block &,llvm::SmallVector<mlir::Value,6u> const&,llvm::StringRef)::$_0>, &__src, 1);
          v8 = v9;
        }

        while (v9 != v3);
      }

      mlir::ODIE::Compiler::Transforms::getValuesNotUsedByOps(&v55, &v63);
      v10 = v2[6];
      v11 = (v2[7] - v10) >> 3;
      v12 = (v10 & 0xFFFFFFFFFFFFFFF9);
      *&v87 = v10 & 0xFFFFFFFFFFFFFFF9;
      *(&v87 + 1) = 0;
      *&v88 = v10 & 0xFFFFFFFFFFFFFFF9;
      *(&v88 + 1) = v11;
      llvm::filter_iterator_base<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_0,std::bidirectional_iterator_tag>::findNextValid(&v87);
      __src = v12;
      *&v66 = v11;
      *(&v66 + 1) = v12;
      *&v67 = v11;
      llvm::filter_iterator_base<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_0,std::bidirectional_iterator_tag>::findNextValid(&__src);
      v13 = v66;
      v60[0] = 0;
      v60[1] = 0;
      v61 = 0;
      v66 = v87;
      v67 = v88;
      v68 = v89;
      __src = 0;
      for (i = *(&v87 + 1); *(&v66 + 1) != v13; i = *(&v66 + 1))
      {
        v15 = __src;
        v52 = __src;
        v53[0] = mlir::ValueRange::dereference_iterator(&v66, i);
        *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](v60, v53) = v52;
        __src = v15 + 1;
        *(&v66 + 1) = i + 1;
        llvm::filter_iterator_base<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_0,std::bidirectional_iterator_tag>::findNextValid(&v66);
      }

      v16 = v63;
      v17 = v64;
      v18 = v63 + 8 * v64;
      v19 = v63;
      if (v64)
      {
        v20 = 8 * v64;
        v19 = v63;
        do
        {
          if (*(*(*(*v19 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
          {
            goto LABEL_12;
          }

          v19 += 8;
          v20 -= 8;
        }

        while (v20);
        __src = &v66 + 8;
        *&v66 = 0x600000000;
      }

      else
      {
LABEL_12:
        __src = &v66 + 8;
        *&v66 = 0x600000000;
        if (v19 == v18)
        {
          LODWORD(v20) = 0;
        }

        else
        {
          v21 = 0;
          v22 = v19;
          do
          {
            v23 = v21++;
            do
            {
              v22 += 8;
              if (v22 == v18)
              {
                goto LABEL_18;
              }
            }

            while (*(*(*(*v22 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id);
          }

          while (v22 != v18);
LABEL_18:
          if (v23 < 6)
          {
            v24 = 0;
            v26 = 0;
            v25 = &v66 + 8;
          }

          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(&__src, &v66 + 8, v21, 8);
            v24 = v66;
            v25 = __src;
            v26 = v66;
          }

          v27 = &v25[8 * v24];
          v28 = *v19;
          do
          {
            *v27 = v28;
            do
            {
              v19 += 8;
              if (v19 == v18)
              {
                goto LABEL_27;
              }

              v28 = *v19;
            }

            while (*(*(*(*v19 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id);
            v27 += 8;
          }

          while (v19 != v18);
LABEL_27:
          LODWORD(v20) = v26 + v21;
          v16 = v63;
          v17 = v64;
        }

        LODWORD(v66) = v20;
        v18 = &v16[8 * v17];
        v29 = v16;
        if (!v17)
        {
LABEL_33:
          if (v29 != v18)
          {
            v30 = v29 + 8;
            if (v29 + 8 != v18)
            {
              do
              {
                if (*(*(*(*v30 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
                {
                  *v29 = *v30;
                  v29 += 8;
                }

                v30 += 8;
              }

              while (v30 != v18);
              v16 = v63;
            }
          }

          goto LABEL_39;
        }
      }

      v29 = v16;
      do
      {
        if (*(*(*(*v29 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::TokenType,void>::id)
        {
          goto LABEL_33;
        }

        v29 += 8;
      }

      while (v29 != v18);
      v29 = v18;
LABEL_39:
      v64 = (v29 - v16) >> 3;
      v59 = v60;
      v52 = &v59;
      v31 = 126 - 2 * __clz(v20);
      if (v20)
      {
        v32 = v31;
      }

      else
      {
        v32 = 0;
      }

      std::__introsort<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,false>(__src, __src + v20, &v52, v32, 1);
      llvm::SmallVectorImpl<mlir::Value>::append<mlir::Value*,void>(&v63, __src, __src + 8 * v66);
      if (__src != &v66 + 8)
      {
        free(__src);
      }

      MEMORY[0x25F891030](v60[0], 8);
      v48 = *(v5 + 24);
      *(v5 + 24) = v2;
      *(v5 + 32) = v3;
      v33 = mlir::OpBuilder::getCheckRegisteredInfo<mlir::ODIE::Compiler::CoreML::YieldOp>(v5 + 8, *(**v51 + 32));
      __src = v51;
      *&v66 = v33;
      *(&v66 + 1) = &v67 + 8;
      *&v67 = 0x400000000;
      v69 = v71;
      v70 = 0x400000000;
      v72 = v74;
      v73 = 0x400000000;
      v75 = 4;
      v76 = &v78;
      v77 = 0x100000000;
      v79 = &v81;
      v80 = 0x100000000;
      v83 = 0;
      v82 = 0;
      v84 = &mlir::detail::TypeIDResolver<void,void>::id;
      v85 = 0;
      v86 = 0;
      llvm::SmallVectorImpl<mlir::Value>::append<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(&v66 + 8, v63 & 0xFFFFFFFFFFFFFFF9, 0, v63 & 0xFFFFFFFFFFFFFFF9, v64);
      v34 = mlir::Operation::create(&__src);
      mlir::OpBuilder::insert((v5 + 8), v34);
      mlir::OperationState::~OperationState(&__src);
      *(v5 + 24) = *(a2 + 16);
      *(v5 + 32) = a2;
      v35 = *(v5 + 8);
      v36 = *(v7 + 8);
      v37 = (*v7 & 0xFFFFFFFFFFFFFFF8);
      if (!v36)
      {
        v37 = 0;
      }

      v38 = v63 & 0xFFFFFFFFFFFFFFF8;
      if (!v64)
      {
        v38 = 0;
      }

      __src = v37;
      *&v66 = v36;
      *&v87 = v38;
      *(&v87 + 1) = v64;
      v39 = mlir::detail::TypeUniquer::get<mlir::FunctionType,mlir::TypeRange &,mlir::TypeRange &>(v35, &__src, &v87);
      v40 = *(v39 + 16);
      v41 = *(v39 + 8);
      v42 = *(v39 + 12);
      v54 = 261;
      v52 = v50;
      v53[0] = v49;
      v44 = mlir::StringAttr::get(*(v5 + 8), &v52, v43);
      v45 = mlir::RegisteredOperationName::lookup(&mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id, *(**v51 + 32));
      if (v46)
      {
        __src = v51;
        *&v66 = v45;
        *(&v66 + 1) = &v67 + 8;
        *&v67 = 0x400000000;
        v69 = v71;
        v70 = 0x400000000;
        v72 = v74;
        v73 = 0x400000000;
        v75 = 4;
        v76 = &v78;
        v77 = 0x100000000;
        v79 = &v81;
        v80 = 0x100000000;
        v83 = 0;
        v82 = 0;
        v84 = &mlir::detail::TypeIDResolver<void,void>::id;
        v85 = 0;
        v86 = 0;
        mlir::ODIE::Compiler::CoreML::IsolatedGroupOp::build(v5 + 8, &__src, (v40 + 8 * v41) & 0xFFFFFFFFFFFFFFF9 | 2, v42, *v7 & 0xFFFFFFFFFFFFFFF9, *(v7 + 8), v44, 0, 0);
      }

      LOWORD(v89) = 1283;
      *&v88 = "coreml.isolated_group";
      *(&v88 + 1) = 21;
      v62 = 259;
      llvm::operator+(&v87, v60, &__src);
      llvm::report_fatal_error(&__src, 1);
    }
  }

  v47 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::ODIE::Compiler::Transforms::createIsolatedGroupOp(mlir::RewriterBase &,mlir::Location,mlir::Operation &,mlir::Block &,llvm::SmallVector<mlir::Value,6u> const&,llvm::StringRef)::$_1>(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 16);
  while (1)
  {
    v3 = *(v2 + 16);
    if (!v3)
    {
      break;
    }

    v4 = *(v3 + 24) & 0xFFFFFFFFFFFFFFF8;
    if (!v4)
    {
      break;
    }

    v2 = *(v4 + 16);
    if (!v2)
    {
      break;
    }

    if (*(*(v2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::IsolatedGroupOp,void>::id)
    {
      return 0;
    }
  }

  return 1;
}

unint64_t llvm::filter_iterator_base<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_0,std::bidirectional_iterator_tag>::findNextValid(unint64_t result)
{
  v1 = *(result + 8);
  if (v1 != *(result + 24))
  {
    v2 = result;
    do
    {
      result = mlir::ValueRange::dereference_iterator(v2, v1);
      if (*(*(*(result + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::CoreML::HandleType,void>::id)
      {
        break;
      }

      v1 = v2[1] + 1;
      v2[1] = v1;
    }

    while (v1 != v2[3]);
  }

  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,false>(uint64_t result, uint64_t *a2, uint64_t ***a3, uint64_t a4, char a5)
{
  v9 = result;
  while (2)
  {
    v198 = a2 - 1;
    v190 = a2 - 3;
    v192 = a2 - 2;
    v195 = a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          v10 = a2 - v9;
          if (v10 > 2)
          {
            switch(v10)
            {
              case 3:
                return std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9, v9 + 1, v198, a3);
              case 4:
                return std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9, v9 + 1, v9 + 2, v198, a3);
              case 5:
                return std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9, v9 + 1, v9 + 2, v9 + 3, v198, a3);
            }
          }

          else
          {
            if (v10 < 2)
            {
              return result;
            }

            if (v10 == 2)
            {
              v91 = *v9;
              v92 = *a3;
              HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*(a2 - 1));
              v200 = HandleForToken;
              if (HandleForToken)
              {
                v94 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v92, &v200);
              }

              else
              {
                v94 = -1;
              }

              v187 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v91);
              v200 = result;
              if (result)
              {
                result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v187, &v200);
                v188 = *result;
              }

              else
              {
                v188 = -1;
              }

              if (v94 < v188)
              {
                v189 = *v9;
                *v9 = *(a2 - 1);
                *(a2 - 1) = v189;
              }

              return result;
            }
          }

          if (v10 <= 23)
          {
            v95 = v9 + 1;
            v97 = v9 == a2 || v95 == a2;
            if (a5)
            {
              if (!v97)
              {
                v98 = 0;
                v99 = v9;
                do
                {
                  v101 = *v99;
                  v100 = v99[1];
                  v99 = v95;
                  v102 = *a3;
                  v200 = mlir::ODIE::Compiler::getHandleForToken(v100);
                  if (v200)
                  {
                    v103 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v102, &v200);
                  }

                  else
                  {
                    v103 = -1;
                  }

                  v104 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v101);
                  v200 = result;
                  if (result)
                  {
                    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v104, &v200);
                    v105 = *result;
                  }

                  else
                  {
                    v105 = -1;
                  }

                  if (v103 < v105)
                  {
                    v106 = *v99;
                    v107 = v98;
                    while (1)
                    {
                      *(v9 + v107 + 8) = *(v9 + v107);
                      if (!v107)
                      {
                        break;
                      }

                      v108 = *(v9 + v107 - 8);
                      v109 = *a3;
                      v200 = mlir::ODIE::Compiler::getHandleForToken(v106);
                      if (v200)
                      {
                        v110 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v109, &v200);
                      }

                      else
                      {
                        v110 = -1;
                      }

                      v111 = *a3;
                      result = mlir::ODIE::Compiler::getHandleForToken(v108);
                      v200 = result;
                      if (result)
                      {
                        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v111, &v200);
                        v112 = *result;
                      }

                      else
                      {
                        v112 = -1;
                      }

                      v107 -= 8;
                      v113 = v110 < v112;
                      a2 = v195;
                      if (!v113)
                      {
                        v114 = (v9 + v107 + 8);
                        goto LABEL_162;
                      }
                    }

                    v114 = v9;
LABEL_162:
                    *v114 = v106;
                  }

                  v95 = v99 + 1;
                  v98 += 8;
                }

                while (v99 + 1 != a2);
              }
            }

            else if (!v97)
            {
              do
              {
                v175 = *v9;
                v174 = v9[1];
                v9 = v95;
                v176 = *a3;
                v200 = mlir::ODIE::Compiler::getHandleForToken(v174);
                if (v200)
                {
                  v177 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v176, &v200);
                }

                else
                {
                  v177 = -1;
                }

                v178 = *a3;
                result = mlir::ODIE::Compiler::getHandleForToken(v175);
                v200 = result;
                if (result)
                {
                  result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v178, &v200);
                  v179 = *result;
                }

                else
                {
                  v179 = -1;
                }

                if (v177 < v179)
                {
                  v180 = *v9;
                  v181 = v9;
                  do
                  {
                    v182 = *(v181 - 2);
                    *v181 = *(v181 - 1);
                    v183 = *a3;
                    v200 = mlir::ODIE::Compiler::getHandleForToken(v180);
                    if (v200)
                    {
                      v184 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v183, &v200);
                    }

                    else
                    {
                      v184 = -1;
                    }

                    v185 = *a3;
                    result = mlir::ODIE::Compiler::getHandleForToken(v182);
                    v200 = result;
                    if (result)
                    {
                      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v185, &v200);
                      v186 = *result;
                    }

                    else
                    {
                      v186 = -1;
                    }

                    --v181;
                  }

                  while (v184 < v186);
                  *v181 = v180;
                }

                v95 = v9 + 1;
              }

              while (v9 + 1 != a2);
            }

            return result;
          }

          v197 = v9;
          if (!a4)
          {
            if (v9 != a2)
            {
              v115 = (v10 - 2) >> 1;
              v116 = v115;
              do
              {
                v117 = v116;
                if (v115 >= v116)
                {
                  v118 = (2 * v116) | 1;
                  v119 = &v197[v118];
                  v120 = 2 * v116 + 2;
                  v191 = v116;
                  if (v120 < v10)
                  {
                    v121 = v119[1];
                    v122 = *a3;
                    v200 = mlir::ODIE::Compiler::getHandleForToken(*v119);
                    if (v200)
                    {
                      v123 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v122, &v200);
                    }

                    else
                    {
                      v123 = -1;
                    }

                    v124 = *a3;
                    v200 = mlir::ODIE::Compiler::getHandleForToken(v121);
                    if (v200)
                    {
                      v125 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v124, &v200);
                    }

                    else
                    {
                      v125 = -1;
                    }

                    if (v123 < v125)
                    {
                      ++v119;
                      v118 = v120;
                    }

                    v115 = (v10 - 2) >> 1;
                    v117 = v191;
                  }

                  v126 = &v197[v117];
                  v127 = *v126;
                  v128 = *a3;
                  v200 = mlir::ODIE::Compiler::getHandleForToken(*v119);
                  if (v200)
                  {
                    v129 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v128, &v200);
                  }

                  else
                  {
                    v129 = -1;
                  }

                  v130 = *a3;
                  result = mlir::ODIE::Compiler::getHandleForToken(v127);
                  v200 = result;
                  if (result)
                  {
                    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v130, &v200);
                    v131 = *result;
                  }

                  else
                  {
                    v131 = -1;
                  }

                  v117 = v191;
                  if (v129 >= v131)
                  {
                    v132 = *v126;
                    v193 = *v126;
                    do
                    {
                      v133 = v119;
                      *v126 = *v119;
                      if (v115 < v118)
                      {
                        break;
                      }

                      v134 = (2 * v118) | 1;
                      v119 = &v197[v134];
                      v118 = 2 * v118 + 2;
                      if (v118 >= v10)
                      {
                        v118 = v134;
                      }

                      else
                      {
                        v135 = v119[1];
                        v136 = *a3;
                        v200 = mlir::ODIE::Compiler::getHandleForToken(*v119);
                        v137 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v136, &v200) : -1;
                        v138 = *a3;
                        v200 = mlir::ODIE::Compiler::getHandleForToken(v135);
                        v139 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v138, &v200) : -1;
                        if (v137 >= v139)
                        {
                          v118 = v134;
                        }

                        else
                        {
                          ++v119;
                        }

                        v115 = (v10 - 2) >> 1;
                        v132 = v193;
                      }

                      v140 = *a3;
                      v200 = mlir::ODIE::Compiler::getHandleForToken(*v119);
                      v141 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v140, &v200) : -1;
                      v142 = *a3;
                      result = mlir::ODIE::Compiler::getHandleForToken(v132);
                      v200 = result;
                      if (result)
                      {
                        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v142, &v200);
                        v143 = *result;
                      }

                      else
                      {
                        v143 = -1;
                      }

                      v126 = v133;
                    }

                    while (v141 >= v143);
                    *v133 = v132;
                    a2 = v195;
                    v117 = v191;
                  }
                }

                v116 = v117 - 1;
              }

              while (v117);
              v144 = v197;
              do
              {
                v145 = 0;
                v194 = *v144;
                v196 = a2;
                v146 = (v10 - 2) >> 1;
                v147 = v144;
                v199 = v10;
                do
                {
                  v148 = &v147[v145];
                  v149 = v148 + 1;
                  v150 = (2 * v145) | 1;
                  v151 = 2 * v145 + 2;
                  if (v151 >= v10)
                  {
                    v145 = (2 * v145) | 1;
                  }

                  else
                  {
                    v154 = v148[2];
                    v153 = v148 + 2;
                    v152 = v154;
                    v155 = *a3;
                    v200 = mlir::ODIE::Compiler::getHandleForToken(*(v153 - 1));
                    if (v200)
                    {
                      v156 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v155, &v200);
                    }

                    else
                    {
                      v156 = -1;
                    }

                    v157 = *a3;
                    result = mlir::ODIE::Compiler::getHandleForToken(v152);
                    v200 = result;
                    if (result)
                    {
                      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v157, &v200);
                      v158 = *result;
                    }

                    else
                    {
                      v158 = -1;
                    }

                    v10 = v199;
                    if (v156 >= v158)
                    {
                      v145 = v150;
                    }

                    else
                    {
                      v149 = v153;
                      v145 = v151;
                    }
                  }

                  *v147 = *v149;
                  v147 = v149;
                }

                while (v145 <= v146);
                a2 = v196 - 1;
                if (v149 == v196 - 1)
                {
                  *v149 = v194;
                  v144 = v197;
                }

                else
                {
                  *v149 = *a2;
                  *a2 = v194;
                  v144 = v197;
                  v159 = (v149 - v197 + 8) >> 3;
                  v113 = v159 < 2;
                  v160 = v159 - 2;
                  if (!v113)
                  {
                    v161 = v160 >> 1;
                    v162 = &v197[v160 >> 1];
                    v163 = *v149;
                    v164 = *a3;
                    v200 = mlir::ODIE::Compiler::getHandleForToken(*v162);
                    v165 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v164, &v200) : -1;
                    v166 = *a3;
                    result = mlir::ODIE::Compiler::getHandleForToken(v163);
                    v200 = result;
                    if (result)
                    {
                      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v166, &v200);
                      v167 = *result;
                    }

                    else
                    {
                      v167 = -1;
                    }

                    if (v165 < v167)
                    {
                      v168 = *v149;
                      do
                      {
                        v169 = v162;
                        *v149 = *v162;
                        if (!v161)
                        {
                          break;
                        }

                        v161 = (v161 - 1) >> 1;
                        v162 = &v197[v161];
                        v170 = *a3;
                        v200 = mlir::ODIE::Compiler::getHandleForToken(*v162);
                        v171 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v170, &v200) : -1;
                        v172 = *a3;
                        result = mlir::ODIE::Compiler::getHandleForToken(v168);
                        v200 = result;
                        if (result)
                        {
                          result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v172, &v200);
                          v173 = *result;
                        }

                        else
                        {
                          v173 = -1;
                        }

                        v149 = v169;
                      }

                      while (v171 < v173);
                      *v169 = v168;
                      a2 = v196 - 1;
                      v10 = v199;
                    }
                  }
                }

                v113 = v10-- <= 2;
              }

              while (!v113);
            }

            return result;
          }

          v11 = v10 >> 1;
          v12 = &v9[v10 >> 1];
          if (v10 < 0x81)
          {
            std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(&v9[v10 >> 1], v9, v198, a3);
          }

          else
          {
            std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9, &v9[v10 >> 1], v198, a3);
            std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9 + 1, v12 - 1, v192, a3);
            std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v9 + 2, &v9[v11 + 1], v190, a3);
            std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(v12 - 1, v12, &v9[v11 + 1], a3);
            v13 = *v9;
            *v9 = *v12;
            *v12 = v13;
          }

          --a4;
          if (a5)
          {
            break;
          }

          v14 = *v9;
          v15 = *a3;
          v200 = mlir::ODIE::Compiler::getHandleForToken(*(v9 - 1));
          v16 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v15, &v200) : -1;
          v17 = *a3;
          v200 = mlir::ODIE::Compiler::getHandleForToken(v14);
          v18 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v17, &v200) : -1;
          if (v16 < v18)
          {
            break;
          }

          v52 = *v9;
          v53 = *v198;
          v54 = *a3;
          v200 = mlir::ODIE::Compiler::getHandleForToken(*v9);
          if (v200)
          {
            v55 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v54, &v200);
          }

          else
          {
            v55 = -1;
          }

          v56 = *a3;
          result = mlir::ODIE::Compiler::getHandleForToken(v53);
          v200 = result;
          if (result)
          {
            result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v56, &v200);
            v57 = *result;
          }

          else
          {
            v57 = -1;
          }

          if (v55 >= v57)
          {
            v64 = v9 + 1;
            do
            {
              v9 = v64;
              if (v64 >= a2)
              {
                break;
              }

              v65 = *v64;
              v66 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v52);
              v67 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v66, &v200) : -1;
              v68 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v65);
              v200 = result;
              if (result)
              {
                result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v68, &v200);
                v69 = *result;
              }

              else
              {
                v69 = -1;
              }

              v64 = v9 + 1;
            }

            while (v67 >= v69);
          }

          else
          {
            do
            {
              v59 = v9[1];
              ++v9;
              v58 = v59;
              v60 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v52);
              if (v200)
              {
                v61 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v60, &v200);
              }

              else
              {
                v61 = -1;
              }

              v62 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v58);
              v200 = result;
              if (result)
              {
                result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v62, &v200);
                v63 = *result;
              }

              else
              {
                v63 = -1;
              }
            }

            while (v61 >= v63);
          }

          v70 = a2;
          if (v9 < a2)
          {
            v70 = a2;
            do
            {
              v72 = *--v70;
              v71 = v72;
              v73 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v52);
              if (v200)
              {
                v74 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v73, &v200);
              }

              else
              {
                v74 = -1;
              }

              v75 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v71);
              v200 = result;
              if (result)
              {
                result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v75, &v200);
                v76 = *result;
              }

              else
              {
                v76 = -1;
              }
            }

            while (v74 < v76);
          }

          while (v9 < v70)
          {
            v77 = *v9;
            *v9 = *v70;
            *v70 = v77;
            do
            {
              v79 = v9[1];
              ++v9;
              v78 = v79;
              v80 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v52);
              if (v200)
              {
                v81 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v80, &v200);
              }

              else
              {
                v81 = -1;
              }

              v82 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v78);
              if (v200)
              {
                v83 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v82, &v200);
              }

              else
              {
                v83 = -1;
              }
            }

            while (v81 >= v83);
            do
            {
              v85 = *--v70;
              v84 = v85;
              v86 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v52);
              if (v200)
              {
                v87 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v86, &v200);
              }

              else
              {
                v87 = -1;
              }

              v88 = *a3;
              result = mlir::ODIE::Compiler::getHandleForToken(v84);
              v200 = result;
              if (result)
              {
                result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v88, &v200);
                v89 = *result;
              }

              else
              {
                v89 = -1;
              }
            }

            while (v87 < v89);
          }

          v90 = v9 - 1;
          if (v9 - 1 != v197)
          {
            *v197 = *v90;
          }

          a5 = 0;
          *v90 = v52;
        }

        v19 = 0;
        v20 = *v9;
        do
        {
          v21 = *a3;
          v200 = mlir::ODIE::Compiler::getHandleForToken(v9[v19 + 1]);
          if (v200)
          {
            v22 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v21, &v200);
          }

          else
          {
            v22 = -1;
          }

          v23 = *a3;
          v200 = mlir::ODIE::Compiler::getHandleForToken(v20);
          if (v200)
          {
            v24 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v23, &v200);
          }

          else
          {
            v24 = -1;
          }

          ++v19;
        }

        while (v22 < v24);
        v25 = &v9[v19];
        v26 = a2;
        if (v19 == 1)
        {
          v26 = a2;
          do
          {
            if (v25 >= v26)
            {
              break;
            }

            v32 = *--v26;
            v33 = *a3;
            v200 = mlir::ODIE::Compiler::getHandleForToken(v32);
            v34 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v33, &v200) : -1;
            v35 = *a3;
            v200 = mlir::ODIE::Compiler::getHandleForToken(v20);
            v36 = v200 ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v35, &v200) : -1;
          }

          while (v34 >= v36);
        }

        else
        {
          do
          {
            v27 = *--v26;
            v28 = *a3;
            v200 = mlir::ODIE::Compiler::getHandleForToken(v27);
            if (v200)
            {
              v29 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v28, &v200);
            }

            else
            {
              v29 = -1;
            }

            v30 = *a3;
            v200 = mlir::ODIE::Compiler::getHandleForToken(v20);
            if (v200)
            {
              v31 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v30, &v200);
            }

            else
            {
              v31 = -1;
            }
          }

          while (v29 >= v31);
        }

        if (v25 >= v26)
        {
          v50 = v25 - 1;
        }

        else
        {
          v37 = v25;
          v38 = v26;
          do
          {
            v39 = *v37;
            *v37 = *v38;
            *v38 = v39;
            do
            {
              v40 = v37[1];
              ++v37;
              v41 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v40);
              if (v200)
              {
                v42 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v41, &v200);
              }

              else
              {
                v42 = -1;
              }

              v43 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v20);
              if (v200)
              {
                v44 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v43, &v200);
              }

              else
              {
                v44 = -1;
              }
            }

            while (v42 < v44);
            do
            {
              v45 = *--v38;
              v46 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v45);
              if (v200)
              {
                v47 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v46, &v200);
              }

              else
              {
                v47 = -1;
              }

              v48 = *a3;
              v200 = mlir::ODIE::Compiler::getHandleForToken(v20);
              if (v200)
              {
                v49 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v48, &v200);
              }

              else
              {
                v49 = -1;
              }
            }

            while (v47 >= v49);
          }

          while (v37 < v38);
          v50 = v37 - 1;
          a2 = v195;
        }

        if (v50 != v197)
        {
          *v197 = *v50;
        }

        *v50 = v20;
        if (v25 >= v26)
        {
          break;
        }

LABEL_74:
        result = std::__introsort<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,false>(v197, v50, a3, a4, a5 & 1);
        a5 = 0;
        v9 = v50 + 1;
      }

      v51 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*>(v197, v50, a3);
      v9 = v50 + 1;
      result = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*>(v50 + 1, a2, a3);
      if (result)
      {
        break;
      }

      if (!v51)
      {
        goto LABEL_74;
      }
    }

    a2 = v50;
    v9 = v197;
    if (!v51)
    {
      continue;
    }

    return result;
  }
}

int *std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t ***a4)
{
  v8 = *a1;
  v9 = *a4;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
  if (HandleForToken)
  {
    v10 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v9, &HandleForToken);
  }

  else
  {
    v10 = -1;
  }

  v11 = *a4;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v8);
  if (HandleForToken)
  {
    v12 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v11, &HandleForToken);
  }

  else
  {
    v12 = -1;
  }

  v13 = *a3;
  v14 = *a2;
  v15 = *a4;
  if (v10 >= v12)
  {
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
    if (HandleForToken)
    {
      v17 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v15, &HandleForToken);
    }

    else
    {
      v17 = -1;
    }

    v21 = *a4;
    result = mlir::ODIE::Compiler::getHandleForToken(v14);
    HandleForToken = result;
    if (result)
    {
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v21, &HandleForToken);
      v22 = *result;
    }

    else
    {
      v22 = -1;
    }

    if (v17 < v22)
    {
      v26 = *a2;
      *a2 = *a3;
      *a3 = v26;
      v27 = *a1;
      v28 = *a4;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
      v29 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v28, &HandleForToken) : -1;
      v32 = *a4;
      result = mlir::ODIE::Compiler::getHandleForToken(v27);
      HandleForToken = result;
      if (result)
      {
        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v32, &HandleForToken);
        v33 = *result;
      }

      else
      {
        v33 = -1;
      }

      if (v29 < v33)
      {
        v35 = *a1;
        *a1 = *a2;
        *a2 = v35;
      }
    }
  }

  else
  {
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
    if (HandleForToken)
    {
      v16 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v15, &HandleForToken);
    }

    else
    {
      v16 = -1;
    }

    v18 = *a4;
    result = mlir::ODIE::Compiler::getHandleForToken(v14);
    HandleForToken = result;
    if (result)
    {
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v18, &HandleForToken);
      v20 = *result;
    }

    else
    {
      v20 = -1;
    }

    v23 = *a1;
    if (v16 >= v20)
    {
      *a1 = *a2;
      *a2 = v23;
      v24 = *a4;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
      if (HandleForToken)
      {
        v25 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v24, &HandleForToken);
      }

      else
      {
        v25 = -1;
      }

      v30 = *a4;
      result = mlir::ODIE::Compiler::getHandleForToken(v23);
      HandleForToken = result;
      if (result)
      {
        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v30, &HandleForToken);
        v31 = *result;
      }

      else
      {
        v31 = -1;
      }

      if (v25 < v31)
      {
        v34 = *a2;
        *a2 = *a3;
        *a3 = v34;
      }
    }

    else
    {
      *a1 = *a3;
      *a3 = v23;
    }
  }

  return result;
}

int *std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t ***a5)
{
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a2, a3, a5);
  v10 = *a3;
  v11 = *a5;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a4);
  if (HandleForToken)
  {
    v12 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v11, &HandleForToken);
  }

  else
  {
    v12 = -1;
  }

  v13 = *a5;
  result = mlir::ODIE::Compiler::getHandleForToken(v10);
  HandleForToken = result;
  if (result)
  {
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v13, &HandleForToken);
    v15 = *result;
  }

  else
  {
    v15 = -1;
  }

  if (v12 < v15)
  {
    v16 = *a3;
    *a3 = *a4;
    *a4 = v16;
    v17 = *a2;
    v18 = *a5;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
    v19 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v18, &HandleForToken) : -1;
    v20 = *a5;
    result = mlir::ODIE::Compiler::getHandleForToken(v17);
    HandleForToken = result;
    if (result)
    {
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v20, &HandleForToken);
      v21 = *result;
    }

    else
    {
      v21 = -1;
    }

    if (v19 < v21)
    {
      v22 = *a2;
      *a2 = *a3;
      *a3 = v22;
      v23 = *a1;
      v24 = *a5;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
      if (HandleForToken)
      {
        v25 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v24, &HandleForToken);
      }

      else
      {
        v25 = -1;
      }

      v26 = *a5;
      result = mlir::ODIE::Compiler::getHandleForToken(v23);
      HandleForToken = result;
      if (result)
      {
        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v26, &HandleForToken);
        v27 = *result;
      }

      else
      {
        v27 = -1;
      }

      if (v25 < v27)
      {
        v28 = *a1;
        *a1 = *a2;
        *a2 = v28;
      }
    }
  }

  return result;
}

int *std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t ***a6)
{
  std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a2, a3, a4, a6);
  v12 = *a4;
  v13 = *a6;
  HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a5);
  if (HandleForToken)
  {
    v14 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v13, &HandleForToken);
  }

  else
  {
    v14 = -1;
  }

  v15 = *a6;
  result = mlir::ODIE::Compiler::getHandleForToken(v12);
  HandleForToken = result;
  if (result)
  {
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v15, &HandleForToken);
    v17 = *result;
  }

  else
  {
    v17 = -1;
  }

  if (v14 < v17)
  {
    v18 = *a4;
    *a4 = *a5;
    *a5 = v18;
    v19 = *a3;
    v20 = *a6;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a4);
    v21 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v20, &HandleForToken) : -1;
    v22 = *a6;
    result = mlir::ODIE::Compiler::getHandleForToken(v19);
    HandleForToken = result;
    if (result)
    {
      result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v22, &HandleForToken);
      v23 = *result;
    }

    else
    {
      v23 = -1;
    }

    if (v21 < v23)
    {
      v24 = *a3;
      *a3 = *a4;
      *a4 = v24;
      v25 = *a2;
      v26 = *a6;
      HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a3);
      v27 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v26, &HandleForToken) : -1;
      v28 = *a6;
      result = mlir::ODIE::Compiler::getHandleForToken(v25);
      HandleForToken = result;
      if (result)
      {
        result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v28, &HandleForToken);
        v29 = *result;
      }

      else
      {
        v29 = -1;
      }

      if (v27 < v29)
      {
        v30 = *a2;
        *a2 = *a3;
        *a3 = v30;
        v31 = *a1;
        v32 = *a6;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*a2);
        if (HandleForToken)
        {
          v33 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v32, &HandleForToken);
        }

        else
        {
          v33 = -1;
        }

        v34 = *a6;
        result = mlir::ODIE::Compiler::getHandleForToken(v31);
        HandleForToken = result;
        if (result)
        {
          result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v34, &HandleForToken);
          v35 = *result;
        }

        else
        {
          v35 = -1;
        }

        if (v33 < v35)
        {
          v36 = *a1;
          *a1 = *a2;
          *a2 = v36;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*>(uint64_t *a1, uint64_t *a2, uint64_t ***a3)
{
  v5 = a2 - a1;
  if (v5 <= 2)
  {
    if (v5 >= 2)
    {
      if (v5 == 2)
      {
        v6 = *a1;
        v7 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*(a2 - 1));
        if (HandleForToken)
        {
          v8 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v7, &HandleForToken);
        }

        else
        {
          v8 = -1;
        }

        v26 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v6);
        if (HandleForToken)
        {
          v27 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v26, &HandleForToken);
        }

        else
        {
          v27 = -1;
        }

        if (v8 < v27)
        {
          v28 = *a1;
          *a1 = *(a2 - 1);
          *(a2 - 1) = v28;
        }

        return 1;
      }

      goto LABEL_11;
    }

    return 1;
  }

  switch(v5)
  {
    case 3:
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
  }

LABEL_11:
  v9 = a1 + 2;
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,mlir::ODIE::Compiler::Transforms::fixupResultTokens(mlir::ValueRange,llvm::SmallVector<mlir::Value,6u> &)::$_3 &,mlir::Value*,0>(a1, a1 + 1, a1 + 2, a3);
  v10 = a1 + 3;
  if (a1 + 3 == a2)
  {
    return 1;
  }

  v11 = 0;
  v12 = 0;
  while (1)
  {
    v13 = *v9;
    v14 = *a3;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(*v10);
    v15 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v14, &HandleForToken) : -1;
    v16 = *a3;
    HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v13);
    v17 = HandleForToken ? *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v16, &HandleForToken) : -1;
    if (v15 < v17)
    {
      v18 = *v10;
      v19 = v11;
      while (1)
      {
        *(a1 + v19 + 24) = *(a1 + v19 + 16);
        if (v19 == -16)
        {
          break;
        }

        v20 = *(a1 + v19 + 8);
        v21 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v18);
        if (HandleForToken)
        {
          v22 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v21, &HandleForToken);
        }

        else
        {
          v22 = -1;
        }

        v23 = *a3;
        HandleForToken = mlir::ODIE::Compiler::getHandleForToken(v20);
        if (HandleForToken)
        {
          v24 = *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>,mlir::Value,unsigned long,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned long>>::operator[](*v23, &HandleForToken);
        }

        else
        {
          v24 = -1;
        }

        v19 -= 8;
        if (v22 >= v24)
        {
          v25 = (a1 + v19 + 24);
          goto LABEL_31;
        }
      }

      v25 = a1;
LABEL_31:
      *v25 = v18;
      if (++v12 == 8)
      {
        return v10 + 1 == a2;
      }
    }

    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
    {
      return 1;
    }
  }
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_3 const>(void *a1, uint64_t a2)
{
  v33[6] = *MEMORY[0x277D85DE8];
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v2 = *(a2 + 68);
    if (v2)
    {
      v4 = *(a2 + 72);
      v5 = &v4[4 * v2];
      do
      {
        v6 = v4[3];
        if ((~*(v6 + 2) & 7) != 0)
        {
          v7 = v4[3];
        }

        else
        {
          v7 = 0;
        }

        v8 = v7 != 0;
        if (v7)
        {
          v9 = *(v7 + 8) & 7;
          if (v9 == 6)
          {
            v10 = v7 + 24 * *(v7 + 16);
            v11 = a1[2];
            v12 = v10 + 120;
            if (v10 == -120)
            {
              goto LABEL_13;
            }
          }

          else
          {
            v12 = v7 + 16 * v9 + 16;
            v11 = a1[2];
          }

          if (*(v12 + 16) != v11)
          {
LABEL_13:
            v8 = 0;
            goto LABEL_18;
          }

          v13 = mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID();
          if ((*(**(v12 + 48) + 32))(*(v12 + 48), v13))
          {
            v14 = mlir::OpBuilder::clone((*a1 + 8), v12);
            v32[0] = v33;
            v32[1] = 0x600000000;
            if (mlir::OpBuilder::tryFold((*a1 + 8), v14, v32))
            {
              (*(**a1 + 16))(*a1, v14);
            }

            else
            {
              v31 = v14 - 4;
              llvm::SmallVectorImpl<mlir::Value>::emplace_back<mlir::OpResult>(v32, &v31);
            }

            v26 = *v32[0];
            v27 = v4[1];
            if (v27)
            {
              v28 = *v4;
              *v27 = *v4;
              if (v28)
              {
                *(v28 + 8) = v4[1];
              }
            }

            v4[3] = v26;
            v4[1] = v26;
            v29 = *v26;
            *v4 = *v26;
            if (v29)
            {
              *(v29 + 8) = v4;
            }

            *v26 = v4;
            if (v32[0] != v33)
            {
              free(v32[0]);
            }

            goto LABEL_38;
          }
        }

        v11 = a1[2];
LABEL_18:
        v16 = *(v11 + 48);
        v15 = *(v11 + 56);
        if (v15 != v16)
        {
          while (*v16 != v6)
          {
            if (++v16 == v15)
            {
              v16 = v15;
              break;
            }
          }
        }

        if (((v16 == v15) & ~v8) == 0)
        {
          v17 = a1[3];
          v32[0] = v6;
          v18 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::doFind<mlir::Value>(v17, v32);
          v19 = !v18 || v18 == *v17 + 16 * *(v17 + 16);
          if (v19 || !*(v18 + 8))
          {
            v20 = v6[1];
            if ((~*(v6 + 2) & 7) != 0)
            {
              v21 = v6;
            }

            else
            {
              v21 = 0;
            }

            if (v21)
            {
              v22 = v21[1] & 7;
              if (v22 == 6)
              {
                v23 = &v21[3 * v21[2] + 15];
                if (!v23)
                {
                  goto LABEL_34;
                }
              }

              else
              {
                v23 = &v21[2 * v22 + 2];
              }

              v24 = (v23 + 24);
            }

            else
            {
LABEL_34:
              v24 = v6 + 4;
            }

            v25 = *v24;
            mlir::Block::addArgument(*a1[1]);
          }
        }

LABEL_38:
        v4 += 4;
      }

      while (v4 != v5);
    }
  }

  v30 = *MEMORY[0x277D85DE8];
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Transforms::segmentFunctionOpInterfaceForDelegate(mlir::FunctionOpInterface,llvm::function_ref<llvm::LogicalResult ()(mlir::Operation *)>,llvm::StringRef,mlir::IRRewriter &)::$_2 const>(void *a1, uint64_t a2)
{
  v3 = *a1;
  v4 = a1[1];
  (*(**a1 + 40))(*a1);
  if ((*(a2 + 46) & 0x80) != 0)
  {
    v5 = *(a2 + 68);
    if (v5)
    {
      v6 = *(a2 + 72);
      v7 = 32 * v5;
      do
      {
        v8 = v6[3];
        v14 = v8;
        v9 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::doFind<mlir::Value>(v4, &v14);
        if (v9 && v9 != *v4 + 16 * *(v4 + 16))
        {
          v8 = *(v9 + 8);
        }

        if (v6[3] != v8)
        {
          v10 = v6[1];
          if (v10)
          {
            v11 = *v6;
            *v10 = *v6;
            if (v11)
            {
              *(v11 + 8) = v6[1];
            }
          }

          v6[3] = v8;
          v12 = *v8;
          *v6 = *v8;
          v6[1] = v8;
          if (v12)
          {
            v12[1] = v6;
          }

          *v8 = v6;
        }

        v6 += 4;
        v7 -= 32;
      }

      while (v7);
    }
  }

  return (*(*v3 + 48))(v3, a2);
}

uint64_t mlir::ODIE::Compiler::CoreML::getKernelRegistry(mlir::ODIE::Compiler::CoreML *this)
{
  if ((atomic_load_explicit(&_MergedGlobals_69, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_69))
  {
    qword_27FC26E08 = 0;
    unk_27FC26E10 = 0;
    qword_27FC26E00 = &unk_286E74130;
    __cxa_atexit(ODIE::Common::MallocAllocator::~MallocAllocator, &qword_27FC26E00, &dword_25C85D000);
    __cxa_guard_release(&_MergedGlobals_69);
  }

  if ((atomic_load_explicit(&qword_27FC26DF8, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26DF8))
  {
    qword_27FC26DF0 = mlir::ODIE::Compiler::CoreML::getKernelRegistry(void)::$_0::operator()();
    __cxa_guard_release(&qword_27FC26DF8);
  }

  return qword_27FC26DF0;
}

_OWORD **mlir::ODIE::Compiler::CoreML::getKernelRegistry(void)::$_0::operator()()
{
  (*(qword_27FC26E00 + 40))(v2);
  ODIE::Registration::KernelRegistry::create(v2, &v3);
  if (v4 != 1)
  {
    return 0;
  }

  v0 = v3;
  ODIE::Kernels::Core::CPU::initialize(v3);
  return v0;
}

uint64_t mlir::ODIE::DebugInfo::FileAttr::get(uint64_t *a1, llvm::hashing::detail::hash_state *a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v20 = *MEMORY[0x277D85DE8];
  v7 = *a1;
  v11[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id;
  v11[1] = a1;
  v16[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail15FileAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_8FileAttrEJNS_9StringRefESE_SE_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_;
  v16[1] = v11;
  v13[0] = a2;
  v13[1] = a3;
  v14[0] = a4;
  v14[1] = a5;
  v15[0] = a6;
  v15[1] = a7;
  memset(v18, 0, sizeof(v18));
  v19 = 0xFF51AFD7ED558CCDLL;
  v17 = llvm::hashing::detail::hash_combine_range_impl<char const>(a2, a2 + a3, a3, a4);
  v8 = llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::StringRef,llvm::StringRef>(&v17, 0, v18, &v18[3] + 1, v14, v15);
  v12 = v13;
  v17 = v13;
  *&v18[0] = v16;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v7 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id, v8, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::FileAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::FileAttrStorage,llvm::StringRef,llvm::StringRef,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::FileAttrStorage *)>,mlir::TypeID,llvm::StringRef,llvm::StringRef,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v12, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::FileAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::FileAttrStorage,llvm::StringRef,llvm::StringRef,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::FileAttrStorage *)>,mlir::TypeID,llvm::StringRef,llvm::StringRef,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v17);
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::FileAttr::parse(mlir::AsmParser *a1)
{
  v53 = *MEMORY[0x277D85DE8];
  (*(*a1 + 32))(a1);
  (*(*a1 + 40))(a1);
  LOBYTE(v37[0]) = 0;
  v39 = 0;
  LOBYTE(v34[0]) = 0;
  v36 = 0;
  LOBYTE(v31[0]) = 0;
  v33 = 0;
  if ((*(*a1 + 152))(a1))
  {
    v29 = 0;
    v30 = 0;
    if (mlir::AsmParser::parseKeyword(a1, &v29))
    {
      v2 = 0;
      v3 = 0;
      v4 = 0;
      v5 = 3;
      do
      {
        v6 = v29;
        v7 = v30;
        if (((*(*a1 + 136))(a1) & 1) == 0)
        {
          goto LABEL_40;
        }

        if (v2 & 1 | (v7 != 8))
        {
          v8 = v7 != 9;
          if (!(v3 & 1 | v8))
          {
            if (*v6 == 0x726F746365726964 && *(v6 + 8) == 121)
            {
              mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
              v11 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v34, &__p);
              if (v47 == 1 && v46 < 0)
              {
                operator delete(__p.n128_u64[0]);
              }

              if ((v36 & 1) == 0)
              {
                v28 = (*(*a1 + 40))(a1, v11);
                v48 = 259;
                (*(*a1 + 24))(v50, a1, v28, &__p);
                p_p = v50;
                goto LABEL_39;
              }

              v3 = 1;
              goto LABEL_29;
            }

            v8 = 0;
          }

          if ((v4 | v8))
          {
            goto LABEL_72;
          }

          if (*v6 != 0x7553363532616873 || *(v6 + 8) != 109)
          {
            goto LABEL_72;
          }

          mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
          v11 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v31, &__p);
          if (v47 == 1 && v46 < 0)
          {
            operator delete(__p.n128_u64[0]);
          }

          if ((v33 & 1) == 0)
          {
            v27 = (*(*a1 + 40))(a1, v11);
            v48 = 259;
            (*(*a1 + 24))(v49, a1, v27, &__p);
            p_p = v49;
            goto LABEL_39;
          }

          v4 = 1;
        }

        else
        {
          if (*v6 != 0x656D616E656C6966)
          {
            v7 = 8;
LABEL_72:
            v25 = (*(*a1 + 40))(a1);
            v40 = "duplicate or unknown struct parameter name: ";
            v41 = 259;
            (*(*a1 + 24))(&__p, a1, v25, &v40);
            if (__p.n128_u64[0])
            {
              v43 = 261;
              v42[0] = v6;
              v42[1] = v7;
              mlir::Diagnostic::operator<<(&__p.n128_i64[1], v42);
            }

            p_p = &__p;
            goto LABEL_39;
          }

          mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
          v11 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v37, &__p);
          if (v47 == 1 && v46 < 0)
          {
            operator delete(__p.n128_u64[0]);
          }

          if ((v39 & 1) == 0)
          {
            v26 = (*(*a1 + 40))(a1, v11);
            v48 = 259;
            (*(*a1 + 24))(v51, a1, v26, &__p);
            p_p = v51;
            goto LABEL_39;
          }

          v2 = 1;
        }

LABEL_29:
        if (!--v5)
        {
          if (((*(*a1 + 168))(a1, v11) & 1) == 0)
          {
            goto LABEL_40;
          }

          v17 = (*(*a1 + 32))(a1);
          if (v38 >= 0)
          {
            v18 = v37;
          }

          else
          {
            v18 = v37[0];
          }

          if (v38 >= 0)
          {
            v19 = v38;
          }

          else
          {
            v19 = v37[1];
          }

          if (v35 >= 0)
          {
            v20 = v34;
          }

          else
          {
            v20 = v34[0];
          }

          if (v35 >= 0)
          {
            v21 = v35;
          }

          else
          {
            v21 = v34[1];
          }

          if (v32 >= 0)
          {
            v22 = v31;
          }

          else
          {
            v22 = v31[0];
          }

          v23 = *v17;
          if (v32 >= 0)
          {
            v24 = v32;
          }

          else
          {
            v24 = v31[1];
          }

          v14 = mlir::ODIE::DebugInfo::FileAttr::get(v23, v18, v19, v20, v21, v22, v24);
          goto LABEL_41;
        }

        if (((*(*a1 + 120))(a1, v11) & 1) == 0)
        {
          goto LABEL_40;
        }

        v29 = 0;
        v30 = 0;
      }

      while (mlir::AsmParser::parseKeyword(a1, &v29));
    }

    v12 = (*(*a1 + 40))(a1);
    v51[0] = "expected a parameter name in struct";
    v52 = 259;
    (*(*a1 + 24))(v44, a1, v12, v51);
    p_p = v44;
LABEL_39:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(p_p);
  }

LABEL_40:
  v14 = 0;
LABEL_41:
  if (v33 == 1 && v32 < 0)
  {
    operator delete(v31[0]);
  }

  if (v36 == 1 && v35 < 0)
  {
    operator delete(v34[0]);
  }

  if (v39 == 1 && v38 < 0)
  {
    operator delete(v37[0]);
  }

  v15 = *MEMORY[0x277D85DE8];
  return v14;
}

llvm::raw_ostream *mlir::ODIE::DebugInfo::FileAttr::print(mlir::ODIE::DebugInfo::FileAttr *this, mlir::AsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }

  else
  {
    *v5 = 60;
    ++*(v4 + 4);
  }

  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if ((*(v6 + 3) - v7) > 0xA)
  {
    *(v7 + 7) = 540876901;
    *v7 = *"filename = ";
    *(v6 + 4) += 11;
  }

  else
  {
    llvm::raw_ostream::write(v6, "filename = ", 0xBuLL);
  }

  (*(*a2 + 80))(a2, *(*this + 8), *(*this + 16));
  v8 = (*(*a2 + 16))(a2);
  v9 = *(v8 + 4);
  if (*(v8 + 3) - v9 > 1uLL)
  {
    *v9 = 8236;
    *(v8 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v8, ", ", 2uLL);
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if ((*(v10 + 3) - v11) > 0xB)
  {
    *(v11 + 8) = 540876921;
    *v11 = *"directory = ";
    *(v10 + 4) += 12;
  }

  else
  {
    llvm::raw_ostream::write(v10, "directory = ", 0xCuLL);
  }

  (*(*a2 + 80))(a2, *(*this + 24), *(*this + 32));
  v12 = (*(*a2 + 16))(a2);
  v13 = *(v12 + 4);
  if (*(v12 + 3) - v13 > 1uLL)
  {
    *v13 = 8236;
    *(v12 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v12, ", ", 2uLL);
  }

  v14 = (*(*a2 + 16))(a2);
  v15 = *(v14 + 4);
  if ((*(v14 + 3) - v15) > 0xB)
  {
    *(v15 + 8) = 540876909;
    *v15 = *"sha256Sum = ";
    *(v14 + 4) += 12;
  }

  else
  {
    llvm::raw_ostream::write(v14, "sha256Sum = ", 0xCuLL);
  }

  (*(*a2 + 80))(a2, *(*this + 40), *(*this + 48));
  result = (*(*a2 + 16))(a2);
  v17 = *(result + 4);
  if (*(result + 3) == v17)
  {

    return llvm::raw_ostream::write(result, ">", 1uLL);
  }

  else
  {
    *v17 = 62;
    ++*(result + 4);
  }

  return result;
}

uint64_t mlir::AsmPrinter::printStrippedAttrOrType<mlir::ODIE::DebugInfo::FileAttr,(void *)0>(mlir::AsmPrinter *a1, uint64_t a2)
{
  v8 = a2;
  result = (*(*a1 + 56))(a1);
  if ((result & 1) == 0)
  {
    v5 = (*(*a1 + 16))(a1);
    v6 = (*(*v5 + 80))(v5) + v5[4] - v5[2];
    mlir::ODIE::DebugInfo::FileAttr::print(&v8, a1);
    result = (*(*v5 + 80))(v5);
    if (v6 == result + v5[4] - v5[2])
    {
      v7 = *(*a1 + 40);

      return v7(a1, a2);
    }
  }

  return result;
}

uint64_t mlir::ODIE::DebugInfo::MetadataAttr::get(uint64_t *a1, llvm::hashing::detail::hash_state *a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  v5 = a4;
  v20 = *MEMORY[0x277D85DE8];
  v6 = *a1;
  v10[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id;
  v10[1] = a1;
  v13[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19MetadataAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12MetadataAttrEJNS_9StringRefENS3_21MetadataAttrInterfaceEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_;
  v13[1] = v10;
  v12[0] = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  v18 = 0;
  v19 = 0xFF51AFD7ED558CCDLL;
  v14 = llvm::hashing::detail::hash_combine_range_impl<char const>(a2, a2 + a3, a3, a4);
  v15 = ((v5 >> 4) ^ (v5 >> 9));
  v7 = llvm::hashing::detail::hash_combine_recursive_helper::combine(&v14, 0, v16, v17);
  v11 = v12;
  v14 = v12;
  v15 = v13;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v6 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id, v7, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::MetadataAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v11, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::MetadataAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v14);
  v9 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::SubprogramAttr::parse(mlir::AsmParser *a1, uint64_t a2)
{
  v79 = *MEMORY[0x277D85DE8];
  (*(*a1 + 32))(a1);
  (*(*a1 + 40))(a1);
  LOBYTE(v52[0]) = 0;
  v54 = 0;
  LOBYTE(v49[0]) = 0;
  v51 = 0;
  if ((*(*a1 + 152))(a1))
  {
    v45 = a2;
    v47 = 0;
    v48 = 0;
    if (mlir::AsmParser::parseKeyword(a1, &v47))
    {
      v4 = 0;
      v5 = 0;
      v44 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v46 = 0;
      v10 = 5;
      do
      {
        v12 = v47;
        v11 = v48;
        if (((*(*a1 + 136))(a1) & 1) == 0)
        {
          goto LABEL_45;
        }

        if (v9 & 1 | (v11 != 11))
        {
          v13 = v11 != 4;
          if (!(v5 & 1 | v13))
          {
            if (*v12 == 1701603686)
            {
              __p.n128_u64[0] = *(*(*a1 + 32))(a1);
              mlir::MLIRContext::getOrLoadDialect(__p.n128_u64[0], "debuginfo", 9uLL, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DebugInfoDialect,void>::id, llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::ODIE::DebugInfo::DebugInfoDialect * mlir::MLIRContext::getOrLoadDialect<mlir::ODIE::DebugInfo::DebugInfoDialect>(void)::{lambda(void)#1}>, &__p);
              v19 = mlir::FieldParser<mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::FileAttr>::parse(a1);
              if ((v20 & 1) == 0)
              {
                v42 = (*(*a1 + 40))(a1);
                v63 = 259;
                (*(*a1 + 24))(&v67, a1, v42, &__p);
                p_p = &v67;
                goto LABEL_44;
              }

              v44 = v19;
              v5 = 1;
              goto LABEL_40;
            }

            v13 = 0;
          }

          if (((v6 | v13) & 1) == 0)
          {
            if (*v12 == 1701667182)
            {
              mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
              v21 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v52, &__p);
              if (v62 == 1 && v61 < 0)
              {
                operator delete(__p.n128_u64[0]);
              }

              if ((v54 & 1) == 0)
              {
                v43 = (*(*a1 + 40))(a1, v21);
                v63 = 259;
                (*(*a1 + 24))(v66, a1, v43, &__p);
                p_p = v66;
                goto LABEL_44;
              }

              v6 = 1;
              goto LABEL_40;
            }

            v13 = 0;
          }
        }

        else
        {
          if (*v12 == 0x55656C69706D6F63 && *(v12 + 3) == 0x74696E55656C6970)
          {
            v16 = mlir::FieldParser<mlir::SymbolRefAttr,mlir::SymbolRefAttr>::parse(a1);
            if ((v17 & 1) == 0)
            {
              v40 = (*(*a1 + 40))(a1);
              v63 = 259;
              (*(*a1 + 24))(__dst, a1, v40, &__p);
              p_p = __dst;
              goto LABEL_44;
            }

            v4 = v16;
            v9 = 1;
            goto LABEL_40;
          }

          v13 = 1;
        }

        if (!(v7 & 1 | (v11 != 11)) && (*v12 == 0x4E6567616B6E696CLL ? (v15 = *(v12 + 3) == 0x656D614E6567616BLL) : (v15 = 0), v15))
        {
          mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
          v18 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v49, &__p);
          if (v62 == 1 && v61 < 0)
          {
            operator delete(__p.n128_u64[0]);
          }

          if ((v51 & 1) == 0)
          {
            v41 = (*(*a1 + 40))(a1, v18);
            v63 = 259;
            (*(*a1 + 24))(v65, a1, v41, &__p);
            p_p = v65;
            goto LABEL_44;
          }

          v7 = 1;
        }

        else
        {
          if (((v8 | v13) & 1) != 0 || *v12 != 1701734764)
          {
            v27 = (*(*a1 + 40))(a1);
            v55 = "duplicate or unknown struct parameter name: ";
            v56 = 259;
            (*(*a1 + 24))(&__p, a1, v27, &v55);
            if (__p.n128_u64[0])
            {
              v58 = 261;
              v57[0] = v12;
              v57[1] = v11;
              mlir::Diagnostic::operator<<(&__p.n128_i64[1], v57);
            }

            p_p = &__p;
            goto LABEL_44;
          }

          __p.n128_u32[0] = 0;
          if ((mlir::AsmParser::parseInteger<unsigned int>(a1, &__p) & 1) == 0)
          {
            v39 = (*(*a1 + 40))(a1);
            v63 = 259;
            (*(*a1 + 24))(v64, a1, v39, &__p);
            p_p = v64;
            goto LABEL_44;
          }

          v46 = __p.n128_u32[0];
          v8 = 1;
        }

LABEL_40:
        if (!--v10)
        {
          if (((*(*a1 + 168))(a1) & 1) == 0)
          {
            goto LABEL_45;
          }

          v28 = *(*(*a1 + 32))(a1);
          v29 = **(*(*a1 + 32))(a1);
          v30 = *(v29 + 528);
          if (!v30)
          {
            v31 = *(v29 + 384);
            *&__dst[0] = &mlir::detail::TypeIDResolver<mlir::NoneType,void>::id;
            v30 = *llvm::DenseMapBase<llvm::DenseMap<mlir::TypeID,mlir::StorageUniquer::BaseStorage *,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,mlir::StorageUniquer::BaseStorage *>>,mlir::TypeID,mlir::StorageUniquer::BaseStorage *,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,mlir::StorageUniquer::BaseStorage *>>::operator[]((v31 + 232), __dst);
          }

          v32 = v53;
          if (v45)
          {
            v33 = v45;
          }

          else
          {
            v33 = v30;
          }

          v34 = v52;
          if (v53 < 0)
          {
            v34 = v52[0];
          }

          if (v53 < 0)
          {
            v32 = v52[1];
          }

          v35 = v50;
          v36 = v49;
          if (v50 < 0)
          {
            v36 = v49[0];
          }

          v37 = *v28;
          if (v50 < 0)
          {
            v35 = v49[1];
          }

          v65[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id;
          v65[1] = v28;
          v66[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21SubprogramAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_14SubprogramAttrEJRNS1_4TypeERNS1_13SymbolRefAttrERNS3_8FileAttrERNS_9StringRefESL_RjEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESP_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSR_E_EEvlS6_;
          v66[1] = v65;
          v67 = v33;
          v68 = v4;
          v69 = v44;
          v70[0] = v34;
          v70[1] = v32;
          v71[0] = v36;
          v71[1] = v35;
          v72[0] = v46;
          memset(v76, 0, sizeof(v76));
          v75 = 0u;
          v74 = 0u;
          memset(__dst, 0, sizeof(__dst));
          v77 = 0;
          v78 = 0xFF51AFD7ED558CCDLL;
          v38 = llvm::hashing::detail::hash_combine_recursive_helper::combine<mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(__dst, __dst, v76, v33, &v68, &v69, v70, v71, v72);
          v64[0] = &v67;
          *&__dst[0] = &v67;
          *(&__dst[0] + 1) = v66;
          v24 = mlir::detail::StorageUniquerImpl::getOrCreate(*(v37 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id, v38, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, v64, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, __dst);
          goto LABEL_46;
        }

        if (((*(*a1 + 120))(a1) & 1) == 0)
        {
          goto LABEL_45;
        }

        v47 = 0;
        v48 = 0;
      }

      while (mlir::AsmParser::parseKeyword(a1, &v47));
    }

    v22 = (*(*a1 + 40))(a1);
    *&__dst[0] = "expected a parameter name in struct";
    LOWORD(v74) = 259;
    (*(*a1 + 24))(v59, a1, v22, __dst);
    p_p = v59;
LABEL_44:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(p_p);
  }

LABEL_45:
  v24 = 0;
LABEL_46:
  if (v51 == 1 && v50 < 0)
  {
    operator delete(v49[0]);
  }

  if (v54 == 1 && v53 < 0)
  {
    operator delete(v52[0]);
  }

  v25 = *MEMORY[0x277D85DE8];
  return v24;
}

llvm::raw_ostream *mlir::ODIE::DebugInfo::SubprogramAttr::print(mlir::ODIE::DebugInfo::SubprogramAttr *this, mlir::AsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }

  else
  {
    *v5 = 60;
    ++*(v4 + 4);
  }

  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if (*(v6 + 3) - v7 > 0xDuLL)
  {
    qmemcpy(v7, "compileUnit = ", 14);
    *(v6 + 4) += 14;
  }

  else
  {
    llvm::raw_ostream::write(v6, "compileUnit = ", 0xEuLL);
  }

  (*(*a2 + 40))(a2, *(*this + 16));
  v8 = (*(*a2 + 16))(a2);
  v9 = *(v8 + 4);
  if (*(v8 + 3) - v9 > 1uLL)
  {
    *v9 = 8236;
    *(v8 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v8, ", ", 2uLL);
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if (*(v10 + 3) - v11 > 6uLL)
  {
    *(v11 + 3) = 540876901;
    *v11 = 1701603686;
    *(v10 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v10, "file = ", 7uLL);
  }

  mlir::AsmPrinter::printStrippedAttrOrType<mlir::ODIE::DebugInfo::FileAttr,(void *)0>(a2, *(*this + 24));
  v12 = (*(*a2 + 16))(a2);
  v13 = *(v12 + 4);
  if (*(v12 + 3) - v13 > 1uLL)
  {
    *v13 = 8236;
    *(v12 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v12, ", ", 2uLL);
  }

  v14 = (*(*a2 + 16))(a2);
  v15 = *(v14 + 4);
  if (*(v14 + 3) - v15 > 6uLL)
  {
    *(v15 + 3) = 540876901;
    *v15 = 1701667182;
    *(v14 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v14, "name = ", 7uLL);
  }

  (*(*a2 + 80))(a2, *(*this + 32), *(*this + 40));
  v16 = (*(*a2 + 16))(a2);
  v17 = *(v16 + 4);
  if (*(v16 + 3) - v17 > 1uLL)
  {
    *v17 = 8236;
    *(v16 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v16, ", ", 2uLL);
  }

  v18 = (*(*a2 + 16))(a2);
  v19 = *(v18 + 4);
  if (*(v18 + 3) - v19 > 0xDuLL)
  {
    qmemcpy(v19, "linkageName = ", 14);
    *(v18 + 4) += 14;
  }

  else
  {
    llvm::raw_ostream::write(v18, "linkageName = ", 0xEuLL);
  }

  (*(*a2 + 80))(a2, *(*this + 48), *(*this + 56));
  v20 = (*(*a2 + 16))(a2);
  v21 = *(v20 + 4);
  if (*(v20 + 3) - v21 > 1uLL)
  {
    *v21 = 8236;
    *(v20 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v20, ", ", 2uLL);
  }

  v22 = (*(*a2 + 16))(a2);
  v23 = *(v22 + 4);
  if (*(v22 + 3) - v23 > 6uLL)
  {
    *(v23 + 3) = 540876901;
    *v23 = 1701734764;
    *(v22 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v22, "line = ", 7uLL);
  }

  v24 = *(*this + 64);
  v25 = (*(*a2 + 16))(a2);
  write_unsigned<unsigned long long>(v25, v24, 0, 0, 0);
  result = (*(*a2 + 16))(a2);
  v27 = *(result + 4);
  if (*(result + 3) == v27)
  {

    return llvm::raw_ostream::write(result, ">", 1uLL);
  }

  else
  {
    *v27 = 62;
    ++*(result + 4);
  }

  return result;
}

uint64_t mlir::ODIE::DebugInfo::LocalVariableAttr::get(uint64_t *a1, uint64_t a2, llvm::hashing::detail::hash_state *a3, unint64_t *a4, int a5, uint64_t a6, int a7)
{
  v8 = a6;
  v32 = *MEMORY[0x277D85DE8];
  v10 = *a1;
  v17[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id;
  v17[1] = a1;
  v22[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail24LocalVariableAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_17LocalVariableAttrEJNS1_4TypeENS_9StringRefEjNS1_13SymbolRefAttrEjEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS6_;
  v22[1] = v17;
  v18[0] = a2;
  v18[1] = a3;
  v18[2] = a4;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  v30 = 0;
  v31 = 0xFF51AFD7ED558CCDLL;
  v26 = ((a2 >> 4) ^ (a2 >> 9));
  v27 = llvm::hashing::detail::hash_combine_range_impl<char const>(a3, a4 + a3, a3, a4);
  v23 = 0;
  v11 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(&v26, &v23, v28, v29, a5);
  v24 = v23;
  v12 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(&v26, &v24, v11, v29, (v8 >> 4) ^ (v8 >> 9));
  v25 = v24;
  v13 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(&v26, &v25, v12, v29, a7);
  v14 = llvm::hashing::detail::hash_combine_recursive_helper::combine(&v26, v25, v13, v29);
  v25 = v18;
  v26 = v18;
  v27 = v22;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v10 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id, v14, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage *)>,mlir::TypeID,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v25, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage *)>,mlir::TypeID,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v26);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::LocalVariableAttr::parse(mlir::AsmParser *a1, uint64_t a2)
{
  v54 = *MEMORY[0x277D85DE8];
  (*(*a1 + 32))(a1);
  (*(*a1 + 40))(a1);
  LOBYTE(v37[0]) = 0;
  v39 = 0;
  if (((*(*a1 + 152))(a1) & 1) == 0)
  {
LABEL_37:
    v19 = 0;
    goto LABEL_38;
  }

  v35 = 0;
  v36 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, &v35))
  {
LABEL_35:
    v17 = (*(*a1 + 40))(a1);
    v52[0] = "expected a parameter name in struct";
    v53 = 259;
    (*(*a1 + 24))(v44, a1, v17, v52);
    p_p = v44;
LABEL_36:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(p_p);
    goto LABEL_37;
  }

  v34 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 4;
  while (1)
  {
    v11 = v35;
    v10 = v36;
    if (((*(*a1 + 136))(a1) & 1) == 0)
    {
      goto LABEL_37;
    }

    if (!(v8 & 1 | (v10 != 4)) && *v11 == 1701667182)
    {
      mlir::FieldParser<std::string,std::string>::parse(a1, &__p);
      v16 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v37, &__p);
      if (v47 == 1 && v46 < 0)
      {
        operator delete(__p.n128_u64[0]);
      }

      if ((v39 & 1) == 0)
      {
        v33 = (*(*a1 + 40))(a1, v16);
        v48 = 259;
        (*(*a1 + 24))(v52, a1, v33, &__p);
        p_p = v52;
        goto LABEL_36;
      }

      v8 = 1;
    }

    else if (v5 & 1 | (v10 != 4))
    {
      if (v4 & 1 | (v10 != 5))
      {
        if (v7 & 1 | (v10 != 11))
        {
          goto LABEL_57;
        }

        if (*v11 != 0x426E496E67696C61 || *(v11 + 3) != 0x737469426E496E67)
        {
          v10 = 11;
LABEL_57:
          v30 = (*(*a1 + 40))(a1);
          v40 = "duplicate or unknown struct parameter name: ";
          v41 = 259;
          (*(*a1 + 24))(&__p, a1, v30, &v40);
          if (__p.n128_u64[0])
          {
            v43 = 261;
            v42[0] = v11;
            v42[1] = v10;
            mlir::Diagnostic::operator<<(&__p.n128_i64[1], v42);
          }

          p_p = &__p;
          goto LABEL_36;
        }

        __p.n128_u32[0] = 0;
        if ((mlir::AsmParser::parseInteger<unsigned int>(a1, &__p) & 1) == 0)
        {
          v32 = (*(*a1 + 40))(a1);
          v48 = 259;
          (*(*a1 + 24))(v49, a1, v32, &__p);
          p_p = v49;
          goto LABEL_36;
        }

        LODWORD(v34) = __p.n128_u32[0];
        v7 = 1;
      }

      else
      {
        if (*v11 != 1886348147 || *(v11 + 4) != 101)
        {
          v10 = 5;
          goto LABEL_57;
        }

        v14 = mlir::FieldParser<mlir::SymbolRefAttr,mlir::SymbolRefAttr>::parse(a1);
        if ((v15 & 1) == 0)
        {
          v31 = (*(*a1 + 40))(a1);
          v48 = 259;
          (*(*a1 + 24))(v50, a1, v31, &__p);
          p_p = v50;
          goto LABEL_36;
        }

        v6 = v14;
        v4 = 1;
      }
    }

    else
    {
      if (*v11 != 1701734764)
      {
        v10 = 4;
        goto LABEL_57;
      }

      __p.n128_u32[0] = 0;
      if ((mlir::AsmParser::parseInteger<unsigned int>(a1, &__p) & 1) == 0)
      {
        v29 = (*(*a1 + 40))(a1);
        v48 = 259;
        (*(*a1 + 24))(v51, a1, v29, &__p);
        p_p = v51;
        goto LABEL_36;
      }

      HIDWORD(v34) = __p.n128_u32[0];
      v5 = 1;
    }

    if (!--v9)
    {
      break;
    }

    if (((*(*a1 + 120))(a1) & 1) == 0)
    {
      goto LABEL_37;
    }

    v35 = 0;
    v36 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, &v35))
    {
      goto LABEL_35;
    }
  }

  if (((*(*a1 + 168))(a1) & 1) == 0)
  {
    goto LABEL_37;
  }

  v22 = *(*(*a1 + 32))(a1);
  v23 = **(*(*a1 + 32))(a1);
  v24 = *(v23 + 528);
  if (!v24)
  {
    v25 = *(v23 + 384);
    v52[0] = &mlir::detail::TypeIDResolver<mlir::NoneType,void>::id;
    v24 = *llvm::DenseMapBase<llvm::DenseMap<mlir::TypeID,mlir::StorageUniquer::BaseStorage *,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,mlir::StorageUniquer::BaseStorage *>>,mlir::TypeID,mlir::StorageUniquer::BaseStorage *,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,mlir::StorageUniquer::BaseStorage *>>::operator[]((v25 + 232), v52);
  }

  if (a2)
  {
    v26 = a2;
  }

  else
  {
    v26 = v24;
  }

  if (v38 >= 0)
  {
    v27 = v37;
  }

  else
  {
    v27 = v37[0];
  }

  if (v38 >= 0)
  {
    v28 = v38;
  }

  else
  {
    v28 = v37[1];
  }

  v19 = mlir::ODIE::DebugInfo::LocalVariableAttr::get(v22, v26, v27, v28, SHIDWORD(v34), v6, v34);
LABEL_38:
  if (v39 == 1 && v38 < 0)
  {
    operator delete(v37[0]);
  }

  v20 = *MEMORY[0x277D85DE8];
  return v19;
}

llvm::raw_ostream *mlir::ODIE::DebugInfo::LocalVariableAttr::print(mlir::ODIE::DebugInfo::LocalVariableAttr *this, mlir::AsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }

  else
  {
    *v5 = 60;
    ++*(v4 + 4);
  }

  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if (*(v6 + 3) - v7 > 6uLL)
  {
    *(v7 + 3) = 540876901;
    *v7 = 1701667182;
    *(v6 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v6, "name = ", 7uLL);
  }

  (*(*a2 + 80))(a2, *(*this + 16), *(*this + 24));
  v8 = (*(*a2 + 16))(a2);
  v9 = *(v8 + 4);
  if (*(v8 + 3) - v9 > 1uLL)
  {
    *v9 = 8236;
    *(v8 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v8, ", ", 2uLL);
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if (*(v10 + 3) - v11 > 6uLL)
  {
    *(v11 + 3) = 540876901;
    *v11 = 1701734764;
    *(v10 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v10, "line = ", 7uLL);
  }

  v12 = *(*this + 32);
  v13 = (*(*a2 + 16))(a2);
  write_unsigned<unsigned long long>(v13, v12, 0, 0, 0);
  v14 = (*(*a2 + 16))(a2);
  v15 = *(v14 + 4);
  if (*(v14 + 3) - v15 > 1uLL)
  {
    *v15 = 8236;
    *(v14 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v14, ", ", 2uLL);
  }

  v16 = (*(*a2 + 16))(a2);
  v17 = *(v16 + 4);
  if (*(v16 + 3) - v17 > 7uLL)
  {
    *v17 = 0x203D2065706F6373;
    *(v16 + 4) += 8;
  }

  else
  {
    llvm::raw_ostream::write(v16, "scope = ", 8uLL);
  }

  (*(*a2 + 40))(a2, *(*this + 40));
  v18 = (*(*a2 + 16))(a2);
  v19 = *(v18 + 4);
  if (*(v18 + 3) - v19 > 1uLL)
  {
    *v19 = 8236;
    *(v18 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v18, ", ", 2uLL);
  }

  v20 = (*(*a2 + 16))(a2);
  v21 = *(v20 + 4);
  if (*(v20 + 3) - v21 > 0xDuLL)
  {
    qmemcpy(v21, "alignInBits = ", 14);
    *(v20 + 4) += 14;
  }

  else
  {
    llvm::raw_ostream::write(v20, "alignInBits = ", 0xEuLL);
  }

  v22 = *(*this + 48);
  v23 = (*(*a2 + 16))(a2);
  write_unsigned<unsigned long long>(v23, v22, 0, 0, 0);
  result = (*(*a2 + 16))(a2);
  v25 = *(result + 4);
  if (*(result + 3) == v25)
  {

    return llvm::raw_ostream::write(result, ">", 1uLL);
  }

  else
  {
    *v25 = 62;
    ++*(result + 4);
  }

  return result;
}

uint64_t mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocationAttr,mlir::LocationAttr,mlir::ODIE::DebugInfo::detail::LocationAttrStorage,mlir::detail::AttributeUniquer,mlir::AttributeTrait::IsLocation>::getChecked<unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(void (*a1)(_OWORD *__return_ptr, uint64_t), uint64_t a2, uint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v33 = *MEMORY[0x277D85DE8];
  if (a6)
  {
    if (!a7)
    {
      goto LABEL_9;
    }
  }

  else if (a7)
  {
LABEL_9:
    v18 = *a3;
    v21[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id;
    v21[1] = a3;
    v29[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19LocationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12LocationAttrEJRjSE_RNS1_13SymbolRefAttrERNS3_8FileAttrERSD_RNS_8ArrayRefINS1_9AttributeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESQ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSS_E_EEvlS6_;
    v29[1] = v21;
    v23 = a4;
    v24 = a5;
    v25 = a6;
    v26 = a7;
    v27 = a8;
    v28[0] = a9;
    v28[1] = a10;
    memset(v31, 0, 56);
    memset(__dst, 0, sizeof(__dst));
    v31[7] = 0xFF51AFD7ED558CCDLL;
    v19 = llvm::hashing::detail::hash_combine_recursive_helper::combine<unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(__dst, __dst, v31, a4, &v24, &v25, &v26, &v27, v28);
    v22 = &v23;
    *&__dst[0] = &v23;
    *(&__dst[0] + 1) = v29;
    result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v18 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id, v19, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v22, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, __dst);
    goto LABEL_10;
  }

  a1(__dst, a2);
  if (*&__dst[0])
  {
    mlir::Diagnostic::operator<<<57ul>(__dst + 8, "expected either a scope or a file to anchor the location");
  }

  v16 = v32;
  mlir::InFlightDiagnostic::~InFlightDiagnostic(__dst);
  if ((v16 & 1) == 0)
  {
    goto LABEL_9;
  }

  result = 0;
LABEL_10:
  v20 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::LocationAttr::parse(uint64_t a1)
{
  v44 = *MEMORY[0x277D85DE8];
  (*(*a1 + 32))(a1);
  v2 = (*(*a1 + 40))(a1);
  LOBYTE(v35[0]) = 0;
  v37 = 0;
  if (((*(*a1 + 152))(a1) & 1) == 0)
  {
    goto LABEL_21;
  }

  (*(*a1 + 40))(a1);
  v3 = (*(*a1 + 40))(a1);
  v27[0] = 0;
  if (((*(*a1 + 440))(a1, v27, 0) & 1) == 0)
  {
    goto LABEL_21;
  }

  v4 = v27[0];
  v5 = *(*v27[0] + 136);
  v6 = v5 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id ? v27[0] : 0;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
  {
    v4 = 0;
  }

  else if (v5 != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id)
  {
    v29[0] = "unknown location anchor";
    v30[8] = 259;
    (*(*a1 + 24))(&v38, a1, v3, v29);
    v7 = v43;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v38);
    v6 = 0;
    v4 = 0;
    v8 = 0;
    if (v7)
    {
      goto LABEL_22;
    }
  }

  v41 = 257;
  if (((*(*a1 + 400))(a1, "at", 2, &v38) & 1) == 0)
  {
    goto LABEL_21;
  }

  LODWORD(v38) = 0;
  v9 = mlir::AsmParser::parseInteger<unsigned int>(a1, &v38);
  v10 = *a1;
  if ((v9 & 1) == 0)
  {
    v18 = (*(v10 + 40))(a1);
    v41 = 259;
    (*(*a1 + 24))(v34, a1, v18, &v38);
    v19 = v34;
    goto LABEL_20;
  }

  v11 = v38;
  if (((*(v10 + 104))(a1) & 1) == 0)
  {
    goto LABEL_21;
  }

  LODWORD(v38) = 0;
  v12 = mlir::AsmParser::parseInteger<unsigned int>(a1, &v38);
  v13 = *a1;
  if ((v12 & 1) == 0)
  {
    v22 = (*(v13 + 40))(a1);
    v41 = 259;
    (*(*a1 + 24))(v33, a1, v22, &v38);
    v19 = v33;
    goto LABEL_20;
  }

  v14 = v38;
  if ((*(v13 + 408))(a1, "inlined", 7))
  {
    v41 = 257;
    if (((*(*a1 + 400))(a1, "at", 2, &v38) & 1) == 0)
    {
      goto LABEL_21;
    }

    v15 = mlir::FieldParser<mlir::ODIE::DebugInfo::LocationAttr,mlir::ODIE::DebugInfo::LocationAttr>::parse(a1);
    if (v16)
    {
      v17 = v15;
      goto LABEL_28;
    }

    v25 = (*(*a1 + 40))(a1);
    v41 = 259;
    (*(*a1 + 24))(v32, a1, v25, &v38);
    v19 = v32;
LABEL_20:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v19);
    goto LABEL_21;
  }

  v17 = 0;
LABEL_28:
  if (((*(*a1 + 408))(a1, "with", 4) & 1) == 0)
  {
    goto LABEL_35;
  }

  if (((*(*a1 + 312))(a1) & 1) == 0)
  {
LABEL_21:
    v8 = 0;
    goto LABEL_22;
  }

  mlir::FieldParser<llvm::SmallVector<mlir::Attribute,6u>,llvm::SmallVector<mlir::Attribute,6u>>::parse(&v38, a1);
  std::__optional_storage_base<llvm::SmallVector<mlir::Attribute,6u>,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<llvm::SmallVector<mlir::Attribute,6u>,false>>(v35, &v38);
  if (v42 == 1 && v38 != v40)
  {
    free(v38);
  }

  v23 = *a1;
  if ((v37 & 1) == 0)
  {
    v26 = (*(v23 + 40))(a1);
    v41 = 259;
    (*(*a1 + 24))(v31, a1, v26, &v38);
    v19 = v31;
    goto LABEL_20;
  }

  if (((*(v23 + 328))(a1) & 1) == 0)
  {
    goto LABEL_21;
  }

LABEL_35:
  if (((*(*a1 + 168))(a1) & 1) == 0)
  {
    goto LABEL_21;
  }

  v24 = *(*(*a1 + 32))(a1);
  v29[0] = v30;
  v29[1] = 0x600000000;
  std::optional<llvm::SmallVector<mlir::Attribute,6u>>::value_or[abi:nn200100]<llvm::SmallVector<mlir::Attribute,6u>>(&v38, v35, v29);
  v27[0] = a1;
  v27[1] = &v28;
  v28 = v2;
  v8 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocationAttr,mlir::LocationAttr,mlir::ODIE::DebugInfo::detail::LocationAttrStorage,mlir::detail::AttributeUniquer,mlir::AttributeTrait::IsLocation>::getChecked<unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(_ZN4llvm12function_refIFN4mlir18InFlightDiagnosticEvEE11callback_fnIZNS1_9AsmParser10getCheckedINS1_4ODIE9DebugInfo12LocationAttrEJPNS1_11MLIRContextEjjNS1_13SymbolRefAttrENS9_8FileAttrESA_NS_8ArrayRefINS1_9AttributeEEEEEEDaNS_5SMLocEDpOT0_EUlvE_EES2_l, v27, v24, v11, v14, v6, v4, v17, v38, v39);
  if (v38 != v40)
  {
    free(v38);
  }

  if (v29[0] != v30)
  {
    free(v29[0]);
  }

LABEL_22:
  if (v37 == 1 && v35[0] != &v36)
  {
    free(v35[0]);
  }

  v20 = *MEMORY[0x277D85DE8];
  return v8;
}

uint64_t mlir::FieldParser<mlir::ODIE::DebugInfo::LocationAttr,mlir::ODIE::DebugInfo::LocationAttr>::parse(uint64_t a1)
{
  v14 = *MEMORY[0x277D85DE8];
  v2 = (*(*a1 + 32))(a1);
  mlir::MLIRContext::getOrLoadDialect(*v2, "debuginfo", 9uLL, v3);
  v4 = (*(*a1 + 40))(a1);
  v11 = 0;
  v12[0] = a1;
  if ((*(*a1 + 448))(a1, &v11, 0, _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo12LocationAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_, v12))
  {
    v5 = v11;
    v6 = 1;
    if (*(*v11 + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id)
    {
      v9 = "invalid kind of attribute specified";
      v10 = 259;
      (*(*a1 + 24))(v12, a1, v4, &v9);
      v6 = (v13 & 1) == 0;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v12);
      v5 = 0;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  if (v6)
  {
    result = v5;
  }

  else
  {
    result = 0;
  }

  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::FieldParser<llvm::SmallVector<mlir::Attribute,6u>,llvm::SmallVector<mlir::Attribute,6u>>::parse(uint64_t a1, uint64_t a2)
{
  v8[6] = *MEMORY[0x277D85DE8];
  v5[1] = &v6;
  v6 = v8;
  v7 = 0x600000000;
  v5[0] = a2;
  if ((*(*a2 + 392))(a2, 0, llvm::function_ref<llvm::ParseResult ()(void)>::callback_fn<mlir::FieldParser<llvm::SmallVector<mlir::Attribute,6u>,llvm::SmallVector<mlir::Attribute,6u>>::parse(mlir::AsmParser &)::{lambda(void)#1}>, v5, 0, 0))
  {
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
    if (v7)
    {
      llvm::SmallVectorImpl<mlir::Attribute>::operator=(a1, &v6);
    }

    v3 = 1;
  }

  else
  {
    v3 = 0;
    *a1 = 0;
  }

  *(a1 + 64) = v3;
  if (v6 != v8)
  {
    free(v6);
  }

  v4 = *MEMORY[0x277D85DE8];
}

void std::optional<llvm::SmallVector<mlir::Attribute,6u>>::value_or[abi:nn200100]<llvm::SmallVector<mlir::Attribute,6u>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a2 + 64);
  *a1 = a1 + 16;
  *(a1 + 8) = 0x600000000;
  if (v5 == 1)
  {
    if (a1 != a2)
    {
      v6 = *(a2 + 8);
      if (v6)
      {
        v7 = *(a2 + 8);
        if (v6 < 7 || (llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), *(a2 + 8), 8), (v7 = *(a2 + 8)) != 0))
        {
          memcpy(*a1, *a2, 8 * v7);
        }

        *(a1 + 8) = v6;
      }
    }
  }

  else if (*(a3 + 8))
  {

    llvm::SmallVectorImpl<mlir::Attribute>::operator=(a1, a3);
  }
}

llvm::raw_ostream *mlir::ODIE::DebugInfo::LocationAttr::print(mlir::ODIE::DebugInfo::LocationAttr *this, mlir::AsmPrinter *a2)
{
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }

  else
  {
    *v5 = 60;
    ++*(v4 + 4);
  }

  v6 = *(*this + 24);
  v7 = *a2 + 40;
  if (*(*this + 16))
  {
    v8 = *(*this + 16);
  }

  else
  {
    v8 = *(*this + 24);
  }

  (*(*a2 + 40))(a2, v8);
  v9 = (*(*a2 + 16))(a2);
  v10 = *(v9 + 4);
  if (v10 >= *(v9 + 3))
  {
    llvm::raw_ostream::write(v9, 32);
  }

  else
  {
    *(v9 + 4) = v10 + 1;
    *v10 = 32;
  }

  v11 = (*(*a2 + 16))(a2);
  v12 = *(v11 + 4);
  if (*(v11 + 3) - v12 > 1uLL)
  {
    *v12 = 29793;
    *(v11 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v11, "at", 2uLL);
  }

  v13 = (*(*a2 + 16))(a2);
  v14 = *(v13 + 4);
  if (v14 >= *(v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }

  else
  {
    *(v13 + 4) = v14 + 1;
    *v14 = 32;
  }

  v15 = *(*this + 8);
  v16 = (*(*a2 + 16))(a2);
  write_unsigned<unsigned long long>(v16, v15, 0, 0, 0);
  v17 = (*(*a2 + 16))(a2);
  v18 = *(v17 + 4);
  if (*(v17 + 3) == v18)
  {
    llvm::raw_ostream::write(v17, ":", 1uLL);
  }

  else
  {
    *v18 = 58;
    ++*(v17 + 4);
  }

  v19 = *(*this + 12);
  v20 = (*(*a2 + 16))(a2);
  write_unsigned<unsigned long long>(v20, v19, 0, 0, 0);
  v21 = *this;
  if (*(*this + 32))
  {
    v22 = (*(*a2 + 16))(a2);
    v23 = *(v22 + 4);
    if (v23 >= *(v22 + 3))
    {
      llvm::raw_ostream::write(v22, 32);
    }

    else
    {
      *(v22 + 4) = v23 + 1;
      *v23 = 32;
    }

    v24 = (*(*a2 + 16))(a2);
    v25 = *(v24 + 4);
    if (*(v24 + 3) - v25 > 6uLL)
    {
      *(v25 + 3) = 1684369001;
      *v25 = 1768713833;
      *(v24 + 4) += 7;
    }

    else
    {
      llvm::raw_ostream::write(v24, "inlined", 7uLL);
    }

    v26 = (*(*a2 + 16))(a2);
    v27 = *(v26 + 4);
    if (v27 >= *(v26 + 3))
    {
      llvm::raw_ostream::write(v26, 32);
    }

    else
    {
      *(v26 + 4) = v27 + 1;
      *v27 = 32;
    }

    v28 = (*(*a2 + 16))(a2);
    v29 = *(v28 + 4);
    if (*(v28 + 3) - v29 > 1uLL)
    {
      *v29 = 29793;
      *(v28 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v28, "at", 2uLL);
    }

    v21 = *this;
    if (*(*this + 32))
    {
      v30 = (*(*a2 + 16))(a2);
      v31 = *(v30 + 4);
      if (v31 >= *(v30 + 3))
      {
        llvm::raw_ostream::write(v30, 32);
      }

      else
      {
        *(v30 + 4) = v31 + 1;
        *v31 = 32;
      }

      v32 = *(*this + 32);
      v55 = v32;
      if (((*(*a2 + 56))(a2, v32) & 1) == 0)
      {
        v33 = (*(*a2 + 16))(a2);
        v34 = (*(*v33 + 80))(v33) + v33[4] - v33[2];
        mlir::ODIE::DebugInfo::LocationAttr::print(&v55, a2);
        if (v34 == (*(*v33 + 80))(v33) + v33[4] - v33[2])
        {
          (*(*a2 + 40))(a2, v32);
        }
      }

      v21 = *this;
    }
  }

  if (*(v21 + 48))
  {
    v35 = (*(*a2 + 16))(a2);
    v36 = *(v35 + 4);
    if (v36 >= *(v35 + 3))
    {
      llvm::raw_ostream::write(v35, 32);
    }

    else
    {
      *(v35 + 4) = v36 + 1;
      *v36 = 32;
    }

    v37 = (*(*a2 + 16))(a2);
    v38 = *(v37 + 4);
    if (*(v37 + 3) - v38 > 3uLL)
    {
      *v38 = 1752459639;
      *(v37 + 4) += 4;
    }

    else
    {
      llvm::raw_ostream::write(v37, "with", 4uLL);
    }

    v39 = (*(*a2 + 16))(a2);
    v40 = *(v39 + 4);
    if (*(v39 + 3) == v40)
    {
      llvm::raw_ostream::write(v39, " ", 1uLL);
    }

    else
    {
      *v40 = 32;
      ++*(v39 + 4);
    }

    v41 = (*(*a2 + 16))(a2);
    v42 = *(v41 + 4);
    if (*(v41 + 3) == v42)
    {
      llvm::raw_ostream::write(v41, "[", 1uLL);
    }

    else
    {
      *v42 = 91;
      ++*(v41 + 4);
    }

    v43 = *this;
    v44 = *(*this + 48);
    if (v44)
    {
      v45 = *(v43 + 40);
      (*(*a2 + 40))(a2, *v45);
      if (v44 != 1)
      {
        v46 = v45 + 1;
        v47 = 8 * v44 - 8;
        do
        {
          v48 = (*(*a2 + 16))(a2);
          v49 = *(v48 + 4);
          if (*(v48 + 3) - v49 > 1uLL)
          {
            *v49 = 8236;
            *(v48 + 4) += 2;
          }

          else
          {
            llvm::raw_ostream::write(v48, ", ", 2uLL);
          }

          v50 = *v46++;
          (*(*a2 + 40))(a2, v50);
          v47 -= 8;
        }

        while (v47);
      }
    }

    v51 = (*(*a2 + 16))(a2);
    v52 = *(v51 + 4);
    if (*(v51 + 3) == v52)
    {
      llvm::raw_ostream::write(v51, "]", 1uLL);
    }

    else
    {
      *v52 = 93;
      ++*(v51 + 4);
    }
  }

  result = (*(*a2 + 16))(a2);
  v54 = *(result + 4);
  if (*(result + 3) == v54)
  {

    return llvm::raw_ostream::write(result, ">", 1uLL);
  }

  else
  {
    *v54 = 62;
    ++*(result + 4);
  }

  return result;
}

uint64_t mlir::ODIE::DebugInfo::DebugInfoDialect::parseAttribute(uint64_t a1, mlir::AsmParser *a2, uint64_t a3)
{
  v116 = *MEMORY[0x277D85DE8];
  v6 = (*(*a2 + 40))(a2);
  mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::KeywordSwitch(v70, a2, 0);
  v110.n128_u64[0] = "file";
  v110.n128_u64[1] = 4;
  if (v73[2])
  {
    goto LABEL_2;
  }

  v8 = v72;
  if (v72 == 4)
  {
    if (*v71 == 1701603686)
    {
      v12 = mlir::ODIE::DebugInfo::FileAttr::parse(a2);
      goto LABEL_117;
    }

    goto LABEL_14;
  }

  if (v72)
  {
LABEL_14:
    v74 = "compile_unit";
    v75 = 12;
    goto LABEL_15;
  }

  (*(*v70[0] + 648))(v70[0], &v110, 1);
  v74 = "compile_unit";
  v75 = 12;
  if (v73[2])
  {
    goto LABEL_2;
  }

  v8 = v72;
  if (v72)
  {
LABEL_15:
    if (v8 != 12 || (*v71 == 0x5F656C69706D6F63 ? (v9 = *(v71 + 8) == 1953066613) : (v9 = 0), !v9))
    {
      v96 = "metadata";
      v97 = 8;
      if (!v8)
      {
        goto LABEL_9;
      }

      goto LABEL_21;
    }

    (*(*a2 + 32))(a2);
    (*(*a2 + 40))(a2);
    LOBYTE(v84[0]) = 0;
    v86 = 0;
    LOBYTE(v81[0]) = 0;
    v83 = 0;
    LOBYTE(v78[0]) = 0;
    v80 = 0;
    if ((*(*a2 + 152))(a2))
    {
      v76 = 0;
      v77 = 0;
      if (mlir::AsmParser::parseKeyword(a2, &v76))
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v69 = 0;
        v68 = 0;
        v17 = 5;
        while (1)
        {
          v19 = v76;
          v18 = v77;
          if (((*(*a2 + 136))(a2) & 1) == 0)
          {
            goto LABEL_92;
          }

          if (v14 & 1 | (v18 != 14))
          {
            if (v13 & 1 | (v18 != 4))
            {
              if (v16 & 1 | (v18 != 8))
              {
                if (BYTE4(v69) & 1 | (v18 != 9))
                {
                  if (v69 & 1 | (v18 != 5))
                  {
                    goto LABEL_177;
                  }

                  if (*v19 != 1734437990 || *(v19 + 4) != 115)
                  {
                    v18 = 5;
LABEL_177:
                    v65 = (*(*a2 + 40))(a2);
                    v87 = "duplicate or unknown struct parameter name: ";
                    v88 = 259;
                    (*(*a2 + 24))(&__p, a2, v65, &v87);
                    if (__p.n128_u64[0])
                    {
                      v90 = 261;
                      v89[0] = v19;
                      v89[1] = v18;
                      mlir::Diagnostic::operator<<(&__p.n128_i64[1], v89);
                    }

                    p_p = &__p;
                    goto LABEL_91;
                  }

                  mlir::FieldParser<std::string,std::string>::parse(a2, &__p);
                  v21 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v78, &__p);
                  if (v93 == 1 && v92 < 0)
                  {
                    operator delete(__p.n128_u64[0]);
                  }

                  if ((v80 & 1) == 0)
                  {
                    v67 = (*(*a2 + 40))(a2, v21);
                    v94 = 259;
                    (*(*a2 + 24))(v95, a2, v67, &__p);
                    p_p = v95;
                    goto LABEL_91;
                  }

                  LOBYTE(v69) = 1;
                }

                else
                {
                  if (*v19 != 0x657A696D6974706FLL || *(v19 + 8) != 100)
                  {
                    v18 = 9;
                    goto LABEL_177;
                  }

                  __p.n128_u8[0] = 0;
                  if ((mlir::AsmParser::parseInteger<BOOL>(a2, &__p) & 1) == 0)
                  {
                    v66 = (*(*a2 + 40))(a2);
                    v94 = 259;
                    (*(*a2 + 24))(&v96, a2, v66, &__p);
                    p_p = &v96;
                    goto LABEL_91;
                  }

                  v68 = __p.n128_u8[0];
                  BYTE4(v69) = 1;
                }
              }

              else
              {
                if (*v19 != 0x72656375646F7270)
                {
                  v18 = 8;
                  goto LABEL_177;
                }

                mlir::FieldParser<std::string,std::string>::parse(a2, &__p);
                v21 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v81, &__p);
                if (v93 == 1 && v92 < 0)
                {
                  operator delete(__p.n128_u64[0]);
                }

                if ((v83 & 1) == 0)
                {
                  v64 = (*(*a2 + 40))(a2, v21);
                  v94 = 259;
                  (*(*a2 + 24))(&v98, a2, v64, &__p);
                  p_p = &v98;
                  goto LABEL_91;
                }

                v16 = 1;
              }
            }

            else
            {
              if (*v19 != 1701603686)
              {
                v18 = 4;
                goto LABEL_177;
              }

              __p.n128_u64[0] = *(*(*a2 + 32))(a2);
              mlir::MLIRContext::getOrLoadDialect(__p.n128_u64[0], "debuginfo", 9uLL, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DebugInfoDialect,void>::id, llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::ODIE::DebugInfo::DebugInfoDialect * mlir::MLIRContext::getOrLoadDialect<mlir::ODIE::DebugInfo::DebugInfoDialect>(void)::{lambda(void)#1}>, &__p);
              v23 = mlir::FieldParser<mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::FileAttr>::parse(a2);
              if ((v24 & 1) == 0)
              {
                v59 = (*(*a2 + 40))(a2);
                v94 = 259;
                (*(*a2 + 24))(&v103, a2, v59, &__p);
                p_p = &v103;
                goto LABEL_91;
              }

              v15 = v23;
              v13 = 1;
            }
          }

          else
          {
            if (*v19 != 0x614C656372756F73 || *(v19 + 6) != 0x65676175676E614CLL)
            {
              v18 = 14;
              goto LABEL_177;
            }

            mlir::FieldParser<std::string,std::string>::parse(a2, &__p);
            v21 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(v84, &__p);
            if (v93 == 1 && v92 < 0)
            {
              operator delete(__p.n128_u64[0]);
            }

            if ((v86 & 1) == 0)
            {
              v51 = (*(*a2 + 40))(a2, v21);
              v94 = 259;
              (*(*a2 + 24))(&v110, a2, v51, &__p);
              goto LABEL_90;
            }

            v14 = 1;
          }

          if (!--v17)
          {
            break;
          }

          if (((*(*a2 + 120))(a2, v21) & 1) == 0)
          {
            goto LABEL_92;
          }

          v76 = 0;
          v77 = 0;
          if (!mlir::AsmParser::parseKeyword(a2, &v76))
          {
            goto LABEL_89;
          }
        }

        if (((*(*a2 + 168))(a2, v21) & 1) == 0)
        {
          goto LABEL_92;
        }

        v42 = *(*(*a2 + 32))(a2);
        if (v85 >= 0)
        {
          v43 = v84;
        }

        else
        {
          v43 = v84[0];
        }

        if (v85 >= 0)
        {
          v44 = v85;
        }

        else
        {
          v44 = v84[1];
        }

        v45 = v82;
        v46 = v81;
        if (v82 < 0)
        {
          v46 = v81[0];
        }

        if (v82 < 0)
        {
          v45 = v81[1];
        }

        v47 = v79;
        v48 = v78;
        if (v79 < 0)
        {
          v48 = v78[0];
        }

        if (v79 < 0)
        {
          v47 = v78[1];
        }

        v49 = *v42;
        v96 = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id;
        v97 = v42;
        v98 = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail22CompileUnitAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_15CompileUnitAttrEJRNS_9StringRefERNS3_8FileAttrESF_RbSF_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_;
        v99 = &v96;
        v103 = v43;
        v104 = v44;
        v105 = v15;
        v106 = v46;
        v107 = v45;
        v108[0] = v68 & 1;
        v109[0] = v48;
        v109[1] = v47;
        v113 = 0u;
        memset(v114, 0, 56);
        v111 = 0u;
        v112 = 0u;
        v110 = 0u;
        v114[7] = 0xFF51AFD7ED558CCDLL;
        v50 = llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(&v110, &v110, v114, v43, v44, &v105, &v106, v108, v109);
        v95[0] = &v103;
        v110.n128_u64[0] = &v103;
        v110.n128_u64[1] = &v98;
        v7 = mlir::detail::StorageUniquerImpl::getOrCreate(*(v49 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id, v50, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, v95, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v110);
        goto LABEL_93;
      }

LABEL_89:
      v26 = (*(*a2 + 40))(a2);
      v103 = "expected a parameter name in struct";
      LOWORD(v107) = 259;
      (*(*a2 + 24))(&v110, a2, v26, &v103);
LABEL_90:
      p_p = &v110;
LABEL_91:
      mlir::InFlightDiagnostic::~InFlightDiagnostic(p_p);
    }

LABEL_92:
    v7 = 0;
LABEL_93:
    if (v80 == 1 && v79 < 0)
    {
      operator delete(v78[0]);
    }

    if (v83 == 1 && v82 < 0)
    {
      operator delete(v81[0]);
    }

    if (v86 != 1 || (v85 & 0x80000000) == 0)
    {
      goto LABEL_149;
    }

    v28 = v84[0];
    goto LABEL_148;
  }

  (*(*v70[0] + 648))(v70[0], &v74, 1);
  v96 = "metadata";
  v97 = 8;
  if (v73[2])
  {
    goto LABEL_2;
  }

  v8 = v72;
  if (!v72)
  {
LABEL_9:
    (*(*v70[0] + 648))(v70[0], &v96, 1);
    v110.n128_u64[0] = "subprogram";
    v110.n128_u64[1] = 10;
    if (v73[2])
    {
      goto LABEL_2;
    }

    v8 = v72;
    if (!v72)
    {
      goto LABEL_11;
    }

    goto LABEL_24;
  }

LABEL_21:
  if (v8 == 8 && *v71 == 0x617461646174656DLL)
  {
    (*(*a2 + 32))(a2);
    (*(*a2 + 40))(a2);
    LOBYTE(v98) = 0;
    v101 = 0;
    if (((*(*a2 + 152))(a2) & 1) == 0)
    {
      goto LABEL_144;
    }

    mlir::FieldParser<std::string,std::string>::parse(a2, &v110);
    v30 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(&v98, &v110);
    if (BYTE8(v111) == 1 && SBYTE7(v111) < 0)
    {
      operator delete(v110.n128_u64[0]);
    }

    v31 = *a2;
    if (v101)
    {
      if (((*(v31 + 104))(a2, v30) & 1) == 0)
      {
        goto LABEL_144;
      }

      v32 = (*(*a2 + 40))(a2);
      v95[0] = 0;
      if ((*(*a2 + 440))(a2, v95, 0))
      {
        v33 = v95[0];
        v34 = *v95[0];
        v35 = mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttrInterface,void>::resolveTypeID();
        if (mlir::detail::InterfaceMap::lookup(v34 + 8, v35))
        {
          v36 = *v33;
          v37 = mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttrInterface,void>::resolveTypeID();
          v38 = mlir::detail::InterfaceMap::lookup(v36 + 8, v37);
        }

        else
        {
          v33 = 0;
          v38 = 0;
        }

        if (v33)
        {
          v52 = v33;
          goto LABEL_167;
        }

        v103 = "invalid kind of attribute specified";
        LOWORD(v107) = 259;
        (*(*a2 + 24))(&v110, a2, v32, &v103);
        v53 = v115;
        mlir::InFlightDiagnostic::~InFlightDiagnostic(&v110);
        if (v53 != 1)
        {
          v52 = 0;
LABEL_167:
          if ((*(*a2 + 168))(a2))
          {
            v60 = v33 & 0xFFFFFFFFFFFFFF00;
            v61 = *(*(*a2 + 32))(a2);
            if (v100 >= 0)
            {
              v62 = &v98;
            }

            else
            {
              v62 = v98;
            }

            if (v100 >= 0)
            {
              v63 = v100;
            }

            else
            {
              v63 = v99;
            }

            v7 = mlir::ODIE::DebugInfo::MetadataAttr::get(v61, v62, v63, (v52 | v60), v38);
            goto LABEL_145;
          }

LABEL_144:
          v7 = 0;
LABEL_145:
          if (v101 != 1 || (v100 & 0x80000000) == 0)
          {
            goto LABEL_149;
          }

          v28 = v98;
LABEL_148:
          operator delete(v28);
LABEL_149:
          v39 = v7 == 0;
          goto LABEL_150;
        }
      }

      v40 = (*(*a2 + 40))(a2);
    }

    else
    {
      v40 = (*(v31 + 40))(a2, v30);
    }

    v103 = v41;
    LOWORD(v107) = 259;
    (*(*a2 + 24))(&v110, a2, v40, &v103);
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v110);
    goto LABEL_144;
  }

  v110.n128_u64[0] = "subprogram";
  v110.n128_u64[1] = 10;
  if (!v8)
  {
LABEL_11:
    (*(*v70[0] + 648))(v70[0], &v110, 1);
    v110.n128_u64[0] = "local_variable";
    v110.n128_u64[1] = 14;
    if (v73[2])
    {
      goto LABEL_2;
    }

    v8 = v72;
    goto LABEL_30;
  }

LABEL_24:
  if (v8 == 10 && *v71 == 0x72676F7270627573 && *(v71 + 8) == 28001)
  {
    v12 = mlir::ODIE::DebugInfo::SubprogramAttr::parse(a2, a3);
    goto LABEL_117;
  }

  v110.n128_u64[0] = "local_variable";
  v110.n128_u64[1] = 14;
LABEL_30:
  if (v8)
  {
    if (v8 == 14 && *v71 == 0x61765F6C61636F6CLL && *(v71 + 6) == 0x656C626169726176)
    {
      v12 = mlir::ODIE::DebugInfo::LocalVariableAttr::parse(a2, a3);
      goto LABEL_117;
    }

    v110.n128_u64[0] = "location";
    v110.n128_u64[1] = 8;
    goto LABEL_37;
  }

  (*(*v70[0] + 648))(v70[0], &v110, 1);
  v110.n128_u64[0] = "location";
  v110.n128_u64[1] = 8;
  if ((v73[2] & 1) == 0)
  {
    v8 = v72;
    if (!v72)
    {
      (*(*v70[0] + 648))(v70[0], &v110, 1);
      if (v73[2])
      {
        v8 = 0;
        v29 = 0;
        v7 = 0;
        goto LABEL_155;
      }

      v8 = v72;
      goto LABEL_119;
    }

LABEL_37:
    if (v8 == 8 && *v71 == 0x6E6F697461636F6CLL)
    {
      v12 = mlir::ODIE::DebugInfo::LocationAttr::parse(a2);
LABEL_117:
      v7 = v12;
      v39 = v12 == 0;
LABEL_150:
      v54 = !v39;
      v73[0] = v54;
      *&v73[1] = 257;
      goto LABEL_154;
    }

LABEL_119:
    v7 = 0;
    v29 = v71;
    *v73 = 0;
    v73[2] = 1;
    goto LABEL_155;
  }

LABEL_2:
  v7 = 0;
LABEL_154:
  v8 = 0;
  v29 = 0;
LABEL_155:
  if ((mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(v70) & 0x100) == 0)
  {
    v102 = 257;
    (*(*a2 + 24))(&v110, a2, v6, &v98);
    if (v110.n128_u64[0])
    {
      if (v110.n128_u64[0])
      {
        LOWORD(v107) = 261;
        v103 = v29;
        v104 = v8;
        mlir::Diagnostic::operator<<(&v110.n128_i64[1], &v103);
        if (v110.n128_u64[0])
        {
          if (v110.n128_u64[0])
          {
            v55 = *(a1 + 8);
            v56 = *(a1 + 16);
            LOWORD(v107) = 261;
            v103 = v55;
            v104 = v56;
            mlir::Diagnostic::operator<<(&v110.n128_i64[1], &v103);
            if (v110.n128_u64[0])
            {
            }
          }
        }
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v110);
    v7 = 0;
  }

  v57 = *MEMORY[0x277D85DE8];
  return v7;
}

void mlir::ODIE::DebugInfo::DebugInfoDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  v5 = *(*a2 + 136);
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id)
  {
    v50 = a2;
    v8 = (*(*a3 + 16))(a3);
    v9 = *(v8 + 4);
    if (*(v8 + 3) - v9 > 3uLL)
    {
      *v9 = 1701603686;
      *(v8 + 4) += 4;
    }

    else
    {
      llvm::raw_ostream::write(v8, "file", 4uLL);
    }

    mlir::ODIE::DebugInfo::FileAttr::print(&v50, a3);
    return;
  }

  if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id)
  {
    v10 = (*(*a3 + 16))(a3);
    v11 = *(v10 + 4);
    if ((*(v10 + 3) - v11) > 0xB)
    {
      *(v11 + 8) = 1953066613;
      *v11 = *"compile_unit";
      *(v10 + 4) += 12;
    }

    else
    {
      llvm::raw_ostream::write(v10, "compile_unit", 0xCuLL);
    }

    v14 = (*(*a3 + 16))(a3);
    v15 = *(v14 + 4);
    if (*(v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, "<", 1uLL);
    }

    else
    {
      *v15 = 60;
      ++*(v14 + 4);
    }

    v18 = (*(*a3 + 16))(a3);
    v19 = *(v18 + 4);
    if ((*(v18 + 3) - v19) > 0x10)
    {
      *(v19 + 16) = 32;
      *v19 = *"sourceLanguage = ";
      *(v18 + 4) += 17;
    }

    else
    {
      llvm::raw_ostream::write(v18, "sourceLanguage = ", 0x11uLL);
    }

    (*(*a3 + 80))(a3, *(a2 + 8), *(a2 + 16));
    v20 = (*(*a3 + 16))(a3);
    v21 = *(v20 + 4);
    if (*(v20 + 3) - v21 > 1uLL)
    {
      *v21 = 8236;
      *(v20 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v20, ", ", 2uLL);
    }

    v22 = (*(*a3 + 16))(a3);
    v23 = *(v22 + 4);
    if (*(v22 + 3) - v23 > 6uLL)
    {
      *(v23 + 3) = 540876901;
      *v23 = 1701603686;
      *(v22 + 4) += 7;
    }

    else
    {
      llvm::raw_ostream::write(v22, "file = ", 7uLL);
    }

    mlir::AsmPrinter::printStrippedAttrOrType<mlir::ODIE::DebugInfo::FileAttr,(void *)0>(a3, *(a2 + 24));
    v24 = (*(*a3 + 16))(a3);
    v25 = *(v24 + 4);
    if (*(v24 + 3) - v25 > 1uLL)
    {
      *v25 = 8236;
      *(v24 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v24, ", ", 2uLL);
    }

    v26 = (*(*a3 + 16))(a3);
    v27 = *(v26 + 4);
    if ((*(v26 + 3) - v27) > 0xA)
    {
      *(v27 + 7) = 540876914;
      *v27 = *"producer = ";
      *(v26 + 4) += 11;
    }

    else
    {
      llvm::raw_ostream::write(v26, "producer = ", 0xBuLL);
    }

    (*(*a3 + 80))(a3, *(a2 + 32), *(a2 + 40));
    v28 = (*(*a3 + 16))(a3);
    v29 = *(v28 + 4);
    if (*(v28 + 3) - v29 > 1uLL)
    {
      *v29 = 8236;
      *(v28 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v28, ", ", 2uLL);
    }

    v30 = (*(*a3 + 16))(a3);
    v31 = *(v30 + 4);
    if ((*(v30 + 3) - v31) > 0xB)
    {
      *(v31 + 8) = 540876900;
      *v31 = *"optimized = ";
      *(v30 + 4) += 12;
    }

    else
    {
      llvm::raw_ostream::write(v30, "optimized = ", 0xCuLL);
    }

    v32 = *(a2 + 48);
    v33 = (*(*a3 + 16))(a3);
    if (v32)
    {
      v34 = 4;
    }

    else
    {
      v34 = 5;
    }

    if (v32)
    {
      v35 = "true";
    }

    else
    {
      v35 = "false";
    }

    llvm::raw_ostream::operator<<(v33, v35, v34);
    v36 = (*(*a3 + 16))(a3);
    v37 = *(v36 + 4);
    if (*(v36 + 3) - v37 > 1uLL)
    {
      *v37 = 8236;
      *(v36 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v36, ", ", 2uLL);
    }

    v38 = (*(*a3 + 16))(a3);
    v39 = *(v38 + 4);
    if (*(v38 + 3) - v39 > 7uLL)
    {
      *v39 = 0x203D207367616C66;
      *(v38 + 4) += 8;
    }

    else
    {
      llvm::raw_ostream::write(v38, "flags = ", 8uLL);
    }

    (*(*a3 + 80))(a3, *(a2 + 56), *(a2 + 64));
  }

  else
  {
    if (v5 != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id)
    {
      if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
      {
        v50 = a2;
        v16 = (*(*a3 + 16))(a3);
        v17 = *(v16 + 4);
        if ((*(v16 + 3) - v17) > 9)
        {
          *(v17 + 8) = 28001;
          *v17 = *"subprogram";
          *(v16 + 4) += 10;
        }

        else
        {
          llvm::raw_ostream::write(v16, "subprogram", 0xAuLL);
        }

        mlir::ODIE::DebugInfo::SubprogramAttr::print(&v50, a3);
      }

      else if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
      {
        v50 = a2;
        v42 = (*(*a3 + 16))(a3);
        v43 = *(v42 + 4);
        if (*(v42 + 3) - v43 > 0xDuLL)
        {
          qmemcpy(v43, "local_variable", 14);
          *(v42 + 4) += 14;
        }

        else
        {
          llvm::raw_ostream::write(v42, "local_variable", 0xEuLL);
        }

        mlir::ODIE::DebugInfo::LocalVariableAttr::print(&v50, a3);
      }

      else if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id)
      {
        v50 = a2;
        v6 = (*(*a3 + 16))(a3);
        v7 = *(v6 + 4);
        if (*(v6 + 3) - v7 > 7uLL)
        {
          *v7 = 0x6E6F697461636F6CLL;
          *(v6 + 4) += 8;
        }

        else
        {
          llvm::raw_ostream::write(v6, "location", 8uLL);
        }

        mlir::ODIE::DebugInfo::LocationAttr::print(&v50, a3);
      }

      return;
    }

    v12 = (*(*a3 + 16))(a3);
    v13 = *(v12 + 4);
    if (*(v12 + 3) - v13 > 7uLL)
    {
      *v13 = 0x617461646174656DLL;
      *(v12 + 4) += 8;
    }

    else
    {
      llvm::raw_ostream::write(v12, "metadata", 8uLL);
    }

    v40 = (*(*a3 + 16))(a3);
    v41 = *(v40 + 4);
    if (*(v40 + 3) == v41)
    {
      llvm::raw_ostream::write(v40, "<", 1uLL);
    }

    else
    {
      *v41 = 60;
      ++*(v40 + 4);
    }

    (*(*a3 + 80))(a3, *(a2 + 8), *(a2 + 16));
    v44 = (*(*a3 + 16))(a3);
    v45 = *(v44 + 4);
    if (*(v44 + 3) == v45)
    {
      llvm::raw_ostream::write(v44, ":", 1uLL);
    }

    else
    {
      *v45 = 58;
      ++*(v44 + 4);
    }

    v46 = (*(*a3 + 16))(a3);
    v47 = *(v46 + 4);
    if (v47 >= *(v46 + 3))
    {
      llvm::raw_ostream::write(v46, 32);
    }

    else
    {
      *(v46 + 4) = v47 + 1;
      *v47 = 32;
    }

    (*(*a3 + 40))(a3, *(a2 + 24));
  }

  v48 = (*(*a3 + 16))(a3);
  v49 = *(v48 + 4);
  if (*(v48 + 3) == v49)
  {

    llvm::raw_ostream::write(v48, ">", 1uLL);
  }

  else
  {
    *v49 = 62;
    ++*(v48 + 4);
  }
}

uint64_t mlir::FieldParser<mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::FileAttr>::parse(uint64_t a1)
{
  v14 = *MEMORY[0x277D85DE8];
  v2 = (*(*a1 + 32))(a1);
  mlir::MLIRContext::getOrLoadDialect(*v2, "debuginfo", 9uLL, v3);
  v4 = (*(*a1 + 40))(a1);
  v11 = 0;
  v12[0] = a1;
  if ((*(*a1 + 448))(a1, &v11, 0, _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo8FileAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_, v12))
  {
    v5 = v11;
    v6 = 1;
    if (*(*v11 + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id)
    {
      v9 = "invalid kind of attribute specified";
      v10 = 259;
      (*(*a1 + 24))(v12, a1, v4, &v9);
      v6 = (v13 & 1) == 0;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v12);
      v5 = 0;
    }
  }

  else
  {
    v5 = 0;
    v6 = 0;
  }

  if (v6)
  {
    result = v5;
  }

  else
  {
    result = 0;
  }

  v8 = *MEMORY[0x277D85DE8];
  return result;
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo8FileAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_(mlir::AsmParser **a1, uint64_t *a2)
{
  v3 = mlir::ODIE::DebugInfo::FileAttr::parse(*a1);
  *a2 = v3;
  return v3 != 0;
}

uint64_t mlir::FieldParser<mlir::SymbolRefAttr,mlir::SymbolRefAttr>::parse(uint64_t a1)
{
  v2 = (*(*a1 + 32))(a1);
  mlir::MLIRContext::getOrLoadDialect(*v2, "builtin", 7uLL, v3);
  v7 = 0;
  v4 = mlir::AsmParser::parseAttribute<mlir::SymbolRefAttr>(a1, &v7, 0);
  v5 = v7;
  if (!v4)
  {
    return 0;
  }

  return v5;
}

void std::__optional_storage_base<llvm::SmallVector<mlir::Attribute,6u>,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<llvm::SmallVector<mlir::Attribute,6u>,false>>(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 64) == *(a2 + 64))
  {
    if (*(a1 + 64))
    {

      llvm::SmallVectorImpl<mlir::Attribute>::operator=(a1, a2);
    }
  }

  else if (*(a1 + 64))
  {
    v3 = *a1;
    if (*a1 != a1 + 16)
    {
      free(v3);
    }

    *(a1 + 64) = 0;
  }

  else
  {
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
    if (*(a2 + 8))
    {
      llvm::SmallVectorImpl<mlir::Attribute>::operator=(a1, a2);
    }

    *(a1 + 64) = 1;
  }
}

uint64_t llvm::SmallVectorImpl<mlir::Attribute>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v5 = (a2 + 16);
    v4 = *a2;
    if (v4 != v5)
    {
      v6 = *a1;
      if (*a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }

      *a1 = v4;
      v7 = (a2 + 8);
      *(a1 + 8) = *(a2 + 8);
      *a2 = v5;
      *(a2 + 12) = 0;
      goto LABEL_17;
    }

    v7 = (a2 + 8);
    v8 = *(a2 + 8);
    v9 = *(a1 + 8);
    if (v9 >= v8)
    {
      if (v8)
      {
        memmove(*a1, v4, 8 * v8);
      }

      goto LABEL_16;
    }

    if (*(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*a1, v4, 8 * v9);
        goto LABEL_14;
      }
    }

    else
    {
      *(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v8, 8);
    }

    v9 = 0;
LABEL_14:
    v10 = *v7 - v9;
    if (v10)
    {
      memcpy((*a1 + 8 * v9), (*a2 + 8 * v9), 8 * v10);
    }

LABEL_16:
    *(a1 + 8) = v8;
LABEL_17:
    *v7 = 0;
  }

  return a1;
}

uint64_t _ZN4llvm12function_refIFN4mlir18InFlightDiagnosticEvEE11callback_fnIZNS1_9AsmParser10getCheckedINS1_4ODIE9DebugInfo12LocationAttrEJPNS1_11MLIRContextEjjNS1_13SymbolRefAttrENS9_8FileAttrESA_NS_8ArrayRefINS1_9AttributeEEEEEEDaNS_5SMLocEDpOT0_EUlvE_EES2_l(uint64_t *a1)
{
  v1 = *a1;
  v2 = *a1[1];
  v5 = 257;
  return (*(*v1 + 24))(v1, v2, v4);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::FileAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::FileAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::CompileUnitAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::CompileUnitAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::MetadataAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::MetadataAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::SubprogramAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::SubprogramAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::LocalVariableAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::LocalVariableAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id);
}

void mlir::Dialect::addAttribute<mlir::ODIE::DebugInfo::LocationAttr>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::LocationAttr>(a1, &v2);
  mlir::Dialect::addAttribute(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id);
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::FileAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::FileAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::FileAttrStorage,mlir::detail::AttributeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo8FileAttrES2_NSE_6detail15FileAttrStorageENSB_16AttributeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v4, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo8FileAttrES2_NSD_6detail15FileAttrStorageENSA_16AttributeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::FileAttr,void>::id, "debuginfo.file", 14);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::CompileUnitAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::CompileUnitAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,mlir::detail::AttributeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo15CompileUnitAttrES2_NSE_6detail22CompileUnitAttrStorageENSB_16AttributeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v4, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo15CompileUnitAttrES2_NSD_6detail22CompileUnitAttrStorageENSA_16AttributeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id, "debuginfo.compile_unit", 22);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo15CompileUnitAttrES2_NSE_6detail22CompileUnitAttrStorageENSB_16AttributeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  if (*(a2 + 24))
  {
    return a3(a4);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo15CompileUnitAttrES2_NSD_6detail22CompileUnitAttrStorageENSA_16AttributeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v23[9] = *MEMORY[0x277D85DE8];
  v3 = *(a2 + 8);
  v4 = *(a2 + 16);
  v5 = *(a2 + 24);
  v6 = *(a2 + 32);
  v7 = *(a2 + 48);
  v8 = *(a2 + 56);
  if (v5)
  {
    v5 = *a3;
  }

  v9 = *(**a2 + 32);
  v10 = *v9;
  v14[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id;
  v14[1] = v9;
  v21[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail22CompileUnitAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_15CompileUnitAttrEJNS_9StringRefENS3_8FileAttrESE_bSE_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_;
  v21[1] = v14;
  v16[0] = v3;
  v16[1] = v4;
  v17 = v5;
  v18 = v6;
  v19[0] = v7;
  v20 = v8;
  memset(v23, 0, 56);
  memset(v22, 0, sizeof(v22));
  v23[7] = 0xFF51AFD7ED558CCDLL;
  v11 = llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(v22, v22, v23, v3, v4, &v17, &v18, v19, &v20);
  v15 = v16;
  *&v22[0] = v16;
  *(&v22[0] + 1) = v21;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v10 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompileUnitAttr,void>::id, v11, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v15, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, v22);
  v13 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::MetadataAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::MetadataAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::MetadataAttrStorage,mlir::detail::AttributeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12MetadataAttrES2_NSE_6detail19MetadataAttrStorageENSB_16AttributeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v4, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12MetadataAttrES2_NSD_6detail19MetadataAttrStorageENSA_16AttributeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttr,void>::id, "debuginfo.metadata", 18);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12MetadataAttrES2_NSE_6detail19MetadataAttrStorageENSB_16AttributeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  if (*(a2 + 24))
  {
    return a3(a4);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12MetadataAttrES2_NSD_6detail19MetadataAttrStorageENSA_16AttributeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, void *a2, unint64_t **a3)
{
  v4 = a2[1];
  v5 = a2[2];
  if (a2[3])
  {
    v6 = *a3;
    if (*a3)
    {
      v7 = *v6;
      v8 = mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttrInterface,void>::resolveTypeID();
      v9 = mlir::detail::InterfaceMap::lookup(v7 + 8, v8);
    }

    else
    {
      v9 = 0;
    }
  }

  else
  {
    v9 = 0;
    v6 = 0;
  }

  v10 = *(**a2 + 32);

  return mlir::ODIE::DebugInfo::MetadataAttr::get(v10, v4, v5, v6, v9);
}

uint64_t mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttrInterface,void>::resolveTypeID()
{
  v0 = &llvm::getTypeName<mlir::SideEffects::AutomaticAllocationScopeResource>(void)::Name;
  {
    v0 = &llvm::getTypeName<mlir::SideEffects::AutomaticAllocationScopeResource>(void)::Name;
    if (v2)
    {
      v3 = llvm::getTypeName<mlir::ODIE::DebugInfo::MetadataAttrInterface>();
      mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::MetadataAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v3, v4);
      v0 = &llvm::getTypeName<mlir::SideEffects::AutomaticAllocationScopeResource>(void)::Name;
    }
  }

  return v0[333];
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::MetadataAttrInterface>()
{
  {
    llvm::getTypeName<mlir::ODIE::DebugInfo::MetadataAttrInterface>(void)::Name = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::MetadataAttrInterface>();
    unk_27FC1BA80 = v1;
  }

  return llvm::getTypeName<mlir::ODIE::DebugInfo::MetadataAttrInterface>(void)::Name;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::MetadataAttrInterface>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::MetadataAttrInterface]";
  v6 = 106;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::SubprogramAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v17[6] = *MEMORY[0x277D85DE8];
  v16[0] = v17;
  v16[1] = 0x300000000;
  v4 = malloc_type_malloc(1uLL, 0x400A2AC0F1uLL);
  if ((atomic_load_explicit(&qword_27FC26E20, memory_order_acquire) & 1) == 0)
  {
    v8 = v4;
    v9 = __cxa_guard_acquire(&qword_27FC26E20);
    v4 = v8;
    if (v9)
    {
      v10 = llvm::getTypeName<mlir::ODIE::DebugInfo::ScopeAttrInterface>();
      _MergedGlobals_70 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v10, v11);
      __cxa_guard_release(&qword_27FC26E20);
      v4 = v8;
    }
  }

  mlir::detail::InterfaceMap::insert(v16, _MergedGlobals_70, v4);
  v5 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v5 = mlir::detail::TypedAttrInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramAttr>::getType;
  v6 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
  mlir::detail::InterfaceMap::insert(v16, v6, v5);
  *&v14 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::SubprogramAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::detail::AttributeUniquer,mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v15 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v16, &v14, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14SubprogramAttrES2_NSE_6detail21SubprogramAttrStorageENSB_16AttributeUniquerEJNSE_18ScopeAttrInterface5TraitENS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v13, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14SubprogramAttrES2_NSD_6detail21SubprogramAttrStorageENSA_16AttributeUniquerEJNSD_18ScopeAttrInterface5TraitENS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v12, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id, "debuginfo.subprogram", 20);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v14);
  mlir::detail::InterfaceMap::~InterfaceMap(v16);
  v7 = *MEMORY[0x277D85DE8];
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::ScopeAttrInterface>()
{
  if ((atomic_load_explicit(&qword_27FC26E38, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26E38))
  {
    qword_27FC26E28 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::ScopeAttrInterface>();
    unk_27FC26E30 = v1;
    __cxa_guard_release(&qword_27FC26E38);
  }

  return qword_27FC26E28;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::ScopeAttrInterface>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::ScopeAttrInterface]";
  v6 = 103;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::SubprogramAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::detail::AttributeUniquer,mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  if ((atomic_load_explicit(&qword_27FC26E48, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26E48))
  {
    v6 = llvm::getTypeName<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait>(void)::Empty>>();
    qword_27FC26E40 = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v6, v7);
    __cxa_guard_release(&qword_27FC26E48);
  }

  v2 = qword_27FC26E40;
  v3 = mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID();
  return v2 == a1 || v3 == a1;
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait>(void)::Empty>>()
{
  if ((atomic_load_explicit(&qword_27FC26E60, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26E60))
  {
    qword_27FC26E50 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait>(void)::Empty>>();
    *algn_27FC26E58 = v1;
    __cxa_guard_release(&qword_27FC26E60);
  }

  return qword_27FC26E50;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait>(void)::Empty>>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::ScopeAttrInterface::Trait<Empty>]";
  v6 = 117;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14SubprogramAttrES2_NSE_6detail21SubprogramAttrStorageENSB_16AttributeUniquerEJNSE_18ScopeAttrInterface5TraitENS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4, void (*a5)(uint64_t), uint64_t a6)
{
  v8 = a2[2];
  v7 = a2[3];
  if (a2[1])
  {
    a5(a6);
  }

  if (v8)
  {
    a3(a4, v8);
  }

  if (v7)
  {

    a3(a4, v7);
  }
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14SubprogramAttrES2_NSD_6detail21SubprogramAttrStorageENSA_16AttributeUniquerEJNSD_18ScopeAttrInterface5TraitENS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  v30 = *MEMORY[0x277D85DE8];
  if (*(a2 + 8))
  {
    v5 = *a5;
  }

  else
  {
    v5 = 0;
  }

  v6 = *(a2 + 24);
  if (*(a2 + 16))
  {
    v8 = *a3++;
    v7 = v8;
  }

  else
  {
    v7 = 0;
  }

  v9 = *(a2 + 32);
  v10 = *(a2 + 48);
  v11 = *(a2 + 64);
  if (v6)
  {
    v6 = *a3;
  }

  v12 = *(**a2 + 32);
  v13 = *v12;
  v17[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id;
  v17[1] = v12;
  v25[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21SubprogramAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_14SubprogramAttrEJNS1_4TypeENS1_13SymbolRefAttrENS3_8FileAttrENS_9StringRefESH_jEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS6_;
  v25[1] = v17;
  v19 = v5;
  v20 = v7;
  v21 = v6;
  v22 = v9;
  v23 = v10;
  v24 = v11;
  memset(v27, 0, sizeof(v27));
  memset(__dst, 0, sizeof(__dst));
  v28 = 0;
  v29 = 0xFF51AFD7ED558CCDLL;
  v14 = llvm::hashing::detail::hash_combine_recursive_helper::combine<mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(__dst, __dst, v27, v5, &v20, &v21, &v22, &v23, &v24);
  v18 = &v19;
  *&__dst[0] = &v19;
  *(&__dst[0] + 1) = v25;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v13 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id, v14, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v18, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, __dst);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::LocalVariableAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v12[6] = *MEMORY[0x277D85DE8];
  v11[0] = v12;
  v11[1] = 0x300000000;
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::detail::TypedAttrInterfaceTraits::Model<mlir::ODIE::DebugInfo::LocalVariableAttr>::getType;
  v5 = mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID();
  mlir::detail::InterfaceMap::insert(v11, v5, v4);
  *&v9 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocalVariableAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v10 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v11, &v9, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo17LocalVariableAttrES2_NSE_6detail24LocalVariableAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v8, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo17LocalVariableAttrES2_NSD_6detail24LocalVariableAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v7, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id, "debuginfo.local_variable", 24);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v9);
  mlir::detail::InterfaceMap::~InterfaceMap(v11);
  v6 = *MEMORY[0x277D85DE8];
}

BOOL mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocalVariableAttr,mlir::Attribute,mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  v2 = mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID();
  v3 = 0;
  do
  {
    v4 = v3;
    v3 = 1;
  }

  while ((v4 & 1) == 0 && v2 != a1);
  return (v4 & 1) == 0;
}

void _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo17LocalVariableAttrES2_NSE_6detail24LocalVariableAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, uint64_t a2, void (*a3)(void, void), uint64_t a4, void (*a5)(uint64_t), uint64_t a6)
{
  v7 = *(a2 + 40);
  if (*(a2 + 8))
  {
    v8 = a3;
    a5(a6);
    a3 = v8;
  }

  if (v7)
  {

    a3(a4, v7);
  }
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo17LocalVariableAttrES2_NSD_6detail24LocalVariableAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  v5 = *(a2 + 40);
  if (!*(a2 + 8))
  {
    v6 = 0;
    if (v5)
    {
      goto LABEL_3;
    }

LABEL_5:
    v7 = 0;
    return mlir::ODIE::DebugInfo::LocalVariableAttr::get(*(**a2 + 32), v6, *(a2 + 16), *(a2 + 24), *(a2 + 32), v7, *(a2 + 48));
  }

  v6 = *a5;
  if (!v5)
  {
    goto LABEL_5;
  }

LABEL_3:
  v7 = *a3;
  return mlir::ODIE::DebugInfo::LocalVariableAttr::get(*(**a2 + 32), v6, *(a2 + 16), *(a2 + 24), *(a2 + 32), v7, *(a2 + 48));
}

void mlir::AbstractAttribute::get<mlir::ODIE::DebugInfo::LocationAttr>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocationAttr,mlir::LocationAttr,mlir::ODIE::DebugInfo::detail::LocationAttrStorage,mlir::detail::AttributeUniquer,mlir::AttributeTrait::IsLocation>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractAttribute::AbstractAttribute(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12LocationAttrENS1_12LocationAttrENSE_6detail19LocationAttrStorageENSB_16AttributeUniquerEJNS1_14AttributeTrait10IsLocationEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_, &v4, _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12LocationAttrENS1_12LocationAttrENSD_6detail19LocationAttrStorageENSA_16AttributeUniquerEJNS1_14AttributeTrait10IsLocationEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id, "debuginfo.location", 18);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

BOOL mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::LocationAttr,mlir::LocationAttr,mlir::ODIE::DebugInfo::detail::LocationAttrStorage,mlir::detail::AttributeUniquer,mlir::AttributeTrait::IsLocation>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  v2 = mlir::detail::TypeIDResolver<mlir::AttributeTrait::IsLocation<mlir::TypeID mlir::TypeID::get<mlir::AttributeTrait::IsLocation>(void)::Empty>,void>::resolveTypeID();
  v3 = 0;
  do
  {
    v4 = v3;
    v3 = 1;
  }

  while ((v4 & 1) == 0 && v2 != a1);
  return (v4 & 1) == 0;
}

uint64_t _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12LocationAttrENS1_12LocationAttrENSE_6detail19LocationAttrStorageENSB_16AttributeUniquerEJNS1_14AttributeTrait10IsLocationEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, void *a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  v7 = a2[3];
  v6 = a2[4];
  v8 = a2[5];
  v9 = a2[6];
  if (a2[2])
  {
    result = a3(a4);
  }

  if (v7)
  {
    result = (a3)(a4, v7);
  }

  if (v6)
  {
    result = (a3)(a4, v6);
  }

  if (v9)
  {
    v11 = 8 * v9;
    do
    {
      if (*v8)
      {
        result = a3(a4);
      }

      ++v8;
      v11 -= 8;
    }

    while (v11);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo12LocationAttrENS1_12LocationAttrENSD_6detail19LocationAttrStorageENSA_16AttributeUniquerEJNS1_14AttributeTrait10IsLocationEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  v26[9] = *MEMORY[0x277D85DE8];
  v4 = *(a2 + 16);
  if (v4)
  {
    --a4;
    v5 = *a3++;
    v4 = v5;
  }

  v6 = *(a2 + 48);
  v7 = *(a2 + 32);
  if (*(a2 + 24))
  {
    --a4;
    v9 = *a3++;
    v8 = v9;
  }

  else
  {
    v8 = 0;
  }

  v10 = *(a2 + 8);
  if (v7)
  {
    --a4;
    v11 = *a3++;
    v7 = v11;
  }

  if (a4 < v6)
  {
    v6 = a4;
  }

  v12 = *(**a2 + 32);
  v13 = *v12;
  v17[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id;
  v17[1] = v12;
  v24[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19LocationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12LocationAttrEJjjNS1_13SymbolRefAttrENS3_8FileAttrESD_NS_8ArrayRefINS1_9AttributeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_;
  v24[1] = v17;
  v19 = v10;
  v20 = v4;
  v21 = v8;
  v22 = v7;
  v23[0] = a3;
  v23[1] = v6;
  memset(v26, 0, 56);
  memset(__dst, 0, sizeof(__dst));
  v26[7] = 0xFF51AFD7ED558CCDLL;
  v14 = llvm::hashing::detail::hash_combine_recursive_helper::combine<unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(__dst, __dst, v26, v10, &v19 + 1, &v20, &v21, &v22, v23);
  v18 = &v19;
  *&__dst[0] = &v19;
  *(&__dst[0] + 1) = v24;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v13 + 560), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocationAttr,void>::id, v14, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute> &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v18, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute> &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, __dst);
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::FileAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::FileAttrStorage,llvm::StringRef,llvm::StringRef,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::FileAttrStorage *)>,mlir::TypeID,llvm::StringRef,llvm::StringRef,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(uint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  v3 = *(a2 + 16);
  if (v3 != *(*a1 + 8) || v3 && memcmp(*(a2 + 8), *v2, v3))
  {
    return 0;
  }

  v5 = *(a2 + 32);
  if (v5 != *(v2 + 24) || v5 && memcmp(*(a2 + 24), *(v2 + 16), v5))
  {
    return 0;
  }

  v6 = *(a2 + 48);
  if (v6 != *(v2 + 40))
  {
    return 0;
  }

  if (v6)
  {
    return memcmp(*(a2 + 40), *(v2 + 32), v6) == 0;
  }

  return 1;
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::FileAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::FileAttrStorage,llvm::StringRef,llvm::StringRef,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::FileAttrStorage *)>,mlir::TypeID,llvm::StringRef,llvm::StringRef,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, unint64_t *a2)
{
  v4 = *(*a1 + 16);
  v5 = *(*a1 + 24);
  v6 = *(*a1 + 32);
  v7 = *(*a1 + 40);
  v8 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, **a1, *(*a1 + 8));
  v10 = v9;
  v11 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, v4, v5);
  v13 = v12;
  v14 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, v6, v7);
  v16 = v15;
  v17 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 56, 3);
  *v17 = 0;
  v17[1] = v8;
  v17[2] = v10;
  v17[3] = v11;
  v17[4] = v13;
  v17[5] = v14;
  v17[6] = v16;
  v18 = *(a1 + 8);
  if (*v18)
  {
    (*v18)(*(v18 + 8), v17);
  }

  return v17;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail15FileAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_8FileAttrEJNS_9StringRefESE_SE_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(llvm::hashing::detail::hash_combine_recursive_helper *a1, void *a2, unint64_t *a3, llvm::hashing::detail::hash_state *a4, uint64_t a5, unsigned int *a6, uint64_t a7, char *a8, uint64_t a9)
{
  v27 = 0;
  v15 = llvm::hashing::detail::hash_combine_range_impl<char const>(a4, a4 + a5, a3, a4);
  v16 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v27, a2, a3, v15);
  v17 = *a6;
  v28 = v27;
  v18 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v28, v16, a3, (v17 >> 4) ^ (v17 >> 9));
  v19 = *a7;
  v20 = *(a7 + 8);
  v29 = v28;
  v23 = llvm::hashing::detail::hash_combine_range_impl<char const>(v19, v19 + v20, v21, v22);
  v24 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v29, v18, a3, v23);
  v30 = v29;
  v25 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<BOOL>(a1, &v30, v24, a3, *a8);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::StringRef>(a1, v30, v25, a3, a9);
}

BOOL mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage::operator==(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 16);
  if (v2 != *(a2 + 8))
  {
    return 0;
  }

  if (v2 && memcmp(*(a1 + 8), *a2, v2))
  {
    return 0;
  }

  if (*(a1 + 24) != *(a2 + 16))
  {
    return 0;
  }

  v5 = *(a1 + 40);
  if (v5 != *(a2 + 32) || v5 && memcmp(*(a1 + 32), *(a2 + 24), v5))
  {
    return 0;
  }

  if (*(a1 + 48) != *(a2 + 40))
  {
    return 0;
  }

  v6 = *(a1 + 64);
  if (v6 != *(a2 + 56))
  {
    return 0;
  }

  if (v6)
  {
    return memcmp(*(a1 + 56), *(a2 + 48), v6) == 0;
  }

  return 1;
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,BOOL,llvm::StringRef &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t *a1, unint64_t *a2)
{
  v3 = mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage::construct(a2, *a1);
  v4 = a1[1];
  if (*v4)
  {
    (*v4)(*(v4 + 8), v3);
  }

  return v3;
}

unint64_t mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage::construct(unint64_t *a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v3 = *(a2 + 24);
  v5 = *(a2 + 32);
  v6 = *(a2 + 40);
  v7 = *(a2 + 48);
  v8 = *(a2 + 56);
  v9 = mlir::StorageUniquer::StorageAllocator::copyInto(a1, *a2, *(a2 + 8));
  v11 = v10;
  v12 = mlir::StorageUniquer::StorageAllocator::copyInto(a1, v3, v5);
  v14 = v13;
  v15 = mlir::StorageUniquer::StorageAllocator::copyInto(a1, v7, v8);
  v17 = v16;
  result = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a1, 72, 3);
  *result = 0;
  *(result + 8) = v9;
  *(result + 16) = v11;
  *(result + 24) = v4;
  *(result + 32) = v12;
  *(result + 40) = v14;
  *(result + 48) = v6;
  *(result + 56) = v15;
  *(result + 64) = v17;
  return result;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail22CompileUnitAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_15CompileUnitAttrEJNS_9StringRefENS3_8FileAttrESE_bSE_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage *)>,mlir::TypeID,llvm::StringRef &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,BOOL &,llvm::StringRef &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t *a1, unint64_t *a2)
{
  v3 = mlir::ODIE::DebugInfo::detail::CompileUnitAttrStorage::construct(a2, *a1);
  v4 = a1[1];
  if (*v4)
  {
    (*v4)(*(v4 + 8), v3);
  }

  return v3;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail22CompileUnitAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_15CompileUnitAttrEJRNS_9StringRefERNS3_8FileAttrESF_RbSF_EEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::MetadataAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(uint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  v3 = *(a2 + 16);
  return v3 == *(*a1 + 8) && (!v3 || !memcmp(*(a2 + 8), *v2, v3)) && *(a2 + 24) == *(v2 + 16);
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::MetadataAttrStorage,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::MetadataAttrStorage *)>,mlir::TypeID,llvm::StringRef,mlir::ODIE::DebugInfo::MetadataAttrInterface &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, unint64_t *a2)
{
  v4 = *(*a1 + 16);
  v5 = *(*a1 + 24);
  v6 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, **a1, *(*a1 + 8));
  v8 = v7;
  v9 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 40, 3);
  *v9 = 0;
  v9[1] = v6;
  v9[2] = v8;
  v9[3] = v4;
  v9[4] = v5;
  v10 = *(a1 + 8);
  if (*v10)
  {
    (*v10)(*(v10 + 8), v9);
  }

  return v9;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19MetadataAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12MetadataAttrEJNS_9StringRefENS3_21MetadataAttrInterfaceEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_recursive_helper::combine<mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(llvm::hashing::detail::hash_combine_recursive_helper *a1, void *__dst, char *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, uint64_t a7, uint64_t a8, int *a9)
{
  v34 = 0;
  v15 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v34, __dst, a3, (a4 >> 4) ^ (a4 >> 9));
  v16 = *a5;
  v35 = v34;
  v17 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v35, v15, a3, (v16 >> 4) ^ (v16 >> 9));
  v18 = *a6;
  v36 = v35;
  v19 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v36, v17, a3, (v18 >> 4) ^ (v18 >> 9));
  v20 = *a7;
  v21 = *(a7 + 8);
  v37 = v36;
  v24 = llvm::hashing::detail::hash_combine_range_impl<char const>(v20, v20 + v21, v22, v23);
  v25 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v37, v19, a3, v24);
  v26 = *a8;
  v27 = *(a8 + 8);
  v38 = v37;
  v30 = llvm::hashing::detail::hash_combine_range_impl<char const>(v26, v26 + v27, v28, v29);
  v31 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v38, v25, a3, v30);
  v39 = v38;
  v32 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(a1, &v39, v31, a3, *a9);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine(a1, v39, v32, a3);
}

BOOL mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage::operator==(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 8) != *a2)
  {
    return 0;
  }

  if (*(a1 + 16) == *(a2 + 8) && *(a1 + 24) == *(a2 + 16))
  {
    v5 = *(a1 + 40);
    if (v5 == *(a2 + 32) && (!v5 || !memcmp(*(a1 + 32), *(a2 + 24), v5)))
    {
      v6 = *(a1 + 56);
      if (v6 == *(a2 + 48) && (!v6 || !memcmp(*(a1 + 48), *(a2 + 40), v6)))
      {
        return *(a1 + 64) == *(a2 + 56);
      }
    }
  }

  return 0;
}

uint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,llvm::StringRef,llvm::StringRef,unsigned int &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t *a1, unint64_t *a2)
{
  v4 = mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage::construct(a2, *a1);
  v5 = v3;
  v6 = a1[1];
  if (*v6)
  {
    (*v6)(*(v6 + 8), v3, v4);
  }

  return v5;
}

__n128 mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage::construct(unint64_t *a1, uint64_t a2)
{
  v3 = *(a2 + 16);
  v4 = *(a2 + 40);
  v5 = *(a2 + 48);
  v6 = *(a2 + 56);
  v15 = *a2;
  v7 = mlir::StorageUniquer::StorageAllocator::copyInto(a1, *(a2 + 24), *(a2 + 32));
  v9 = v8;
  v10 = mlir::StorageUniquer::StorageAllocator::copyInto(a1, v4, v5);
  v12 = v11;
  v13 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a1, 72, 3);
  *v13 = 0;
  result = v15;
  *(v13 + 8) = v15;
  *(v13 + 24) = v3;
  *(v13 + 32) = v7;
  *(v13 + 40) = v9;
  *(v13 + 48) = v10;
  *(v13 + 56) = v12;
  *(v13 + 64) = v6;
  return result;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21SubprogramAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_14SubprogramAttrEJNS1_4TypeENS1_13SymbolRefAttrENS3_8FileAttrENS_9StringRefESH_jEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

uint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage *)>,mlir::TypeID,mlir::Type &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,llvm::StringRef &,llvm::StringRef &,unsigned int &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t *a1, unint64_t *a2)
{
  v4 = mlir::ODIE::DebugInfo::detail::SubprogramAttrStorage::construct(a2, *a1);
  v5 = v3;
  v6 = a1[1];
  if (*v6)
  {
    (*v6)(*(v6 + 8), v3, v4);
  }

  return v5;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21SubprogramAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_14SubprogramAttrEJRNS1_4TypeERNS1_13SymbolRefAttrERNS3_8FileAttrERNS_9StringRefESL_RjEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESP_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSR_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage *)>,mlir::TypeID,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(void *a1, uint64_t a2)
{
  v2 = *a1;
  if (*(a2 + 8) == **a1 && (v4 = *(a2 + 24), v4 == v2[2]) && (!v4 || !memcmp(*(a2 + 16), v2[1], v4)) && *(a2 + 32) == *(v2 + 6) && *(a2 + 40) == v2[4])
  {
    return *(a2 + 48) == *(v2 + 10);
  }

  else
  {
    return 0;
  }
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocalVariableAttrStorage *)>,mlir::TypeID,mlir::Type,llvm::StringRef,unsigned int,mlir::SymbolRefAttr,unsigned int &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t **a1, unint64_t *a2)
{
  v4 = **a1;
  v5 = *(*a1 + 6);
  v6 = (*a1)[4];
  v7 = *(*a1 + 10);
  v8 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, (*a1)[1], (*a1)[2]);
  v10 = v9;
  v11 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 56, 3);
  *v11 = 0;
  *(v11 + 8) = v4;
  *(v11 + 16) = v8;
  *(v11 + 24) = v10;
  *(v11 + 32) = v5;
  *(v11 + 40) = v6;
  *(v11 + 48) = v7;
  v12 = a1[1];
  if (*v12)
  {
    (*v12)(v12[1], v11);
  }

  return v11;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail24LocalVariableAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_17LocalVariableAttrEJNS1_4TypeENS_9StringRefEjNS1_13SymbolRefAttrEjEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_recursive_helper::combine<unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(llvm::hashing::detail::hash_combine_recursive_helper *a1, _DWORD *__dst, unint64_t *a3, int a4, int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, uint64_t a9)
{
  v24 = 0;
  v15 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(a1, &v24, __dst, a3, a4);
  v25 = v24;
  v16 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(a1, &v25, v15, a3, *a5);
  v17 = *a6;
  v26 = v25;
  v18 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v26, v16, a3, (v17 >> 4) ^ (v17 >> 9));
  v19 = *a7;
  v27 = v26;
  v20 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v27, v18, a3, (v19 >> 4) ^ (v19 >> 9));
  v21 = *a8;
  v28 = v27;
  v22 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(a1, &v28, v20, a3, (v21 >> 4) ^ (v21 >> 9));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::ArrayRef<mlir::Attribute>>(a1, v28, v22, a3, a9);
}

BOOL mlir::ODIE::DebugInfo::detail::LocationAttrStorage::operator==(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 8) != *a2)
  {
    return 0;
  }

  if (*(a1 + 12) != *(a2 + 4))
  {
    return 0;
  }

  if (*(a1 + 16) != *(a2 + 8))
  {
    return 0;
  }

  if (*(a1 + 24) != *(a2 + 16))
  {
    return 0;
  }

  if (*(a1 + 32) != *(a2 + 24))
  {
    return 0;
  }

  v2 = *(a1 + 48);
  if (v2 != *(a2 + 40))
  {
    return 0;
  }

  if (!v2)
  {
    return 1;
  }

  v3 = *(a1 + 40);
  v4 = *(a2 + 32);
  v5 = 8 * v2 - 8;
  do
  {
    v7 = *v4++;
    v6 = v7;
    v8 = *v3++;
    result = v8 == v6;
    v10 = v8 != v6 || v5 == 0;
    v5 -= 8;
  }

  while (!v10);
  return result;
}

uint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int,unsigned int,mlir::SymbolRefAttr,mlir::ODIE::DebugInfo::FileAttr,mlir::ODIE::DebugInfo::LocationAttr,llvm::ArrayRef<mlir::Attribute> &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, unint64_t *a2)
{
  v4 = mlir::ODIE::DebugInfo::detail::LocationAttrStorage::construct(a2, *a1);
  v5 = v3;
  v6 = *(a1 + 8);
  if (*v6)
  {
    (*v6)(*(v6 + 8), v3, v4);
  }

  return v5;
}

__n128 mlir::ODIE::DebugInfo::detail::LocationAttrStorage::construct(unint64_t *a1, uint64_t *a2)
{
  v3 = a2[3];
  v4 = *a2;
  v10 = *(a2 + 1);
  v5 = mlir::StorageUniquer::StorageAllocator::copyInto<mlir::Attribute>(a1, a2[4], a2[5]);
  v7 = v6;
  v8 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a1, 56, 3);
  *v8 = 0;
  *(v8 + 8) = v4;
  result = v10;
  *(v8 + 16) = v10;
  *(v8 + 32) = v3;
  *(v8 + 40) = v5;
  *(v8 + 48) = v7;
  return result;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19LocationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12LocationAttrEJjjNS1_13SymbolRefAttrENS3_8FileAttrESD_NS_8ArrayRefINS1_9AttributeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

uint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::LocationAttrStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::LocationAttrStorage,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::LocationAttrStorage *)>,mlir::TypeID,unsigned int &,unsigned int &,mlir::SymbolRefAttr &,mlir::ODIE::DebugInfo::FileAttr &,mlir::ODIE::DebugInfo::LocationAttr &,llvm::ArrayRef<mlir::Attribute> &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, unint64_t *a2)
{
  v4 = mlir::ODIE::DebugInfo::detail::LocationAttrStorage::construct(a2, *a1);
  v5 = v3;
  v6 = *(a1 + 8);
  if (*v6)
  {
    (*v6)(*(v6 + 8), v3, v4);
  }

  return v5;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail19LocationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS3_12LocationAttrEJRjSE_RNS1_13SymbolRefAttrERNS3_8FileAttrERSD_RNS_8ArrayRefINS1_9AttributeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESQ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSS_E_EEvlS6_(uint64_t *a1, uint64_t *a2)
{
  result = mlir::AbstractAttribute::lookup(*a1, a1[1]);
  *a2 = result;
  return result;
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo12LocationAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_(void *a1, uint64_t *a2)
{
  v3 = mlir::ODIE::DebugInfo::LocationAttr::parse(*a1);
  *a2 = v3;
  return v3 != 0;
}

uint64_t llvm::function_ref<llvm::ParseResult ()(void)>::callback_fn<mlir::FieldParser<llvm::SmallVector<mlir::Attribute,6u>,llvm::SmallVector<mlir::Attribute,6u>>::parse(mlir::AsmParser &)::{lambda(void)#1}>(uint64_t *a1)
{
  v2 = *a1;
  v4 = 0;
  if (((*(*v2 + 440))(v2, &v4, 0) & 1) == 0)
  {
    return 0;
  }

  llvm::SmallVectorTemplateBase<mlir::Attribute,true>::push_back(a1[1], v4);
  return 1;
}

uint64_t mlir::ODIE::DebugInfo::ValueOp::verify(mlir::ODIE::DebugInfo::ValueOp *this)
{
  v23 = *MEMORY[0x277D85DE8];
  v2 = *this;
  v3 = *(*(v2 + 16 * ((*(v2 + 44) >> 23) & 1) + 64) + 8);
  if (*(*v3 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id)
  {
    v11 = (*(*(*(v2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == v3[1];
  }

  else
  {
    v14 = "debuginfo type: ";
    v15 = 259;
    mlir::Operation::emitError(&v18, v2, &v14);
    if (v18)
    {
      v16 = 4;
      v17 = v3;
      v4 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v20, &v16, 1);
      v5 = v20 + 24 * v21;
      v6 = *v4;
      *(v5 + 16) = *(v4 + 16);
      *v5 = v6;
      ++v21;
      if (v18)
      {
        mlir::Diagnostic::operator<<<50ul>(&v19, " was not equivalent to the input operand's type: ");
        if (v18)
        {
          v7 = *(*(*(*this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
          v16 = 4;
          v17 = v7;
          v8 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v20, &v16, 1);
          v9 = v20 + 24 * v21;
          v10 = *v8;
          *(v9 + 16) = *(v8 + 16);
          *v9 = v10;
          ++v21;
        }
      }
    }

    v11 = v22 ^ 1;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v18);
  }

  v12 = *MEMORY[0x277D85DE8];
  return v11 & 1;
}

uint64_t mlir::ODIE::DebugInfo::RecordOp::getEffects(uint64_t a1, uint64_t a2)
{
  v5 = mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>();
  v4 = mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get();
  return llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>>::emplace_back<mlir::MemoryEffects::Write *,mlir::SideEffects::DefaultResource *>(a2, &v5, &v4);
}

uint64_t llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>>::emplace_back<mlir::MemoryEffects::Write *,mlir::SideEffects::DefaultResource *>(uint64_t a1, void *a2, uint64_t *a3)
{
  v3 = *(a1 + 8);
  if (v3 >= *(a1 + 12))
  {
    return llvm::SmallVectorTemplateBase<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,true>::growAndEmplaceBack<mlir::MemoryEffects::Write *,mlir::SideEffects::DefaultResource *>(a1, a2, a3);
  }

  v4 = (*a1 + 40 * v3);
  v5 = *a3;
  *v4 = *a2;
  v4[1] = v5;
  v4[2] = 0;
  v4[3] = 0;
  *(v4 + 29) = 0;
  LODWORD(v4) = *(a1 + 8) + 1;
  *(a1 + 8) = v4;
  return *a1 + 40 * v4 - 40;
}

uint64_t mlir::ODIE::DebugInfo::RecordOp::setPropertiesFromAttr(void *a1, uint64_t *a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v21 = *MEMORY[0x277D85DE8];
  if (*(*a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
  {
    v8 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(a2[1], a2[1] + 16 * a2[2], "id", 2uLL);
    if (v9)
    {
      v10 = *(v8 + 8);
      if (v10)
      {
        if (*(*v10 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        {
          a3(&v17, a4);
          if (v17)
          {
            if (v17)
            {
              v15 = 0;
              v16 = v10;
              v11 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v19, &v15, 1);
              v12 = v19 + 24 * v20;
              v13 = *v11;
              *(v12 + 16) = *(v11 + 16);
              *v12 = v13;
              ++v20;
            }
          }

          goto LABEL_4;
        }

        *a1 = v10;
      }
    }

    result = 1;
    goto LABEL_13;
  }

  a3(&v17, a4);
  if (v17)
  {
    mlir::Diagnostic::operator<<<42ul>(v18, "expected DictionaryAttr to set properties");
  }

LABEL_4:
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v17);
  result = 0;
LABEL_13:
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::RecordOp::getPropertiesAsAttr(uint64_t *a1, uint64_t *a2, const llvm::Twine *a3)
{
  v15[6] = *MEMORY[0x277D85DE8];
  v13 = v15;
  v14 = 0x300000000;
  v3 = *a2;
  if (*a2)
  {
    v5 = *(**v3 + 32);
    v12 = 261;
    v11[0] = "id";
    v11[1] = 2;
    v6 = mlir::StringAttr::get(v5, v11, a3);
    llvm::SmallVectorTemplateBase<mlir::NamedAttribute,true>::push_back(&v13, v6, v3);
    v7 = v13;
    if (v14)
    {
      v8 = mlir::DictionaryAttr::get(a1, v13, v14);
      v7 = v13;
    }

    else
    {
      v8 = 0;
    }

    if (v7 != v15)
    {
      free(v7);
    }
  }

  else
  {
    v8 = 0;
  }

  v9 = *MEMORY[0x277D85DE8];
  return v8;
}

unint64_t mlir::ODIE::DebugInfo::RecordOp::computePropertiesHash(void *a1)
{
  v1 = 0x9DDFEA08EB382D69 * ((8 * *a1 - 0xAE502812AA7333) ^ HIDWORD(*a1));
  v2 = 0x9DDFEA08EB382D69 * (HIDWORD(*a1) ^ (v1 >> 47) ^ v1);
  v3 = v2 ^ (v2 >> 47);
  v4 = ((0x9DDFEA08EB382D69 * v3) >> 32) ^ 0xFF51AFD7ED558CCDLL;
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (((0x759C16B48 * v3) & 0x7FFFFFFF8) + 8));
  return 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
}

unint64_t mlir::ODIE::DebugInfo::RecordOp::getInherentAttr(uint64_t a1, void *a2, _WORD *a3, uint64_t a4)
{
  if (a4 == 2 && *a3 == 25705)
  {
    v5 = *a2 & 0xFFFFFFFFFFFFFF00;
    v4 = *a2;
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  return v5 | v4;
}

void *mlir::ODIE::DebugInfo::RecordOp::setInherentAttr(void *result, _WORD *a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 2 && *a2 == 25705)
  {
    if (a4)
    {
      if (*(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        v4 = a4;
      }

      else
      {
        v4 = 0;
      }
    }

    else
    {
      v4 = 0;
    }

    *result = v4;
  }

  return result;
}

void mlir::ODIE::DebugInfo::RecordOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, const llvm::Twine *a3)
{
  v3 = *a2;
  if (*a2)
  {
    v5 = *(**v3 + 32);
    v8 = 261;
    v7[0] = "id";
    v7[1] = 2;
    v6 = mlir::StringAttr::get(v5, v7, a3);
    mlir::NamedAttrList::push_back(a3, v6, v3);
  }
}

BOOL mlir::ODIE::DebugInfo::RecordOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v6 = mlir::NamedAttrList::findAttr<mlir::NamedAttrList const,mlir::StringAttr>(a2, **(a1 + 96));
  result = 1;
  if (v7)
  {
    v8 = v6[1];
    if (v8)
    {
      if (!mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps1(v8, "id", 2, a3, a4))
      {
        return 0;
      }
    }
  }

  return result;
}

BOOL mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps1(void *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  v15 = *MEMORY[0x277D85DE8];
  if (!a1 || *(*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id && (v7 = a1[1], *(*v7 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) && v7[2] == -2147483584)
  {
    v8 = 1;
  }

  else
  {
    a4(&v13, a5);
    if (v13)
    {
      mlir::Diagnostic::operator<<<12ul>(v14, "attribute '");
      if (v13)
      {
        v12 = 261;
        v11[0] = a2;
        v11[1] = a3;
        mlir::Diagnostic::operator<<(v14, v11);
        if (v13)
        {
          mlir::Diagnostic::operator<<<66ul>(v14, "' failed to satisfy constraint: 64-bit unsigned integer attribute");
        }
      }
    }

    v8 = (v14[192] & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v13);
  }

  v9 = *MEMORY[0x277D85DE8];
  return v8;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  result = *(a1 + 256);
  if (!result)
  {
    operator new();
  }

  return result;
}

uint64_t mlir::ODIE::DebugInfo::RecordOp::getId(mlir::ODIE::DebugInfo::RecordOp *this)
{
  v1 = *(*this + 16 * ((*(*this + 44) >> 23) & 1) + 64);
  if (*(v1 + 24) > 0x40u)
  {
    operator new[]();
  }

  return *(v1 + 16);
}

BOOL mlir::ODIE::DebugInfo::RecordOp::verifyInvariantsImpl(unsigned int **this)
{
  v10 = *MEMORY[0x277D85DE8];
  v1 = *this;
  v2 = *&v1[4 * ((v1[11] >> 23) & 1) + 16];
  if (v2)
  {
    v8[0] = v1;
    v3 = mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps1(v2, "id", 2, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, v8);
  }

  else
  {
    v6 = "requires attribute 'id'";
    v7 = 259;
    mlir::Operation::emitOpError(v1, &v6, v8);
    v3 = (v9 & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v8);
  }

  v4 = *MEMORY[0x277D85DE8];
  return v3;
}

BOOL mlir::ODIE::DebugInfo::RecordOp::parse(uint64_t a1, uint64_t a2)
{
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  v15[0] = v16;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v12 = 0;
  v13[0] = &v14;
  if (((*(*a1 + 280))() & 1) == 0)
  {
    return 0;
  }

  v4 = (*(*a1 + 40))(a1);
  if (((*(*a1 + 704))(a1, v16, 1) & 1) == 0)
  {
    return 0;
  }

  if (((*(*a1 + 104))(a1) & 1) == 0)
  {
    return 0;
  }

  v10[0] = 0;
  if (((*(*a1 + 536))(a1, v10) & 1) == 0)
  {
    return 0;
  }

  v14 = v10[0];
  if (((*(*a1 + 296))(a1) & 1) == 0)
  {
    return 0;
  }

  v5 = (*(*a1 + 32))(a1);
  v6 = mlir::IntegerType::get(*v5, 64, 2);
  if (!mlir::AsmParser::parseAttribute<mlir::IntegerAttr>(a1, &v12, v6))
  {
    return 0;
  }

  if (v12)
  {
    v7 = mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>(a2);
    *v7 = v12;
  }

  v11 = (*(*a1 + 40))(a1);
  if (((*(*a1 + 488))(a1, a2 + 112) & 1) != 0 && (v8 = *(a2 + 8), v10[0] = a1, v10[1] = &v11, v10[2] = a2, mlir::ODIE::DebugInfo::RecordOp::verifyInherentAttrs(v8, a2 + 112, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::RecordOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, v10)))
  {
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16);
  }

  else
  {
    return 0;
  }
}

void mlir::ODIE::DebugInfo::RecordOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v20[4] = *MEMORY[0x277D85DE8];
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "(", 1uLL);
  }

  else
  {
    *v5 = 40;
    ++*(v4 + 4);
  }

  (*(*a2 + 160))(a2, *(*(*this + 9) + 24));
  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if (v7 >= *(v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    *(v6 + 4) = v7 + 1;
    *v7 = 32;
  }

  v8 = (*(*a2 + 16))(a2);
  v9 = *(v8 + 4);
  if (*(v8 + 3) == v9)
  {
    llvm::raw_ostream::write(v8, ":", 1uLL);
  }

  else
  {
    *v9 = 58;
    ++*(v8 + 4);
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if (v11 >= *(v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }

  else
  {
    *(v10 + 4) = v11 + 1;
    *v11 = 32;
  }

  (*(*a2 + 32))(a2, *(*(*(*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v12 = (*(*a2 + 16))(a2);
  v13 = *(v12 + 4);
  if (*(v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ")", 1uLL);
  }

  else
  {
    *v13 = 41;
    ++*(v12 + 4);
  }

  v14 = (*(*a2 + 16))(a2);
  v15 = *(v14 + 4);
  if (v15 >= *(v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }

  else
  {
    *(v14 + 4) = v15 + 1;
    *v15 = 32;
  }

  (*(*a2 + 48))(a2, *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 8));
  v18 = v20;
  v19 = 0x200000000;
  llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(&v18, "id", 2);
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  (*(*a2 + 192))(a2, *(AttrDictionary + 8), *(AttrDictionary + 16), v18, v19);
  if (v18 != v20)
  {
    free(v18);
  }

  v17 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::DebugInfo::SubprogramOp::setPropertiesFromAttr(void *a1, uint64_t *a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v25 = *MEMORY[0x277D85DE8];
  if (*(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
  {
    a3(&v21, a4);
    if (v21)
    {
      mlir::Diagnostic::operator<<<42ul>(v22, "expected DictionaryAttr to set properties");
    }

    goto LABEL_4;
  }

  v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(a2[1], a2[1] + 16 * a2[2], "subprogram", 0xAuLL);
  if ((v10 & 1) == 0 || (v11 = *(v9 + 8)) == 0)
  {
LABEL_12:
    v12 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(a2[1], a2[1] + 16 * a2[2], "sym_name", 8uLL);
    if (v13)
    {
      v14 = *(v12 + 8);
      if (v14)
      {
        if (*(*v14 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          a3(&v21, a4);
          if (!v21)
          {
            goto LABEL_4;
          }

          if (!v21)
          {
            goto LABEL_4;
          }

          v19 = 0;
          v20 = v14;
          goto LABEL_18;
        }

        a1[1] = v14;
      }
    }

    result = 1;
    goto LABEL_21;
  }

  if (*(*v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
  {
    *a1 = v11;
    goto LABEL_12;
  }

  a3(&v21, a4);
  if (!v21)
  {
    goto LABEL_4;
  }

  if (!v21)
  {
    goto LABEL_4;
  }

  v19 = 0;
  v20 = v11;
LABEL_18:
  v15 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v23, &v19, 1);
  v16 = v23 + 24 * v24;
  v17 = *v15;
  *(v16 + 16) = *(v15 + 16);
  *v16 = v17;
  ++v24;
LABEL_4:
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v21);
  result = 0;
LABEL_21:
  v18 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::SubprogramOp::getPropertiesAsAttr(uint64_t *a1, uint64_t *a2, const llvm::Twine *a3)
{
  v20[6] = *MEMORY[0x277D85DE8];
  v18 = v20;
  v19 = 0x300000000;
  v5 = *a2;
  if (*a2)
  {
    v6 = *(**v5 + 32);
    v17 = 261;
    v15 = "subprogram";
    v16 = 10;
    v7 = mlir::StringAttr::get(v6, &v15, a3);
    llvm::SmallVectorTemplateBase<mlir::NamedAttribute,true>::push_back(&v18, v7, v5);
  }

  v8 = a2[1];
  if (v8)
  {
    v9 = *(**v8 + 32);
    v17 = 261;
    v15 = "sym_name";
    v16 = 8;
    v10 = mlir::StringAttr::get(v9, &v15, a3);
    llvm::SmallVectorTemplateBase<mlir::NamedAttribute,true>::push_back(&v18, v10, v8);
  }

  v11 = v18;
  if (v19)
  {
    v12 = mlir::DictionaryAttr::get(a1, v18, v19);
    v11 = v18;
  }

  else
  {
    v12 = 0;
  }

  if (v11 != v20)
  {
    free(v11);
  }

  v13 = *MEMORY[0x277D85DE8];
  return v12;
}

unint64_t mlir::ODIE::DebugInfo::SubprogramOp::computePropertiesHash(void *a1)
{
  v14 = *MEMORY[0x277D85DE8];
  v1 = a1[1];
  v2 = 0x9DDFEA08EB382D69 * ((8 * *a1 - 0xAE502812AA7333) ^ HIDWORD(*a1));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(*a1) ^ (v2 >> 47) ^ v2);
  v9 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((8 * v1 - 0xAE502812AA7333) ^ HIDWORD(v1));
  v8 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  v12 = 0;
  v13 = 0xFF51AFD7ED558CCDLL;
  result = llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code>(v10, 0, v10, v11, &v9, &v8);
  v7 = *MEMORY[0x277D85DE8];
  return result;
}

unint64_t mlir::ODIE::DebugInfo::SubprogramOp::getInherentAttr(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a4 != 8)
  {
    if (a4 != 10)
    {
      goto LABEL_10;
    }

    if (*a3 != 0x72676F7270627573 || *(a3 + 8) != 28001)
    {
      goto LABEL_10;
    }

    v5 = *a2;
LABEL_12:
    v6 = v5 & 0xFFFFFFFFFFFFFF00;
    return v6 | v5;
  }

  if (*a3 == 0x656D616E5F6D7973)
  {
    v5 = a2[1];
    goto LABEL_12;
  }

LABEL_10:
  LOBYTE(v5) = 0;
  v6 = 0;
  return v6 | v5;
}

void *mlir::ODIE::DebugInfo::SubprogramOp::setInherentAttr(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 8)
  {
    if (*a2 == 0x656D616E5F6D7973)
    {
      if (a4)
      {
        if (*(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          v5 = a4;
        }

        else
        {
          v5 = 0;
        }
      }

      else
      {
        v5 = 0;
      }

      result[1] = v5;
    }
  }

  else if (a3 == 10 && *a2 == 0x72676F7270627573 && *(a2 + 8) == 28001)
  {
    if (a4)
    {
      if (*(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
      {
        v6 = a4;
      }

      else
      {
        v6 = 0;
      }
    }

    else
    {
      v6 = 0;
    }

    *result = v6;
  }

  return result;
}

void mlir::ODIE::DebugInfo::SubprogramOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, const llvm::Twine *a3)
{
  v5 = *a2;
  if (*a2)
  {
    v6 = *(**v5 + 32);
    v13 = 261;
    v11 = "subprogram";
    v12 = 10;
    v7 = mlir::StringAttr::get(v6, &v11, a3);
    mlir::NamedAttrList::push_back(a3, v7, v5);
  }

  v8 = a2[1];
  if (v8)
  {
    v9 = *(**v8 + 32);
    v13 = 261;
    v11 = "sym_name";
    v12 = 8;
    v10 = mlir::StringAttr::get(v9, &v11, a3);
    mlir::NamedAttrList::push_back(a3, v10, v8);
  }
}

BOOL mlir::ODIE::DebugInfo::SubprogramOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v8 = mlir::NamedAttrList::findAttr<mlir::NamedAttrList const,mlir::StringAttr>(a2, **(a1 + 96));
  result = 0;
  if ((v9 & 1) == 0 || (v10 = v8[1]) == 0 || mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps3(v10, "subprogram", 10, a3, a4))
  {
    v11 = mlir::NamedAttrList::findAttr<mlir::NamedAttrList const,mlir::StringAttr>(a2, *(*(a1 + 96) + 8));
    if ((v12 & 1) == 0)
    {
      return 1;
    }

    v13 = v11[1];
    if (!v13 || mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps2(v13, "sym_name", 8, a3, a4))
    {
      return 1;
    }
  }

  return result;
}

BOOL mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps3(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  v14 = *MEMORY[0x277D85DE8];
  if (!a1 || *(*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
  {
    v7 = 1;
  }

  else
  {
    a4(&v12, a5);
    if (v12)
    {
      mlir::Diagnostic::operator<<<12ul>(v13, "attribute '");
      if (v12)
      {
        v11 = 261;
        v10[0] = a2;
        v10[1] = a3;
        mlir::Diagnostic::operator<<(v13, v10);
        if (v12)
        {
          mlir::Diagnostic::operator<<<33ul>(v13, "' failed to satisfy constraint: ");
        }
      }
    }

    v7 = (v13[192] & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v12);
  }

  v8 = *MEMORY[0x277D85DE8];
  return v7;
}

BOOL mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps2(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  v14 = *MEMORY[0x277D85DE8];
  if (!a1 || *(*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    v7 = 1;
  }

  else
  {
    a4(&v12, a5);
    if (v12)
    {
      mlir::Diagnostic::operator<<<12ul>(v13, "attribute '");
      if (v12)
      {
        v11 = 261;
        v10[0] = a2;
        v10[1] = a3;
        mlir::Diagnostic::operator<<(v13, v10);
        if (v12)
        {
          mlir::Diagnostic::operator<<<49ul>(v13, "' failed to satisfy constraint: string attribute");
        }
      }
    }

    v7 = (v13[192] & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v12);
  }

  v8 = *MEMORY[0x277D85DE8];
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  result = *(a1 + 256);
  if (!result)
  {
    operator new();
  }

  return result;
}

BOOL mlir::DialectBytecodeReader::readAttribute<mlir::ODIE::DebugInfo::SubprogramAttr>(uint64_t a1, void *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  v14 = 0;
  if ((*(*a1 + 48))(a1, &v14))
  {
    v4 = v14;
    v5 = *(*v14 + 136);
    if (v5 != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
    {
      v4 = 0;
    }

    *a2 = v4;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
    {
      v9 = 1;
    }

    else
    {
      v13[16] = 257;
      (*(*a1 + 16))(&v18, a1, v13);
      if (v18)
      {
        mlir::Diagnostic::operator<<<10ul>(v19, "expected ");
      }

      if ((atomic_load_explicit(&qword_27FC26EC8, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26EC8))
      {
        qword_27FC26EB8 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::SubprogramAttr>();
        unk_27FC26EC0 = v12;
        __cxa_guard_release(&qword_27FC26EC8);
      }

      if (v18)
      {
        v17 = 261;
        v15 = qword_27FC26EB8;
        v16 = unk_27FC26EC0;
        mlir::Diagnostic::operator<<(v19, &v15);
        if (v18)
        {
          mlir::Diagnostic::operator<<<12ul>(v19, ", but got: ");
          if (v18)
          {
            LODWORD(v15) = 0;
            v16 = v14;
            v6 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v20, &v15, 1);
            v7 = v20 + 24 * v21;
            v8 = *v6;
            *(v7 + 16) = *(v6 + 16);
            *v7 = v8;
            ++v21;
          }
        }
      }

      v9 = (v22 & 1) == 0;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(&v18);
    }
  }

  else
  {
    v9 = 0;
  }

  v10 = *MEMORY[0x277D85DE8];
  return v9;
}

BOOL mlir::ODIE::DebugInfo::SubprogramOp::verifyInvariantsImpl(unsigned int **this)
{
  v16 = *MEMORY[0x277D85DE8];
  v2 = *this;
  v3 = &v2[4 * ((v2[11] >> 23) & 1)];
  v6 = *(v3 + 8);
  v4 = v3 + 16;
  v5 = v6;
  if (!v6)
  {
    v9 = "requires attribute 'subprogram'";
LABEL_7:
    v12 = v9;
    v13 = 259;
    mlir::Operation::emitOpError(v2, &v12, v14);
    v8 = (v15 & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v14);
    goto LABEL_9;
  }

  v7 = *(v4 + 1);
  if (!v7)
  {
    v9 = "requires attribute 'sym_name'";
    goto LABEL_7;
  }

  v14[0] = v2;
  if (mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps2(v7, "sym_name", 8, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, v14))
  {
    v14[0] = *this;
    v8 = mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps3(v5, "subprogram", 10, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, v14);
  }

  else
  {
    v8 = 0;
  }

LABEL_9:
  v10 = *MEMORY[0x277D85DE8];
  return v8;
}

uint64_t mlir::ODIE::DebugInfo::SubprogramOp::parse(mlir::AsmParser *a1, uint64_t a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v11 = 0;
  if (!mlir::AsmParser::parseSymbolName(a1, &v11))
  {
    goto LABEL_12;
  }

  if (v11)
  {
    v4 = mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>(a2);
    *(v4 + 8) = v11;
  }

  v5 = (*(*a1 + 40))(a1);
  v14 = 0;
  v15[0] = a1;
  if (((*(*a1 + 448))(a1, &v14, 0, _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo14SubprogramAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_, v15) & 1) == 0)
  {
    goto LABEL_12;
  }

  v6 = v14;
  if (*(*v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramAttr,void>::id)
  {
    *mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>(a2) = v6;
  }

  else
  {
    v12[0] = "invalid kind of attribute specified";
    v13 = 259;
    (*(*a1 + 24))(v15, a1, v5, v12);
    v7 = v16;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v15);
    if (v7)
    {
LABEL_12:
      result = 0;
      goto LABEL_13;
    }
  }

  v12[0] = (*(*a1 + 40))(a1);
  if (((*(*a1 + 496))(a1, a2 + 112) & 1) == 0)
  {
    goto LABEL_12;
  }

  v8 = *(a2 + 8);
  v15[0] = a1;
  v15[1] = v12;
  v15[2] = a2;
  if (!mlir::ODIE::DebugInfo::SubprogramOp::verifyInherentAttrs(v8, a2 + 112, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::SubprogramOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, v15))
  {
    goto LABEL_12;
  }

  result = 1;
LABEL_13:
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::ODIE::DebugInfo::SubprogramOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v15[4] = *MEMORY[0x277D85DE8];
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (v5 >= *(v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }

  else
  {
    *(v4 + 4) = v5 + 1;
    *v5 = 32;
  }

  v6 = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 9);
  (*(*a2 + 88))(a2, *(v6 + 16), *(v6 + 24));
  v7 = (*(*a2 + 16))(a2);
  v8 = *(v7 + 4);
  if (v8 >= *(v7 + 3))
  {
    llvm::raw_ostream::write(v7, 32);
  }

  else
  {
    *(v7 + 4) = v8 + 1;
    *v8 = 32;
  }

  v13 = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 8);
  if (((*(*a2 + 56))(a2) & 1) == 0)
  {
    v9 = (*(*a2 + 16))(a2);
    v10 = (*(*v9 + 80))(v9) + v9[4] - v9[2];
    mlir::ODIE::DebugInfo::SubprogramAttr::print(&v13, a2);
    if (v10 == (*(*v9 + 80))(v9) + v9[4] - v9[2])
    {
      (*(*a2 + 40))(a2, v13);
    }
  }

  v13 = v15;
  v14 = 0x200000000;
  llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(&v13, "sym_name", 8);
  llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(&v13, "subprogram", 10);
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  (*(*a2 + 200))(a2, *(AttrDictionary + 8), *(AttrDictionary + 16), v13, v14);
  if (v13 != v15)
  {
    free(v13);
  }

  v12 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::DebugInfo::ValueOp::setPropertiesFromAttr(void *a1, uint64_t *a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v21 = *MEMORY[0x277D85DE8];
  if (*(*a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
  {
    v8 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(a2[1], a2[1] + 16 * a2[2], "variable", 8uLL);
    if (v9)
    {
      v10 = *(v8 + 8);
      if (v10)
      {
        if (*(*v10 + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
        {
          a3(&v17, a4);
          if (v17)
          {
            if (v17)
            {
              v15 = 0;
              v16 = v10;
              v11 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v19, &v15, 1);
              v12 = v19 + 24 * v20;
              v13 = *v11;
              *(v12 + 16) = *(v11 + 16);
              *v12 = v13;
              ++v20;
            }
          }

          goto LABEL_4;
        }

        *a1 = v10;
      }
    }

    result = 1;
    goto LABEL_13;
  }

  a3(&v17, a4);
  if (v17)
  {
    mlir::Diagnostic::operator<<<42ul>(v18, "expected DictionaryAttr to set properties");
  }

LABEL_4:
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v17);
  result = 0;
LABEL_13:
  v14 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::ODIE::DebugInfo::ValueOp::getPropertiesAsAttr(uint64_t *a1, uint64_t *a2, const llvm::Twine *a3)
{
  v15[6] = *MEMORY[0x277D85DE8];
  v13 = v15;
  v14 = 0x300000000;
  v3 = *a2;
  if (*a2)
  {
    v5 = *(**v3 + 32);
    v12 = 261;
    v11[0] = "variable";
    v11[1] = 8;
    v6 = mlir::StringAttr::get(v5, v11, a3);
    llvm::SmallVectorTemplateBase<mlir::NamedAttribute,true>::push_back(&v13, v6, v3);
    v7 = v13;
    if (v14)
    {
      v8 = mlir::DictionaryAttr::get(a1, v13, v14);
      v7 = v13;
    }

    else
    {
      v8 = 0;
    }

    if (v7 != v15)
    {
      free(v7);
    }
  }

  else
  {
    v8 = 0;
  }

  v9 = *MEMORY[0x277D85DE8];
  return v8;
}

unint64_t mlir::ODIE::DebugInfo::ValueOp::computePropertiesHash(void *a1)
{
  v1 = 0x9DDFEA08EB382D69 * ((8 * *a1 - 0xAE502812AA7333) ^ HIDWORD(*a1));
  v2 = 0x9DDFEA08EB382D69 * (HIDWORD(*a1) ^ (v1 >> 47) ^ v1);
  v3 = v2 ^ (v2 >> 47);
  v4 = ((0x9DDFEA08EB382D69 * v3) >> 32) ^ 0xFF51AFD7ED558CCDLL;
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (((0x759C16B48 * v3) & 0x7FFFFFFF8) + 8));
  return 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
}

unint64_t mlir::ODIE::DebugInfo::ValueOp::getInherentAttr(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a4 == 8 && *a3 == 0x656C626169726176)
  {
    v5 = *a2 & 0xFFFFFFFFFFFFFF00;
    v4 = *a2;
  }

  else
  {
    v4 = 0;
    v5 = 0;
  }

  return v5 | v4;
}

void *mlir::ODIE::DebugInfo::ValueOp::setInherentAttr(void *result, void *a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 8 && *a2 == 0x656C626169726176)
  {
    if (a4)
    {
      if (*(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
      {
        v4 = a4;
      }

      else
      {
        v4 = 0;
      }
    }

    else
    {
      v4 = 0;
    }

    *result = v4;
  }

  return result;
}

void mlir::ODIE::DebugInfo::ValueOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, const llvm::Twine *a3)
{
  v3 = *a2;
  if (*a2)
  {
    v5 = *(**v3 + 32);
    v8 = 261;
    v7[0] = "variable";
    v7[1] = 8;
    v6 = mlir::StringAttr::get(v5, v7, a3);
    mlir::NamedAttrList::push_back(a3, v6, v3);
  }
}

BOOL mlir::ODIE::DebugInfo::ValueOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  v6 = mlir::NamedAttrList::findAttr<mlir::NamedAttrList const,mlir::StringAttr>(a2, **(a1 + 96));
  result = 1;
  if (v7)
  {
    v8 = v6[1];
    if (v8)
    {
      if (!mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps4(v8, "variable", 8, a3, a4))
      {
        return 0;
      }
    }
  }

  return result;
}

BOOL mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps4(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  v14 = *MEMORY[0x277D85DE8];
  if (!a1 || *(*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
  {
    v7 = 1;
  }

  else
  {
    a4(&v12, a5);
    if (v12)
    {
      mlir::Diagnostic::operator<<<12ul>(v13, "attribute '");
      if (v12)
      {
        v11 = 261;
        v10[0] = a2;
        v10[1] = a3;
        mlir::Diagnostic::operator<<(v13, v10);
        if (v12)
        {
          mlir::Diagnostic::operator<<<33ul>(v13, "' failed to satisfy constraint: ");
        }
      }
    }

    v7 = (v13[192] & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v12);
  }

  v8 = *MEMORY[0x277D85DE8];
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  result = *(a1 + 256);
  if (!result)
  {
    operator new();
  }

  return result;
}

BOOL mlir::DialectBytecodeReader::readAttribute<mlir::ODIE::DebugInfo::LocalVariableAttr>(uint64_t a1, void *a2)
{
  v23 = *MEMORY[0x277D85DE8];
  v14 = 0;
  if ((*(*a1 + 48))(a1, &v14))
  {
    v4 = v14;
    v5 = *(*v14 + 136);
    if (v5 != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
    {
      v4 = 0;
    }

    *a2 = v4;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
    {
      v9 = 1;
    }

    else
    {
      v13[16] = 257;
      (*(*a1 + 16))(&v18, a1, v13);
      if (v18)
      {
        mlir::Diagnostic::operator<<<10ul>(v19, "expected ");
      }

      if ((atomic_load_explicit(&qword_27FC26F08, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26F08))
      {
        qword_27FC26EF8 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::LocalVariableAttr>();
        unk_27FC26F00 = v12;
        __cxa_guard_release(&qword_27FC26F08);
      }

      if (v18)
      {
        v17 = 261;
        v15 = qword_27FC26EF8;
        v16 = unk_27FC26F00;
        mlir::Diagnostic::operator<<(v19, &v15);
        if (v18)
        {
          mlir::Diagnostic::operator<<<12ul>(v19, ", but got: ");
          if (v18)
          {
            LODWORD(v15) = 0;
            v16 = v14;
            v6 = llvm::SmallVectorTemplateCommon<mlir::DiagnosticArgument,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::DiagnosticArgument,true>>(&v20, &v15, 1);
            v7 = v20 + 24 * v21;
            v8 = *v6;
            *(v7 + 16) = *(v6 + 16);
            *v7 = v8;
            ++v21;
          }
        }
      }

      v9 = (v22 & 1) == 0;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(&v18);
    }
  }

  else
  {
    v9 = 0;
  }

  v10 = *MEMORY[0x277D85DE8];
  return v9;
}

BOOL mlir::ODIE::DebugInfo::ValueOp::verifyInvariantsImpl(unsigned int **this)
{
  v10 = *MEMORY[0x277D85DE8];
  v1 = *this;
  v2 = *&v1[4 * ((v1[11] >> 23) & 1) + 16];
  if (v2)
  {
    v8[0] = v1;
    v3 = mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps4(v2, "variable", 8, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, v8);
  }

  else
  {
    v6 = "requires attribute 'variable'";
    v7 = 259;
    mlir::Operation::emitOpError(v1, &v6, v8);
    v3 = (v9 & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v8);
  }

  v4 = *MEMORY[0x277D85DE8];
  return v3;
}

BOOL mlir::ODIE::DebugInfo::ValueOp::parse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v27 = *MEMORY[0x277D85DE8];
  memset(v20, 0, sizeof(v20));
  v21 = 0;
  v19[0] = v20;
  v19[1] = 1;
  v17[1] = 1;
  v18 = 0;
  if (((*(*a1 + 280))(a1, a2, a3, a4, a5, a6, a7, a8, &v18) & 1) == 0)
  {
    goto LABEL_14;
  }

  v10 = (*(*a1 + 40))(a1);
  if (((*(*a1 + 704))(a1, v20, 1) & 1) == 0)
  {
    goto LABEL_14;
  }

  if (((*(*a1 + 104))(a1) & 1) == 0)
  {
    goto LABEL_14;
  }

  v25[0] = 0;
  if (((*(*a1 + 536))(a1, v25) & 1) == 0)
  {
    goto LABEL_14;
  }

  v18 = v25[0];
  if (((*(*a1 + 296))(a1) & 1) == 0)
  {
    goto LABEL_14;
  }

  v11 = (*(*a1 + 40))(a1);
  v24 = 0;
  v25[0] = a1;
  if (((*(*a1 + 448))(a1, &v24, 0, _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo17LocalVariableAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_, v25) & 1) == 0)
  {
    goto LABEL_14;
  }

  v12 = v24;
  if (*(*v24 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::LocalVariableAttr,void>::id)
  {
    *mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>(a2) = v12;
  }

  else
  {
    v22[0] = "invalid kind of attribute specified";
    v23 = 259;
    (*(*a1 + 24))(v25, a1, v11, v22);
    v13 = v26;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v25);
    if (v13)
    {
LABEL_14:
      result = 0;
      goto LABEL_15;
    }
  }

  v22[0] = (*(*a1 + 40))(a1);
  if (((*(*a1 + 488))(a1, a2 + 112) & 1) == 0)
  {
    goto LABEL_14;
  }

  v14 = *(a2 + 8);
  v25[0] = a1;
  v25[1] = v22;
  v25[2] = a2;
  if (!mlir::ODIE::DebugInfo::ValueOp::verifyInherentAttrs(v14, a2 + 112, llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::ValueOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, v25))
  {
    goto LABEL_14;
  }

  result = mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v10, a2 + 16);
LABEL_15:
  v16 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::ODIE::DebugInfo::ValueOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v22[4] = *MEMORY[0x277D85DE8];
  v4 = (*(*a2 + 16))(a2);
  v5 = *(v4 + 4);
  if (*(v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "(", 1uLL);
  }

  else
  {
    *v5 = 40;
    ++*(v4 + 4);
  }

  (*(*a2 + 160))(a2, *(*(*this + 9) + 24));
  v6 = (*(*a2 + 16))(a2);
  v7 = *(v6 + 4);
  if (v7 >= *(v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }

  else
  {
    *(v6 + 4) = v7 + 1;
    *v7 = 32;
  }

  v8 = (*(*a2 + 16))(a2);
  v9 = *(v8 + 4);
  if (*(v8 + 3) == v9)
  {
    llvm::raw_ostream::write(v8, ":", 1uLL);
  }

  else
  {
    *v9 = 58;
    ++*(v8 + 4);
  }

  v10 = (*(*a2 + 16))(a2);
  v11 = *(v10 + 4);
  if (v11 >= *(v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }

  else
  {
    *(v10 + 4) = v11 + 1;
    *v11 = 32;
  }

  (*(*a2 + 32))(a2, *(*(*(*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v12 = (*(*a2 + 16))(a2);
  v13 = *(v12 + 4);
  if (*(v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ")", 1uLL);
  }

  else
  {
    *v13 = 41;
    ++*(v12 + 4);
  }

  v14 = (*(*a2 + 16))(a2);
  v15 = *(v14 + 4);
  if (v15 >= *(v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }

  else
  {
    *(v14 + 4) = v15 + 1;
    *v15 = 32;
  }

  v20 = *(*this + 2 * ((*(*this + 11) >> 23) & 1) + 8);
  if (((*(*a2 + 56))(a2) & 1) == 0)
  {
    v16 = (*(*a2 + 16))(a2);
    v17 = (*(*v16 + 80))(v16) + v16[4] - v16[2];
    mlir::ODIE::DebugInfo::LocalVariableAttr::print(&v20, a2);
    if (v17 == (*(*v16 + 80))(v16) + v16[4] - v16[2])
    {
      (*(*a2 + 40))(a2, v20);
    }
  }

  v20 = v22;
  v21 = 0x200000000;
  llvm::SmallVectorTemplateBase<llvm::StringRef,true>::push_back(&v20, "variable", 8);
  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  (*(*a2 + 192))(a2, *(AttrDictionary + 8), *(AttrDictionary + 16), v20, v21);
  if (v20 != v22)
  {
    free(v20);
  }

  v19 = *MEMORY[0x277D85DE8];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(mlir::Operation **a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(mlir::Operation **a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(mlir::Operation **a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::__mlir_ods_local_attr_constraint_DebugInfoOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(mlir::Operation **a1@<X0>, uint64_t a2@<X8>)
{
  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, v3, a2);
}

uint64_t llvm::SmallVectorTemplateBase<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,true>::growAndEmplaceBack<mlir::MemoryEffects::Write *,mlir::SideEffects::DefaultResource *>(uint64_t a1, void *a2, uint64_t *a3)
{
  v12[2] = *MEMORY[0x277D85DE8];
  v4 = *a3;
  v11[0] = *a2;
  v11[1] = v4;
  v11[2] = 0;
  v12[0] = 0;
  *(v12 + 5) = 0;
  v5 = llvm::SmallVectorTemplateCommon<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,void>::reserveForParamAndGetAddressImpl<llvm::SmallVectorTemplateBase<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,true>>(a1, v11, 1);
  v6 = *a1 + 40 * *(a1 + 8);
  v7 = *(v5 + 32);
  v8 = *(v5 + 16);
  *v6 = *v5;
  *(v6 + 16) = v8;
  *(v6 + 32) = v7;
  LODWORD(v6) = *(a1 + 8) + 1;
  *(a1 + 8) = v6;
  v9 = *MEMORY[0x277D85DE8];
  return *a1 + 40 * v6 - 40;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    JUMPOUT(0x25F891040);
  }
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>()
{
  if ((atomic_load_explicit(&qword_27FC26E88, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26E88))
  {
    qword_27FC26E78 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>();
    unk_27FC26E80 = v1;
    __cxa_guard_release(&qword_27FC26E88);
  }

  return qword_27FC26E78;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::detail::RecordOpGenericAdaptorBase::Properties]";
  v6 = 131;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::RecordOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v11[25] = *MEMORY[0x277D85DE8];
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v10);
  if (v10)
  {
    mlir::Diagnostic::operator<<<2ul>(v11, "'");
    if (v10)
    {
      v5 = *(*(*(*(a1 + 16) + 8) + 8) + 16);
      v6 = *(*(*(*(a1 + 16) + 8) + 8) + 24);
      v9 = 261;
      v8[0] = v5;
      v8[1] = v6;
      mlir::Diagnostic::operator<<(v11, v8);
      if (v10)
      {
        mlir::Diagnostic::operator<<<6ul>(v11, "' op ");
      }
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v10);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v10);
  v7 = *MEMORY[0x277D85DE8];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    JUMPOUT(0x25F891040);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>()
{
  if ((atomic_load_explicit(&qword_27FC26EB0, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26EB0))
  {
    qword_27FC26EA0 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>();
    *algn_27FC26EA8 = v1;
    __cxa_guard_release(&qword_27FC26EB0);
  }

  return qword_27FC26EA0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::detail::SubprogramOpGenericAdaptorBase::Properties]";
  v6 = 135;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::SubprogramAttr>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::SubprogramAttr]";
  v6 = 99;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo14SubprogramAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_(mlir::AsmParser **a1, uint64_t *a2, uint64_t a3)
{
  v4 = mlir::ODIE::DebugInfo::SubprogramAttr::parse(*a1, a3);
  *a2 = v4;
  return v4 != 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::SubprogramOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v11[25] = *MEMORY[0x277D85DE8];
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v10);
  if (v10)
  {
    mlir::Diagnostic::operator<<<2ul>(v11, "'");
    if (v10)
    {
      v5 = *(*(*(*(a1 + 16) + 8) + 8) + 16);
      v6 = *(*(*(*(a1 + 16) + 8) + 8) + 24);
      v9 = 261;
      v8[0] = v5;
      v8[1] = v6;
      mlir::Diagnostic::operator<<(v11, v8);
      if (v10)
      {
        mlir::Diagnostic::operator<<<6ul>(v11, "' op ");
      }
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v10);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v10);
  v7 = *MEMORY[0x277D85DE8];
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    JUMPOUT(0x25F891040);
  }
}

uint64_t llvm::getTypeName<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>()
{
  if ((atomic_load_explicit(&qword_27FC26EF0, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire(&qword_27FC26EF0))
  {
    qword_27FC26EE0 = llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>();
    *algn_27FC26EE8 = v1;
    __cxa_guard_release(&qword_27FC26EF0);
  }

  return qword_27FC26EE0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::detail::ValueOpGenericAdaptorBase::Properties]";
  v6 = 130;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::DebugInfo::LocalVariableAttr>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::DebugInfo::LocalVariableAttr]";
  v6 = 102;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

BOOL _ZN4llvm12function_refIFNS_11ParseResultERN4mlir9AttributeENS2_4TypeEEE11callback_fnIZNS2_9AsmParser32parseCustomAttributeWithFallbackINS2_4ODIE9DebugInfo17LocalVariableAttrEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES1_E4typeERSG_S5_EUlS4_S5_E_EES1_lS4_S5_(mlir::AsmParser **a1, uint64_t *a2, uint64_t a3)
{
  v4 = mlir::ODIE::DebugInfo::LocalVariableAttr::parse(*a1, a3);
  *a2 = v4;
  return v4 != 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::ODIE::DebugInfo::ValueOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v11[25] = *MEMORY[0x277D85DE8];
  v4 = **(a1 + 8);
  (*(**a1 + 24))(&v10);
  if (v10)
  {
    mlir::Diagnostic::operator<<<2ul>(v11, "'");
    if (v10)
    {
      v5 = *(*(*(*(a1 + 16) + 8) + 8) + 16);
      v6 = *(*(*(*(a1 + 16) + 8) + 8) + 24);
      v9 = 261;
      v8[0] = v5;
      v8[1] = v6;
      mlir::Diagnostic::operator<<(v11, v8);
      if (v10)
      {
        mlir::Diagnostic::operator<<<6ul>(v11, "' op ");
      }
    }
  }

  mlir::InFlightDiagnostic::InFlightDiagnostic(a2, &v10);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v10);
  v7 = *MEMORY[0x277D85DE8];
}

void mlir::ODIE::DebugInfo::DebugInfoDialect::~DebugInfoDialect(mlir::ODIE::DebugInfo::DebugInfoDialect *this)
{
  mlir::Dialect::~Dialect(this);

  JUMPOUT(0x25F891040);
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::Model(void *a1, uint64_t a2)
{
  v7[6] = *MEMORY[0x277D85DE8];
  v6[0] = v7;
  v6[1] = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>>(v6);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>>(v6);
  mlir::OperationName::Impl::Impl(a1, "debuginfo.record", 0x10, a2, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::RecordOp,void>::id, v6);
  mlir::detail::InterfaceMap::~InterfaceMap(v6);
  *a1 = &unk_286EAA668;
  v4 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));

  JUMPOUT(0x25F891040);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::foldHook()
{
  v3[4] = *MEMORY[0x277D85DE8];
  v3[3] = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks + 2;
  v0 = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks[0]();
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::~UniqueFunctionBase(v3);
  v1 = *MEMORY[0x277D85DE8];
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[3] = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks + 2;
  v2 = (llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  v7[4] = *MEMORY[0x277D85DE8];
  v7[3] = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2;
  (llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks[0])(v7, a2, a3, a4, a5);
  result = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::~UniqueFunctionBase(v7);
  v6 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::RecordOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  if (a4)
  {
    v4 = *a4;
  }

  else
  {
    v4 = 0;
  }

  *a3 = v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>::writeProperties;
  v3 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();

  mlir::detail::InterfaceMap::insert(a1, v3, v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::RecordOp>::getEffects;
  v3 = mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID();

  mlir::detail::InterfaceMap::insert(a1, v3, v2);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  v9[7] = *MEMORY[0x277D85DE8];
  v9[0] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID();
  v9[1] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID();
  v9[2] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID();
  v9[3] = mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID();
  v9[4] = mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID();
  v9[5] = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID();
  v3 = mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID();
  v4 = 0;
  v9[6] = v3;
  do
  {
    v5 = v9[v4];
    if (v5 == a2)
    {
      break;
    }
  }

  while (v4++ != 6);
  result = v5 == a2;
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::ODIE::DebugInfo::RecordOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::ODIE::DebugInfo::RecordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(unsigned int *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyZeroResults(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyOneOperand(a1, v5))
  {
    v8 = a1;
    return mlir::ODIE::DebugInfo::RecordOp::verifyInvariantsImpl(&v8);
  }

  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::Model(void *a1, uint64_t a2)
{
  v7[6] = *MEMORY[0x277D85DE8];
  v6[0] = v7;
  v6[1] = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>>(v6);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>>(v6);
  mlir::OperationName::Impl::Impl(a1, "debuginfo.subprogram", 0x14, a2, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::SubprogramOp,void>::id, v6);
  mlir::detail::InterfaceMap::~InterfaceMap(v6);
  *a1 = &unk_286EAA730;
  v4 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));

  JUMPOUT(0x25F891040);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::foldHook()
{
  v3[4] = *MEMORY[0x277D85DE8];
  v3[3] = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks + 2;
  v0 = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks[0]();
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::~UniqueFunctionBase(v3);
  v1 = *MEMORY[0x277D85DE8];
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[3] = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks + 2;
  v2 = (llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  v7[4] = *MEMORY[0x277D85DE8];
  v7[3] = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2;
  (llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks[0])(v7, a2, a3, a4, a5);
  result = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::~UniqueFunctionBase(v7);
  v6 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::verifyInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::verifyRegionInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *a3 = *a4;
  }

  else
  {
    *a3 = 0;
    *(a3 + 8) = 0;
  }
}

__n128 mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::SubprogramOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result = *a3;
  *a2 = *a3;
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::writeProperties;
  v3 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();

  mlir::detail::InterfaceMap::insert(a1, v3, v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = a2 + 16 * ((*(a2 + 44) >> 23) & 1);
  (*(*a3 + 16))(a3, *(v4 + 64));
  v5 = *(v4 + 72);
  v6 = *(*a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(0x80uLL, 0x800408754F03FuLL);
  *v2 = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::getNameAttr;
  v2[1] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::setName;
  v2[2] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::getVisibility;
  v2[3] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::isNested;
  v2[4] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::isPrivate;
  v2[5] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::isPublic;
  v2[6] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::setVisibility;
  v2[7] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::setNested;
  v2[8] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::setPrivate;
  v2[9] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::setPublic;
  v2[10] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::getSymbolUses;
  v2[11] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::symbolKnownUseEmpty;
  v2[12] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::replaceAllSymbolUses;
  v2[13] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::isOptionalSymbol;
  v2[14] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::canDiscardOnUseEmpty;
  v2[15] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::isDeclaration;
  v3 = mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID();

  mlir::detail::InterfaceMap::insert(a1, v3, v2);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::SubprogramOp>::getNameAttr(uint64_t a1, uint64_t a2)
{
  result = mlir::Operation::getAttr(a2, "sym_name", 8uLL);
  if (result)
  {
    if (*(*result + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    {
      return 0;
    }
  }

  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  v9[7] = *MEMORY[0x277D85DE8];
  v9[0] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID();
  v9[1] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID();
  v9[2] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID();
  v9[3] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID();
  v9[4] = mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID();
  v9[5] = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID();
  v3 = mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID();
  v4 = 0;
  v9[6] = v3;
  do
  {
    v5 = v9[v4];
    if (v5 == a2)
    {
      break;
    }
  }

  while (v4++ != 6);
  result = v5 == a2;
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::ODIE::DebugInfo::SubprogramOp::print(&v7, a3);
}

uint64_t mlir::Op<mlir::ODIE::DebugInfo::SubprogramOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::SymbolOpInterface::Trait>::verifyInvariants(mlir::Operation *a1, mlir::Operation *a2)
{
  v18 = *MEMORY[0x277D85DE8];
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyZeroResults(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyZeroOperands(a1, v5) && (v16[0] = a1, mlir::ODIE::DebugInfo::SubprogramOp::verifyInvariantsImpl(v16)) && (mlir::detail::verifySymbol(a1, v6) & 1) != 0)
  {
    v7 = *(a1 + 2);
    if (v7 && (v8 = *(v7 + 24) & 0xFFFFFFFFFFFFFFF8) != 0 && (v9 = *(v8 + 16)) != 0 && (v10 = mlir::detail::TypeIDResolver<mlir::OpTrait::SymbolTable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SymbolTable>(void)::Empty>,void>::resolveTypeID(), ((*(**(v9 + 48) + 32))(*(v9 + 48), v10) & 1) == 0) && *(*(v9 + 48) + 16) != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v14 = "symbol's parent must have the SymbolTable trait";
      v15 = 259;
      mlir::Operation::emitOpError(a1, &v14, v16);
      v11 = v17 ^ 1;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v16);
    }

    else
    {
      v11 = 1;
    }
  }

  else
  {
    v11 = 0;
  }

  v12 = *MEMORY[0x277D85DE8];
  return v11 & 1;
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::Model(void *a1, uint64_t a2)
{
  v7[6] = *MEMORY[0x277D85DE8];
  v6[0] = v7;
  v6[1] = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::ValueOp>>(v6);
  mlir::OperationName::Impl::Impl(a1, "debuginfo.value", 0xF, a2, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::ValueOp,void>::id, v6);
  mlir::detail::InterfaceMap::~InterfaceMap(v6);
  *a1 = &unk_286EAA7F8;
  v4 = *MEMORY[0x277D85DE8];
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::~Model(uint64_t a1)
{
  *a1 = &unk_286E788F8;
  mlir::detail::InterfaceMap::~InterfaceMap((a1 + 32));

  JUMPOUT(0x25F891040);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::foldHook()
{
  v3[4] = *MEMORY[0x277D85DE8];
  v3[3] = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks + 2;
  v0 = llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks[0]();
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::~UniqueFunctionBase(v3);
  v1 = *MEMORY[0x277D85DE8];
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[3] = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks + 2;
  v2 = (llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void *mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  v7[4] = *MEMORY[0x277D85DE8];
  v7[3] = &llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2;
  llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks(v7, a2, a3, a4, a5);
  result = llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::~UniqueFunctionBase(v7);
  v6 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x277D85DE8];
  v5[0] = mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyRegionInvariants;
  v5[3] = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks + 2);
  v2 = (llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::CallbacksHolder<llvm::LogicalResult (*)(mlir::Operation *),llvm::LogicalResult (* const)(mlir::Operation *),void>::Callbacks[0])(v5, a2);
  llvm::detail::UniqueFunctionBase<llvm::LogicalResult,mlir::Operation *>::~UniqueFunctionBase(v5);
  v3 = *MEMORY[0x277D85DE8];
  return v2;
}

void mlir::RegisteredOperationName::Model<mlir::ODIE::DebugInfo::ValueOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  if (a4)
  {
    v4 = *a4;
  }

  else
  {
    v4 = 0;
  }

  *a3 = v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::ValueOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::ValueOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::ODIE::DebugInfo::ValueOp>::writeProperties;
  v3 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID();

  mlir::detail::InterfaceMap::insert(a1, v3, v2);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  v9[6] = *MEMORY[0x277D85DE8];
  v9[0] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID();
  v9[1] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID();
  v9[2] = mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID();
  v9[3] = mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID();
  v9[4] = mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID();
  v3 = mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID();
  v4 = 0;
  v9[5] = v3;
  do
  {
    v5 = v9[v4];
    if (v5 == a2)
    {
      break;
    }
  }

  while (v4++ != 5);
  result = v5 == a2;
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, llvm::formatv_object_base *a4, llvm::formatv_object_base *a5)
{
  mlir::OpState::printOpName(a2, a3, a4, a5);
  v7 = a2;
  mlir::ODIE::DebugInfo::ValueOp::print(&v7, a3);
}

uint64_t mlir::Op<mlir::ODIE::DebugInfo::ValueOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants(unsigned int *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2) && mlir::OpTrait::impl::verifyZeroResults(a1, v3) && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4) && mlir::OpTrait::impl::verifyOneOperand(a1, v5) && (v8 = a1, mlir::ODIE::DebugInfo::ValueOp::verifyInvariantsImpl(&v8)))
  {
    v8 = a1;
    v6 = mlir::ODIE::DebugInfo::ValueOp::verify(&v8);
  }

  else
  {
    v6 = 0;
  }

  return v6 & 1;
}

uint64_t mlir::ODIE::DebugInfo::CompositeType::get(void *a1, int a2, llvm::hashing::detail::hash_state *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10)
{
  v13 = a5;
  v14 = a9;
  *v59 = *MEMORY[0x277D85DE8];
  v35 = *a1;
  v36[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id;
  v36[1] = &v37;
  v37 = a1;
  v47[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail20CompositeTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_13CompositeTypeEJjNS_9StringRefENS1_13SymbolRefAttrEyyyNS_8ArrayRefINS3_6DITypeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_;
  v47[1] = v36;
  v38 = a2;
  v39 = a3;
  v40 = a4;
  v41 = a5;
  v42 = a6;
  v43 = a7;
  v44 = a8;
  v45 = a9;
  v46 = a10;
  memset(v56, 0, sizeof(v56));
  *&v54[4] = 0u;
  v55 = 0u;
  v57 = 0xFF51AFD7ED558CCDLL;
  *v53 = a2;
  *&v53[4] = llvm::hashing::detail::hash_combine_range_impl<char const>(a3, a4 + a3, a3, a4);
  *&v53[12] = (v13 >> 4) ^ (v13 >> 9);
  *v54 = a6;
  v48 = 0;
  v15 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long long>(v53, &v48, &v54[8], &v56[8], a7);
  v49 = v48;
  v18 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long long>(v53, &v49, v15, &v56[8], a8);
  v50 = v49;
  if (a10)
  {
    v19 = 0;
    v20 = &a9[2 * a10];
    while (v19 <= 0x38)
    {
      v21 = v19 + 8;
      v22 = *v14;
      v14 += 2;
      *&__src[v19] = (v22 >> 4) ^ (v22 >> 9);
      v19 = v21;
      if (8 * a10 == v21)
      {
        goto LABEL_7;
      }
    }

    v51[0] = xmmword_25D0A0610;
    v51[1] = xmmword_25D0A0620;
    v51[2] = xmmword_25D0A0630;
    v52 = 0xF7ACCA5326449396;
    llvm::hashing::detail::hash_state::mix(v51, __src, v16, v17);
    v24 = 64;
    if (v19 != 8 * a10)
    {
      do
      {
        v25 = 0;
        do
        {
          v26 = *v14;
          v14 += 2;
          v27 = v25 + 8;
          *&__src[v25] = (v26 >> 4) ^ (v26 >> 9);
          if (v14 == v20)
          {
            break;
          }

          v28 = v25 >= 0x31;
          v25 += 8;
        }

        while (!v28);
        std::__rotate[abi:nn200100]<std::_ClassicAlgPolicy,char *,char *>(__src, &__src[v27], v59);
        llvm::hashing::detail::hash_state::mix(v51, __src, v29, v30);
        v24 += v27;
      }

      while (v14 != v20);
    }

    v23 = llvm::hashing::detail::hash_state::finalize(v51, v24);
  }

  else
  {
    v21 = 0;
LABEL_7:
    v23 = llvm::hashing::detail::hash_short(__src, v21, 0xFF51AFD7ED558CCDLL);
  }

  v31 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v53, &v50, v18, &v56[8], v23);
  v32 = llvm::hashing::detail::hash_combine_recursive_helper::combine(v53, v50, v31, &v56[8]);
  *__src = &v38;
  *v53 = &v38;
  *&v53[8] = v47;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v35 + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id, v32, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompositeTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType> &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, __src, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompositeTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType> &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, v53);
  v34 = *MEMORY[0x277D85DE8];
  return result;
}

void mlir::FieldParser<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>>::parse(uint64_t a1, uint64_t a2)
{
  v8[6] = *MEMORY[0x277D85DE8];
  v5[1] = &v6;
  v6 = v8;
  v7 = 0x600000000;
  v5[0] = a2;
  if ((*(*a2 + 392))(a2, 0, llvm::function_ref<llvm::ParseResult ()(void)>::callback_fn<mlir::FieldParser<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>>::parse(mlir::AsmParser &)::{lambda(void)#1}>, v5, 0, 0))
  {
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
    if (v7)
    {
      llvm::SmallVectorImpl<mlir::ODIE::DebugInfo::DIType>::operator=(a1, &v6);
    }

    v3 = 1;
  }

  else
  {
    v3 = 0;
    *a1 = 0;
  }

  *(a1 + 64) = v3;
  if (v6 != v8)
  {
    free(v6);
  }

  v4 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::DebugInfo::DebugInfoDialect::parseType(uint64_t a1, mlir::AsmParser *a2)
{
  v159 = *MEMORY[0x277D85DE8];
  v4 = (*(*a2 + 40))(a2);
  mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::KeywordSwitch(v114, a2, 0);
  v151[0] = "unresolved";
  v151[1] = 10;
  if (v117[2])
  {
    goto LABEL_2;
  }

  v6 = v116;
  if (v116 == 10)
  {
    if (*v115 == 0x766C6F7365726E75 && *(v115 + 8) == 25701)
    {
      (*(*a2 + 32))(a2);
      (*(*a2 + 40))(a2);
      if ((*(*a2 + 152))(a2))
      {
        *&v156 = 0;
        v16 = (*(*a2 + 536))(a2, &v156);
        v17 = *a2;
        if (v16)
        {
          v18 = v156;
          if ((*(v17 + 168))(a2))
          {
            v19 = (*(*a2 + 32))(a2);
            v5 = mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::UnresolvedType,mlir::Type>(*v19, v18);
            goto LABEL_216;
          }
        }

        else
        {
          v66 = (*(v17 + 40))(a2);
          v155 = 259;
          (*(*a2 + 24))(&v156, a2, v66, &v153);
          mlir::InFlightDiagnostic::~InFlightDiagnostic(&v156);
        }
      }

      v5 = 0;
LABEL_216:
      v117[0] = v5 != 0;
      *&v117[1] = 257;
      goto LABEL_3;
    }

    goto LABEL_27;
  }

  if (v116)
  {
LABEL_27:
    v126 = "basic";
    v127 = 5;
    goto LABEL_28;
  }

  (*(*v114[0] + 648))(v114[0], v151, 1);
  v126 = "basic";
  v127 = 5;
  if (v117[2])
  {
    goto LABEL_2;
  }

  v6 = v116;
  if (!v116)
  {
    (*(*v114[0] + 648))(v114[0], &v126, 1);
    v120 = "derived";
    v121 = 7;
    if (v117[2])
    {
      goto LABEL_2;
    }

    v6 = v116;
    if (!v116)
    {
      goto LABEL_19;
    }

    goto LABEL_34;
  }

LABEL_28:
  if (v6 == 5 && *v115 == 1769169250 && *(v115 + 4) == 99)
  {
    (*(*a2 + 32))(a2);
    (*(*a2 + 40))(a2);
    LOBYTE(v134) = 0;
    v137 = 0;
    if ((*(*a2 + 152))(a2))
    {
      v131 = 0;
      v132 = 0;
      if (mlir::AsmParser::parseKeyword(a2, &v131))
      {
        v20 = 0;
        v111 = 0;
        v105 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v108 = 0;
        v24 = 4;
        do
        {
          v26 = v131;
          v25 = v132;
          if (((*(*a2 + 136))(a2) & 1) == 0)
          {
            goto LABEL_91;
          }

          if (v23 & 1 | (v25 != 5))
          {
            v27 = v25 != 10;
            if (!(v20 & 1 | v27))
            {
              if (*v26 == 0x69646F636E457764 && *(v26 + 4) == 26478)
              {
                __p.n128_u32[0] = 0;
                if ((mlir::AsmParser::parseInteger<unsigned int>(a2, &__p) & 1) == 0)
                {
                  v88 = (*(*a2 + 40))(a2);
                  v149 = 259;
                  (*(*a2 + 24))(&v153, a2, v88, &__p);
                  p_p = &v153;
                  goto LABEL_90;
                }

                v105 = __p.n128_u32[0];
                v20 = 1;
                goto LABEL_85;
              }

              v27 = 0;
LABEL_75:
              if ((v22 | v27))
              {
                goto LABEL_246;
              }

              if (*v26 != 0x69426E49657A6973 || *(v26 + 4) != 29556)
              {
                goto LABEL_246;
              }

              __p.n128_u64[0] = 0;
              if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &__p) & 1) == 0)
              {
                v80 = (*(*a2 + 40))(a2);
                v149 = 259;
                (*(*a2 + 24))(v150, a2, v80, &__p);
                p_p = v150;
                goto LABEL_90;
              }

              v108 = __p.n128_u64[0];
              v22 = 1;
              goto LABEL_85;
            }

            if (v21 & 1 | (v25 != 4))
            {
              goto LABEL_75;
            }

            if (*v26 != 1701667182)
            {
              v25 = 4;
              goto LABEL_246;
            }

            mlir::FieldParser<std::string,std::string>::parse(a2, &__p);
            v28 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(&v134, &__p);
            if (v148 == 1 && v147 < 0)
            {
              operator delete(__p.n128_u64[0]);
            }

            if ((v137 & 1) == 0)
            {
              v86 = (*(*a2 + 40))(a2, v28);
              v149 = 259;
              (*(*a2 + 24))(v151, a2, v86, &__p);
              p_p = v151;
              goto LABEL_90;
            }

            v21 = 1;
          }

          else
          {
            if (*v26 != 1632925540 || v26[4] != 103)
            {
              v25 = 5;
LABEL_246:
              v77 = (*(*a2 + 40))(a2);
              v140.n128_u64[0] = "duplicate or unknown struct parameter name: ";
              v143 = 259;
              (*(*a2 + 24))(&__p, a2, v77, &v140);
              if (__p.n128_u64[0])
              {
                v145 = 261;
                v144[0] = v26;
                v144[1] = v25;
                mlir::Diagnostic::operator<<(&__p.n128_i64[1], v144);
              }

              p_p = &__p;
              goto LABEL_90;
            }

            __p.n128_u32[0] = 0;
            if ((mlir::AsmParser::parseInteger<unsigned int>(a2, &__p) & 1) == 0)
            {
              v78 = (*(*a2 + 40))(a2);
              v149 = 259;
              (*(*a2 + 24))(&v156, a2, v78, &__p);
              goto LABEL_89;
            }

            v111 = __p.n128_u32[0];
            v23 = 1;
          }

LABEL_85:
          if (!--v24)
          {
            if (((*(*a2 + 168))(a2, v28) & 1) == 0)
            {
              goto LABEL_91;
            }

            v67 = *(*(*a2 + 32))(a2);
            v68 = SHIBYTE(v136);
            v69 = &v134;
            if (v136 < 0)
            {
              v69 = v134;
            }

            if (v136 < 0)
            {
              v68 = v135;
            }

            *&v156 = v69;
            *(&v156 + 1) = v68;
            v5 = mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::BasicType,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(v67, v111, v105, &v156, v108);
LABEL_92:
            if (v137 == 1 && SHIBYTE(v136) < 0)
            {
              v34 = v134;
              goto LABEL_213;
            }

            goto LABEL_216;
          }

          if (((*(*a2 + 120))(a2, v28) & 1) == 0)
          {
            goto LABEL_91;
          }

          v131 = 0;
          v132 = 0;
        }

        while (mlir::AsmParser::parseKeyword(a2, &v131));
      }

      v32 = (*(*a2 + 40))(a2);
      v153 = "expected a parameter name in struct";
      v155 = 259;
      (*(*a2 + 24))(&v156, a2, v32, &v153);
LABEL_89:
      p_p = &v156;
LABEL_90:
      mlir::InFlightDiagnostic::~InFlightDiagnostic(p_p);
    }

LABEL_91:
    v5 = 0;
    goto LABEL_92;
  }

  v120 = "derived";
  v121 = 7;
  if (!v6)
  {
LABEL_19:
    (*(*v114[0] + 648))(v114[0], &v120, 1);
    v118 = "composite";
    v119 = 9;
    if ((v117[2] & 1) == 0)
    {
      v6 = v116;
      if (!v116)
      {
        goto LABEL_21;
      }

      goto LABEL_40;
    }

LABEL_2:
    v5 = 0;
LABEL_3:
    v6 = 0;
    v7 = 0;
    goto LABEL_4;
  }

LABEL_34:
  if (v6 == 7 && *v115 == 1769104740 && *(v115 + 3) == 1684371049)
  {
    (*(*a2 + 32))(a2);
    (*(*a2 + 40))(a2);
    LOBYTE(v126) = 0;
    v129 = 0;
    if ((*(*a2 + 152))(a2))
    {
      v122 = 0;
      v123 = 0;
      if (mlir::AsmParser::parseKeyword(a2, &v122))
      {
        v35 = 0;
        v109 = 0;
        v112 = 0;
        v36 = 0;
        v103 = 0;
        v106 = 0;
        v37 = 0;
        v97 = 0;
        v99 = 0;
        v101 = 0;
        v38 = 0;
        v39 = 6;
        while (1)
        {
          v40 = v122;
          v41 = v123;
          if (((*(*a2 + 136))(a2) & 1) == 0)
          {
            goto LABEL_148;
          }

          if (v38 & 1 | (v41 != 5))
          {
            if (v36 & 1 | (v41 != 4))
            {
              if (v35 & 1 | (v41 != 10))
              {
                if (v112 & 1 | (v41 != 11))
                {
                  if (v106 & 1 | (v41 != 12))
                  {
                    if (v101 & 1 | (v41 != 8))
                    {
                      goto LABEL_271;
                    }

                    if (*v40 != 0x6570795465736162)
                    {
                      v41 = 8;
                      goto LABEL_271;
                    }

                    v140.n128_u64[0] = 0;
                    if (!mlir::AsmParser::parseType<mlir::ODIE::DebugInfo::DIType>(a2, &v140))
                    {
                      v96 = (*(*a2 + 40))(a2);
                      v143 = 259;
                      (*(*a2 + 24))(v144, a2, v96, &v140);
                      v48 = v144;
                      goto LABEL_147;
                    }

                    v97 = v140.n128_u64[0];
                    v101 = 1;
                  }

                  else
                  {
                    if (*v40 != 0x6E4974657366666FLL || *(v40 + 2) != 1937008962)
                    {
                      v41 = 12;
                      goto LABEL_271;
                    }

                    v140.n128_u64[0] = 0;
                    if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
                    {
                      v94 = (*(*a2 + 40))(a2);
                      v143 = 259;
                      (*(*a2 + 24))(&__p, a2, v94, &v140);
                      v48 = &__p;
                      goto LABEL_147;
                    }

                    v99 = v140.n128_u64[0];
                    v106 = 1;
                  }
                }

                else
                {
                  if (*v40 != 0x426E496E67696C61 || *(v40 + 3) != 0x737469426E496E67)
                  {
                    v41 = 11;
                    goto LABEL_271;
                  }

                  v140.n128_u64[0] = 0;
                  if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
                  {
                    v93 = (*(*a2 + 40))(a2);
                    v143 = 259;
                    (*(*a2 + 24))(v150, a2, v93, &v140);
                    v48 = v150;
                    goto LABEL_147;
                  }

                  v103 = v140.n128_u64[0];
                  v112 = 1;
                }
              }

              else
              {
                if (*v40 != 0x69426E49657A6973 || *(v40 + 4) != 29556)
                {
                  v41 = 10;
                  goto LABEL_271;
                }

                v140.n128_u64[0] = 0;
                if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
                {
                  v89 = (*(*a2 + 40))(a2);
                  v143 = 259;
                  (*(*a2 + 24))(v151, a2, v89, &v140);
                  v48 = v151;
                  goto LABEL_147;
                }

                v109 = v140.n128_u64[0];
                v35 = 1;
              }
            }

            else
            {
              if (*v40 != 1701667182)
              {
                v41 = 4;
                goto LABEL_271;
              }

              mlir::FieldParser<std::string,std::string>::parse(a2, &v140);
              v43 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(&v126, &v140);
              if (v142 == 1 && v141 < 0)
              {
                operator delete(v140.n128_u64[0]);
              }

              if ((v129 & 1) == 0)
              {
                v81 = (*(*a2 + 40))(a2, v43);
                v143 = 259;
                (*(*a2 + 24))(&v153, a2, v81, &v140);
                v48 = &v153;
                goto LABEL_147;
              }

              v36 = 1;
            }
          }

          else
          {
            if (*v40 != 1632925540 || v40[4] != 103)
            {
              v41 = 5;
LABEL_271:
              v95 = (*(*a2 + 40))(a2);
              v131 = "duplicate or unknown struct parameter name: ";
              v133 = 259;
              (*(*a2 + 24))(&v140, a2, v95, &v131);
              if (v140.n128_u64[0])
              {
                v138 = 261;
                v134 = v40;
                v135 = v41;
                mlir::Diagnostic::operator<<(&v140.n128_i64[1], &v134);
              }

              v48 = &v140;
              goto LABEL_147;
            }

            v140.n128_u32[0] = 0;
            if ((mlir::AsmParser::parseInteger<unsigned int>(a2, &v140) & 1) == 0)
            {
              v79 = (*(*a2 + 40))(a2);
              v143 = 259;
              (*(*a2 + 24))(&v156, a2, v79, &v140);
              goto LABEL_146;
            }

            v37 = v140.n128_u32[0];
            v38 = 1;
          }

          if (!--v39)
          {
            break;
          }

          if (((*(*a2 + 120))(a2) & 1) == 0)
          {
            goto LABEL_148;
          }

          v122 = 0;
          v123 = 0;
          if (!mlir::AsmParser::parseKeyword(a2, &v122))
          {
            goto LABEL_145;
          }
        }

        if (((*(*a2 + 168))(a2) & 1) == 0)
        {
          goto LABEL_148;
        }

        v70 = *(*(*a2 + 32))(a2);
        v71 = v128;
        v72 = &v126;
        if (v128 < 0)
        {
          v72 = v126;
        }

        if (v128 < 0)
        {
          v71 = v127;
        }

        *&v156 = v72;
        *(&v156 + 1) = v71;
        v5 = mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::DerivedType,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(v70, v37, &v156, v109, v103, v99, v97);
        goto LABEL_149;
      }

LABEL_145:
      v47 = (*(*a2 + 40))(a2);
      v153 = "expected a parameter name in struct";
      v155 = 259;
      (*(*a2 + 24))(&v156, a2, v47, &v153);
LABEL_146:
      v48 = &v156;
LABEL_147:
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v48);
    }

LABEL_148:
    v5 = 0;
LABEL_149:
    if (v129 != 1 || (v128 & 0x80000000) == 0)
    {
      goto LABEL_216;
    }

    v34 = v126;
    goto LABEL_213;
  }

  v118 = "composite";
  v119 = 9;
  if (v6)
  {
LABEL_40:
    if (v6 != 9)
    {
      goto LABEL_45;
    }

    if (*v115 != 0x7469736F706D6F63 || *(v115 + 8) != 101)
    {
      goto LABEL_45;
    }

    (*(*a2 + 32))(a2);
    (*(*a2 + 40))(a2);
    LOBYTE(v122) = 0;
    v125 = 0;
    LOBYTE(v134) = 0;
    v139 = 0;
    if (((*(*a2 + 152))(a2) & 1) == 0)
    {
      goto LABEL_206;
    }

    v120 = 0;
    v121 = 0;
    if (mlir::AsmParser::parseKeyword(a2, &v120))
    {
      v49 = 0;
      v98 = 0;
      v100 = 0;
      v50 = 0;
      v113 = 0;
      v51 = 0;
      v102 = 0;
      v104 = 0;
      v107 = 0;
      v110 = 0;
      v52 = 0;
      v53 = 6;
      while (1)
      {
        v55 = v120;
        v54 = v121;
        if (((*(*a2 + 136))(a2) & 1) == 0)
        {
          goto LABEL_206;
        }

        if (!(v52 & 1 | (v54 != 5)))
        {
          break;
        }

        v56 = v54 != 4;
        if (v113 & 1 | v56)
        {
          goto LABEL_165;
        }

        if (*v55 == 1701667182)
        {
          mlir::FieldParser<std::string,std::string>::parse(a2, &v140);
          v62 = std::__optional_storage_base<std::string,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<std::string,false>>(&v122, &v140);
          if (v142 == 1 && v141 < 0)
          {
            operator delete(v140.n128_u64[0]);
          }

          if ((v125 & 1) == 0)
          {
            v92 = (*(*a2 + 40))(a2, v62);
            v143 = 259;
            (*(*a2 + 24))(&v153, a2, v92, &v140);
            v65 = &v153;
            goto LABEL_205;
          }

          v113 = 1;
          goto LABEL_199;
        }

        v56 = 0;
LABEL_170:
        if (((v50 | v56) & 1) == 0 && *v55 == 1701734764)
        {
          v140.n128_u64[0] = 0;
          if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
          {
            v90 = (*(*a2 + 40))(a2);
            v143 = 259;
            (*(*a2 + 24))(v150, a2, v90, &v140);
            v65 = v150;
            goto LABEL_205;
          }

          v100 = v140.n128_u64[0];
          v50 = 1;
        }

        else if (v51 & 1 | (v54 != 10))
        {
          if (v110 & 1 | (v54 != 11))
          {
            v83 = v54;
            goto LABEL_256;
          }

          if (*v55 != 0x426E496E67696C61 || *(v55 + 3) != 0x737469426E496E67)
          {
            v83 = 11;
LABEL_256:
            v84 = (*(*a2 + 40))(a2);
            v126 = "duplicate or unknown struct parameter name: ";
            v130 = 259;
            (*(*a2 + 24))(&v140, a2, v84, &v126);
            if (v140.n128_u64[0])
            {
              v133 = 261;
              v131 = v55;
              v132 = v83;
              mlir::Diagnostic::operator<<(&v140.n128_i64[1], &v131);
            }

            v65 = &v140;
            goto LABEL_205;
          }

          v140.n128_u64[0] = 0;
          if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
          {
            v85 = (*(*a2 + 40))(a2);
            v143 = 259;
            (*(*a2 + 24))(v144, a2, v85, &v140);
            v65 = v144;
            goto LABEL_205;
          }

          v104 = v140.n128_u64[0];
          v110 = 1;
        }

        else
        {
          if (*v55 != 0x69426E49657A6973 || *(v55 + 4) != 29556)
          {
            v83 = 10;
            goto LABEL_256;
          }

          v140.n128_u64[0] = 0;
          if ((mlir::AsmParser::parseInteger<unsigned long long>(a2, &v140) & 1) == 0)
          {
            v82 = (*(*a2 + 40))(a2);
            v143 = 259;
            (*(*a2 + 24))(&__p, a2, v82, &v140);
            v65 = &__p;
            goto LABEL_205;
          }

          v107 = v140.n128_u64[0];
          v51 = 1;
        }

LABEL_199:
        if (!--v53)
        {
          if ((*(*a2 + 120))(a2))
          {
            v157[8] = 257;
            if ((*(*a2 + 400))(a2, "elements", 8, &v156) & 1) != 0 && ((*(*a2 + 136))(a2) & 1) != 0 && ((*(*a2 + 312))(a2))
            {
              mlir::FieldParser<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>>::parse(&v156, a2);
              std::__optional_storage_base<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,false>>(&v134, &v156);
              if (v158 == 1 && v156 != v157)
              {
                free(v156);
              }

              v73 = *a2;
              if ((v139 & 1) == 0)
              {
                v63 = (*(v73 + 40))(a2);
                goto LABEL_203;
              }

              if ((*(v73 + 328))(a2) & 1) != 0 && ((*(*a2 + 168))(a2))
              {
                v74 = *(*(*a2 + 32))(a2);
                if (v124 >= 0)
                {
                  v75 = &v122;
                }

                else
                {
                  v75 = v122;
                }

                if (v124 >= 0)
                {
                  v76 = v124;
                }

                else
                {
                  v76 = v123;
                }

                v5 = mlir::ODIE::DebugInfo::CompositeType::get(v74, v102, v75, v76, v98, v100, v107, v104, v134, v135);
                goto LABEL_207;
              }
            }
          }

          goto LABEL_206;
        }

        if (((*(*a2 + 120))(a2) & 1) == 0)
        {
          goto LABEL_206;
        }

        v120 = 0;
        v121 = 0;
        if (!mlir::AsmParser::parseKeyword(a2, &v120))
        {
          goto LABEL_202;
        }
      }

      if (*v55 == 1632925540 && v55[4] == 103)
      {
        v140.n128_u32[0] = 0;
        if ((mlir::AsmParser::parseInteger<unsigned int>(a2, &v140) & 1) == 0)
        {
          v87 = (*(*a2 + 40))(a2);
          v143 = 259;
          (*(*a2 + 24))(&v156, a2, v87, &v140);
          goto LABEL_204;
        }

        v102 = v140.n128_u32[0];
        v52 = 1;
        goto LABEL_199;
      }

      v56 = 1;
LABEL_165:
      if (!(v49 & 1 | (v54 != 5)) && *v55 == 1886348147 && v55[4] == 101)
      {
        v98 = mlir::FieldParser<mlir::SymbolRefAttr,mlir::SymbolRefAttr>::parse(a2);
        if ((v61 & 1) == 0)
        {
          v91 = (*(*a2 + 40))(a2);
          v143 = 259;
          (*(*a2 + 24))(v151, a2, v91, &v140);
          v65 = v151;
          goto LABEL_205;
        }

        v49 = 1;
        goto LABEL_199;
      }

      goto LABEL_170;
    }

LABEL_202:
    v63 = (*(*a2 + 40))(a2);
    v64 = "expected a parameter name in struct";
LABEL_203:
    v153 = v64;
    v155 = 259;
    (*(*a2 + 24))(&v156, a2, v63, &v153);
LABEL_204:
    v65 = &v156;
LABEL_205:
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v65);
LABEL_206:
    v5 = 0;
LABEL_207:
    if (v139 == 1 && v134 != &v136)
    {
      free(v134);
    }

    if (v125 != 1 || (v124 & 0x80000000) == 0)
    {
      goto LABEL_216;
    }

    v34 = v122;
LABEL_213:
    operator delete(v34);
    goto LABEL_216;
  }

LABEL_21:
  (*(*v114[0] + 648))(v114[0], &v118, 1);
  if (v117[2])
  {
    goto LABEL_2;
  }

  v6 = v116;
LABEL_45:
  v5 = 0;
  v7 = v115;
  *v117 = 0;
  v117[2] = 1;
LABEL_4:
  if ((mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(v114) & 0x100) == 0)
  {
    v152 = 257;
    (*(*a2 + 24))(&v156, a2, v4, v151);
    if (v156)
    {
      if (v156)
      {
        v155 = 261;
        v153 = v7;
        v154 = v6;
        mlir::Diagnostic::operator<<(&v156 + 8, &v153);
        if (v156)
        {
          if (v156)
          {
            v8 = *(a1 + 8);
            v9 = *(a1 + 16);
            v155 = 261;
            v153 = v8;
            v154 = v9;
            mlir::Diagnostic::operator<<(&v156 + 8, &v153);
            if (v156)
            {
            }
          }
        }
      }
    }

    mlir::InFlightDiagnostic::~InFlightDiagnostic(&v156);
    v5 = 0;
  }

  v10 = *MEMORY[0x277D85DE8];
  return v5;
}

void mlir::ODIE::DebugInfo::DebugInfoDialect::printType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*a2 + 136);
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id)
  {
    v8 = (*(*a3 + 16))(a3);
    v9 = *(v8 + 4);
    if ((*(v8 + 3) - v9) > 9)
    {
      *(v9 + 8) = 25701;
      *v9 = *"unresolved";
      *(v8 + 4) += 10;
    }

    else
    {
      llvm::raw_ostream::write(v8, "unresolved", 0xAuLL);
    }

    v12 = (*(*a3 + 16))(a3);
    v13 = *(v12 + 4);
    if (*(v12 + 3) == v13)
    {
      llvm::raw_ostream::write(v12, "<", 1uLL);
    }

    else
    {
      *v13 = 60;
      ++*(v12 + 4);
    }

    v16 = *(a2 + 8);
    goto LABEL_82;
  }

  if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id)
  {
    v10 = (*(*a3 + 16))(a3);
    v11 = *(v10 + 4);
    if ((*(v10 + 3) - v11) > 4)
    {
      *(v11 + 4) = 99;
      *v11 = 1769169250;
      *(v10 + 4) += 5;
    }

    else
    {
      llvm::raw_ostream::write(v10, "basic", 5uLL);
    }

    v17 = (*(*a3 + 16))(a3);
    v18 = *(v17 + 4);
    if (*(v17 + 3) == v18)
    {
      llvm::raw_ostream::write(v17, "<", 1uLL);
    }

    else
    {
      *v18 = 60;
      ++*(v17 + 4);
    }

    v19 = (*(*a3 + 16))(a3);
    v20 = *(v19 + 4);
    if (*(v19 + 3) - v20 > 7uLL)
    {
      *v20 = 0x203D206761547764;
      *(v19 + 4) += 8;
    }

    else
    {
      llvm::raw_ostream::write(v19, "dwTag = ", 8uLL);
    }

    v21 = *(a2 + 8);
    v22 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v22, v21, 0, 0, 0);
    v23 = (*(*a3 + 16))(a3);
    v24 = *(v23 + 4);
    if (*(v23 + 3) - v24 > 1uLL)
    {
      *v24 = 8236;
      *(v23 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v23, ", ", 2uLL);
    }

    v25 = (*(*a3 + 16))(a3);
    v26 = *(v25 + 4);
    if (*(v25 + 3) - v26 > 0xCuLL)
    {
      qmemcpy(v26, "dwEncoding = ", 13);
      *(v25 + 4) += 13;
    }

    else
    {
      llvm::raw_ostream::write(v25, "dwEncoding = ", 0xDuLL);
    }

    v27 = *(a2 + 12);
    v28 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v28, v27, 0, 0, 0);
    v29 = (*(*a3 + 16))(a3);
    v30 = *(v29 + 4);
    if (*(v29 + 3) - v30 > 1uLL)
    {
      *v30 = 8236;
      *(v29 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v29, ", ", 2uLL);
    }

    v31 = (*(*a3 + 16))(a3);
    v32 = *(v31 + 4);
    if (*(v31 + 3) - v32 > 6uLL)
    {
      *(v32 + 3) = 540876901;
      *v32 = 1701667182;
      *(v31 + 4) += 7;
    }

    else
    {
      llvm::raw_ostream::write(v31, "name = ", 7uLL);
    }

    (*(*a3 + 80))(a3, *(a2 + 16), *(a2 + 24));
    v33 = (*(*a3 + 16))(a3);
    v34 = *(v33 + 4);
    if (*(v33 + 3) - v34 > 1uLL)
    {
      *v34 = 8236;
      *(v33 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v33, ", ", 2uLL);
    }

    v35 = (*(*a3 + 16))(a3);
    v36 = *(v35 + 4);
    if (*(v35 + 3) - v36 > 0xCuLL)
    {
      qmemcpy(v36, "sizeInBits = ", 13);
      *(v35 + 4) += 13;
    }

    else
    {
      llvm::raw_ostream::write(v35, "sizeInBits = ", 0xDuLL);
    }

    v37 = *(a2 + 32);
    v38 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v38, v37, 0, 0, 0);
    goto LABEL_83;
  }

  if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id)
  {
    v14 = (*(*a3 + 16))(a3);
    v15 = *(v14 + 4);
    if (*(v14 + 3) - v15 > 6uLL)
    {
      *(v15 + 3) = 1684371049;
      *v15 = 1769104740;
      *(v14 + 4) += 7;
    }

    else
    {
      llvm::raw_ostream::write(v14, "derived", 7uLL);
    }

    v39 = (*(*a3 + 16))(a3);
    v40 = *(v39 + 4);
    if (*(v39 + 3) == v40)
    {
      llvm::raw_ostream::write(v39, "<", 1uLL);
    }

    else
    {
      *v40 = 60;
      ++*(v39 + 4);
    }

    v41 = (*(*a3 + 16))(a3);
    v42 = *(v41 + 4);
    if (*(v41 + 3) - v42 > 7uLL)
    {
      *v42 = 0x203D206761547764;
      *(v41 + 4) += 8;
    }

    else
    {
      llvm::raw_ostream::write(v41, "dwTag = ", 8uLL);
    }

    v43 = *(a2 + 8);
    v44 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v44, v43, 0, 0, 0);
    v45 = (*(*a3 + 16))(a3);
    v46 = *(v45 + 4);
    if (*(v45 + 3) - v46 > 1uLL)
    {
      *v46 = 8236;
      *(v45 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v45, ", ", 2uLL);
    }

    v47 = (*(*a3 + 16))(a3);
    v48 = *(v47 + 4);
    if (*(v47 + 3) - v48 > 6uLL)
    {
      *(v48 + 3) = 540876901;
      *v48 = 1701667182;
      *(v47 + 4) += 7;
    }

    else
    {
      llvm::raw_ostream::write(v47, "name = ", 7uLL);
    }

    (*(*a3 + 80))(a3, *(a2 + 16), *(a2 + 24));
    v49 = (*(*a3 + 16))(a3);
    v50 = *(v49 + 4);
    if (*(v49 + 3) - v50 > 1uLL)
    {
      *v50 = 8236;
      *(v49 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v49, ", ", 2uLL);
    }

    v51 = (*(*a3 + 16))(a3);
    v52 = *(v51 + 4);
    if (*(v51 + 3) - v52 > 0xCuLL)
    {
      qmemcpy(v52, "sizeInBits = ", 13);
      *(v51 + 4) += 13;
    }

    else
    {
      llvm::raw_ostream::write(v51, "sizeInBits = ", 0xDuLL);
    }

    v53 = *(a2 + 32);
    v54 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v54, v53, 0, 0, 0);
    v55 = (*(*a3 + 16))(a3);
    v56 = *(v55 + 4);
    if (*(v55 + 3) - v56 > 1uLL)
    {
      *v56 = 8236;
      *(v55 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v55, ", ", 2uLL);
    }

    v57 = (*(*a3 + 16))(a3);
    v58 = *(v57 + 4);
    if (*(v57 + 3) - v58 > 0xDuLL)
    {
      qmemcpy(v58, "alignInBits = ", 14);
      *(v57 + 4) += 14;
    }

    else
    {
      llvm::raw_ostream::write(v57, "alignInBits = ", 0xEuLL);
    }

    v59 = *(a2 + 40);
    v60 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v60, v59, 0, 0, 0);
    v61 = (*(*a3 + 16))(a3);
    v62 = *(v61 + 4);
    if (*(v61 + 3) - v62 > 1uLL)
    {
      *v62 = 8236;
      *(v61 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v61, ", ", 2uLL);
    }

    v63 = (*(*a3 + 16))(a3);
    v64 = *(v63 + 4);
    if (*(v63 + 3) - v64 > 0xEuLL)
    {
      qmemcpy(v64, "offsetInBits = ", 15);
      *(v63 + 4) += 15;
    }

    else
    {
      llvm::raw_ostream::write(v63, "offsetInBits = ", 0xFuLL);
    }

    v65 = *(a2 + 48);
    v66 = (*(*a3 + 16))(a3);
    write_unsigned<unsigned long long>(v66, v65, 0, 0, 0);
    v67 = (*(*a3 + 16))(a3);
    v68 = *(v67 + 4);
    if (*(v67 + 3) - v68 > 1uLL)
    {
      *v68 = 8236;
      *(v67 + 4) += 2;
    }

    else
    {
      llvm::raw_ostream::write(v67, ", ", 2uLL);
    }

    v69 = (*(*a3 + 16))(a3);
    v70 = *(v69 + 4);
    if ((*(v69 + 3) - v70) > 0xA)
    {
      *(v70 + 7) = 540876901;
      *v70 = *"baseType = ";
      *(v69 + 4) += 11;
    }

    else
    {
      llvm::raw_ostream::write(v69, "baseType = ", 0xBuLL);
    }

    v16 = *(a2 + 56);
LABEL_82:
    (*(*a3 + 32))(a3, v16);
    goto LABEL_83;
  }

  if (v5 != &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id)
  {
    return;
  }

  v6 = (*(*a3 + 16))(a3);
  v7 = *(v6 + 4);
  if ((*(v6 + 3) - v7) > 8)
  {
    *(v7 + 8) = 101;
    *v7 = *"composite";
    *(v6 + 4) += 9;
  }

  else
  {
    llvm::raw_ostream::write(v6, "composite", 9uLL);
  }

  v73 = (*(*a3 + 16))(a3);
  v74 = *(v73 + 4);
  if (*(v73 + 3) == v74)
  {
    llvm::raw_ostream::write(v73, "<", 1uLL);
  }

  else
  {
    *v74 = 60;
    ++*(v73 + 4);
  }

  v75 = (*(*a3 + 16))(a3);
  v76 = *(v75 + 4);
  if (*(v75 + 3) - v76 > 7uLL)
  {
    *v76 = 0x203D206761547764;
    *(v75 + 4) += 8;
  }

  else
  {
    llvm::raw_ostream::write(v75, "dwTag = ", 8uLL);
  }

  v77 = *(a2 + 8);
  v78 = (*(*a3 + 16))(a3);
  write_unsigned<unsigned long long>(v78, v77, 0, 0, 0);
  v79 = (*(*a3 + 16))(a3);
  v80 = *(v79 + 4);
  if (*(v79 + 3) - v80 > 1uLL)
  {
    *v80 = 8236;
    *(v79 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v79, ", ", 2uLL);
  }

  v81 = (*(*a3 + 16))(a3);
  v82 = *(v81 + 4);
  if (*(v81 + 3) - v82 > 6uLL)
  {
    *(v82 + 3) = 540876901;
    *v82 = 1701667182;
    *(v81 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v81, "name = ", 7uLL);
  }

  (*(*a3 + 80))(a3, *(a2 + 16), *(a2 + 24));
  v83 = (*(*a3 + 16))(a3);
  v84 = *(v83 + 4);
  if (*(v83 + 3) - v84 > 1uLL)
  {
    *v84 = 8236;
    *(v83 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v83, ", ", 2uLL);
  }

  v85 = (*(*a3 + 16))(a3);
  v86 = *(v85 + 4);
  if (*(v85 + 3) - v86 > 7uLL)
  {
    *v86 = 0x203D2065706F6373;
    *(v85 + 4) += 8;
  }

  else
  {
    llvm::raw_ostream::write(v85, "scope = ", 8uLL);
  }

  (*(*a3 + 40))(a3, *(a2 + 32));
  v87 = (*(*a3 + 16))(a3);
  v88 = *(v87 + 4);
  if (*(v87 + 3) - v88 > 1uLL)
  {
    *v88 = 8236;
    *(v87 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v87, ", ", 2uLL);
  }

  v89 = (*(*a3 + 16))(a3);
  v90 = *(v89 + 4);
  if (*(v89 + 3) - v90 > 6uLL)
  {
    *(v90 + 3) = 540876901;
    *v90 = 1701734764;
    *(v89 + 4) += 7;
  }

  else
  {
    llvm::raw_ostream::write(v89, "line = ", 7uLL);
  }

  v91 = *(a2 + 40);
  v92 = (*(*a3 + 16))(a3);
  write_unsigned<unsigned long long>(v92, v91, 0, 0, 0);
  v93 = (*(*a3 + 16))(a3);
  v94 = *(v93 + 4);
  if (*(v93 + 3) - v94 > 1uLL)
  {
    *v94 = 8236;
    *(v93 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v93, ", ", 2uLL);
  }

  v95 = (*(*a3 + 16))(a3);
  v96 = *(v95 + 4);
  if (*(v95 + 3) - v96 > 0xCuLL)
  {
    qmemcpy(v96, "sizeInBits = ", 13);
    *(v95 + 4) += 13;
  }

  else
  {
    llvm::raw_ostream::write(v95, "sizeInBits = ", 0xDuLL);
  }

  v97 = *(a2 + 48);
  v98 = (*(*a3 + 16))(a3);
  write_unsigned<unsigned long long>(v98, v97, 0, 0, 0);
  v99 = (*(*a3 + 16))(a3);
  v100 = *(v99 + 4);
  if (*(v99 + 3) - v100 > 1uLL)
  {
    *v100 = 8236;
    *(v99 + 4) += 2;
  }

  else
  {
    llvm::raw_ostream::write(v99, ", ", 2uLL);
  }

  v101 = (*(*a3 + 16))(a3);
  v102 = *(v101 + 4);
  if (*(v101 + 3) - v102 > 0xDuLL)
  {
    qmemcpy(v102, "alignInBits = ", 14);
    *(v101 + 4) += 14;
  }

  else
  {
    llvm::raw_ostream::write(v101, "alignInBits = ", 0xEuLL);
  }

  v103 = *(a2 + 56);
  v104 = (*(*a3 + 16))(a3);
  write_unsigned<unsigned long long>(v104, v103, 0, 0, 0);
  v105 = (*(*a3 + 16))(a3);
  v106 = *(v105 + 4);
  if (*(v105 + 3) == v106)
  {
    llvm::raw_ostream::write(v105, ",", 1uLL);
  }

  else
  {
    *v106 = 44;
    ++*(v105 + 4);
  }

  v107 = (*(*a3 + 16))(a3);
  v108 = *(v107 + 4);
  if (v108 >= *(v107 + 3))
  {
    llvm::raw_ostream::write(v107, 32);
  }

  else
  {
    *(v107 + 4) = v108 + 1;
    *v108 = 32;
  }

  v109 = (*(*a3 + 16))(a3);
  v110 = *(v109 + 4);
  if (*(v109 + 3) - v110 > 7uLL)
  {
    *v110 = 0x73746E656D656C65;
    *(v109 + 4) += 8;
  }

  else
  {
    llvm::raw_ostream::write(v109, "elements", 8uLL);
  }

  v111 = (*(*a3 + 16))(a3);
  v112 = *(v111 + 4);
  if (v112 >= *(v111 + 3))
  {
    llvm::raw_ostream::write(v111, 32);
  }

  else
  {
    *(v111 + 4) = v112 + 1;
    *v112 = 32;
  }

  v113 = (*(*a3 + 16))(a3);
  v114 = *(v113 + 4);
  if (*(v113 + 3) == v114)
  {
    llvm::raw_ostream::write(v113, "=", 1uLL);
  }

  else
  {
    *v114 = 61;
    ++*(v113 + 4);
  }

  v115 = (*(*a3 + 16))(a3);
  v116 = *(v115 + 4);
  if (v116 >= *(v115 + 3))
  {
    llvm::raw_ostream::write(v115, 32);
  }

  else
  {
    *(v115 + 4) = v116 + 1;
    *v116 = 32;
  }

  v117 = (*(*a3 + 16))(a3);
  v118 = *(v117 + 4);
  if (*(v117 + 3) == v118)
  {
    llvm::raw_ostream::write(v117, "[", 1uLL);
  }

  else
  {
    *v118 = 91;
    ++*(v117 + 4);
  }

  v119 = *(a2 + 72);
  if (v119)
  {
    v120 = *(a2 + 64);
    (*(*a3 + 32))(a3, *v120);
    if (v119 != 1)
    {
      v121 = 8 * v119;
      v122 = v120 + 1;
      v123 = v121 - 8;
      do
      {
        v124 = (*(*a3 + 16))(a3);
        v125 = *(v124 + 4);
        if (*(v124 + 3) - v125 > 1uLL)
        {
          *v125 = 8236;
          *(v124 + 4) += 2;
        }

        else
        {
          llvm::raw_ostream::write(v124, ", ", 2uLL);
        }

        v126 = *v122++;
        (*(*a3 + 32))(a3, v126);
        v123 -= 8;
      }

      while (v123);
    }
  }

  v127 = (*(*a3 + 16))(a3);
  v128 = *(v127 + 4);
  if (*(v127 + 3) == v128)
  {
    llvm::raw_ostream::write(v127, "]", 1uLL);
  }

  else
  {
    *v128 = 93;
    ++*(v127 + 4);
  }

LABEL_83:
  v71 = (*(*a3 + 16))(a3);
  v72 = *(v71 + 4);
  if (*(v71 + 3) == v72)
  {

    llvm::raw_ostream::write(v71, ">", 1uLL);
  }

  else
  {
    *v72 = 62;
    ++*(v71 + 4);
  }
}

BOOL mlir::AsmParser::parseType<mlir::ODIE::DebugInfo::DIType>(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v4 = (*(*a1 + 40))(a1);
  v14 = 0;
  if ((*(*a1 + 536))(a1, &v14))
  {
    v5 = *(*v14 + 136);
    if (v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id || v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id || v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id || v5 == &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id)
    {
      *a2 = v14;
      v11 = 1;
    }

    else
    {
      *a2 = 0;
      v12 = "invalid kind of type specified";
      v13 = 259;
      (*(*a1 + 24))(v15, a1, v4, &v12);
      v11 = (v16 & 1) == 0;
      mlir::InFlightDiagnostic::~InFlightDiagnostic(v15);
    }
  }

  else
  {
    v11 = 0;
  }

  v9 = *MEMORY[0x277D85DE8];
  return v11;
}

void std::__optional_storage_base<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,false>>(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 64) == *(a2 + 64))
  {
    if (*(a1 + 64))
    {

      llvm::SmallVectorImpl<mlir::ODIE::DebugInfo::DIType>::operator=(a1, a2);
    }
  }

  else if (*(a1 + 64))
  {
    v3 = *a1;
    if (*a1 != a1 + 16)
    {
      free(v3);
    }

    *(a1 + 64) = 0;
  }

  else
  {
    *a1 = a1 + 16;
    *(a1 + 8) = 0x600000000;
    if (*(a2 + 8))
    {
      llvm::SmallVectorImpl<mlir::ODIE::DebugInfo::DIType>::operator=(a1, a2);
    }

    *(a1 + 64) = 1;
  }
}

uint64_t llvm::SmallVectorImpl<mlir::ODIE::DebugInfo::DIType>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v5 = (a2 + 16);
    v4 = *a2;
    if (v4 != v5)
    {
      v6 = *a1;
      if (*a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }

      *a1 = v4;
      v7 = (a2 + 8);
      *(a1 + 8) = *(a2 + 8);
      *a2 = v5;
      *(a2 + 12) = 0;
      goto LABEL_17;
    }

    v7 = (a2 + 8);
    v8 = *(a2 + 8);
    v9 = *(a1 + 8);
    if (v9 >= v8)
    {
      if (v8)
      {
        memmove(*a1, v4, 8 * v8);
      }

      goto LABEL_16;
    }

    if (*(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*a1, v4, 8 * v9);
        goto LABEL_14;
      }
    }

    else
    {
      *(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (a1 + 16), v8, 8);
    }

    v9 = 0;
LABEL_14:
    v10 = *v7 - v9;
    if (v10)
    {
      memcpy((*a1 + 8 * v9), (*a2 + 8 * v9), 8 * v10);
    }

LABEL_16:
    *(a1 + 8) = v8;
LABEL_17:
    *v7 = 0;
  }

  return a1;
}

void mlir::Dialect::addType<mlir::ODIE::DebugInfo::UnresolvedType>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractType::get<mlir::ODIE::DebugInfo::UnresolvedType>(a1, &v2);
  mlir::Dialect::addType(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id);
}

void mlir::Dialect::addType<mlir::ODIE::DebugInfo::BasicType>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractType::get<mlir::ODIE::DebugInfo::BasicType>(a1, &v2);
  mlir::Dialect::addType(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id);
}

void mlir::Dialect::addType<mlir::ODIE::DebugInfo::DerivedType>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractType::get<mlir::ODIE::DebugInfo::DerivedType>(a1, &v2);
  mlir::Dialect::addType(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id);
}

void mlir::Dialect::addType<mlir::ODIE::DebugInfo::CompositeType>(uint64_t a1)
{
  v4[11] = *MEMORY[0x277D85DE8];
  mlir::AbstractType::get<mlir::ODIE::DebugInfo::CompositeType>(a1, &v2);
  mlir::Dialect::addType(a1, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id, &v2);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(v4);
  mlir::detail::InterfaceMap::~InterfaceMap(&v3);
  mlir::StorageUniquer::registerParametricStorageTypeImpl((**(a1 + 32) + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id);
}

void mlir::AbstractType::get<mlir::ODIE::DebugInfo::UnresolvedType>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::UnresolvedType,mlir::ODIE::DebugInfo::DIType,mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage,mlir::detail::TypeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractType::AbstractType(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14UnresolvedTypeENSE_6DITypeENSE_6detail21UnresolvedTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_, &v4, _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14UnresolvedTypeENSD_6DITypeENSD_6detail21UnresolvedTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id, "debuginfo.unresolved", 20);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14UnresolvedTypeENSE_6DITypeENSE_6detail21UnresolvedTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), uint64_t a6)
{
  if (*(a2 + 8))
  {
    return a5(a6);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo14UnresolvedTypeENSD_6DITypeENSD_6detail21UnresolvedTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v5 = a2[1];
  if (v5)
  {
    v5 = *a5;
  }

  return mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::UnresolvedType,mlir::Type>(*(**a2 + 32), v5);
}

void mlir::AbstractType::get<mlir::ODIE::DebugInfo::BasicType>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::BasicType,mlir::ODIE::DebugInfo::DIType,mlir::ODIE::DebugInfo::detail::BasicTypeStorage,mlir::detail::TypeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractType::AbstractType(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo9BasicTypeENSE_6DITypeENSE_6detail16BasicTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_, &v4, _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo9BasicTypeENSD_6DITypeENSD_6detail16BasicTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id, "debuginfo.basic", 15);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo9BasicTypeENSD_6DITypeENSD_6detail16BasicTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  v2 = *(a2 + 12);
  v4 = *(a2 + 32);
  v5 = *(**a2 + 32);
  v7 = *(a2 + 16);
  return mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::BasicType,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(v5, v3, v2, &v7, v4);
}

void mlir::AbstractType::get<mlir::ODIE::DebugInfo::DerivedType>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::DerivedType,mlir::ODIE::DebugInfo::DIType,mlir::ODIE::DebugInfo::detail::DerivedTypeStorage,mlir::detail::TypeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractType::AbstractType(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo11DerivedTypeENSE_6DITypeENSE_6detail18DerivedTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_, &v4, _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo11DerivedTypeENSD_6DITypeENSD_6detail18DerivedTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id, "debuginfo.derived", 17);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo11DerivedTypeENSE_6DITypeENSE_6detail18DerivedTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), uint64_t a6)
{
  if (*(a2 + 56))
  {
    return a5(a6);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo11DerivedTypeENSD_6DITypeENSD_6detail18DerivedTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v9 = *(a2 + 8);
  v10 = *(a2 + 16);
  v11 = *(a2 + 32);
  v12 = *(a2 + 40);
  v13 = *(a2 + 48);
  if (*(a2 + 56))
  {
    v14 = *a5;
  }

  else
  {
    v14 = 0;
  }

  v18 = v5;
  v19 = v6;
  v15 = *(**a2 + 32);
  v17 = v10;
  return mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::DerivedType,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(v15, v9, &v17, v11, v12, v13, v14);
}

void mlir::AbstractType::get<mlir::ODIE::DebugInfo::CompositeType>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v9 = *MEMORY[0x277D85DE8];
  memset(v8, 0, sizeof(v8));
  v7[1] = 0x300000000;
  *&v5 = mlir::detail::StorageUserBase<mlir::ODIE::DebugInfo::CompositeType,mlir::ODIE::DebugInfo::DIType,mlir::ODIE::DebugInfo::detail::CompositeTypeStorage,mlir::detail::TypeUniquer>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
  v6 = llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks + 2;
  v7[0] = v8;
  mlir::AbstractType::AbstractType(a2, a1, v7, &v5, _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo13CompositeTypeENSE_6DITypeENSE_6detail20CompositeTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_, &v4, _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo13CompositeTypeENSD_6DITypeENSD_6detail20CompositeTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_, &v3, &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::CompositeType,void>::id, "debuginfo.composite", 19);
  llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::~UniqueFunctionBase(&v5);
  mlir::detail::InterfaceMap::~InterfaceMap(v7);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t _ZN4llvm12function_refIFvN4mlir4TypeENS0_IFvNS1_9AttributeEEEENS0_IFvS2_EEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo13CompositeTypeENSE_6DITypeENSE_6detail20CompositeTypeStorageENSB_11TypeUniquerEJEE29getWalkImmediateSubElementsFnEvEUlT_S5_S7_E_EEvlS2_S5_S7_(uint64_t a1, void *a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t (*a5)(uint64_t), uint64_t a6)
{
  v8 = a2[8];
  v9 = a2[9];
  if (a2[4])
  {
    result = a3(a4);
  }

  if (v9)
  {
    v11 = 8 * v9;
    do
    {
      if (*v8)
      {
        result = a5(a6);
      }

      ++v8;
      v11 -= 8;
    }

    while (v11);
  }

  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir4TypeES2_NS_8ArrayRefINS1_9AttributeEEENS3_IS2_EEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_4ODIE9DebugInfo13CompositeTypeENSD_6DITypeENSD_6detail20CompositeTypeStorageENSA_11TypeUniquerEJEE32getReplaceImmediateSubElementsFnEvEUlT_S5_S6_E_EES2_lS2_S5_S6_(int a1, uint64_t a2, uint64_t *a3, int a4, unsigned int *a5, unint64_t a6)
{
  v6 = a6;
  v8 = *(a2 + 8);
  if (*(a2 + 32))
  {
    v9 = *a3;
  }

  else
  {
    v9 = 0;
  }

  if (a6 >= *(a2 + 72))
  {
    v6 = *(a2 + 72);
  }

  return mlir::ODIE::DebugInfo::CompositeType::get(*(**a2 + 32), v8, *(a2 + 16), *(a2 + 24), v9, *(a2 + 40), *(a2 + 48), *(a2 + 56), a5, v6);
}

uint64_t mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::UnresolvedType,mlir::Type>(void *a1, uint64_t a2)
{
  v15 = *MEMORY[0x277D85DE8];
  v2 = *a1;
  v6[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id;
  v6[1] = &v7;
  v7 = a1;
  v10[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21UnresolvedTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_14UnresolvedTypeEJNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_;
  v10[1] = v6;
  v9 = a2;
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  v13 = 0;
  v14 = 0xFF51AFD7ED558CCDLL;
  v3 = llvm::hashing::detail::hash_combine_recursive_helper::combine<mlir::Type>(v11, 0, v11, v12, &v9);
  v8 = &v9;
  *&v11[0] = &v9;
  *(&v11[0] + 1) = v10;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v2 + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::UnresolvedType,void>::id, v3, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage,mlir::Type>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage *)>,mlir::TypeID,mlir::Type &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v8, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage,mlir::Type>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage *)>,mlir::TypeID,mlir::Type &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, v11);
  v5 = *MEMORY[0x277D85DE8];
  return result;
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage,mlir::Type>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::UnresolvedTypeStorage *)>,mlir::TypeID,mlir::Type &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t **a1, unint64_t *a2)
{
  v3 = **a1;
  v4 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 16, 3);
  *v4 = 0;
  v4[1] = v3;
  v5 = a1[1];
  if (*v5)
  {
    (*v5)(v5[1], v4);
  }

  return v4;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail21UnresolvedTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_14UnresolvedTypeEJNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_(uint64_t a1, uint64_t *a2)
{
  result = mlir::AbstractType::lookup(*a1, **(a1 + 8));
  *a2 = result;
  return result;
}

uint64_t mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::BasicType,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(void *a1, unsigned int a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  v24 = *MEMORY[0x277D85DE8];
  v6 = *a1;
  v13[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id;
  v13[1] = &v14;
  v14 = a1;
  v18[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail16BasicTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_9BasicTypeEJjjNS_9StringRefEyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_;
  v18[1] = v13;
  v15[0] = a2;
  v15[1] = a3;
  v16 = *a4;
  v17 = a5;
  memset(v22, 0, sizeof(v22));
  v23 = 0xFF51AFD7ED558CCDLL;
  v21 = __PAIR64__(a3, a2);
  v19 = 0;
  v7 = llvm::hashing::detail::hash_combine_range_impl<char const>(v16, v16 + *(&v16 + 1), a3, a4);
  v8 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(&v21, &v19, v22, &v22[3] + 8, v7);
  v20 = v19;
  v9 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long long>(&v21, &v20, v8, &v22[3] + 8, a5);
  v10 = llvm::hashing::detail::hash_combine_recursive_helper::combine(&v21, v20, v9, &v22[3] + 8);
  v20 = v15;
  v21 = v15;
  *&v22[0] = v18;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v6 + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::BasicType,void>::id, v10, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::BasicTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::BasicTypeStorage,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::BasicTypeStorage *)>,mlir::TypeID,unsigned int,unsigned int,llvm::StringRef,unsigned long long &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v20, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::BasicTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::BasicTypeStorage,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::BasicTypeStorage *)>,mlir::TypeID,unsigned int,unsigned int,llvm::StringRef,unsigned long long &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, &v21);
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::BasicTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::BasicTypeStorage,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::BasicTypeStorage *)>,mlir::TypeID,unsigned int,unsigned int,llvm::StringRef,unsigned long long &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(void *a1, uint64_t a2)
{
  v2 = *a1;
  if (*(a2 + 8) == **a1 && *(a2 + 12) == v2[1] && (v4 = *(a2 + 24), v4 == *(v2 + 2)) && (!v4 || !memcmp(*(a2 + 16), *(v2 + 1), v4)))
  {
    return *(a2 + 32) == *(v2 + 3);
  }

  else
  {
    return 0;
  }
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::BasicTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::BasicTypeStorage,unsigned int,unsigned int,llvm::StringRef,unsigned long long>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::BasicTypeStorage *)>,mlir::TypeID,unsigned int,unsigned int,llvm::StringRef,unsigned long long &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t **a1, unint64_t *a2)
{
  v4 = (*a1)[3];
  v5 = **a1;
  v6 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, (*a1)[1], (*a1)[2]);
  v8 = v7;
  v9 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 40, 3);
  *v9 = 0;
  v9[1] = v5;
  v9[2] = v6;
  v9[3] = v8;
  v9[4] = v4;
  v10 = a1[1];
  if (*v10)
  {
    (*v10)(v10[1], v9);
  }

  return v9;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail16BasicTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_9BasicTypeEJjjNS_9StringRefEyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESH_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSJ_E_EEvlS6_(uint64_t a1, uint64_t *a2)
{
  result = mlir::AbstractType::lookup(*a1, **(a1 + 8));
  *a2 = result;
  return result;
}

uint64_t mlir::detail::TypeUniquer::get<mlir::ODIE::DebugInfo::DerivedType,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(void *a1, int a2, __int128 *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7 = a7;
  v36 = *MEMORY[0x277D85DE8];
  v11 = *a1;
  v18[0] = &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id;
  v18[1] = &v19;
  v19 = a1;
  v26[0] = _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail18DerivedTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_11DerivedTypeEJjNS_9StringRefEyyyNS3_6DITypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_;
  v26[1] = v18;
  v20 = a2;
  v21 = *a3;
  v22 = a4;
  v23 = a5;
  v24 = a6;
  v25 = a7;
  v32 = 0u;
  memset(v33, 0, sizeof(v33));
  *&v30[16] = 0u;
  v31 = 0u;
  v34 = 0;
  v35 = 0xFF51AFD7ED558CCDLL;
  *v30 = a2;
  *&v30[4] = llvm::hashing::detail::hash_combine_range_impl<char const>(v21, v21 + *(&v21 + 1), a3, a4);
  *&v30[12] = a4;
  v27 = 0;
  v12 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long long>(v30, &v27, &v30[20], v33, a5);
  v28 = v27;
  v13 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long long>(v30, &v28, v12, v33, a6);
  v29 = v28;
  v14 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v30, &v29, v13, v33, (v7 >> 4) ^ (v7 >> 9));
  v15 = llvm::hashing::detail::hash_combine_recursive_helper::combine(v30, v29, v14, v33);
  v29 = &v20;
  *v30 = &v20;
  *&v30[8] = v26;
  result = mlir::detail::StorageUniquerImpl::getOrCreate(*(v11 + 384), &mlir::detail::TypeIDResolver<mlir::ODIE::DebugInfo::DerivedType,void>::id, v15, llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::DerivedTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, &v29, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::DerivedTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, v30);
  v17 = *MEMORY[0x277D85DE8];
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::DerivedTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(void *a1, uint64_t a2)
{
  v2 = *a1;
  if (*(a2 + 8) == **a1 && (v4 = *(a2 + 24), v4 == *(v2 + 2)) && (!v4 || !memcmp(*(a2 + 16), *(v2 + 1), v4)) && *(a2 + 32) == *(v2 + 3) && *(a2 + 40) == *(v2 + 4) && *(a2 + 48) == *(v2 + 5))
  {
    return *(a2 + 56) == *(v2 + 6);
  }

  else
  {
    return 0;
  }
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::DerivedTypeStorage,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::DerivedTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,unsigned long long,unsigned long long,unsigned long long,mlir::ODIE::DebugInfo::DIType &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(int **a1, unint64_t *a2)
{
  v4 = **a1;
  v13 = *(*a1 + 6);
  v5 = *(*a1 + 5);
  v6 = *(*a1 + 6);
  v7 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, *(*a1 + 1), *(*a1 + 2));
  v9 = v8;
  v10 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 64, 3);
  *v10 = 0;
  *(v10 + 8) = v4;
  *(v10 + 16) = v7;
  *(v10 + 24) = v9;
  *(v10 + 32) = v13;
  *(v10 + 48) = v5;
  *(v10 + 56) = v6;
  v11 = a1[1];
  if (*v11)
  {
    (*v11)(*(v11 + 1), v10);
  }

  return v10;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail18DerivedTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_11DerivedTypeEJjNS_9StringRefEyyyNS3_6DITypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESI_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSK_E_EEvlS6_(uint64_t a1, uint64_t *a2)
{
  result = mlir::AbstractType::lookup(*a1, **(a1 + 8));
  *a2 = result;
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompositeTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType> &&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(void *a1, uint64_t a2)
{
  v2 = *a1;
  if (*(a2 + 8) != **a1)
  {
    return 0;
  }

  v4 = *(a2 + 24);
  if (v4 != *(v2 + 2) || v4 && memcmp(*(a2 + 16), *(v2 + 1), v4))
  {
    return 0;
  }

  if (*(a2 + 32) != *(v2 + 3))
  {
    return 0;
  }

  if (*(a2 + 40) != *(v2 + 4))
  {
    return 0;
  }

  if (*(a2 + 48) != *(v2 + 5))
  {
    return 0;
  }

  if (*(a2 + 56) != *(v2 + 6))
  {
    return 0;
  }

  v5 = *(a2 + 72);
  if (v5 != *(v2 + 8))
  {
    return 0;
  }

  if (!v5)
  {
    return 1;
  }

  v6 = *(a2 + 64);
  v7 = *(v2 + 7);
  v8 = 8 * v5 - 8;
  do
  {
    v10 = *v7++;
    v9 = v10;
    v11 = *v6++;
    result = v11 == v9;
    v13 = v11 != v9 || v8 == 0;
    v8 -= 8;
  }

  while (!v13);
  return result;
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage * mlir::StorageUniquer::get<mlir::ODIE::DebugInfo::detail::CompositeTypeStorage,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType>>(llvm::function_ref<void ()(mlir::ODIE::DebugInfo::detail::CompositeTypeStorage *)>,mlir::TypeID,unsigned int,llvm::StringRef,mlir::SymbolRefAttr,unsigned long long,unsigned long long,unsigned long long,llvm::ArrayRef<mlir::ODIE::DebugInfo::DIType> &&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(int **a1, unint64_t *a2)
{
  v4 = **a1;
  v5 = *(*a1 + 3);
  v6 = *(*a1 + 4);
  v22 = *(*a1 + 6);
  v23 = *(*a1 + 5);
  v8 = *(*a1 + 7);
  v7 = *(*a1 + 8);
  v9 = mlir::StorageUniquer::StorageAllocator::copyInto(a2, *(*a1 + 1), *(*a1 + 2));
  v11 = v10;
  if (v7)
  {
    v21 = v6;
    v12 = v5;
    v13 = v4;
    v14 = 8 * v7;
    v15 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 8 * v7, 3);
    v16 = v15;
    do
    {
      v17 = *v8++;
      *v16++ = v17;
      v14 -= 8;
    }

    while (v14);
    v4 = v13;
    v5 = v12;
    v6 = v21;
  }

  else
  {
    v15 = 0;
  }

  v18 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(a2, 80, 3);
  *v18 = 0;
  *(v18 + 8) = v4;
  *(v18 + 16) = v9;
  *(v18 + 24) = v11;
  *(v18 + 32) = v5;
  *(v18 + 40) = v6;
  *(v18 + 48) = v23;
  *(v18 + 56) = v22;
  *(v18 + 64) = v15;
  *(v18 + 72) = v7;
  v19 = a1[1];
  if (*v19)
  {
    (*v19)(*(v19 + 1), v18);
  }

  return v18;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir4ODIE9DebugInfo6detail20CompositeTypeStorageEEE11callback_fnIZNS1_6detail11TypeUniquer13getWithTypeIDINS3_13CompositeTypeEJjNS_9StringRefENS1_13SymbolRefAttrEyyyNS_8ArrayRefINS3_6DITypeEEEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_11TypeStorageEEE5valueESL_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSN_E_EEvlS6_(uint64_t a1, uint64_t *a2)
{
  result = mlir::AbstractType::lookup(*a1, **(a1 + 8));
  *a2 = result;
  return result;
}

uint64_t llvm::function_ref<llvm::ParseResult ()(void)>::callback_fn<mlir::FieldParser<llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>,llvm::SmallVector<mlir::ODIE::DebugInfo::DIType,6u>>::parse(mlir::AsmParser &)::{lambda(void)#1}>(uint64_t *a1)
{
  v2 = *a1;
  v7 = 0;
  if (!mlir::AsmParser::parseType<mlir::ODIE::DebugInfo::DIType>(v2, &v7))
  {
    return 0;
  }

  v3 = v7;
  v4 = a1[1];
  v5 = *(v4 + 8);
  if (v5 >= *(v4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (v4 + 16), v5 + 1, 8);
    LODWORD(v5) = *(v4 + 8);
  }

  *(*v4 + 8 * v5) = v3;
  ++*(v4 + 8);
  return 1;
}

void mlir::ODIE::Compiler::Serialization::Utils::serializeOdixProgramToFileBuffer(uint64_t a1@<X0>, unsigned int *a2@<X1>, const llvm::Twine *a3@<X2>, void *a4@<X8>)
{
  v10 = *MEMORY[0x277D85DE8];
  mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::ODIXProgramBuilder(v9, a2, a3);
  if (mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::finish(v9))
  {
    operator new();
  }

  *&v7 = "Unable to serialize module into ODIX program fb.";
  LOWORD(v8) = 259;
  (*a1)(*(a1 + 8), &v7);
  *a4 = 0;
  mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::~ODIXProgramBuilder(v9);
  v6 = *MEMORY[0x277D85DE8];
}

BOOL mlir::ODIE::Compiler::Serialization::Utils::serializeOdixProgramToFile(uint64_t a1, unsigned int *a2, const llvm::Twine *a3)
{
  mlir::ODIE::Compiler::Serialization::Utils::serializeOdixProgramToFileBuffer(a1, a2, a3, &v8);
  v3 = v8;
  if (!v8)
  {
    return 0;
  }

  (*(*v8 + 24))(&v7, v8);
  v4 = v7;
  if (v7)
  {
    (*(*v7 + 8))(v7);
  }

  v5 = v4 == 0;
  (*(*v3 + 40))(v3);
  return v5;
}

BOOL mlir::ODIE::Compiler::Serialization::serializeODIXIRToPackage(unsigned int *a1, uint64_t a2)
{
  v8 = &v9;
  v9 = a1;
  memset(&__p, 0, sizeof(__p));
  std::string::append[abi:nn200100]<char const*,0>(&__p, "program.odix", "");
  std::__fs::filesystem::operator/[abi:nn200100](&__p, a2, &__s);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = llvm::function_ref<void ()(llvm::Twine const&)>::callback_fn<mlir::ODIE::Compiler::Serialization::serializeODIXIRToPackage(mlir::ModuleOp,std::__fs::filesystem::path const&)::$_0 const>;
  __p.__r_.__value_.__l.__size_ = &v8;
  if ((SHIBYTE(__s.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    p_s = &__s;
LABEL_6:
    strlen(p_s);
    goto LABEL_7;
  }

  p_s = __s.__pn_.__r_.__value_.__r.__words[0];
  if (__s.__pn_.__r_.__value_.__r.__words[0])
  {
    goto LABEL_6;
  }

LABEL_7:
  v4 = mlir::ODIE::Compiler::Serialization::Utils::serializeOdixProgramToFile(&__p, v9, p_s);
  if (SHIBYTE(__s.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__s.__pn_.__r_.__value_.__l.__data_);
  }

  return v4;
}

void llvm::function_ref<void ()(llvm::Twine const&)>::callback_fn<mlir::ODIE::Compiler::Serialization::serializeODIXIRToPackage(mlir::ModuleOp,std::__fs::filesystem::path const&)::$_0 const>(void ****a1, const llvm::Twine *a2)
{
  v3[26] = *MEMORY[0x277D85DE8];
  mlir::Operation::emitError(v3, **a1, a2);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(v3);
  v2 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndex(uint64_t a1, uint64_t a2)
{
  v5 = a2;
  v3 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::doFind<mlir::Value>((a1 + 40), &v5);
  result = 0;
  if (v3)
  {
    if (v3 != *(a1 + 40) + 16 * *(a1 + 56))
    {
      return *(v3 + 8) | 0x100000000;
    }
  }

  return result;
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(std::vector<unsigned int> *a1, uint64_t a2, uint64_t a3, std::vector<unsigned int>::size_type __n)
{
  v16 = *MEMORY[0x277D85DE8];
  a1->__begin_ = 0;
  a1->__end_ = 0;
  a1->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a1, __n);
  v14 = a3;
  v15 = 0;
  if (__n)
  {
    v8 = 0;
    do
    {
      v9 = mlir::ValueRange::dereference_iterator(&v14, v8);
      RegisterIndex = mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndex(a2, v9);
      v12 = RegisterIndex;
      v13 = BYTE4(RegisterIndex);
      std::vector<unsigned int>::push_back[abi:nn200100](&a1->__begin_, &v12);
      v15 = ++v8;
    }

    while (__n != v8);
  }

  v11 = *MEMORY[0x277D85DE8];
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypeToProgram(uint64_t a1, uint64_t *a2)
{
  v2 = a2;
  v39 = a2;
  if (*(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::OperandType,void>::id)
  {
    v4 = llvm::DefaultDoCastIfPossible<mlir::ODIE::Compiler::ODIX::ODIXSerializableType,mlir::Type,llvm::CastInfo<mlir::ODIE::Compiler::ODIX::ODIXSerializableType,mlir::Type,void>>::doCastIfPossible(a2);
    if (v4)
    {
      v2 = (*v5)(v5, v4);
      v39 = v2;
    }
  }

  v7 = a1 + 208;
  v6 = *(a1 + 208);
  v8 = *(a1 + 224);
  if (v8)
  {
    v9 = ((v2 >> 4) ^ (v2 >> 9)) & (v8 - 1);
    v10 = *(v6 + 16 * v9);
    if (v10 == v2)
    {
LABEL_6:
      if (v9 != v8)
      {
        v21 = (v6 + 16 * v9 + 8);
        return *v21;
      }
    }

    else
    {
      v37 = 1;
      while (v10 != -4096)
      {
        v38 = v9 + v37++;
        v9 = v38 & (v8 - 1);
        v10 = *(v6 + 16 * v9);
        if (v10 == v2)
        {
          goto LABEL_6;
        }
      }
    }
  }

  v11 = 0xCBF29CE484222325;
  if (*(*v2 + 136) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::OperandType,void>::id)
  {
    v12 = v2;
  }

  else
  {
    v12 = 0;
  }

  v13 = v12[1];
  v14 = v12[2];
  v15 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(a1, v12[3]);
  if (v14)
  {
    v16 = v13;
    do
    {
      v17 = *v16++;
      v11 = 0x100000001B3 * (v11 ^ v17);
      --v14;
    }

    while (v14);
  }

  if (v13)
  {
    v18 = strlen(v13);
    flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((a1 + 48), v13, v18);
    v19 = *(a1 + 96);
    v20 = v19;
  }

  else
  {
    v20 = 0;
    v19 = *(a1 + 96);
  }

  *(a1 + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(a1 + 48, 6, v11);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 8, v15);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(a1 + 48, 4, v20);
  v22 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v19);
  v24 = *(a1 + 192);
  v23 = *(a1 + 200);
  if (v24 >= v23)
  {
    v26 = *(a1 + 184);
    v27 = v24 - v26;
    v28 = (v24 - v26) >> 2;
    v29 = v28 + 1;
    if ((v28 + 1) >> 62)
    {
      std::vector<flatbuffers::Offset<ODIE_FB::TypeDesc>>::__throw_length_error[abi:nn200100]();
    }

    v30 = v23 - v26;
    if (v30 >> 1 > v29)
    {
      v29 = v30 >> 1;
    }

    if (v30 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v31 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v31 = v29;
    }

    if (v31)
    {
      if (!(v31 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v32 = (v24 - v26) >> 2;
    v33 = (4 * v28);
    v34 = (4 * v28 - 4 * v32);
    *v33 = v22;
    v25 = v33 + 1;
    memcpy(v34, v26, v27);
    *(a1 + 184) = v34;
    *(a1 + 192) = v25;
    *(a1 + 200) = 0;
    if (v26)
    {
      operator delete(v26);
    }
  }

  else
  {
    *v24 = v22;
    v25 = v24 + 4;
  }

  *(a1 + 192) = v25;
  v35 = ((v25 - *(a1 + 184)) >> 2) - 1;
  *llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::operator[](v7, &v39) = v35;
  v21 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::operator[](v7, &v39);
  return *v21;
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(uint64_t a1, uint64_t a2)
{
  v66 = *MEMORY[0x277D85DE8];
  v4 = *(a1 + 296);
  if (v4)
  {
    v5 = *(a1 + 280);
    v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    v7 = *(v5 + 16 * v6);
    if (v7 == a2)
    {
LABEL_3:
      if (v6 != v4)
      {
        appended = *(v5 + 16 * v6 + 8);
LABEL_56:
        v54 = *MEMORY[0x277D85DE8];
        return appended;
      }
    }

    else
    {
      v57 = 1;
      while (v7 != -4096)
      {
        v58 = v6 + v57++;
        v6 = v58 & (v4 - 1);
        v7 = *(v5 + 16 * v6);
        if (v7 == a2)
        {
          goto LABEL_3;
        }
      }
    }
  }

  v8 = *a2;
  v9 = *(*a2 + 136);
  if (v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    *(a1 + 144) = 1;
    v17 = *(a1 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<long long>(a1 + 48, U64Value);
    v18 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v17);
    v19 = *MEMORY[0x277D85DE8];
    v20 = v18;
    v21 = a1;
    v22 = a2;
    v23 = 2;
LABEL_40:

    return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(v21, v22, v23, v20);
  }

  if (v9 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v62 = a2;
    ValueAsDouble = mlir::FloatAttr::getValueAsDouble(&v62);
    *(a1 + 144) = 1;
    v25 = *(a1 + 96);
    if (ValueAsDouble != 0.0 || *(a1 + 160) == 1)
    {
      if (*(a1 + 152) <= 7uLL)
      {
        *(a1 + 152) = 8;
      }

      flatbuffers::vector_downward<unsigned int>::fill(a1 + 48, -v25 & 7);
      v26 = *(a1 + 112);
      if (((v26 - *(a1 + 120)) & 0xFFFFFFF8) == 0)
      {
        flatbuffers::vector_downward<unsigned int>::reallocate((a1 + 48), 8uLL);
        v26 = *(a1 + 112);
      }

      *(v26 - 8) = ValueAsDouble;
      *(a1 + 112) = v26 - 8;
      v27 = *(a1 + 96) + 8;
      *(a1 + 96) = v27;
      flatbuffers::FlatBufferBuilderImpl<false>::TrackField(a1 + 48, 4, v27);
    }

    v28 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v25);
    v29 = *MEMORY[0x277D85DE8];
    v20 = v28;
    v21 = a1;
    v22 = a2;
    v23 = 3;
    goto LABEL_40;
  }

  if (v9 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    v30 = *(a2 + 16);
    if (v30)
    {
      v31 = strlen(*(a2 + 16));
      flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((a1 + 48), v30, v31);
      v32 = *(a1 + 96);
      v33 = v32;
    }

    else
    {
      v33 = 0;
      v32 = *(a1 + 96);
    }

    *(a1 + 144) = 1;
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(a1 + 48, 4, v33);
    v42 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v32);
    v43 = *MEMORY[0x277D85DE8];
    v20 = v42;
    v21 = a1;
    v22 = a2;
    v23 = 4;
    goto LABEL_40;
  }

  if (a2 && v9 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    v63 = 0;
    v64[0] = 0;
    v62 = 0;
    v10 = *(a2 + 16);
    if (v10)
    {
      v11 = *(a2 + 8);
      v12 = 8 * v10;
      do
      {
        v13 = *v11++;
        v61 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(a1, v13);
        std::vector<unsigned int>::push_back[abi:nn200100](&v62, &v61);
        v12 -= 8;
      }

      while (v12);
      v10 = v62;
      v14 = v63;
    }

    else
    {
      v14 = 0;
    }

    v44 = v14 - v10;
    if (v44)
    {
      v45 = v10;
    }

    else
    {
      v45 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    v46 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(a1 + 48, v45, v44 >> 2);
    *(a1 + 144) = 1;
    v47 = *(a1 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(a1 + 48, 4, v46);
    v48 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v47);
    appended = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 1, v48);
    if (v62)
    {
      v63 = v62;
      operator delete(v62);
    }

    goto LABEL_56;
  }

  if (a2 && v9 == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
  {
    mlir::NamedAttrList::NamedAttrList(&v62, a2);
    if (v63)
    {
      v34 = *v62;
      v35 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(a1, *(v62 + 1));
      v36 = *(v34 + 16);
      if (v36)
      {
        v37 = strlen(v36);
        flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((a1 + 48), v36, v37);
        v38 = *(a1 + 96);
        v39 = v38;
      }

      else
      {
        v39 = 0;
        v38 = *(a1 + 96);
      }

      *(a1 + 144) = 1;
      flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 6, v35);
      flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(a1 + 48, 4, v39);
      flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v38);
      operator new();
    }

    *(a1 + 144) = 1;
    flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(a1 + 48, 0);
    *(a1 + 144) = 0;
    v50 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(a1 + 48, 0);
    *(a1 + 144) = 1;
    v51 = *(a1 + 96);
    if (v50)
    {
      v52 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(a1 + 48, v50);
      flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 4, v52);
    }

    v53 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v51);
    appended = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 7, v53);
    if (v62 != v64)
    {
      free(v62);
    }

    goto LABEL_56;
  }

  if (v9 == &mlir::detail::TypeIDResolver<mlir::DenseArrayAttr,void>::id)
  {
    v49 = *MEMORY[0x277D85DE8];

    return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::DenseArrayAttr>(a1, a2);
  }

  else if (a2 && v9 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    v40 = *MEMORY[0x277D85DE8];

    return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::TypeAttr>(a1, a2);
  }

  else if (v9 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::EnumAttr,void>::id)
  {
    v56 = *MEMORY[0x277D85DE8];

    return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::ODIE::Compiler::ODIX::EnumAttr>(a1, a2);
  }

  else
  {
    if (v9 != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      v60 = *(v8 + 144);
      v59 = *(v8 + 152);
      v65 = 1283;
      v62 = "Unknown attribute type can't be serialized: ";
      v64[0] = v60;
      v64[1] = v59;
      llvm::report_fatal_error(&v62, 1);
    }

    v55 = *MEMORY[0x277D85DE8];

    return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::UnitAttr>(a1, a2);
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::operator[](uint64_t a1, uint64_t *a2)
{
  v9 = 0;
  v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::LookupBucketFor<mlir::Type>(*a1, *(a1 + 16), *a2, &v9);
  v5 = v9;
  if (v4)
  {
    return v5 + 8;
  }

  v10 = v9;
  v6 = *(a1 + 8);
  v7 = *(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }

  if (v7 + ~v6 - *(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::grow(a1, v7);
    llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::LookupBucketFor<mlir::Type>(*a1, *(a1 + 16), *a2, &v10);
    v6 = *(a1 + 8);
    v5 = v10;
  }

  *(a1 + 8) = v6 + 1;
  if (*v5 != -4096)
  {
    --*(a1 + 12);
  }

  *v5 = *a2;
  *(v5 + 8) = 0;
  return v5 + 8;
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypesToProgram(std::vector<unsigned int> *a1, uint64_t a2, uint64_t a3, std::vector<unsigned int>::size_type __n)
{
  a1->__begin_ = 0;
  a1->__end_ = 0;
  a1->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a1, __n);
  if (__n)
  {
    v8 = 0;
    do
    {
      v9 = mlir::TypeRange::dereference_iterator(a3, v8);
      v10 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypeToProgram(a2, v9);
      std::vector<unsigned int>::push_back[abi:nn200100](&a1->__begin_, &v10);
      ++v8;
    }

    while (__n != v8);
  }
}

unint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::addRegisterToFunction(uint64_t a1, uint64_t a2)
{
  v6 = a2;
  result = mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndex(a1, a2);
  if (!HIDWORD(result))
  {
    v4 = *(a1 + 16);
    if (*(a1 + 24) == v4)
    {
      std::vector<unsigned int>::resize((a1 + 16), 1uLL);
      v4 = *(a1 + 16);
    }

    v5 = *v4;
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::operator[]((a1 + 40), &v6);
    *result = v5;
    ++*v4;
  }

  return result;
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addSymbolToProgram(uint64_t a1, void *a2)
{
  v4 = *(a1 + 416);
  if (v4)
  {
    v5 = *(a1 + 400);
    v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    v7 = *(v5 + 16 * v6);
    if (v7 == a2)
    {
LABEL_3:
      if (v6 != v4)
      {
        LODWORD(v9) = *(v5 + 16 * v6 + 8);
        return v9 | 0x100000000;
      }
    }

    else
    {
      v41 = 1;
      while (v7 != -4096)
      {
        v42 = v6 + v41++;
        v6 = v42 & (v4 - 1);
        v7 = *(v5 + 16 * v6);
        if (v7 == a2)
        {
          goto LABEL_3;
        }
      }
    }
  }

  mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypesToProgram(&v45, a1, *(a2[3] + 16) & 0xFFFFFFFFFFFFFFF9 | 2, *(a2[3] + 8));
  mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypesToProgram(&__p, a1, (*(a2[3] + 16) + 8 * *(a2[3] + 8)) & 0xFFFFFFFFFFFFFFF9 | 2, *(a2[3] + 12));
  v8 = *(a2[4] + 16);
  v43 = a2;
  if (v8)
  {
    if ((v8 & 0x8000000000000000) == 0)
    {
      operator new();
    }

    std::vector<ODIE_FB::Intent>::__throw_length_error[abi:nn200100]();
  }

  v10 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(a1, a2[5]);
  v11 = a2[1];
  if (v11 == 2)
  {
    v13 = 2;
  }

  else
  {
    v13 = v11 == 1;
  }

  v12 = a2[2];
  v14 = *(v12 + 16);
  if (v14)
  {
    v15 = strlen(*(v12 + 16));
    flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((a1 + 48), v14, v15);
    v14 = *(a1 + 96);
  }

  if (v45.__end_ == v45.__begin_)
  {
    begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    begin = v45.__begin_;
  }

  v17 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(a1 + 48, begin, v45.__end_ - v45.__begin_);
  if (__p.__end_ == __p.__begin_)
  {
    v18 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v18 = __p.__begin_;
  }

  v19 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(a1 + 48, v18, __p.__end_ - __p.__begin_);
  *(a1 + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(a1 + 48, 0);
  *(a1 + 144) = 0;
  v20 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(a1 + 48, 0);
  *(a1 + 144) = 1;
  v21 = *(a1 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 14, v10);
  if (v20)
  {
    v22 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(a1 + 48, v20);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 12, v22);
  }

  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(a1 + 48, 10, v19);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(a1 + 48, 8, v17);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(a1 + 48, 6, v14);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(a1 + 48, 4, v13);
  v23 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v21);
  v9 = (*(a1 + 384) - *(a1 + 376)) >> 2;
  v46 = 0;
  v24 = llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>,mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::ODIX::SymbolAttr>(*(a1 + 400), *(a1 + 416), v43, &v46);
  v25 = v46;
  if ((v24 & 1) == 0)
  {
    v47 = v46;
    v26 = *(a1 + 408);
    v27 = *(a1 + 416);
    if (4 * v26 + 4 >= 3 * v27)
    {
      v27 *= 2;
    }

    else if (v27 + ~v26 - *(a1 + 412) > v27 >> 3)
    {
LABEL_24:
      *(a1 + 408) = v26 + 1;
      if (*v25 != -4096)
      {
        --*(a1 + 412);
      }

      *v25 = v43;
      *(v25 + 8) = 0;
      goto LABEL_27;
    }

    llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::grow(a1 + 400, v27);
    llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>,mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::ODIX::SymbolAttr>(*(a1 + 400), *(a1 + 416), v43, &v47);
    v26 = *(a1 + 408);
    v25 = v47;
    goto LABEL_24;
  }

LABEL_27:
  *(v25 + 8) = v9;
  v29 = *(a1 + 384);
  v28 = *(a1 + 392);
  if (v29 >= v28)
  {
    v31 = *(a1 + 376);
    v32 = v29 - v31;
    v33 = (v29 - v31) >> 2;
    v34 = v33 + 1;
    if ((v33 + 1) >> 62)
    {
      std::vector<flatbuffers::Offset<ODIE_FB::Symbol>>::__throw_length_error[abi:nn200100]();
    }

    v35 = v28 - v31;
    if (v35 >> 1 > v34)
    {
      v34 = v35 >> 1;
    }

    if (v35 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v36 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v36 = v34;
    }

    if (v36)
    {
      if (!(v36 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v37 = (v29 - v31) >> 2;
    v38 = (4 * v33);
    v39 = (4 * v33 - 4 * v37);
    *v38 = v23;
    v30 = v38 + 1;
    memcpy(v39, v31, v32);
    *(a1 + 376) = v39;
    *(a1 + 384) = v30;
    *(a1 + 392) = 0;
    if (v31)
    {
      operator delete(v31);
    }
  }

  else
  {
    *v29 = v23;
    v30 = v29 + 4;
  }

  *(a1 + 384) = v30;
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }

  if (v45.__begin_)
  {
    v45.__end_ = v45.__begin_;
    operator delete(v45.__begin_);
  }

  return v9 | 0x100000000;
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(uint64_t a1, uint64_t a2, char a3, int a4)
{
  v9 = *(a1 + 240);
  v8 = *(a1 + 248);
  if (v9 >= v8)
  {
    v11 = *(a1 + 232);
    v12 = (v9 - v11);
    v13 = v9 - v11 + 1;
    if (v13 < 0)
    {
      std::vector<ODIE_FB::Attribute>::__throw_length_error[abi:nn200100]();
    }

    v14 = v8 - v11;
    if (2 * v14 > v13)
    {
      v13 = 2 * v14;
    }

    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v15 = v13;
    }

    if (v15)
    {
      operator new();
    }

    v16 = v9 - v11;
    *v12 = a3;
    v10 = v12 + 1;
    memcpy(0, v11, v16);
    *(a1 + 232) = 0;
    *(a1 + 240) = v12 + 1;
    *(a1 + 248) = 0;
    if (v11)
    {
      operator delete(v11);
    }
  }

  else
  {
    *v9 = a3;
    v10 = v9 + 1;
  }

  *(a1 + 240) = v10;
  v18 = *(a1 + 264);
  v17 = *(a1 + 272);
  if (v18 >= v17)
  {
    v20 = *(a1 + 256);
    v21 = v18 - v20;
    v22 = (v18 - v20) >> 2;
    v23 = v22 + 1;
    if ((v22 + 1) >> 62)
    {
      std::vector<flatbuffers::Offset<void>>::__throw_length_error[abi:nn200100]();
    }

    v24 = v17 - v20;
    if (v24 >> 1 > v23)
    {
      v23 = v24 >> 1;
    }

    if (v24 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v25 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v25 = v23;
    }

    if (v25)
    {
      if (!(v25 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v26 = (v18 - v20) >> 2;
    v27 = (4 * v22);
    v28 = (4 * v22 - 4 * v26);
    *v27 = a4;
    v19 = v27 + 1;
    memcpy(v28, v20, v21);
    *(a1 + 256) = v28;
    *(a1 + 264) = v19;
    *(a1 + 272) = 0;
    if (v20)
    {
      operator delete(v20);
    }
  }

  else
  {
    *v18 = a4;
    v19 = v18 + 4;
  }

  *(a1 + 264) = v19;
  v29 = *(a1 + 256);
  v35 = 0;
  v30 = llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>,mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::LookupBucketFor<mlir::Attribute>(*(a1 + 280), *(a1 + 296), a2, &v35);
  v31 = v35;
  if ((v30 & 1) == 0)
  {
    v36 = v35;
    v32 = *(a1 + 288);
    v33 = *(a1 + 296);
    if (4 * v32 + 4 >= 3 * v33)
    {
      v33 *= 2;
    }

    else if (v33 + ~v32 - *(a1 + 292) > v33 >> 3)
    {
LABEL_29:
      *(a1 + 288) = v32 + 1;
      if (*v31 != -4096)
      {
        --*(a1 + 292);
      }

      *v31 = a2;
      *(v31 + 8) = 0;
      goto LABEL_32;
    }

    llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::grow(a1 + 280, v33);
    llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>,mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::LookupBucketFor<mlir::Attribute>(*(a1 + 280), *(a1 + 296), a2, &v36);
    v32 = *(a1 + 288);
    v31 = v36;
    goto LABEL_29;
  }

LABEL_32:
  result = ((v19 - v29) >> 2) - 1;
  *(v31 + 8) = result;
  return result;
}

uint64_t anonymous namespace::getU64Value(uint64_t a1)
{
  v8 = a1;
  v1 = *(a1 + 8);
  if (*(*v1 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    goto LABEL_2;
  }

  v2 = v1[2] & 0xC0000000;
  if (v2 == 0x80000000)
  {
    return mlir::IntegerAttr::getUInt(&v8);
  }

  if (v2 == 0x40000000)
  {
    return mlir::IntegerAttr::getSInt(&v8);
  }

LABEL_2:
  v7 = *(a1 + 24);
  if (v7 > 0x40)
  {
    operator new[]();
  }

  v6 = *(a1 + 16);
  LimitedValue = llvm::APInt::getLimitedValue(&v6, 0xFFFFFFFFFFFFFFFFLL);
  if (v7 >= 0x41 && v6)
  {
    MEMORY[0x25F891010](v6, 0x1000C8000313F17);
  }

  return LimitedValue;
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::TypeAttr>(uint64_t a1, uint64_t a2)
{
  v4 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addTypeToProgram(a1, *(a2 + 8));
  *(a1 + 144) = 1;
  v5 = *(a1 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 4, v4);
  v6 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v5);

  return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 6, v6);
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::DenseArrayAttr>(uint64_t a1, uint64_t a2)
{
  v5 = *(a2 + 24);
  v4 = *(a2 + 32);
  *(a1 + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(a1 + 48, v4);
  if (v4)
  {
    if (!*(a1 + 152))
    {
      *(a1 + 152) = 1;
    }

    flatbuffers::FlatBufferBuilderImpl<false>::PushBytes((a1 + 48), v5, v4);
  }

  *(a1 + 144) = 0;
  v6 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(a1 + 48, v4);
  *(a1 + 144) = 1;
  v7 = *(a1 + 96);
  if (v6)
  {
    v8 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(a1 + 48, v6);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(a1 + 48, 4, v8);
  }

  v9 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v7);

  return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 5, v9);
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::ODIE::Compiler::ODIX::EnumAttr>(uint64_t a1, uint64_t a2)
{
  v5 = *(a2 + 8);
  v4 = *(a2 + 16);
  v6 = *(v4 + 16);
  if (v6)
  {
    v7 = strlen(*(v4 + 16));
    flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((a1 + 48), v6, v7);
    v8 = *(a1 + 96);
    v9 = v8;
  }

  else
  {
    v9 = 0;
    v8 = *(a1 + 96);
  }

  *(a1 + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<long long>(a1 + 48, v5);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(a1 + 48, 6, v9);
  v10 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v8);

  return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 8, v10);
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttributeSpecific<mlir::UnitAttr>(uint64_t a1, uint64_t a2)
{
  *(a1 + 144) = 1;
  v4 = *(a1 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(a1 + 48, 4, 1);
  v5 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(a1 + 48, v4);

  return mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::appendAttributeToProgramTables(a1, a2, 9, v5);
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeJumpOp(uint64_t *a1, uint64_t a2)
{
  v21.__begin_ = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  UInt = mlir::IntegerAttr::getUInt(&v21);
  v5 = *a1;
  *(v5 + 144) = 1;
  v6 = *(v5 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v5 + 48, 4, UInt);
  v7 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v5 + 48, v6);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v21, a1[1], 0, 0);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v20, a1[1], 0, 0);
  v8 = *a1;
  v18 = 0;
  v19 = 0;
  __p = 0;
  v23 = *(a2 + 24);
  v22[0] = v8;
  v22[1] = &__p;
  mlir::LocationAttr::walk(&v23, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, v22);
  v9 = *a1;
  if (v21.__end_ == v21.__begin_)
  {
    begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    begin = v21.__begin_;
  }

  v11 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v9 + 48, begin, v21.__end_ - v21.__begin_);
  if (v20.__end_ == v20.__begin_)
  {
    v12 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v12 = v20.__begin_;
  }

  v13 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v9 + 48, v12, v20.__end_ - v20.__begin_);
  if (v18 == __p)
  {
    v14 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v14 = __p;
  }

  v15 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v9 + 48, v14, (v18 - __p) >> 2);
  *(v9 + 144) = 1;
  v16 = *(v9 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v9 + 48, 12, v15);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v9 + 48, 10, v13);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v9 + 48, 8, v11);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v9 + 48, v7);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v9 + 48, 4, 1);
  LODWORD(v22[0]) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v9 + 48, v16);
  std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((a1 + 3), v22);
  if (__p)
  {
    v18 = __p;
    operator delete(__p);
  }

  if (v20.__begin_)
  {
    v20.__end_ = v20.__begin_;
    operator delete(v20.__begin_);
  }

  if (v21.__begin_)
  {
    v21.__end_ = v21.__begin_;
    operator delete(v21.__begin_);
  }
}

BOOL mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeCallOp(uint64_t *a1, uint64_t a2)
{
  v45 = *MEMORY[0x277D85DE8];
  v4 = a2 + 64;
  v5 = *(*(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1) + 8) + 8);
  v6 = mlir::SymbolTable::lookup((*a1 + 8), *(v5 + 16), *(v5 + 24));
  if (v6 && *(*(v6 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::SymbolOp,void>::id)
  {
    v10 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addSymbolToProgram(*a1, *(v6 + 16 * ((*(v6 + 44) >> 23) & 1) + 72));
    v11 = *a1;
    v12 = *(v4 + 16 * ((*(a2 + 44) >> 23) & 1) + 16) != 0;
    *(v11 + 144) = 1;
    v13 = *(v11 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v11 + 48, 4, v10);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v11 + 48, 6, v12);
    v14 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v11 + 48, v13);
    v15 = *(a2 + 44);
    v16 = v4 + 16 * ((v15 >> 23) & 1);
    v17 = *(v16 + 32);
    if ((v15 & 0x800000) != 0)
    {
      v18 = *(a2 + 72);
      v19 = v18 & 0xFFFFFFFFFFFFFFF9 | 2;
    }

    else
    {
      v18 = 0;
      v19 = 2;
    }

    v20 = (*(v16 + 36) + v17) - v17;
    v21 = (v18 + 32 * v17) & 0xFFFFFFFFFFFFFFF9;
    v22 = v14;
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(v43, a1[1], v19, v17);
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v39, a1[1], v21 | 2, v20);
    v23 = *a1;
    v36 = 0;
    v37 = 0;
    __p = 0;
    v24 = *(a2 + 24);
    v41[0] = v23;
    v41[1] = &__p;
    v42 = v24;
    mlir::LocationAttr::walk(&v42, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, v41);
    v25 = *a1;
    if (v43[0].__end_ == v43[0].__begin_)
    {
      begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      begin = v43[0].__begin_;
    }

    v27 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v25 + 48, begin, v43[0].__end_ - v43[0].__begin_);
    if (v39.__end_ == v39.__begin_)
    {
      v28 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v28 = v39.__begin_;
    }

    v29 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v25 + 48, v28, v39.__end_ - v39.__begin_);
    if (v36 == __p)
    {
      v30 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v30 = __p;
    }

    v31 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v25 + 48, v30, (v36 - __p) >> 2);
    *(v25 + 144) = 1;
    v32 = *(v25 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v25 + 48, 12, v31);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v25 + 48, 10, v29);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v25 + 48, 8, v27);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v25 + 48, v22);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v25 + 48, 4, 7);
    LODWORD(v41[0]) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v25 + 48, v32);
    std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((a1 + 3), v41);
    if (__p)
    {
      v36 = __p;
      operator delete(__p);
    }

    if (v39.__begin_)
    {
      v39.__end_ = v39.__begin_;
      operator delete(v39.__begin_);
    }

    if (v43[0].__begin_)
    {
      v43[0].__end_ = v43[0].__begin_;
      operator delete(v43[0].__begin_);
    }

    v9 = 1;
  }

  else
  {
    __p = "callee '";
    v38 = 259;
    mlir::Operation::emitError(v43, a2, &__p);
    if (v43[0].__begin_)
    {
      v7 = *(*(*(v4 + 16 * ((*(a2 + 44) >> 23) & 1) + 8) + 8) + 16);
      v8 = *(*(*(v4 + 16 * ((*(a2 + 44) >> 23) & 1) + 8) + 8) + 24);
      v40 = 261;
      v39.__begin_ = v7;
      v39.__end_ = v8;
      mlir::Diagnostic::operator<<(&v43[0].__end_, &v39);
      if (v43[0].__begin_)
      {
        mlir::Diagnostic::operator<<<17ul>(&v43[0].__end_, " of unknown kind");
      }
    }

    v9 = (v44 & 1) == 0;
    mlir::InFlightDiagnostic::~InFlightDiagnostic(v43);
  }

  v33 = *MEMORY[0x277D85DE8];
  return v9;
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeAsyncInvokeRegionOp(uint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  v5 = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  v6 = *(*llvm::StringMap<std::pair<mlir::ODIE::Compiler::ODIX::RegionOp,unsigned int>,llvm::MallocAllocator>::find(a1[1] + 64, *(v5 + 16), *(v5 + 24)) + 16);
  *(v4 + 144) = 1;
  v7 = *(v4 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 4, v6);
  v8 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v4 + 48, v7);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v22, a1[1], 0, 0);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v21, a1[1], 0, 0);
  v9 = *a1;
  v19 = 0;
  v20 = 0;
  __p = 0;
  v24 = *(a2 + 24);
  v23[0] = v9;
  v23[1] = &__p;
  mlir::LocationAttr::walk(&v24, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, v23);
  v10 = *a1;
  if (v22.__end_ == v22.__begin_)
  {
    begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    begin = v22.__begin_;
  }

  v12 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v10 + 48, begin, v22.__end_ - v22.__begin_);
  if (v21.__end_ == v21.__begin_)
  {
    v13 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v13 = v21.__begin_;
  }

  v14 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v10 + 48, v13, v21.__end_ - v21.__begin_);
  if (v19 == __p)
  {
    v15 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v15 = __p;
  }

  v16 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v10 + 48, v15, (v19 - __p) >> 2);
  *(v10 + 144) = 1;
  v17 = *(v10 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v10 + 48, 12, v16);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v10 + 48, 10, v14);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v10 + 48, 8, v12);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v10 + 48, v8);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v10 + 48, 4, 8);
  LODWORD(v23[0]) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v10 + 48, v17);
  std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((a1 + 3), v23);
  if (__p)
  {
    v19 = __p;
    operator delete(__p);
  }

  if (v21.__begin_)
  {
    v21.__end_ = v21.__begin_;
    operator delete(v21.__begin_);
  }

  if (v22.__begin_)
  {
    v22.__end_ = v22.__begin_;
    operator delete(v22.__begin_);
  }
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeSetContextOp(uint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  v5 = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  v25 = *(v5 + 24);
  if (v25 > 0x40)
  {
    operator new[]();
  }

  v24 = *(v5 + 16);
  LimitedValue = llvm::APInt::getLimitedValue(&v24, 0xFFFFFFFFFFFFFFFFLL);
  *(v4 + 144) = 1;
  v7 = *(v4 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 4, LimitedValue);
  v8 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v4 + 48, v7);
  v9 = *(a2 + 72);
  v10 = *(v9 + 56);
  v22 = *(v9 + 24);
  v23 = v10;
  v11 = v8;
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v30, a1[1], &v23, 1uLL);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v29, a1[1], &v22, 1uLL);
  v12 = *a1;
  v27 = 0;
  v28 = 0;
  __p = 0;
  v13 = *(a2 + 24);
  v31[0] = v12;
  v31[1] = &__p;
  v32 = v13;
  mlir::LocationAttr::walk(&v32, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, v31);
  v14 = *a1;
  if (v30.__end_ == v30.__begin_)
  {
    begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    begin = v30.__begin_;
  }

  v16 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, begin, v30.__end_ - v30.__begin_);
  if (v29.__end_ == v29.__begin_)
  {
    v17 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v17 = v29.__begin_;
  }

  v18 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, v17, v29.__end_ - v29.__begin_);
  if (v27 == __p)
  {
    v19 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v19 = __p;
  }

  v20 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, v19, (v27 - __p) >> 2);
  *(v14 + 144) = 1;
  v21 = *(v14 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 12, v20);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 10, v18);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 8, v16);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v14 + 48, v11);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v14 + 48, 4, 10);
  LODWORD(v31[0]) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v14 + 48, v21);
  std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((a1 + 3), v31);
  if (__p)
  {
    v27 = __p;
    operator delete(__p);
  }

  if (v29.__begin_)
  {
    v29.__end_ = v29.__begin_;
    operator delete(v29.__begin_);
  }

  if (v30.__begin_)
  {
    v30.__end_ = v30.__begin_;
    operator delete(v30.__begin_);
  }

  if (v25 >= 0x41)
  {
    if (v24)
    {
      MEMORY[0x25F891010](v24, 0x1000C8000313F17);
    }
  }
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeGetContextOp(uint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  v5 = *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64);
  v25 = *(v5 + 24);
  if (v25 > 0x40)
  {
    operator new[]();
  }

  v24 = *(v5 + 16);
  LimitedValue = llvm::APInt::getLimitedValue(&v24, 0xFFFFFFFFFFFFFFFFLL);
  *(v4 + 144) = 1;
  v7 = *(v4 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 4, LimitedValue);
  v8 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v4 + 48, v7);
  v9 = *(a2 + 72);
  v10 = *(v9 + 24);
  v22 = *(v9 + 56);
  v23 = v10;
  v11 = v8;
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v30, a1[1], &v23, 1uLL);
  mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v29, a1[1], &v22, 1uLL);
  v12 = *a1;
  v27 = 0;
  v28 = 0;
  __p = 0;
  v13 = *(a2 + 24);
  v31[0] = v12;
  v31[1] = &__p;
  v32 = v13;
  mlir::LocationAttr::walk(&v32, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, v31);
  v14 = *a1;
  if (v30.__end_ == v30.__begin_)
  {
    begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    begin = v30.__begin_;
  }

  v16 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, begin, v30.__end_ - v30.__begin_);
  if (v29.__end_ == v29.__begin_)
  {
    v17 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v17 = v29.__begin_;
  }

  v18 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, v17, v29.__end_ - v29.__begin_);
  if (v27 == __p)
  {
    v19 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  else
  {
    v19 = __p;
  }

  v20 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v14 + 48, v19, (v27 - __p) >> 2);
  *(v14 + 144) = 1;
  v21 = *(v14 + 96);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 12, v20);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 10, v18);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v14 + 48, 8, v16);
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v14 + 48, v11);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v14 + 48, 4, 9);
  LODWORD(v31[0]) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v14 + 48, v21);
  std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((a1 + 3), v31);
  if (__p)
  {
    v27 = __p;
    operator delete(__p);
  }

  if (v29.__begin_)
  {
    v29.__end_ = v29.__begin_;
    operator delete(v29.__begin_);
  }

  if (v30.__begin_)
  {
    v30.__end_ = v30.__begin_;
    operator delete(v30.__begin_);
  }

  if (v25 >= 0x41)
  {
    if (v24)
    {
      MEMORY[0x25F891010](v24, 0x1000C8000313F17);
    }
  }
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::ODIXProgramBuilder(uint64_t a1, unsigned int *a2, const llvm::Twine *a3)
{
  v31[6] = *MEMORY[0x277D85DE8];
  *a1 = a2;
  mlir::SymbolTable::SymbolTable((a1 + 8), a2, a3);
  *(a1 + 48) = 0;
  *(a1 + 56) = 0;
  *(a1 + 64) = 1024;
  *(a1 + 72) = 0x7FFFFFFF;
  *(a1 + 80) = xmmword_25D0A0940;
  *(a1 + 96) = 0;
  *(a1 + 136) = 0;
  *(a1 + 144) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0;
  *(a1 + 104) = 0;
  *(a1 + 126) = 0;
  *(a1 + 152) = 1;
  *(a1 + 160) = 256;
  *(a1 + 168) = 0;
  *(a1 + 176) = 0;
  *(a1 + 184) = 0u;
  *(a1 + 200) = 0u;
  *(a1 + 212) = 0u;
  *(a1 + 232) = 0u;
  *(a1 + 424) = a1 + 440;
  *(a1 + 296) = 0;
  *(a1 + 264) = 0u;
  *(a1 + 280) = 0u;
  *(a1 + 248) = 0u;
  *(a1 + 320) = 0u;
  *(a1 + 304) = 0u;
  *(a1 + 332) = 0u;
  *(a1 + 352) = 0u;
  *(a1 + 368) = 0u;
  *(a1 + 384) = 0u;
  *(a1 + 400) = 0u;
  *(a1 + 416) = 0;
  *(a1 + 432) = 0x600000000;
  *(a1 + 488) = a1 + 504;
  *(a1 + 568) = 0u;
  *(a1 + 496) = 0x100000000;
  *(a1 + 600) = 0u;
  *(a1 + 616) = 0u;
  *(a1 + 584) = 0u;
  *(a1 + 632) = 0;
  *(a1 + 636) = 16;
  *(a1 + 668) = 0u;
  *(a1 + 656) = 0u;
  *(a1 + 640) = 0u;
  *(a1 + 684) = 16;
  v5 = (((&a2[4 * ((a2[11] >> 23) & 1) + 17] + ((a2[11] >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * a2[10]);
  v6 = v5[1];
  if (*v5 == v5)
  {
    goto LABEL_11;
  }

  while (v6 != v5)
  {
    v7 = v6 - 1;
    if (!v6)
    {
      v7 = 0;
    }

    if (v7[4] != v7 + 4)
    {
      break;
    }

    v6 = v6[1];
  }

  if (v6 == v5)
  {
LABEL_11:
    v9 = 0;
  }

  else
  {
    v8 = v6 - 1;
    if (!v6)
    {
      v8 = 0;
    }

    v9 = v8[5];
  }

  v23 = v5;
  *&v21 = v5;
  *(&v21 + 1) = v6;
  *&v22 = v9;
  *(&v22 + 1) = v5;
  v24 = mlir::detail::op_filter_iterator<mlir::ODIE::Compiler::ODIX::DataSegmentOp,mlir::Region::OpIterator>::filter;
  llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v21);
  v26 = v21;
  v27 = v22;
  v28 = v23;
  v29 = v24;
  *&v21 = v5;
  *(&v21 + 1) = v5;
  *&v22 = 0;
  *(&v22 + 1) = v5;
  v23 = v5;
  v24 = mlir::detail::op_filter_iterator<mlir::ODIE::Compiler::ODIX::DataSegmentOp,mlir::Region::OpIterator>::filter;
  llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v21);
  v10 = v22;
  v21 = v26;
  v22 = v27;
  v23 = v28;
  v24 = v29;
  v25 = mlir::detail::op_iterator<mlir::ODIE::Compiler::ODIX::DataSegmentOp,mlir::Region::OpIterator>::unwrap;
  while (v22 != v10)
  {
    v11 = v25();
    v20 = v11;
    v12 = *(a1 + 432);
    if (v12 >= *(a1 + 436))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 424, (a1 + 440), v12 + 1, 8);
      v12 = *(a1 + 432);
    }

    *(*(a1 + 424) + 8 * v12) = v11;
    ++*(a1 + 432);
    v13 = v30;
    mlir::ODIE::Compiler::ODIX::DataSegmentOp::getRecordOffsets(&v20, v30);
    v14 = *(a1 + 496);
    v15 = *(a1 + 488);
    if (v14 >= *(a1 + 500))
    {
      if (v15 <= v30 && v15 + (v14 << 6) > v30)
      {
        v17 = v30 - v15;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<unsigned long long,6u>,false>::grow(a1 + 488, v14 + 1);
        v15 = *(a1 + 488);
        v13 = &v17[v15];
      }

      else
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<unsigned long long,6u>,false>::grow(a1 + 488, v14 + 1);
        v15 = *(a1 + 488);
        v13 = v30;
      }
    }

    v16 = (v15 + (*(a1 + 496) << 6));
    *v16 = v16 + 2;
    v16[1] = 0x600000000;
    if (*(v13 + 2))
    {
      llvm::SmallVectorImpl<unsigned long long>::operator=(v16, v13);
    }

    ++*(a1 + 496);
    if (v30[0] != v31)
    {
      free(v30[0]);
    }

    mlir::Region::OpIterator::operator++(&v21);
    llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v21);
  }

  v18 = *MEMORY[0x277D85DE8];
  return a1;
}

void mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::~ODIXProgramBuilder(mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder *this)
{
  llvm::StringMap<unsigned int,llvm::MallocAllocator>::~StringMap(this + 664);
  v2 = *(this + 80);
  if (v2)
  {
    *(this + 81) = v2;
    operator delete(v2);
  }

  llvm::StringMap<unsigned int,llvm::MallocAllocator>::~StringMap(this + 616);
  v3 = *(this + 74);
  if (v3)
  {
    *(this + 75) = v3;
    operator delete(v3);
  }

  v4 = *(this + 71);
  if (v4)
  {
    *(this + 72) = v4;
    operator delete(v4);
  }

  v5 = *(this + 61);
  v6 = *(this + 124);
  if (v6)
  {
    v7 = &v5[64 * v6 - 64];
    v8 = -64 * v6;
    do
    {
      if (v7 + 2 != *v7)
      {
        free(*v7);
      }

      v7 -= 8;
      v8 += 64;
    }

    while (v8);
    v5 = *(this + 61);
  }

  if (v5 != this + 504)
  {
    free(v5);
  }

  v9 = *(this + 53);
  if (v9 != this + 440)
  {
    free(v9);
  }

  MEMORY[0x25F891030](*(this + 50), 8);
  v10 = *(this + 47);
  if (v10)
  {
    *(this + 48) = v10;
    operator delete(v10);
  }

  v11 = *(this + 44);
  if (v11)
  {
    *(this + 45) = v11;
    operator delete(v11);
  }

  MEMORY[0x25F891030](*(this + 41), 8);
  v12 = *(this + 38);
  if (v12)
  {
    *(this + 39) = v12;
    operator delete(v12);
  }

  MEMORY[0x25F891030](*(this + 35), 8);
  v13 = *(this + 32);
  if (v13)
  {
    *(this + 33) = v13;
    operator delete(v13);
  }

  v14 = *(this + 29);
  if (v14)
  {
    *(this + 30) = v14;
    operator delete(v14);
  }

  MEMORY[0x25F891030](*(this + 26), 8);
  v15 = *(this + 23);
  if (v15)
  {
    *(this + 24) = v15;
    operator delete(v15);
  }

  v16 = *(this + 21);
  if (v16)
  {
    std::__tree<flatbuffers::Offset<flatbuffers::String>,flatbuffers::FlatBufferBuilderImpl<false>::StringOffsetCompare,std::allocator<flatbuffers::Offset<flatbuffers::String>>>::destroy(*(v16 + 8));
    MEMORY[0x25F891040](v16, 0x1060C40C2B13FB5);
  }

  v17 = *(this + 13);
  if (v17)
  {
    v18 = *(this + 6);
    if (v18)
    {
      v19 = *(this + 11);
      (*(*v18 + 24))(v18);
    }

    else
    {
      MEMORY[0x25F891010](v17, 0x1000C8077774924);
    }
  }

  *(this + 13) = 0;
  if (*(this + 56) == 1)
  {
    v20 = *(this + 6);
    if (v20)
    {
      (*(*v20 + 8))(v20);
    }
  }

  *(this + 6) = 0;
  *(this + 56) = 0;
  MEMORY[0x25F891030](*(this + 2), 8);
}

uint64_t mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::finish(mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder *this)
{
  v247 = *MEMORY[0x277D85DE8];
  flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl(this + 6, "myPlatformId", 0xCuLL);
  v2 = *(this + 24);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(this + 48, 4, v2);
  *(this + 44) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(this + 48, v2);
  v3 = *(((*this + 16 * ((*(*this + 44) >> 23) & 1) + ((*(*this + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(*this + 40) + 8);
  if (v3)
  {
    v4 = v3 - 8;
  }

  else
  {
    v4 = 0;
  }

  v5 = v4 + 32;
  v6 = *(v4 + 40);
  if (v6 != v4 + 32)
  {
    v212 = v4 + 32;
    do
    {
      if (*(*(v6 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::FunctionOp,void>::id)
      {
        v7 = (((v6 + 64 + 16 * ((*(v6 + 44) >> 23) & 1) + ((*(v6 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v6 + 40));
        v8 = v7[1];
        if (v8)
        {
          v9 = v8 - 8;
        }

        else
        {
          v9 = 0;
        }

        v209 = *(v9 + 32);
        v210 = v9 + 32;
        v211 = v6 + 64;
        v219 = v6;
        *v220 = this;
        v223 = 0;
        v224 = 0;
        v225 = 0;
        v221 = 0u;
        memset(v222, 0, 28);
        v226 = 24;
        mlir::Region::getOps<mlir::ODIE::Compiler::ODIX::RegionOp>(v7, v244);
        v240 = *&v244[32];
        v241 = *&v244[48];
        v238 = *v244;
        v239 = *&v244[16];
        v242 = *&v244[64];
        *&v244[56] = *&v244[48];
        *&v244[40] = *&v244[32];
        *&v244[24] = *&v244[16];
        *&v244[8] = *v244;
        *v244 = 0;
        v10 = v245;
        v11 = v6;
        v12 = this;
        v214 = v6;
        if (*&v244[24] != v245)
        {
          while (1)
          {
            v13 = *v244;
            v14 = (*&v244[64])();
            v15 = *(v14 + 16 * ((*(v14 + 44) >> 23) & 1) + 64);
            v17 = *(v15 + 16);
            v16 = *(v15 + 24);
            v19 = llvm::xxh3_64bits(v17, v16, v18);
            v20 = llvm::StringMapImpl::LookupBucketFor(&v223, v17, v16, v19);
            v21 = v223;
            v22 = v20;
            v23 = *(v223 + v20);
            if (v23 == -8)
            {
              break;
            }

            if (!v23)
            {
              goto LABEL_15;
            }

LABEL_23:
            *(v23 + 8) = v14;
            *(v23 + 16) = v13;
            ++*v244;
            mlir::Region::OpIterator::operator++(&v244[8]);
            llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v244[8]);
            if (*&v244[24] == v10)
            {
              v11 = v219;
              v12 = *v220;
              v6 = v214;
              goto LABEL_25;
            }
          }

          --v225;
LABEL_15:
          buffer = llvm::allocate_buffer((v16 + 25), 8uLL);
          v25 = buffer;
          v26 = buffer + 24;
          if (v16)
          {
            memcpy(buffer + 24, v17, v16);
          }

          v26[v16] = 0;
          *v25 = v16;
          *(v25 + 1) = 0;
          *(v25 + 4) = 0;
          v21[v22] = v25;
          ++HIDWORD(v224);
          v27 = llvm::StringMapImpl::RehashTable(&v223, v22);
          for (i = (v223 + 8 * v27); ; ++i)
          {
            v23 = *i;
            if (*i && v23 != -8)
            {
              break;
            }
          }

          goto LABEL_23;
        }

LABEL_25:
        v30 = *(*(v11 + 16 * ((*(v11 + 44) >> 23) & 1) + 80) + 8);
        v31 = mlir::SymbolTable::lookup(v12 + 1, *(v30 + 16), *(v30 + 24));
        if (*(*(v31 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::SymbolOp,void>::id)
        {
          v32 = v31;
        }

        else
        {
          v32 = 0;
        }

        v33 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::addSymbolToProgram(*v220, *(v32 + 16 * ((*(v32 + 44) >> 23) & 1) + 72));
        v34 = v219;
        v36 = *(v219 + 40);
        v35 = *(v219 + 44);
        v37 = (v35 >> 23) & 1;
        v38 = (v35 >> 21) & 0x7F8;
        v39 = *(((v219 + 16 * v37 + v38 + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v36 + 8);
        if (v39)
        {
          v40 = (v39 - 8);
        }

        else
        {
          v40 = 0;
        }

        if (v40[4] == v40 + 4)
        {
          v69 = 0;
          v70 = 1;
        }

        else
        {
          v41 = v33;
          v42 = v40[6];
          v43 = v40[7];
          if (v42 != v43)
          {
            do
            {
              v44 = *v42++;
              mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::addRegisterToFunction(&v219, v44);
            }

            while (v42 != v43);
            v34 = v219;
            v36 = *(v219 + 40);
            v45 = *(v219 + 44);
            v37 = (v45 >> 23) & 1;
            v38 = (v45 >> 21) & 0x7F8;
          }

          v46 = (((v34 + 16 * v37 + v38 + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v36);
          v47 = v46[1];
          v208 = v41;
          if (*v46 == v46)
          {
            goto LABEL_45;
          }

          while (v47 != v46)
          {
            v48 = v47 - 1;
            if (!v47)
            {
              v48 = 0;
            }

            if (v48[4] != v48 + 4)
            {
              break;
            }

            v47 = v47[1];
          }

          if (v47 == v46)
          {
LABEL_45:
            v50 = 0;
          }

          else
          {
            v49 = v47 - 1;
            if (!v47)
            {
              v49 = 0;
            }

            v50 = v49[5];
          }

          *&v244[32] = v46;
          *&v244[40] = 0;
          *v244 = v46;
          *&v244[8] = v47;
          *&v244[16] = v50;
          *&v244[24] = v46;
          *&v244[48] = mlir::detail::op_filter_iterator<mlir::ODIE::Compiler::ODIX::ValueOp,mlir::Region::OpIterator>::filter;
          llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(v244);
          v238 = *v244;
          v239 = *&v244[16];
          v240 = *&v244[32];
          *&v241 = *&v244[48];
          *v244 = v46;
          *&v244[8] = v46;
          *&v244[16] = 0;
          *&v244[24] = v46;
          *&v244[32] = v46;
          *&v244[40] = 0;
          *&v244[48] = mlir::detail::op_filter_iterator<mlir::ODIE::Compiler::ODIX::ValueOp,mlir::Region::OpIterator>::filter;
          llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(v244);
          v51 = *&v244[16];
          *v244 = v238;
          *&v244[16] = v239;
          *&v244[32] = v240;
          *&v244[48] = v241;
          *&v244[56] = mlir::detail::op_iterator<mlir::ODIE::Compiler::ODIX::ValueOp,mlir::Region::OpIterator>::unwrap;
          while (*&v244[16] != v51)
          {
            v52 = (*&v244[56])();
            mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::addRegisterToFunction(&v219, v52 - 16);
            mlir::Region::OpIterator::operator++(v244);
            llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(v244);
          }

          mlir::Region::getOps<mlir::ODIE::Compiler::ODIX::RegionOp>((((v219 + 16 * ((*(v219 + 44) >> 23) & 1) + ((*(v219 + 44) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(v219 + 40)), &v238);
          v227 = v238;
          v228 = v239;
          v229 = v240;
          v230 = v241;
          v217 = v243;
          if (v239 == v243)
          {
            v53 = 0;
LABEL_72:
            v71 = *v220;
            if (*(&v221 + 1) == v221)
            {
              v72 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
            }

            else
            {
              v72 = v221;
            }

            v73 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(*v220 + 48, v72, (*(&v221 + 1) - v221) >> 2);
            *(v71 + 144) = 1;
            flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(v71 + 48, v53);
            if (v53)
            {
              v74 = 0;
            }

            else
            {
              v74 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
            }

            if (v53)
            {
              if (*(v71 + 152) <= 3uLL)
              {
                *(v71 + 152) = 4;
              }

              v75 = v53 >> 2;
              flatbuffers::vector_downward<unsigned int>::fill(v71 + 48, -*(v71 + 96) & 3);
              v76 = v74 - 4;
              do
              {
                v77 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(v71 + 48, *&v76[4 * v75]);
                flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(v71 + 48, v77);
                --v75;
              }

              while (v75);
            }

            *(v71 + 144) = 0;
            v78 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(v71 + 48, v53 >> 2);
            *(v71 + 144) = 1;
            v79 = *(v71 + 96);
            if (v78)
            {
              v80 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(v71 + 48, v78);
              flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v71 + 48, 8, v80);
            }

            flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v71 + 48, 6, v73);
            flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v71 + 48, 4, v208);
            v69 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v71 + 48, v79) << 32;
            v70 = 1;
          }

          else
          {
            v53 = 0;
            while (1)
            {
              v54 = (*(&v230 + 1))();
              v231[0] = *v220;
              v231[1] = &v219;
              v232 = v54;
              v234 = 0;
              v235 = 0;
              __p = 0;
              *v244 = v231;
              if (mlir::detail::walk<mlir::ForwardIterator>(v54, llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::finish(void)::$_0>, v244, 1))
              {
                v55 = v231[0];
                v56 = __p;
                v57 = v234;
                v58 = v234 - __p;
                *(v231[0] + 144) = 1;
                flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(v55 + 48, v58);
                v59 = v57 - v56;
                if (v59)
                {
                  if (*(v55 + 152) <= 3uLL)
                  {
                    *(v55 + 152) = 4;
                  }

                  v60 = v59 >> 2;
                  flatbuffers::vector_downward<unsigned int>::fill(v55 + 48, -*(v55 + 96) & 3);
                  v61 = v56 - 4;
                  do
                  {
                    v62 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(v55 + 48, *&v61[4 * v60]);
                    flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(v55 + 48, v62);
                    --v60;
                  }

                  while (v60);
                }

                *(v55 + 144) = 0;
                v63 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(v55 + 48, v59 >> 2);
                *(v55 + 144) = 1;
                v64 = *(v55 + 96);
                if (v63)
                {
                  v65 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(v55 + 48, v63);
                  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v55 + 48, 4, v65);
                }

                v66 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v55 + 48, v64) | 0x100000000;
              }

              else
              {
                v236 = "Unable to process region op.";
                v237 = 259;
                mlir::Operation::emitError(v244, v232, &v236);
                mlir::InFlightDiagnostic::~InFlightDiagnostic(v244);
                v66 = 0;
              }

              if (__p)
              {
                v234 = __p;
                operator delete(__p);
              }

              if ((v66 & 0x100000000) == 0)
              {
                break;
              }

              v67 = v53;
              v68 = v53 >> 2;
              if (((v53 >> 2) + 1) >> 62)
              {
                std::vector<flatbuffers::Offset<ODIE_FB::Region>>::__throw_length_error[abi:nn200100]();
              }

              if (v53 >> 2 != -1)
              {
                if (!(((v53 >> 2) + 1) >> 62))
                {
                  operator new();
                }

                goto LABEL_230;
              }

              *(4 * v68) = v66;
              v53 = 4 * v68 + 4;
              memcpy(0, 0, v67);
              mlir::Region::OpIterator::operator++(&v227);
              llvm::filter_iterator_base<mlir::Region::OpIterator,BOOL (*)(mlir::Operation &),std::forward_iterator_tag>::findNextValid(&v227);
              if (v228 == v217)
              {
                goto LABEL_72;
              }
            }

            v231[0] = "Unable to serialize chain op to ODIX.";
            LOWORD(v234) = 259;
            mlir::Operation::emitOpError(v54, v231, v244);
            mlir::InFlightDiagnostic::~InFlightDiagnostic(v244);
            v70 = 0;
            v69 = 0;
          }

          v6 = v214;
        }

        if (HIDWORD(v224) && v224)
        {
          v81 = 0;
          v82 = 8 * v224;
          do
          {
            v83 = *(v223 + v81);
            if (v83 != -8 && v83 != 0)
            {
              MEMORY[0x25F891030]();
            }

            v81 += 8;
          }

          while (v82 != v81);
        }

        free(v223);
        MEMORY[0x25F891030](v222[1], 8);
        if (v221)
        {
          *(&v221 + 1) = v221;
          operator delete(v221);
        }

        if ((v70 | v69))
        {
          v5 = v212;
          if ((v70 | v69) >> 32)
          {
            if (v209 != v210)
            {
              *v244 = (*(this + 39) - *(this + 38)) >> 2;
              std::vector<unsigned int>::push_back[abi:nn200100](this + 44, v244);
            }

            v86 = *(this + 38);
            v85 = *(this + 39);
            *&v238 = *(*(v211 + 16 * ((*(v6 + 44) >> 23) & 1) + 16) + 8);
            *v244 = 0;
            v87 = llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,unsigned int,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,unsigned int>>,mlir::StringAttr,unsigned int,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,unsigned int>>::LookupBucketFor<mlir::StringAttr>(this + 41, &v238, v244);
            v88 = *v244;
            if ((v87 & 1) == 0)
            {
              v88 = llvm::DenseMapBase<llvm::DenseMap<mlir::StringAttr,unsigned int,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,unsigned int>>,mlir::StringAttr,unsigned int,llvm::DenseMapInfo<mlir::StringAttr,void>,llvm::detail::DenseMapPair<mlir::StringAttr,unsigned int>>::InsertIntoBucketImpl<mlir::StringAttr>(this + 328, &v238, *v244);
              *v88 = v238;
              *(v88 + 2) = 0;
            }

            v89 = HIDWORD(v69);
            *(v88 + 2) = (v85 - v86) >> 2;
            v91 = *(this + 39);
            v90 = *(this + 40);
            if (v91 >= v90)
            {
              v94 = *(this + 38);
              v95 = v91 - v94;
              v96 = (v91 - v94) >> 2;
              v97 = v96 + 1;
              if ((v96 + 1) >> 62)
              {
                std::vector<flatbuffers::Offset<ODIE_FB::Function>>::__throw_length_error[abi:nn200100]();
              }

              v98 = v90 - v94;
              if (v98 >> 1 > v97)
              {
                v97 = v98 >> 1;
              }

              if (v98 >= 0x7FFFFFFFFFFFFFFCLL)
              {
                v99 = 0x3FFFFFFFFFFFFFFFLL;
              }

              else
              {
                v99 = v97;
              }

              if (v99)
              {
                if (!(v99 >> 62))
                {
                  operator new();
                }

LABEL_230:
                std::__throw_bad_array_new_length[abi:nn200100]();
              }

              v100 = v96;
              v101 = (4 * v96);
              v102 = &v101[-v100];
              *v101 = v89;
              v92 = v101 + 1;
              memcpy(v102, v94, v95);
              *(this + 38) = v102;
              *(this + 39) = v92;
              *(this + 40) = 0;
              if (v94)
              {
                operator delete(v94);
              }
            }

            else
            {
              *v91 = v89;
              v92 = v91 + 4;
            }

            v5 = v212;
            *(this + 39) = v92;
          }
        }

        else
        {
          *&v238 = "Unable to serialize ODIXFunctionBuilder from MLIR function op.";
          LOWORD(v240) = 259;
          mlir::Operation::emitError(v244, v6, &v238);
          v93 = v246;
          mlir::InFlightDiagnostic::~InFlightDiagnostic(v244);
          v5 = v212;
          if (v93)
          {
            result = 0;
            goto LABEL_228;
          }
        }
      }

      v6 = *(v6 + 8);
    }

    while (v6 != v5);
  }

  v103 = *(this + 108);
  if (v103)
  {
    v104 = 0;
    v105 = *(this + 53);
    for (j = 8 * v103; j; j -= 8)
    {
      Size = mlir::ODIE::Compiler::ODIX::DataSegmentOp::getSize(v105);
      *(this + 144) = 1;
      v108 = *(this + 24);
      flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(this + 48, 6, Size);
      flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(this + 48, 4, v104);
      v109 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(this + 48, v108);
      v110 = *(this + 72);
      v111 = *(this + 73);
      if (v110 >= v111)
      {
        v113 = *(this + 71);
        v114 = v110 - v113;
        v115 = (v110 - v113) >> 2;
        v116 = v115 + 1;
        if ((v115 + 1) >> 62)
        {
          std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>::__throw_length_error[abi:nn200100]();
        }

        v117 = v111 - v113;
        if (v117 >> 1 > v116)
        {
          v116 = v117 >> 1;
        }

        if (v117 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v118 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v118 = v116;
        }

        if (v118)
        {
          if (!(v118 >> 62))
          {
            operator new();
          }

          goto LABEL_230;
        }

        v119 = (v110 - v113) >> 2;
        v120 = (4 * v115);
        v121 = (4 * v115 - 4 * v119);
        *v120 = v109;
        v112 = v120 + 1;
        memcpy(v121, v113, v114);
        *(this + 71) = v121;
        *(this + 72) = v112;
        *(this + 73) = 0;
        if (v113)
        {
          operator delete(v113);
        }
      }

      else
      {
        *v110 = v109;
        v112 = v110 + 4;
      }

      *(this + 72) = v112;
      v104 += mlir::ODIE::Compiler::ODIX::DataSegmentOp::getSize(v105);
      v105 = (v105 + 8);
    }
  }

  AttrDictionary = mlir::Operation::getAttrDictionary(*this);
  v218 = mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::encodeAttribute(this, AttrDictionary);
  v124 = *(this + 23);
  v123 = *(this + 24);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v123 - v124);
  v125 = v123 - v124;
  if (v125)
  {
    v126 = v124;
  }

  else
  {
    v126 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
  }

  if (v125)
  {
    v127 = v125 >> 2;
    if (*(this + 19) <= 3uLL)
    {
      *(this + 19) = 4;
    }

    flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
    v128 = v126 - 4;
    do
    {
      v129 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v128[4 * v127]);
      flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v129);
      --v127;
    }

    while (v127);
  }

  *(this + 144) = 0;
  v130 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v125 >> 2);
  v132 = *(this + 29);
  v131 = *(this + 30);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v131 - v132);
  v133 = v131 - v132;
  if (v133)
  {
    if (!*(this + 19))
    {
      *(this + 19) = 1;
    }

    flatbuffers::FlatBufferBuilderImpl<false>::PushBytes(this + 6, v132, v133);
  }

  *(this + 144) = 0;
  v134 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v133);
  v136 = *(this + 32);
  v135 = *(this + 33);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v135 - v136);
  v137 = v135 - v136;
  if (v137)
  {
    v138 = v136;
  }

  else
  {
    v138 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
  }

  if (v137)
  {
    v139 = v137 >> 2;
    if (*(this + 19) <= 3uLL)
    {
      *(this + 19) = 4;
    }

    flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
    v140 = v138 - 4;
    do
    {
      v141 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v140[4 * v139]);
      flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v141);
      --v139;
    }

    while (v139);
  }

  *(this + 144) = 0;
  v142 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v137 >> 2);
  v143 = *(this + 47);
  v144 = *(this + 48);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v144 - v143);
  v146 = v144 - v143;
  v145 = v144 == v143;
  if (v144 == v143)
  {
    v147 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
  }

  else
  {
    v147 = v143;
  }

  if (!v145)
  {
    v148 = v146 >> 2;
    if (*(this + 19) <= 3uLL)
    {
      *(this + 19) = 4;
    }

    flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
    v149 = v147 - 4;
    do
    {
      v150 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v149[4 * v148]);
      flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v150);
      --v148;
    }

    while (v148);
  }

  *(this + 144) = 0;
  v151 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v146 >> 2);
  *(this + 144) = 1;
  v152 = *(this + 24);
  if (v151)
  {
    v153 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v151);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 10, v153);
  }

  if (v142)
  {
    v154 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v142);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 8, v154);
  }

  if (v134)
  {
    v155 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v134);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 6, v155);
  }

  if (v130)
  {
    v156 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v130);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 4, v156);
  }

  v215 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(this + 48, v152);
  v216 = *(this + 44);
  v157 = *(this + 80);
  v158 = *(this + 81);
  v159 = *(this + 74);
  v160 = *(this + 75);
  v161 = *(this + 71);
  v213 = *(this + 72);
  v162 = *(this + 38);
  v163 = *(this + 39);
  *(this + 144) = 1;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v163 - v162);
  v164 = v163 - v162;
  if (v164)
  {
    v165 = v164 >> 2;
    if (*(this + 19) <= 3uLL)
    {
      *(this + 19) = 4;
    }

    flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
    v166 = v162 - 4;
    do
    {
      v167 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *(v166 + 4 * v165));
      flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v167);
      --v165;
    }

    while (v165);
  }

  *(this + 144) = 0;
  v168 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v164 >> 2);
  v169 = *(this + 45) - *(this + 44);
  if (v169)
  {
    v170 = *(this + 44);
  }

  else
  {
    v170 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
  }

  v171 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(this + 48, v170, v169 >> 2);
  if (v157 == v158)
  {
    v179 = 0;
  }

  else
  {
    v172 = *(this + 80);
    v173 = *(this + 81);
    *(this + 144) = 1;
    flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v173 - v172);
    v174 = v173 - v172;
    if (v174)
    {
      v175 = v172;
    }

    else
    {
      v175 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
    }

    if (v174)
    {
      v176 = v174 >> 2;
      if (*(this + 19) <= 3uLL)
      {
        *(this + 19) = 4;
      }

      flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
      v177 = v175 - 4;
      do
      {
        v178 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v177[4 * v176]);
        flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v178);
        --v176;
      }

      while (v176);
    }

    *(this + 144) = 0;
    v179 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v174 >> 2);
  }

  if (v159 == v160)
  {
    v188 = 0;
    v184 = v213;
  }

  else
  {
    v180 = *(this + 74);
    v181 = *(this + 75);
    *(this + 144) = 1;
    flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v181 - v180);
    v182 = v181 - v180;
    if (v182)
    {
      v183 = v180;
    }

    else
    {
      v183 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
    }

    v184 = v213;
    if (v182)
    {
      v185 = v182 >> 2;
      if (*(this + 19) <= 3uLL)
      {
        *(this + 19) = 4;
      }

      flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
      v186 = v183 - 4;
      do
      {
        v187 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v186[4 * v185]);
        flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v187);
        --v185;
      }

      while (v185);
    }

    *(this + 144) = 0;
    v188 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v182 >> 2);
  }

  if (v161 == v184)
  {
    v196 = 0;
  }

  else
  {
    v189 = *(this + 71);
    v190 = *(this + 72);
    *(this + 144) = 1;
    flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(this + 48, v190 - v189);
    v191 = v190 - v189;
    if (v191)
    {
      v192 = v189;
    }

    else
    {
      v192 = &flatbuffers::data<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>,std::allocator<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>>>(std::vector<flatbuffers::Offset<ODIE_FB::DataSegmentInfo>> const&)::t;
    }

    if (v191)
    {
      v193 = v191 >> 2;
      if (*(this + 19) <= 3uLL)
      {
        *(this + 19) = 4;
      }

      flatbuffers::vector_downward<unsigned int>::fill(this + 48, -*(this + 24) & 3);
      v194 = v192 - 4;
      do
      {
        v195 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, *&v194[4 * v193]);
        flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v195);
        --v193;
      }

      while (v193);
    }

    *(this + 144) = 0;
    v196 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v191 >> 2);
  }

  *(this + 144) = 1;
  v197 = *(this + 24);
  flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 18, v218);
  if (v196)
  {
    v198 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v196);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 16, v198);
  }

  if (v188)
  {
    v199 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v188);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 14, v199);
  }

  if (v179)
  {
    v200 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v179);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 12, v200);
  }

  flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(this + 48, 10, v171);
  if (v168)
  {
    v201 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v168);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 8, v201);
  }

  if (v215)
  {
    v202 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v215);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 6, v202);
  }

  if (v216)
  {
    v203 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v216);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(this + 48, 4, v203);
  }

  v204 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(this + 48, v197);
  *(this + 15) = *(this + 13);
  flatbuffers::vector_downward<unsigned int>::fill(this + 48, (-4 - *(this + 24)) & (*(this + 19) - 1));
  v205 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(this + 48, v204);
  flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(this + 48, v205);
  result = 1;
  *(this + 145) = 1;
LABEL_228:
  v206 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl(void *a1, void *a2, size_t a3)
{
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(a1, a3 + 1);
  flatbuffers::vector_downward<unsigned int>::fill(a1, 1uLL);
  flatbuffers::FlatBufferBuilderImpl<false>::PushBytes(a1, a2, a3);

  return flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(a1, a3);
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(result + 104) <= 3uLL)
    {
      *(result + 104) = 4;
    }

    return flatbuffers::vector_downward<unsigned int>::fill(result, (-a2 - *(result + 48)) & 3);
  }

  return result;
}

uint64_t flatbuffers::vector_downward<unsigned int>::fill(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    v3 = result;
    v4 = *(result + 64);
    if ((v4 - *(result + 72)) < a2)
    {
      result = flatbuffers::vector_downward<unsigned int>::reallocate(result, a2);
      v4 = *(v3 + 64);
    }

    v5 = 0;
    *(v3 + 64) = v4 - a2;
    *(v3 + 48) += a2;
    do
    {
      *(*(v3 + 64) + v5++) = 0;
    }

    while (a2 != v5);
  }

  return result;
}

void *flatbuffers::FlatBufferBuilderImpl<false>::PushBytes(void *result, void *__src, size_t __n)
{
  if (__n)
  {
    v5 = result;
    v6 = result[8];
    if ((v6 - *(result + 18)) < __n)
    {
      flatbuffers::vector_downward<unsigned int>::reallocate(result, __n);
      v6 = v5[8];
    }

    v5[8] = v6 - __n;
    *(v5 + 12) += __n;

    return memcpy((v6 - __n), __src, __n);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(uint64_t a1, int a2)
{
  if (*(a1 + 104) <= 3uLL)
  {
    *(a1 + 104) = 4;
  }

  flatbuffers::vector_downward<unsigned int>::fill(a1, -*(a1 + 48) & 3);
  v4 = *(a1 + 64);
  if (((v4 - *(a1 + 72)) & 0xFFFFFFFC) == 0)
  {
    flatbuffers::vector_downward<unsigned int>::reallocate(a1, 4uLL);
    v4 = *(a1 + 64);
  }

  *(a1 + 48) += 4;
  *(v4 - 4) = a2;
  *(a1 + 64) = v4 - 4;
  return *(a1 + 48);
}

uint64_t flatbuffers::vector_downward<unsigned int>::reallocate(uint64_t *a1, unint64_t a2)
{
  v3 = a1[5];
  v4 = *(a1 + 12);
  v5 = a1[7];
  v6 = a1[9] - v5;
  if (v3)
  {
    v7 = v3 >> 1;
  }

  else
  {
    v7 = a1[2];
  }

  if (v7 <= a2)
  {
    v7 = a2;
  }

  v8 = (v3 + a1[4] + v7 - 1) & -a1[4];
  a1[5] = v8;
  v9 = *a1;
  if (v5)
  {
    if (!v9)
    {
      v12 = &unk_286EAA8C0;
      operator new[]();
    }

    result = (*(*v9 + 32))(v9, v5, v3, v8, v4, v6);
  }

  else
  {
    if (!v9)
    {
      v12 = &unk_286EAA8C0;
      operator new[]();
    }

    result = (*(*v9 + 16))(v9, v8);
  }

  v11 = result + a1[5] - v4;
  a1[7] = result;
  a1[8] = v11;
  a1[9] = result + v6;
  return result;
}

char *flatbuffers::Allocator::reallocate_downward(flatbuffers::Allocator *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, size_t a5, size_t a6)
{
  v12 = (*(*this + 16))(this, a4);
  memcpy(&v12[a4 - a5], &a2[a3 - a5], a5);
  memcpy(v12, a2, a6);
  (*(*this + 24))(this, a2, a3);
  return v12;
}

void flatbuffers::DefaultAllocator::deallocate(flatbuffers::DefaultAllocator *this, unsigned __int8 *a2)
{
  if (a2)
  {
    JUMPOUT(0x25F891010);
  }
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    v4 = result;
    v5 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(result, a3);

    return flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4, a2, v5);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(uint64_t result, uint64_t a2, int a3)
{
  v4 = result;
  if (a3 || *(result + 112) == 1)
  {
    v5 = flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(result, a3);

    return flatbuffers::FlatBufferBuilderImpl<false>::TrackField(v4, a2, v5);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(uint64_t a1, int a2)
{
  if (*(a1 + 104) <= 3uLL)
  {
    *(a1 + 104) = 4;
  }

  flatbuffers::vector_downward<unsigned int>::fill(a1, -*(a1 + 48) & 3);
  return (*(a1 + 48) - a2 + 4);
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::TrackField(uint64_t result, uint64_t a2, unsigned int a3)
{
  v5 = result;
  v6 = *(result + 72);
  if (((*(result + 64) - v6) & 0xFFFFFFF8) == 0)
  {
    result = flatbuffers::vector_downward<unsigned int>::reallocate(result, 8uLL);
    v6 = *(v5 + 72);
  }

  *v6 = a3 | (a2 << 32);
  *(v5 + 72) += 8;
  ++*(v5 + 80);
  if (*(v5 + 84) < a2)
  {
    *(v5 + 84) = a2;
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::EndTable(uint64_t a1, __int16 a2)
{
  if (*(a1 + 104) <= 3uLL)
  {
    *(a1 + 104) = 4;
  }

  flatbuffers::vector_downward<unsigned int>::fill(a1, -*(a1 + 48) & 3);
  v4 = *(a1 + 64);
  v5 = *(a1 + 72);
  if (((v4 - v5) & 0xFFFFFFFC) == 0)
  {
    flatbuffers::vector_downward<unsigned int>::reallocate(a1, 4uLL);
    v4 = *(a1 + 64);
    v5 = *(a1 + 72);
  }

  *(a1 + 48) += 4;
  *(v4 - 4) = 0;
  v6 = v4 - 4;
  *(a1 + 64) = v6;
  v7 = *(a1 + 48);
  if ((*(a1 + 84) + 2) <= 4u)
  {
    v8 = 4;
  }

  else
  {
    v8 = (*(a1 + 84) + 2);
  }

  *(a1 + 84) = v8;
  v9 = (v6 - v5);
  v10 = v7;
  if (v9 < v8)
  {
    flatbuffers::vector_downward<unsigned int>::reallocate(a1, v8);
    v6 = *(a1 + 64);
    v10 = *(a1 + 48);
  }

  *(a1 + 64) = v6 - v8;
  *(a1 + 48) = v10 + v8;
  bzero((v6 - v8), v8);
  v11 = v7 - a2;
  v13 = *(a1 + 64);
  v12 = *(a1 + 72);
  v13[1] = v11;
  *v13 = *(a1 + 84);
  v14 = *(a1 + 80);
  v15 = (v12 - 8 * v14);
  if (v14)
  {
    v16 = v12 - 8 * v14;
    do
    {
      v17 = (v7 - *v16);
      *(v13 + *(v16 + 4)) = v7 - *v16;
      v16 += 8;
    }

    while (v16 < v12);
  }

  *(a1 + 72) = v15;
  *(a1 + 80) = 0;
  *(a1 + 84) = 0;
  v18 = *(a1 + 48);
  if ((*(a1 + 113) & 1) == 0)
  {
    goto LABEL_21;
  }

  v19 = *(a1 + 56);
  if (v19 >= v15)
  {
    goto LABEL_21;
  }

  v26 = *(a1 + 48);
  v20 = *v13;
  v21 = *(a1 + 40);
  v22 = v19 + v21;
  v23 = *(a1 + 56);
  while (1)
  {
    v24 = *v23;
    if (v20 == *(v22 - v24) && !memcmp((v22 - v24), v13, v20))
    {
      break;
    }

    if (++v23 >= v15)
    {
      v18 = v26;
      goto LABEL_21;
    }
  }

  v13 = (v13 + v26 - v7);
  *(a1 + 64) = v13;
  *(a1 + 48) = v7;
  v18 = v7;
  if (v24 == v7)
  {
LABEL_21:
    if (((v13 - v15) & 0xFFFFFFFC) == 0)
    {
      flatbuffers::vector_downward<unsigned int>::reallocate(a1, 4uLL);
      v15 = *(a1 + 72);
    }

    *v15 = v18;
    *(a1 + 72) = v15 + 1;
    v19 = *(a1 + 56);
    v21 = *(a1 + 40);
    LODWORD(v24) = v18;
  }

  *(v19 + v21 - (*(a1 + 88) + v7)) = v24 - v7;
  *(a1 + 96) = 0;
  return v7;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(uint64_t result, uint64_t a2, uint64_t a3)
{
  v5 = result;
  if (a3 || *(result + 112) == 1)
  {
    if (*(result + 104) <= 7uLL)
    {
      *(result + 104) = 8;
    }

    flatbuffers::vector_downward<unsigned int>::fill(result, -*(result + 48) & 7);
    v6 = *(v5 + 64);
    if (((v6 - *(v5 + 72)) & 0xFFFFFFF8) == 0)
    {
      flatbuffers::vector_downward<unsigned int>::reallocate(v5, 8uLL);
      v6 = *(v5 + 64);
    }

    *(v6 - 8) = a3;
    *(v5 + 64) = v6 - 8;
    v7 = *(v5 + 48) + 8;
    *(v5 + 48) = v7;

    return flatbuffers::FlatBufferBuilderImpl<false>::TrackField(v5, a2, v7);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(uint64_t a1, void *a2, uint64_t a3)
{
  *(a1 + 96) = 1;
  v6 = 4 * a3;
  flatbuffers::FlatBufferBuilderImpl<false>::PreAlign<unsigned int>(a1, 4 * a3);
  if (a3)
  {
    if (*(a1 + 104) <= 3uLL)
    {
      *(a1 + 104) = 4;
    }

    flatbuffers::vector_downward<unsigned int>::fill(a1, -*(a1 + 48) & 3);
    flatbuffers::FlatBufferBuilderImpl<false>::PushBytes(a1, a2, v6);
  }

  *(a1 + 96) = 0;

  return flatbuffers::FlatBufferBuilderImpl<false>::PushElement<unsigned int,unsigned int>(a1, a3);
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    v4 = result;
    v5 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(result, a3);

    return flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4, a2, v5);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddElement<long long>(uint64_t result, uint64_t a2)
{
  v3 = result;
  if (a2 || *(result + 112) == 1)
  {
    if (*(result + 104) <= 7uLL)
    {
      *(result + 104) = 8;
    }

    flatbuffers::vector_downward<unsigned int>::fill(result, -*(result + 48) & 7);
    v4 = *(v3 + 64);
    if (((v4 - *(v3 + 72)) & 0xFFFFFFF8) == 0)
    {
      flatbuffers::vector_downward<unsigned int>::reallocate(v3, 8uLL);
      v4 = *(v3 + 64);
    }

    *(v4 - 8) = a2;
    *(v3 + 64) = v4 - 8;
    v5 = *(v3 + 48) + 8;
    *(v3 + 48) = v5;

    return flatbuffers::FlatBufferBuilderImpl<false>::TrackField(v3, 4, v5);
  }

  return result;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(uint64_t result, uint64_t a2, int a3)
{
  v3 = a3;
  v5 = result;
  if (a3 || *(result + 112) == 1)
  {
    if (!*(result + 104))
    {
      *(result + 104) = 1;
    }

    v6 = *(result + 64);
    if (v6 == *(result + 72))
    {
      flatbuffers::vector_downward<unsigned int>::reallocate(result, 1uLL);
      v6 = *(v5 + 64);
    }

    *(v5 + 64) = v6 - 1;
    ++*(v5 + 48);
    *(v6 - 1) = v3;
    v7 = *(v5 + 48);

    return flatbuffers::FlatBufferBuilderImpl<false>::TrackField(v5, a2, v7);
  }

  return result;
}

uint64_t llvm::StringMap<std::pair<mlir::ODIE::Compiler::ODIX::RegionOp,unsigned int>,llvm::MallocAllocator>::find(uint64_t a1, unsigned __int8 *a2, const unsigned __int8 *a3)
{
  v6 = llvm::xxh3_64bits(a2, a3, a3);
  Key = llvm::StringMapImpl::FindKey(a1, a2, a3, v6);
  if (Key == -1)
  {
    v8 = *(a1 + 8);
  }

  else
  {
    v8 = Key;
  }

  return *a1 + 8 * v8;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>(uint64_t *a1, uint64_t a2)
{
  if (*(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColRange,void>::id)
  {
    return 1;
  }

  v4 = *a1;
  v79.__r_.__value_.__r.__words[0] = *(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::StringAttr::str(&v79, &v84);
  v5 = *(a2 + 16);
  if ((*(a2 + 8) & 6) != 0)
  {
    v6 = *(a2 + 24);
  }

  else
  {
    v6 = 0;
  }

  v81 = v85;
  *v80 = v84;
  v7 = v84;
  v8 = HIBYTE(v85);
  v9 = SHIBYTE(v85);
  v82 = v5;
  __val = v6;
  std::to_string(&v78, v5);
  if (v9 >= 0)
  {
    v10 = v80;
  }

  else
  {
    v10 = v7;
  }

  if (v9 >= 0)
  {
    v11 = v8;
  }

  else
  {
    v11 = *(&v7 + 1);
  }

  v12 = std::string::insert(&v78, 0, v10, v11);
  v13 = v12->__r_.__value_.__r.__words[2];
  *&v79.__r_.__value_.__l.__data_ = *&v12->__r_.__value_.__l.__data_;
  v79.__r_.__value_.__r.__words[2] = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, __val);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v16 = std::string::append(&v79, p_p, size);
  v17 = v16->__r_.__value_.__r.__words[2];
  v84 = *&v16->__r_.__value_.__l.__data_;
  v85 = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v79.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v78.__r_.__value_.__l.__data_);
  }

  if (v85 >= 0)
  {
    v18 = &v84;
  }

  else
  {
    v18 = v84;
  }

  if (v85 >= 0)
  {
    v19 = SHIBYTE(v85);
  }

  else
  {
    v19 = *(&v84 + 1);
  }

  v20 = llvm::StringMap<unsigned int,llvm::MallocAllocator>::find(v4 + 616, v18, v19);
  if (*(v4 + 616) + 8 * *(v4 + 624) == v20)
  {
    v22 = v80;
    if (v81 >= 0)
    {
      v23 = v80;
    }

    else
    {
      v23 = v80[0];
    }

    if (v81 >= 0)
    {
      v24 = SHIBYTE(v81);
    }

    else
    {
      v24 = v80[1];
    }

    v25 = llvm::StringMap<unsigned int,llvm::MallocAllocator>::find(v4 + 664, v23, v24);
    if (*(v4 + 664) + 8 * *(v4 + 672) == v25)
    {
      v27 = (*(v4 + 648) - *(v4 + 640)) >> 2;
      if (v81 >= 0)
      {
        v28 = v80;
      }

      else
      {
        v28 = v80[0];
      }

      if (v81 >= 0)
      {
        v29 = SHIBYTE(v81);
      }

      else
      {
        v29 = v80[1];
      }

      v30 = llvm::xxh3_64bits(v28, v29, v26);
      *(*llvm::StringMap<unsigned int,llvm::MallocAllocator>::try_emplace_with_hash<>((v4 + 664), v28, v29, v30) + 8) = v27;
      if (SHIBYTE(v81) < 0 && (v22 = v80[0]) == 0)
      {
        v33 = 0;
        v32 = *(v4 + 96);
      }

      else
      {
        v31 = strlen(v22);
        flatbuffers::FlatBufferBuilderImpl<false>::CreateStringImpl((v4 + 48), v22, v31);
        v32 = *(v4 + 96);
        v33 = v32;
      }

      *(v4 + 144) = 1;
      flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::String>(v4 + 48, 4, v33);
      v34 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v4 + 48, v32);
      v36 = *(v4 + 648);
      v37 = *(v4 + 656);
      if (v36 >= v37)
      {
        v39 = *(v4 + 640);
        v40 = v36 - v39;
        v41 = (v36 - v39) >> 2;
        v42 = v41 + 1;
        if ((v41 + 1) >> 62)
        {
          std::vector<flatbuffers::Offset<ODIE_FB::Filename>>::__throw_length_error[abi:nn200100]();
        }

        v43 = v37 - v39;
        if (v43 >> 1 > v42)
        {
          v42 = v43 >> 1;
        }

        if (v43 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v44 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v44 = v42;
        }

        if (v44)
        {
          if (!(v44 >> 62))
          {
            operator new();
          }

          goto LABEL_100;
        }

        v45 = (v36 - v39) >> 2;
        v46 = (4 * v41);
        v47 = (4 * v41 - 4 * v45);
        *v46 = v34;
        v38 = v46 + 1;
        memcpy(v47, v39, v40);
        *(v4 + 640) = v47;
        *(v4 + 648) = v38;
        *(v4 + 656) = 0;
        if (v39)
        {
          operator delete(v39);
        }
      }

      else
      {
        *v36 = v34;
        v38 = v36 + 4;
      }

      *(v4 + 648) = v38;
      if (v81 >= 0)
      {
        v48 = v80;
      }

      else
      {
        v48 = v80[0];
      }

      if (v81 >= 0)
      {
        v49 = SHIBYTE(v81);
      }

      else
      {
        v49 = v80[1];
      }

      v50 = llvm::xxh3_64bits(v48, v49, v35);
      v25 = llvm::StringMap<unsigned int,llvm::MallocAllocator>::try_emplace_with_hash<>((v4 + 664), v48, v49, v50);
    }

    v51 = *(*v25 + 8);
    v52 = (*(v4 + 600) - *(v4 + 592)) >> 2;
    if (v85 >= 0)
    {
      v53 = &v84;
    }

    else
    {
      v53 = v84;
    }

    if (v85 >= 0)
    {
      v54 = SHIBYTE(v85);
    }

    else
    {
      v54 = *(&v84 + 1);
    }

    v55 = llvm::xxh3_64bits(v53, v54, v26);
    *(*llvm::StringMap<unsigned int,llvm::MallocAllocator>::try_emplace_with_hash<>((v4 + 616), v53, v54, v55) + 8) = v52;
    v57 = v82;
    v56 = __val;
    *(v4 + 144) = 1;
    v58 = *(v4 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 8, v56);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 6, v57);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v4 + 48, 4, v51);
    v59 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v4 + 48, v58);
    v61 = *(v4 + 600);
    v62 = *(v4 + 608);
    if (v61 < v62)
    {
      *v61 = v59;
      v63 = v61 + 4;
LABEL_86:
      *(v4 + 600) = v63;
      v21 = a1[1];
      if (v85 >= 0)
      {
        v73 = &v84;
      }

      else
      {
        v73 = v84;
      }

      if (v85 >= 0)
      {
        v74 = SHIBYTE(v85);
      }

      else
      {
        v74 = *(&v84 + 1);
      }

      v75 = llvm::xxh3_64bits(v73, v74, v60);
      v20 = llvm::StringMap<unsigned int,llvm::MallocAllocator>::try_emplace_with_hash<>((v4 + 616), v73, v74, v75);
      goto LABEL_93;
    }

    v64 = *(v4 + 592);
    v65 = v61 - v64;
    v66 = (v61 - v64) >> 2;
    v67 = v66 + 1;
    if ((v66 + 1) >> 62)
    {
      std::vector<flatbuffers::Offset<ODIE_FB::Location>>::__throw_length_error[abi:nn200100]();
    }

    v68 = v62 - v64;
    if (v68 >> 1 > v67)
    {
      v67 = v68 >> 1;
    }

    if (v68 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v69 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v69 = v67;
    }

    if (!v69)
    {
      v70 = (v61 - v64) >> 2;
      v71 = (4 * v66);
      v72 = (4 * v66 - 4 * v70);
      *v71 = v59;
      v63 = v71 + 1;
      memcpy(v72, v64, v65);
      *(v4 + 592) = v72;
      *(v4 + 600) = v63;
      *(v4 + 608) = 0;
      if (v64)
      {
        operator delete(v64);
      }

      goto LABEL_86;
    }

    if (!(v69 >> 62))
    {
      operator new();
    }

LABEL_100:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v21 = a1[1];
LABEL_93:
  std::vector<unsigned int>::push_back[abi:nn200100](v21, (*v20 + 8));
  if (SHIBYTE(v85) < 0)
  {
    operator delete(v84);
  }

  if (SHIBYTE(v81) < 0)
  {
    operator delete(v80[0]);
  }

  return 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::LookupBucketFor<mlir::Type>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>,mlir::Type,unsigned int,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,unsigned int>>::LookupBucketFor<mlir::Type>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          *(v21 + 2) = *(v19 + 8);
          ++*(a1 + 8);
        }

        v19 += 16;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>,mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::LookupBucketFor<mlir::Attribute>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>,mlir::Attribute,unsigned int,llvm::DenseMapInfo<mlir::Attribute,void>,llvm::detail::DenseMapPair<mlir::Attribute,unsigned int>>::LookupBucketFor<mlir::Attribute>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          *(v21 + 2) = *(v19 + 8);
          ++*(a1 + 8);
        }

        v19 += 16;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

void std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100](uint64_t a1, _DWORD *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = (v7 >> 2) + 1;
    if (v8 >> 62)
    {
      std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::__throw_length_error[abi:nn200100]();
    }

    v9 = v3 - v6;
    if (v9 >> 1 > v8)
    {
      v8 = v9 >> 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      if (!(v10 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v11 = (4 * (v7 >> 2));
    *v11 = *a2;
    v5 = v11 + 1;
    memcpy(0, v6, v7);
    *a1 = 0;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = v4 + 1;
  }

  *(a1 + 8) = v5;
}

uint64_t flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    v2 = result;
    v3 = flatbuffers::FlatBufferBuilderImpl<false>::ReferTo(result, a2);

    return flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v2, 6, v3);
  }

  return result;
}

BOOL llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::finish(void)::$_0>(uint64_t **a1, mlir::Operation *this)
{
  v92 = *MEMORY[0x277D85DE8];
  v2 = *a1;
  if ((*a1)[2] == this)
  {
    goto LABEL_79;
  }

  v4 = *(*(this + 6) + 16);
  if (this && v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::MoveOp,void>::id)
  {
    v5 = *v2;
    *(v5 + 144) = 1;
    v6 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v5 + 48, *(v5 + 96));
    v7 = *(this + 9);
    v8 = *(v7 + 24);
    v83 = *(v7 + 56);
    v84 = v8;
    v9 = v6;
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v91, v2[1], &v84, 1uLL);
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v81, v2[1], &v83, 1uLL);
    v10 = *v2;
    __p = 0;
    v86 = 0;
    v87 = 0;
    v88 = v10;
    v11 = *(this + 3);
    p_p = &__p;
    v90 = v11;
    mlir::LocationAttr::walk(&v90, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, &v88);
    v12 = *v2;
    if (v91.__end_ == v91.__begin_)
    {
      begin = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      begin = v91.__begin_;
    }

    v14 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, begin, v91.__end_ - v91.__begin_);
    if (v81.__end_ == v81.__begin_)
    {
      v15 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v15 = v81.__begin_;
    }

    v16 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v15, v81.__end_ - v81.__begin_);
    if (v86 == __p)
    {
      v17 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v17 = __p;
    }

    v18 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v17, (v86 - __p) >> 2);
    *(v12 + 144) = 1;
    v19 = *(v12 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 12, v18);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 10, v16);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 8, v14);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v12 + 48, v9);
    v20 = v12 + 48;
    v21 = 4;
LABEL_73:
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned char>(v20, 4, v21);
    LODWORD(v88) = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v12 + 48, v19);
    std::vector<flatbuffers::Offset<ODIE_FB::Operation>>::push_back[abi:nn200100]((v2 + 3), &v88);
    if (__p)
    {
      v86 = __p;
      operator delete(__p);
    }

    if (v81.__begin_)
    {
      v81.__end_ = v81.__begin_;
      operator delete(v81.__begin_);
    }

    if (v91.__begin_)
    {
      v91.__end_ = v91.__begin_;
      operator delete(v91.__begin_);
    }

    goto LABEL_79;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::LoadImmOp,void>::id)
  {
    v23 = *v2;
    v24 = *(this + 2 * ((*(this + 11) >> 23) & 1) + 8);
    v25 = *(*v24 + 136);
    if (v25 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
    }

    else if (v25 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    {
      llvm::APFloat::Storage::Storage(&v91, (v24 + 16));
      llvm::APFloat::bitcastToAPInt(&v91, &v81);
      if (LODWORD(v81.__end_) > 0x40)
      {
        U64Value = *v81.__begin_;
        MEMORY[0x25F891010]();
      }

      else
      {
        U64Value = v81.__begin_;
      }

      llvm::APFloat::Storage::~Storage(&v91);
    }

    else
    {
      U64Value = 0;
    }

    *(v23 + 144) = 1;
    v69 = *(v23 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(v23 + 48, 4, U64Value);
    v70 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v23 + 48, v69);
    v84 = *(*(this + 9) + 24);
    v71 = v70;
    memset(&v91, 0, sizeof(v91));
    std::vector<unsigned int>::reserve(&v91, 0);
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v81, v2[1], &v84, 1uLL);
    v72 = *v2;
    __p = 0;
    v86 = 0;
    v87 = 0;
    v88 = v72;
    v73 = *(this + 3);
    p_p = &__p;
    v90 = v73;
    mlir::LocationAttr::walk(&v90, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, &v88);
    v12 = *v2;
    if (v91.__end_ == v91.__begin_)
    {
      v74 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v74 = v91.__begin_;
    }

    v75 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v74, v91.__end_ - v91.__begin_);
    if (v81.__end_ == v81.__begin_)
    {
      v76 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v76 = v81.__begin_;
    }

    v77 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v76, v81.__end_ - v81.__begin_);
    if (v86 == __p)
    {
      v78 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v78 = __p;
    }

    v79 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v78, (v86 - __p) >> 2);
    *(v12 + 144) = 1;
    v19 = *(v12 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 12, v79);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 10, v77);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 8, v75);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v12 + 48, v71);
    v20 = v12 + 48;
    v21 = 5;
    goto LABEL_73;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::LoadDsOp,void>::id)
  {
    v27 = *(this + 2 * ((*(this + 11) >> 23) & 1) + 8);
    v28 = *v2;
    v29 = *(v27 + 8);
    v30 = *(*(*(*v2 + 488) + (v29 << 6)) + 8 * *(v27 + 12));
    v31 = *(v27 + 16);
    *(v28 + 144) = 1;
    v32 = *(v28 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned long long>(v28 + 48, 6, v31 + v30);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v28 + 48, 4, v29);
    v33 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v28 + 48, v32);
    v84 = *(*(this + 9) + 24);
    v34 = v33;
    memset(&v91, 0, sizeof(v91));
    std::vector<unsigned int>::reserve(&v91, 0);
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v81, v2[1], &v84, 1uLL);
    v35 = *v2;
    __p = 0;
    v86 = 0;
    v87 = 0;
    v88 = v35;
    v36 = *(this + 3);
    p_p = &__p;
    v90 = v36;
    mlir::LocationAttr::walk(&v90, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, &v88);
    v12 = *v2;
    if (v91.__end_ == v91.__begin_)
    {
      v37 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v37 = v91.__begin_;
    }

    v38 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v37, v91.__end_ - v91.__begin_);
    if (v81.__end_ == v81.__begin_)
    {
      v39 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v39 = v81.__begin_;
    }

    v40 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v39, v81.__end_ - v81.__begin_);
    if (v86 == __p)
    {
      v41 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v41 = __p;
    }

    v42 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v41, (v86 - __p) >> 2);
    *(v12 + 144) = 1;
    v19 = *(v12 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 12, v42);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 10, v40);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 8, v38);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v12 + 48, v34);
    v20 = v12 + 48;
    v21 = 6;
    goto LABEL_73;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::InvokeRegionOp,void>::id)
  {
    v43 = *v2;
    v44 = *(this + 2 * ((*(this + 11) >> 23) & 1) + 8);
    v45 = *(*llvm::StringMap<std::pair<mlir::ODIE::Compiler::ODIX::RegionOp,unsigned int>,llvm::MallocAllocator>::find(v2[1] + 64, *(v44 + 16), *(v44 + 24)) + 16);
    *(v43 + 144) = 1;
    v46 = *(v43 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v43 + 48, 4, v45);
    v47 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v43 + 48, v46);
    memset(&v91, 0, sizeof(v91));
    std::vector<unsigned int>::reserve(&v91, 0);
    memset(&v81, 0, sizeof(v81));
    std::vector<unsigned int>::reserve(&v81, 0);
    v48 = *v2;
    __p = 0;
    v86 = 0;
    v87 = 0;
    v88 = v48;
    v49 = *(this + 3);
    p_p = &__p;
    v90 = v49;
    mlir::LocationAttr::walk(&v90, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, &v88);
    v12 = *v2;
    if (v91.__end_ == v91.__begin_)
    {
      v50 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v50 = v91.__begin_;
    }

    v51 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v50, v91.__end_ - v91.__begin_);
    if (v81.__end_ == v81.__begin_)
    {
      v52 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v52 = v81.__begin_;
    }

    v53 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v52, v81.__end_ - v81.__begin_);
    if (v86 == __p)
    {
      v54 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v54 = __p;
    }

    v55 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v54, (v86 - __p) >> 2);
    *(v12 + 144) = 1;
    v19 = *(v12 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 12, v55);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 10, v53);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 8, v51);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v12 + 48, v47);
    v20 = v12 + 48;
    v21 = 3;
    goto LABEL_73;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::BranchOp,void>::id)
  {
    v91.__begin_ = *(this + 2 * ((*(this + 11) >> 23) & 1) + 8);
    UInt = mlir::IntegerAttr::getUInt(&v91);
    v57 = *v2;
    *(v57 + 144) = 1;
    v58 = *(v57 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddElement<unsigned int>(v57 + 48, 4, UInt);
    v59 = flatbuffers::FlatBufferBuilderImpl<false>::EndTable(v57 + 48, v58);
    v84 = *(*(this + 9) + 24);
    v60 = v59;
    mlir::ODIE::Compiler::Serialization::Utils::ODIXFunctionBuilder::getRegisterIndices(&v91, v2[1], &v84, 1uLL);
    memset(&v81, 0, sizeof(v81));
    std::vector<unsigned int>::reserve(&v81, 0);
    v61 = *v2;
    __p = 0;
    v86 = 0;
    v87 = 0;
    v88 = v61;
    v62 = *(this + 3);
    p_p = &__p;
    v90 = v62;
    mlir::LocationAttr::walk(&v90, llvm::function_ref<mlir::WalkResult ()(mlir::Location)>::callback_fn<mlir::ODIE::Compiler::Serialization::Utils::ODIXProgramBuilder::getOrCreateLocIndices(mlir::Operation *)::$_0>, &v88);
    v12 = *v2;
    if (v91.__end_ == v91.__begin_)
    {
      v63 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v63 = v91.__begin_;
    }

    v64 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v63, v91.__end_ - v91.__begin_);
    if (v81.__end_ == v81.__begin_)
    {
      v65 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v65 = v81.__begin_;
    }

    v66 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v65, v81.__end_ - v81.__begin_);
    if (v86 == __p)
    {
      v67 = &flatbuffers::data<unsigned int,std::allocator<unsigned int>>(std::vector<unsigned int> const&)::t;
    }

    else
    {
      v67 = __p;
    }

    v68 = flatbuffers::FlatBufferBuilderImpl<false>::CreateVector<unsigned int,flatbuffers::Offset,flatbuffers::Vector>(v12 + 48, v67, (v86 - __p) >> 2);
    *(v12 + 144) = 1;
    v19 = *(v12 + 96);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 12, v68);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 10, v66);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<flatbuffers::Vector<unsigned int,unsigned int>>(v12 + 48, 8, v64);
    flatbuffers::FlatBufferBuilderImpl<false>::AddOffset<void>(v12 + 48, v60);
    v20 = v12 + 48;
    v21 = 2;
    goto LABEL_73;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::JumpOp,void>::id)
  {
    mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeJumpOp(*a1, this);
LABEL_79:
    result = 1;
    goto LABEL_80;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::CallOp,void>::id)
  {
    result = mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeCallOp(*a1, this);
    goto LABEL_80;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp,void>::id)
  {
    mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeAsyncInvokeRegionOp(*a1, this);
    goto LABEL_79;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::SetContextOp,void>::id)
  {
    mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeSetContextOp(*a1, this);
    goto LABEL_79;
  }

  if (v4 == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::GetContextOp,void>::id)
  {
    mlir::ODIE::Compiler::Serialization::Utils::ODIXRegionBuilder::serializeGetContextOp(*a1, this);
    goto LABEL_79;
  }

  v81.__begin_ = "Detected an unexpected op within a region.";
  v82 = 259;
  mlir::Operation::emitOpError(this, &v81, &v91);
  mlir::InFlightDiagnostic::~InFlightDiagnostic(&v91);
  result = 0;
LABEL_80:
  v80 = *MEMORY[0x277D85DE8];
  return result;
}

void std::__tree<flatbuffers::Offset<flatbuffers::String>,flatbuffers::FlatBufferBuilderImpl<false>::StringOffsetCompare,std::allocator<flatbuffers::Offset<flatbuffers::String>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<flatbuffers::Offset<flatbuffers::String>,flatbuffers::FlatBufferBuilderImpl<false>::StringOffsetCompare,std::allocator<flatbuffers::Offset<flatbuffers::String>>>::destroy(*a1);
    std::__tree<flatbuffers::Offset<flatbuffers::String>,flatbuffers::FlatBufferBuilderImpl<false>::StringOffsetCompare,std::allocator<flatbuffers::Offset<flatbuffers::String>>>::destroy(a1[1]);

    operator delete(a1);
  }
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<unsigned long long,6u>,false>::grow(uint64_t a1, unint64_t a2)
{
  v14 = 0;
  v3 = (a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (a1 + 16), a2, 64, &v14);
  v5 = v4;
  v6 = *a1;
  v7 = *(a1 + 8);
  if (v7)
  {
    v8 = v7 << 6;
    v9 = v4;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2])
      {
        llvm::SmallVectorImpl<unsigned long long>::operator=(v9, v6);
      }

      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }

    while (v8);
    v6 = *a1;
    v10 = *(a1 + 8);
    if (v10)
    {
      v11 = &v6[16 * v10 - 16];
      v12 = -64 * v10;
      do
      {
        if (v11 + 2 != *v11)
        {
          free(*v11);
        }

        v11 -= 8;
        v12 += 64;
      }

      while (v12);
      v6 = *a1;
    }
  }

  v13 = v14;
  if (v6 != v3)
  {
    free(v6);
  }

  *a1 = v5;
  *(a1 + 12) = v13;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>,mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::ODIX::SymbolAttr>(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }

    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
        {
          v12 = 0;
        }

        else
        {
          v12 = v7 == -8192;
        }

        if (v12)
        {
          v10 = v6;
        }

        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (a1 + 16 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
        {
          goto LABEL_5;
        }
      }

      v8 = 0;
      if (v10)
      {
        v6 = v10;
      }
    }
  }

  else
  {
    v6 = 0;
    v8 = 0;
  }

LABEL_5:
  *a4 = v6;
  return v8;
}

char *llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::grow(uint64_t a1, int a2)
{
  v3 = *(a1 + 16);
  v4 = *a1;
  v5 = (a2 - 1) | ((a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
  {
    v8 = v7 + 1;
  }

  else
  {
    v8 = 64;
  }

  *(a1 + 16) = v8;
  result = llvm::allocate_buffer((16 * v8), 8uLL);
  *a1 = result;
  if (v4)
  {
    *(a1 + 8) = 0;
    v10 = *(a1 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = v10 + 0xFFFFFFFFFFFFFFFLL;
      v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
      v14 = (v12 & 0xFFFFFFFFFFFFFFFLL) - (v12 & 1) + 2;
      v15 = vdupq_n_s64(v13);
      v16 = result + 16;
      do
      {
        v17 = vmovn_s64(vcgeq_u64(v15, vorrq_s8(vdupq_n_s64(v11), xmmword_25D0A0500)));
        if (v17.i8[0])
        {
          *(v16 - 2) = -4096;
        }

        if (v17.i8[4])
        {
          *v16 = -4096;
        }

        v11 += 2;
        v16 += 4;
      }

      while (v14 != v11);
    }

    if (v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        v20 = *v19;
        if ((*v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v30 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>,mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int,llvm::DenseMapInfo<mlir::ODIE::Compiler::ODIX::SymbolAttr,void>,llvm::detail::DenseMapPair<mlir::ODIE::Compiler::ODIX::SymbolAttr,unsigned int>>::LookupBucketFor<mlir::ODIE::Compiler::ODIX::SymbolAttr>(*a1, *(a1 + 16), v20, &v30);
          v21 = v30;
          *v30 = *v19;
          *(v21 + 2) = *(v19 + 8);
          ++*(a1 + 8);
        }

        v19 += 16;
        v18 -= 16;
      }

      while (v18);
    }

    JUMPOUT(0x25F891030);
  }

  *(a1 + 8) = 0;
  v22 = *(a1 + 16);
  if (v22)
  {
    v23 = 0;
    v24 = v22 + 0xFFFFFFFFFFFFFFFLL;
    v25 = v24 & 0xFFFFFFFFFFFFFFFLL;
    v26 = (v24 & 0xFFFFFFFFFFFFFFFLL) - (v24 & 1) + 2;
    v27 = vdupq_n_s64(v25);
    v28 = result + 16;
    do
    {
      v29 = vmovn_s64(vcgeq_u64(v27, vorrq_s8(vdupq_n_s64(v23), xmmword_25D0A0500)));
      if (v29.i8[0])
      {
        *(v28 - 2) = -4096;
      }

      if (v29.i8[4])
      {
        *v28 = -4096;
      }

      v23 += 2;
      v28 += 4;
    }

    while (v26 != v23);
  }

  return result;
}

void mlir::ODIE::Compiler::ODIX::ResolveJumpLabelsPass::~ResolveJumpLabelsPass(mlir::ODIE::Compiler::ODIX::ResolveJumpLabelsPass *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::ODIX::ResolveJumpLabelsPass::runOnOperation(mlir::ODIE::Compiler::ODIX::ResolveJumpLabelsPass *this)
{
  v17 = *MEMORY[0x277D85DE8];
  v1 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
  __src = 0u;
  v4 = 0u;
  v2 = v1;
  v5 = v7;
  v6 = 0x600000000;
  v7[7] = 0;
  v7[6] = 0;
  v8 = 0;
  v10 = 0;
  v9 = 0;
  v11 = 0;
  v12 = 40;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 40;
  operator new();
}

BOOL mlir::OperationPass<mlir::ODIE::Compiler::ODIX::FunctionOp>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  if ((*(a1 + 32) & 1) == 0)
  {
    return 0;
  }

  v2 = *(a2 + 8);
  v3 = *(v2 + 24);
  if (v3 != *(a1 + 24))
  {
    return 0;
  }

  if (v3)
  {
    return memcmp(*(v2 + 16), *(a1 + 16), v3) == 0;
  }

  return 1;
}

void mlir::ODIE::Compiler::ODIX::CollapseLabelPattern::~CollapseLabelPattern(mlir::ODIE::Compiler::ODIX::CollapseLabelPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::CollapseLabelPattern::matchAndRewrite(uint64_t a1, uint64_t a2, const llvm::Twine *a3)
{
  v4 = *(a2 + 8);
  if (v4 == *(a2 + 16) + 32)
  {
    mlir::Operation::setDiscardableAttr(a2, *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64), a3);
    return 0;
  }

  else
  {
    v6 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(*(v4 + 56) + 8), *(*(v4 + 56) + 8) + 16 * *(*(v4 + 56) + 16), "odix.label", 0xAuLL);
    if ((v8 & 1) == 0 || !*(v6 + 8))
    {
      mlir::Operation::setDiscardableAttr(v4, *(a2 + 16 * ((*(a2 + 44) >> 23) & 1) + 64), v7);
    }

    (*(*a3 + 16))(a3, a2);
    return 1;
  }
}

void mlir::Operation::setDiscardableAttr(uint64_t a1, uint64_t a2, const llvm::Twine *a3)
{
  v5 = *(***(a1 + 24) + 32);
  v8 = 261;
  v7[0] = "odix.label";
  v7[1] = 10;
  v6 = mlir::StringAttr::get(v5, v7, a3);
  mlir::Operation::setDiscardableAttr(a1, v6, a2);
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::CollapseLabelPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::CollapseLabelPattern]";
  v6 = 110;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::JumpOp>::~ResolveControlFlowOpPattern(mlir::RewritePattern *a1)
{
  mlir::RewritePattern::~RewritePattern(a1);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::JumpOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = a2 + 64;
  v4 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  if (*(*v4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    return 0;
  }

  v7 = *((*(*(a2 + 16) + 24) & 0xFFFFFFFFFFFFFFF8) + 16);
  v9 = *(v7 + 40);
  v8 = *(v7 + 44);
  v28 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  v10 = *(((v7 + 16 * ((v8 >> 23) & 1) + ((v8 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v9 + 8);
  if (v10)
  {
    v11 = v10 - 8;
  }

  else
  {
    v11 = 0;
  }

  v12 = v11 + 32;
  v13 = *(v11 + 40);
  if (v13 == v11 + 32)
  {
LABEL_14:
    mlir::StringAttr::str(&v28, &v23);
    v19 = std::string::insert(&v23, 0, "failed to find a target op for label ");
    v20 = v19->__r_.__value_.__r.__words[2];
    *__p = *&v19->__r_.__value_.__l.__data_;
    v25 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    v27 = 260;
    v26 = __p;
    v29 = &v26;
    v21 = *(a3 + 16);
    if (v21 && v21[2] == 1)
    {
      (*(*v21 + 88))(v21, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::ODIX::JumpOp &>(mlir::ODIE::Compiler::ODIX::JumpOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v29);
    }

    if (SHIBYTE(v25) < 0)
    {
      operator delete(__p[0]);
    }

    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v23.__r_.__value_.__l.__data_);
    }

    return 0;
  }

  v14 = 0;
  while (1)
  {
    v15 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(*(v13 + 56) + 8), *(*(v13 + 56) + 8) + 16 * *(*(v13 + 56) + 16), "odix.label", 0xAuLL);
    if (v16)
    {
      v17 = *(v15 + 8);
      if (v17)
      {
        if (v17 == v4 && *(*v17 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          break;
        }
      }
    }

    ++v14;
    v13 = *(v13 + 8);
    if (v13 == v12)
    {
      goto LABEL_14;
    }
  }

  *(v3 + 16 * ((*(a2 + 44) >> 23) & 1)) = mlir::Builder::getUI32IntegerAttr((a3 + 8), v14);
  return 1;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::JumpOp>>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::JumpOp>]";
  v6 = 153;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::BranchOp>::~ResolveControlFlowOpPattern(mlir::RewritePattern *a1)
{
  mlir::RewritePattern::~RewritePattern(a1);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::BranchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = a2 + 64;
  v4 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  if (*(*v4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    return 0;
  }

  v7 = *((*(*(a2 + 16) + 24) & 0xFFFFFFFFFFFFFFF8) + 16);
  v9 = *(v7 + 40);
  v8 = *(v7 + 44);
  v28 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  v10 = *(((v7 + 16 * ((v8 >> 23) & 1) + ((v8 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v9 + 8);
  if (v10)
  {
    v11 = v10 - 8;
  }

  else
  {
    v11 = 0;
  }

  v12 = v11 + 32;
  v13 = *(v11 + 40);
  if (v13 == v11 + 32)
  {
LABEL_14:
    mlir::StringAttr::str(&v28, &v23);
    v19 = std::string::insert(&v23, 0, "failed to find a target op for label ");
    v20 = v19->__r_.__value_.__r.__words[2];
    *__p = *&v19->__r_.__value_.__l.__data_;
    v25 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    v27 = 260;
    v26 = __p;
    v29 = &v26;
    v21 = *(a3 + 16);
    if (v21 && v21[2] == 1)
    {
      (*(*v21 + 88))(v21, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::ODIX::BranchOp &>(mlir::ODIE::Compiler::ODIX::BranchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v29);
    }

    if (SHIBYTE(v25) < 0)
    {
      operator delete(__p[0]);
    }

    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v23.__r_.__value_.__l.__data_);
    }

    return 0;
  }

  v14 = 0;
  while (1)
  {
    v15 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(*(*(v13 + 56) + 8), *(*(v13 + 56) + 8) + 16 * *(*(v13 + 56) + 16), "odix.label", 0xAuLL);
    if (v16)
    {
      v17 = *(v15 + 8);
      if (v17)
      {
        if (v17 == v4 && *(*v17 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          break;
        }
      }
    }

    ++v14;
    v13 = *(v13 + 8);
    if (v13 == v12)
    {
      goto LABEL_14;
    }
  }

  *(v3 + 16 * ((*(a2 + 44) >> 23) & 1)) = mlir::Builder::getUI32IntegerAttr((a3 + 8), v14);
  return 1;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::BranchOp>>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::ResolveControlFlowOpPattern<mlir::ODIE::Compiler::ODIX::BranchOp>]";
  v6 = 155;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::RemoveEndOfChainLabelPattern::~RemoveEndOfChainLabelPattern(mlir::ODIE::Compiler::ODIX::RemoveEndOfChainLabelPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::RemoveEndOfChainLabelPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(a2 + 8) != *(a2 + 16) + 32)
  {
    return 0;
  }

  (*(*a3 + 16))(a3);
  return 1;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::RemoveEndOfChainLabelPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::RemoveEndOfChainLabelPattern]";
  v6 = 118;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::SimplifyOdixFunctions::~SimplifyOdixFunctions(mlir::ODIE::Compiler::ODIX::SimplifyOdixFunctions *this)
{
  mlir::Pass::~Pass(this);

  JUMPOUT(0x25F891040);
}

void mlir::ODIE::Compiler::ODIX::SimplifyOdixFunctions::runOnOperation(mlir::ODIE::Compiler::ODIX::SimplifyOdixFunctions *this)
{
  v18 = *MEMORY[0x277D85DE8];
  mlir::ODIE::Compiler::ODIX::RegionTable::RegionTable(v3, *(this + 5) & 0xFFFFFFFFFFFFFFF8);
  v2 = *(***((*(this + 5) & 0xFFFFFFFFFFFFFFF8) + 24) + 32);
  __src = 0u;
  v5 = 0u;
  v3[14] = v2;
  v6 = v8;
  v7 = 0x600000000;
  v8[6] = 0;
  v8[7] = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 40;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 40;
  operator new();
}

void mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::InvokeRegionOp>::~InvokeRegionRemovalPattern(mlir::RewritePattern *a1)
{
  mlir::RewritePattern::~RewritePattern(a1);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::InvokeRegionOp>::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v6 = *(a1 + 96);
  v7 = a2 + 64;
  v8 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  v9 = llvm::StringMap<mlir::ODIE::Compiler::ODIX::RegionOp,llvm::MallocAllocator>::find(v6, *(v8 + 16), *(v8 + 24));
  if (*v6 + 8 * *(v6 + 8) == v9)
  {
    v10 = 0;
  }

  else
  {
    v10 = *(*v9 + 8);
  }

  if (mlir::ODIE::Compiler::ODIX::RegionOp::isEmpty(v10))
  {
    mlir::ODIE::Compiler::ODIX::RegionTable::removeUse(*(a1 + 96), a2);
    (*(*a3 + 16))(a3, a2);
    return 1;
  }

  v13 = *(((&v10[4 * ((v10[11] >> 23) & 1) + 17] + ((v10[11] >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * v10[10] + 8);
  v14 = v13 - 8;
  if (!v13)
  {
    v14 = 0;
  }

  v15 = *(v14 + 40);
  if (*(v15 + 8) == v14 + 32 && *(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::InvokeRegionOp,void>::id)
  {
    v17 = *(v15 + 16 * ((*(v15 + 44) >> 23) & 1) + 64);
    v18 = *(v17 + 16);
    v19 = *(v17 + 24);
    v20 = *(***(a2 + 24) + 32);
    v23 = 261;
    v22[0] = v18;
    v22[1] = v19;
    *(v7 + 16 * ((*(a2 + 44) >> 23) & 1)) = mlir::StringAttr::get(v20, v22, v11);
    mlir::ODIE::Compiler::ODIX::RegionTable::replaceUses(*(a1 + 96), a2, v18, v19);
    return 1;
  }

  v23 = 259;
  v21 = v22;
  v22[0] = "Target region is non-empty";
  v16 = a3[2];
  if (v16)
  {
    if (v16[2] == 1)
    {
      (*(*v16 + 88))(v16, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::ODIX::InvokeRegionOp &>(mlir::ODIE::Compiler::ODIX::InvokeRegionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    }
  }

  return 0;
}

BOOL mlir::ODIE::Compiler::ODIX::RegionOp::isEmpty(mlir::ODIE::Compiler::ODIX::RegionOp *this)
{
  v1 = (((this + 16 * ((*(this + 11) >> 23) & 1) + ((*(this + 11) >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * *(this + 10));
  if (*v1 == v1)
  {
    return 1;
  }

  v2 = v1[1];
  return *(v2 + 8) == v1 && *(v2 + 24) == v2 + 24;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::InvokeRegionOp>>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::InvokeRegionOp>]";
  v6 = 160;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp>::~InvokeRegionRemovalPattern(mlir::RewritePattern *a1)
{
  mlir::RewritePattern::~RewritePattern(a1);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp>::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v6 = *(a1 + 96);
  v7 = a2 + 64;
  v8 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  v9 = llvm::StringMap<mlir::ODIE::Compiler::ODIX::RegionOp,llvm::MallocAllocator>::find(v6, *(v8 + 16), *(v8 + 24));
  if (*v6 + 8 * *(v6 + 8) == v9)
  {
    v10 = 0;
  }

  else
  {
    v10 = *(*v9 + 8);
  }

  if (mlir::ODIE::Compiler::ODIX::RegionOp::isEmpty(v10))
  {
    mlir::ODIE::Compiler::ODIX::RegionTable::removeUse(*(a1 + 96), a2);
    (*(*a3 + 16))(a3, a2);
    return 1;
  }

  v13 = *(((&v10[4 * ((v10[11] >> 23) & 1) + 17] + ((v10[11] >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8) + 32 * v10[10] + 8);
  v14 = v13 - 8;
  if (!v13)
  {
    v14 = 0;
  }

  v15 = *(v14 + 40);
  if (*(v15 + 8) == v14 + 32 && *(*(v15 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp,void>::id)
  {
    v17 = *(v15 + 16 * ((*(v15 + 44) >> 23) & 1) + 64);
    v18 = *(v17 + 16);
    v19 = *(v17 + 24);
    v20 = *(***(a2 + 24) + 32);
    v23 = 261;
    v22[0] = v18;
    v22[1] = v19;
    *(v7 + 16 * ((*(a2 + 44) >> 23) & 1)) = mlir::StringAttr::get(v20, v22, v11);
    mlir::ODIE::Compiler::ODIX::RegionTable::replaceUses(*(a1 + 96), a2, v18, v19);
    return 1;
  }

  v23 = 259;
  v21 = v22;
  v22[0] = "Target region is non-empty";
  v16 = a3[2];
  if (v16)
  {
    if (v16[2] == 1)
    {
      (*(*v16 + 88))(v16, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp &>(mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    }
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp>>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::InvokeRegionRemovalPattern<mlir::ODIE::Compiler::ODIX::AsyncInvokeRegionOp>]";
  v6 = 165;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

void mlir::ODIE::Compiler::ODIX::UnusedRegionRemovalPattern::~UnusedRegionRemovalPattern(mlir::ODIE::Compiler::ODIX::UnusedRegionRemovalPattern *this)
{
  mlir::RewritePattern::~RewritePattern(this);

  JUMPOUT(0x25F891040);
}

uint64_t mlir::ODIE::Compiler::ODIX::UnusedRegionRemovalPattern::matchAndRewrite(uint64_t a1, uint64_t a2, void *a3)
{
  v6 = a2 + 64;
  v7 = *(a2 + 64 + 16 * ((*(a2 + 44) >> 23) & 1));
  v8 = *(v7 + 16);
  v9 = *(v7 + 24);
  if (v9 == 18 && (*v8 == 0x5F746C7561666564 ? (v10 = *(v8 + 8) == 0x696F707972746E65) : (v10 = 0), v10 ? (v11 = *(v8 + 16) == 29806) : (v11 = 0), v11))
  {
    v20 = "Region is an entrypoint";
  }

  else
  {
    v12 = *(a1 + 96);
    v13 = llvm::StringMap<llvm::SmallVector<mlir::Operation *,6u>,llvm::MallocAllocator>::find(v12 + 24, v8, v9);
    if (*(v12 + 24) + 8 * *(v12 + 32) == v13)
    {
LABEL_12:
      v15 = *(a1 + 96);
      v16 = *(v6 + 16 * ((*(a2 + 44) >> 23) & 1));
      v17 = *(v16 + 16);
      v18 = *(v16 + 24);
      llvm::StringMap<mlir::ODIE::Compiler::ODIX::RegionOp,llvm::MallocAllocator>::erase(v15, v17, v18);
      llvm::StringMap<llvm::SmallVector<mlir::Operation *,6u>,llvm::MallocAllocator>::erase(v15 + 24, v17, v18);
      (*(*a3 + 16))(a3, a2);
      return 1;
    }

    v14 = *(*v13 + 16);
    if (v14 == 1)
    {
      v21 = **(*v13 + 8);
      if (v21)
      {
        v22 = *(v21[6] + 16) == &mlir::detail::TypeIDResolver<mlir::ODIE::Compiler::ODIX::InvokeRegionOp,void>::id;
      }

      else
      {
        v22 = 0;
      }

      if (v22)
      {
        v24 = *(((v6 + 16 * ((*(a2 + 44) >> 23) & 1) + ((*(a2 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(a2 + 40) + 8);
        if (v24)
        {
          v25 = v24 - 8;
        }

        else
        {
          v25 = 0;
        }

        v26 = *(v25 + 40);
        v27 = (v25 + 32);
        if (v26 != (v25 + 32))
        {
          do
          {
            v28 = v26[1];
            mlir::RewriterBase::moveOpBefore(a3, v26, v21[2], v21);
            v26 = v28;
          }

          while (v28 != v27);
        }

        return 1;
      }
    }

    else if (!v14)
    {
      goto LABEL_12;
    }

    v20 = "Region has uses";
  }

  v29 = v20;
  v30 = 259;
  v31 = &v29;
  v23 = a3[2];
  if (v23)
  {
    if (v23[2] == 1)
    {
      (*(*v23 + 88))(v23, *(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<llvm::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::ODIE::Compiler::ODIX::RegionOp &>(mlir::ODIE::Compiler::ODIX::RegionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
    }
  }

  return 0;
}

const char *llvm::detail::getTypeNameImpl<mlir::ODIE::Compiler::ODIX::UnusedRegionRemovalPattern>()
{
  v5 = "StringRef llvm::detail::getTypeNameImpl() [DesiredTypeName = mlir::ODIE::Compiler::ODIX::UnusedRegionRemovalPattern]";
  v6 = 116;
  v0 = llvm::StringRef::find(&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
  {
    v1 = v0;
  }

  else
  {
    v1 = v6;
  }

  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
  {
    v3 = 18;
  }

  else
  {
    v3 = v6 - v1;
  }

  return &v2[v3];
}

uint64_t _GLOBAL__sub_I_ErrorHandling_cpp()
{
  v0 = MEMORY[0x277D82690];
  __cxa_atexit(MEMORY[0x277D82690], &ErrorHandlerMutex, &dword_25C85D000);

  return __cxa_atexit(v0, &BadAllocErrorHandlerMutex, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_BasicBlock_cpp()
{
  v0 = llvm::cl::Option::Option(UseNewDbgInfoFormat, 0, 0);
  byte_27FC1CC50 = 0;
  qword_27FC1CC58 = &unk_286E76000;
  *&word_27FC1CC60 = 0;
  UseNewDbgInfoFormat[0] = &unk_286E79348;
  qword_27FC1CC68 = &unk_286E79090;
  qword_27FC1CC70 = &unk_286E76020;
  qword_27FC1CC88 = &qword_27FC1CC70;
  llvm::cl::Option::setArgStr(v0, "experimental-debuginfo-iterators", 32);
  qword_27FC1CBF8 = "Enable communicating debuginfo positions through iterators, eliminating intrinsics. Has no effect if --preserve-input-debuginfo-format=true.";
  unk_27FC1CC00 = 140;
  byte_27FC1CC50 = 1;
  word_27FC1CC60 = 257;
  llvm::cl::Option::addArgument(UseNewDbgInfoFormat);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, UseNewDbgInfoFormat, &dword_25C85D000);
  v1 = llvm::cl::Option::Option(&qword_27FC21FA8, 0, 0);
  dword_27FC22020 = 0;
  qword_27FC22028 = &unk_286E79050;
  unk_27FC22030 = 0;
  qword_27FC21FA8 = &unk_286E79B08;
  qword_27FC22038 = &unk_286E790C0;
  qword_27FC22040 = &unk_286E79B70;
  qword_27FC22058 = &qword_27FC22040;
  llvm::cl::Option::setArgStr(v1, "preserve-input-debuginfo-format", 31);
  word_27FC21FB2 = word_27FC21FB2 & 0xFF9F | 0x20;
  qword_27FC21FC8 = "When set to true, IR files will be processed and printed in their current debug info format, regardless of default behaviour or other flags passed. Has no effect if input IR does not contain debug records or intrinsics. Ignored in llvm-link, llvm-lto, and llvm-lto2.";
  unk_27FC21FD0 = 266;
  llvm::cl::Option::addArgument(&qword_27FC21FA8);
  __cxa_atexit(llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::~opt, &qword_27FC21FA8, &dword_25C85D000);
  v2 = llvm::cl::Option::Option(&qword_27FC22060, 0, 0);
  byte_27FC220E9 = 0;
  qword_27FC220D8 = 0;
  unk_27FC220E0 = &unk_286E76000;
  qword_27FC22060 = &unk_286E793D0;
  qword_27FC220F0 = &unk_286E79090;
  qword_27FC220F8 = &unk_286E79438;
  qword_27FC22110 = &qword_27FC220F8;
  llvm::cl::Option::setArgStr(v2, "write-experimental-debuginfo-iterators-to-bitcode", 49);
  word_27FC2206A = word_27FC2206A & 0xFF9F | 0x20;
  llvm::cl::opt_storage<BOOL,true,false>::setLocation(&qword_27FC220D8, &qword_27FC22060, _MergedGlobals_41);
  *qword_27FC220D8 = 1;
  unk_27FC220E8 = 257;
  llvm::cl::Option::addArgument(&qword_27FC22060);

  return __cxa_atexit(llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::~opt, &qword_27FC22060, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_Constants_cpp()
{
  v0 = llvm::cl::Option::Option(&_MergedGlobals_42, 0, 0);
  byte_27FC22190 = 0;
  qword_27FC22198 = &unk_286E76000;
  *&word_27FC221A0 = 0;
  _MergedGlobals_42 = &unk_286E79348;
  qword_27FC221A8 = &unk_286E79090;
  qword_27FC221B0 = &unk_286E76020;
  qword_27FC221C8 = &qword_27FC221B0;
  llvm::cl::Option::setArgStr(v0, "use-constant-int-for-fixed-length-splat", 39);
  byte_27FC22190 = 0;
  word_27FC221A0 = 256;
  word_27FC22122 = word_27FC22122 & 0xFF9F | 0x20;
  qword_27FC22138 = "Use ConstantInt's native fixed-length vector splat support.";
  unk_27FC22140 = 59;
  llvm::cl::Option::addArgument(&_MergedGlobals_42);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &_MergedGlobals_42, &dword_25C85D000);
  v1 = llvm::cl::Option::Option(&qword_27FC221D0, 0, 0);
  byte_27FC22248 = 0;
  qword_27FC22250 = &unk_286E76000;
  *&word_27FC22258 = 0;
  qword_27FC221D0 = &unk_286E79348;
  qword_27FC22260 = &unk_286E79090;
  qword_27FC22268 = &unk_286E76020;
  qword_27FC22280 = &qword_27FC22268;
  llvm::cl::Option::setArgStr(v1, "use-constant-fp-for-fixed-length-splat", 38);
  byte_27FC22248 = 0;
  word_27FC22258 = 256;
  word_27FC221DA = word_27FC221DA & 0xFF9F | 0x20;
  qword_27FC221F0 = "Use ConstantFP's native fixed-length vector splat support.";
  unk_27FC221F8 = 58;
  llvm::cl::Option::addArgument(&qword_27FC221D0);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC221D0, &dword_25C85D000);
  v2 = llvm::cl::Option::Option(&qword_27FC22288, 0, 0);
  byte_27FC22300 = 0;
  qword_27FC22308 = &unk_286E76000;
  *&word_27FC22310 = 0;
  qword_27FC22288 = &unk_286E79348;
  qword_27FC22318 = &unk_286E79090;
  qword_27FC22320 = &unk_286E76020;
  qword_27FC22338 = &qword_27FC22320;
  llvm::cl::Option::setArgStr(v2, "use-constant-int-for-scalable-splat", 35);
  byte_27FC22300 = 0;
  word_27FC22310 = 256;
  word_27FC22292 = word_27FC22292 & 0xFF9F | 0x20;
  qword_27FC222A8 = "Use ConstantInt's native scalable vector splat support.";
  unk_27FC222B0 = 55;
  llvm::cl::Option::addArgument(&qword_27FC22288);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC22288, &dword_25C85D000);
  v3 = llvm::cl::Option::Option(&qword_27FC22340, 0, 0);
  byte_27FC223B8 = 0;
  qword_27FC223C8 = 0;
  qword_27FC223C0 = &unk_286E76000;
  qword_27FC22340 = &unk_286E79348;
  qword_27FC223D0 = &unk_286E79090;
  qword_27FC223D8 = &unk_286E76020;
  qword_27FC223F0 = &qword_27FC223D8;
  llvm::cl::Option::setArgStr(v3, "use-constant-fp-for-scalable-splat", 34);
  byte_27FC223B8 = 0;
  LOWORD(qword_27FC223C8) = 256;
  word_27FC2234A = word_27FC2234A & 0xFF9F | 0x20;
  qword_27FC22360 = "Use ConstantFP's native scalable vector splat support.";
  qword_27FC22368 = 54;
  llvm::cl::Option::addArgument(&qword_27FC22340);

  return __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC22340, &dword_25C85D000);
}

double _GLOBAL__sub_I_DebugInfoMetadata_cpp()
{
  v0 = llvm::cl::Option::Option(&qword_27FC22410, 0, 0);
  byte_27FC22488 = 0;
  qword_27FC22490 = &unk_286E76000;
  unk_27FC22498 = 0;
  qword_27FC22410 = &unk_286E79348;
  qword_27FC224A0 = &unk_286E79090;
  qword_27FC224A8 = &unk_286E76020;
  qword_27FC224C0 = &qword_27FC224A8;
  llvm::cl::Option::setArgStr(v0, "enable-fs-discriminator", 23);
  word_27FC2241A = word_27FC2241A & 0xFF9F | 0x20;
  qword_27FC22430 = "Enable adding flow sensitive discriminators";
  unk_27FC22438 = 43;
  llvm::cl::Option::addArgument(&qword_27FC22410);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC22410, &dword_25C85D000);
  result = NAN;
  _MergedGlobals_43 = xmmword_25D0A05E0;
  return result;
}

uint64_t _GLOBAL__sub_I_DiagnosticHandler_cpp()
{
  *&v6 = "Enable optimization remarks from passes whose name match the given regular expression";
  *(&v6 + 1) = 85;
  v5 = &_MergedGlobals_44;
  v4 = 2;
  v0 = llvm::cl::Option::Option(qword_27FC224F8, 0, 0);
  qword_27FC22570 = 0;
  unk_27FC22578 = &unk_286E98430;
  qword_27FC224F8[0] = &unk_286E98390;
  qword_27FC22580 = &unk_286E791E0;
  qword_27FC22588 = &unk_286E98450;
  qword_27FC225A0 = &qword_27FC22588;
  llvm::cl::Option::setArgStr(v0, "pass-remarks", 12);
  llvm::cl::Option::addArgument(qword_27FC224F8);
  *&v6 = "Enable missed optimization remarks from passes whose name match the given regular expression";
  *(&v6 + 1) = 92;
  v5 = &unk_27FC224D8;
  v4 = 2;
  v1 = llvm::cl::Option::Option(qword_27FC225A8, 0, 0);
  qword_27FC22620 = 0;
  unk_27FC22628 = &unk_286E98430;
  qword_27FC225A8[0] = &unk_286E98390;
  qword_27FC22630 = &unk_286E791E0;
  qword_27FC22638 = &unk_286E98450;
  qword_27FC22650 = &qword_27FC22638;
  llvm::cl::Option::setArgStr(v1, "pass-remarks-missed", 19);
  llvm::cl::Option::addArgument(qword_27FC225A8);
  *&v6 = "Enable optimization analysis remarks from passes whose name match the given regular expression";
  *(&v6 + 1) = 94;
  v5 = &unk_27FC224E8;
  v4 = 2;
  v2 = llvm::cl::Option::Option(qword_27FC22658, 0, 0);
  qword_27FC226D0 = 0;
  qword_27FC226D8 = &unk_286E98430;
  qword_27FC22658[0] = &unk_286E98390;
  qword_27FC226E0 = &unk_286E791E0;
  qword_27FC226E8 = &unk_286E98450;
  qword_27FC22700 = &qword_27FC226E8;
  llvm::cl::Option::setArgStr(v2, "pass-remarks-analysis", 21);
  llvm::cl::Option::addArgument(qword_27FC22658);
}

uint64_t _GLOBAL__sub_I_Function_cpp()
{
  v0 = llvm::cl::Option::Option(&NonGlobalValueMaxNameSize, 0, 0);
  dword_27FC22780 = 0;
  qword_27FC22788 = &unk_286E793B0;
  *&dword_27FC22790 = 0;
  NonGlobalValueMaxNameSize = &unk_286E79278;
  qword_27FC22798 = &unk_286E790F0;
  qword_27FC227A0 = &unk_286E98498;
  qword_27FC227B8 = &qword_27FC227A0;
  llvm::cl::Option::setArgStr(v0, "non-global-value-max-name-size", 30);
  word_27FC22712 = word_27FC22712 & 0xFF9F | 0x20;
  dword_27FC22780 = 1024;
  byte_27FC22794 = 1;
  dword_27FC22790 = 1024;
  qword_27FC22728 = "Maximum size for the name of non-global values.";
  unk_27FC22730 = 47;
  llvm::cl::Option::addArgument(&NonGlobalValueMaxNameSize);

  return __cxa_atexit(llvm::cl::opt<int,false,llvm::cl::parser<int>>::~opt, &NonGlobalValueMaxNameSize, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_Instructions_cpp()
{
  v0 = llvm::cl::Option::Option(&DisableI2pP2iOpt, 0, 0);
  byte_27FC22838 = 0;
  qword_27FC22840 = &unk_286E76000;
  *&word_27FC22848 = 0;
  DisableI2pP2iOpt = &unk_286E79348;
  qword_27FC22850 = &unk_286E79090;
  qword_27FC22858 = &unk_286E76020;
  qword_27FC22870 = &qword_27FC22858;
  llvm::cl::Option::setArgStr(v0, "disable-i2p-p2i-opt", 19);
  byte_27FC22838 = 0;
  word_27FC22848 = 256;
  qword_27FC227E0 = "Disables inttoptr/ptrtoint roundtrip optimization";
  unk_27FC227E8 = 49;
  llvm::cl::Option::addArgument(&DisableI2pP2iOpt);

  return __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &DisableI2pP2iOpt, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_ModuleSummaryIndex_cpp()
{
  v0 = llvm::cl::Option::Option(&qword_27FC228E8, 0, 0);
  byte_27FC22960 = 0;
  qword_27FC22968 = &unk_286E76000;
  *&word_27FC22970 = 0;
  qword_27FC228E8 = &unk_286E79348;
  qword_27FC22978 = &unk_286E79090;
  qword_27FC22980 = &unk_286E76020;
  qword_27FC22998 = &qword_27FC22980;
  llvm::cl::Option::setArgStr(v0, "propagate-attrs", 15);
  byte_27FC22960 = 1;
  word_27FC22970 = 257;
  word_27FC228F2 = word_27FC228F2 & 0xFF9F | 0x20;
  qword_27FC22908 = "Propagate attributes in index";
  unk_27FC22910 = 29;
  llvm::cl::Option::addArgument(&qword_27FC228E8);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC228E8, &dword_25C85D000);
  v1 = llvm::cl::Option::Option(&qword_27FC229A0, 0, 0);
  byte_27FC22A18 = 0;
  qword_27FC22A20 = &unk_286E76000;
  *&word_27FC22A28 = 0;
  qword_27FC229A0 = &unk_286E79348;
  qword_27FC22A30 = &unk_286E79090;
  qword_27FC22A38 = &unk_286E76020;
  qword_27FC22A50 = &qword_27FC22A38;
  llvm::cl::Option::setArgStr(v1, "import-constants-with-refs", 26);
  byte_27FC22A18 = 1;
  word_27FC22A28 = 257;
  word_27FC229AA = word_27FC229AA & 0xFF9F | 0x20;
  qword_27FC229C0 = "Import constant global variables with references";
  unk_27FC229C8 = 48;
  llvm::cl::Option::addArgument(&qword_27FC229A0);
  __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC229A0, &dword_25C85D000);
  v8 = &v10;
  v9 = 0;
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  qword_27FC22880 = 0xC100000001;
  qword_27FC22888 = 0;
  unk_27FC22890 = 0;
  dword_27FC228B0 = 0;
  qword_27FC22898 = 0;
  unk_27FC228A0 = &dword_27FC228B0;
  _MergedGlobals_45 = &unk_286E984E0;
  qword_27FC228A8 = 0;
  dword_27FC228B4 = 0;
  qword_27FC228B8 = &unk_27FC228C8;
  unk_27FC228C0 = 0u;
  unk_27FC228D0 = 0u;
  qword_27FC228E0 = 0;
  v10 = v3;
  std::vector<llvm::AllocInfo>::__destroy_vector::operator()[abi:nn200100](&v10);
  v10 = v4;
  std::vector<llvm::CallsiteInfo>::__destroy_vector::operator()[abi:nn200100](&v10);
  v10 = v5;
  std::vector<llvm::FunctionSummary::ParamAccess>::__destroy_vector::operator()[abi:nn200100](&v10);
  v10 = v6;
  std::vector<llvm::FunctionSummary::ConstVCall>::__destroy_vector::operator()[abi:nn200100](&v10);
  v10 = v7;
  std::vector<llvm::FunctionSummary::ConstVCall>::__destroy_vector::operator()[abi:nn200100](&v10);
  if (v8 != &v10)
  {
    free(v8);
  }

  return __cxa_atexit(llvm::FunctionSummary::~FunctionSummary, &_MergedGlobals_45, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_OptBisect_cpp()
{
  v10 = *MEMORY[0x277D85DE8];
  v4[0] = &unk_286E98550;
  v4[3] = v4;
  std::__function::__value_func<void ()(int)>::__value_func[abi:nn200100](v5, v4);
  v0 = llvm::cl::Option::Option(&_MergedGlobals_46, 0, 0);
  dword_27FC22AD8 = 0;
  qword_27FC22AE0 = &unk_286E793B0;
  *&dword_27FC22AE8 = 0;
  _MergedGlobals_46 = &unk_286E79278;
  qword_27FC22AF0 = &unk_286E790F0;
  qword_27FC22AF8[0] = &unk_286E98498;
  qword_27FC22B10 = qword_27FC22AF8;
  llvm::cl::Option::setArgStr(v0, "opt-bisect-limit", 16);
  dword_27FC22AD8 = 0x7FFFFFFF;
  byte_27FC22AEC = 1;
  dword_27FC22AE8 = 0x7FFFFFFF;
  word_27FC22A6A = word_27FC22A6A & 0xFF98 | 0x20;
  std::__function::__value_func<void ()(int)>::__value_func[abi:nn200100](v6, v5);
  v9 = 0;
  if (v7)
  {
    operator new();
  }

  std::function<void ()(int const&)>::operator=(qword_27FC22AF8, v8);
  std::__function::__value_func<void ()(int const&)>::~__value_func[abi:nn200100](v8);
  std::__function::__value_func<void ()(int)>::~__value_func[abi:nn200100](v6);
  qword_27FC22A80 = "Maximum optimization to perform";
  unk_27FC22A88 = 31;
  llvm::cl::Option::addArgument(&_MergedGlobals_46);
  std::__function::__value_func<void ()(int)>::~__value_func[abi:nn200100](v5);
  std::__function::__value_func<void ()(int)>::~__value_func[abi:nn200100](v4);
  __cxa_atexit(llvm::cl::opt<int,false,llvm::cl::parser<int>>::~opt, &_MergedGlobals_46, &dword_25C85D000);
  v1 = llvm::cl::Option::Option(&qword_27FC22B18, 0, 0);
  byte_27FC22B90 = 0;
  qword_27FC22B98 = &unk_286E76000;
  *&word_27FC22BA0 = 0;
  qword_27FC22B18 = &unk_286E79348;
  qword_27FC22BA8 = &unk_286E79090;
  qword_27FC22BB0 = &unk_286E76020;
  qword_27FC22BC8 = &qword_27FC22BB0;
  llvm::cl::Option::setArgStr(v1, "opt-bisect-verbose", 18);
  qword_27FC22B38 = "Show verbose output when opt-bisect-limit is set";
  unk_27FC22B40 = 48;
  byte_27FC22B90 = 1;
  word_27FC22BA0 = 257;
  word_27FC22B22 = word_27FC22B22 & 0xFF98 | 0x20;
  llvm::cl::Option::addArgument(&qword_27FC22B18);
  result = __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &qword_27FC22B18, &dword_25C85D000);
  v3 = *MEMORY[0x277D85DE8];
  return result;
}

uint64_t _GLOBAL__sub_I_Value_cpp()
{
  v0 = llvm::cl::Option::Option(&UseDerefAtPointSemantics, 0, 0);
  byte_27FC22C48 = 0;
  qword_27FC22C50 = &unk_286E76000;
  *&word_27FC22C58 = 0;
  UseDerefAtPointSemantics = &unk_286E79348;
  qword_27FC22C60 = &unk_286E79090;
  qword_27FC22C68 = &unk_286E76020;
  qword_27FC22C80 = &qword_27FC22C68;
  llvm::cl::Option::setArgStr(v0, "use-dereferenceable-at-point-semantics", 38);
  word_27FC22BDA = word_27FC22BDA & 0xFF9F | 0x20;
  byte_27FC22C48 = 0;
  word_27FC22C58 = 256;
  qword_27FC22BF0 = "Deref attributes and metadata infer facts at definition only";
  unk_27FC22BF8 = 60;
  llvm::cl::Option::addArgument(&UseDerefAtPointSemantics);

  return __cxa_atexit(llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::~opt, &UseDerefAtPointSemantics, &dword_25C85D000);
}

uint64_t _GLOBAL__sub_I_RemarkStreamer_cpp()
{
  v0 = llvm::cl::Option::Option(&EnableRemarksSection, 0, 0);
  dword_27FC22D00 = 0;
  qword_27FC22D08 = &unk_286E79050;
  *&dword_27FC22D10 = 0;
  EnableRemarksSection = &unk_286E79B08;
  qword_27FC22D18 = &unk_286E790C0;
  qword_27FC22D20 = &unk_286E79B70;
  qword_27FC22D38 = &qword_27FC22D20;
  llvm::cl::Option::setArgStr(v0, "remarks-section", 15);
  qword_27FC22CA8 = "Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.";
  unk_27FC22CB0 = 133;
  dword_27FC22D00 = 0;
  byte_27FC22D14 = 1;
  dword_27FC22D10 = 0;
  word_27FC22C92 = word_27FC22C92 & 0xFF9F | 0x20;
  llvm::cl::Option::addArgument(&EnableRemarksSection);

  return __cxa_atexit(llvm::cl::opt<llvm::cl::BOOLOrDefault,false,llvm::cl::parser<llvm::cl::BOOLOrDefault>>::~opt, &EnableRemarksSection, &dword_25C85D000);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x2821F73E8](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__extension(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x2821F73F0](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__parent_path(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x2821F73F8](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x2821F7400](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__stem(const std::__fs::filesystem::path *this)
{
  v1 = MEMORY[0x2821F7428](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return MEMORY[0x2821F7F28](retstr, __val);
}

{
  return MEMORY[0x2821F7F38](retstr, __val);
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete(void *__p, std::align_val_t a2)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2, const std::nothrow_t *a3)
{
    ;
  }
}

void operator new()
{
    ;
  }
}