@interface HMMTRAccessoryServer
+ (BOOL)certificateSubjectHasCATs:(id)ts;
+ (id)_convertPairingFailureError:(id)error;
+ (id)logCategory;
+ (id)shortDescription;
+ (void)propagateCharactersticValuesToAccessory:(id)accessory;
- (BOOL)_controllerIsOnWiFiNetworkWhichSupportsBothBands;
- (BOOL)_delegateRespondsToSelector:(SEL)selector;
- (BOOL)_handleUnmappedAttributeReport:(id)report;
- (BOOL)_ignoreAttributeReport:(id)report;
- (BOOL)_isAllowedForRawEventDictionaryHandling:(id)handling;
- (BOOL)_isBridgedBasicInformation:(id)information reportClusterID:(id)d;
- (BOOL)_legacyHMDHAPAccessoryDelegateShouldHandleEvent:(id)event;
- (BOOL)_populateCommissioningParameterCountryCode:(id)code;
- (BOOL)_shouldUpdateUnreachableState;
- (BOOL)accessoryWithSameDiscriminatorDiscovered;
- (BOOL)doesMatchDiscriminator:(id)discriminator;
- (BOOL)handleNotAvailableImageResponseCounter;
- (BOOL)hasNetworkProvisioningFailed:(unsigned int)failed;
- (BOOL)hasPreferredLocalLink;
- (BOOL)isDisabled;
- (BOOL)isEqual:(id)equal;
- (BOOL)isLocallyDiscoveredAndMatchesDiscriminatorOfSetupPayload:(id)payload;
- (BOOL)isPairedInStorage;
- (BOOL)isReadyToReadFromMTRDevice;
- (BOOL)matchesSetupID:(id)d;
- (BOOL)matchesSetupID:(id)d serverIdentifier:(id)identifier;
- (BOOL)removePairingForCurrentControllerOnQueue:(id)queue completion:(id)completion;
- (BOOL)tryPairingPassword:(id)password onboardingSetupPayloadString:(id)string error:(id *)error;
- (BOOL)updateProductAttributes;
- (HAPAccessory)primaryAccessory;
- (HMMTRAccessoryPairingEndContext)pairingEndContextWhenRemove;
- (HMMTRAccessoryServer)initWithKeystore:(id)keystore browser:(id)browser;
- (HMMTRAccessoryServerBrowser)browser;
- (HMMTRAccessoryServerDelegate)chipDelegate;
- (HMMTRAccessoryServerDiagnosticsEventDelegate)diagnosticsEventDelegate;
- (HMMTRPairing)currentPairing;
- (HMMTRReportObserver)hmdHAPAccessoryDelegate;
- (MTRDeviceController)deviceController;
- (NSData)rootPublicKey;
- (NSDictionary)endpointToDeviceTypesMap;
- (NSError)removeReason;
- (NSHashTable)reportObservers;
- (NSNumber)supportedLinkLayerTypes;
- (double)handleBusyImageResponseCounter;
- (id)_categoryFromAccessoryInfo:(id)info endpoint:(id)endpoint;
- (id)_categoryFromTopology:(id)topology endpoint:(id)endpoint;
- (id)_convertFetchedCredentials:(id)credentials;
- (id)_distinctEndpointsHavingHapServicesForTopology:(id)topology;
- (id)_endCurrentMetricTimeWithName:(id)name;
- (id)_fetchSupportedThreadFeatures;
- (id)_getFirstNonOtherCategory:(id)category;
- (id)_getOperationalHardwareAddressFromReadValue:(id)value;
- (id)_getOperationalNetworkAddressForAccessory:(id)accessory;
- (id)_getSupportedLinkLayerTypesForAccessory:(id)accessory;
- (id)_getThreadHardwareAddressFromReadValue:(id)value;
- (id)_hapAccessoryAtEndpoint:(id)endpoint;
- (id)_matterCredentialsFromTHCredentials:(id)credentials;
- (id)_pairingSetupPayload;
- (id)_populateHandlingForCharacteristics:(id)characteristics;
- (id)_processEvent:(id)event;
- (id)_progressStateToString:(int64_t)string;
- (id)_readFixedCharacteristicValue:(id)value;
- (id)_readLocallyMaintainedCharacteristicValue:(id)value;
- (id)_readPastEventsFromAccessory:(id)accessory forClusters:(id)clusters;
- (id)_setupPayloadForLastCommissioning;
- (id)accessoryProductID;
- (id)accessoryVendorID;
- (id)attributeDescriptions;
- (id)collectDiagnosticsForAccessory:(id)accessory;
- (id)connectedNetworkIDFromReadValue:(id)value;
- (id)createDoorLockClusterObjectWithFlow:(id)flow;
- (id)currentDeviceTypeFromDCL;
- (id)currentWiFiNetworkInfo;
- (id)dataOfReadValue:(id)value;
- (id)deviceID;
- (id)deviceTopology;
- (id)dumpState:(id)state;
- (id)endPointForHapAccessory:(id)accessory;
- (id)endpointForDiagnosticCluster:(id)cluster clusterName:(id)name amongEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported;
- (id)endpointsForHAPAccessory:(id)accessory topology:(id)topology;
- (id)ensureCommissioningID;
- (id)errorCountOfThreadNetworkDiagnostics:(id)diagnostics;
- (id)errorCountOfWiFiNetworkDiagnostics:(id)diagnostics;
- (id)generalDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported;
- (id)getConnectNetworkIDForAccessory:(id)accessory;
- (id)getOperationalNetworkAddressForAccessory:(id)accessory;
- (id)getSupportedLinkLayerTypesForAccessory:(id)accessory;
- (id)getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:(id)map;
- (id)getThreadNetworkLinkQualityForAccessory:(id)accessory;
- (id)getWiFiNetworkLinkQualityForAccessory:(id)accessory;
- (id)highestRSSIofThreadNetworkDiagnostics:(id)diagnostics;
- (id)logIdentifier;
- (id)mergeExistingAclEntries:(id)entries withAdminNodes:(id)nodes regularUserNodes:(id)userNodes;
- (id)mergeExistingAclEntries:(id)entries withNewNodes:(id)nodes withPrivilege:(unsigned __int8)privilege;
- (id)networkCommissioningClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported;
- (id)numberOfReadValue:(id)value;
- (id)packetCountOfThreadNetworkDiagnostics:(id)diagnostics;
- (id)packetCountOfWiFiNetworkDiagnostics:(id)diagnostics;
- (id)populateACLEntriesAfterPairing;
- (id)populateACLEntriesForPairing;
- (id)privateDescription;
- (id)protocolMappingStateForCharacteristic:(id)characteristic;
- (id)readPastDiagnosticEventsFromAccessory:(id)accessory fromEventNumber:(id)number;
- (id)removeNode:(id)node withPrivilge:(unsigned __int8)privilge fromExistingAclEntries:(id)entries;
- (id)stringOfReadValue:(id)value;
- (id)threadNetworkDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported;
- (id)wifiNetworkDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported;
- (id)wifiNetworkInfoForSSID:(id)d;
- (int64_t)_getLinkLayerTypeForAccessory:(id)accessory;
- (int64_t)getLinkLayerTypeForAccessory:(id)accessory;
- (int64_t)linkLayerType;
- (int64_t)pairedState;
- (os_state_data_s)createStateData:(id)data data:(id)a4;
- (unint64_t)_registerStateCaptureHandlerWithStateCaptureInformation:(id)information;
- (unint64_t)hash;
- (unint64_t)pairingProgress;
- (void)_buildHAPCategoriesFromCHIPWithCompletionHandler:(id)handler;
- (void)_clearCommissioneeInfoAfterPairingCompletion;
- (void)_collectNetworkCredentials:(id)credentials;
- (void)_commissionWithParams:(id)params;
- (void)_continueNetworkProvisioning;
- (void)_controller:(id)_controller commissioningAndPairedNodeRecoveryComplete:(id)complete nodeID:(id)d abstractMetrics:(id)metrics;
- (void)_controller:(id)_controller commissioningComplete:(id)complete nodeID:(id)d abstractMetrics:(id)metrics;
- (void)_createFirmwareUpdateServiceWithInstanceID:(int64_t)d device:(id)device completionHandler:(id)handler;
- (void)_deleteAccessoryServerData;
- (void)_deregisterDeviceConnectedStateCaptureHandler;
- (void)_deregisterPartsListStateCaptureHandler;
- (void)_deregisterStateCaptureHandlers;
- (void)_deviceInternalStateChanged:(id)changed;
- (void)_disconnectWithError:(id)error;
- (void)_endpointForOTARequestorWithTopology:(id)topology mtrDevice:(id)device callbackQueue:(id)queue completionHandler:(id)handler;
- (void)_fetchAdditionalThreadNetworkInformationFromDevice:(id)device completion:(id)completion;
- (void)_fetchAdditionalThreadNetworkInformationWithCompletion:(id)completion;
- (void)_fetchCurrentPairingWithCompletionHandler:(id)handler;
- (void)_fetchSerialNumberWithCompletionHandler:(id)handler;
- (void)_finalizePairing;
- (void)_findSystemCommissionerPairingMatchingSetupPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager;
- (void)_finishMaximumDurationCollection;
- (void)_flushMTRDeviceReadReadyHandlers;
- (void)_getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:(id)cluster completion:(id)completion;
- (void)_getCommissioneeNetworkCommissioningClusterEndpointWithDevice:(id)device completion:(id)completion;
- (void)_handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group fabricID:(id)d rootCACert:(id)cert ipk:(id)ipk controllerNodeID:(id)iD commissioneeNodeID:(id)nodeID error:(id)error;
- (void)_handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group fabricID:(id)d rootCACert:(id)cert operationalPublicKey:(id)key ipk:(id)ipk controllerNodeID:(id)iD;
- (void)_handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group error:(id)error;
- (void)_handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group responseParams:(id)params error:(id)error;
- (void)_handleDiagnosticsEvent:(id)event;
- (void)_handleEventReport:(id)report;
- (void)_handleNewSystemCommissionerFabricNodeID:(id)d dispatchGroup:(id)group fabricID:(id)iD rootCACert:(id)cert operationalPublicKey:(id)key ipk:(id)ipk controllerNodeID:(id)nodeID device:(id)self0;
- (void)_handlePairingFailureWithError:(id)error context:(id)context;
- (void)_handleSystemCommissionerRootCertificate:(id)certificate fabricID:(id)d ipk:(id)ipk controllerNodeID:(id)iD dispatchGroup:(id)group csrResponseParams:(id)params device:(id)device;
- (void)_handleThreadRadioStateChanged;
- (void)_handleUnreachableStateWithError:(id)error;
- (void)_initAccessoriesForServer;
- (void)_metricCollectionWithError:(id)error description:(id)description progressState:(int64_t)state;
- (void)_notifyDelegateOfAccessoryMatchingCommissioningDiscriminatorDiscovered;
- (void)_notifyDelegateOfMTRMetrics:(id)metrics;
- (void)_notifyDelegateOfMatterAccessoryIsWEDAccessory:(id)accessory;
- (void)_notifyDelegateOfMatterAccessoryThreadCapabilities:(id)capabilities;
- (void)_notifyDelegateOfMatterAccessoryVendorID:(id)d productID:(id)iD deviceType:(id)type;
- (void)_notifyDelegateOfPairingProgress:(int64_t)progress error:(id)error;
- (void)_notifyDelegateOfPairingStep:(unint64_t)step;
- (void)_notifyDelegateOfSupportedLinkLayerTypes:(id)types;
- (void)_onNetworkScanResults:(id)results;
- (void)_onThreadScanResults:(id)results;
- (void)_onUnpairFinishedWithError:(id)error queue:(id)queue completion:(id)completion;
- (void)_onWiFiScanResults:(id)results;
- (void)_openPairingWindowForDuration:(double)duration completionHandler:(id)handler;
- (void)_openPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler;
- (void)_pairOnSystemCommissionerFabric;
- (void)_pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:(id)key;
- (void)_pairingComplete:(id)complete context:(id)context;
- (void)_persistAccessoryServerData;
- (void)_populateServiceForCharacteristic:(id)characteristic;
- (void)_populateThreadCredentials:(id)credentials completion:(id)completion;
- (void)_populateWifiCredentials:(id)credentials scanResults:(id)results completion:(id)completion;
- (void)_prepareThreadCredentials;
- (void)_queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:(id)characteristic completion:(id)completion;
- (void)_queueOpenPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler;
- (void)_readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:(id)characteristic responseHandler:(id)handler;
- (void)_readCharacteristicValueFromCacheWithCharacteristic:(id)characteristic responseHandler:(id)handler;
- (void)_readCharacteristicValues:(id)values timeout:(double)timeout skipCache:(BOOL)cache sendNotification:(BOOL)notification completionQueue:(id)queue completionHandler:(id)handler;
- (void)_rebuildHAPServicesFromCHIPWithCompletionHandler:(id)handler;
- (void)_reportPairingComplete;
- (void)_requestAccessoryNetworkScanWithCompletionHandler:(id)handler;
- (void)_retrieveRootEndpointPartsListWithDevice:(id)device completion:(id)completion;
- (void)_retryPairing;
- (void)_returnMatterSupportPairingAsStagedPairing;
- (void)_setCategoryForPrimaryAccessory:(id)accessory;
- (void)_setSupportedLinkLayerTypes:(id)types;
- (void)_setupMatterDevice;
- (void)_setupPairingProperties;
- (void)_setupThreadPairing;
- (void)_startCurrentMetricTimeWithName:(id)name;
- (void)_startLocallyDiscoveredAccessoryServerPairingWithRequest:(id)request fabricID:(id)d;
- (void)_startPairingWithReadyToCancelHandler:(id)handler error:(id *)error pairingEndContext:(id *)context;
- (void)_tryPairingUsingMatterSupport;
- (void)_tryPairingWithOnboardingPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager;
- (void)_unpair:(id)_unpair completion:(id)completion;
- (void)_updateAdditionalCharacteristicsFromCharacteristicUpdate:(id)update service:(id)service path:(id)path completionHandler:(id)handler;
- (void)_updateAttributeTimer:(id)timer report:(id)report timeout:(double)timeout server:(id)server;
- (void)_updateDefaultEntriesForBridgedClusterIDCharacteristicMap:(id)map;
- (void)_updateDefaultEntriesForClusterIDCharacteristicMap:(id)map;
- (void)_updateDelegateOfConnectionStatus:(BOOL)status withError:(id)error;
- (void)_updateMetricWithProgressState:(int64_t)state error:(id)error;
- (void)_updatedCharacteristicsForAttributeReport:(id)report completionHandler:(id)handler;
- (void)_updatedCharacteristicsForEventReport:(id)report completionHandler:(id)handler;
- (void)_writeCharacteristicValues:(id)values responseTuples:(id)tuples completionQueue:(id)queue completionHandler:(id)handler;
- (void)abortStagingWithError:(id)error context:(id)context;
- (void)addMetricsWithDuration:(id)duration metricsKey:(id)key;
- (void)addPairing:(id)pairing completionQueue:(id)queue completionHandler:(id)handler;
- (void)addReportObserver:(id)observer;
- (void)announceOtaProvider:(id)provider providerEndpoint:(id)endpoint immediateAnnouncement:(BOOL)announcement delayCounter:(int64_t)counter completionHandler:(id)handler;
- (void)commitStagedPairing;
- (void)configureDefaultRequiresThreadRouter;
- (void)controller:(id)controller commissioningSessionEstablishmentDone:(id)done;
- (void)controller:(id)controller readCommissioneeInfo:(id)info;
- (void)dealloc;
- (void)device:(id)device receivedAttributeReport:(id)report;
- (void)device:(id)device receivedEventReport:(id)report;
- (void)device:(id)device stateChanged:(unint64_t)changed;
- (void)deviceCachePrimed:(id)primed;
- (void)deviceConfigurationChanged:(id)changed;
- (void)disable;
- (void)disconnectWithError:(id)error;
- (void)discoverAccessories;
- (void)dispatchAfter:(unint64_t)after block:(id)block;
- (void)dispatchBlock:(id)block;
- (void)enableEvents:(BOOL)events forCharacteristics:(id)characteristics withCompletionHandler:(id)handler queue:(id)queue;
- (void)enumerateHAPServices:(id)services;
- (void)fetchColorControlClusterForHapAccessory:(id)accessory completionHandler:(id)handler;
- (void)fetchExtendedMACAddressFromDevice:(id)device completion:(id)completion;
- (void)fetchLastKnownPairingsWithCompletionHandler:(id)handler;
- (void)fetchPairingsWithCompletionHandler:(id)handler;
- (void)fetchSoftwareVersion:(BOOL)version completionHandler:(id)handler;
- (void)fetchWEDSupportInformationFromDevice:(id)device completion:(id)completion;
- (void)findSystemCommissionerPairingMatchingSetupPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager;
- (void)finishPairing;
- (void)generateAccessoryConfigurationForReason:(id)reason completionHandler:(id)handler;
- (void)handleAttestationComplete;
- (void)handleCHIPRemoteRequest:(id)request completion:(id)completion;
- (void)handleCHIPRemoteRequest:(id)request device:(id)device completion:(id)completion;
- (void)handleCommissioneeHasReceivedNetworkCredentials;
- (void)handleDownloadLogCommand:(id)command device:(id)device completion:(id)completion;
- (void)handleFirmwareUpdateStatusChange:(int64_t)change;
- (void)handleRemoveFromBrowser;
- (void)handleThreadDirectConnectionSleepyTypeChange:(BOOL)change;
- (void)handleThreadNetworkStateChangedNotification:(id)notification;
- (void)handleUpdatesForCharacteristics:(id)characteristics stateNumber:(id)number;
- (void)handleWEDDisconnectedWhileNotPairing;
- (void)identifyWithCompletion:(id)completion;
- (void)isDiscoverableWithCompletion:(id)completion;
- (void)listPairingsWithCompletionQueue:(id)queue completionHandler:(id)handler;
- (void)markAsSubscribed;
- (void)markForResubscription;
- (void)notifyDelegateOfUnauthenticatedAccessoryPromptEnded;
- (void)notifyDelegateOfUnauthenticatedAccessoryPromptStarted;
- (void)notifyMatterFirmwareRevisionNumberCharacteristicChanged;
- (void)openPairingWindowForDuration:(double)duration completionHandler:(id)handler;
- (void)openPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler;
- (void)processAttributeReport:(id)report;
- (void)queueAccessoryOperation:(id)operation highPriority:(BOOL)priority completion:(id)completion;
- (void)readPairingWindowStatusWithCompletionHandler:(id)handler;
- (void)readSpecificationVersionWithCompletionHandler:(id)handler;
- (void)refreshThreadCapabilitiesWithCompletion:(id)completion;
- (void)removeAllPairingsWithCompletionHandler:(id)handler;
- (void)removePairing:(id)pairing completionHandler:(id)handler;
- (void)removePairing:(id)pairing completionQueue:(id)queue completionHandler:(id)handler;
- (void)removeReportObserver:(id)observer;
- (void)resetNonAvailableCounters;
- (void)resetThreadNetworkDiagnosticsCountForAccessory:(id)accessory;
- (void)resetWiFiNetworkDiagnosticsCountForAccessory:(id)accessory;
- (void)setClusterIDForCharacteristic:(id)characteristic endpointID:(id)d clusterID:(id)iD;
- (void)setCommissioningID:(id)d;
- (void)setEndpointToDeviceTypesMap:(id)map;
- (void)setLinkLayerType:(int64_t)type;
- (void)setPairedState:(int64_t)state;
- (void)setPairingProgress:(unint64_t)progress;
- (void)setPrimaryAccessory:(id)accessory;
- (void)setRemoveReason:(id)reason pairingEndContextWhenRemove:(id)remove;
- (void)setSupportedLinkLayerTypes:(id)types;
- (void)setupReporting;
- (void)startPairingMetricWithActivity:(id)activity;
- (void)startPairingWithRequest:(id)request;
- (void)startStagedPairingWithCompletion:(id)completion;
- (void)startStagedPairingWithDeviceCredentialHandler:(id)handler wifiScanResultsHandler:(id)resultsHandler threadScanResultsHandler:(id)scanResultsHandler readyToCancelHandler:(id)cancelHandler progressUpdateHandler:(id)updateHandler commissioneeInfoHandler:(id)infoHandler scanningNetworks:(BOOL)networks completion:(id)self0;
- (void)stopPairingWithError:(id *)error metricsReadyHandler:(id)handler;
- (void)timerDidFire:(id)fire;
- (void)triggerEstablishingMatterSubscription;
- (void)tryPairingWithOnboardingPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager;
- (void)updateAccessoryControlToAdministratorNodes:(id)nodes sharedUserNodes:(id)userNodes completion:(id)completion;
- (void)updateAccessoryControlToIncludeAdministratorNodes:(id)nodes sharedUserNodes:(id)userNodes completion:(id)completion;
- (void)updateAccessoryControlToRemoveAdministratorNode:(id)node completion:(id)completion;
- (void)updateAccessoryName:(id)name;
- (void)updateAllCharacteristicValuesPostHAPServiceEnumeration:(id)enumeration;
- (void)updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory:(id)accessory completion:(id)completion;
- (void)updateDefaultOtaProvider:(id)provider providerEndpoint:(id)endpoint completionHandler:(id)handler;
- (void)updateFabricLabel:(id)label completionHandler:(id)handler;
- (void)updateSoftwareVersion:(id)version;
- (void)updateVidPidWithAttestationDeviceInfo:(id)info;
- (void)validateAttestationDeviceInfo:(id)info error:(id)error completion:(id)completion;
- (void)writeCharacteristicValues:(id)values timeout:(double)timeout expiry:(id)expiry completionQueue:(id)queue completionHandler:(id)handler;
@end

@implementation HMMTRAccessoryServer

- (id)endPointForHapAccessory:(id)accessory
{
  services = [accessory services];
  v4 = [services hmf_objectPassingTest:&__block_literal_global_49];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v5 = v4;
  }

  else
  {
    v5 = 0;
  }

  v6 = v5;

  endpoint = [v6 endpoint];

  return endpoint;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory__endPointForHapAccessory___block_invoke(uint64_t a1, void *a2)
{
  v2 = [a2 type];
  v3 = [v2 isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

  return v3;
}

- (id)_hapAccessoryAtEndpoint:(id)endpoint
{
  endpointCopy = endpoint;
  accessories = [(HAPAccessoryServer *)self accessories];
  v6 = [accessories count];

  if (v6 == 1)
  {
    primaryAccessory = [(HMMTRAccessoryServer *)self primaryAccessory];
  }

  else
  {
    deviceTopology = [(HMMTRAccessoryServer *)self deviceTopology];
    accessories2 = [(HAPAccessoryServer *)self accessories];
    v12[0] = MEMORY[0x277D85DD0];
    v12[1] = 3221225472;
    v12[2] = __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke;
    v12[3] = &unk_2786EC6E8;
    v13 = deviceTopology;
    v14 = endpointCopy;
    v10 = deviceTopology;
    primaryAccessory = [accessories2 hmf_objectPassingTest:v12];
  }

  return primaryAccessory;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke(uint64_t a1, void *a2)
{
  v3 = [a2 services];
  v4 = [v3 hmf_objectPassingTest:&__block_literal_global_58];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v5 = v4;
  }

  else
  {
    v5 = 0;
  }

  v6 = v5;

  v7 = *(a1 + 32);
  v8 = [v6 endpoint];
  v9 = [v7 getPartsListAtEndpoint:v8];

  v10 = [v6 endpoint];

  if ([v10 isEqual:*(a1 + 40)])
  {
    v11 = 1;
  }

  else
  {
    v11 = [v9 containsObject:*(a1 + 40)];
  }

  return v11;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke_2(uint64_t a1, void *a2)
{
  v2 = [a2 type];
  v3 = [v2 isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

  return v3;
}

- (void)handleCHIPRemoteRequest:(id)request completion:(id)completion
{
  v27 = *MEMORY[0x277D85DE8];
  requestCopy = request;
  completionCopy = completion;
  v8 = random();
  v9 = objc_autoreleasePoolPush();
  selfCopy = self;
  v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = HMFGetLogIdentifier();
    *buf = 138543618;
    v24 = v12;
    v25 = 2048;
    v26 = v8;
    _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) queued.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v9);
  v19[0] = MEMORY[0x277D85DD0];
  v19[1] = 3221225472;
  v19[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke;
  v19[3] = &unk_2786EF850;
  v22 = v8;
  v19[4] = selfCopy;
  v20 = requestCopy;
  v21 = completionCopy;
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_21;
  v16[3] = &unk_2786ED9B0;
  v17 = v21;
  v18 = v8;
  v16[4] = selfCopy;
  v13 = requestCopy;
  v14 = v21;
  [(HMMTRAccessoryServer *)selfCopy queueAccessoryOperation:v19 highPriority:0 completion:v16];

  v15 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke(uint64_t a1)
{
  v34 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 56);
    *buf = 138543618;
    v31 = v5;
    v32 = 2048;
    v33 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = [*(a1 + 32) deviceController];
  if (v7 && (v8 = MEMORY[0x277CD5220], [*(a1 + 32) nodeID], v9 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v8, "deviceWithNodeID:controller:", v9, v7), v10 = objc_claimAutoreleasedReturnValue(), v9, v10))
  {
    v11 = *(a1 + 32);
    v12 = *(a1 + 40);
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_18;
    v27[3] = &unk_2786ED988;
    v14 = *(a1 + 48);
    v13 = *(a1 + 56);
    v27[4] = v11;
    v29 = v13;
    v28 = v14;
    [v11 handleCHIPRemoteRequest:v12 device:v10 completion:v27];
  }

  else
  {
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      v19 = *(a1 + 56);
      *buf = 138543618;
      v31 = v18;
      v32 = 2048;
      v33 = v19;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@Device not found to handle remote request job(%lu)", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v20 = objc_autoreleasePoolPush();
    v21 = *(a1 + 32);
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      v24 = *(a1 + 56);
      *buf = 138543618;
      v31 = v23;
      v32 = 2048;
      v33 = v24;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) complete.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v20);
    v25 = *(a1 + 48);
    v10 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:2 userInfo:0];
    (*(v25 + 16))(v25, 0, v10);
  }

  v26 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_21(uint64_t a1, void *a2)
{
  v14 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      v8 = *(a1 + 48);
      v10 = 138543618;
      v11 = v7;
      v12 = 2048;
      v13 = v8;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) unscheduled.", &v10, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
    (*(*(a1 + 40) + 16))();
  }

  v9 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_18(uint64_t a1, void *a2, void *a3)
{
  v17 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = HMFGetLogIdentifier();
    v11 = *(a1 + 48);
    v13 = 138543618;
    v14 = v10;
    v15 = 2048;
    v16 = v11;
    _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) complete.", &v13, 0x16u);
  }

  objc_autoreleasePoolPop(v7);
  (*(*(a1 + 40) + 16))();

  v12 = *MEMORY[0x277D85DE8];
}

- (void)handleDownloadLogCommand:(id)command device:(id)device completion:(id)completion
{
  v28 = *MEMORY[0x277D85DE8];
  commandCopy = command;
  deviceCopy = device;
  completionCopy = completion;
  cHIPDownloadLogType = [commandCopy CHIPDownloadLogType];
  cHIPDownloadTimeout = [commandCopy CHIPDownloadTimeout];
  v13 = cHIPDownloadTimeout;
  if (cHIPDownloadLogType && cHIPDownloadTimeout)
  {
    integerValue = [cHIPDownloadLogType integerValue];
    [v13 doubleValue];
    v16 = v15;
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __81__HMMTRAccessoryServer_RemoteAccess__handleDownloadLogCommand_device_completion___block_invoke;
    v24[3] = &unk_2786ED960;
    v24[4] = self;
    v25 = completionCopy;
    [deviceCopy downloadLogOfType:integerValue timeout:clientQueue queue:v24 completion:v16];
  }

  else
  {
    v18 = objc_autoreleasePoolPush();
    selfCopy = self;
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = HMFGetLogIdentifier();
      *buf = 138543362;
      v27 = v21;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_ERROR, "%{public}@Download log command w/o valid log type/timeout", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v18);
    v22 = [MEMORY[0x277CCA9B8] hapErrorWithCode:9];
    (*(completionCopy + 2))(completionCopy, 0, v22);
  }

  v23 = *MEMORY[0x277D85DE8];
}

void __81__HMMTRAccessoryServer_RemoteAccess__handleDownloadLogCommand_device_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v43 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = [v5 lastPathComponent];
  v8 = objc_autoreleasePoolPush();
  v9 = *(a1 + 32);
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543874;
    v38 = v11;
    v39 = 2112;
    v40 = v5;
    v41 = 2112;
    v42 = v6;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Did download to URL: %@. Error: %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v8);
  if (v5 && !v6 && v7)
  {
    v12 = [MEMORY[0x277D0F8D0] sharedPreferences];
    v13 = [v12 preferenceForKey:@"maxAccessoryLogSize"];
    v14 = [v13 numberValue];
    v15 = [v14 unsignedIntegerValue];

    v16 = [MEMORY[0x277CCAA00] defaultManager];
    v17 = [v5 path];
    v34 = 0;
    v18 = [v16 attributesOfItemAtPath:v17 error:&v34];
    v19 = v34;

    v20 = [v18 fileSize];
    v21 = v20;
    if (v19 || v20 > v15)
    {
      v25 = objc_autoreleasePoolPush();
      v26 = *(a1 + 32);
      v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        HMFGetLogIdentifier();
        v28 = v32 = v25;
        v29 = [MEMORY[0x277CCABB0] numberWithUnsignedInteger:v21];
        *buf = 138543874;
        v38 = v28;
        v39 = 2112;
        v40 = v29;
        v41 = 2112;
        v42 = v19;
        _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_ERROR, "%{public}@Invalid log file with size %@. Error: %@", buf, 0x20u);

        v25 = v32;
      }

      objc_autoreleasePoolPop(v25);
      v30 = *(a1 + 40);
      if (!v19)
      {
        v19 = [MEMORY[0x277CCA9B8] hapErrorWithCode:12];
      }

      (*(v30 + 16))(v30, 0, v19);
    }

    else
    {
      v33 = 0;
      v22 = [MEMORY[0x277CBEA90] dataWithContentsOfURL:v5 options:0 error:&v33];
      v19 = v33;
      if (v22)
      {
        v35[0] = @"fileData";
        v35[1] = @"fileName";
        v36[0] = v22;
        v36[1] = v7;
        v23 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v36 forKeys:v35 count:2];
      }

      else
      {
        v23 = 0;
      }

      (*(*(a1 + 40) + 16))();
    }

    goto LABEL_21;
  }

  v24 = *(a1 + 40);
  if (!v6)
  {
    v18 = [MEMORY[0x277CCA9B8] hapErrorWithCode:12];
    (*(v24 + 16))(v24, 0, v18);
LABEL_21:

    goto LABEL_22;
  }

  (*(v24 + 16))(v24, 0, v6);
LABEL_22:

  v31 = *MEMORY[0x277D85DE8];
}

- (void)handleCHIPRemoteRequest:(id)request device:(id)device completion:(id)completion
{
  v74 = *MEMORY[0x277D85DE8];
  requestCopy = request;
  deviceCopy = device;
  completionCopy = completion;
  v10 = [requestCopy objectForKeyedSubscript:@"command"];
  if (v10)
  {
    cHIPEndpointID = [requestCopy CHIPEndpointID];
    cHIPClusterID = [requestCopy CHIPClusterID];
    cHIPAttributeID = [requestCopy CHIPAttributeID];
    cHIPCommandID = [requestCopy CHIPCommandID];
    if ([v10 isEqualToString:@"read"])
    {
      objc_initWeak(location, self);
      cHIPReadParams = [requestCopy CHIPReadParams];
      clientQueue = [(HAPAccessoryServer *)self clientQueue];
      v65[0] = MEMORY[0x277D85DD0];
      v65[1] = 3221225472;
      v65[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke;
      v65[3] = &unk_2786ED938;
      objc_copyWeak(&v68, location);
      v66 = v10;
      v67 = completionCopy;
      [deviceCopy readAttributeWithEndpointId:cHIPEndpointID clusterId:cHIPClusterID attributeId:cHIPAttributeID params:cHIPReadParams clientQueue:clientQueue completion:v65];

      objc_destroyWeak(&v68);
      objc_destroyWeak(location);
    }

    else if ([v10 isEqualToString:@"write"])
    {
      v19 = [requestCopy objectForKeyedSubscript:@"data"];
      if (v19)
      {
        objc_initWeak(location, self);
        cHIPTimedWriteTimeout = [requestCopy CHIPTimedWriteTimeout];
        clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
        v61[0] = MEMORY[0x277D85DD0];
        v61[1] = 3221225472;
        v61[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_9;
        v61[3] = &unk_2786ED938;
        objc_copyWeak(&v64, location);
        v62 = v10;
        v63 = completionCopy;
        [deviceCopy writeAttributeWithEndpointId:cHIPEndpointID clusterId:cHIPClusterID attributeId:cHIPAttributeID value:v19 timedWriteTimeout:cHIPTimedWriteTimeout clientQueue:clientQueue2 completion:v61];

        objc_destroyWeak(&v64);
        objc_destroyWeak(location);
      }

      else
      {
        v53 = objc_autoreleasePoolPush();
        selfCopy = self;
        v32 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = HMFGetLogIdentifier();
          *location = 138543618;
          *&location[4] = v33;
          v72 = 2112;
          v73 = requestCopy;
          _os_log_impl(&dword_22AEAE000, v32, OS_LOG_TYPE_ERROR, "%{public}@data field missing from CHIP remote request message payload: %@", location, 0x16u);
        }

        objc_autoreleasePoolPop(v53);
        v34 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:2 userInfo:0];
        (*(completionCopy + 2))(completionCopy, 0, v34);
      }
    }

    else if ([v10 isEqualToString:@"command"])
    {
      if (cHIPCommandID && cHIPClusterID)
      {
        cHIPCommandFields = [requestCopy CHIPCommandFields];
        if (!cHIPCommandFields)
        {
          v23 = *MEMORY[0x277CD5180];
          v24 = *MEMORY[0x277CD51A0];
          v69[0] = *MEMORY[0x277CD5188];
          v69[1] = v24;
          v70[0] = v23;
          v70[1] = MEMORY[0x277CBEBF8];
          cHIPCommandFields = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v70 forKeys:v69 count:2];
        }

        objc_initWeak(location, self);
        cHIPTimedInvokeTimeout = [requestCopy CHIPTimedInvokeTimeout];
        clientQueue3 = [(HAPAccessoryServer *)self clientQueue];
        v57[0] = MEMORY[0x277D85DD0];
        v57[1] = 3221225472;
        v57[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_11;
        v57[3] = &unk_2786ED938;
        objc_copyWeak(&v60, location);
        v58 = v10;
        v59 = completionCopy;
        [deviceCopy invokeCommandWithEndpointId:cHIPEndpointID clusterId:cHIPClusterID commandId:cHIPCommandID commandFields:cHIPCommandFields timedInvokeTimeout:cHIPTimedInvokeTimeout clientQueue:clientQueue3 completion:v57];

        objc_destroyWeak(&v60);
        objc_destroyWeak(location);
      }

      else
      {
        v35 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v37 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          v38 = HMFGetLogIdentifier();
          *location = 138543362;
          *&location[4] = v38;
          _os_log_impl(&dword_22AEAE000, v37, OS_LOG_TYPE_ERROR, "%{public}@Invoke CHIP command with no specific command path", location, 0xCu);
        }

        objc_autoreleasePoolPop(v35);
        v39 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:9 userInfo:0];
        (*(completionCopy + 2))(completionCopy, 0, v39);
      }
    }

    else if ([v10 isEqualToString:@"subscribe"])
    {
      cHIPMinInterval = [requestCopy CHIPMinInterval];
      cHIPMaxInterval = [requestCopy CHIPMaxInterval];
      if (cHIPMinInterval && cHIPMaxInterval)
      {
        v27 = objc_alloc_init(MEMORY[0x277CBEB38]);
        [v27 setCHIPRemoteCommand:v10];
        context = objc_autoreleasePoolPush();
        selfCopy3 = self;
        v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          HMFGetLogIdentifier();
          v30 = *location = 138543618;
          *&location[4] = v30;
          v72 = 2112;
          v73 = v27;
          _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_DEBUG, "%{public}@Subscribe CHIP attribute responded with %@", location, 0x16u);
        }

        objc_autoreleasePoolPop(context);
        (*(completionCopy + 2))(completionCopy, v27, 0);
      }

      else
      {
        v45 = objc_autoreleasePoolPush();
        selfCopy4 = self;
        v47 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v48 = HMFGetLogIdentifier();
          *location = 138543362;
          *&location[4] = v48;
          _os_log_impl(&dword_22AEAE000, v47, OS_LOG_TYPE_ERROR, "%{public}@Subscribe CHIP attribute with no specific min/max interval", location, 0xCu);
        }

        objc_autoreleasePoolPop(v45);
        v27 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:9 userInfo:0];
        (*(completionCopy + 2))(completionCopy, 0, v27);
      }
    }

    else if ([v10 isEqualToString:@"downloadLog"])
    {
      [(HMMTRAccessoryServer *)self handleDownloadLogCommand:requestCopy device:deviceCopy completion:completionCopy];
    }

    else
    {
      v40 = objc_autoreleasePoolPush();
      selfCopy5 = self;
      v42 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        v43 = HMFGetLogIdentifier();
        *location = 138543362;
        *&location[4] = v43;
        _os_log_impl(&dword_22AEAE000, v42, OS_LOG_TYPE_ERROR, "%{public}@Unsupported manufacturer extension control command", location, 0xCu);
      }

      objc_autoreleasePoolPop(v40);
      v44 = [MEMORY[0x277CCA9B8] hapErrorWithCode:3 marker:239];
      (*(completionCopy + 2))(completionCopy, 0, v44);
    }
  }

  else
  {
    v15 = objc_autoreleasePoolPush();
    selfCopy6 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      *location = 138543618;
      *&location[4] = v18;
      v72 = 2112;
      v73 = requestCopy;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@command field missing from CHIP remote request message payload: %@", location, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    cHIPEndpointID = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:2 userInfo:0];
    (*(completionCopy + 2))(completionCopy, 0, cHIPEndpointID);
  }

  v49 = *MEMORY[0x277D85DE8];
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  if (WeakRetained)
  {
    v9 = objc_autoreleasePoolPush();
    v10 = WeakRetained;
    v11 = HMFGetOSLogHandle();
    v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v13 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v13;
        v25 = 2112;
        v26 = v6;
        v14 = "%{public}@Read CHIP attribute completed with an error: %@";
        v15 = v12;
        v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_22AEAE000, v15, v16, v14, &v23, 0x16u);
      }
    }

    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v13;
      v25 = 2112;
      v26 = v5;
      v14 = "%{public}@Read CHIP attribute completed with value: %@";
      v15 = v12;
      v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }

    objc_autoreleasePoolPop(v9);
  }

  if (v5)
  {
    v17 = objc_alloc_init(MEMORY[0x277CBEB38]);
    [v17 setCHIPRemoteCommand:*(a1 + 32)];
    [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      v18 = objc_autoreleasePoolPush();
      v19 = WeakRetained;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v21;
        v25 = 2112;
        v26 = v17;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Read CHIP attribute responded with %@", &v23, 0x16u);
      }

      objc_autoreleasePoolPop(v18);
    }

    (*(*(a1 + 40) + 16))();
  }

  else
  {
    (*(*(a1 + 40) + 16))(*(a1 + 40), 0, v6, v7);
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_9(uint64_t a1, void *a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  if (WeakRetained)
  {
    v9 = objc_autoreleasePoolPush();
    v10 = WeakRetained;
    v11 = HMFGetOSLogHandle();
    v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v13 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v13;
        v25 = 2112;
        v26 = v6;
        v14 = "%{public}@Write CHIP attribute completed with an error: %@";
        v15 = v12;
        v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_22AEAE000, v15, v16, v14, &v23, 0x16u);
      }
    }

    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v13;
      v25 = 2112;
      v26 = v5;
      v14 = "%{public}@Write CHIP attribute completed with values: %@";
      v15 = v12;
      v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }

    objc_autoreleasePoolPop(v9);
  }

  if (v5)
  {
    v17 = objc_alloc_init(MEMORY[0x277CBEB38]);
    [v17 setCHIPRemoteCommand:*(a1 + 32)];
    [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      v18 = objc_autoreleasePoolPush();
      v19 = WeakRetained;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v21;
        v25 = 2112;
        v26 = v17;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Write CHIP attribute responded with %@", &v23, 0x16u);
      }

      objc_autoreleasePoolPop(v18);
    }

    (*(*(a1 + 40) + 16))();
  }

  else
  {
    (*(*(a1 + 40) + 16))(*(a1 + 40), 0, v6, v7);
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_11(uint64_t a1, void *a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  if (WeakRetained)
  {
    v9 = objc_autoreleasePoolPush();
    v10 = WeakRetained;
    v11 = HMFGetOSLogHandle();
    v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v13 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v13;
        v25 = 2112;
        v26 = v6;
        v14 = "%{public}@Invoke CHIP command completed with an error: %@";
        v15 = v12;
        v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_22AEAE000, v15, v16, v14, &v23, 0x16u);
      }
    }

    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v13;
      v25 = 2112;
      v26 = v5;
      v14 = "%{public}@Invoke CHIP command completed with response: %@";
      v15 = v12;
      v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }

    objc_autoreleasePoolPop(v9);
  }

  if (v5)
  {
    v17 = objc_alloc_init(MEMORY[0x277CBEB38]);
    [v17 setCHIPRemoteCommand:*(a1 + 32)];
    [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      v18 = objc_autoreleasePoolPush();
      v19 = WeakRetained;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        v23 = 138543618;
        v24 = v21;
        v25 = 2112;
        v26 = v17;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Invoke CHIP command responded with %@", &v23, 0x16u);
      }

      objc_autoreleasePoolPop(v18);
    }

    (*(*(a1 + 40) + 16))();
  }

  else
  {
    (*(*(a1 + 40) + 16))(*(a1 + 40), 0, v6, v7);
  }

  v22 = *MEMORY[0x277D85DE8];
}

- (id)_getThreadHardwareAddressFromReadValue:(id)value
{
  v82 = *MEMORY[0x277D85DE8];
  valueCopy = value;
  v5 = valueCopy;
  if (!valueCopy)
  {
    v9 = 0;
    goto LABEL_58;
  }

  v64 = *MEMORY[0x277CD5188];
  v6 = [valueCopy objectForKeyedSubscript:?];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v7 = v6;
  }

  else
  {
    v7 = 0;
  }

  v8 = v7;

  v57 = v8;
  v9 = 0;
  if (![v8 isEqual:*MEMORY[0x277CD50B0]])
  {
    goto LABEL_57;
  }

  v61 = *MEMORY[0x277CD51A0];
  v10 = [v5 objectForKeyedSubscript:?];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v11 = v10;
  }

  else
  {
    v11 = 0;
  }

  v12 = v11;

  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  obj = v12;
  v13 = [obj countByEnumeratingWithState:&v76 objects:v81 count:16];
  if (!v13)
  {
    v9 = 0;
    goto LABEL_56;
  }

  v14 = v13;
  v56 = v5;
  v15 = *v77;
  v16 = *MEMORY[0x277CD50D8];
  v17 = *MEMORY[0x277CD5180];
  v18 = 0x277CBE000uLL;
  v65 = *MEMORY[0x277CD50D0];
  v58 = *MEMORY[0x277CD5180];
  v59 = *v77;
LABEL_11:
  v19 = 0;
  v60 = v14;
  while (1)
  {
    if (*v77 != v15)
    {
      objc_enumerationMutation(obj);
    }

    v20 = [*(*(&v76 + 1) + 8 * v19) objectForKeyedSubscript:{v16, v56}];
    v21 = *(v18 + 2752);
    objc_opt_class();
    v22 = (objc_opt_isKindOfClass() & 1) != 0 ? v20 : 0;
    v23 = v22;

    v24 = [v23 objectForKeyedSubscript:v64];
    objc_opt_class();
    v25 = (objc_opt_isKindOfClass() & 1) != 0 ? v24 : 0;
    v26 = v25;

    v27 = v23;
    if ([v26 isEqual:v17])
    {
      break;
    }

LABEL_49:

    if (++v19 == v14)
    {
      v14 = [obj countByEnumeratingWithState:&v76 objects:v81 count:16];
      if (!v14)
      {
        v9 = 0;
        goto LABEL_54;
      }

      goto LABEL_11;
    }
  }

  v63 = v19;
  v70 = v23;
  v28 = [v23 objectForKeyedSubscript:v61];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v29 = v28;
  }

  else
  {
    v29 = 0;
  }

  v30 = v29;

  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v31 = v30;
  v71 = [v31 countByEnumeratingWithState:&v72 objects:v80 count:16];
  if (!v71)
  {

    v53 = v31;
    v9 = 0;
    v27 = v70;
LABEL_48:

    v19 = v63;
    goto LABEL_49;
  }

  v69 = 0;
  v66 = 0;
  v67 = v31;
  v68 = *v73;
  v32 = v65;
  do
  {
    for (i = 0; i != v71; ++i)
    {
      v34 = v26;
      if (*v73 != v68)
      {
        objc_enumerationMutation(v67);
      }

      v35 = *(*(&v72 + 1) + 8 * i);
      v36 = [v35 objectForKeyedSubscript:v32];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v37 = v36;
      }

      else
      {
        v37 = 0;
      }

      v38 = v37;

      if ([v38 isEqual:&unk_283EE7E00])
      {
        v39 = [v35 objectForKeyedSubscript:v16];
        v40 = *(v18 + 2752);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v41 = v39;
        }

        else
        {
          v41 = 0;
        }

        v42 = v41;

        v43 = [(HMMTRAccessoryServer *)self numberOfReadValue:v42];

        v69 |= [v43 isEqualToNumber:&unk_283EE7E18];
      }

      else
      {
        if (![v38 isEqual:&unk_283EE7DE8])
        {
          goto LABEL_43;
        }

        v44 = [v35 objectForKeyedSubscript:v16];
        v45 = *(v18 + 2752);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v46 = v44;
        }

        else
        {
          v46 = 0;
        }

        v47 = v46;

        v43 = [(HMMTRAccessoryServer *)self dataOfReadValue:v47];
        v48 = v16;
        v49 = [objc_alloc(MEMORY[0x277D0F7E8]) initWithAddressData:v43];
        [v49 formattedString];
        v50 = v18;
        v52 = v51 = self;

        v16 = v48;
        v66 = v52;
        self = v51;
        v18 = v50;
        v32 = v65;
      }

LABEL_43:
      v26 = v34;

      v27 = v70;
    }

    v71 = [v67 countByEnumeratingWithState:&v72 objects:v80 count:16];
  }

  while (v71);

  v9 = v66;
  if ((v69 & (v66 != 0)) == 0)
  {
    v15 = v59;
    v14 = v60;
    v17 = v58;
    v53 = v67;
    goto LABEL_48;
  }

LABEL_54:
  v5 = v56;
LABEL_56:

LABEL_57:
LABEL_58:

  v54 = *MEMORY[0x277D85DE8];

  return v9;
}

- (id)_getOperationalHardwareAddressFromReadValue:(id)value
{
  v80 = *MEMORY[0x277D85DE8];
  valueCopy = value;
  v5 = valueCopy;
  if (valueCopy)
  {
    v6 = *MEMORY[0x277CD5188];
    v7 = [valueCopy objectForKeyedSubscript:*MEMORY[0x277CD5188]];
    v8 = 0x277CCA000uLL;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v9 = v7;
    }

    else
    {
      v9 = 0;
    }

    v10 = v9;

    v11 = 0;
    v12 = 0;
    if ([v10 isEqual:*MEMORY[0x277CD50B0]])
    {
      selfCopy = self;
      v59 = *MEMORY[0x277CD51A0];
      v13 = [v5 objectForKeyedSubscript:?];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v14 = v13;
      }

      else
      {
        v14 = 0;
      }

      v15 = v14;

      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      obj = v15;
      v12 = [obj countByEnumeratingWithState:&v74 objects:v79 count:16];
      if (v12)
      {
        v55 = v10;
        v56 = v5;
        LOBYTE(v5) = 0;
        v68 = 0;
        v16 = *v75;
        v67 = *MEMORY[0x277CD50D8];
        v64 = *MEMORY[0x277CD5180];
        v17 = *MEMORY[0x277CD50D0];
        v18 = selfCopy;
        v57 = *v75;
        v58 = v6;
        while (2)
        {
          v19 = 0;
          v60 = v12;
          do
          {
            if (*v75 != v16)
            {
              objc_enumerationMutation(obj);
            }

            if (v5)
            {
              v12 = v68;
              v11 = v68;
              goto LABEL_56;
            }

            v20 = [*(*(&v74 + 1) + 8 * v19) objectForKeyedSubscript:v67];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              v21 = v20;
            }

            else
            {
              v21 = 0;
            }

            v22 = v21;

            v23 = [v22 objectForKeyedSubscript:v6];
            v24 = v8;
            v25 = *(v8 + 3240);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              v26 = v23;
            }

            else
            {
              v26 = 0;
            }

            v27 = v6;
            v28 = v26;

            v29 = v28;
            v65 = v22;
            if ([v28 isEqual:v64])
            {
              v62 = v28;
              v63 = v19;
              v30 = [v22 objectForKeyedSubscript:v59];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                v31 = v30;
              }

              else
              {
                v31 = 0;
              }

              v32 = v31;

              v72 = 0u;
              v73 = 0u;
              v70 = 0u;
              v71 = 0u;
              v69 = v32;
              v33 = [v69 countByEnumeratingWithState:&v70 objects:v78 count:16];
              if (v33)
              {
                v34 = v33;
                LODWORD(v5) = 0;
                v35 = *v71;
                v36 = v67;
                do
                {
                  for (i = 0; i != v34; ++i)
                  {
                    if (*v71 != v35)
                    {
                      objc_enumerationMutation(v69);
                    }

                    v38 = *(*(&v70 + 1) + 8 * i);
                    v39 = [v38 objectForKeyedSubscript:v17];
                    objc_opt_class();
                    if (objc_opt_isKindOfClass())
                    {
                      v40 = v39;
                    }

                    else
                    {
                      v40 = 0;
                    }

                    v41 = v40;

                    if ([v41 isEqual:&unk_283EE7DA0])
                    {
                      v42 = [v38 objectForKeyedSubscript:v36];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        v43 = v42;
                      }

                      else
                      {
                        v43 = 0;
                      }

                      v44 = v43;

                      v45 = [(HMMTRAccessoryServer *)v18 numberOfReadValue:v44];

                      LODWORD(v5) = [v45 BOOLValue] | v5;
                    }

                    else if ([v41 isEqual:&unk_283EE7DE8])
                    {
                      v46 = [v38 objectForKeyedSubscript:v36];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        v47 = v46;
                      }

                      else
                      {
                        v47 = 0;
                      }

                      v48 = v47;

                      v49 = [(HMMTRAccessoryServer *)v18 dataOfReadValue:v48];
                      v50 = [objc_alloc(MEMORY[0x277D0F7E8]) initWithAddressData:v49];
                      formattedString = [v50 formattedString];

                      v68 = formattedString;
                      v18 = selfCopy;
                      v36 = v67;
                    }
                  }

                  v34 = [v69 countByEnumeratingWithState:&v70 objects:v78 count:16];
                }

                while (v34);
              }

              else
              {
                LOBYTE(v5) = 0;
              }

              v16 = v57;
              v6 = v58;
              v8 = 0x277CCA000;
              v12 = v60;
              v29 = v62;
              v19 = v63;
            }

            else
            {
              LOBYTE(v5) = 0;
              v6 = v27;
              v8 = v24;
            }

            v19 = v19 + 1;
          }

          while (v19 != v12);
          v12 = [obj countByEnumeratingWithState:&v74 objects:v79 count:16];
          if (v12)
          {
            continue;
          }

          break;
        }

        v12 = v68;
        if (v5)
        {
          v11 = v68;
        }

        else
        {
          v11 = 0;
        }

LABEL_56:
        v10 = v55;
        v5 = v56;
      }

      else
      {
        v11 = 0;
      }
    }

    v52 = v11;
  }

  else
  {
    v52 = 0;
  }

  v53 = *MEMORY[0x277D85DE8];

  return v52;
}

- (id)_getOperationalNetworkAddressForAccessory:(id)accessory
{
  v33 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice)
  {
    v6 = [HMMTRDeviceTopology alloc];
    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    v8 = [(HMMTRDeviceTopology *)v6 initWithNodeId:nodeID server:self];

    if (v8)
    {
      dictionary = [MEMORY[0x277CBEB38] dictionary];
      v10 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:accessoryCopy topology:v8];
      v30 = 0;
      if (![v10 count])
      {

        v10 = &unk_283EE9210;
      }

      matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
      v12 = [(HMMTRAccessoryServer *)self generalDiagnosticsClusterFromEndpoints:v10 topology:v8 device:matterDevice2 definitelyUnsupported:&v30];

      if (v12)
      {
        v13 = [v12 readAttributeNetworkInterfacesWithParams:0];
        v14 = [(HMMTRAccessoryServer *)self _getOperationalHardwareAddressFromReadValue:v13];

        [dictionary setObject:v14 forKeyedSubscript:@"hardware_address"];
        v15 = dictionary;
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          *buf = 138543362;
          v32 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Matter device doesn't have general diagnostic cluster", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
        v15 = 0;
      }
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = HMFGetLogIdentifier();
        *buf = 138543362;
        v32 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@Matter topology is nil", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v15 = 0;
    }
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543362;
      v32 = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@Matter device is nil", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v16);
    v15 = 0;
  }

  v28 = *MEMORY[0x277D85DE8];

  return v15;
}

- (void)_handleDiagnosticsEvent:(id)event
{
  v282 = *MEMORY[0x277D85DE8];
  eventCopy = event;
  v5 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD5140]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v6 = v5;
  }

  else
  {
    v6 = 0;
  }

  v7 = v6;

  v8 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD5138]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v9 = v8;
  }

  else
  {
    v9 = 0;
  }

  v10 = v9;

  v11 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD5148]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  v13 = v12;

  cluster = [v7 cluster];
  v15 = [cluster isEqual:&unk_283EE7D58];

  if (v15)
  {
    event = [v7 event];
    v17 = [event isEqual:&unk_283EE7D88];

    if (v17)
    {
      v220 = v13;
      v18 = *MEMORY[0x277CD50D8];
      v19 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD50D8]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v20 = v19;
      }

      else
      {
        v20 = 0;
      }

      v21 = v20;

      if (v21)
      {
        v22 = [v21 objectForKeyedSubscript:*MEMORY[0x277CD5188]];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v23 = v22;
        }

        else
        {
          v23 = 0;
        }

        v24 = v23;

        v221 = v24;
        if ([v24 isEqual:*MEMORY[0x277CD5180]])
        {
          selfCopy8 = self;
          v214 = eventCopy;
          v218 = v10;
          v209 = v7;
          v206 = v21;
          v25 = [v21 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v26 = v25;
          }

          else
          {
            v26 = 0;
          }

          v27 = v26;

          if (v27)
          {
            v250 = 0u;
            v251 = 0u;
            v248 = 0u;
            v249 = 0u;
            obj = v27;
            v28 = [obj countByEnumeratingWithState:&v248 objects:v281 count:16];
            if (!v28)
            {
LABEL_38:

              v40 = selfCopy8;
LABEL_110:
              v125 = objc_autoreleasePoolPush();
              v126 = v40;
              v127 = HMFGetOSLogHandle();
              v7 = v209;
              eventCopy = v214;
              if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
              {
                v128 = HMFGetLogIdentifier();
                *buf = 138543618;
                v266 = v128;
                v267 = 2112;
                v268 = v214;
                _os_log_impl(&dword_22AEAE000, v127, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics ConnectionStatus event data has unexpected structure: %@", buf, 0x16u);
              }

              goto LABEL_194;
            }

            v29 = v28;
            v30 = *v249;
            v31 = *MEMORY[0x277CD50D0];
LABEL_26:
            v32 = 0;
            while (1)
            {
              if (*v249 != v30)
              {
                objc_enumerationMutation(obj);
              }

              v33 = *(*(&v248 + 1) + 8 * v32);
              v34 = [v33 objectForKeyedSubscript:v31];
              objc_opt_class();
              v35 = (objc_opt_isKindOfClass() & 1) != 0 ? v34 : 0;
              v36 = v35;

              v37 = [v33 objectForKeyedSubscript:v18];
              objc_opt_class();
              v38 = (objc_opt_isKindOfClass() & 1) != 0 ? v37 : 0;
              v39 = v38;

              if ([v36 isEqual:&unk_283EE7D88])
              {
                break;
              }

              if (v29 == ++v32)
              {
                v29 = [obj countByEnumeratingWithState:&v248 objects:v281 count:16];
                if (v29)
                {
                  goto LABEL_26;
                }

                goto LABEL_38;
              }
            }

            v40 = selfCopy8;
            v115 = [(HMMTRAccessoryServer *)selfCopy8 numberOfReadValue:v39];

            if (!v115)
            {
              goto LABEL_110;
            }

            v116 = objc_autoreleasePoolPush();
            v117 = selfCopy8;
            v118 = HMFGetOSLogHandle();
            v7 = v209;
            v10 = v218;
            if (os_log_type_enabled(v118, OS_LOG_TYPE_INFO))
            {
              v119 = HMFGetLogIdentifier();
              primaryAccessory = [(HMMTRAccessoryServer *)v117 primaryAccessory];
              shortDescription = [primaryAccessory shortDescription];
              *buf = 138544386;
              v266 = v119;
              v267 = 2112;
              v268 = shortDescription;
              v269 = 2112;
              v270 = v218;
              v271 = 2112;
              v272 = v220;
              v273 = 2112;
              v274 = v115;
              _os_log_impl(&dword_22AEAE000, v118, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] Thread connection status %@", buf, 0x34u);
            }

            objc_autoreleasePoolPop(v116);
            v279 = @"threadNetwork_ConnectionStatus";
            v122 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
            v278 = v115;
            v123 = [MEMORY[0x277CBEA60] arrayWithObjects:&v278 count:1];
            v124 = [(HMMTRAccessoryServerDiagnosticsEvent *)v122 initWithValues:v123];
            v280 = v124;
            v82 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v280 forKeys:&v279 count:1];
            eventCopy = v214;
LABEL_167:

            v13 = v220;
LABEL_168:
            if (v82)
            {
              v218 = v10;
              v234 = 0u;
              v235 = 0u;
              v232 = 0u;
              v233 = 0u;
              accessories = [(HAPAccessoryServer *)selfCopy8 accessories];
              v208 = [accessories countByEnumeratingWithState:&v232 objects:v253 count:16];
              if (v208)
              {
                v181 = *v233;
                v217 = eventCopy;
                v220 = v13;
                objb = accessories;
                v205 = *v233;
                do
                {
                  v182 = 0;
                  do
                  {
                    v183 = v7;
                    if (*v233 != v181)
                    {
                      objc_enumerationMutation(accessories);
                    }

                    v213 = v182;
                    v184 = *(*(&v232 + 1) + 8 * v182);
                    v228 = 0u;
                    v229 = 0u;
                    v230 = 0u;
                    v231 = 0u;
                    v223 = v184;
                    services = [v184 services];
                    v186 = [services countByEnumeratingWithState:&v228 objects:v252 count:16];
                    if (v186)
                    {
                      v187 = v186;
                      v188 = *v229;
                      while (2)
                      {
                        for (i = 0; i != v187; ++i)
                        {
                          if (*v229 != v188)
                          {
                            objc_enumerationMutation(services);
                          }

                          v190 = *(*(&v228 + 1) + 8 * i);
                          objc_opt_class();
                          if (objc_opt_isKindOfClass())
                          {
                            endpoint = [v190 endpoint];
                            endpoint2 = [v183 endpoint];
                            v193 = [endpoint isEqualToNumber:endpoint2];

                            if (v193)
                            {
                              v198 = objc_autoreleasePoolPush();
                              v199 = selfCopy8;
                              v200 = HMFGetOSLogHandle();
                              if (os_log_type_enabled(v200, OS_LOG_TYPE_INFO))
                              {
                                v201 = HMFGetLogIdentifier();
                                *buf = 138543874;
                                v266 = v201;
                                v267 = 2112;
                                v268 = v82;
                                v269 = 2112;
                                v270 = v223;
                                _os_log_impl(&dword_22AEAE000, v200, OS_LOG_TYPE_INFO, "%{public}@Calling delegate to handle diagnostics event: %@ for accessory: %@", buf, 0x20u);
                              }

                              objc_autoreleasePoolPop(v198);
                              diagnosticsEventDelegate = [(HMMTRAccessoryServer *)v199 diagnosticsEventDelegate];
                              [diagnosticsEventDelegate handleDiagnosticsEvents:v82 forAccessory:v223];

                              eventCopy = v217;
                              v7 = v183;
                              goto LABEL_196;
                            }
                          }
                        }

                        v187 = [services countByEnumeratingWithState:&v228 objects:v252 count:16];
                        if (v187)
                        {
                          continue;
                        }

                        break;
                      }
                    }

                    v182 = v213 + 1;
                    v7 = v183;
                    v13 = v220;
                    accessories = objb;
                    v181 = v205;
                  }

                  while (v213 + 1 != v208);
                  eventCopy = v217;
                  v208 = [objb countByEnumeratingWithState:&v232 objects:v253 count:16];
                }

                while (v208);
              }

              v194 = objc_autoreleasePoolPush();
              v195 = selfCopy8;
              v196 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v196, OS_LOG_TYPE_ERROR))
              {
                v197 = HMFGetLogIdentifier();
                *buf = 138543618;
                v266 = v197;
                v267 = 2112;
                v268 = v82;
                _os_log_impl(&dword_22AEAE000, v196, OS_LOG_TYPE_ERROR, "%{public}@Diagnostic event did not find any destination accessory: %@", buf, 0x16u);
              }

              objc_autoreleasePoolPop(v194);
            }

            goto LABEL_197;
          }

LABEL_199:
          _HMFPreconditionFailure();
        }

        v108 = objc_autoreleasePoolPush();
        selfCopy7 = self;
        v110 = HMFGetOSLogHandle();
        v111 = v221;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
        {
          HMFGetLogIdentifier();
          v113 = v112 = v10;
          *buf = 138543618;
          v266 = v113;
          v267 = 2112;
          v268 = v221;
          v114 = "%{public}@ThreadNetworkDiagnostics ConnectionStatus event data type is unexpected: %@";
LABEL_140:
          _os_log_impl(&dword_22AEAE000, v110, OS_LOG_TYPE_ERROR, v114, buf, 0x16u);

          v10 = v112;
          goto LABEL_141;
        }

        goto LABEL_141;
      }

LABEL_198:
      _HMFPreconditionFailure();
      goto LABEL_199;
    }

LABEL_137:
    v82 = 0;
    goto LABEL_197;
  }

  cluster2 = [v7 cluster];
  v42 = [cluster2 isEqual:&unk_283EE7D70];

  if (!v42)
  {
    goto LABEL_137;
  }

  event2 = [v7 event];
  v44 = [event2 isEqual:&unk_283EE7DA0];

  if (!v44)
  {
    event3 = [v7 event];
    v84 = [event3 isEqual:&unk_283EE7DB8];

    if (v84)
    {
      v218 = v10;
      v220 = v13;
      v85 = *MEMORY[0x277CD50D8];
      v86 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD50D8]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v87 = v86;
      }

      else
      {
        v87 = 0;
      }

      v88 = v87;

      if (!v88)
      {
        goto LABEL_198;
      }

      v89 = [v88 objectForKeyedSubscript:*MEMORY[0x277CD5188]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v90 = v89;
      }

      else
      {
        v90 = 0;
      }

      v91 = v90;

      v221 = v91;
      if ([v91 isEqual:*MEMORY[0x277CD5180]])
      {
        selfCopy8 = self;
        v211 = v7;
        v216 = eventCopy;
        v206 = v88;
        v92 = [v88 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v93 = v92;
        }

        else
        {
          v93 = 0;
        }

        v94 = v93;

        if (v94)
        {
          v242 = 0u;
          v243 = 0u;
          v240 = 0u;
          v241 = 0u;
          obj = v94;
          v95 = [obj countByEnumeratingWithState:&v240 objects:v261 count:16];
          if (!v95)
          {
            goto LABEL_103;
          }

          v96 = v95;
          v97 = *v241;
          v98 = *MEMORY[0x277CD50D0];
          while (1)
          {
            for (j = 0; j != v96; ++j)
            {
              if (*v241 != v97)
              {
                objc_enumerationMutation(obj);
              }

              v100 = *(*(&v240 + 1) + 8 * j);
              v101 = [v100 objectForKeyedSubscript:v98];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                v102 = v101;
              }

              else
              {
                v102 = 0;
              }

              v103 = v102;

              v104 = [v100 objectForKeyedSubscript:v85];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                v105 = v104;
              }

              else
              {
                v105 = 0;
              }

              v106 = v105;

              if ([v103 isEqual:&unk_283EE7D88])
              {
                v107 = selfCopy8;
                v115 = [(HMMTRAccessoryServer *)selfCopy8 numberOfReadValue:v106];

                if (v115)
                {
                  v157 = objc_autoreleasePoolPush();
                  v158 = selfCopy8;
                  v159 = HMFGetOSLogHandle();
                  v7 = v211;
                  if (os_log_type_enabled(v159, OS_LOG_TYPE_INFO))
                  {
                    v160 = HMFGetLogIdentifier();
                    primaryAccessory2 = [(HMMTRAccessoryServer *)v158 primaryAccessory];
                    shortDescription2 = [primaryAccessory2 shortDescription];
                    *buf = 138544386;
                    v266 = v160;
                    v267 = 2112;
                    v268 = shortDescription2;
                    v269 = 2112;
                    v270 = v10;
                    v271 = 2112;
                    v272 = v220;
                    v273 = 2112;
                    v274 = v115;
                    _os_log_impl(&dword_22AEAE000, v159, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Connection Status event with status %@", buf, 0x34u);
                  }

                  objc_autoreleasePoolPop(v157);
                  v259 = @"wifiNetwork_ConnectionStatus";
                  v163 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
                  v258 = v115;
                  v123 = [MEMORY[0x277CBEA60] arrayWithObjects:&v258 count:1];
                  v124 = [(HMMTRAccessoryServerDiagnosticsEvent *)v163 initWithValues:v123];
                  v260 = v124;
                  v164 = MEMORY[0x277CBEAC0];
                  v165 = &v260;
                  v166 = &v259;
                  goto LABEL_166;
                }

LABEL_149:
                v125 = objc_autoreleasePoolPush();
                v126 = v107;
                v127 = HMFGetOSLogHandle();
                v7 = v211;
                eventCopy = v216;
                if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
                {
                  v167 = HMFGetLogIdentifier();
                  *buf = 138543618;
                  v266 = v167;
                  v267 = 2112;
                  v268 = v216;
                  v168 = "%{public}@WiFiNetworkDiagnostics ConnectionStatus event data has unexpected structure: %@";
                  goto LABEL_193;
                }

                goto LABEL_194;
              }
            }

            v96 = [obj countByEnumeratingWithState:&v240 objects:v261 count:16];
            if (!v96)
            {
LABEL_103:

              v107 = selfCopy8;
              goto LABEL_149;
            }
          }
        }

        goto LABEL_199;
      }

      v151 = objc_autoreleasePoolPush();
      selfCopy6 = self;
      v153 = HMFGetOSLogHandle();
      v154 = v91;
      if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
      {
        v155 = HMFGetLogIdentifier();
        *buf = 138543618;
        v266 = v155;
        v267 = 2112;
        v268 = v221;
        v156 = "%{public}@WiFiNetworkDiagnostics ConnectionStatus event data type is unexpected: %@";
LABEL_153:
        _os_log_impl(&dword_22AEAE000, v153, OS_LOG_TYPE_ERROR, v156, buf, 0x16u);
      }
    }

    else
    {
      event4 = [v7 event];
      v130 = [event4 isEqual:&unk_283EE7D88];

      if (!v130)
      {
        goto LABEL_137;
      }

      v218 = v10;
      v220 = v13;
      v131 = *MEMORY[0x277CD50D8];
      v132 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD50D8]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v133 = v132;
      }

      else
      {
        v133 = 0;
      }

      v88 = v133;

      if (!v88)
      {
        goto LABEL_198;
      }

      v134 = [v88 objectForKeyedSubscript:*MEMORY[0x277CD5188]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v135 = v134;
      }

      else
      {
        v135 = 0;
      }

      v136 = v135;

      v221 = v136;
      if ([v136 isEqual:*MEMORY[0x277CD5180]])
      {
        selfCopy8 = self;
        v212 = v7;
        v216 = eventCopy;
        v206 = v88;
        v137 = [v88 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v138 = v137;
        }

        else
        {
          v138 = 0;
        }

        v139 = v138;

        if (v139)
        {
          v238 = 0u;
          v239 = 0u;
          v236 = 0u;
          v237 = 0u;
          obj = v139;
          v140 = [obj countByEnumeratingWithState:&v236 objects:v257 count:16];
          if (!v140)
          {
            goto LABEL_136;
          }

          v141 = v140;
          v142 = *v237;
          v143 = *MEMORY[0x277CD50D0];
          while (1)
          {
            for (k = 0; k != v141; ++k)
            {
              if (*v237 != v142)
              {
                objc_enumerationMutation(obj);
              }

              v145 = *(*(&v236 + 1) + 8 * k);
              v146 = [v145 hmf_numberForKey:v143];
              v147 = [v145 objectForKeyedSubscript:v131];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                v148 = v147;
              }

              else
              {
                v148 = 0;
              }

              v149 = v148;

              if ([v146 isEqual:&unk_283EE7D88])
              {
                v150 = selfCopy8;
                v115 = [(HMMTRAccessoryServer *)selfCopy8 numberOfReadValue:v149];

                if (v115)
                {
                  v173 = objc_autoreleasePoolPush();
                  v174 = selfCopy8;
                  v175 = HMFGetOSLogHandle();
                  v7 = v212;
                  if (os_log_type_enabled(v175, OS_LOG_TYPE_INFO))
                  {
                    v176 = HMFGetLogIdentifier();
                    primaryAccessory3 = [(HMMTRAccessoryServer *)v174 primaryAccessory];
                    shortDescription3 = [primaryAccessory3 shortDescription];
                    *buf = 138544386;
                    v266 = v176;
                    v267 = 2112;
                    v268 = shortDescription3;
                    v269 = 2112;
                    v270 = v10;
                    v271 = 2112;
                    v272 = v220;
                    v273 = 2112;
                    v274 = v115;
                    _os_log_impl(&dword_22AEAE000, v175, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Disconnection event with reason %@", buf, 0x34u);
                  }

                  objc_autoreleasePoolPop(v173);
                  v255 = @"wifiNetwork_ConnectionStatus";
                  v179 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
                  v254 = v115;
                  v123 = [MEMORY[0x277CBEA60] arrayWithObjects:&v254 count:1];
                  v124 = [(HMMTRAccessoryServerDiagnosticsEvent *)v179 initWithValues:v123];
                  v256 = v124;
                  v164 = MEMORY[0x277CBEAC0];
                  v165 = &v256;
                  v166 = &v255;
LABEL_166:
                  v82 = [v164 dictionaryWithObjects:v165 forKeys:v166 count:1];
                  eventCopy = v216;
                  v10 = v218;
                  goto LABEL_167;
                }

LABEL_191:
                v125 = objc_autoreleasePoolPush();
                v126 = v150;
                v127 = HMFGetOSLogHandle();
                v7 = v212;
                eventCopy = v216;
                if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
                {
                  v167 = HMFGetLogIdentifier();
                  *buf = 138543618;
                  v266 = v167;
                  v267 = 2112;
                  v268 = v216;
                  v168 = "%{public}@WiFiNetworkDiagnostics Disconnection event data has unexpected structure: %@";
LABEL_193:
                  _os_log_impl(&dword_22AEAE000, v127, OS_LOG_TYPE_ERROR, v168, buf, 0x16u);
                }

LABEL_194:

                objc_autoreleasePoolPop(v125);
LABEL_195:
                v82 = 0;
LABEL_196:
                v10 = v218;
                v13 = v220;
                goto LABEL_197;
              }
            }

            v141 = [obj countByEnumeratingWithState:&v236 objects:v257 count:16];
            if (!v141)
            {
LABEL_136:

              v150 = selfCopy8;
              goto LABEL_191;
            }
          }
        }

        goto LABEL_199;
      }

      v151 = objc_autoreleasePoolPush();
      selfCopy6 = self;
      v153 = HMFGetOSLogHandle();
      v154 = v136;
      if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
      {
        v155 = HMFGetLogIdentifier();
        *buf = 138543618;
        v266 = v155;
        v267 = 2112;
        v268 = v221;
        v156 = "%{public}@WiFiNetworkDiagnostics Disconnection event data type is unexpected: %@";
        goto LABEL_153;
      }
    }

    objc_autoreleasePoolPop(v151);
    goto LABEL_195;
  }

  v220 = v13;
  v45 = *MEMORY[0x277CD50D8];
  v46 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD50D8]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v47 = v46;
  }

  else
  {
    v47 = 0;
  }

  v21 = v47;

  if (!v21)
  {
    goto LABEL_198;
  }

  v48 = [v21 objectForKeyedSubscript:*MEMORY[0x277CD5188]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v49 = v48;
  }

  else
  {
    v49 = 0;
  }

  v50 = v49;

  v207 = v50;
  if (([v50 isEqual:*MEMORY[0x277CD5180]] & 1) == 0)
  {
    v108 = objc_autoreleasePoolPush();
    selfCopy7 = self;
    v110 = HMFGetOSLogHandle();
    v111 = v50;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
    {
      HMFGetLogIdentifier();
      v113 = v112 = v10;
      *buf = 138543618;
      v266 = v113;
      v267 = 2112;
      v268 = v207;
      v114 = "%{public}@WiFiNetworkDiagnostics AssociationFailure event data type is unexpected: %@";
      goto LABEL_140;
    }

LABEL_141:

    objc_autoreleasePoolPop(v108);
    v82 = 0;
    v13 = v220;
    goto LABEL_197;
  }

  selfCopy8 = self;
  v204 = v21;
  v51 = [v21 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v52 = v51;
  }

  else
  {
    v52 = 0;
  }

  v53 = v52;

  if (!v53)
  {
    goto LABEL_199;
  }

  v219 = v10;
  v246 = 0u;
  v247 = 0u;
  v244 = 0u;
  v245 = 0u;
  v54 = v53;
  v55 = [v54 countByEnumeratingWithState:&v244 objects:v277 count:16];
  obja = v54;
  if (!v55)
  {

    v57 = 0;
    v71 = 0;
    v13 = v220;
    goto LABEL_157;
  }

  v56 = v55;
  v210 = v7;
  v215 = eventCopy;
  v222 = 0;
  v57 = 0;
  v58 = *v245;
  v59 = *MEMORY[0x277CD50D0];
  do
  {
    for (m = 0; m != v56; ++m)
    {
      if (*v245 != v58)
      {
        objc_enumerationMutation(obja);
      }

      v61 = *(*(&v244 + 1) + 8 * m);
      v62 = [v61 objectForKeyedSubscript:v59];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v63 = v62;
      }

      else
      {
        v63 = 0;
      }

      v64 = v63;

      v65 = [v61 objectForKeyedSubscript:v45];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v66 = v65;
      }

      else
      {
        v66 = 0;
      }

      v67 = v66;

      if ([v64 isEqual:&unk_283EE7D88])
      {
        v68 = [(HMMTRAccessoryServer *)selfCopy8 numberOfReadValue:v67];
        v69 = v57;
        v57 = v68;
      }

      else
      {
        if (![v64 isEqual:&unk_283EE7DA0])
        {
          goto LABEL_69;
        }

        v70 = [(HMMTRAccessoryServer *)selfCopy8 numberOfReadValue:v67];
        v69 = v222;
        v222 = v70;
      }

LABEL_69:
    }

    v56 = [obja countByEnumeratingWithState:&v244 objects:v277 count:16];
  }

  while (v56);

  v7 = v210;
  if (v57)
  {
    v13 = v220;
    v71 = v222;
    if (v222)
    {
      v72 = objc_autoreleasePoolPush();
      v73 = selfCopy8;
      v74 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
      {
        v75 = HMFGetLogIdentifier();
        primaryAccessory4 = [(HMMTRAccessoryServer *)v73 primaryAccessory];
        shortDescription4 = [primaryAccessory4 shortDescription];
        *buf = 138544642;
        v266 = v75;
        v267 = 2112;
        v268 = shortDescription4;
        v269 = 2112;
        v270 = v219;
        v271 = 2112;
        v272 = v220;
        v273 = 2112;
        v274 = v57;
        v275 = 2112;
        v276 = v222;
        _os_log_impl(&dword_22AEAE000, v74, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Association Failure event with cause %@, status %@", buf, 0x3Eu);
      }

      objc_autoreleasePoolPop(v72);
      v263 = @"wifiNetwork_AssociationFailure";
      v78 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
      v262[0] = v57;
      v71 = v222;
      v262[1] = v222;
      v79 = [MEMORY[0x277CBEA60] arrayWithObjects:v262 count:2];
      v80 = [(HMMTRAccessoryServerDiagnosticsEvent *)v78 initWithValues:v79];
      v264 = v80;
      v81 = 1;
      v82 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v264 forKeys:&v263 count:1];

      eventCopy = v215;
      goto LABEL_160;
    }

    eventCopy = v215;
  }

  else
  {
    eventCopy = v215;
    v13 = v220;
    v71 = v222;
  }

LABEL_157:
  v169 = objc_autoreleasePoolPush();
  v170 = selfCopy8;
  v171 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
  {
    v172 = HMFGetLogIdentifier();
    *buf = 138543618;
    v266 = v172;
    v267 = 2112;
    v268 = eventCopy;
    _os_log_impl(&dword_22AEAE000, v171, OS_LOG_TYPE_ERROR, "%{public}@WiFiNetworkDiagnostics AssociationFailure event data has unexpected structure: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v169);
  v81 = 0;
  v82 = 0;
LABEL_160:

  v10 = v219;
  if (v81)
  {
    goto LABEL_168;
  }

LABEL_197:

  v203 = *MEMORY[0x277D85DE8];
}

- (id)generalDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported
{
  deviceCopy = device;
  v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_283EE7D28 clusterName:@"GeneralDiagnostics" amongEndpoints:endpoints topology:topology device:deviceCopy definitelyUnsupported:unsupported];
  if (v11)
  {
    v12 = objc_alloc(MEMORY[0x277CD5268]);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v14 = [v12 initWithDevice:deviceCopy endpointID:v11 queue:clientQueue];
  }

  else
  {
    v14 = 0;
  }

  return v14;
}

- (id)errorCountOfWiFiNetworkDiagnostics:(id)diagnostics
{
  v4 = [diagnostics readAttributeOverrunCountWithParams:0];
  v5 = [(HMMTRAccessoryServer *)self numberOfReadValue:v4];

  return v5;
}

- (id)packetCountOfWiFiNetworkDiagnostics:(id)diagnostics
{
  diagnosticsCopy = diagnostics;
  v5 = [diagnosticsCopy readAttributePacketUnicastTxCountWithParams:0];
  v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (!v6)
  {
    goto LABEL_6;
  }

  unsignedLongValue = [v6 unsignedLongValue];
  v8 = [diagnosticsCopy readAttributePacketMulticastTxCountWithParams:0];
  v9 = [(HMMTRAccessoryServer *)self numberOfReadValue:v8];

  if (!v9)
  {
    goto LABEL_6;
  }

  unsignedLongValue2 = [v9 unsignedLongValue];
  v11 = [diagnosticsCopy readAttributePacketUnicastRxCountWithParams:0];
  v12 = [(HMMTRAccessoryServer *)self numberOfReadValue:v11];

  if (!v12)
  {
    goto LABEL_6;
  }

  unsignedLongValue3 = [v12 unsignedLongValue];
  v14 = [diagnosticsCopy readAttributePacketMulticastRxCountWithParams:0];
  v15 = [(HMMTRAccessoryServer *)self numberOfReadValue:v14];

  if (v15)
  {
    unsignedLongValue4 = [v15 unsignedLongValue];
    v17 = [MEMORY[0x277CCABB0] numberWithUnsignedInt:(unsignedLongValue2 + unsignedLongValue + unsignedLongValue3 + unsignedLongValue4)];
  }

  else
  {
LABEL_6:
    v17 = 0;
  }

  return v17;
}

- (id)highestRSSIofThreadNetworkDiagnostics:(id)diagnostics
{
  v89 = *MEMORY[0x277D85DE8];
  diagnosticsCopy = diagnostics;
  v5 = [diagnosticsCopy readAttributeNeighborTableWithParams:0];
  v6 = v5;
  if (v5)
  {
    v71 = *MEMORY[0x277CD5188];
    v7 = [v5 objectForKeyedSubscript:?];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v8 = v7;
    }

    else
    {
      v8 = 0;
    }

    v9 = v8;

    if ([v9 isEqual:*MEMORY[0x277CD50B0]])
    {
      v67 = *MEMORY[0x277CD51A0];
      v10 = [v6 objectForKeyedSubscript:?];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v11 = v10;
      }

      else
      {
        v11 = 0;
      }

      v12 = v11;

      if (!v12)
      {
        goto LABEL_75;
      }

      v61 = v6;
      v62 = diagnosticsCopy;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v13 = v12;
      v70 = [v13 countByEnumeratingWithState:&v79 objects:v84 count:16];
      if (!v70)
      {
        v65 = 0;
        goto LABEL_66;
      }

      v65 = 0;
      v69 = *v80;
      v73 = *MEMORY[0x277CD50D8];
      v68 = *MEMORY[0x277CD5180];
      v14 = *MEMORY[0x277CD50D0];
      selfCopy = self;
      obj = v13;
LABEL_12:
      v15 = 0;
      while (1)
      {
        v16 = v9;
        if (*v80 != v69)
        {
          objc_enumerationMutation(obj);
        }

        v17 = [*(*(&v79 + 1) + 8 * v15) objectForKeyedSubscript:{v73, v61, v62}];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v18 = v17;
        }

        else
        {
          v18 = 0;
        }

        v19 = v18;

        if (!v19)
        {
LABEL_73:
          _HMFPreconditionFailure();
LABEL_74:
          _HMFPreconditionFailure();
LABEL_75:
          _HMFPreconditionFailure();
        }

        v20 = [v19 objectForKeyedSubscript:v71];
        objc_opt_class();
        v21 = (objc_opt_isKindOfClass() & 1) != 0 ? v20 : 0;
        v9 = v21;

        if (([v9 isEqual:v68] & 1) == 0)
        {
          break;
        }

        v22 = [v19 objectForKeyedSubscript:v67];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v23 = v22;
        }

        else
        {
          v23 = 0;
        }

        v24 = v23;

        if (!v24)
        {
          goto LABEL_74;
        }

        v74 = v15;
        v77 = 0u;
        v78 = 0u;
        v75 = 0u;
        v76 = 0u;
        v25 = v24;
        v26 = [v25 countByEnumeratingWithState:&v75 objects:v83 count:16];
        if (v26)
        {
          v27 = v26;
          v72 = v9;
          v28 = *v76;
LABEL_29:
          v29 = 0;
          while (1)
          {
            if (*v76 != v28)
            {
              objc_enumerationMutation(v25);
            }

            v30 = *(*(&v75 + 1) + 8 * v29);
            v31 = [v30 objectForKeyedSubscript:v14];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              v32 = v31;
            }

            else
            {
              v32 = 0;
            }

            v33 = v32;

            if (!v33)
            {
              _HMFPreconditionFailure();
              goto LABEL_73;
            }

            if ([v33 isEqual:&unk_283EE7DD0])
            {
              break;
            }

            if (v27 == ++v29)
            {
              v27 = [v25 countByEnumeratingWithState:&v75 objects:v83 count:16];
              if (!v27)
              {
                v9 = v72;
                self = selfCopy;
                goto LABEL_53;
              }

              goto LABEL_29;
            }
          }

          v34 = [v30 objectForKeyedSubscript:v73];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v35 = v34;
          }

          else
          {
            v35 = 0;
          }

          v36 = v35;

          if (!v36)
          {
            goto LABEL_73;
          }

          self = selfCopy;
          v37 = [(HMMTRAccessoryServer *)selfCopy numberOfReadValue:v36];
          v38 = v37;
          if (v37)
          {
            v9 = v72;
            if (!v65 || (v39 = [v37 integerValue], v39 > objc_msgSend(v65, "integerValue")))
            {
              v40 = v38;

              v65 = v40;
            }
          }

          else
          {
            context = objc_autoreleasePoolPush();
            v41 = selfCopy;
            v42 = HMFGetOSLogHandle();
            v9 = v72;
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              v43 = HMFGetLogIdentifier();
              *buf = 138543362;
              v86 = v43;
              v44 = v43;
              _os_log_impl(&dword_22AEAE000, v42, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable AverageRssi entry is not a number", buf, 0xCu);

              self = selfCopy;
            }

            objc_autoreleasePoolPop(context);
          }

          v17 = v34;
        }

        else
        {
          v17 = v19;
        }

LABEL_53:

        v15 = v74 + 1;
        if (v74 + 1 == v70)
        {
          v13 = obj;
          v70 = [obj countByEnumeratingWithState:&v79 objects:v84 count:16];
          if (!v70)
          {
LABEL_66:

            v58 = v65;
            v49 = v58;
            v6 = v61;
            diagnosticsCopy = v62;
            goto LABEL_67;
          }

          goto LABEL_12;
        }
      }

      v54 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v56 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        v57 = HMFGetLogIdentifier();
        *buf = 138543618;
        v86 = v57;
        v87 = 2112;
        v88 = v9;
        _os_log_impl(&dword_22AEAE000, v56, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable entry is not a structure but a %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v54);
      v13 = obj;

      v49 = 0;
      v6 = v61;
      diagnosticsCopy = v62;
      v58 = v65;
LABEL_67:
    }

    else
    {
      v50 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v52 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        v53 = HMFGetLogIdentifier();
        *buf = 138543618;
        v86 = v53;
        v87 = 2112;
        v88 = v9;
        _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable attribute is not an array but a %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v50);
      v49 = 0;
    }
  }

  else
  {
    v45 = objc_autoreleasePoolPush();
    selfCopy4 = self;
    v47 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      v48 = HMFGetLogIdentifier();
      *buf = 138543362;
      v86 = v48;
      _os_log_impl(&dword_22AEAE000, v47, OS_LOG_TYPE_ERROR, "%{public}@NeighborTable missing from ThreadNetworkDiagnostics", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v45);
    v49 = 0;
  }

  v59 = *MEMORY[0x277D85DE8];

  return v49;
}

- (id)errorCountOfThreadNetworkDiagnostics:(id)diagnostics
{
  diagnosticsCopy = diagnostics;
  v5 = [diagnosticsCopy readAttributeTxDirectMaxRetryExpiryCountWithParams:0];
  v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (!v6)
  {
    goto LABEL_13;
  }

  unsignedLongValue = [v6 unsignedLongValue];
  v8 = [diagnosticsCopy readAttributeTxIndirectMaxRetryExpiryCountWithParams:0];
  v9 = [(HMMTRAccessoryServer *)self numberOfReadValue:v8];

  if (!v9)
  {
    goto LABEL_13;
  }

  unsignedLongValue2 = [v9 unsignedLongValue];
  v11 = [diagnosticsCopy readAttributeTxErrCcaCountWithParams:0];
  v12 = [(HMMTRAccessoryServer *)self numberOfReadValue:v11];

  if (!v12)
  {
    goto LABEL_13;
  }

  unsignedLongValue3 = [v12 unsignedLongValue];
  v14 = [diagnosticsCopy readAttributeTxErrAbortCountWithParams:0];
  v15 = [(HMMTRAccessoryServer *)self numberOfReadValue:v14];

  if (!v15)
  {
    goto LABEL_13;
  }

  unsignedLongValue4 = [v15 unsignedLongValue];
  v17 = [diagnosticsCopy readAttributeTxErrBusyChannelCountWithParams:0];
  v18 = [(HMMTRAccessoryServer *)self numberOfReadValue:v17];

  if (!v18)
  {
    goto LABEL_13;
  }

  unsignedLongValue5 = [v18 unsignedLongValue];
  v20 = [diagnosticsCopy readAttributeRxErrNoFrameCountWithParams:0];
  v21 = [(HMMTRAccessoryServer *)self numberOfReadValue:v20];

  if (!v21)
  {
    goto LABEL_13;
  }

  unsignedLongValue6 = [v21 unsignedLongValue];
  v22 = [diagnosticsCopy readAttributeRxErrUnknownNeighborCountWithParams:0];
  v23 = [(HMMTRAccessoryServer *)self numberOfReadValue:v22];

  if (!v23)
  {
    goto LABEL_13;
  }

  unsignedLongValue7 = [v23 unsignedLongValue];
  v24 = [diagnosticsCopy readAttributeRxErrInvalidSrcAddrCountWithParams:0];
  v25 = [(HMMTRAccessoryServer *)self numberOfReadValue:v24];

  if (!v25)
  {
    goto LABEL_13;
  }

  unsignedLongValue8 = [v25 unsignedLongValue];
  v26 = [diagnosticsCopy readAttributeRxErrSecCountWithParams:0];
  v27 = [(HMMTRAccessoryServer *)self numberOfReadValue:v26];

  if (!v27)
  {
    goto LABEL_13;
  }

  unsignedLongValue9 = [v27 unsignedLongValue];
  v28 = [diagnosticsCopy readAttributeRxErrFcsCountWithParams:0];
  v29 = [(HMMTRAccessoryServer *)self numberOfReadValue:v28];

  if (!v29)
  {
    goto LABEL_13;
  }

  unsignedLongValue10 = [v29 unsignedLongValue];
  v31 = [diagnosticsCopy readAttributeRxErrOtherCountWithParams:0];
  v32 = [(HMMTRAccessoryServer *)self numberOfReadValue:v31];

  if (v32)
  {
    unsignedLongValue11 = [v32 unsignedLongValue];
    v34 = [MEMORY[0x277CCABB0] numberWithUnsignedInt:(unsignedLongValue2 + unsignedLongValue + unsignedLongValue3 + unsignedLongValue4 + unsignedLongValue5 + unsignedLongValue6 + unsignedLongValue7 + unsignedLongValue8 + unsignedLongValue9 + unsignedLongValue10 + unsignedLongValue11)];
  }

  else
  {
LABEL_13:
    v34 = 0;
  }

  return v34;
}

- (id)packetCountOfThreadNetworkDiagnostics:(id)diagnostics
{
  diagnosticsCopy = diagnostics;
  v5 = [diagnosticsCopy readAttributeTxTotalCountWithParams:0];
  v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (v6 && (v7 = [v6 unsignedLongValue], objc_msgSend(diagnosticsCopy, "readAttributeRxTotalCountWithParams:", 0), v8 = objc_claimAutoreleasedReturnValue(), -[HMMTRAccessoryServer numberOfReadValue:](self, "numberOfReadValue:", v8), v9 = objc_claimAutoreleasedReturnValue(), v6, v8, v9))
  {
    unsignedLongValue = [v9 unsignedLongValue];
    v11 = [MEMORY[0x277CCABB0] numberWithUnsignedInt:(unsignedLongValue + v7)];
  }

  else
  {
    v11 = 0;
  }

  return v11;
}

- (id)connectedNetworkIDFromReadValue:(id)value
{
  v76 = *MEMORY[0x277D85DE8];
  valueCopy = value;
  v4 = valueCopy;
  if (valueCopy)
  {
    v5 = *MEMORY[0x277CD5188];
    v6 = [valueCopy objectForKeyedSubscript:*MEMORY[0x277CD5188]];
    v7 = 0x277CCA000uLL;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v8 = v6;
    }

    else
    {
      v8 = 0;
    }

    v9 = v8;

    v10 = 0;
    v11 = 0;
    if ([v9 isEqual:*MEMORY[0x277CD50B0]])
    {
      v57 = *MEMORY[0x277CD51A0];
      v12 = [v4 objectForKeyedSubscript:?];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v13 = v12;
      }

      else
      {
        v13 = 0;
      }

      v14 = v13;

      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      obj = v14;
      v11 = [obj countByEnumeratingWithState:&v70 objects:v75 count:16];
      if (v11)
      {
        v53 = v9;
        v54 = v4;
        LOBYTE(v15) = 0;
        v64 = 0;
        v16 = *v71;
        v17 = *MEMORY[0x277CD50D8];
        v62 = *MEMORY[0x277CD5180];
        v18 = *MEMORY[0x277CD50D0];
        v55 = *v71;
        v56 = v5;
        while (2)
        {
          v19 = 0;
          v58 = v11;
          do
          {
            if (*v71 != v16)
            {
              objc_enumerationMutation(obj);
            }

            if (v15)
            {
              v11 = v64;
              v10 = v64;
              goto LABEL_56;
            }

            v20 = [*(*(&v70 + 1) + 8 * v19) objectForKeyedSubscript:v17];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              v21 = v20;
            }

            else
            {
              v21 = 0;
            }

            v22 = v21;

            v23 = [v22 objectForKeyedSubscript:v5];
            v24 = v7;
            v25 = *(v7 + 3240);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              v26 = v23;
            }

            else
            {
              v26 = 0;
            }

            v27 = v5;
            v28 = v26;

            v29 = v28;
            v63 = v22;
            if ([v28 isEqual:v62])
            {
              v60 = v28;
              v61 = v19;
              v30 = [v22 objectForKeyedSubscript:v57];
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                v31 = v30;
              }

              else
              {
                v31 = 0;
              }

              v32 = v31;

              v68 = 0u;
              v69 = 0u;
              v66 = 0u;
              v67 = 0u;
              v33 = v32;
              v34 = [v33 countByEnumeratingWithState:&v66 objects:v74 count:16];
              if (v34)
              {
                v35 = v34;
                v15 = 0;
                v36 = *v67;
                do
                {
                  for (i = 0; i != v35; ++i)
                  {
                    if (*v67 != v36)
                    {
                      objc_enumerationMutation(v33);
                    }

                    v38 = *(*(&v66 + 1) + 8 * i);
                    v39 = [v38 objectForKeyedSubscript:v18];
                    objc_opt_class();
                    if (objc_opt_isKindOfClass())
                    {
                      v40 = v39;
                    }

                    else
                    {
                      v40 = 0;
                    }

                    v41 = v40;

                    if ([v41 isEqual:&unk_283EE7DA0])
                    {
                      v42 = [v38 objectForKeyedSubscript:v17];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        v43 = v42;
                      }

                      else
                      {
                        v43 = 0;
                      }

                      v44 = v43;

                      v45 = [(HMMTRAccessoryServer *)self numberOfReadValue:v44];

                      v15 |= [v45 BOOLValue];
                    }

                    else if ([v41 isEqual:&unk_283EE7D88])
                    {
                      v46 = [v38 objectForKeyedSubscript:v17];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        v47 = v46;
                      }

                      else
                      {
                        v47 = 0;
                      }

                      v48 = v47;

                      v49 = [(HMMTRAccessoryServer *)self stringOfReadValue:v48];

                      v64 = v49;
                    }
                  }

                  v35 = [v33 countByEnumeratingWithState:&v66 objects:v74 count:16];
                }

                while (v35);
              }

              else
              {
                LOBYTE(v15) = 0;
              }

              v16 = v55;
              v5 = v56;
              v7 = 0x277CCA000;
              v11 = v58;
              v29 = v60;
              v19 = v61;
            }

            else
            {
              LOBYTE(v15) = 0;
              v5 = v27;
              v7 = v24;
            }

            v19 = v19 + 1;
          }

          while (v19 != v11);
          v11 = [obj countByEnumeratingWithState:&v70 objects:v75 count:16];
          if (v11)
          {
            continue;
          }

          break;
        }

        v11 = v64;
        if (v15)
        {
          v10 = v64;
        }

        else
        {
          v10 = 0;
        }

LABEL_56:
        v9 = v53;
        v4 = v54;
      }

      else
      {
        v10 = 0;
      }
    }

    v50 = v10;
  }

  else
  {
    v50 = 0;
  }

  v51 = *MEMORY[0x277D85DE8];

  return v50;
}

- (id)stringOfReadValue:(id)value
{
  valueCopy = value;
  v4 = valueCopy;
  if (!valueCopy)
  {
    v16 = 0;
    goto LABEL_24;
  }

  v5 = [valueCopy objectForKeyedSubscript:*MEMORY[0x277CD5188]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v6 = v5;
  }

  else
  {
    v6 = 0;
  }

  v7 = v6;

  if ([v7 isEqual:*MEMORY[0x277CD5168]])
  {
    v8 = [v4 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v9 = v8;
    }

    else
    {
      v9 = 0;
    }

    v10 = v9;

    v11 = [objc_alloc(MEMORY[0x277CCACA8]) initWithBytes:objc_msgSend(v10 length:"bytes") encoding:{objc_msgSend(v10, "length"), 4}];
    if (!v11)
    {
      bytes = [v10 bytes];
      if ([v10 length])
      {
        v13 = 0;
        v14 = &stru_283ED2308;
        do
        {
          v15 = v14;
          v14 = [(__CFString *)v14 stringByAppendingFormat:@"%X", *(bytes + v13)];

          ++v13;
        }

        while ([v10 length] > v13);
      }

      else
      {
        v14 = &stru_283ED2308;
      }

      goto LABEL_21;
    }
  }

  else
  {
    if (![v7 isEqual:*MEMORY[0x277CD5190]])
    {
      v14 = 0;
      goto LABEL_23;
    }

    v10 = [v4 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v17 = v10;
    }

    else
    {
      v17 = 0;
    }

    v11 = v17;
  }

  v14 = v11;
LABEL_21:

LABEL_23:
  v16 = v14;

LABEL_24:

  return v16;
}

- (id)dataOfReadValue:(id)value
{
  valueCopy = value;
  v4 = valueCopy;
  if (valueCopy)
  {
    v5 = [valueCopy objectForKeyedSubscript:*MEMORY[0x277CD5188]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v6 = v5;
    }

    else
    {
      v6 = 0;
    }

    v7 = v6;

    v8 = [v7 isEqual:*MEMORY[0x277CD5168]];
    v9 = 0;
    if (v8)
    {
      v10 = [v4 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v11 = v10;
      }

      else
      {
        v11 = 0;
      }

      v9 = v11;
    }

    v12 = v9;
  }

  else
  {
    v12 = 0;
  }

  return v12;
}

- (id)numberOfReadValue:(id)value
{
  valueCopy = value;
  v4 = valueCopy;
  if (valueCopy)
  {
    v5 = [valueCopy objectForKeyedSubscript:*MEMORY[0x277CD5188]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v6 = v5;
    }

    else
    {
      v6 = 0;
    }

    v7 = v6;

    if (([v7 isEqual:*MEMORY[0x277CD5178]] & 1) != 0 || (objc_msgSend(v7, "isEqual:", *MEMORY[0x277CD5198]) & 1) != 0 || (objc_msgSend(v7, "isEqual:", *MEMORY[0x277CD50C0]) & 1) != 0 || (objc_msgSend(v7, "isEqual:", *MEMORY[0x277CD5150]) & 1) != 0 || objc_msgSend(v7, "isEqual:", *MEMORY[0x277CD5118]))
    {
      v8 = [v4 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v9 = v8;
      }

      else
      {
        v9 = 0;
      }

      v10 = v9;
    }

    else
    {
      v10 = 0;
    }
  }

  else
  {
    v10 = 0;
  }

  return v10;
}

- (id)networkCommissioningClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported
{
  deviceCopy = device;
  v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_283EE7D10 clusterName:@"NetworkCommissioningCluster" amongEndpoints:endpoints topology:topology device:deviceCopy definitelyUnsupported:unsupported];
  if (v11)
  {
    v12 = objc_alloc(MEMORY[0x277CD5278]);
    unsignedShortValue = [v11 unsignedShortValue];
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v15 = [v12 initWithDevice:deviceCopy endpoint:unsignedShortValue queue:clientQueue];
  }

  else
  {
    v15 = 0;
  }

  return v15;
}

- (id)wifiNetworkDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported
{
  deviceCopy = device;
  v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_283EE7D70 clusterName:@"WiFiNetworkDiagnostics" amongEndpoints:endpoints topology:topology device:deviceCopy definitelyUnsupported:unsupported];
  if (v11)
  {
    v12 = objc_alloc(MEMORY[0x277CD52C0]);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v14 = [v12 initWithDevice:deviceCopy endpointID:v11 queue:clientQueue];
  }

  else
  {
    v14 = 0;
  }

  return v14;
}

- (id)threadNetworkDiagnosticsClusterFromEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported
{
  deviceCopy = device;
  v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_283EE7D58 clusterName:@"ThreadNetworkDiagnostics" amongEndpoints:endpoints topology:topology device:deviceCopy definitelyUnsupported:unsupported];
  if (v11)
  {
    v12 = objc_alloc(MEMORY[0x277CD52B8]);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v14 = [v12 initWithDevice:deviceCopy endpointID:v11 queue:clientQueue];
  }

  else
  {
    v14 = 0;
  }

  return v14;
}

- (id)endpointForDiagnosticCluster:(id)cluster clusterName:(id)name amongEndpoints:(id)endpoints topology:(id)topology device:(id)device definitelyUnsupported:(BOOL *)unsupported
{
  v104 = *MEMORY[0x277D85DE8];
  clusterCopy = cluster;
  nameCopy = name;
  endpointsCopy = endpoints;
  topologyCopy = topology;
  deviceCopy = device;
  v92 = 0u;
  v93 = 0u;
  v94 = 0u;
  v95 = 0u;
  v18 = endpointsCopy;
  v19 = [v18 countByEnumeratingWithState:&v92 objects:v103 count:16];
  if (!v19)
  {

LABEL_40:
    v60 = objc_autoreleasePoolPush();
    selfCopy = self;
    v62 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
    {
      v63 = HMFGetLogIdentifier();
      *buf = 138543874;
      v98 = v63;
      v99 = 2112;
      v100 = nameCopy;
      v101 = 2112;
      v102 = v18;
      _os_log_impl(&dword_22AEAE000, v62, OS_LOG_TYPE_DEBUG, "%{public}@No %@ cluster in any endpoints %@.", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v60);
    v54 = 0;
    *unsupported = 1;
    goto LABEL_43;
  }

  v20 = v19;
  selfCopy2 = self;
  v85 = deviceCopy;
  v86 = nameCopy;
  v21 = 0;
  v22 = *v93;
  while (2)
  {
    for (i = 0; i != v20; ++i)
    {
      if (*v93 != v22)
      {
        objc_enumerationMutation(v18);
      }

      v24 = *(*(&v92 + 1) + 8 * i);
      v25 = [topologyCopy getClustersInUseAtEndpoint:v24];
      if ([v25 containsObject:clusterCopy])
      {
        v56 = objc_autoreleasePoolPush();
        v57 = selfCopy2;
        v58 = HMFGetOSLogHandle();
        nameCopy = v86;
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          v59 = HMFGetLogIdentifier();
          *buf = 138543874;
          v98 = v59;
          v99 = 2112;
          v100 = v86;
          v101 = 2112;
          v102 = v24;
          _os_log_impl(&dword_22AEAE000, v58, OS_LOG_TYPE_DEBUG, "%{public}@%@ cluster found in endpoint %@", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v56);
        v54 = v24;

        deviceCopy = v85;
        goto LABEL_43;
      }

      v21 |= [v24 isEqual:&unk_283EE7D88];
    }

    v20 = [v18 countByEnumeratingWithState:&v92 objects:v103 count:16];
    if (v20)
    {
      continue;
    }

    break;
  }

  deviceCopy = v85;
  nameCopy = v86;
  self = selfCopy2;
  if ((v21 & 1) == 0)
  {
    goto LABEL_40;
  }

  v26 = objc_autoreleasePoolPush();
  v27 = selfCopy2;
  v28 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
  {
    v29 = HMFGetLogIdentifier();
    *buf = 138543618;
    v98 = v29;
    v99 = 2112;
    v100 = v86;
    _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_DEBUG, "%{public}@Checking endpoint 0 for %@ cluster", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v26);
  v30 = objc_alloc(MEMORY[0x277CD5258]);
  clientQueue = [(HAPAccessoryServer *)v27 clientQueue];
  v32 = [v30 initWithDevice:v85 endpointID:&unk_283EE7D88 queue:clientQueue];

  v33 = [v32 readAttributeServerListWithParams:0];
  v34 = v33;
  v81 = v32;
  if (v33)
  {
    v84 = v27;
    v35 = [v33 objectForKeyedSubscript:*MEMORY[0x277CD5188]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v36 = v35;
    }

    else
    {
      v36 = 0;
    }

    v37 = v36;

    v80 = v37;
    if ([v37 isEqual:*MEMORY[0x277CD50B0]])
    {
      v79 = v34;
      v38 = [v34 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v39 = v38;
      }

      else
      {
        v39 = 0;
      }

      v40 = v39;

      if (!v40)
      {
LABEL_59:
        _HMFPreconditionFailure();
      }

      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      obj = v40;
      v41 = [obj countByEnumeratingWithState:&v88 objects:v96 count:16];
      if (!v41)
      {
        goto LABEL_33;
      }

      v42 = v41;
      v43 = *v89;
      v44 = *MEMORY[0x277CD50D8];
LABEL_23:
      v45 = 0;
      while (1)
      {
        if (*v89 != v43)
        {
          objc_enumerationMutation(obj);
        }

        v46 = [*(*(&v88 + 1) + 8 * v45) objectForKeyedSubscript:v44];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v47 = v46;
        }

        else
        {
          v47 = 0;
        }

        v48 = v47;

        if (!v48)
        {
          _HMFPreconditionFailure();
          goto LABEL_59;
        }

        v49 = [(HMMTRAccessoryServer *)v84 numberOfReadValue:v48];
        if ([v49 isEqual:clusterCopy])
        {
          break;
        }

        if (v42 == ++v45)
        {
          v42 = [obj countByEnumeratingWithState:&v88 objects:v96 count:16];
          if (!v42)
          {
LABEL_33:

            v50 = objc_autoreleasePoolPush();
            v51 = v84;
            v52 = HMFGetOSLogHandle();
            nameCopy = v86;
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
              v53 = HMFGetLogIdentifier();
              *buf = 138543618;
              v98 = v53;
              v99 = 2112;
              v100 = v86;
              _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_DEBUG, "%{public}@Endpoint 0 does not have cluster %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v50);
            v54 = 0;
            *unsupported = 1;
            deviceCopy = v85;
            v55 = obj;
            goto LABEL_55;
          }

          goto LABEL_23;
        }
      }

      v75 = objc_autoreleasePoolPush();
      v76 = v84;
      v77 = HMFGetOSLogHandle();
      nameCopy = v86;
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
      {
        v78 = HMFGetLogIdentifier();
        *buf = 138543618;
        v98 = v78;
        v99 = 2112;
        v100 = v86;
        _os_log_impl(&dword_22AEAE000, v77, OS_LOG_TYPE_DEBUG, "%{public}@Endpoint 0 has cluster %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v75);
      v55 = obj;

      v54 = &unk_283EE7D88;
      deviceCopy = v85;
LABEL_55:

      v66 = v79;
    }

    else
    {
      v66 = v34;
      v71 = objc_autoreleasePoolPush();
      v72 = v84;
      v73 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        v74 = HMFGetLogIdentifier();
        *buf = 138543618;
        v98 = v74;
        v99 = 2112;
        v100 = v80;
        _os_log_impl(&dword_22AEAE000, v73, OS_LOG_TYPE_ERROR, "%{public}@Unexpected ServerList value type: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v71);
      v54 = 0;
      *unsupported = 0;
    }
  }

  else
  {
    v66 = 0;
    v67 = objc_autoreleasePoolPush();
    v68 = v27;
    v69 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
    {
      v70 = HMFGetLogIdentifier();
      *buf = 138543362;
      v98 = v70;
      _os_log_impl(&dword_22AEAE000, v69, OS_LOG_TYPE_ERROR, "%{public}@ServerList couldn't be read from endpoint 0", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v67);
    v54 = 0;
    *unsupported = 0;
  }

LABEL_43:
  v64 = *MEMORY[0x277D85DE8];

  return v54;
}

- (id)endpointsForHAPAccessory:(id)accessory topology:(id)topology
{
  v49 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  topologyCopy = topology;
  array = [MEMORY[0x277CBEB18] array];
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v35 = accessoryCopy;
  services = [accessoryCopy services];
  v8 = [services countByEnumeratingWithState:&v36 objects:v48 count:16];
  if (v8)
  {
    v9 = v8;
    v10 = *v37;
    while (2)
    {
      for (i = 0; i != v9; ++i)
      {
        if (*v37 != v10)
        {
          objc_enumerationMutation(services);
        }

        v12 = *(*(&v36 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v13 = v12;
        }

        else
        {
          v13 = 0;
        }

        v14 = v13;

        type = [v14 type];
        v16 = [type isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v16)
        {
          endpoint = [v14 endpoint];
          [array addObject:endpoint];

          endpoint2 = [v14 endpoint];
          v22 = topologyCopy;
          v25 = [topologyCopy getPartsListAtEndpoint:endpoint2];

          [array addObjectsFromArray:v25];
          v26 = objc_autoreleasePoolPush();
          selfCopy = self;
          v28 = HMFGetOSLogHandle();
          v20 = v35;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            v29 = HMFGetLogIdentifier();
            *buf = 138544130;
            v41 = v29;
            v42 = 2112;
            v43 = v35;
            v44 = 2112;
            v45 = v14;
            v46 = 2112;
            v47 = array;
            _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_DEBUG, "%{public}@HAPAccessory %@ service: %@, endpoints: %@", buf, 0x2Au);
          }

          objc_autoreleasePoolPop(v26);
          v30 = array;

          goto LABEL_18;
        }
      }

      v9 = [services countByEnumeratingWithState:&v36 objects:v48 count:16];
      if (v9)
      {
        continue;
      }

      break;
    }
  }

  v17 = objc_autoreleasePoolPush();
  selfCopy2 = self;
  v19 = HMFGetOSLogHandle();
  v20 = v35;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v21 = HMFGetLogIdentifier();
    *buf = 138543618;
    v41 = v21;
    v42 = 2112;
    v43 = v35;
    _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No endpoints available for diagnostic clusters for HAPAccessory: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v17);
  v22 = topologyCopy;
LABEL_18:

  v31 = *MEMORY[0x277D85DE8];

  return array;
}

- (void)resetWiFiNetworkDiagnosticsCountForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke;
  v7[3] = &unk_2786EF328;
  v7[4] = self;
  v8 = accessoryCopy;
  v6 = accessoryCopy;
  dispatch_async(clientQueue, v7);
}

void __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Resetting WiFiNetworkDiagnostics counters", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = [*(a1 + 32) matterDevice];

  if (v6)
  {
    v7 = [HMMTRDeviceTopology alloc];
    v8 = [*(a1 + 32) nodeID];
    v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:*(a1 + 32)];

    if (v9)
    {
      v10 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v9];
      buf[0] = 0;
      v11 = *(a1 + 32);
      v12 = [v11 matterDevice];
      v13 = [v11 wifiNetworkDiagnosticsClusterFromEndpoints:v10 topology:v9 device:v12 definitelyUnsupported:buf];

      v15[0] = MEMORY[0x277D85DD0];
      v15[1] = 3221225472;
      v15[2] = __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke_217;
      v15[3] = &unk_2786EF290;
      v15[4] = *(a1 + 32);
      [v13 resetCountsWithExpectedValues:MEMORY[0x277CBEBF8] expectedValueInterval:&unk_283EE7D88 completion:v15];
    }
  }

  v14 = *MEMORY[0x277D85DE8];
}

void __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke_217(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Reset WiFiNetworkDiagnostics counters with error: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *MEMORY[0x277D85DE8];
}

- (void)resetThreadNetworkDiagnosticsCountForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke;
  v7[3] = &unk_2786EF328;
  v7[4] = self;
  v8 = accessoryCopy;
  v6 = accessoryCopy;
  dispatch_async(clientQueue, v7);
}

void __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Resetting ThreadNetworkDiagnostics counters", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = [*(a1 + 32) matterDevice];

  if (v6)
  {
    v7 = [HMMTRDeviceTopology alloc];
    v8 = [*(a1 + 32) nodeID];
    v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:*(a1 + 32)];

    if (v9)
    {
      v10 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v9];
      buf[0] = 0;
      v11 = *(a1 + 32);
      v12 = [v11 matterDevice];
      v13 = [v11 threadNetworkDiagnosticsClusterFromEndpoints:v10 topology:v9 device:v12 definitelyUnsupported:buf];

      v15[0] = MEMORY[0x277D85DD0];
      v15[1] = 3221225472;
      v15[2] = __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke_215;
      v15[3] = &unk_2786EF290;
      v15[4] = *(a1 + 32);
      [v13 resetCountsWithExpectedValues:MEMORY[0x277CBEBF8] expectedValueInterval:&unk_283EE7D88 completion:v15];
    }
  }

  v14 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke_215(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Reset ThreadNetworkDiagnostics counters with error: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *MEMORY[0x277D85DE8];
}

- (id)getThreadNetworkLinkQualityForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__1810;
  v16 = __Block_byref_object_dispose__1811;
  v17 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __77__HMMTRAccessoryServer_Diagnostics__getThreadNetworkLinkQualityForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __77__HMMTRAccessoryServer_Diagnostics__getThreadNetworkLinkQualityForAccessory___block_invoke(uint64_t a1)
{
  v31 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];

  if (v2)
  {
    v3 = [HMMTRDeviceTopology alloc];
    v4 = [*(a1 + 32) nodeID];
    v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(a1 + 32)];

    if (v5)
    {
      v6 = [MEMORY[0x277CBEB38] dictionary];
      v7 = *(*(a1 + 48) + 8);
      v8 = *(v7 + 40);
      *(v7 + 40) = v6;

      v9 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v5];
      v26 = 0;
      v10 = *(a1 + 32);
      v11 = [v10 matterDevice];
      v12 = [v10 threadNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v26];

      if (v12)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC38] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
        v13 = [*(a1 + 32) highestRSSIofThreadNetworkDiagnostics:v12];
        if (v13)
        {
          v14 = objc_autoreleasePoolPush();
          v15 = *(a1 + 32);
          v16 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v17 = HMFGetLogIdentifier();
            *buf = 138543618;
            v28 = v17;
            v29 = 2112;
            v30 = v13;
            _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v14);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v13 forKeyedSubscript:@"threadNetwork_RSSI"];
        }

        v18 = *(a1 + 32);
        v19 = [v12 readAttributeNetworkNameWithParams:0];
        v20 = [v18 stringOfReadValue:v19];

        if (v20)
        {
          v21 = objc_autoreleasePoolPush();
          v22 = *(a1 + 32);
          v23 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            v24 = HMFGetLogIdentifier();
            *buf = 138543618;
            v28 = v24;
            v29 = 2112;
            v30 = v20;
            _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - Network Name: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v21);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v20 forKeyedSubscript:@"threadNetwork_Name"];
        }
      }
    }
  }

  v25 = *MEMORY[0x277D85DE8];
}

- (id)getWiFiNetworkLinkQualityForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__1810;
  v16 = __Block_byref_object_dispose__1811;
  v17 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __75__HMMTRAccessoryServer_Diagnostics__getWiFiNetworkLinkQualityForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __75__HMMTRAccessoryServer_Diagnostics__getWiFiNetworkLinkQualityForAccessory___block_invoke(uint64_t a1)
{
  v26 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];

  if (v2)
  {
    v3 = [HMMTRDeviceTopology alloc];
    v4 = [*(a1 + 32) nodeID];
    v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(a1 + 32)];

    if (v5)
    {
      v6 = [MEMORY[0x277CBEB38] dictionary];
      v7 = *(*(a1 + 48) + 8);
      v8 = *(v7 + 40);
      *(v7 + 40) = v6;

      v9 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v5];
      v21 = 0;
      v10 = *(a1 + 32);
      v11 = [v10 matterDevice];
      v12 = [v10 wifiNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v21];

      if (v12)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC38] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
        v13 = *(a1 + 32);
        v14 = [v12 readAttributeRSSIWithParams:0];
        v15 = [v13 numberOfReadValue:v14];

        if (v15)
        {
          v16 = objc_autoreleasePoolPush();
          v17 = *(a1 + 32);
          v18 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v19 = HMFGetLogIdentifier();
            *buf = 138543618;
            v23 = v19;
            v24 = 2112;
            v25 = v15;
            _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v16);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"wifiNetwork_RSSI"];
        }
      }
    }
  }

  v20 = *MEMORY[0x277D85DE8];
}

- (id)getConnectNetworkIDForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__1810;
  v16 = __Block_byref_object_dispose__1811;
  v17 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_Diagnostics__getConnectNetworkIDForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __69__HMMTRAccessoryServer_Diagnostics__getConnectNetworkIDForAccessory___block_invoke(uint64_t a1)
{
  v26 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];

  if (v2)
  {
    v3 = [HMMTRDeviceTopology alloc];
    v4 = [*(a1 + 32) nodeID];
    v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(a1 + 32)];

    if (v5)
    {
      v6 = [MEMORY[0x277CBEB38] dictionary];
      v7 = *(*(a1 + 48) + 8);
      v8 = *(v7 + 40);
      *(v7 + 40) = v6;

      v9 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v5];
      v21 = 0;
      v10 = *(a1 + 32);
      v11 = [v10 matterDevice];
      v12 = [v10 networkCommissioningClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v21];

      if (v12)
      {
        v13 = *(a1 + 32);
        v14 = [v12 readAttributeNetworksWithParams:0];
        v15 = [v13 connectedNetworkIDFromReadValue:v14];

        v16 = objc_autoreleasePoolPush();
        v17 = *(a1 + 32);
        v18 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v19 = HMFGetLogIdentifier();
          *buf = 138543618;
          v23 = v19;
          v24 = 2112;
          v25 = v15;
          _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Found connected network ID: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v16);
        [*(*(*(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"network_ID"];
      }
    }
  }

  v20 = *MEMORY[0x277D85DE8];
}

- (id)getOperationalNetworkAddressForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__1810;
  v16 = __Block_byref_object_dispose__1811;
  v17 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __78__HMMTRAccessoryServer_Diagnostics__getOperationalNetworkAddressForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

uint64_t __78__HMMTRAccessoryServer_Diagnostics__getOperationalNetworkAddressForAccessory___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) _getOperationalNetworkAddressForAccessory:*(a1 + 40)];
  v3 = *(*(a1 + 48) + 8);
  v4 = *(v3 + 40);
  *(v3 + 40) = v2;

  return MEMORY[0x2821F96F8]();
}

- (id)getSupportedLinkLayerTypesForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__1810;
  v16 = __Block_byref_object_dispose__1811;
  v17 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_Diagnostics__getSupportedLinkLayerTypesForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

uint64_t __76__HMMTRAccessoryServer_Diagnostics__getSupportedLinkLayerTypesForAccessory___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) _getSupportedLinkLayerTypesForAccessory:*(a1 + 40)];
  v3 = *(*(a1 + 48) + 8);
  v4 = *(v3 + 40);
  *(v3 + 40) = v2;

  return MEMORY[0x2821F96F8]();
}

- (id)_getSupportedLinkLayerTypesForAccessory:(id)accessory
{
  v33 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  dispatch_assert_queue_V2(clientQueue);

  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice)
  {
    v7 = [HMMTRDeviceTopology alloc];
    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:nodeID server:self];

    if (v9)
    {
      v10 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:accessoryCopy topology:v9];
      v30 = 0;
      matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
      v12 = [(HMMTRAccessoryServer *)self networkCommissioningClusterFromEndpoints:v10 topology:v9 device:matterDevice2 definitelyUnsupported:&v30];

      if (v12)
      {
        v13 = [v12 readAttributeFeatureMapWithParams:0];
        v14 = [(HMMTRAccessoryServer *)self numberOfReadValue:v13];

        v15 = [(HMMTRAccessoryServer *)self getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:v14];
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          *buf = 138543362;
          v32 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - no network commissioning cluster", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
        v15 = 0;
      }
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = HMFGetLogIdentifier();
        *buf = 138543362;
        v32 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - no topology", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v15 = 0;
    }
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543362;
      v32 = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - matter device not available", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v16);
    v15 = 0;
  }

  v28 = *MEMORY[0x277D85DE8];

  return v15;
}

- (id)getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:(id)map
{
  v21 = *MEMORY[0x277D85DE8];
  mapCopy = map;
  v5 = mapCopy;
  if (mapCopy)
  {
    unsignedIntegerValue = [mapCopy unsignedIntegerValue];
    v7 = (8 * [v5 unsignedIntegerValue]) & 0x10 | (2 * (unsignedIntegerValue & 1));
    v8 = (v7 | [v5 unsignedIntegerValue] & 4);
    v9 = objc_autoreleasePoolPush();
    selfCopy = self;
    v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = HMFGetLogIdentifier();
      v15 = 138543874;
      v16 = v12;
      v17 = 2112;
      v18 = v5;
      v19 = 2048;
      v20 = v8;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_DEBUG, "%{public}@NetworkCommissioningCluster featureMap: %@, supportedLinkLayerTypes = %ld", &v15, 0x20u);
    }

    objc_autoreleasePoolPop(v9);
    if (v8)
    {
      v8 = [MEMORY[0x277CCABB0] numberWithUnsignedLong:v8];
    }
  }

  else
  {
    v8 = 0;
  }

  v13 = *MEMORY[0x277D85DE8];

  return v8;
}

- (int64_t)getLinkLayerTypeForAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __66__HMMTRAccessoryServer_Diagnostics__getLinkLayerTypeForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v10 = accessoryCopy;
  v11 = &v12;
  block[4] = self;
  v6 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v7 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v7;
}

uint64_t __66__HMMTRAccessoryServer_Diagnostics__getLinkLayerTypeForAccessory___block_invoke(uint64_t a1)
{
  result = [*(a1 + 32) _getLinkLayerTypeForAccessory:*(a1 + 40)];
  *(*(*(a1 + 48) + 8) + 24) = result;
  return result;
}

- (int64_t)_getLinkLayerTypeForAccessory:(id)accessory
{
  v26 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice)
  {
    v6 = [HMMTRDeviceTopology alloc];
    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    v8 = [(HMMTRDeviceTopology *)v6 initWithNodeId:nodeID server:self];

    if (v8)
    {
      v9 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:accessoryCopy topology:v8];
      v21 = 0;
      matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
      v11 = [(HMMTRAccessoryServer *)self networkCommissioningClusterFromEndpoints:v9 topology:v8 device:matterDevice2 definitelyUnsupported:&v21];

      if (v11)
      {
        v12 = [v11 readAttributeFeatureMapWithParams:0];
        v13 = [(HMMTRAccessoryServer *)self numberOfReadValue:v12];

        if (v13)
        {
          v14 = objc_autoreleasePoolPush();
          selfCopy = self;
          v16 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v17 = HMFGetLogIdentifier();
            *buf = 138543618;
            v23 = v17;
            v24 = 2112;
            v25 = v13;
            _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_DEBUG, "%{public}@NetworkCommissioningCluster featureMap: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v14);
          if ([v13 unsignedIntegerValue])
          {
            v18 = 1;
          }

          else if (([v13 unsignedIntegerValue] & 2) != 0)
          {
            v18 = 4;
          }

          else
          {
            v18 = ([v13 unsignedIntegerValue] >> 1) & 2;
          }
        }

        else
        {
          v18 = 0;
        }
      }

      else
      {
        v18 = 0;
      }
    }

    else
    {
      v18 = 0;
    }
  }

  else
  {
    v18 = 0;
  }

  v19 = *MEMORY[0x277D85DE8];
  return v18;
}

- (id)_processEvent:(id)event
{
  v23[4] = *MEMORY[0x277D85DE8];
  v3 = *MEMORY[0x277CD5140];
  eventCopy = event;
  v5 = [eventCopy objectForKeyedSubscript:v3];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v6 = v5;
  }

  else
  {
    v6 = 0;
  }

  v7 = v6;

  v8 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD5138]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v9 = v8;
  }

  else
  {
    v9 = 0;
  }

  v10 = v9;

  v11 = [eventCopy objectForKeyedSubscript:*MEMORY[0x277CD5148]];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  v13 = v12;

  if (v13)
  {
    v14 = v13;
  }

  else
  {
    v14 = &unk_283EE7D88;
  }

  v22[0] = @"UpTime";
  v22[1] = @"EventNumber";
  if (v10)
  {
    v15 = v10;
  }

  else
  {
    v15 = &unk_283EE7D88;
  }

  v23[0] = v14;
  v23[1] = v15;
  v22[2] = @"Cluster";
  cluster = [v7 cluster];
  v23[2] = cluster;
  v22[3] = @"Event";
  event = [v7 event];

  if (event)
  {
    v18 = event;
  }

  else
  {
    v18 = &unk_283EE7D88;
  }

  v23[3] = v18;
  v19 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v23 forKeys:v22 count:4];

  v20 = *MEMORY[0x277D85DE8];

  return v19;
}

- (id)_readPastEventsFromAccessory:(id)accessory forClusters:(id)clusters
{
  v56 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  clustersCopy = clusters;
  v47 = 0;
  v48 = &v47;
  v49 = 0x3032000000;
  v50 = __Block_byref_object_copy__1810;
  v51 = __Block_byref_object_dispose__1811;
  array = [MEMORY[0x277CBEB18] array];
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];
  LODWORD(clusters) = matterDevice == 0;

  if (clusters)
  {
    v23 = objc_autoreleasePoolPush();
    selfCopy = self;
    v25 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v26 = HMFGetLogIdentifier();
      *buf = 138543362;
      v55 = v26;
      _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_ERROR, "%{public}@Matter device is nil", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v23);
    v22 = 0;
  }

  else
  {
    v7 = [HMMTRDeviceTopology alloc];
    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    v37 = [(HMMTRDeviceTopology *)v7 initWithNodeId:nodeID server:self];

    if (v37)
    {
      v9 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:accessoryCopy topology:?];
      buf[0] = 0;
      if (![v9 count])
      {

        v9 = &unk_283EE91F8;
      }

      group = dispatch_group_create();
      v43 = 0u;
      v44 = 0u;
      v45 = 0u;
      v46 = 0u;
      obj = clustersCopy;
      v10 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
      if (v10)
      {
        v11 = *v44;
        do
        {
          for (i = 0; i != v10; ++i)
          {
            if (*v44 != v11)
            {
              objc_enumerationMutation(obj);
            }

            v13 = *(*(&v43 + 1) + 8 * i);
            matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
            v15 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:v13 clusterName:&stru_283ED2308 amongEndpoints:v9 topology:v37 device:matterDevice2 definitelyUnsupported:buf];

            if ((buf[0] & 1) == 0)
            {
              v16 = MEMORY[0x277CD5220];
              nodeID2 = [(HMMTRAccessoryServer *)self nodeID];
              deviceController = [(HMMTRAccessoryServer *)self deviceController];
              v19 = [v16 deviceWithNodeID:nodeID2 controller:deviceController];

              if (v19)
              {
                v20 = objc_alloc_init(MEMORY[0x277CD54D8]);
                [v20 setFilterByFabric:1];
                [v20 setMinEventNumber:0];
                dispatch_group_enter(group);
                clientQueue = [(HAPAccessoryServer *)self clientQueue];
                v38[0] = MEMORY[0x277D85DD0];
                v38[1] = 3221225472;
                v38[2] = __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke;
                v38[3] = &unk_2786EDB30;
                v38[4] = self;
                v39 = accessoryCopy;
                v40 = v13;
                v42 = &v47;
                v41 = group;
                [v19 readEventsWithEndpointID:v15 clusterID:v13 eventID:0 params:v20 queue:clientQueue completion:v38];
              }
            }
          }

          v10 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
        }

        while (v10);
      }

      dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
      v22 = v48[5];
    }

    else
    {
      v27 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v29 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v30 = HMFGetLogIdentifier();
        *buf = 138543362;
        v55 = v30;
        _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_ERROR, "%{public}@Matter topology is nil", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v27);
      v22 = 0;
    }
  }

  _Block_object_dispose(&v47, 8);

  v31 = *MEMORY[0x277D85DE8];

  return v22;
}

void __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v41 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = HMFGetLogIdentifier();
    v11 = [*(a1 + 40) shortDescription];
    v12 = [*(a1 + 48) integerValue];
    *buf = 138544130;
    v34 = v10;
    v35 = 2112;
    v36 = v11;
    v37 = 2048;
    v38 = v12;
    v39 = 2112;
    v40 = v6;
    _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@[%@] Read diagnostic events for cluster ID 0x%lX, error: %@", buf, 0x2Au);
  }

  v26 = v6;

  objc_autoreleasePoolPop(v7);
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  obj = v5;
  v13 = [obj countByEnumeratingWithState:&v28 objects:v32 count:16];
  if (v13)
  {
    v14 = v13;
    v15 = *v29;
    do
    {
      for (i = 0; i != v14; ++i)
      {
        if (*v29 != v15)
        {
          objc_enumerationMutation(obj);
        }

        v17 = *(*(&v28 + 1) + 8 * i);
        v18 = objc_autoreleasePoolPush();
        v19 = *(a1 + 32);
        v20 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          v21 = HMFGetLogIdentifier();
          v22 = [*(a1 + 40) shortDescription];
          *buf = 138543874;
          v34 = v21;
          v35 = 2112;
          v36 = v22;
          v37 = 2112;
          v38 = v17;
          _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@[%@] Received diagnostic event %@", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v18);
        v23 = *(*(*(a1 + 64) + 8) + 40);
        v24 = [*(a1 + 32) _processEvent:v17];
        [v23 addObject:v24];
      }

      v14 = [obj countByEnumeratingWithState:&v28 objects:v32 count:16];
    }

    while (v14);
  }

  dispatch_group_leave(*(a1 + 56));
  v25 = *MEMORY[0x277D85DE8];
}

- (id)readPastDiagnosticEventsFromAccessory:(id)accessory fromEventNumber:(id)number
{
  v16 = *MEMORY[0x277D85DE8];
  v11 = &unk_283EE7CF8;
  v12 = &unk_283EE7D28;
  v13 = &unk_283EE7D40;
  v14 = &unk_283EE7D58;
  v15 = &unk_283EE7D70;
  v5 = MEMORY[0x277CBEA60];
  accessoryCopy = accessory;
  v7 = [v5 arrayWithObjects:&v11 count:5];
  v8 = [(HMMTRAccessoryServer *)self _readPastEventsFromAccessory:accessoryCopy forClusters:v7, v11, v12, v13, v14, v15, v16];

  v9 = *MEMORY[0x277D85DE8];

  return v8;
}

- (id)collectDiagnosticsForAccessory:(id)accessory
{
  v27 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  v17 = 0;
  v18 = &v17;
  v19 = 0x3032000000;
  v20 = __Block_byref_object_copy__1810;
  v21 = __Block_byref_object_dispose__1811;
  v22 = 0;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543618;
    v24 = v8;
    v25 = 2112;
    v26 = accessoryCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Collecting accessory diagnostics for %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __68__HMMTRAccessoryServer_Diagnostics__collectDiagnosticsForAccessory___block_invoke;
  block[3] = &unk_2786F0468;
  v15 = accessoryCopy;
  v16 = &v17;
  block[4] = selfCopy;
  v10 = accessoryCopy;
  dispatch_sync(clientQueue, block);

  v11 = v18[5];
  _Block_object_dispose(&v17, 8);

  v12 = *MEMORY[0x277D85DE8];

  return v11;
}

void __68__HMMTRAccessoryServer_Diagnostics__collectDiagnosticsForAccessory___block_invoke(uint64_t a1)
{
  v198 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];

  if (v2)
  {
    v3 = [HMMTRDeviceTopology alloc];
    v4 = [*(a1 + 32) nodeID];
    v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(a1 + 32)];

    if (v5)
    {
      v6 = [MEMORY[0x277CBEB38] dictionary];
      v7 = *(*(a1 + 48) + 8);
      v8 = *(v7 + 40);
      *(v7 + 40) = v6;

      v9 = [*(a1 + 32) endpointsForHAPAccessory:*(a1 + 40) topology:v5];
      v193 = 0;
      v10 = *(a1 + 32);
      v11 = [v10 matterDevice];
      v12 = [v10 generalDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v193];

      if (v12)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC38] forKeyedSubscript:@"general_DiagnosticsSupported"];
        v13 = *(a1 + 32);
        v14 = [v12 readAttributeRebootCountWithParams:0];
        v15 = [v13 numberOfReadValue:v14];

        if (v15)
        {
          v16 = objc_autoreleasePoolPush();
          v17 = *(a1 + 32);
          v18 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            v19 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v19;
            v196 = 2112;
            v197 = v15;
            _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - RebootCount: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v16);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"general_RebootCount"];
        }

        v20 = *(a1 + 32);
        v21 = [v12 readAttributeUpTimeWithParams:0];
        v22 = [v20 numberOfReadValue:v21];

        if (v22)
        {
          v23 = objc_autoreleasePoolPush();
          v24 = *(a1 + 32);
          v25 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            v26 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v26;
            v196 = 2112;
            v197 = v22;
            _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - UpTime: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v23);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v22 forKeyedSubscript:@"general_UpTime"];
          v27 = objc_alloc_init(MEMORY[0x277CCA968]);
          v28 = [MEMORY[0x277CBEAF8] localeWithLocaleIdentifier:@"en_US_POSIX"];
          [v27 setLocale:v28];

          [v27 setDateFormat:@"yyyy-MM-dd' 'HH:mm:ss-ZZZZZ"];
          v29 = [MEMORY[0x277CBEBB0] timeZoneForSecondsFromGMT:-28800];
          [v27 setTimeZone:v29];

          v30 = [MEMORY[0x277CBEAA8] date];
          [v22 doubleValue];
          v32 = [v30 addTimeInterval:-v31];

          v33 = [v27 stringFromDate:v32];
          [*(*(*(a1 + 48) + 8) + 40) setObject:v33 forKeyedSubscript:@"general_LastRebootTime"];
        }

        v34 = *(a1 + 32);
        v35 = [v12 readAttributeTotalOperationalHoursWithParams:0];
        v36 = [v34 numberOfReadValue:v35];

        if (v36)
        {
          v37 = objc_autoreleasePoolPush();
          v38 = *(a1 + 32);
          v39 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            v40 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v40;
            v196 = 2112;
            v197 = v36;
            _os_log_impl(&dword_22AEAE000, v39, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - TotalOperationalHours: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v37);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v36 forKeyedSubscript:@"general_TotalOperationalHours"];
        }

        v41 = *(a1 + 32);
        v42 = [v12 readAttributeBootReasonWithParams:0];
        v43 = [v41 numberOfReadValue:v42];

        if (v43)
        {
          v44 = objc_autoreleasePoolPush();
          v45 = *(a1 + 32);
          v46 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            v47 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v47;
            v196 = 2112;
            v197 = v43;
            _os_log_impl(&dword_22AEAE000, v46, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - BootReason: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v44);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v43 forKeyedSubscript:@"general_BootReason"];
        }
      }

      else if (v193 == 1)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC28] forKeyedSubscript:@"general_DiagnosticsSupported"];
      }

      v48 = *(a1 + 32);
      v49 = [v48 matterDevice];
      v50 = [v48 threadNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v49 definitelyUnsupported:&v193];

      v192 = v12;
      if (v50)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC38] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
        v51 = *(a1 + 32);
        v52 = [v50 readAttributeFeatureMapWithParams:0];
        v53 = [v51 numberOfReadValue:v52];

        if (v53)
        {
          v54 = objc_autoreleasePoolPush();
          v55 = *(a1 + 32);
          v56 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            v57 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v57;
            v196 = 2112;
            v197 = v53;
            _os_log_impl(&dword_22AEAE000, v56, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - FeatureMap: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v54);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v53 forKeyedSubscript:@"threadNetwork_DiagnosticsFeatureMap"];
        }

        if (([v53 unsignedIntegerValue] & 8) != 0)
        {
          v59 = [*(a1 + 32) packetCountOfThreadNetworkDiagnostics:v50];
          if (v59)
          {
            v60 = objc_autoreleasePoolPush();
            v61 = *(a1 + 32);
            v62 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
            {
              v63 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v63;
              v196 = 2112;
              v197 = v59;
              _os_log_impl(&dword_22AEAE000, v62, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - PacketCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v60);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v59 forKeyedSubscript:@"threadNetwork_PacketCount"];
          }

          v64 = *(a1 + 32);
          v65 = [v50 readAttributeTxUnicastCountWithParams:0];
          v66 = [v64 numberOfReadValue:v65];

          if (v66)
          {
            v67 = objc_autoreleasePoolPush();
            v68 = *(a1 + 32);
            v69 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
            {
              v70 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v70;
              v196 = 2112;
              v197 = v66;
              _os_log_impl(&dword_22AEAE000, v69, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - TxUnicastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v67);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v66 forKeyedSubscript:@"threadNetwork_PacketTxUnicastCount"];
          }

          v71 = *(a1 + 32);
          v72 = [v50 readAttributeTxBroadcastCountWithParams:0];
          v73 = [v71 numberOfReadValue:v72];

          if (v73)
          {
            v74 = objc_autoreleasePoolPush();
            v75 = *(a1 + 32);
            v76 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              v77 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v77;
              v196 = 2112;
              v197 = v73;
              _os_log_impl(&dword_22AEAE000, v76, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - TxBroadcastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v74);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v73 forKeyedSubscript:@"threadNetwork_PacketTxBroadcastCount"];
          }

          v78 = *(a1 + 32);
          v79 = [v50 readAttributeRxUnicastCountWithParams:0];
          v80 = [v78 numberOfReadValue:v79];

          if (v80)
          {
            v81 = objc_autoreleasePoolPush();
            v82 = *(a1 + 32);
            v83 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
            {
              v84 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v84;
              v196 = 2112;
              v197 = v80;
              _os_log_impl(&dword_22AEAE000, v83, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RxUnicastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v81);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v80 forKeyedSubscript:@"threadNetwork_PacketRxUnicastCount"];
          }

          v85 = *(a1 + 32);
          v86 = [v50 readAttributeRxBroadcastCountWithParams:0];
          v87 = [v85 numberOfReadValue:v86];

          if (v87)
          {
            v88 = objc_autoreleasePoolPush();
            v89 = *(a1 + 32);
            v90 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
            {
              v91 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v91;
              v196 = 2112;
              v197 = v87;
              _os_log_impl(&dword_22AEAE000, v90, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RxBroadcastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v88);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v87 forKeyedSubscript:@"threadNetwork_PacketRxBroadcastCount"];
          }

          v58 = [*(a1 + 32) errorCountOfThreadNetworkDiagnostics:v50];

          if (v58)
          {
            v92 = objc_autoreleasePoolPush();
            v93 = *(a1 + 32);
            v94 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
            {
              v95 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v95;
              v196 = 2112;
              v197 = v58;
              _os_log_impl(&dword_22AEAE000, v94, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - ErrorCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v92);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v58 forKeyedSubscript:@"threadNetwork_ErrorCount"];
          }
        }

        else
        {
          v58 = 0;
        }

        if (([v53 unsignedIntegerValue] & 2) != 0)
        {
          v97 = *(a1 + 32);
          v98 = [v50 readAttributeOverrunCountWithParams:0];
          v96 = [v97 numberOfReadValue:v98];

          if (v96)
          {
            v99 = objc_autoreleasePoolPush();
            v100 = *(a1 + 32);
            v101 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
            {
              v102 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v102;
              v196 = 2112;
              v197 = v96;
              _os_log_impl(&dword_22AEAE000, v101, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - OverrunCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v99);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v96 forKeyedSubscript:@"threadNetwork_OverrunCount"];
          }
        }

        else
        {
          v96 = v58;
        }

        v103 = *(a1 + 32);
        v104 = [v50 readAttributeChannelWithParams:0];
        v105 = [v103 numberOfReadValue:v104];

        if (v105)
        {
          v106 = objc_autoreleasePoolPush();
          v107 = *(a1 + 32);
          v108 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
          {
            v109 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v109;
            v196 = 2112;
            v197 = v105;
            _os_log_impl(&dword_22AEAE000, v108, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - ChannelNumber: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v106);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v105 forKeyedSubscript:@"threadNetwork_ChannelNumber"];
        }

        v110 = [*(a1 + 32) highestRSSIofThreadNetworkDiagnostics:v50];

        if (v110)
        {
          v111 = objc_autoreleasePoolPush();
          v112 = *(a1 + 32);
          v113 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            v114 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v114;
            v196 = 2112;
            v197 = v110;
            _os_log_impl(&dword_22AEAE000, v113, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v111);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v110 forKeyedSubscript:@"threadNetwork_RSSI"];
        }

        v12 = v192;
      }

      else if (v193 == 1)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC28] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
      }

      v115 = *(a1 + 32);
      v116 = [v115 matterDevice];
      v117 = [v115 wifiNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v116 definitelyUnsupported:&v193];

      if (v117)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC38] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
        v118 = *(a1 + 32);
        v119 = [v117 readAttributeFeatureMapWithParams:0];
        v120 = [v118 numberOfReadValue:v119];

        if (v120)
        {
          v121 = objc_autoreleasePoolPush();
          v122 = *(a1 + 32);
          v123 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
          {
            v124 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v124;
            v196 = 2112;
            v197 = v120;
            _os_log_impl(&dword_22AEAE000, v123, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - FeatureMap: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v121);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v120 forKeyedSubscript:@"wifiNetwork_DiagnosticsFeatureMap"];
        }

        v191 = v9;
        if ([v120 unsignedIntegerValue])
        {
          v126 = [*(a1 + 32) packetCountOfWiFiNetworkDiagnostics:v117];
          if (v126)
          {
            v127 = objc_autoreleasePoolPush();
            v128 = *(a1 + 32);
            v129 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
            {
              v130 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v130;
              v196 = 2112;
              v197 = v126;
              _os_log_impl(&dword_22AEAE000, v129, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v127);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v126 forKeyedSubscript:@"wifiNetwork_PacketCount"];
          }

          v131 = *(a1 + 32);
          v132 = [v117 readAttributePacketUnicastTxCountWithParams:0];
          v133 = [v131 numberOfReadValue:v132];

          if (v133)
          {
            v134 = objc_autoreleasePoolPush();
            v135 = *(a1 + 32);
            v136 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
            {
              v137 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v137;
              v196 = 2112;
              v197 = v133;
              _os_log_impl(&dword_22AEAE000, v136, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketTxUnicastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v134);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v133 forKeyedSubscript:@"wifiNetwork_PacketTxUnicastCount"];
          }

          v138 = *(a1 + 32);
          v139 = [v117 readAttributePacketMulticastTxCountWithParams:0];
          v140 = [v138 numberOfReadValue:v139];

          if (v140)
          {
            v141 = objc_autoreleasePoolPush();
            v142 = *(a1 + 32);
            v143 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
            {
              v144 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v144;
              v196 = 2112;
              v197 = v140;
              _os_log_impl(&dword_22AEAE000, v143, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketTxMulticastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v141);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v140 forKeyedSubscript:@"wifiNetwork_PacketTxMulticastCount"];
          }

          v145 = *(a1 + 32);
          v146 = [v117 readAttributePacketUnicastRxCountWithParams:0];
          v147 = [v145 numberOfReadValue:v146];

          if (v147)
          {
            v148 = objc_autoreleasePoolPush();
            v149 = *(a1 + 32);
            v150 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v150, OS_LOG_TYPE_DEBUG))
            {
              v151 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v151;
              v196 = 2112;
              v197 = v147;
              _os_log_impl(&dword_22AEAE000, v150, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketRxUnicastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v148);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v147 forKeyedSubscript:@"wifiNetwork_PacketRxUnicastCount"];
          }

          v152 = *(a1 + 32);
          v153 = [v117 readAttributePacketMulticastRxCountWithParams:0];
          v154 = [v152 numberOfReadValue:v153];

          if (v154)
          {
            v155 = objc_autoreleasePoolPush();
            v156 = *(a1 + 32);
            v157 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
            {
              v158 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v158;
              v196 = 2112;
              v197 = v154;
              _os_log_impl(&dword_22AEAE000, v157, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketRxMulticastCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v155);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v154 forKeyedSubscript:@"wifiNetwork_PacketRxMulticastCount"];
          }

          v159 = *(a1 + 32);
          v160 = [v117 readAttributeBeaconRxCountWithParams:0];
          v125 = [v159 numberOfReadValue:v160];

          if (v125)
          {
            v161 = objc_autoreleasePoolPush();
            v162 = *(a1 + 32);
            v163 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
            {
              v164 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v164;
              v196 = 2112;
              v197 = v125;
              _os_log_impl(&dword_22AEAE000, v163, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - BeaconRxCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v161);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v125 forKeyedSubscript:@"wifiNetwork_BeaconRxCount"];
          }
        }

        else
        {
          v125 = 0;
        }

        if (([v120 unsignedIntegerValue] & 2) != 0)
        {
          v165 = [*(a1 + 32) errorCountOfWiFiNetworkDiagnostics:v117];

          if (v165)
          {
            v166 = objc_autoreleasePoolPush();
            v167 = *(a1 + 32);
            v168 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
            {
              v169 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v169;
              v196 = 2112;
              v197 = v165;
              _os_log_impl(&dword_22AEAE000, v168, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - ErrorCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v166);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v165 forKeyedSubscript:@"wifiNetwork_ErrorCount"];
          }

          v170 = *(a1 + 32);
          v171 = [v117 readAttributeBeaconLostCountWithParams:0];
          v125 = [v170 numberOfReadValue:v171];

          if (v125)
          {
            v172 = objc_autoreleasePoolPush();
            v173 = *(a1 + 32);
            v174 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
            {
              v175 = HMFGetLogIdentifier();
              *buf = 138543618;
              v195 = v175;
              v196 = 2112;
              v197 = v125;
              _os_log_impl(&dword_22AEAE000, v174, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - BeaconLostCount: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v172);
            [*(*(*(a1 + 48) + 8) + 40) setObject:v125 forKeyedSubscript:@"wifiNetwork_BeaconLostCount"];
          }
        }

        v176 = *(a1 + 32);
        v177 = [v117 readAttributeChannelNumberWithParams:0];
        v178 = [v176 numberOfReadValue:v177];

        if (v178)
        {
          v179 = objc_autoreleasePoolPush();
          v180 = *(a1 + 32);
          v181 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
          {
            v182 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v182;
            v196 = 2112;
            v197 = v178;
            _os_log_impl(&dword_22AEAE000, v181, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - ChannelNumber: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v179);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v178 forKeyedSubscript:@"wifiNetwork_ChannelNumber"];
        }

        v183 = *(a1 + 32);
        v184 = [v117 readAttributeRSSIWithParams:0];
        v185 = [v183 numberOfReadValue:v184];

        v9 = v191;
        if (v185)
        {
          v186 = objc_autoreleasePoolPush();
          v187 = *(a1 + 32);
          v188 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
          {
            v189 = HMFGetLogIdentifier();
            *buf = 138543618;
            v195 = v189;
            v196 = 2112;
            v197 = v185;
            _os_log_impl(&dword_22AEAE000, v188, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - RSSI: %@", buf, 0x16u);

            v9 = v191;
          }

          objc_autoreleasePoolPop(v186);
          [*(*(*(a1 + 48) + 8) + 40) setObject:v185 forKeyedSubscript:@"wifiNetwork_RSSI"];
        }

        v12 = v192;
      }

      else if (v193 == 1)
      {
        [*(*(*(a1 + 48) + 8) + 40) setObject:MEMORY[0x277CBEC28] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
      }
    }
  }

  v190 = *MEMORY[0x277D85DE8];
}

- (void)_handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group fabricID:(id)d rootCACert:(id)cert ipk:(id)ipk controllerNodeID:(id)iD commissioneeNodeID:(id)nodeID error:(id)error
{
  v52 = *MEMORY[0x277D85DE8];
  groupCopy = group;
  dCopy = d;
  certCopy = cert;
  ipkCopy = ipk;
  iDCopy = iD;
  nodeIDCopy = nodeID;
  errorCopy = error;
  v21 = objc_autoreleasePoolPush();
  selfCopy = self;
  v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    v24 = HMFGetLogIdentifier();
    *buf = 138543362;
    v49 = v24;
    _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_INFO, "%{public}@Handling Add NOC response", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v21);
  if (errorCopy)
  {
    v25 = objc_autoreleasePoolPush();
    v26 = selfCopy;
    v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = HMFGetLogIdentifier();
      *buf = 138543618;
      v49 = v28;
      v50 = 2112;
      v51 = errorCopy;
      _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_ERROR, "%{public}@Failed to add noc with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v25);
    dispatch_group_leave(groupCopy);
    v29 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:19 error:errorCopy];
    [(HMMTRAccessoryServer *)v26 _handlePairingFailureWithError:errorCopy context:v29];
  }

  else
  {
    [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingStep:20];
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    v31 = objc_autoreleasePoolPush();
    v32 = selfCopy;
    v33 = HMFGetOSLogHandle();
    v34 = v33;
    if (browser)
    {
      v41 = certCopy;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        v35 = HMFGetLogIdentifier();
        *buf = 138543362;
        v49 = v35;
        _os_log_impl(&dword_22AEAE000, v34, OS_LOG_TYPE_INFO, "%{public}@Switching to System Commissioner Fabric to complete commissioning...", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v31);
      clientQueue = [(HAPAccessoryServer *)v32 clientQueue];
      v43[0] = MEMORY[0x277D85DD0];
      v43[1] = 3221225472;
      v43[2] = __201__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_ipk_controllerNodeID_commissioneeNodeID_error___block_invoke;
      v43[3] = &unk_2786EDD20;
      v43[4] = v32;
      v29 = browser;
      v44 = v29;
      v45 = groupCopy;
      v46 = dCopy;
      v47 = nodeIDCopy;
      certCopy = v41;
      [v29 finishSystemCommissionerFabricCommissioningWithFabricID:v46 rootCACert:v41 ipk:ipkCopy controllerNodeID:iDCopy commissioneeNodeID:v47 queue:clientQueue completion:v43];
    }

    else
    {
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        v37 = HMFGetLogIdentifier();
        *buf = 138543362;
        v49 = v37;
        _os_log_impl(&dword_22AEAE000, v34, OS_LOG_TYPE_ERROR, "%{public}@Accessory Server Browser disappeared. Aborting pairing", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v31);
      dispatch_group_leave(groupCopy);
      v38 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:1 userInfo:0];
      v39 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:20 error:v38];
      [(HMMTRAccessoryServer *)v32 _handlePairingFailureWithError:v38 context:v39];

      v29 = 0;
    }
  }

  v40 = *MEMORY[0x277D85DE8];
}

void __201__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_ipk_controllerNodeID_commissioneeNodeID_error___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  v73 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v8)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543618;
      v70 = v13;
      v71 = 2112;
      v72 = v8;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to finish commissioning for System Commissioner with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    v14 = *(a1 + 40);
    v15 = [*(a1 + 32) fabricUUID];
    [v14 setUpBrowserTargetFabricUUID:v15];

    dispatch_group_leave(*(a1 + 48));
    [*(a1 + 32) _handlePairingFailureWithError:v8 context:v9];
    goto LABEL_34;
  }

  [*(a1 + 32) _notifyDelegateOfPairingStep:22];
  v16 = objc_autoreleasePoolPush();
  v17 = *(a1 + 32);
  v18 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    v19 = HMFGetLogIdentifier();
    v20 = *(a1 + 56);
    *buf = 138543618;
    v70 = v19;
    v71 = 2112;
    v72 = v20;
    _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Successfully commissioned accessory to System Commissioner Fabric (%@), updating storage", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v16);
  v21 = [*(a1 + 32) browser];
  v22 = [v21 storageForSystemCommissioner];

  [v22 addPairedNodeID:*(a1 + 64) toSystemCommissionerFabric:1];
  v23 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.VendorID."];
  v24 = [*(a1 + 32) vendorID];
  [v22 setValueForKey:v23 value:v24 systemCommissionerFabric:1];

  v25 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.FabricIndex."];
  [v22 setValueForKey:v25 value:*(a1 + 56) systemCommissionerFabric:1];

  v26 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.ProductID."];
  v27 = [*(a1 + 32) productID];
  [v22 setValueForKey:v26 value:v27 systemCommissionerFabric:1];

  v28 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.Category."];
  v29 = [*(a1 + 32) category];
  [v22 setValueForKey:v28 value:v29 systemCommissionerFabric:1];

  v30 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.ConfigNumber."];
  v31 = [MEMORY[0x277CCABB0] numberWithUnsignedInteger:{objc_msgSend(*(a1 + 32), "configNumber")}];
  [v22 setValueForKey:v30 value:v31 systemCommissionerFabric:1];

  v32 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.Staged."];
  [v22 setValueForKey:v32 value:MEMORY[0x277CBEC28] systemCommissionerFabric:1];

  v33 = [*(a1 + 32) topology];

  if (v33)
  {
    v34 = [HMMTRStorage formatKeyForNodeId:*(a1 + 64) key:@"HMD.MTRPlugin.Topology."];
    v35 = [*(a1 + 32) topology];
    v36 = [v35 base64EncodedStringWithOptions:0];
    [v22 setValueForKey:v34 value:v36 systemCommissionerFabric:1];
  }

  v37 = [*(a1 + 32) ensureCommissioningID];
  [v22 setSystemCommissionerFabricNodeID:*(a1 + 64) forUuid:v37];
  [v22 setUuid:v37 forSystemCommissionerFabricNode:*(a1 + 64)];
  if (v7)
  {
    [v22 setSerialNumber:v7 forSystemCommissionerFabricNode:*(a1 + 64)];
  }

  v38 = [*(a1 + 32) name];
  [v22 setDeviceName:v38 forSystemCommissionerFabricNode:*(a1 + 64)];

  v39 = [*(a1 + 32) setupPayloadString];
  if (v39 && (v40 = v39, [*(a1 + 32) setupPayloadString], v41 = objc_claimAutoreleasedReturnValue(), v42 = objc_msgSend(v41, "isEqual:", &stru_283ED2308), v41, v40, (v42 & 1) == 0))
  {
    v47 = [*(a1 + 32) setupPayloadString];
  }

  else
  {
    v43 = [*(a1 + 32) onboardingSetupPayloadString];
    if (!v43)
    {
      goto LABEL_18;
    }

    v44 = v43;
    v45 = [*(a1 + 32) onboardingSetupPayloadString];
    v46 = [v45 isEqual:&stru_283ED2308];

    if (v46)
    {
      goto LABEL_18;
    }

    v47 = [*(a1 + 32) onboardingSetupPayloadString];
  }

  v48 = v47;
  [v22 setSetupPayload:v47 forSystemCommissionerFabricNode:*(a1 + 64)];

LABEL_18:
  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    [v22 setWEDSupported:objc_msgSend(*(a1 + 32) forSystemCommissionerFabricNode:{"isWEDDevice"), *(a1 + 64)}];
    if ([*(a1 + 32) isWEDDevice])
    {
      v49 = [*(a1 + 32) eMACAddress];
      [v22 setExtendedMACAddress:v49 forSystemCommissionerFabricNode:*(a1 + 64)];
    }
  }

  if (_os_feature_enabled_impl())
  {
    v50 = [*(a1 + 32) commissioneeInfo];

    if (!v50)
    {
      _HMFPreconditionFailure();
    }

    v51 = MEMORY[0x277CD55B0];
    v52 = [*(a1 + 32) commissioneeInfo];
    v53 = [v52 rootEndpoint];
    v54 = [v51 threadCredentialManagementEndpoint:v53];

    if (v54)
    {
      [v22 setThreadCredentialManagementEndpoint:v54 forSystemCommissionerFabricNode:*(a1 + 64)];
    }
  }

  v55 = v7;
  v56 = v9;
  v57 = *(a1 + 40);
  v58 = [*(a1 + 32) vendorID];
  v59 = [*(a1 + 32) productID];
  v60 = [*(a1 + 32) setupPayloadString];
  if ([v60 isEqual:&stru_283ED2308])
  {
    [v57 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v37 vendorID:v58 productID:v59 serialNumber:v55 setupPayload:0];
  }

  else
  {
    v61 = [*(a1 + 32) setupPayloadString];
    [v57 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v37 vendorID:v58 productID:v59 serialNumber:v55 setupPayload:v61];
  }

  v62 = objc_autoreleasePoolPush();
  v63 = *(a1 + 32);
  v64 = HMFGetOSLogHandle();
  v9 = v56;
  if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
  {
    v65 = HMFGetLogIdentifier();
    *buf = 138543362;
    v70 = v65;
    _os_log_impl(&dword_22AEAE000, v64, OS_LOG_TYPE_INFO, "%{public}@Successfully paired accessory into System Commissioner", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v62);
  v66 = *(a1 + 40);
  v67 = [*(a1 + 32) fabricUUID];
  [v66 setUpBrowserTargetFabricUUID:v67];

  v7 = v55;
  if ((isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
  {
    [*(a1 + 32) setOperationDisabled:1];
    [*(a1 + 32) setOperationDisabledReason:1];
  }

  [*(a1 + 32) _handlePairOnSystemCommissionerFabricSuccess];
  dispatch_group_leave(*(a1 + 48));
  v8 = 0;
LABEL_34:

  v68 = *MEMORY[0x277D85DE8];
}

- (void)_handleNewSystemCommissionerFabricNodeID:(id)d dispatchGroup:(id)group fabricID:(id)iD rootCACert:(id)cert operationalPublicKey:(id)key ipk:(id)ipk controllerNodeID:(id)nodeID device:(id)self0
{
  v80[2] = *MEMORY[0x277D85DE8];
  dCopy = d;
  group = group;
  iDCopy = iD;
  certCopy = cert;
  keyCopy = key;
  ipkCopy = ipk;
  nodeIDCopy = nodeID;
  deviceCopy = device;
  v21 = objc_alloc(MEMORY[0x277CD5208]);
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v59 = deviceCopy;
  v58 = [v21 initWithDevice:deviceCopy endpointID:&unk_283EE7F68 queue:clientQueue];

  v23 = objc_alloc_init(MEMORY[0x277CD5458]);
  v24 = *MEMORY[0x277CDBFE0];
  v79[0] = *MEMORY[0x277CDC028];
  v79[1] = v24;
  v25 = *MEMORY[0x277CDC000];
  v80[0] = *MEMORY[0x277CDC040];
  v80[1] = v25;
  v26 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v80 forKeys:v79 count:2];
  error = 0;
  v60 = keyCopy;
  v27 = SecKeyCreateWithData(keyCopy, v26, &error);
  if (!v27)
  {
    v40 = objc_autoreleasePoolPush();
    selfCopy = self;
    v42 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      v43 = HMFGetLogIdentifier();
      *buf = 138543874;
      v74 = v43;
      v75 = 2112;
      v76 = v60;
      v77 = 2112;
      v78 = error;
      _os_log_impl(&dword_22AEAE000, v42, OS_LOG_TYPE_ERROR, "%{public}@Failed to create SecKey from %@: %@", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v40);
    dispatch_group_leave(group);
    v30 = error;
    v31 = [HMMTRAccessoryPairingEndContext otherContextWithStep:18 error:v30];
    [(HMMTRAccessoryServer *)selfCopy _handlePairingFailureWithError:v30 context:v31];
    goto LABEL_16;
  }

  v28 = v27;
  browser = [(HMMTRAccessoryServer *)self browser];
  v71 = 0;
  v30 = [browser createSystemCommissionerFabricNOCWithSigningCertificate:certCopy operationalPublicKey:v28 fabricID:iDCopy nodeID:dCopy caseAuthenticatedTags:0 error:&v71];
  v31 = v71;

  CFRelease(v28);
  if (!v30)
  {
    v44 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v46 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      v47 = HMFGetLogIdentifier();
      *buf = 138543618;
      v74 = v47;
      v75 = 2112;
      v76 = v31;
      _os_log_impl(&dword_22AEAE000, v46, OS_LOG_TYPE_ERROR, "%{public}@Failed to create system fabric NOC: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v44);
    dispatch_group_leave(group);
    v48 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:18 error:v31];
    [(HMMTRAccessoryServer *)selfCopy2 _handlePairingFailureWithError:v31 context:v48];

    v30 = 0;
    goto LABEL_16;
  }

  v32 = [MEMORY[0x277CD5230] convertX509Certificate:v30];
  [v23 setNocValue:v32];

  nocValue = [v23 nocValue];

  if (!nocValue)
  {
    v49 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v51 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      HMFGetLogIdentifier();
      v52 = v57 = v49;
      *buf = 138543362;
      v74 = v52;
      _os_log_impl(&dword_22AEAE000, v51, OS_LOG_TYPE_ERROR, "%{public}@Failed to convert NOC to TLV format", buf, 0xCu);

      v49 = v57;
    }

    objc_autoreleasePoolPop(v49);
    dispatch_group_leave(group);
    v53 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
    v54 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:18 error:v53];
    [(HMMTRAccessoryServer *)selfCopy3 _handlePairingFailureWithError:v53 context:v54];

LABEL_16:
    v39 = v58;
    goto LABEL_17;
  }

  [v23 setIpkValue:ipkCopy];
  [v23 setCaseAdminSubject:nodeIDCopy];
  [v23 setAdminVendorId:&unk_283EE7F98];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:19];
  v34 = objc_autoreleasePoolPush();
  selfCopy4 = self;
  v36 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    v56 = certCopy;
    v38 = v37 = iDCopy;
    *buf = 138543618;
    v74 = v38;
    v75 = 2112;
    v76 = dCopy;
    _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_INFO, "%{public}@Adding NOC for System Commissioner with node ID %@", buf, 0x16u);

    iDCopy = v37;
    certCopy = v56;
  }

  objc_autoreleasePoolPop(v34);
  v64[0] = MEMORY[0x277D85DD0];
  v64[1] = 3221225472;
  v64[2] = __175__HMMTRAccessoryServer_SystemCommissionerPairing___handleNewSystemCommissionerFabricNodeID_dispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID_device___block_invoke;
  v64[3] = &unk_2786EDCF8;
  v64[4] = selfCopy4;
  groupCopy = group;
  v66 = iDCopy;
  v67 = certCopy;
  v68 = ipkCopy;
  v69 = nodeIDCopy;
  v70 = dCopy;
  v39 = v58;
  [v58 addNOCWithParams:v23 completion:v64];

LABEL_17:
  v55 = *MEMORY[0x277D85DE8];
}

- (void)_handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group fabricID:(id)d rootCACert:(id)cert operationalPublicKey:(id)key ipk:(id)ipk controllerNodeID:(id)iD
{
  v54 = *MEMORY[0x277D85DE8];
  groupCopy = group;
  dCopy = d;
  certCopy = cert;
  keyCopy = key;
  ipkCopy = ipk;
  iDCopy = iD;
  v19 = objc_autoreleasePoolPush();
  selfCopy = self;
  v21 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    v22 = HMFGetLogIdentifier();
    *buf = 138543362;
    v53 = v22;
    _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@Handling AddTrustedRootCert response", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v19);
  deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
  v24 = dCopy;
  if (!deviceController)
  {
    v31 = objc_autoreleasePoolPush();
    v32 = selfCopy;
    v33 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v34 = HMFGetLogIdentifier();
      *buf = 138543362;
      v53 = v34;
      _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v31);
    dispatch_group_leave(groupCopy);
    v30 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    v35 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:17 error:v30];
    [(HMMTRAccessoryServer *)v32 _handlePairingFailureWithError:v30 context:v35];

    goto LABEL_12;
  }

  v25 = MEMORY[0x277CD5220];
  nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
  v27 = [v25 deviceWithNodeID:nodeID controller:deviceController];

  if (!v27)
  {
    v36 = objc_autoreleasePoolPush();
    v37 = selfCopy;
    v38 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v39 = HMFGetLogIdentifier();
      *buf = 138543362;
      v53 = v39;
      _os_log_impl(&dword_22AEAE000, v38, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v36);
    dispatch_group_leave(groupCopy);
    v40 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
    v41 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:17 error:v40];
    [(HMMTRAccessoryServer *)v37 _handlePairingFailureWithError:v40 context:v41];

    v30 = 0;
LABEL_12:
    v29 = certCopy;
    goto LABEL_13;
  }

  [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingStep:18];
  browser = [(HMMTRAccessoryServer *)selfCopy browser];
  v44[0] = MEMORY[0x277D85DD0];
  v44[1] = 3221225472;
  v44[2] = __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke;
  v44[3] = &unk_2786EDCD0;
  v44[4] = selfCopy;
  v45 = groupCopy;
  v46 = v24;
  v29 = certCopy;
  v47 = certCopy;
  v48 = keyCopy;
  v49 = ipkCopy;
  v50 = iDCopy;
  v30 = v27;
  v51 = v30;
  [browser createNewSystemCommissionerFabricNodeIDWithCompletion:v44];

LABEL_13:
  v42 = *MEMORY[0x277D85DE8];
}

void __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke_2;
  block[3] = &unk_2786EDC58;
  v5 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v14 = v3;
  v6 = v5;
  v7 = *(a1 + 48);
  v8 = *(a1 + 56);
  v9 = *(a1 + 64);
  *&v10 = v8;
  *(&v10 + 1) = v9;
  *&v11 = v6;
  *(&v11 + 1) = v7;
  v15 = v11;
  v16 = v10;
  v17 = *(a1 + 72);
  v18 = *(a1 + 80);
  v19 = *(a1 + 88);
  v12 = v3;
  dispatch_async(v4, block);
}

- (void)_handleSystemCommissionerRootCertificate:(id)certificate fabricID:(id)d ipk:(id)ipk controllerNodeID:(id)iD dispatchGroup:(id)group csrResponseParams:(id)params device:(id)device
{
  v58 = *MEMORY[0x277D85DE8];
  certificateCopy = certificate;
  dCopy = d;
  ipkCopy = ipk;
  iDCopy = iD;
  groupCopy = group;
  paramsCopy = params;
  deviceCopy = device;
  v20 = objc_alloc(MEMORY[0x277CD5208]);
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v22 = [v20 initWithDevice:deviceCopy endpointID:&unk_283EE7F68 queue:clientQueue];

  v23 = objc_alloc_init(MEMORY[0x277CD5460]);
  v24 = [MEMORY[0x277CD5230] convertX509Certificate:certificateCopy];
  [v23 setRootCertificate:v24];

  rootCertificate = [v23 rootCertificate];

  if (rootCertificate)
  {
    [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:17];
    v26 = objc_autoreleasePoolPush();
    selfCopy = self;
    v28 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      v45 = certificateCopy;
      v29 = deviceCopy;
      v30 = groupCopy;
      v31 = v22;
      v32 = paramsCopy;
      v34 = v33 = iDCopy;
      *buf = 138543362;
      v57 = v34;
      _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_INFO, "%{public}@Adding trusted root certificate", buf, 0xCu);

      iDCopy = v33;
      paramsCopy = v32;
      v22 = v31;
      groupCopy = v30;
      deviceCopy = v29;
      certificateCopy = v45;
    }

    objc_autoreleasePoolPop(v26);
    v49[0] = MEMORY[0x277D85DD0];
    v49[1] = 3221225472;
    v49[2] = __161__HMMTRAccessoryServer_SystemCommissionerPairing___handleSystemCommissionerRootCertificate_fabricID_ipk_controllerNodeID_dispatchGroup_csrResponseParams_device___block_invoke;
    v49[3] = &unk_2786EDCA8;
    v49[4] = selfCopy;
    v50 = groupCopy;
    v51 = paramsCopy;
    v35 = dCopy;
    v52 = dCopy;
    v53 = certificateCopy;
    v36 = ipkCopy;
    v54 = ipkCopy;
    v55 = iDCopy;
    [v22 addTrustedRootCertificateWithParams:v23 completion:v49];
  }

  else
  {
    v37 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v39 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      HMFGetLogIdentifier();
      v46 = paramsCopy;
      v41 = v40 = iDCopy;
      *buf = 138543362;
      v57 = v41;
      _os_log_impl(&dword_22AEAE000, v39, OS_LOG_TYPE_ERROR, "%{public}@Failed to convert root CA cert to Matter certificate", buf, 0xCu);

      iDCopy = v40;
      paramsCopy = v46;
    }

    objc_autoreleasePoolPop(v37);
    dispatch_group_leave(groupCopy);
    v42 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
    v43 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:v42];
    [(HMMTRAccessoryServer *)selfCopy2 _handlePairingFailureWithError:v42 context:v43];

    v36 = ipkCopy;
    v35 = dCopy;
  }

  v44 = *MEMORY[0x277D85DE8];
}

void __161__HMMTRAccessoryServer_SystemCommissionerPairing___handleSystemCommissionerRootCertificate_fabricID_ipk_controllerNodeID_dispatchGroup_csrResponseParams_device___block_invoke(uint64_t a1, void *a2)
{
  v29 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = v3;
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543618;
      v26 = v8;
      v27 = 2112;
      v28 = v4;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to add trusted root certificate with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v5);
    dispatch_group_leave(*(a1 + 40));
    v9 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:16 error:v4];
    [*(a1 + 32) _handlePairingFailureWithError:v4 context:v9];
  }

  else
  {
    v10 = [*(a1 + 48) nocsrElements];
    v9 = [HMMTRTLVParser csrFromNOCSRElements:v10];

    if (v9)
    {
      v24 = 0;
      v11 = [MEMORY[0x277CD5230] publicKeyFromCSR:v9 error:&v24];
      v4 = v24;
      if (v11)
      {
        [*(a1 + 32) _handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:*(a1 + 40) fabricID:*(a1 + 56) rootCACert:*(a1 + 64) operationalPublicKey:v11 ipk:*(a1 + 72) controllerNodeID:*(a1 + 80)];
      }

      else
      {
        v18 = objc_autoreleasePoolPush();
        v19 = *(a1 + 32);
        v20 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v21 = HMFGetLogIdentifier();
          *buf = 138543618;
          v26 = v21;
          v27 = 2112;
          v28 = v4;
          _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_ERROR, "%{public}@Failed to extract public key from CSR: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v18);
        dispatch_group_leave(*(a1 + 40));
        v22 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:16 error:v4];
        [*(a1 + 32) _handlePairingFailureWithError:v4 context:v22];

        v11 = 0;
      }
    }

    else
    {
      v12 = objc_autoreleasePoolPush();
      v13 = *(a1 + 32);
      v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = HMFGetLogIdentifier();
        v16 = [*(a1 + 48) nocsrElements];
        *buf = 138543618;
        v26 = v15;
        v27 = 2112;
        v28 = v16;
        _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@Failed to extract CSR from nocsr_elements: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v12);
      dispatch_group_leave(*(a1 + 40));
      v11 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
      v17 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:v11];
      [*(a1 + 32) _handlePairingFailureWithError:v11 context:v17];

      v4 = 0;
    }
  }

  v23 = *MEMORY[0x277D85DE8];
}

- (void)_handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group responseParams:(id)params error:(id)error
{
  v43 = *MEMORY[0x277D85DE8];
  groupCopy = group;
  paramsCopy = params;
  errorCopy = error;
  v11 = objc_autoreleasePoolPush();
  selfCopy = self;
  v13 = HMFGetOSLogHandle();
  v14 = v13;
  if (errorCopy)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v40 = v15;
      v41 = 2112;
      v42 = errorCopy;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@Failed CSR request with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    dispatch_group_leave(groupCopy);
    deviceController = [HMMTRAccessoryPairingEndContext mtrContextWithStep:15 error:errorCopy];
    [(HMMTRAccessoryServer *)selfCopy _handlePairingFailureWithError:errorCopy context:deviceController];
  }

  else
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      *buf = 138543362;
      v40 = v17;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Handling CSRResponse", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v11);
    deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
    if (deviceController)
    {
      v18 = MEMORY[0x277CD5220];
      nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
      v20 = [v18 deviceWithNodeID:nodeID controller:deviceController];

      if (v20)
      {
        [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingStep:16];
        browser = [(HMMTRAccessoryServer *)selfCopy browser];
        v35[0] = MEMORY[0x277D85DD0];
        v35[1] = 3221225472;
        v35[2] = __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke;
        v35[3] = &unk_2786EDC80;
        v35[4] = selfCopy;
        v36 = groupCopy;
        v37 = paramsCopy;
        v22 = v20;
        v38 = v22;
        [browser fetchSystemCommissionerRootCertificateWithCompletion:v35];
      }

      else
      {
        v28 = objc_autoreleasePoolPush();
        v29 = selfCopy;
        v30 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          v31 = HMFGetLogIdentifier();
          *buf = 138543618;
          v40 = v31;
          v41 = 2112;
          v42 = 0;
          _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v28);
        dispatch_group_leave(groupCopy);
        v32 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
        v33 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:15 error:v32];
        [(HMMTRAccessoryServer *)v29 _handlePairingFailureWithError:v32 context:v33];

        v22 = 0;
      }
    }

    else
    {
      v23 = objc_autoreleasePoolPush();
      v24 = selfCopy;
      v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        v26 = HMFGetLogIdentifier();
        *buf = 138543362;
        v40 = v26;
        _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v23);
      dispatch_group_leave(groupCopy);
      v22 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      v27 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:15 error:v22];
      [(HMMTRAccessoryServer *)v24 _handlePairingFailureWithError:v22 context:v27];
    }
  }

  v34 = *MEMORY[0x277D85DE8];
}

void __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  v16 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke_2;
  block[3] = &unk_2786EDC58;
  v24 = v11;
  v25 = v15;
  v17 = *(a1 + 40);
  v26 = *(a1 + 32);
  v27 = v17;
  v28 = v12;
  v29 = v13;
  v30 = v14;
  v31 = *(a1 + 48);
  v32 = *(a1 + 56);
  v18 = v14;
  v19 = v13;
  v20 = v12;
  v21 = v15;
  v22 = v11;
  dispatch_async(v16, block);
}

void __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke_2(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32) && !*(a1 + 40))
  {
    v8 = *(a1 + 64);
    v9 = *(a1 + 72);
    v10 = *(a1 + 56);
    v11 = *(a1 + 80);
    v12 = *(a1 + 88);
    [*(a1 + 48) _handleSystemCommissionerRootCertificate:*(a1 + 96) fabricID:? ipk:? controllerNodeID:? dispatchGroup:? csrResponseParams:? device:?];
  }

  else
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 48);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 40);
      *buf = 138543618;
      v15 = v5;
      v16 = 2112;
      v17 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch root certificate: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v2);
    dispatch_group_leave(*(a1 + 56));
    v7 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:*(a1 + 40)];
    [*(a1 + 48) _handlePairingFailureWithError:*(a1 + 40) context:v7];
  }

  v13 = *MEMORY[0x277D85DE8];
}

- (void)_handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)group error:(id)error
{
  v46 = *MEMORY[0x277D85DE8];
  groupCopy = group;
  errorCopy = error;
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543362;
    v43 = v11;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Handling Arm fail safe response", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  if (errorCopy)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = selfCopy;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v43 = v15;
      v44 = 2112;
      v45 = errorCopy;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@Failed to arm fail safe with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v12);
    dispatch_group_leave(groupCopy);
    deviceController = [HMMTRAccessoryPairingEndContext mtrContextWithStep:14 error:errorCopy];
    [(HMMTRAccessoryServer *)v13 _handlePairingFailureWithError:errorCopy context:deviceController];
  }

  else
  {
    deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
    if (deviceController)
    {
      v17 = MEMORY[0x277CD5220];
      nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
      v19 = [v17 deviceWithNodeID:nodeID controller:deviceController];

      if (v19)
      {
        [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingStep:15];
        v20 = objc_alloc(MEMORY[0x277CD5208]);
        clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
        v22 = [v20 initWithDevice:v19 endpointID:&unk_283EE7F68 queue:clientQueue];

        v23 = objc_alloc_init(MEMORY[0x277CD5468]);
        v24 = [MEMORY[0x277CBEB28] dataWithCapacity:32];
        v25 = 8;
        do
        {
          *buf = arc4random();
          [v24 appendBytes:buf length:4];
          --v25;
        }

        while (v25);
        [v23 setCsrNonce:v24];
        v26 = objc_autoreleasePoolPush();
        v27 = selfCopy;
        v28 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          v29 = v39 = v26;
          *buf = 138543362;
          v43 = v29;
          _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_INFO, "%{public}@Sending CSRRequest", buf, 0xCu);

          v26 = v39;
        }

        objc_autoreleasePoolPop(v26);
        v40[0] = MEMORY[0x277D85DD0];
        v40[1] = 3221225472;
        v40[2] = __144__HMMTRAccessoryServer_SystemCommissionerPairing___handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_error___block_invoke;
        v40[3] = &unk_2786EDC30;
        v40[4] = v27;
        v41 = groupCopy;
        [v22 CSRRequestWithParams:v23 completion:v40];
      }

      else
      {
        v34 = objc_autoreleasePoolPush();
        v35 = selfCopy;
        v36 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          v37 = HMFGetLogIdentifier();
          *buf = 138543362;
          v43 = v37;
          _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v34);
        dispatch_group_leave(groupCopy);
        v22 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
        v23 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:14 error:v22];
        [(HMMTRAccessoryServer *)v35 _handlePairingFailureWithError:v22 context:v23];
      }
    }

    else
    {
      v30 = objc_autoreleasePoolPush();
      v31 = selfCopy;
      v32 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v33 = HMFGetLogIdentifier();
        *buf = 138543362;
        v43 = v33;
        _os_log_impl(&dword_22AEAE000, v32, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v30);
      dispatch_group_leave(groupCopy);
      v19 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      v22 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:14 error:v19];
      [(HMMTRAccessoryServer *)v31 _handlePairingFailureWithError:v19 context:v22];
    }
  }

  v38 = *MEMORY[0x277D85DE8];
}

- (void)_pairOnSystemCommissionerFabric
{
  v48 = *MEMORY[0x277D85DE8];
  [(HMMTRAccessoryServer *)self _handlePairOnSystemCommissionerFabricStart];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:13];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v45 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Pairing with system commissioner fabric after successful Apple Home pairing", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  [(HMMTRAccessoryServer *)selfCopy setBlockInvalidation:1];
  v7 = random();
  v8 = objc_autoreleasePoolPush();
  v9 = selfCopy;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543618;
    v45 = v11;
    v46 = 2048;
    v47 = v7;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) queued.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v8);
  v12 = objc_autoreleasePoolPush();
  v13 = v9;
  v14 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    v15 = HMFGetLogIdentifier();
    *buf = 138543618;
    v45 = v15;
    v46 = 2048;
    v47 = v7;
    _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v12);
  v16 = dispatch_group_create();
  dispatch_group_enter(v16);
  deviceController = [(HMMTRAccessoryServer *)v13 deviceController];
  if (deviceController)
  {
    v18 = MEMORY[0x277CD5220];
    nodeID = [(HMMTRAccessoryServer *)v13 nodeID];
    v20 = [v18 deviceWithNodeID:nodeID controller:deviceController];

    if (v20)
    {
      v40 = v7;
      [(HMMTRAccessoryServer *)v13 _notifyDelegateOfPairingStep:14];
      v21 = objc_alloc(MEMORY[0x277CD51F8]);
      clientQueue = [(HAPAccessoryServer *)v13 clientQueue];
      v23 = [v21 initWithDevice:v20 endpointID:&unk_283EE7F68 queue:clientQueue];

      v24 = objc_alloc_init(MEMORY[0x277CD5418]);
      [v24 setExpiryLengthSeconds:&unk_283EE7F80];
      [v24 setBreadcrumb:&unk_283EE7F68];
      v25 = objc_autoreleasePoolPush();
      v26 = v13;
      v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        v28 = HMFGetLogIdentifier();
        *buf = 138543362;
        v45 = v28;
        _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_INFO, "%{public}@Arming fail safe", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v25);
      v42[0] = MEMORY[0x277D85DD0];
      v42[1] = 3221225472;
      v42[2] = __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke;
      v42[3] = &unk_2786EDC08;
      v42[4] = v26;
      v43 = v16;
      [v23 armFailSafeWithParams:v24 completion:v42];

      v7 = v40;
    }

    else
    {
      v34 = objc_autoreleasePoolPush();
      v35 = v13;
      v36 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        v37 = HMFGetLogIdentifier();
        *buf = 138543362;
        v45 = v37;
        _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v34);
      dispatch_group_leave(v16);
      v23 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
      v24 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:13 error:v23];
      [(HMMTRAccessoryServer *)v35 _handlePairingFailureWithError:v23 context:v24];
    }

    clientQueue2 = [(HAPAccessoryServer *)v13 clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke_13;
    block[3] = &unk_2786EF620;
    block[4] = v13;
    block[5] = v7;
    dispatch_group_notify(v16, clientQueue2, block);
  }

  else
  {
    v29 = objc_autoreleasePoolPush();
    v30 = v13;
    v31 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v32 = HMFGetLogIdentifier();
      *buf = 138543362;
      v45 = v32;
      _os_log_impl(&dword_22AEAE000, v31, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to commission with system commissioner fabric", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v29);
    dispatch_group_leave(v16);
    v20 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
    v33 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:13 error:v20];
    [(HMMTRAccessoryServer *)v30 _handlePairingFailureWithError:v20 context:v33];
  }

  v39 = *MEMORY[0x277D85DE8];
}

uint64_t __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke_13(uint64_t a1)
{
  v13 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v9 = 138543618;
    v10 = v5;
    v11 = 2048;
    v12 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) completed.", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  result = [*(a1 + 32) setBlockInvalidation:0];
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

- (void)_pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:(id)key
{
  keyCopy = key;
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:10];
  v6[0] = MEMORY[0x277D85DD0];
  v6[1] = 3221225472;
  v6[2] = __119__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey___block_invoke;
  v6[3] = &unk_2786EFCE0;
  v6[4] = self;
  v7 = keyCopy;
  v5 = keyCopy;
  [(HMMTRAccessoryServer *)self fetchPairingsWithCompletionHandler:v6];
}

void __119__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  v43 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = v9;
  if (v7)
  {
    v33 = v9;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v11 = v7;
    v12 = [v11 countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v12)
    {
      v13 = v12;
      v14 = *v35;
      while (2)
      {
        for (i = 0; i != v13; ++i)
        {
          if (*v35 != v14)
          {
            objc_enumerationMutation(v11);
          }

          v16 = *(*(&v34 + 1) + 8 * i);
          v17 = [v16 rootPublicKey];
          v18 = [v17 isEqual:*(a1 + 40)];

          if (v18)
          {
            v19 = objc_autoreleasePoolPush();
            v20 = *(a1 + 32);
            v21 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
            {
              v22 = HMFGetLogIdentifier();
              v23 = [v16 nodeID];
              *buf = 138543618;
              v40 = v22;
              v41 = 2112;
              v42 = v23;
              _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@Accessory is already paired to system commissioner fabric with node ID %@. Completing Apple Home pairing.", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v19);
            v24 = [*(a1 + 32) browser];
            v25 = [v24 storageForSystemCommissioner];

            v26 = [v16 nodeID];
            v27 = [v25 uuidForSystemCommissionerFabricNode:v26];
            [*(a1 + 32) setCommissioningID:v27];

            if ((isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
            {
              [*(a1 + 32) setOperationDisabled:1];
              [*(a1 + 32) setOperationDisabledReason:1];
            }

            [*(a1 + 32) _handlePairOnSystemCommissionerFabricSuccess];

            goto LABEL_16;
          }
        }

        v13 = [v11 countByEnumeratingWithState:&v34 objects:v38 count:16];
        if (v13)
        {
          continue;
        }

        break;
      }
    }

    [*(a1 + 32) _pairOnSystemCommissionerFabric];
LABEL_16:
    v10 = v33;
  }

  else
  {
    v28 = objc_autoreleasePoolPush();
    v29 = *(a1 + 32);
    v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = HMFGetLogIdentifier();
      *buf = 138543618;
      v40 = v31;
      v41 = 2112;
      v42 = v8;
      _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch pairings from newly paired accessory: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v28);
    [*(a1 + 32) _handlePairingFailureWithError:v8 context:v10];
  }

  v32 = *MEMORY[0x277D85DE8];
}

- (HMMTRAccessoryServerDiagnosticsEventDelegate)diagnosticsEventDelegate
{
  WeakRetained = objc_loadWeakRetained(&self->_diagnosticsEventDelegate);

  return WeakRetained;
}

- (HMMTRAccessoryServerBrowser)browser
{
  WeakRetained = objc_loadWeakRetained(&self->_browser);

  return WeakRetained;
}

- (HMMTRReportObserver)hmdHAPAccessoryDelegate
{
  WeakRetained = objc_loadWeakRetained(&self->_hmdHAPAccessoryDelegate);

  return WeakRetained;
}

- (HMMTRAccessoryServerDelegate)chipDelegate
{
  WeakRetained = objc_loadWeakRetained(&self->_chipDelegate);

  return WeakRetained;
}

- (unint64_t)hash
{
  identifier = [(HAPAccessoryServer *)self identifier];
  v4 = [identifier hash];

  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  v6 = [nodeID hash];

  return v6 ^ v4;
}

- (BOOL)isEqual:(id)equal
{
  equalCopy = equal;
  v5 = equalCopy;
  if (!equalCopy)
  {
    goto LABEL_6;
  }

  if (self == equalCopy)
  {
    v12 = 1;
    goto LABEL_10;
  }

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v6 = v5;
    identifier = [(HAPAccessoryServer *)v6 identifier];
    identifier2 = [(HAPAccessoryServer *)self identifier];
    v9 = [identifier isEqual:identifier2];

    if (v9)
    {
      nodeID = [(HMMTRAccessoryServer *)v6 nodeID];
      nodeID2 = [(HMMTRAccessoryServer *)self nodeID];
      v12 = [nodeID isEqual:nodeID2];
    }

    else
    {
      v12 = 0;
    }
  }

  else
  {
LABEL_6:
    v12 = 0;
  }

LABEL_10:

  return v12;
}

- (id)attributeDescriptions
{
  v44[12] = *MEMORY[0x277D85DE8];
  v3 = objc_alloc(MEMORY[0x277D0F778]);
  name = [(HAPAccessoryServer *)self name];
  v42 = [v3 initWithName:@"Name" value:name];
  v44[0] = v42;
  v4 = objc_alloc(MEMORY[0x277D0F778]);
  identifier = [(HAPAccessoryServer *)self identifier];
  v40 = [v4 initWithName:@"Identifier" value:identifier];
  v44[1] = v40;
  v5 = objc_alloc(MEMORY[0x277D0F778]);
  v6 = MEMORY[0x277CCABB0];
  rootPublicKey = [(HMMTRAccessoryServer *)self rootPublicKey];
  v38 = [v6 numberWithUnsignedInteger:{objc_msgSend(rootPublicKey, "hash")}];
  v37 = [v5 initWithName:@"Root Public Key Hash" value:v38];
  v44[2] = v37;
  v7 = objc_alloc(MEMORY[0x277D0F778]);
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  v35 = [v7 initWithName:@"NodeID" value:nodeID];
  v44[3] = v35;
  v8 = objc_alloc(MEMORY[0x277D0F778]);
  fabricID = [(HMMTRAccessoryServer *)self fabricID];
  v33 = [v8 initWithName:@"FabricID" value:fabricID];
  v44[4] = v33;
  v9 = objc_alloc(MEMORY[0x277D0F778]);
  category = [(HAPAccessoryServer *)self category];
  v31 = [v9 initWithName:@"Category" value:category];
  v44[5] = v31;
  v10 = objc_alloc(MEMORY[0x277D0F778]);
  vendorID = [(HMMTRAccessoryServer *)self vendorID];
  v29 = [v10 initWithName:@"VID" value:vendorID];
  v44[6] = v29;
  v11 = objc_alloc(MEMORY[0x277D0F778]);
  productID = [(HMMTRAccessoryServer *)self productID];
  v13 = [v11 initWithName:@"PID" value:productID];
  v44[7] = v13;
  v14 = objc_alloc(MEMORY[0x277D0F778]);
  objectID = [(HMMTRAccessoryServer *)self objectID];
  v16 = [v14 initWithName:@"ObjID" value:objectID];
  v44[8] = v16;
  v17 = objc_alloc(MEMORY[0x277D0F778]);
  fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
  v19 = [v17 initWithName:@"FabricUUID" value:fabricUUID];
  v44[9] = v19;
  v20 = objc_alloc(MEMORY[0x277D0F778]);
  [(HMMTRAccessoryServer *)self knownToSystemCommissioner];
  v21 = HMFBooleanToString();
  v22 = [v20 initWithName:@"SystemCommissioner" value:v21];
  v44[10] = v22;
  v23 = objc_alloc(MEMORY[0x277D0F778]);
  controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
  v25 = [v23 initWithName:@"Controller" value:controllerWrapper];
  v44[11] = v25;
  v28 = [MEMORY[0x277CBEA60] arrayWithObjects:v44 count:12];

  v26 = *MEMORY[0x277D85DE8];

  return v28;
}

- (id)privateDescription
{
  v3 = MEMORY[0x277CCACA8];
  shortDescription = [objc_opt_class() shortDescription];
  identifier = [(HAPAccessoryServer *)self identifier];
  v6 = [v3 stringWithFormat:@"%@ %@", shortDescription, identifier];

  return v6;
}

- (id)logIdentifier
{
  v3 = MEMORY[0x277CCACA8];
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  fabricID = [(HMMTRAccessoryServer *)self fabricID];
  objectID = [(HMMTRAccessoryServer *)self objectID];
  v7 = [v3 stringWithFormat:@"%@/%@(%@)", nodeID, fabricID, objectID];

  return v7;
}

- (void)dispatchAfter:(unint64_t)after block:(id)block
{
  blockCopy = block;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  dispatch_after(after, clientQueue, blockCopy);
}

- (void)notifyDelegateOfUnauthenticatedAccessoryPromptEnded
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v11 = 138543362;
    v12 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of unauthenticated accessory prompt end", &v11, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v8 = delegate;
  }

  else
  {
    v8 = 0;
  }

  v9 = v8;

  [v9 notifyUnauthenticatedMatterAccessoryPromptEnded];
  v10 = *MEMORY[0x277D85DE8];
}

- (void)notifyDelegateOfUnauthenticatedAccessoryPromptStarted
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v11 = 138543362;
    v12 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of unauthenticated accessory prompt start", &v11, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v8 = delegate;
  }

  else
  {
    v8 = 0;
  }

  v9 = v8;

  [v9 notifyUnauthenticatedMatterAccessoryPromptStarted];
  v10 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfMatterAccessoryIsWEDAccessory:(id)accessory
{
  v18 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    [accessoryCopy BOOLValue];
    v9 = HMFBooleanToString();
    v14 = 138543618;
    v15 = v8;
    v16 = 2112;
    v17 = v9;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of isWEDAccessory %@", &v14, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v11 = delegate;
  }

  else
  {
    v11 = 0;
  }

  v12 = v11;

  [v12 notifyMatterAccessoryIsWEDAccessory:accessoryCopy];
  v13 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfMatterAccessoryThreadCapabilities:(id)capabilities
{
  v17 = *MEMORY[0x277D85DE8];
  capabilitiesCopy = capabilities;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v13 = 138543618;
    v14 = v8;
    v15 = 2112;
    v16 = capabilitiesCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of Thread capabilities %@", &v13, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v10 = delegate;
  }

  else
  {
    v10 = 0;
  }

  v11 = v10;

  [v11 notifyMatterAccessoryThreadCapabilities:capabilitiesCopy];
  v12 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfMatterAccessoryVendorID:(id)d productID:(id)iD deviceType:(id)type
{
  v27 = *MEMORY[0x277D85DE8];
  dCopy = d;
  iDCopy = iD;
  typeCopy = type;
  v11 = objc_autoreleasePoolPush();
  selfCopy = self;
  v13 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v14 = HMFGetLogIdentifier();
    v19 = 138544130;
    v20 = v14;
    v21 = 2112;
    v22 = dCopy;
    v23 = 2112;
    v24 = iDCopy;
    v25 = 2112;
    v26 = typeCopy;
    _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of accessory vendor ID %@, product ID %@, device type %@", &v19, 0x2Au);
  }

  objc_autoreleasePoolPop(v11);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v16 = delegate;
  }

  else
  {
    v16 = 0;
  }

  v17 = v16;

  [v17 notifyMatterAccessoryVendorID:dCopy productID:iDCopy deviceType:typeCopy];
  v18 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfMTRMetrics:(id)metrics
{
  v17 = *MEMORY[0x277D85DE8];
  metricsCopy = metrics;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v13 = 138543618;
    v14 = v8;
    v15 = 2048;
    v16 = metricsCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of mtr metrics %p", &v13, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v10 = delegate;
  }

  else
  {
    v10 = 0;
  }

  v11 = v10;

  [v11 notifyMTRMetrics:metricsCopy];
  v12 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfAccessoryMatchingCommissioningDiscriminatorDiscovered
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v11 = 138543362;
    v12 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Notifying matter accessory matching commissioning discriminator discovered", &v11, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v8 = delegate;
  }

  else
  {
    v8 = 0;
  }

  v9 = v8;

  [v9 notifyMatterAccessoryMatchingCommissioningDiscriminatorDiscovered];
  v10 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfSupportedLinkLayerTypes:(id)types
{
  v17 = *MEMORY[0x277D85DE8];
  typesCopy = types;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v13 = 138543618;
    v14 = v8;
    v15 = 2112;
    v16 = typesCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying supported link layer types: %@", &v13, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v10 = delegate;
  }

  else
  {
    v10 = 0;
  }

  v11 = v10;

  [v11 notifySupportedLinkLayerTypes:typesCopy];
  v12 = *MEMORY[0x277D85DE8];
}

- (void)_notifyDelegateOfPairingStep:(unint64_t)step
{
  v18 = *MEMORY[0x277D85DE8];
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v9 = HMMTRAccessoryPairingStepAsString(step);
    v14 = 138543618;
    v15 = v8;
    v16 = 2112;
    v17 = v9;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying matter metric pairing step %@", &v14, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  if ([delegate conformsToProtocol:&unk_283F236B0])
  {
    v11 = delegate;
  }

  else
  {
    v11 = 0;
  }

  v12 = v11;

  [v12 notifyMatterAccessoryPairingStep:step];
  v13 = *MEMORY[0x277D85DE8];
}

- (void)deviceConfigurationChanged:(id)changed
{
  v31 = *MEMORY[0x277D85DE8];
  changedCopy = changed;
  if (![(HMMTRAccessoryServer *)self isDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v26 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@MTRDevice configuration changed", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    if (![(HMMTRAccessoryServer *)selfCopy isPaired]|| [(HMMTRAccessoryServer *)selfCopy isKnownToSystemCommissioner])
    {
      v9 = objc_autoreleasePoolPush();
      v10 = selfCopy;
      v11 = HMFGetOSLogHandle();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
LABEL_11:

        objc_autoreleasePoolPop(v9);
        goto LABEL_12;
      }

      v12 = HMFGetLogIdentifier();
      isPaired = [(HMMTRAccessoryServer *)v10 isPaired];
      v14 = "is not paired yet";
      if (isPaired)
      {
        v14 = "is for system commissioner";
      }

      *buf = 138543618;
      v26 = v12;
      v27 = 2080;
      v28 = v14;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@No enumeration because server %s", buf, 0x16u);
LABEL_10:

      goto LABEL_11;
    }

    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __51__HMMTRAccessoryServer_deviceConfigurationChanged___block_invoke;
    v24[3] = &unk_2786EF290;
    v24[4] = selfCopy;
    [(HMMTRAccessoryServer *)selfCopy enumerateHAPServices:v24];
    if (HAPIsInternalBuild())
    {
      browser = [(HMMTRAccessoryServer *)selfCopy browser];
      if (([browser isCurrentDevicePrimaryResident] & 1) == 0)
      {

        goto LABEL_12;
      }

      stateCaptureConfigChangeTimer = [(HMMTRAccessoryServer *)selfCopy stateCaptureConfigChangeTimer];

      if (!stateCaptureConfigChangeTimer)
      {
        v18 = [objc_alloc(MEMORY[0x277D0F920]) initWithTimeInterval:0 options:600.0];
        [(HMMTRAccessoryServer *)selfCopy setStateCaptureConfigChangeTimer:v18];

        clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
        stateCaptureConfigChangeTimer2 = [(HMMTRAccessoryServer *)selfCopy stateCaptureConfigChangeTimer];
        [stateCaptureConfigChangeTimer2 setDelegateQueue:clientQueue];

        stateCaptureConfigChangeTimer3 = [(HMMTRAccessoryServer *)selfCopy stateCaptureConfigChangeTimer];
        [stateCaptureConfigChangeTimer3 setDelegate:selfCopy];

        stateCaptureConfigChangeTimer4 = [(HMMTRAccessoryServer *)selfCopy stateCaptureConfigChangeTimer];
        [stateCaptureConfigChangeTimer4 resume];

        v9 = objc_autoreleasePoolPush();
        v10 = selfCopy;
        v11 = HMFGetOSLogHandle();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          goto LABEL_11;
        }

        v12 = HMFGetLogIdentifier();
        name = [(HAPAccessoryServer *)v10 name];
        *buf = 138543874;
        v26 = v12;
        v27 = 2112;
        v28 = name;
        v29 = 2112;
        v30 = &unk_283EE8CE8;
        _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration: Setting timer to capture state information due to configuration change for accessory %@, timeout is %@", buf, 0x20u);

        goto LABEL_10;
      }
    }
  }

LABEL_12:

  v15 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer_deviceConfigurationChanged___block_invoke(uint64_t a1, void *a2)
{
  v11 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543362;
    v10 = v7;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Enumeration per configuration change complete", &v9, 0xCu);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *MEMORY[0x277D85DE8];
}

- (void)deviceCachePrimed:(id)primed
{
  v17 = *MEMORY[0x277D85DE8];
  primedCopy = primed;
  if (![(HMMTRAccessoryServer *)self isDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      v15 = 138543362;
      v16 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@MTRDevice cache primed", &v15, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    reportDistributor = [(HMMTRAccessoryServer *)selfCopy reportDistributor];
    [reportDistributor allAttributesReady];

    if (![(HMMTRAccessoryServer *)selfCopy serviceEnumerationInProgress]&& [(HMMTRAccessoryServer *)selfCopy fullServiceEnumerationPendingCachePrimedEvent])
    {
      v10 = objc_autoreleasePoolPush();
      v11 = selfCopy;
      v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        v13 = HMFGetLogIdentifier();
        v15 = 138543362;
        v16 = v13;
        _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, "%{public}@Triggering service enumeration upon cache primed event", &v15, 0xCu);
      }

      objc_autoreleasePoolPop(v10);
      [(HMMTRAccessoryServer *)v11 setFullServiceEnumerationPendingCachePrimedEvent:0];
      [(HMMTRAccessoryServer *)v11 _rebuildHAPServicesFromCHIPWithCompletionHandler:0];
    }
  }

  v14 = *MEMORY[0x277D85DE8];
}

- (NSHashTable)reportObservers
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = [(NSHashTable *)self->_reportObservers copy];
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (void)removeReportObserver:(id)observer
{
  observerCopy = observer;
  v4 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  [(NSHashTable *)self->_reportObservers removeObject:observerCopy];
  os_unfair_lock_unlock((self + v4));
}

- (void)addReportObserver:(id)observer
{
  v15 = *MEMORY[0x277D85DE8];
  observerCopy = observer;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v11 = 138543618;
    v12 = v8;
    v13 = 2112;
    v14 = observerCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Registering %@ to receive attribute and event reports", &v11, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  v9 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  [(NSHashTable *)selfCopy->_reportObservers addObject:observerCopy];
  os_unfair_lock_unlock((selfCopy + v9));

  v10 = *MEMORY[0x277D85DE8];
}

- (BOOL)_legacyHMDHAPAccessoryDelegateShouldHandleEvent:(id)event
{
  v3 = [event objectForKeyedSubscript:*MEMORY[0x277CD5130]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v4 = v3;
  }

  else
  {
    v4 = 0;
  }

  v5 = v4;

  v6 = [v5 isEqual:MEMORY[0x277CBEC38]];
  return v6 ^ 1;
}

- (BOOL)_isAllowedForRawEventDictionaryHandling:(id)handling
{
  handlingCopy = handling;
  cluster = [handlingCopy cluster];
  unsignedIntValue = [cluster unsignedIntValue];
  if (unsignedIntValue == 513)
  {
    event = [handlingCopy event];
    if ([event unsignedIntValue] == 323551232)
    {
      v7 = 1;
LABEL_8:

      goto LABEL_9;
    }
  }

  cluster2 = [handlingCopy cluster];
  if ([cluster2 unsignedIntValue] == 323615749)
  {
    event2 = [handlingCopy event];
    v7 = [event2 unsignedIntValue] == 1;
  }

  else
  {
    v7 = 0;
  }

  if (unsignedIntValue == 513)
  {
    goto LABEL_8;
  }

LABEL_9:

  return v7;
}

- (void)_handleEventReport:(id)report
{
  v69 = *MEMORY[0x277D85DE8];
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  obj = report;
  v48 = [obj countByEnumeratingWithState:&v57 objects:v68 count:16];
  if (v48)
  {
    v47 = *v58;
    v46 = *MEMORY[0x277CD5140];
    *&v4 = 138543618;
    v43 = v4;
    selfCopy = self;
    do
    {
      for (i = 0; i != v48; ++i)
      {
        if (*v58 != v47)
        {
          objc_enumerationMutation(obj);
        }

        v6 = *(*(&v57 + 1) + 8 * i);
        v7 = objc_alloc(MEMORY[0x277CD5410]);
        v56 = 0;
        v8 = [v7 initWithResponseValue:v6 error:&v56];
        v9 = v56;
        v10 = [v6 objectForKeyedSubscript:v46];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v11 = v10;
        }

        else
        {
          v11 = 0;
        }

        v12 = v11;

        endpoint = [v12 endpoint];
        v14 = [(HMMTRAccessoryServer *)self _hapAccessoryAtEndpoint:endpoint];

        if ([(HMMTRAccessoryServer *)self _isAllowedForRawEventDictionaryHandling:v12]&& [(HMMTRAccessoryServer *)self _legacyHMDHAPAccessoryDelegateShouldHandleEvent:v6])
        {
          v49 = v9;
          v15 = objc_autoreleasePoolPush();
          selfCopy2 = self;
          v17 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
          {
            v18 = HMFGetLogIdentifier();
            *buf = v43;
            v63 = v18;
            v64 = 2112;
            v65 = v6;
            _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Handling custom event: %@", buf, 0x16u);
          }

          v50 = v12;

          objc_autoreleasePoolPop(v15);
          internalOnlyInitializer = [MEMORY[0x277D0F7B8] internalOnlyInitializer];
          v20 = objc_autoreleasePoolPush();
          v21 = selfCopy2;
          v22 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            v23 = HMFGetLogIdentifier();
            uUID = [internalOnlyInitializer UUID];
            *buf = 138543874;
            v63 = v23;
            v64 = 2112;
            v65 = uUID;
            v66 = 2112;
            v67 = v6;
            _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@[NewFlow: %@ {Feature:Event Reports}] HMMTRAccessoryServer Handling custom event report=%@", buf, 0x20u);

            self = selfCopy;
          }

          objc_autoreleasePoolPop(v20);
          hmdHAPAccessoryDelegate = [(HMMTRAccessoryServer *)v21 hmdHAPAccessoryDelegate];
          [hmdHAPAccessoryDelegate handleRawEventReportDictionary:v6 flow:internalOnlyInitializer hapAccessory:v14];

LABEL_29:
          v9 = v49;
          v12 = v50;
          goto LABEL_33;
        }

        if (v8)
        {
          v49 = v9;
          v50 = v12;
          internalOnlyInitializer2 = [MEMORY[0x277D0F7B8] internalOnlyInitializer];
          v27 = objc_autoreleasePoolPush();
          selfCopy3 = self;
          v29 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
          {
            v30 = HMFGetLogIdentifier();
            uUID2 = [internalOnlyInitializer2 UUID];
            *buf = 138543874;
            v63 = v30;
            v64 = 2112;
            v65 = uUID2;
            v66 = 2112;
            v67 = v8;
            _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@[NewFlow: %@ {Feature:Event Reports}] HMMTRAccessoryServer Handling parsed event report=%@", buf, 0x20u);
          }

          objc_autoreleasePoolPop(v27);
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          reportObservers = [(HMMTRAccessoryServer *)selfCopy3 reportObservers];
          v33 = [reportObservers countByEnumeratingWithState:&v52 objects:v61 count:16];
          if (v33)
          {
            v34 = v33;
            v35 = *v53;
            do
            {
              for (j = 0; j != v34; ++j)
              {
                if (*v53 != v35)
                {
                  objc_enumerationMutation(reportObservers);
                }

                [*(*(&v52 + 1) + 8 * j) handleEventReport:v8 dictionary:v6 flow:internalOnlyInitializer2 hapAccessory:{v14, v43}];
              }

              v34 = [reportObservers countByEnumeratingWithState:&v52 objects:v61 count:16];
            }

            while (v34);
          }

          if ([(HMMTRAccessoryServer *)selfCopy3 _legacyHMDHAPAccessoryDelegateShouldHandleEvent:v6])
          {
            hmdHAPAccessoryDelegate2 = [(HMMTRAccessoryServer *)selfCopy3 hmdHAPAccessoryDelegate];
            [hmdHAPAccessoryDelegate2 handleEventReport:v8 dictionary:v6 flow:internalOnlyInitializer2 hapAccessory:v14];
          }

          self = selfCopy;
          goto LABEL_29;
        }

        v38 = objc_autoreleasePoolPush();
        selfCopy4 = self;
        v40 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          v41 = v51 = v12;
          *buf = 138543874;
          v63 = v41;
          v64 = 2112;
          v65 = v6;
          v66 = 2112;
          v67 = v9;
          _os_log_impl(&dword_22AEAE000, v40, OS_LOG_TYPE_INFO, "%{public}@Received event %@ is not parsed: %@", buf, 0x20u);

          v12 = v51;
        }

        objc_autoreleasePoolPop(v38);
LABEL_33:
      }

      v48 = [obj countByEnumeratingWithState:&v57 objects:v68 count:16];
    }

    while (v48);
  }

  v42 = *MEMORY[0x277D85DE8];
}

- (void)device:(id)device receivedEventReport:(id)report
{
  v57 = *MEMORY[0x277D85DE8];
  deviceCopy = device;
  reportCopy = report;
  if (![(HMMTRAccessoryServer *)self isDisabled])
  {
    selfCopy = self;
    group = dispatch_group_create();
    v44[0] = 0;
    v44[1] = v44;
    v44[2] = 0x3032000000;
    v44[3] = __Block_byref_object_copy__10189;
    v44[4] = __Block_byref_object_dispose__10190;
    v45 = objc_alloc_init(MEMORY[0x277CBEB18]);
    v40 = 0u;
    v41 = 0u;
    v42 = 0u;
    v43 = 0u;
    obj = reportCopy;
    v7 = [obj countByEnumeratingWithState:&v40 objects:v56 count:16];
    if (v7)
    {
      v28 = *v41;
      v27 = *MEMORY[0x277CD5140];
      v25 = *MEMORY[0x277CD50D8];
      v24 = reportCopy;
      do
      {
        v30 = v7;
        for (i = 0; i != v30; ++i)
        {
          if (*v41 != v28)
          {
            objc_enumerationMutation(obj);
          }

          v9 = *(*(&v40 + 1) + 8 * i);
          v10 = [v9 objectForKeyedSubscript:v27];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v11 = v10;
          }

          else
          {
            v11 = 0;
          }

          v12 = v11;

          dispatch_group_enter(group);
          context = objc_autoreleasePoolPush();
          v13 = selfCopy;
          v14 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            v15 = HMFGetLogIdentifier();
            endpoint = [v12 endpoint];
            cluster = [v12 cluster];
            event = [v12 event];
            v19 = [v9 objectForKeyedSubscript:v25];
            *buf = 138544386;
            v47 = v15;
            v48 = 2112;
            v49 = endpoint;
            v50 = 2112;
            v51 = cluster;
            v52 = 2112;
            v53 = event;
            v54 = 2112;
            v55 = v19;
            _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Handling Event Report: endpoint:%@ cluster:%@ event:%@ value:%@", buf, 0x34u);

            reportCopy = v24;
          }

          objc_autoreleasePoolPop(context);
          v36[0] = MEMORY[0x277D85DD0];
          v36[1] = 3221225472;
          v36[2] = __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke;
          v36[3] = &unk_2786F0440;
          v36[4] = v13;
          v20 = v12;
          v37 = v20;
          v39 = v44;
          v38 = group;
          [(HMMTRAccessoryServer *)v13 _updatedCharacteristicsForEventReport:v9 completionHandler:v36];
          [(HMMTRAccessoryServer *)v13 _handleDiagnosticsEvent:v9];
        }

        v7 = [obj countByEnumeratingWithState:&v40 objects:v56 count:16];
      }

      while (v7);
    }

    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke_977;
    block[3] = &unk_2786F0468;
    block[4] = selfCopy;
    v35 = v44;
    v34 = obj;
    dispatch_group_notify(group, clientQueue, block);

    _Block_object_dispose(v44, 8);
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (![v3 count])
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v7 = HMFGetLogIdentifier();
      v8 = [*(a1 + 40) endpoint];
      v9 = [*(a1 + 40) cluster];
      v11 = 138543874;
      v12 = v7;
      v13 = 2112;
      v14 = v8;
      v15 = 2112;
      v16 = v9;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for event report: endpoint:%@ cluster:%@", &v11, 0x20u);
    }

    objc_autoreleasePoolPop(v4);
  }

  [*(*(*(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(a1 + 48));

  v10 = *MEMORY[0x277D85DE8];
}

uint64_t __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke_977(uint64_t a1)
{
  v17 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v7 = *(*(*(a1 + 48) + 8) + 40);
    v11 = 138543874;
    v12 = v5;
    v13 = 2112;
    v14 = v7;
    v15 = 2112;
    v16 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Calling didUpdateValuesForCharacteristics for %@ from handling reports %@", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v2);
  v8 = [*(a1 + 32) delegate];
  [v8 accessoryServer:*(a1 + 32) didUpdateValuesForCharacteristics:*(*(*(a1 + 48) + 8) + 40) stateNumber:0 broadcast:0];

  result = [*(a1 + 32) _handleEventReport:*(a1 + 40)];
  v10 = *MEMORY[0x277D85DE8];
  return result;
}

- (void)processAttributeReport:(id)report
{
  v60 = *MEMORY[0x277D85DE8];
  reportCopy = report;
  group = dispatch_group_create();
  v50[0] = 0;
  v50[1] = v50;
  v50[2] = 0x3032000000;
  v50[3] = __Block_byref_object_copy__10189;
  v50[4] = __Block_byref_object_dispose__10190;
  v51 = objc_alloc_init(MEMORY[0x277CBEB18]);
  dispatch_group_enter(group);
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543618;
    v55 = v8;
    v56 = 2112;
    v57 = reportCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Processing Attribute Report: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  v49 = 0;
  v9 = [objc_alloc(MEMORY[0x277CD51C8]) initWithResponseValue:reportCopy error:&v49];
  v10 = v49;
  v11 = MEMORY[0x277CD50B8];
  if (!v9)
  {
    context = objc_autoreleasePoolPush();
    v12 = selfCopy;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = v10;
      v15 = HMFGetLogIdentifier();
      v16 = [reportCopy objectForKeyedSubscript:*v11];
      *buf = 138543874;
      v55 = v15;
      v56 = 2112;
      v57 = v16;
      v58 = 2112;
      v59 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Attribute report %@ is not parsed into a known struct: %@", buf, 0x20u);

      v10 = v14;
    }

    objc_autoreleasePoolPop(context);
  }

  v17 = [reportCopy objectForKeyedSubscript:*v11];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v18 = v17;
  }

  else
  {
    v18 = 0;
  }

  v19 = v18;

  endpoint = [v19 endpoint];
  v21 = [(HMMTRAccessoryServer *)selfCopy _hapAccessoryAtEndpoint:endpoint];

  v47 = 0u;
  v48 = 0u;
  v46 = 0u;
  v45 = 0u;
  reportObservers = [(HMMTRAccessoryServer *)selfCopy reportObservers];
  v23 = [reportObservers countByEnumeratingWithState:&v45 objects:v53 count:16];
  if (v23)
  {
    v24 = *v46;
    do
    {
      v25 = 0;
      do
      {
        if (*v46 != v24)
        {
          objc_enumerationMutation(reportObservers);
        }

        [*(*(&v45 + 1) + 8 * v25++) handleAttributeReport:v9 dictionary:reportCopy hapAccessory:v21];
      }

      while (v23 != v25);
      v23 = [reportObservers countByEnumeratingWithState:&v45 objects:v53 count:16];
    }

    while (v23);
  }

  hmdHAPAccessoryDelegate = [(HMMTRAccessoryServer *)selfCopy hmdHAPAccessoryDelegate];
  [hmdHAPAccessoryDelegate handleAttributeReport:v9 dictionary:reportCopy hapAccessory:v21];

  v40[0] = MEMORY[0x277D85DD0];
  v40[1] = 3221225472;
  v40[2] = __47__HMMTRAccessoryServer_processAttributeReport___block_invoke;
  v40[3] = &unk_2786F0440;
  v27 = reportCopy;
  v41 = v27;
  v42 = selfCopy;
  v44 = v50;
  v28 = group;
  v43 = v28;
  [(HMMTRAccessoryServer *)selfCopy _updatedCharacteristicsForAttributeReport:v27 completionHandler:v40];
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __47__HMMTRAccessoryServer_processAttributeReport___block_invoke_976;
  block[3] = &unk_2786F0468;
  v39 = v50;
  block[4] = selfCopy;
  v30 = v27;
  v38 = v30;
  dispatch_group_notify(v28, clientQueue, block);

  v52 = v30;
  v31 = [MEMORY[0x277CBEA60] arrayWithObjects:&v52 count:1];
  chipReportHandler = [(HMMTRAccessoryServer *)selfCopy chipReportHandler];
  if (chipReportHandler)
  {
    encodedCHIPReports = [v31 encodedCHIPReports];
    (chipReportHandler)[2](chipReportHandler, encodedCHIPReports);
  }

  _Block_object_dispose(v50, 8);
  v34 = *MEMORY[0x277D85DE8];
}

void __47__HMMTRAccessoryServer_processAttributeReport___block_invoke(uint64_t a1, void *a2)
{
  v18 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (![v3 count])
  {
    v4 = [*(a1 + 32) objectForKeyedSubscript:*MEMORY[0x277CD50B8]];
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 40);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = HMFGetLogIdentifier();
      v9 = [v4 endpoint];
      v10 = [v4 cluster];
      v12 = 138543874;
      v13 = v8;
      v14 = 2112;
      v15 = v9;
      v16 = 2112;
      v17 = v10;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for attribute report: endpoint:%@ cluster:%@", &v12, 0x20u);
    }

    objc_autoreleasePoolPop(v5);
  }

  [*(*(*(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(a1 + 48));

  v11 = *MEMORY[0x277D85DE8];
}

void __47__HMMTRAccessoryServer_processAttributeReport___block_invoke_976(uint64_t a1)
{
  v16 = *MEMORY[0x277D85DE8];
  if (([*(*(*(a1 + 48) + 8) + 40) hmf_isEmpty] & 1) == 0)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 40);
      v7 = *(*(*(a1 + 48) + 8) + 40);
      v10 = 138543874;
      v11 = v5;
      v12 = 2112;
      v13 = v7;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Calling didUpdateValuesForCharacteristics for %@ from processing report %@", &v10, 0x20u);
    }

    objc_autoreleasePoolPop(v2);
    v8 = [*(a1 + 32) delegate];
    [v8 accessoryServer:*(a1 + 32) didUpdateValuesForCharacteristics:*(*(*(a1 + 48) + 8) + 40) stateNumber:0 broadcast:0];
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)device:(id)device receivedAttributeReport:(id)report
{
  v91 = *MEMORY[0x277D85DE8];
  deviceCopy = device;
  reportCopy = report;
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    goto LABEL_48;
  }

  selfCopy = self;
  v56 = reportCopy;
  group = dispatch_group_create();
  v81[0] = 0;
  v81[1] = v81;
  v81[2] = 0x3032000000;
  v81[3] = __Block_byref_object_copy__10189;
  v81[4] = __Block_byref_object_dispose__10190;
  v82 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v80 = 0u;
  obj = reportCopy;
  v7 = [obj countByEnumeratingWithState:&v77 objects:v90 count:16];
  if (!v7)
  {
    goto LABEL_45;
  }

  v60 = *v78;
  v63 = *MEMORY[0x277CD50B8];
  v59 = *MEMORY[0x277CD50D8];
  do
  {
    v62 = v7;
    for (i = 0; i != v62; ++i)
    {
      if (*v78 != v60)
      {
        objc_enumerationMutation(obj);
      }

      v9 = *(*(&v77 + 1) + 8 * i);
      dispatch_group_enter(group);
      v10 = objc_autoreleasePoolPush();
      v11 = selfCopy;
      v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v13 = HMFGetLogIdentifier();
        *buf = 138543618;
        v85 = v13;
        v86 = 2112;
        v87 = v9;
        _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Handling Attribute Report: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v10);
      v14 = [v9 objectForKeyedSubscript:v63];
      if (v14)
      {
        v15 = [v9 objectForKeyedSubscript:v59];
        v16 = v15 == 0;

        if (!v16)
        {
          reportDistributor = [(HMMTRAccessoryServer *)v11 reportDistributor];
          [reportDistributor distributeAttributeReport:v9];

          v18 = objc_alloc(MEMORY[0x277CD51C8]);
          v76 = 0;
          v19 = [v18 initWithResponseValue:v9 error:&v76];
          v20 = v76;
          if (!v19)
          {
            v21 = objc_autoreleasePoolPush();
            v22 = v11;
            v23 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              v24 = HMFGetLogIdentifier();
              v25 = [v9 objectForKeyedSubscript:v63];
              *buf = 138543874;
              v85 = v24;
              v86 = 2112;
              v87 = v25;
              v88 = 2112;
              v89 = v20;
              _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_DEBUG, "%{public}@Attribute report %@ is not parsed into a known struct: %@", buf, 0x20u);
            }

            objc_autoreleasePoolPop(v21);
          }

          v26 = [v9 objectForKeyedSubscript:v63];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v27 = v26;
          }

          else
          {
            v27 = 0;
          }

          v64 = v27;

          cluster = [v64 cluster];
          if ([cluster isEqualToNumber:&unk_283EE8D48])
          {
            attribute = [v64 attribute];
            v30 = [attribute isEqualToNumber:&unk_283EE8D60];

            if (v30)
            {
              [(HMMTRAccessoryServer *)v11 _updateAttributeTimer:v64 report:v9 timeout:v11 server:1.5];
              v31 = objc_autoreleasePoolPush();
              v32 = v11;
              v33 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
              {
                v34 = HMFGetLogIdentifier();
                *buf = 138543618;
                v85 = v34;
                v86 = 2112;
                v87 = v9;
                _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_DEBUG, "%{public}@Skip handling of report: %@", buf, 0x16u);
              }

              objc_autoreleasePoolPop(v31);
              dispatch_group_leave(group);
              goto LABEL_42;
            }
          }

          else
          {
          }

          endpoint = [v64 endpoint];
          v40 = [(HMMTRAccessoryServer *)v11 _hapAccessoryAtEndpoint:endpoint];

          v74 = 0u;
          v75 = 0u;
          v73 = 0u;
          v72 = 0u;
          reportObservers = [(HMMTRAccessoryServer *)v11 reportObservers];
          v42 = [reportObservers countByEnumeratingWithState:&v72 objects:v83 count:16];
          v43 = v20;
          if (v42)
          {
            v44 = *v73;
            do
            {
              for (j = 0; j != v42; ++j)
              {
                if (*v73 != v44)
                {
                  objc_enumerationMutation(reportObservers);
                }

                [*(*(&v72 + 1) + 8 * j) handleAttributeReport:v19 dictionary:v9 hapAccessory:v40];
              }

              v42 = [reportObservers countByEnumeratingWithState:&v72 objects:v83 count:16];
            }

            while (v42);
          }

          v20 = v43;
          hmdHAPAccessoryDelegate = [(HMMTRAccessoryServer *)v11 hmdHAPAccessoryDelegate];
          [hmdHAPAccessoryDelegate handleAttributeReport:v19 dictionary:v9 hapAccessory:v40];

          if ([(HMMTRAccessoryServer *)v11 _handleUnmappedAttributeReport:v9])
          {
LABEL_39:
            dispatch_group_leave(group);
          }

          else
          {
            if ([(HMMTRAccessoryServer *)v11 _ignoreAttributeReport:v9])
            {
              v47 = objc_autoreleasePoolPush();
              v48 = v11;
              v49 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
              {
                v50 = HMFGetLogIdentifier();
                *buf = 138543618;
                v85 = v50;
                v86 = 2112;
                v87 = v9;
                _os_log_impl(&dword_22AEAE000, v49, OS_LOG_TYPE_INFO, "%{public}@Ignoring report: %@", buf, 0x16u);
              }

              objc_autoreleasePoolPop(v47);
              goto LABEL_39;
            }

            v69[0] = MEMORY[0x277D85DD0];
            v69[1] = 3221225472;
            v69[2] = __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke;
            v69[3] = &unk_2786F0440;
            v69[4] = v9;
            v69[5] = v11;
            v71 = v81;
            v70 = group;
            [(HMMTRAccessoryServer *)v11 _updatedCharacteristicsForAttributeReport:v9 completionHandler:v69];
          }

LABEL_42:
          continue;
        }
      }

      v35 = objc_autoreleasePoolPush();
      v36 = v11;
      v37 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        v38 = HMFGetLogIdentifier();
        *buf = 138543618;
        v85 = v38;
        v86 = 2112;
        v87 = v9;
        _os_log_impl(&dword_22AEAE000, v37, OS_LOG_TYPE_DEBUG, "%{public}@Malformed attribute report. Ignoring report: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v35);
      dispatch_group_leave(group);
    }

    v7 = [obj countByEnumeratingWithState:&v77 objects:v90 count:16];
  }

  while (v7);
LABEL_45:

  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke_975;
  block[3] = &unk_2786F0468;
  v68 = v81;
  block[4] = selfCopy;
  v52 = obj;
  v67 = v52;
  dispatch_group_notify(group, clientQueue, block);

  chipReportHandler = [(HMMTRAccessoryServer *)selfCopy chipReportHandler];
  if (chipReportHandler)
  {
    encodedCHIPReports = [v52 encodedCHIPReports];
    (chipReportHandler)[2](chipReportHandler, encodedCHIPReports);
  }

  _Block_object_dispose(v81, 8);
  reportCopy = v56;
LABEL_48:

  v55 = *MEMORY[0x277D85DE8];
}

void __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke(uint64_t a1, void *a2)
{
  v21 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (![v3 count])
  {
    v4 = [*(a1 + 32) objectForKeyedSubscript:*MEMORY[0x277CD50B8]];
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 40);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = HMFGetLogIdentifier();
      v9 = [v4 endpoint];
      v10 = [v4 cluster];
      v11 = [v4 attribute];
      v13 = 138544130;
      v14 = v8;
      v15 = 2112;
      v16 = v9;
      v17 = 2112;
      v18 = v10;
      v19 = 2112;
      v20 = v11;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for attribute report: endpoint:%@ cluster:%@ attribute:%@", &v13, 0x2Au);
    }

    objc_autoreleasePoolPop(v5);
  }

  [*(*(*(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(a1 + 48));

  v12 = *MEMORY[0x277D85DE8];
}

void __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke_975(uint64_t a1)
{
  v16 = *MEMORY[0x277D85DE8];
  if (([*(*(*(a1 + 48) + 8) + 40) hmf_isEmpty] & 1) == 0)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 40);
      v7 = *(*(*(a1 + 48) + 8) + 40);
      v10 = 138543874;
      v11 = v5;
      v12 = 2112;
      v13 = v7;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Calling didUpdateValuesForCharacteristics for %@ from handling reports %@", &v10, 0x20u);
    }

    objc_autoreleasePoolPop(v2);
    v8 = [*(a1 + 32) delegate];
    [v8 accessoryServer:*(a1 + 32) didUpdateValuesForCharacteristics:*(*(*(a1 + 48) + 8) + 40) stateNumber:0 broadcast:0];
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (BOOL)_ignoreAttributeReport:(id)report
{
  v3 = *MEMORY[0x277CD50B8];
  reportCopy = report;
  v5 = [reportCopy objectForKeyedSubscript:v3];
  v6 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:reportCopy];

  cluster = [v5 cluster];
  if ([cluster isEqualToNumber:&unk_283EE8A78])
  {
    attribute = [v5 attribute];
    v9 = [attribute isEqualToNumber:&unk_283EE89B8];

    if (v9)
    {
      v10 = v6 == 0;
    }

    else
    {
      v10 = 0;
    }

    if (v10)
    {
      goto LABEL_21;
    }
  }

  else
  {
  }

  cluster2 = [v5 cluster];
  if ([cluster2 isEqualToNumber:&unk_283EE8D00])
  {
    attribute2 = [v5 attribute];
    v13 = [attribute2 isEqualToNumber:&unk_283EE89B8];

    if (v13)
    {
      v14 = v6 == 0;
    }

    else
    {
      v14 = 0;
    }

    if (v14)
    {
      goto LABEL_21;
    }
  }

  else
  {
  }

  cluster3 = [v5 cluster];
  if (([cluster3 isEqualToNumber:&unk_283EE8D18] & 1) == 0)
  {

LABEL_23:
    v18 = 0;
    goto LABEL_24;
  }

  attribute3 = [v5 attribute];
  v17 = [attribute3 isEqualToNumber:&unk_283EE8AD8];

  if (!v17 || !v6 || ([v6 isEqualToNumber:&unk_283EE8D30] & 1) == 0)
  {
    goto LABEL_23;
  }

LABEL_21:
  v18 = 1;
LABEL_24:

  return v18;
}

- (void)_updateDelegateOfConnectionStatus:(BOOL)status withError:(id)error
{
  errorCopy = error;
  if ([(HMMTRAccessoryServer *)self _delegateRespondsToSelector:sel_accessoryServer_didUpdateConnectionState_linkLayerType_withError_])
  {
    delegateQueue = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer__updateDelegateOfConnectionStatus_withError___block_invoke;
    block[3] = &unk_2786F0418;
    statusCopy = status;
    block[4] = self;
    v9 = errorCopy;
    dispatch_async(delegateQueue, block);
  }
}

void __68__HMMTRAccessoryServer__updateDelegateOfConnectionStatus_withError___block_invoke(uint64_t a1)
{
  if (*(a1 + 48) == 1)
  {
    v2 = [*(a1 + 32) linkLayerType];
    v3 = [*(a1 + 32) primaryAccessory];
    [v3 setLinkLayerType:v2];

    v4 = *(a1 + 32);
    v5 = [v4 primaryAccessory];
    v6 = [v4 getSupportedLinkLayerTypesForAccessory:v5];
    [v4 _setSupportedLinkLayerTypes:v6];
  }

  else
  {
    v2 = 0;
  }

  v7 = [*(a1 + 32) delegate];
  [v7 accessoryServer:*(a1 + 32) didUpdateConnectionState:*(a1 + 48) linkLayerType:v2 withError:*(a1 + 40)];
}

- (void)_deviceInternalStateChanged:(id)changed
{
  v26 = *MEMORY[0x277D85DE8];
  changedCopy = changed;
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice == changedCopy && [(HMMTRAccessoryServer *)self isReadyToReadFromMTRDevice])
  {
    pendingMTRDeviceReadReadyHandlers = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
    allValues = [pendingMTRDeviceReadReadyHandlers allValues];

    pendingMTRDeviceReadReadyHandlers2 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
    [pendingMTRDeviceReadReadyHandlers2 removeAllObjects];

    if (([allValues hmf_isEmpty] & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      selfCopy = self;
      v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        v12 = HMFGetLogIdentifier();
        *buf = 138543362;
        v25 = v12;
        _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@MTRDevice is ready to read from. Triggering pending MTRDevice read-ready handlers", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v9);
    }

    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v13 = allValues;
    v14 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v14)
    {
      v15 = v14;
      v16 = *v20;
      do
      {
        v17 = 0;
        do
        {
          if (*v20 != v16)
          {
            objc_enumerationMutation(v13);
          }

          (*(*(*(&v19 + 1) + 8 * v17) + 16))(*(*(&v19 + 1) + 8 * v17));
          ++v17;
        }

        while (v15 != v17);
        v15 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }

      while (v15);
    }
  }

  v18 = *MEMORY[0x277D85DE8];
}

- (BOOL)isReadyToReadFromMTRDevice
{
  if (!isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    return 1;
  }

  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];
  v4 = objc_opt_respondsToSelector();

  if ((v4 & 1) == 0)
  {
    return 1;
  }

  matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
  _deviceHasActiveSubscription = [matterDevice2 _deviceHasActiveSubscription];

  return _deviceHasActiveSubscription;
}

- (void)device:(id)device stateChanged:(unint64_t)changed
{
  v44 = *MEMORY[0x277D85DE8];
  deviceCopy = device;
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    goto LABEL_30;
  }

  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice != deviceCopy)
  {
    goto LABEL_30;
  }

  [(HMMTRAccessoryServer *)self setMtrDeviceStateReported:1];
  if (!changed)
  {
    browser2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:19 description:@"MTRDevice state changed to MTRDeviceStateUnknown" reason:0 suggestion:0 underlyingError:0];
    v22 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v23 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v24 = HMFGetLogIdentifier();
      *buf = 138543362;
      v39 = v24;
      _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_ERROR, "%{public}@Matter device state unknown", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v22);
    goto LABEL_19;
  }

  if (changed == 2)
  {
    v17 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      v39 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@Matter device unreachable & disconnected", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    browser2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:19 description:@"MTRDevice state changed to MTRDeviceStateUnreachable" reason:0 suggestion:0 underlyingError:0];
LABEL_19:
    [(HMMTRAccessoryServer *)selfCopy2 _handleUnreachableStateWithError:browser2];
    goto LABEL_20;
  }

  if (changed != 1)
  {
    [(HMMTRAccessoryServer *)self setMtrDeviceStateReported:0];
    goto LABEL_30;
  }

  v8 = objc_autoreleasePoolPush();
  selfCopy3 = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543362;
    v39 = v11;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Matter device reachable & connected", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  [(HMMTRAccessoryServer *)selfCopy3 didUpdateReachability:1];
  [(HMMTRAccessoryServer *)selfCopy3 setMtrDeviceConnected:1];
  if (![(HMMTRAccessoryServer *)selfCopy3 serviceEnumerationFailed])
  {
    [(HMMTRAccessoryServer *)selfCopy3 _updateDelegateOfConnectionStatus:1 withError:0];
  }

  [(HMMTRAccessoryServer *)selfCopy3 markAsSubscribed];
  browser = [(HMMTRAccessoryServer *)selfCopy3 browser];
  isCurrentDevicePrimaryResident = [browser isCurrentDevicePrimaryResident];

  if (isCurrentDevicePrimaryResident)
  {
    v37[0] = MEMORY[0x277D85DD0];
    v37[1] = 3221225472;
    v37[2] = __44__HMMTRAccessoryServer_device_stateChanged___block_invoke;
    v37[3] = &unk_2786EF290;
    v37[4] = selfCopy3;
    v14 = MEMORY[0x2318887D0](v37);
    if ([(HMMTRAccessoryServer *)selfCopy3 fullServiceEnumerationPendingCachePrimedEvent])
    {
      serviceEnumerationFromDeviceCompletionHandlers = [(HMMTRAccessoryServer *)selfCopy3 serviceEnumerationFromDeviceCompletionHandlers];
      v16 = MEMORY[0x2318887D0](v14);
      [serviceEnumerationFromDeviceCompletionHandlers addObject:v16];
    }

    else
    {
      [(HMMTRAccessoryServer *)selfCopy3 _rebuildHAPServicesFromCHIPWithCompletionHandler:v14];
    }
  }

  if (HAPIsInternalBuild())
  {
    browser2 = [(HMMTRAccessoryServer *)selfCopy3 browser];
    if ([browser2 isCurrentDevicePrimaryResident])
    {
      stateCaptureDeviceConnectedTimer = [(HMMTRAccessoryServer *)selfCopy3 stateCaptureDeviceConnectedTimer];

      if (!stateCaptureDeviceConnectedTimer)
      {
        v26 = [objc_alloc(MEMORY[0x277D0F920]) initWithTimeInterval:0 options:600.0];
        [(HMMTRAccessoryServer *)selfCopy3 setStateCaptureDeviceConnectedTimer:v26];

        clientQueue = [(HAPAccessoryServer *)selfCopy3 clientQueue];
        stateCaptureDeviceConnectedTimer2 = [(HMMTRAccessoryServer *)selfCopy3 stateCaptureDeviceConnectedTimer];
        [stateCaptureDeviceConnectedTimer2 setDelegateQueue:clientQueue];

        stateCaptureDeviceConnectedTimer3 = [(HMMTRAccessoryServer *)selfCopy3 stateCaptureDeviceConnectedTimer];
        [stateCaptureDeviceConnectedTimer3 setDelegate:selfCopy3];

        stateCaptureDeviceConnectedTimer4 = [(HMMTRAccessoryServer *)selfCopy3 stateCaptureDeviceConnectedTimer];
        [stateCaptureDeviceConnectedTimer4 resume];

        v31 = objc_autoreleasePoolPush();
        v32 = selfCopy3;
        v33 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          v34 = HMFGetLogIdentifier();
          name = [(HAPAccessoryServer *)v32 name];
          *buf = 138543874;
          v39 = v34;
          v40 = 2112;
          v41 = name;
          v42 = 2112;
          v43 = &unk_283EE8CE8;
          _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration: Setting timer to capture state information for %@ due to matter device reachable notification, timeout is %@", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v31);
      }

      goto LABEL_30;
    }

LABEL_20:
  }

LABEL_30:

  v36 = *MEMORY[0x277D85DE8];
}

void __44__HMMTRAccessoryServer_device_stateChanged___block_invoke(uint64_t a1, void *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v15 = 138543618;
    v16 = v7;
    v17 = 2112;
    v18 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Enumeration per reachable device complete: %@", &v15, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  if (!v3)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      v12 = [*(a1 + 32) clusterIDCharacteristicMap];
      v15 = 138543618;
      v16 = v11;
      v17 = 2112;
      v18 = v12;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@clusterIDCharacteristicMap : %@", &v15, 0x16u);
    }

    objc_autoreleasePoolPop(v8);
  }

  v13 = [*(a1 + 32) browser];
  [v13 notifyDiscoveredAccessoryServer:*(a1 + 32)];

  v14 = *MEMORY[0x277D85DE8];
}

- (void)_deregisterStateCaptureHandlers
{
  [(HMMTRAccessoryServer *)self _deregisterPartsListStateCaptureHandler];

  [(HMMTRAccessoryServer *)self _deregisterDeviceConnectedStateCaptureHandler];
}

- (void)_deregisterDeviceConnectedStateCaptureHandler
{
  if ([(HMMTRAccessoryServer *)self deviceConnectedStateHandle])
  {
    [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlerWithHandle:[(HMMTRAccessoryServer *)self deviceConnectedStateHandle]];

    [(HMMTRAccessoryServer *)self setDeviceConnectedStateHandle:0];
  }
}

- (void)_deregisterPartsListStateCaptureHandler
{
  if ([(HMMTRAccessoryServer *)self partsListStateCaptureHandle])
  {
    [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlerWithHandle:[(HMMTRAccessoryServer *)self partsListStateCaptureHandle]];

    [(HMMTRAccessoryServer *)self setPartsListStateCaptureHandle:0];
  }
}

- (unint64_t)_registerStateCaptureHandlerWithStateCaptureInformation:(id)information
{
  informationCopy = information;
  if (HAPIsInternalBuild())
  {
    objc_initWeak(&location, self);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    objc_copyWeak(&v9, &location);
    v8 = informationCopy;
    v6 = os_state_add_handler();

    objc_destroyWeak(&v9);
    objc_destroyWeak(&location);
  }

  else
  {
    v6 = 0;
  }

  return v6;
}

uint64_t __80__HMMTRAccessoryServer__registerStateCaptureHandlerWithStateCaptureInformation___block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 16) != 3)
  {
    return 0;
  }

  WeakRetained = objc_loadWeakRetained((a1 + 40));
  if (WeakRetained)
  {
    v4 = [objc_alloc(MEMORY[0x277D0F880]) initWithName:@"os-state-HMMTRAccessoryServer"];
    v5 = [WeakRetained dumpState:*(a1 + 32)];
    v6 = MEMORY[0x277CCACA8];
    v7 = [WeakRetained nodeID];
    v8 = [WeakRetained fabricID];
    v9 = [WeakRetained objectID];
    v10 = [v6 stringWithFormat:@"Accessory Configuration for %@/%@(%@)", v7, v8, v9];

    v11 = [WeakRetained createStateData:v10 data:v5];
  }

  else
  {
    v11 = 0;
  }

  return v11;
}

- (os_state_data_s)createStateData:(id)data data:(id)a4
{
  dataCopy = data;
  v6 = [MEMORY[0x277CCAC58] dataWithPropertyList:a4 format:200 options:0 error:0];
  v7 = v6;
  if (v6)
  {
    v8 = [v6 length];
    v9 = malloc_type_calloc(1uLL, v8 + 200, 0x1000040BEF03554uLL);
    v9->var0 = 1;
    v9->var1.var1 = v8;
    [dataCopy UTF8String];
    __strlcpy_chk();
    memcpy(v9->var4, [v7 bytes], v8);
  }

  else
  {
    v9 = 0;
  }

  return v9;
}

- (id)dumpState:(id)state
{
  stateCopy = state;
  v4 = [MEMORY[0x277CBEB38] dictionaryWithCapacity:12];
  v5 = v4;
  if (stateCopy)
  {
    v6 = stateCopy;
  }

  else
  {
    v6 = 0;
  }

  [v4 setObject:v6 forKeyedSubscript:*MEMORY[0x277D0F170]];

  return v5;
}

- (void)_fetchAdditionalThreadNetworkInformationFromDevice:(id)device completion:(id)completion
{
  deviceCopy = device;
  completionCopy = completion;
  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    v8 = dispatch_group_create();
    dispatch_group_enter(v8);
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke;
    v16[3] = &unk_2786EFD08;
    v16[4] = self;
    v9 = v8;
    v17 = v9;
    [(HMMTRAccessoryServer *)self fetchWEDSupportInformationFromDevice:deviceCopy completion:v16];
    dispatch_group_enter(v9);
    v14[0] = MEMORY[0x277D85DD0];
    v14[1] = 3221225472;
    v14[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_942;
    v14[3] = &unk_2786EFD08;
    v14[4] = self;
    v15 = v9;
    v10 = v9;
    [(HMMTRAccessoryServer *)self fetchExtendedMACAddressFromDevice:deviceCopy completion:v14];
    delegateQueue = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_943;
    block[3] = &unk_2786EF878;
    v13 = completionCopy;
    dispatch_group_notify(v10, delegateQueue, block);
  }

  else
  {
    (*(completionCopy + 2))(completionCopy, 0);
  }
}

void __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v16 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version string of CHIP Accessory with error %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  dispatch_group_leave(*(a1 + 40));

  v11 = *MEMORY[0x277D85DE8];
}

void __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_942(uint64_t a1, void *a2, void *a3)
{
  v16 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch eMAC address of CHIP Accessory with error %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  dispatch_group_leave(*(a1 + 40));

  v11 = *MEMORY[0x277D85DE8];
}

- (void)handleWEDDisconnectedWhileNotPairing
{
  v12 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v10 = 138543362;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@WED disconnected while not pairing", &v10, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  if (![(HMMTRAccessoryServer *)selfCopy servicesEnumerated]&& ![(HMMTRAccessoryServer *)selfCopy serviceEnumerationFailed])
  {
    [(HMMTRAccessoryServer *)selfCopy disable];
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    v8 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:15];
    [browser invalidateAccessoryServer:selfCopy reason:v8];
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)handleThreadNetworkStateChangedNotification:(id)notification
{
  v15 = *MEMORY[0x277D85DE8];
  notificationCopy = notification;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];

  if (clientQueue)
  {
    clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer_handleThreadNetworkStateChangedNotification___block_invoke;
    block[3] = &unk_2786F0CA8;
    block[4] = self;
    dispatch_async(clientQueue2, block);
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v14 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@handleThreadNetworkStateChangedNotification - clientQueue not available", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
  }

  v11 = *MEMORY[0x277D85DE8];
}

- (void)_handleThreadRadioStateChanged
{
  v51 = *MEMORY[0x277D85DE8];
  browser = [(HMMTRAccessoryServer *)self browser];
  threadRadioManager = [browser threadRadioManager];
  isReadyToEstablishWEDConnection = [threadRadioManager isReadyToEstablishWEDConnection];

  browser2 = [(HMMTRAccessoryServer *)self browser];
  connectionRequestSuspended = [browser2 connectionRequestSuspended];

  if ([(HMMTRAccessoryServer *)self pairedState]&& ![(HMMTRAccessoryServer *)self isDisabled])
  {
    v8 = ![(HMMTRAccessoryServer *)self removalInProgress];
  }

  else
  {
    LOBYTE(v8) = 0;
  }

  supportedLinkLayerTypes = [(HMMTRAccessoryServer *)self supportedLinkLayerTypes];
  unsignedIntValue = [supportedLinkLayerTypes unsignedIntValue];

  if (connectionRequestSuspended & 1 | ((v8 & 1) == 0) || (unsignedIntValue & 0x10) == 0)
  {
    v12 = objc_autoreleasePoolPush();
    selfCopy = self;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15 = HMFGetLogIdentifier();
      v16 = HMFBooleanToString();
      v17 = HMFBooleanToString();
      v18 = HMFBooleanToString();
      *buf = 138544130;
      v44 = v15;
      v45 = 2112;
      v46 = v16;
      v47 = 2112;
      v48 = v17;
      v49 = 2112;
      v50 = v18;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_DEBUG, "%{public}@_handleThreadRadioStateChanged: ignoring thread radio state change - isBrowserInPairingState = %@, isAccessoryServerValid = %@, isAccessoryServerThreadCapable = %@ ", buf, 0x2Au);
    }

    objc_autoreleasePoolPop(v12);
  }

  else
  {
    v11 = isReadyToEstablishWEDConnection && ![(HMMTRAccessoryServer *)self isWEDDevice];
    [(HMMTRAccessoryServer *)self setRequiresThreadRouter:v11];
    v19 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v22 = HMFGetLogIdentifier();
      [(HMMTRAccessoryServer *)selfCopy2 requiresThreadRouter];
      v23 = HMFBooleanToString();
      [(HMMTRAccessoryServer *)selfCopy2 isWEDDevice];
      v24 = HMFBooleanToString();
      v25 = HMFBooleanToString();
      *buf = 138544130;
      v44 = v22;
      v45 = 2112;
      v46 = v23;
      v47 = 2112;
      v48 = v24;
      v49 = 2112;
      v50 = v25;
      _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@_handleThreadRadioStateChanged - requiresThreadRouter = %@ (isWED = %@, isControllerInSleepyRouterState = %@)", buf, 0x2Au);
    }

    objc_autoreleasePoolPop(v19);
    chipDelegate = [(HMMTRAccessoryServer *)selfCopy2 chipDelegate];
    if (chipDelegate && (v27 = chipDelegate, [(HAPAccessoryServer *)selfCopy2 delegateQueue], v28 = objc_claimAutoreleasedReturnValue(), v28, v27, v28))
    {
      delegateQueue = [(HAPAccessoryServer *)selfCopy2 delegateQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __54__HMMTRAccessoryServer__handleThreadRadioStateChanged__block_invoke;
      block[3] = &unk_2786F0CA8;
      block[4] = selfCopy2;
      dispatch_async(delegateQueue, block);
    }

    else
    {
      v30 = objc_autoreleasePoolPush();
      v31 = selfCopy2;
      v32 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v33 = HMFGetLogIdentifier();
        *buf = 138543362;
        v44 = v33;
        _os_log_impl(&dword_22AEAE000, v32, OS_LOG_TYPE_ERROR, "%{public}@_handleThreadRadioStateChanged - chipDelegate not available", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v30);
    }

    browser3 = [(HMMTRAccessoryServer *)selfCopy2 browser];
    threadRadioManager2 = [browser3 threadRadioManager];
    v36 = [threadRadioManager2 isThreadNetworkConnected] | isReadyToEstablishWEDConnection;

    if ((v36 & 1) == 0)
    {
      v37 = objc_autoreleasePoolPush();
      v38 = selfCopy2;
      v39 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        v40 = HMFGetLogIdentifier();
        *buf = 138543362;
        v44 = v40;
        _os_log_impl(&dword_22AEAE000, v39, OS_LOG_TYPE_INFO, "%{public}@_handleThreadRadioStateChanged - thread went offline - marking accessory for resubscription", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v37);
      [(HMMTRAccessoryServer *)v38 markForResubscription];
    }
  }

  v41 = *MEMORY[0x277D85DE8];
}

void __54__HMMTRAccessoryServer__handleThreadRadioStateChanged__block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) chipDelegate];
  [v2 didUpdateRequiresThreadRouterForAccessoryServer:*(a1 + 32)];
}

- (void)handleThreadDirectConnectionSleepyTypeChange:(BOOL)change
{
  v26 = *MEMORY[0x277D85DE8];
  v4 = change && ![(HMMTRAccessoryServer *)self isWEDDevice];
  [(HMMTRAccessoryServer *)self setRequiresThreadRouter:v4];
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)selfCopy requiresThreadRouter];
    v9 = HMFBooleanToString();
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    [(HMMTRAccessoryServer *)selfCopy isWEDDevice];
    v11 = HMFBooleanToString();
    v12 = HMFBooleanToString();
    *buf = 138544386;
    v17 = v8;
    v18 = 2112;
    v19 = v9;
    v20 = 2112;
    v21 = nodeID;
    v22 = 2112;
    v23 = v11;
    v24 = 2112;
    v25 = v12;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@handleThreadDirectConnectionSleepyTypeChange - requiresThreadRouter = %@ for accessory with nodeID %@ (isWED = %@, isSleepyLink = %@)", buf, 0x34u);
  }

  objc_autoreleasePoolPop(v5);
  delegateQueue = [(HAPAccessoryServer *)selfCopy delegateQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_handleThreadDirectConnectionSleepyTypeChange___block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = selfCopy;
  dispatch_async(delegateQueue, block);

  v14 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_handleThreadDirectConnectionSleepyTypeChange___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) chipDelegate];
  [v2 didUpdateRequiresThreadRouterForAccessoryServer:*(a1 + 32)];
}

- (void)_fetchAdditionalThreadNetworkInformationWithCompletion:(id)completion
{
  completionCopy = completion;
  if (isFeatureMatterLocalFabricConfigEnabled() && self->_linkLayerType == 4)
  {
    deviceController = [(HMMTRAccessoryServer *)self deviceController];
    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    v8 = 0;
    v7 = [deviceController getDeviceBeingCommissioned:objc_msgSend(nodeID error:{"unsignedLongLongValue"), &v8}];

    if (v7)
    {
      [(HMMTRAccessoryServer *)self _fetchAdditionalThreadNetworkInformationFromDevice:v7 completion:completionCopy];
    }

    else
    {
      completionCopy[2](completionCopy, 0);
    }
  }

  else
  {
    completionCopy[2](completionCopy, 0);
  }
}

- (void)refreshThreadCapabilitiesWithCompletion:(id)completion
{
  v42 = *MEMORY[0x277D85DE8];
  completionCopy = completion;
  if (!isFeatureMatterLocalFabricConfigEnabled() || self->_linkLayerType != 4)
  {
    completionCopy[2](completionCopy, 0);
    goto LABEL_8;
  }

  if ([(HMMTRAccessoryServer *)self isWEDDevice])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
      *buf = 138543618;
      *&buf[4] = v8;
      *&buf[12] = 2112;
      *&buf[14] = nodeID;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory is already WED capable, will not try to refresh information for accessory with nodeID %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v5);
    completionCopy[2](completionCopy, 0);
    goto LABEL_8;
  }

  browser = [(HMMTRAccessoryServer *)self browser];
  storage = [browser storage];
  dataSource = [storage dataSource];
  fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
  v15 = [dataSource storageDataSourceForFabricUUID:fabricUUID];

  nodeID2 = [(HMMTRAccessoryServer *)self nodeID];
  v17 = [v15 storageDataSourceForDeviceWithNodeID:nodeID2];

  v32[0] = 0;
  v32[1] = v32;
  v32[2] = 0x2020000000;
  isWEDDevice = [(HMMTRAccessoryServer *)self isWEDDevice];
  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x3032000000;
  v39 = __Block_byref_object_copy__10189;
  v40 = __Block_byref_object_dispose__10190;
  eMACAddress = [(HMMTRAccessoryServer *)self eMACAddress];
  deviceController = [(HMMTRAccessoryServer *)self deviceController];
  if (!deviceController)
  {
    completionCopy[2](completionCopy, 0);
    goto LABEL_13;
  }

  nodeID3 = [(HMMTRAccessoryServer *)self nodeID];
  v20 = [(HMMTRAccessoryServer *)self mtrBaseDeviceWithNodeID:nodeID3 controller:deviceController];

  if (v20)
  {
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke;
    v27[3] = &unk_2786F03C8;
    v27[4] = self;
    v29 = completionCopy;
    v30 = v32;
    v28 = v17;
    v31 = buf;
    [(HMMTRAccessoryServer *)self _fetchAdditionalThreadNetworkInformationFromDevice:v20 completion:v27];

LABEL_13:
    _Block_object_dispose(buf, 8);

    _Block_object_dispose(v32, 8);
    goto LABEL_8;
  }

  v21 = objc_autoreleasePoolPush();
  selfCopy2 = self;
  v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    v24 = HMFGetLogIdentifier();
    nodeID4 = [(HMMTRAccessoryServer *)selfCopy2 nodeID];
    *v34 = 138543618;
    v35 = v24;
    v36 = 2112;
    v37 = nodeID4;
    _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_ERROR, "%{public}@Unable to get additional thread information from accessory after firmware update for nodeID %@ because of no device", v34, 0x16u);
  }

  objc_autoreleasePoolPop(v21);
  v26 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (completionCopy)[2](completionCopy, v26);

  _Block_object_dispose(buf, 8);
  _Block_object_dispose(v32, 8);

LABEL_8:
  v10 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke(uint64_t a1, void *a2)
{
  v43 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v9 = [*(a1 + 32) nodeID];
      *buf = 138543874;
      v34 = v8;
      v35 = 2112;
      v36 = v9;
      v37 = 2112;
      v38 = v3;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to refresh thread capabilities from accessory nodeID %@, error: %@", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v4);
    v10 = *(*(a1 + 48) + 16);
    goto LABEL_15;
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    v12 = [*(a1 + 32) nodeID];
    v13 = [*(a1 + 32) softwareVersionNumber];
    [*(a1 + 32) isWEDDevice];
    v14 = HMFBooleanToString();
    v15 = [*(a1 + 32) eMACAddress];
    *buf = 138544386;
    v34 = v11;
    v35 = 2112;
    v36 = v12;
    v37 = 2112;
    v38 = v13;
    v39 = 2112;
    v40 = v14;
    v41 = 2112;
    v42 = v15;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Refreshed thread capabilities for accessory with nodeID: %@, firmwareVersion = %@ WED: %@ eMAC: %@", buf, 0x34u);
  }

  objc_autoreleasePoolPop(v4);
  if (![*(a1 + 32) isWEDDevice] || (objc_msgSend(*(a1 + 32), "eMACAddress"), v16 = objc_claimAutoreleasedReturnValue(), v16, !v16))
  {
    v10 = *(*(a1 + 48) + 16);
LABEL_15:
    v10();
    goto LABEL_16;
  }

  v17 = dispatch_group_create();
  v18 = *(*(*(a1 + 56) + 8) + 24);
  if (v18 != [*(a1 + 32) isWEDDevice])
  {
    dispatch_group_enter(v17);
    v19 = *(a1 + 40);
    v20 = [*(a1 + 32) isWEDDevice];
    v31[0] = MEMORY[0x277D85DD0];
    v31[1] = 3221225472;
    v31[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_939;
    v31[3] = &unk_2786EF9E0;
    v31[4] = *(a1 + 32);
    v32 = v17;
    [v19 updateWedSupport:v20 completion:v31];
  }

  v21 = *(*(*(a1 + 64) + 8) + 40);
  v22 = [*(a1 + 32) eMACAddress];
  LOBYTE(v21) = HMFEqualObjects();

  if ((v21 & 1) == 0)
  {
    dispatch_group_enter(v17);
    v23 = *(a1 + 40);
    v24 = [*(a1 + 32) eMACAddress];
    v29[0] = MEMORY[0x277D85DD0];
    v29[1] = 3221225472;
    v29[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_940;
    v29[3] = &unk_2786EF9E0;
    v29[4] = *(a1 + 32);
    v30 = v17;
    [v23 updateExtendedMACAddress:v24 completion:v29];
  }

  v25 = [*(a1 + 32) delegateQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_941;
  block[3] = &unk_2786EF878;
  v28 = *(a1 + 48);
  dispatch_group_notify(v17, v25, block);

LABEL_16:
  v26 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_939(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543618;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to WED support version after firmware update error: %@", &v9, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  dispatch_group_leave(*(a1 + 40));

  v8 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_940(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543618;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to Wed support version after firmware update error: %@", &v9, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  dispatch_group_leave(*(a1 + 40));

  v8 = *MEMORY[0x277D85DE8];
}

- (void)_continueNetworkProvisioning
{
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:3];
  [(HMMTRAccessoryServer *)self _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameNetworkScan"];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:17];
  v3[0] = MEMORY[0x277D85DD0];
  v3[1] = 3221225472;
  v3[2] = __52__HMMTRAccessoryServer__continueNetworkProvisioning__block_invoke;
  v3[3] = &unk_2786F03A0;
  v3[4] = self;
  [(HMMTRAccessoryServer *)self _requestAccessoryNetworkScanWithCompletionHandler:v3];
}

void __52__HMMTRAccessoryServer__continueNetworkProvisioning__block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  v22 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = *(a1 + 32);
  if (!v7 || v8)
  {
    [v10 _notifyDelegateOfPairingProgress:19 error:v8];
    [*(a1 + 32) _pairingComplete:v8 context:v9];
  }

  else
  {
    [v10 _notifyDelegateOfPairingProgress:18];
    v11 = objc_autoreleasePoolPush();
    v12 = *(a1 + 32);
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      v18 = 138543618;
      v19 = v14;
      v20 = 2112;
      v21 = v7;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Scanned networks: %@", &v18, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v15 = [*(a1 + 32) stageWiFiScanResultsHandler];
    if (v15)
    {
    }

    else
    {
      v16 = [*(a1 + 32) stageThreadScanResultsHandler];

      if (!v16)
      {
        [*(a1 + 32) _collectNetworkCredentials:v7];
        goto LABEL_10;
      }
    }

    [*(a1 + 32) _onNetworkScanResults:v7];
  }

LABEL_10:

  v17 = *MEMORY[0x277D85DE8];
}

- (void)_controller:(id)_controller commissioningAndPairedNodeRecoveryComplete:(id)complete nodeID:(id)d abstractMetrics:(id)metrics
{
  v30 = *MEMORY[0x277D85DE8];
  _controllerCopy = _controller;
  completeCopy = complete;
  dCopy = d;
  metricsCopy = metrics;
  if (!completeCopy)
  {
    [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:28];
    [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:7];
    [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:33];
    deviceController = [(HMMTRAccessoryServer *)self deviceController];
    if (deviceController)
    {
      [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:34];
      [(HMMTRAccessoryServer *)self setCommissioningCompleted:1];
      [(HMMTRAccessoryServer *)self _pairingComplete:0 context:0];
      completeCopy = 0;
    }

    else
    {
      v22 = objc_autoreleasePoolPush();
      selfCopy = self;
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v25 = HMFGetLogIdentifier();
        v28 = 138543362;
        v29 = v25;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to handle commissioning completion", &v28, 0xCu);
      }

      objc_autoreleasePoolPop(v22);
      completeCopy = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingProgress:29 error:completeCopy];
      v26 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:7 error:completeCopy];
      [(HMMTRAccessoryServer *)selfCopy _pairingComplete:completeCopy context:v26];
    }

    goto LABEL_15;
  }

  if ([(HMMTRAccessoryServer *)self commissioningSessionEstablished])
  {
    commissioningFailureOverridingError = [(HMMTRAccessoryServer *)self commissioningFailureOverridingError];

    if (commissioningFailureOverridingError)
    {
      commissioningFailureOverridingError2 = [(HMMTRAccessoryServer *)self commissioningFailureOverridingError];

      completeCopy = commissioningFailureOverridingError2;
    }

    deviceController = [HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:completeCopy];
    [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:29 error:completeCopy];
    v17 = *MEMORY[0x277CFECD8];
    os_unfair_lock_lock_with_options();
    linkLayerType = self->_linkLayerType;
    os_unfair_lock_unlock((self + v17));
    if ([completeCopy code] == 9 && linkLayerType == 1)
    {
      v19 = MEMORY[0x277CCA9B8];
      localizedFailureReason = [completeCopy localizedFailureReason];
      v21 = [v19 hapErrorWithCode:25 description:@"WiFi Commissioning failed with error" reason:localizedFailureReason suggestion:0 underlyingError:completeCopy];

      completeCopy = v21;
    }

    [(HMMTRAccessoryServer *)self _pairingComplete:completeCopy context:deviceController];
LABEL_15:

    goto LABEL_16;
  }

  [(HMMTRAccessoryServer *)self _retryPairing];
LABEL_16:

  v27 = *MEMORY[0x277D85DE8];
}

- (void)_controller:(id)_controller commissioningComplete:(id)complete nodeID:(id)d abstractMetrics:(id)metrics
{
  v61 = *MEMORY[0x277D85DE8];
  _controllerCopy = _controller;
  completeCopy = complete;
  dCopy = d;
  metricsCopy = metrics;
  v14 = objc_autoreleasePoolPush();
  selfCopy = self;
  v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    v17 = HMFGetLogIdentifier();
    *buf = 138543618;
    *&buf[4] = v17;
    *&buf[12] = 2112;
    *&buf[14] = completeCopy;
    _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Accessory commissioning complete. %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v14);
  v18 = objc_autoreleasePoolPush();
  v19 = selfCopy;
  v20 = HMFGetOSLogHandle();
  v21 = os_log_type_enabled(v20, OS_LOG_TYPE_INFO);
  if (metricsCopy)
  {
    if (v21)
    {
      v22 = HMFGetLogIdentifier();
      *buf = 138543618;
      *&buf[4] = v22;
      *&buf[12] = 2112;
      *&buf[14] = @"com.apple.matter.pairing-event";
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Submitting Matter metric after commissioning complete: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v18);
    v23 = @"com.apple.matter.pairing-event";
    v24 = metricsCopy;
    if (submitMatterMetrics_onceToken != -1)
    {
      dispatch_once(&submitMatterMetrics_onceToken, &__block_literal_global_7541);
    }

    v25 = submitMatterMetrics_metricsQueue;
    *buf = MEMORY[0x277D85DD0];
    *&buf[8] = 3221225472;
    *&buf[16] = __submitMatterMetrics_block_invoke_2;
    v58 = &unk_2786EF328;
    v26 = v24;
    v59 = v26;
    v27 = @"com.apple.matter.pairing-event";
    v60 = @"com.apple.matter.pairing-event";
    dispatch_async(v25, buf);

    dictionary = dictionaryFromMatterMetrics(v26);
  }

  else
  {
    if (v21)
    {
      v29 = HMFGetLogIdentifier();
      *buf = 138543362;
      *&buf[4] = v29;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate with empty mtr metrics", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v18);
    dictionary = [MEMORY[0x277CBEAC0] dictionary];
  }

  v30 = dictionary;
  [(HMMTRAccessoryServer *)v19 _notifyDelegateOfMTRMetrics:dictionary];

  [(HMMTRAccessoryServer *)v19 setCommissionCompletePending:0];
  commissionMetricsReadyHandler = [(HMMTRAccessoryServer *)v19 commissionMetricsReadyHandler];
  [(HMMTRAccessoryServer *)v19 setCommissionMetricsReadyHandler:0];
  if (commissionMetricsReadyHandler)
  {
    commissionMetricsReadyHandler[2](commissionMetricsReadyHandler);
  }

  if ([(HMMTRAccessoryServer *)v19 isKnownToSystemCommissioner])
  {
    goto LABEL_21;
  }

  domain = [completeCopy domain];
  if (([domain isEqual:*MEMORY[0x277CD5120]] & 1) == 0)
  {

    goto LABEL_21;
  }

  code = [completeCopy code];

  if (code != 11)
  {
LABEL_21:
    [(HMMTRAccessoryServer *)v19 _controller:_controllerCopy commissioningAndPairedNodeRecoveryComplete:completeCopy nodeID:dCopy abstractMetrics:metricsCopy];
    goto LABEL_22;
  }

  v34 = objc_autoreleasePoolPush();
  v35 = v19;
  v36 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    v37 = HMFGetLogIdentifier();
    *buf = 138543362;
    *&buf[4] = v37;
    _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_INFO, "%{public}@Removing the conflicting fabric from the accessory", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v34);
  v38 = [HMMTRCommissioningSessionHandler alloc];
  clientQueue = [(HAPAccessoryServer *)v35 clientQueue];
  v51 = [(HMMTRCommissioningSessionHandler *)v38 initWithClientQueue:clientQueue];

  controllerWrapper = [(HMMTRAccessoryServer *)v35 controllerWrapper];
  startupParams = [controllerWrapper startupParams];
  _setupPayloadForLastCommissioning = [(HMMTRAccessoryServer *)v35 _setupPayloadForLastCommissioning];
  nodeID = [(HMMTRAccessoryServer *)v35 nodeID];
  browser = [(HMMTRAccessoryServer *)v35 browser];
  storage = [browser storage];
  dataSource = [storage dataSource];
  fabricUUID = [(HMMTRAccessoryServer *)v35 fabricUUID];
  v42 = [dataSource storageDataSourceForFabricUUID:fabricUUID];
  allNodeIDs = [v42 allNodeIDs];
  v52[0] = MEMORY[0x277D85DD0];
  v52[1] = 3221225472;
  v52[2] = __81__HMMTRAccessoryServer__controller_commissioningComplete_nodeID_abstractMetrics___block_invoke;
  v52[3] = &unk_2786F0378;
  v52[4] = v35;
  v53 = _controllerCopy;
  v54 = completeCopy;
  v55 = dCopy;
  v56 = metricsCopy;
  [(HMMTRCommissioningSessionHandler *)v51 establishSessionToRemoveFabricWithDeviceController:v53 forControllerParameters:startupParams setupPayload:_setupPayloadForLastCommissioning nodeID:nodeID allPairedNodeIDs:allNodeIDs completion:v52];

LABEL_22:
  v44 = *MEMORY[0x277D85DE8];
}

void __81__HMMTRAccessoryServer__controller_commissioningComplete_nodeID_abstractMetrics___block_invoke(uint64_t a1, void *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v17 = 138543362;
      v18 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Accessory conflicting fabric could not be removed. Failing the pairing", &v17, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [*(a1 + 32) _controller:*(a1 + 40) commissioningAndPairedNodeRecoveryComplete:*(a1 + 48) nodeID:*(a1 + 56) abstractMetrics:*(a1 + 64)];
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v17 = 138543362;
      v18 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Retrying commissioning after removing conflicting fabric", &v17, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [*(a1 + 32) setHasPriorSuccessfulPairing:1];
    v10 = objc_alloc_init(MEMORY[0x277CD5300]);
    v11 = [*(a1 + 32) browser];
    v12 = [v11 attestationStatus];
    [v12 populateDelegate:v10];

    v14 = *(a1 + 32);
    v13 = *(a1 + 40);
    v15 = [v14 clientQueue];
    [v13 setDeviceControllerDelegate:v14 queue:v15];

    [*(a1 + 32) _commissionWithParams:v10];
  }

  v16 = *MEMORY[0x277D85DE8];
}

- (void)controller:(id)controller readCommissioneeInfo:(id)info
{
  v30 = *MEMORY[0x277D85DE8];
  controllerCopy = controller;
  infoCopy = info;
  if ([(HMMTRAccessoryServer *)self isPairingInProgress])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Matter CommissioneeInfo has been read", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    [(HMMTRAccessoryServer *)selfCopy setCommissioneeInfo:infoCopy];
    delegateQueue = [(HAPAccessoryServer *)selfCopy delegateQueue];
    if (delegateQueue)
    {
      v13 = delegateQueue;
      delegate = [(HAPAccessoryServer *)selfCopy delegate];
      v15 = objc_opt_respondsToSelector();

      if (v15)
      {
        delegateQueue2 = [(HAPAccessoryServer *)selfCopy delegateQueue];
        v22 = MEMORY[0x277D85DD0];
        v23 = 3221225472;
        v24 = __56__HMMTRAccessoryServer_controller_readCommissioneeInfo___block_invoke;
        v25 = &unk_2786EF328;
        v26 = selfCopy;
        v27 = infoCopy;
        dispatch_async(delegateQueue2, &v22);
      }
    }

    if ([(HMMTRAccessoryServer *)selfCopy isKnownToSystemCommissioner:v22])
    {
      stageCompletion = [(HMMTRAccessoryServer *)selfCopy stageCompletion];
      if (stageCompletion)
      {
        v18 = stageCompletion;
        stageCommissioneeInfoHandler = [(HMMTRAccessoryServer *)selfCopy stageCommissioneeInfoHandler];

        if (stageCommissioneeInfoHandler)
        {
          stageCommissioneeInfoHandler2 = [(HMMTRAccessoryServer *)selfCopy stageCommissioneeInfoHandler];
          (stageCommissioneeInfoHandler2)[2](stageCommissioneeInfoHandler2, infoCopy);
        }
      }
    }
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __56__HMMTRAccessoryServer_controller_readCommissioneeInfo___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) delegate];
  [v2 accessoryServer:*(a1 + 32) didReadCommissioneeInfo:*(a1 + 40)];
}

- (void)controller:(id)controller commissioningSessionEstablishmentDone:(id)done
{
  v31 = *MEMORY[0x277D85DE8];
  controllerCopy = controller;
  doneCopy = done;
  if ([(HMMTRAccessoryServer *)self pairingProgress]!= 1)
  {
    v14 = objc_autoreleasePoolPush();
    selfCopy = self;
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      v27 = 138543362;
      v28 = v17;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Ignoring unexpected call to pairing complete", &v27, 0xCu);
    }

    v13 = v14;
    goto LABEL_9;
  }

  v8 = objc_autoreleasePoolPush();
  selfCopy2 = self;
  v10 = HMFGetOSLogHandle();
  v11 = v10;
  if (doneCopy)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v12 = HMFGetLogIdentifier();
      v27 = 138543618;
      v28 = v12;
      v29 = 2112;
      v30 = doneCopy;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed before network provisioning: %@", &v27, 0x16u);
    }

    v13 = v8;
LABEL_9:
    objc_autoreleasePoolPop(v13);
    goto LABEL_10;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v19 = HMFGetLogIdentifier();
    v27 = 138543362;
    v28 = v19;
    _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory ready for network provisioning", &v27, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  [(HMMTRAccessoryServer *)selfCopy2 setCommissioningSessionEstablished:1];
  if ([(HMMTRAccessoryServer *)selfCopy2 hasPriorSuccessfulPairing])
  {
    v20 = objc_autoreleasePoolPush();
    v21 = selfCopy2;
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      v27 = 138543362;
      v28 = v23;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@not reading thread network prerequisites", &v27, 0xCu);
    }

    objc_autoreleasePoolPop(v20);
    v24 = objc_alloc_init(MEMORY[0x277CD5300]);
    browser = [(HMMTRAccessoryServer *)v21 browser];
    attestationStatus = [browser attestationStatus];
    [attestationStatus populateDelegate:v24];

    [(HMMTRAccessoryServer *)v21 _commissionWithParams:v24];
  }

  else
  {
    [(HMMTRAccessoryServer *)selfCopy2 _continueNetworkProvisioning];
  }

LABEL_10:

  v18 = *MEMORY[0x277D85DE8];
}

- (void)_queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:(id)characteristic completion:(id)completion
{
  v66 = *MEMORY[0x277D85DE8];
  characteristicCopy = characteristic;
  completionCopy = completion;
  category = [(HAPAccessoryServer *)self category];
  if (([category isEqual:&unk_283EE8BF8] & 1) == 0)
  {

LABEL_17:
    completionCopy[2](completionCopy, 0);
    goto LABEL_18;
  }

  service = [characteristicCopy service];
  accessory = [service accessory];
  category2 = [accessory category];
  v12 = [category2 isEqual:&unk_283EE8BF8];

  if (v12)
  {
    goto LABEL_17;
  }

  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (!matterDevice)
  {
    goto LABEL_17;
  }

  v14 = [HMMTRHAPService chipPluginServiceForCharacteristic:characteristicCopy];
  v15 = v14;
  if (v14 && ([v14 endpoint], v16 = objc_claimAutoreleasedReturnValue(), v16, v16))
  {
    selfCopy = self;
    v48 = v15;
    v46 = characteristicCopy;
    service2 = [characteristicCopy service];
    accessory2 = [service2 accessory];

    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v49 = accessory2;
    services = [accessory2 services];
    v20 = [services countByEnumeratingWithState:&v53 objects:v65 count:16];
    if (v20)
    {
      v21 = v20;
      v22 = *v54;
      v23 = *MEMORY[0x277CFE810];
LABEL_8:
      v24 = 0;
      while (1)
      {
        if (*v54 != v22)
        {
          objc_enumerationMutation(services);
        }

        v25 = *(*(&v53 + 1) + 8 * v24);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          type = [v25 type];
          v27 = [type isEqualToString:v23];

          if (v27)
          {
            break;
          }
        }

        if (v21 == ++v24)
        {
          v21 = [services countByEnumeratingWithState:&v53 objects:v65 count:16];
          if (v21)
          {
            goto LABEL_8;
          }

          goto LABEL_15;
        }
      }

      v31 = v25;

      v32 = v31;
      characteristicCopy = v46;
      v28 = selfCopy;
      v29 = v49;
      if (v31)
      {
        goto LABEL_24;
      }
    }

    else
    {
LABEL_15:

      characteristicCopy = v46;
      v28 = selfCopy;
      v29 = v49;
    }

    v33 = objc_autoreleasePoolPush();
    v34 = v28;
    v35 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      v36 = HMFGetLogIdentifier();
      endpoint = [v48 endpoint];
      *buf = 138544130;
      v58 = v36;
      v59 = 2112;
      v60 = endpoint;
      v61 = 2112;
      v62 = characteristicCopy;
      v63 = 2112;
      v64 = v29;
      v28 = selfCopy;
      _os_log_impl(&dword_22AEAE000, v35, OS_LOG_TYPE_INFO, "%{public}@Unable to locate Accessory Information Service on accessory %@, defaulting to service endpoint %@ for characteristic: %@", buf, 0x2Au);
    }

    objc_autoreleasePoolPop(v33);
    v32 = 0;
    v31 = v48;
LABEL_24:
    endpoint2 = [v31 endpoint];
    v39 = [HMMTRDeviceReader alloc];
    clientQueue = [(HAPAccessoryServer *)v28 clientQueue];
    reportDistributor = [(HMMTRAccessoryServer *)v28 reportDistributor];
    matterDevice2 = [(HMMTRAccessoryServer *)v28 matterDevice];
    v43 = [(HMMTRDeviceReader *)v39 initWithClientQueue:clientQueue distributor:reportDistributor device:matterDevice2 endpointID:endpoint2 clusterID:&unk_283EE8A60 attributeID:&unk_283EE8CD0];

    bridgedAccessoryReachabilityReaderTimeoutNSecs = [(HMMTRAccessoryServer *)v28 bridgedAccessoryReachabilityReaderTimeoutNSecs];

    if (bridgedAccessoryReachabilityReaderTimeoutNSecs)
    {
      bridgedAccessoryReachabilityReaderTimeoutNSecs2 = [(HMMTRAccessoryServer *)v28 bridgedAccessoryReachabilityReaderTimeoutNSecs];
      -[HMMTRDeviceReader setReportTimeoutNSecs:](v43, "setReportTimeoutNSecs:", [bridgedAccessoryReachabilityReaderTimeoutNSecs2 longLongValue]);
    }

    v50[0] = MEMORY[0x277D85DD0];
    v50[1] = 3221225472;
    v50[2] = __97__HMMTRAccessoryServer__queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic_completion___block_invoke;
    v50[3] = &unk_2786F0350;
    v52 = completionCopy;
    v50[4] = v28;
    v15 = v48;
    v51 = v48;
    [(HMMTRDeviceReader *)v43 readAttributeWithCompletion:v50];
  }

  else
  {
    completionCopy[2](completionCopy, 0);
  }

LABEL_18:
  v30 = *MEMORY[0x277D85DE8];
}

void __97__HMMTRAccessoryServer__queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic_completion___block_invoke(uint64_t a1, void *a2)
{
  v20 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = v3;
  if (v3 && ([v3 objectForKeyedSubscript:*MEMORY[0x277CD5188]], v5 = objc_claimAutoreleasedReturnValue(), v6 = objc_msgSend(v5, "isEqual:", *MEMORY[0x277CD50C0]), v5, (v6 & 1) != 0))
  {
    v7 = [v4 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v8 = v7;
    }

    else
    {
      v8 = 0;
    }

    v9 = v8;

    if ([v9 isEqual:MEMORY[0x277CBEC28]])
    {
      v10 = objc_autoreleasePoolPush();
      v11 = *(a1 + 32);
      v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = HMFGetLogIdentifier();
        v14 = [*(a1 + 40) endpoint];
        v16 = 138543618;
        v17 = v13;
        v18 = 2112;
        v19 = v14;
        _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@Bridged accessory for endpoint %@ is unreachable", &v16, 0x16u);
      }

      objc_autoreleasePoolPop(v10);
    }

    (*(*(a1 + 48) + 16))();
  }

  else
  {
    (*(*(a1 + 48) + 16))();
  }

  v15 = *MEMORY[0x277D85DE8];
}

- (void)fetchColorControlClusterForHapAccessory:(id)accessory completionHandler:(id)handler
{
  accessoryCopy = accessory;
  handlerCopy = handler;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke;
  block[3] = &unk_2786F0EA8;
  v12 = accessoryCopy;
  v13 = handlerCopy;
  block[4] = self;
  v9 = accessoryCopy;
  v10 = handlerCopy;
  dispatch_async(clientQueue, block);
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke(id *a1)
{
  v40 = *MEMORY[0x277D85DE8];
  v2 = [a1[4] matterDevice];
  if (v2)
  {
    v3 = v2;
    v4 = [a1[4] isReadyToReadFromMTRDevice];

    if (v4)
    {
      v5 = +[HMMTRDescriptorClusterManager sharedManager];
      v6 = [a1[4] matterDevice];
      v7 = [v5 endpointForClusterID:&unk_283EE8AC0 mtrDevice:v6];

      if (!v7)
      {
        v20 = objc_autoreleasePoolPush();
        v21 = a1[4];
        v22 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          v23 = HMFGetLogIdentifier();
          *buf = 138543362;
          v37 = v23;
          _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@No endpoint found to fetch color control cluster", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v20);
        v24 = a1[6];
        v14 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
        v24[2](v24, 0, v14);
        goto LABEL_17;
      }

      if ([a1[5] isPrimary])
      {
        v8 = +[HMMTRDescriptorClusterManager sharedManager];
        v9 = [a1[4] matterDevice];
        v10 = [v8 endpointForClusterID:&unk_283EE8AC0 mtrDevice:v9];

        if (v10)
        {
LABEL_6:
          v11 = +[HMMTRDescriptorClusterManager sharedManager];
          v12 = [a1[4] matterDevice];
          v13 = [a1[4] clientQueue];
          v33[0] = MEMORY[0x277D85DD0];
          v33[1] = 3221225472;
          v33[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_927;
          v33[3] = &unk_2786F0C38;
          v33[4] = a1[4];
          v14 = v10;
          v34 = v14;
          v35 = a1[6];
          [v11 isEndpointPresentForClusterID:&unk_283EE8AC0 endpoint:v14 mtrDevice:v12 callbackQueue:v13 completionHandler:v33];

LABEL_17:
          goto LABEL_18;
        }
      }

      else
      {
        v10 = [a1[4] endPointForHapAccessory:a1[5]];
        if (v10)
        {
          goto LABEL_6;
        }
      }

      v25 = objc_autoreleasePoolPush();
      v26 = a1[4];
      v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        v28 = HMFGetLogIdentifier();
        v29 = a1[5];
        *buf = 138543618;
        v37 = v28;
        v38 = 2112;
        v39 = v29;
        _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_ERROR, "%{public}@Nil endpoint to fetch color control cluster for hapAccessory: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v25);
      v30 = a1[6];
      v31 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:4 userInfo:0];
      v30[2](v30, 0, v31);

      v14 = 0;
      goto LABEL_17;
    }
  }

  v15 = objc_autoreleasePoolPush();
  v16 = a1[4];
  v17 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v18 = HMFGetLogIdentifier();
    *buf = 138543362;
    v37 = v18;
    _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to read specification version", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v15);
  v19 = a1[6];
  v7 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
  v19[2](v19, 0, v7);
LABEL_18:

  v32 = *MEMORY[0x277D85DE8];
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_927(uint64_t a1, int a2, void *a3)
{
  v26 = *MEMORY[0x277D85DE8];
  v5 = a3;
  v6 = objc_autoreleasePoolPush();
  v7 = *(a1 + 32);
  v8 = HMFGetOSLogHandle();
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
  if (a2)
  {
    if (v9)
    {
      v10 = HMFGetLogIdentifier();
      v11 = *(a1 + 40);
      v22 = 138543618;
      v23 = v10;
      v24 = 2112;
      v25 = v11;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Found color control cluster at endpoint: %@", &v22, 0x16u);
    }

    objc_autoreleasePoolPop(v6);
    v12 = [HMMTRSyncClusterColorControl alloc];
    v13 = [*(a1 + 32) matterDevice];
    v14 = [*(a1 + 40) unsignedShortValue];
    v15 = [*(a1 + 32) clientQueue];
    v16 = [(MTRClusterColorControl *)v12 initWithDevice:v13 endpoint:v14 queue:v15];

    v17 = *(*(a1 + 48) + 16);
  }

  else
  {
    if (v9)
    {
      v18 = HMFGetLogIdentifier();
      v19 = *(a1 + 40);
      v22 = 138543618;
      v23 = v18;
      v24 = 2112;
      v25 = v19;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Did not find color control cluster at endpoint: %@ ", &v22, 0x16u);
    }

    objc_autoreleasePoolPop(v6);
    v20 = *(a1 + 48);
    v16 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    v17 = *(v20 + 16);
  }

  v17();

  v21 = *MEMORY[0x277D85DE8];
}

- (BOOL)doesMatchDiscriminator:(id)discriminator
{
  discriminatorCopy = discriminator;
  discriminatorIsOriginatedFromShort = [(HMMTRAccessoryServer *)self discriminatorIsOriginatedFromShort];
  discriminator = [(HMMTRAccessoryServer *)self discriminator];
  v7 = discriminator;
  if (discriminatorIsOriginatedFromShort)
  {
    unsignedShortValue = [discriminator unsignedShortValue];

    unsignedShortValue2 = [discriminatorCopy unsignedShortValue];
    return (unsignedShortValue2 ^ unsignedShortValue) < 0x100;
  }

  else
  {
    v11 = [discriminator isEqual:discriminatorCopy];

    return v11;
  }
}

- (id)createDoorLockClusterObjectWithFlow:(id)flow
{
  v26 = *MEMORY[0x277D85DE8];
  flowCopy = flow;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    uUID = [flowCopy UUID];
    *buf = 138543618;
    *&buf[4] = v8;
    v24 = 2112;
    v25 = uUID;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Creating door lock cluster object", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  *buf = 0;
  v10 = [MEMORY[0x277D0F7C0] futureWithPromise:buf];
  v19[0] = MEMORY[0x277D85DD0];
  v19[1] = 3221225472;
  v19[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke;
  v19[3] = &unk_2786EF378;
  v19[4] = selfCopy;
  v20 = flowCopy;
  v21 = *buf;
  v11 = v10;
  v22 = v11;
  v17[0] = MEMORY[0x277D85DD0];
  v17[1] = 3221225472;
  v17[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_926;
  v17[3] = &unk_2786EF290;
  v18 = v21;
  v12 = flowCopy;
  [(HMMTRAccessoryServer *)selfCopy queueAccessoryOperation:v19 highPriority:1 completion:v17];
  v13 = v18;
  v14 = v11;

  v15 = *MEMORY[0x277D85DE8];

  return v14;
}

void __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke(uint64_t a1)
{
  v67 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = [*(a1 + 40) UUID];
    *buf = 138543618;
    v60 = v5;
    v61 = 2112;
    v62 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Getting door lock cluster object", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = [*(a1 + 32) doorLockCluster];

  if (v7)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      v12 = [*(a1 + 40) UUID];
      *buf = 138543618;
      v60 = v11;
      v61 = 2112;
      v62 = v12;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Found existing door lock cluster object", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v8);
    v13 = *(a1 + 48);
    v14 = [*(a1 + 32) doorLockCluster];
    [v13 fulfillWithValue:v14];
  }

  else
  {
    v15 = [*(a1 + 32) doorLockClusterFuture];

    if (v15)
    {
      v16 = objc_autoreleasePoolPush();
      v17 = *(a1 + 32);
      v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        v19 = HMFGetLogIdentifier();
        v20 = [*(a1 + 40) UUID];
        *buf = 138543618;
        v60 = v19;
        v61 = 2112;
        v62 = v20;
        _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Creation is already in progress", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v16);
      v21 = objc_alloc(MEMORY[0x277D0F7A8]);
      v22 = [*(a1 + 32) clientQueue];
      v14 = [v21 initWithQueue:v22];

      v23 = [*(a1 + 32) doorLockClusterFuture];
      v56[0] = MEMORY[0x277D85DD0];
      v56[1] = 3221225472;
      v56[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_918;
      v56[3] = &unk_2786F02D8;
      v24 = *(a1 + 40);
      v56[4] = *(a1 + 32);
      v57 = v24;
      v58 = *(a1 + 48);
      v53[0] = MEMORY[0x277D85DD0];
      v53[1] = 3221225472;
      v53[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_920;
      v53[3] = &unk_2786F0300;
      v25 = *(a1 + 40);
      v53[4] = *(a1 + 32);
      v54 = v25;
      v55 = *(a1 + 48);
      v26 = [v23 inContext:v14 then:v56 orRecover:v53];
    }

    else
    {
      [*(a1 + 32) setDoorLockClusterFuture:*(a1 + 56)];
      v14 = [*(a1 + 32) deviceController];
      if (v14)
      {
        v27 = [*(a1 + 32) matterDevice];
        if (!v27)
        {
          v28 = objc_autoreleasePoolPush();
          v29 = *(a1 + 32);
          v30 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            v31 = HMFGetLogIdentifier();
            v32 = [*(a1 + 40) UUID];
            *buf = 138543618;
            v60 = v31;
            v61 = 2112;
            v62 = v32;
            _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] No matter device available", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v28);
          v33 = *(a1 + 48);
          v34 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
          [v33 rejectWithError:v34];
        }

        v35 = objc_autoreleasePoolPush();
        v36 = *(a1 + 32);
        v37 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          v38 = HMFGetLogIdentifier();
          v39 = [*(a1 + 40) UUID];
          *buf = 138544130;
          v60 = v38;
          v61 = 2112;
          v62 = v39;
          v63 = 2112;
          v64 = &unk_283EE8CB8;
          v65 = 2112;
          v66 = v27;
          _os_log_impl(&dword_22AEAE000, v37, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Looking up endpoint for clusterID: %@, device: %@, ", buf, 0x2Au);
        }

        objc_autoreleasePoolPop(v35);
        v40 = +[HMMTRDescriptorClusterManager sharedManager];
        v41 = [*(a1 + 32) clientQueue];
        v50[0] = MEMORY[0x277D85DD0];
        v50[1] = 3221225472;
        v50[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_924;
        v50[3] = &unk_2786F0328;
        v42 = *(a1 + 40);
        v50[4] = *(a1 + 32);
        v51 = v42;
        v52 = *(a1 + 48);
        [v40 endpointForClusterID:&unk_283EE8CB8 mtrDevice:v27 callbackQueue:v41 completionHandler:v50];
      }

      else
      {
        v43 = objc_autoreleasePoolPush();
        v44 = *(a1 + 32);
        v45 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          v46 = HMFGetLogIdentifier();
          v47 = [*(a1 + 40) UUID];
          *buf = 138543618;
          v60 = v46;
          v61 = 2112;
          v62 = v47;
          _os_log_impl(&dword_22AEAE000, v45, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] No Matter device controller available", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v43);
        v48 = *(a1 + 48);
        v27 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
        [v48 rejectWithError:v27];
      }
    }
  }

  v49 = *MEMORY[0x277D85DE8];
}

uint64_t __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_926(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return [*(result + 32) rejectWithError:a2];
  }

  return result;
}

uint64_t __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_918(id *a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = a1[4];
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v8 = [a1[5] UUID];
    v11 = 138543874;
    v12 = v7;
    v13 = 2112;
    v14 = v8;
    v15 = 2112;
    v16 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Returning doorLockCluster: %@", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  [a1[6] fulfillWithValue:v3];

  v9 = *MEMORY[0x277D85DE8];
  return 1;
}

uint64_t __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_920(id *a1, void *a2)
{
  v18 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = a1[4];
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    v7 = HMFGetLogIdentifier();
    v8 = [a1[5] UUID];
    v9 = a1[4];
    v12 = 138543874;
    v13 = v7;
    v14 = 2112;
    v15 = v8;
    v16 = 2048;
    v17 = v9;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Failed to create door lock cluster object. Removing door lock cluster future from accessory server: %p", &v12, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  [a1[4] setDoorLockClusterFuture:0];
  [a1[6] rejectWithError:v3];

  v10 = *MEMORY[0x277D85DE8];
  return 1;
}

void __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_924(id *a1, void *a2, void *a3)
{
  v31 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = [a1[4] clientQueue];
  dispatch_assert_queue_V2(v7);

  if (v5)
  {
    v8 = [HMMTRSyncClusterDoorLock alloc];
    v9 = [a1[4] matterDevice];
    v10 = [v5 unsignedShortValue];
    v11 = [a1[4] clientQueue];
    v12 = [(HMMTRSyncClusterDoorLock *)v8 initWithDevice:v9 endpoint:v10 queue:v11 accessoryServer:a1[4]];

    [a1[4] setDoorLockCluster:v12];
    v13 = objc_autoreleasePoolPush();
    v14 = a1[4];
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      v17 = [a1[5] UUID];
      v25 = 138543874;
      v26 = v16;
      v27 = 2112;
      v28 = v17;
      v29 = 2112;
      v30 = v12;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Created door lock cluster object: %@", &v25, 0x20u);
    }

    objc_autoreleasePoolPop(v13);
    [a1[6] fulfillWithValue:v12];
  }

  else
  {
    v18 = objc_autoreleasePoolPush();
    v19 = a1[4];
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = HMFGetLogIdentifier();
      v22 = [a1[5] UUID];
      v25 = 138543874;
      v26 = v21;
      v27 = 2112;
      v28 = v22;
      v29 = 2112;
      v30 = v6;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Did not find endpoint for door lock with error: %@", &v25, 0x20u);
    }

    objc_autoreleasePoolPop(v18);
    if (v6)
    {
      v23 = v6;
    }

    else
    {
      v23 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
    }

    v12 = v23;
    [a1[6] rejectWithError:v23];
  }

  v24 = *MEMORY[0x277D85DE8];
}

- (void)handleFirmwareUpdateStatusChange:(int64_t)change
{
  browser = [(HMMTRAccessoryServer *)self browser];
  threadSoftwareUpdateController = [browser threadSoftwareUpdateController];
  [threadSoftwareUpdateController handleFirmwareUpdateStatusChangeForAccessoryServer:self state:change];
}

- (id)accessoryProductID
{
  productID = [(HMMTRAccessoryServer *)self productID];
  v3 = [productID copy];

  return v3;
}

- (id)accessoryVendorID
{
  vendorID = [(HMMTRAccessoryServer *)self vendorID];
  v3 = [vendorID copy];

  return v3;
}

- (void)announceOtaProvider:(id)provider providerEndpoint:(id)endpoint immediateAnnouncement:(BOOL)announcement delayCounter:(int64_t)counter completionHandler:(id)handler
{
  announcementCopy = announcement;
  v60 = *MEMORY[0x277D85DE8];
  providerCopy = provider;
  endpointCopy = endpoint;
  handlerCopy = handler;
  v14 = objc_autoreleasePoolPush();
  selfCopy = self;
  v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    v17 = HMFGetLogIdentifier();
    v18 = HMFBooleanToString();
    *buf = 138544130;
    v53 = v17;
    v54 = 2112;
    v55 = selfCopy;
    v56 = 2112;
    v57 = v18;
    v58 = 2048;
    counterCopy = counter;
    _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@announceOtaProvider for %@, immediateAnnouncement: %@, delayCounter: %lu", buf, 0x2Au);
  }

  objc_autoreleasePoolPop(v14);
  v19 = [HMMTRDeviceTopology alloc];
  nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
  v21 = [(HMMTRDeviceTopology *)v19 initWithNodeId:nodeID server:selfCopy];

  getEnabledOTARequestorEndpoint = [(HMMTRDeviceTopology *)v21 getEnabledOTARequestorEndpoint];
  if (getEnabledOTARequestorEndpoint)
  {

LABEL_9:
    v30 = MEMORY[0x277CD5310];
    nodeID2 = [(HMMTRAccessoryServer *)selfCopy nodeID];
    unsignedLongLongValue = [nodeID2 unsignedLongLongValue];
    deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
    v29 = [v30 deviceWithNodeID:unsignedLongLongValue deviceController:deviceController];

    v34 = objc_alloc(MEMORY[0x277CD5288]);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    v36 = [v34 initWithDevice:v29 endpoint:0 queue:clientQueue];

    v37 = objc_alloc_init(MEMORY[0x277CD5480]);
    [v37 setProviderNodeId:providerCopy];
    [v37 setEndpoint:endpointCopy];
    [v37 setVendorId:&unk_283EE8C88];
    [v37 setAnnouncementReason:&unk_283EE8C28];
    if (v36)
    {
      if (announcementCopy)
      {
        v50[0] = MEMORY[0x277D85DD0];
        v50[1] = 3221225472;
        v50[2] = __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke;
        v50[3] = &unk_2786EF8A0;
        v50[4] = selfCopy;
        v51 = handlerCopy;
        [v36 announceOtaProviderWithParams:v37 expectedValues:0 expectedValueInterval:0 completionHandler:v50];
      }

      v45[0] = MEMORY[0x277D85DD0];
      v45[1] = 3221225472;
      v45[2] = __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_913;
      v45[3] = &unk_2786F02B0;
      v45[4] = selfCopy;
      v46 = v36;
      counterCopy2 = counter;
      v47 = v37;
      v48 = handlerCopy;
      [(HMMTRAccessoryServer *)selfCopy updateDefaultOtaProvider:providerCopy providerEndpoint:endpointCopy completionHandler:v45];
    }

    else
    {
      v38 = objc_autoreleasePoolPush();
      v39 = selfCopy;
      v40 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v41 = HMFGetLogIdentifier();
        *buf = 138543362;
        v53 = v41;
        _os_log_impl(&dword_22AEAE000, v40, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to announce OTA provider", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v38);
      v42 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      (*(handlerCopy + 2))(handlerCopy, v42);
    }

    goto LABEL_17;
  }

  v23 = [(HMMTRDeviceTopology *)v21 getVersionForKey:@"EnumeratedProtocolMap"];
  intValue = [v23 intValue];

  if (intValue < 101)
  {
    goto LABEL_9;
  }

  v25 = objc_autoreleasePoolPush();
  v26 = selfCopy;
  v27 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
  {
    v28 = HMFGetLogIdentifier();
    *buf = 138543362;
    v53 = v28;
    _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_INFO, "%{public}@Ignoring OTA announcement, OTA requestor cluster not supported on this accessory", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v25);
  v29 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:5 userInfo:0];
  (*(handlerCopy + 2))(handlerCopy, v29);
LABEL_17:

  v43 = *MEMORY[0x277D85DE8];
}

void __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  v24 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v9 = *(a1 + 32);
      v18 = 138543874;
      v19 = v8;
      v20 = 2112;
      v21 = v9;
      v22 = 2112;
      v23 = v3;
      v10 = "%{public}@Failed to announce ota provider to %@ with error %@";
      v11 = v7;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 32;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v11, v12, v10, &v18, v13);
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v14 = *(a1 + 32);
    v18 = 138543618;
    v19 = v8;
    v20 = 2112;
    v21 = v14;
    v10 = "%{public}@Successfully announced ota provider to %@";
    v11 = v7;
    v12 = OS_LOG_TYPE_INFO;
    v13 = 22;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v4);
  (*(*(a1 + 40) + 16))(*(a1 + 40), v3, v15, v16);

  v17 = *MEMORY[0x277D85DE8];
}

void __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_913(uint64_t a1, void *a2)
{
  v47 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v8 = *(a1 + 32);
    *buf = 138543874;
    v42 = v7;
    v43 = 2112;
    v44 = v8;
    v45 = 2112;
    v46 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Update default OTA provider completed for server:%@ with error: %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  v9 = objc_alloc_init(MEMORY[0x277CD54D8]);
  v10 = [*(a1 + 40) readAttributeUpdateStateWithParams:v9];
  v11 = 0.0;
  if (!v10)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = *(a1 + 32);
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543362;
      v42 = v15;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@An error occurred while trying to read the OTA requestor update state", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v12);
    v11 = 120.0;
  }

  v16 = [v10 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v17 = v16;
  }

  else
  {
    v17 = 0;
  }

  v18 = COERCE_DOUBLE(v17);

  v19 = objc_autoreleasePoolPush();
  v20 = *(a1 + 32);
  v21 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    v22 = HMFGetLogIdentifier();
    *buf = 138543618;
    v42 = v22;
    v43 = 2112;
    v44 = v18;
    _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@OTA Requestor update state:%@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v19);
  v23 = [*&v18 isEqualToNumber:&unk_283EE8CA0];
  v24 = 120.0;
  v25 = *(a1 + 64);
  if (v23)
  {
    v24 = v11;
  }

  if (v25)
  {
    v26 = v25 * 300.0;
  }

  else
  {
    v26 = v24;
  }

  v27 = objc_autoreleasePoolPush();
  v28 = *(a1 + 32);
  v29 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
  {
    v30 = HMFGetLogIdentifier();
    v31 = *(a1 + 32);
    *buf = 138543874;
    v42 = v30;
    v43 = 2048;
    v44 = v26;
    v45 = 2112;
    v46 = v31;
    _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@Sending announcement after %f secs for %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v27);
  v32 = dispatch_time(0, (v26 * 1000000000.0));
  v33 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_916;
  block[3] = &unk_2786EF3C8;
  v38 = *(a1 + 40);
  v34 = *(a1 + 48);
  v35 = *(a1 + 32);
  v39 = v34;
  v40 = v35;
  dispatch_after(v32, v33, block);

  (*(*(a1 + 56) + 16))();
  v36 = *MEMORY[0x277D85DE8];
}

uint64_t __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_916(void *a1)
{
  v2 = a1[4];
  v1 = a1[5];
  v4[0] = MEMORY[0x277D85DD0];
  v4[1] = 3221225472;
  v4[2] = __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_2;
  v4[3] = &unk_2786EF290;
  v4[4] = a1[6];
  return [v2 announceOtaProviderWithParams:v1 expectedValues:0 expectedValueInterval:0 completionHandler:v4];
}

void __114__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_delayCounter_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  v22 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v9 = *(a1 + 32);
      v16 = 138543874;
      v17 = v8;
      v18 = 2112;
      v19 = v9;
      v20 = 2112;
      v21 = v3;
      v10 = "%{public}@Failed to announce ota provider to %@ with error %@";
      v11 = v7;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 32;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v11, v12, v10, &v16, v13);
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v14 = *(a1 + 32);
    v16 = 138543618;
    v17 = v8;
    v18 = 2112;
    v19 = v14;
    v10 = "%{public}@Successfully announced ota provider to %@";
    v11 = v7;
    v12 = OS_LOG_TYPE_INFO;
    v13 = 22;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v4);
  v15 = *MEMORY[0x277D85DE8];
}

- (void)updateDefaultOtaProvider:(id)provider providerEndpoint:(id)endpoint completionHandler:(id)handler
{
  v36 = *MEMORY[0x277D85DE8];
  providerCopy = provider;
  endpointCopy = endpoint;
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v11 = objc_autoreleasePoolPush();
    selfCopy = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543362;
      v33 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting updating default OTA provider.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v11);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v31 = handlerCopy;
    dispatch_async(clientQueue, block);

    v16 = v31;
  }

  else
  {
    v17 = random();
    v18 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      v21 = HMFGetLogIdentifier();
      *buf = 138543618;
      v33 = v21;
      v34 = 2048;
      v35 = v17;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v18);
    v25[0] = MEMORY[0x277D85DD0];
    v25[1] = 3221225472;
    v25[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_901;
    v25[3] = &unk_2786F0288;
    v25[4] = selfCopy2;
    v29 = v17;
    v26 = providerCopy;
    v28 = handlerCopy;
    v27 = endpointCopy;
    v23[0] = MEMORY[0x277D85DD0];
    v23[1] = 3221225472;
    v23[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_909;
    v23[3] = &unk_2786F0BC0;
    v24 = v28;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v25 highPriority:0 completion:v23];

    v16 = v26;
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, v2);
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_901(uint64_t a1)
{
  v24 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 64);
    *buf = 138543618;
    v21 = v5;
    v22 = 2048;
    v23 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_902;
  block[3] = &unk_2786F0260;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v16 = v9;
  v19 = *(a1 + 56);
  v17 = *(a1 + 48);
  v18 = v7;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_908;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 64);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_909(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_902(uint64_t a1)
{
  v27 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    *buf = 138543618;
    v24 = v5;
    v25 = 2112;
    v26 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to update default ota provider to %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v21[0] = MEMORY[0x277D85DD0];
  v21[1] = 3221225472;
  v21[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_903;
  v21[3] = &unk_2786F0BC0;
  v22 = *(a1 + 64);
  v7 = MEMORY[0x2318887D0](v21);
  v8 = *(a1 + 32);
  v9 = [HMMTRDeviceTopology alloc];
  v10 = [*(a1 + 32) nodeID];
  v11 = [(HMMTRDeviceTopology *)v9 initWithNodeId:v10 server:*(a1 + 32)];
  v12 = [*(a1 + 32) matterDevice];
  v13 = [*(a1 + 32) clientQueue];
  v17[0] = MEMORY[0x277D85DD0];
  v17[1] = 3221225472;
  v17[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_2;
  v17[3] = &unk_2786F1010;
  v14 = *(a1 + 40);
  v17[4] = *(a1 + 32);
  v20 = v7;
  v18 = v14;
  v19 = *(a1 + 48);
  v15 = v7;
  [v8 _endpointForOTARequestorWithTopology:v11 mtrDevice:v12 callbackQueue:v13 completionHandler:v17];

  dispatch_group_leave(*(a1 + 56));
  v16 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_908(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v65 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543618;
      v62 = v10;
      v63 = 2112;
      v64 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to query endpoints for ota requestor cluster : %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    (*(*(a1 + 56) + 16))();
  }

  v11 = [*(a1 + 32) matterDevice];

  if (v11)
  {
    v12 = objc_alloc(MEMORY[0x277CD5288]);
    v13 = [*(a1 + 32) matterDevice];
    v14 = [*(a1 + 32) clientQueue];
    v40 = [v12 initWithDevice:v13 endpointID:v5 queue:v14];

    v15 = *MEMORY[0x277CD50D0];
    v59[0] = &unk_283EE89E8;
    v42 = v5;
    v16 = *MEMORY[0x277CD50D8];
    v58[0] = v15;
    v58[1] = v16;
    v41 = v6;
    v18 = *MEMORY[0x277CD5198];
    v19 = *MEMORY[0x277CD51A0];
    v56[0] = *MEMORY[0x277CD5188];
    v17 = v56[0];
    v56[1] = v19;
    v20 = *(a1 + 40);
    v57[0] = v18;
    v57[1] = v20;
    v21 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v57 forKeys:v56 count:2];
    v59[1] = v21;
    v22 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v59 forKeys:v58 count:2];
    v60[0] = v22;
    v54[1] = v16;
    v55[0] = &unk_283EE8C70;
    v52[0] = v17;
    v52[1] = v19;
    v23 = *(a1 + 48);
    v53[0] = v18;
    v53[1] = v23;
    v54[0] = v15;
    v24 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v53 forKeys:v52 count:2];
    v55[1] = v24;
    v25 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v55 forKeys:v54 count:2];
    v60[1] = v25;
    v26 = [MEMORY[0x277CBEA60] arrayWithObjects:v60 count:2];

    v27 = *MEMORY[0x277CD50B0];
    v50[1] = v19;
    v51[0] = v27;
    v50[0] = v17;
    v47 = v16;
    v28 = *MEMORY[0x277CD5180];
    v45[0] = v17;
    v45[1] = v19;
    v6 = v41;
    v5 = v42;
    v29 = v40;
    v46[0] = v28;
    v46[1] = v26;
    v30 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v46 forKeys:v45 count:2];
    v48 = v30;
    v31 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v48 forKeys:&v47 count:1];
    v49 = v31;
    v32 = [MEMORY[0x277CBEA60] arrayWithObjects:&v49 count:1];
    v51[1] = v32;
    v33 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v51 forKeys:v50 count:2];

    [v40 writeAttributeDefaultOTAProvidersWithValue:v33 expectedValueInterval:&unk_283EE8BB0];
    (*(*(a1 + 56) + 16))();
  }

  else
  {
    v34 = objc_autoreleasePoolPush();
    v35 = *(a1 + 32);
    v36 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v37 = HMFGetLogIdentifier();
      *buf = 138543362;
      v62 = v37;
      _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to update default OTA provider", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v34);
    v38 = [*(a1 + 32) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_904;
    block[3] = &unk_2786EF878;
    v44 = *(a1 + 56);
    dispatch_async(v38, block);

    v29 = v44;
  }

  v39 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_904(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, v2);
}

- (BOOL)accessoryWithSameDiscriminatorDiscovered
{
  v18 = *MEMORY[0x277D85DE8];
  if ([(HMMTRAccessoryServer *)self locallyDiscovered])
  {
    v3 = objc_autoreleasePoolPush();
    selfCopy = self;
    v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = HMFGetLogIdentifier();
      v16 = 138543362;
      v17 = v6;
      _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_DEBUG, "%{public}@accessoryWithSameDiscriminatorDiscovered -> YES as server was locally discovered", &v16, 0xCu);
    }

    objc_autoreleasePoolPop(v3);
    v7 = 1;
  }

  else
  {
    _pairingSetupPayload = [(HMMTRAccessoryServer *)self _pairingSetupPayload];
    if (_pairingSetupPayload)
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      v7 = [browser locallyDiscoveredAccessoryServerMatchesDiscriminatorOfSetupPayload:_pairingSetupPayload];
    }

    else
    {
      v10 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v13 = HMFGetLogIdentifier();
        v16 = 138543362;
        v17 = v13;
        _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_DEBUG, "%{public}@accessoryWithSameDiscriminatorDiscovered -> NO as setupPayload is missing", &v16, 0xCu);
      }

      objc_autoreleasePoolPop(v10);
      v7 = 0;
    }
  }

  v14 = *MEMORY[0x277D85DE8];
  return v7;
}

- (BOOL)isLocallyDiscoveredAndMatchesDiscriminatorOfSetupPayload:(id)payload
{
  v33 = *MEMORY[0x277D85DE8];
  payloadCopy = payload;
  if ([(HMMTRAccessoryServer *)self locallyDiscovered])
  {
    if ([payloadCopy hasShortDiscriminator])
    {
      v5 = MEMORY[0x277CCABB0];
      discriminator = [payloadCopy discriminator];
      discriminator2 = [v5 numberWithInt:{objc_msgSend(discriminator, "unsignedShortValue") << 8}];
    }

    else
    {
      discriminator2 = [payloadCopy discriminator];
    }

    if ([(HMMTRAccessoryServer *)self doesMatchDiscriminator:discriminator2])
    {
      v9 = objc_autoreleasePoolPush();
      selfCopy = self;
      v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = HMFGetLogIdentifier();
        v27 = 138543618;
        v28 = v12;
        v29 = 2112;
        v30 = discriminator2;
        _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_DEBUG, "%{public}@isLocallyDiscoveredAndMatchesDiscriminatorOfSetupPayload matched discriminator %@ against server's own", &v27, 0x16u);
      }

      objc_autoreleasePoolPop(v9);
      v8 = 1;
    }

    else if ([payloadCopy hasShortDiscriminator] && !-[HMMTRAccessoryServer discriminatorIsOriginatedFromShort](self, "discriminatorIsOriginatedFromShort"))
    {
      v18 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        discriminator3 = [(HMMTRAccessoryServer *)selfCopy2 discriminator];
        v27 = 138543874;
        v28 = v21;
        v29 = 2112;
        v30 = discriminator2;
        v31 = 2112;
        v32 = discriminator3;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@isLocallyDiscoveredAndMatchesDiscriminatorOfSetupPayload compares short discriminator %@ against its own %@", &v27, 0x20u);
      }

      objc_autoreleasePoolPop(v18);
      discriminator4 = [(HMMTRAccessoryServer *)selfCopy2 discriminator];
      v24 = [discriminator4 unsignedShortValue] & 0xF00;
      v8 = v24 == [discriminator2 unsignedShortValue];
    }

    else
    {
      v13 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v16 = HMFGetLogIdentifier();
        discriminator5 = [(HMMTRAccessoryServer *)selfCopy3 discriminator];
        v27 = 138543874;
        v28 = v16;
        v29 = 2112;
        v30 = discriminator2;
        v31 = 2112;
        v32 = discriminator5;
        _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_DEBUG, "%{public}@isLocallyDiscoveredAndMatchesDiscriminatorOfSetupPayload failed to match discriminator %@ against its own %@", &v27, 0x20u);
      }

      objc_autoreleasePoolPop(v13);
      v8 = 0;
    }
  }

  else
  {
    v8 = 0;
  }

  v25 = *MEMORY[0x277D85DE8];
  return v8;
}

- (void)_handleUnreachableStateWithError:(id)error
{
  v12 = *MEMORY[0x277D85DE8];
  errorCopy = error;
  [(HMMTRAccessoryServer *)self setMtrDeviceConnected:0];
  if ([(HMMTRAccessoryServer *)self _shouldUpdateUnreachableState])
  {
    [(HMMTRAccessoryServer *)self didUpdateReachability:0];
    [(HMMTRAccessoryServer *)self _updateDelegateOfConnectionStatus:0 withError:errorCopy];
  }

  else
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      v10 = 138543362;
      v11 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Ignored unreachable state for WED accessory", &v10, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  [(HMMTRAccessoryServer *)self markForResubscription];

  v9 = *MEMORY[0x277D85DE8];
}

- (BOOL)_shouldUpdateUnreachableState
{
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    if (![browser isCurrentDevicePrimaryResident])
    {
      isWEDDevice = [(HMMTRAccessoryServer *)self isWEDDevice];

      v4 = !isWEDDevice;
      return v4 & 1;
    }
  }

  v4 = 1;
  return v4 & 1;
}

- (void)generateAccessoryConfigurationForReason:(id)reason completionHandler:(id)handler
{
  v39 = *MEMORY[0x277D85DE8];
  reasonCopy = reason;
  handlerCopy = handler;
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    name = [(HAPAccessoryServer *)selfCopy name];
    *buf = 138543874;
    v34 = v11;
    v35 = 2112;
    v36 = name;
    v37 = 2112;
    v38 = reasonCopy;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration: Generate Accessory Configuration for '%@' by reason : %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v8);
  if ([(HMMTRAccessoryServer *)selfCopy operationDisabled])
  {
    v13 = objc_autoreleasePoolPush();
    v14 = selfCopy;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v16;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting generating accessory configuration information.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v13);
    clientQueue = [(HAPAccessoryServer *)v14 clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v32 = handlerCopy;
    dispatch_async(clientQueue, block);

    v18 = v32;
  }

  else
  {
    v19 = random();
    v20 = objc_autoreleasePoolPush();
    v21 = selfCopy;
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      *buf = 138543618;
      v34 = v23;
      v35 = 2048;
      v36 = v19;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate accessory configuration information job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v20);
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_895;
    v27[3] = &unk_2786EF850;
    v27[4] = v21;
    v30 = v19;
    v29 = handlerCopy;
    v28 = reasonCopy;
    v25[0] = MEMORY[0x277D85DD0];
    v25[1] = 3221225472;
    v25[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_900;
    v25[3] = &unk_2786F0BC0;
    v26 = v29;
    [(HMMTRAccessoryServer *)v21 queueAccessoryOperation:v27 highPriority:0 completion:v25];

    v18 = v29;
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, 0, v2);
}

void __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_895(uint64_t a1)
{
  v26 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 56);
    *buf = 138543618;
    v23 = v5;
    v24 = 2048;
    v25 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate accessory configuration information job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_896;
  block[3] = &unk_2786F0288;
  v9 = *(a1 + 48);
  v10 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v18 = v7;
  v11 = *(a1 + 56);
  v20 = v9;
  v21 = v11;
  v19 = v10;
  v12 = v7;
  dispatch_async(v8, block);

  v13 = [*(a1 + 32) clientQueue];
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_2_899;
  v16[3] = &unk_2786EF620;
  v14 = *(a1 + 56);
  v16[4] = *(a1 + 32);
  v16[5] = v14;
  dispatch_group_notify(v12, v13, v16);

  v15 = *MEMORY[0x277D85DE8];
}

uint64_t __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_900(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_896(uint64_t a1)
{
  v34 = *MEMORY[0x277D85DE8];
  v28[0] = MEMORY[0x277D85DD0];
  v28[1] = 3221225472;
  v28[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_2;
  v28[3] = &unk_2786F0210;
  v29 = *(a1 + 56);
  v2 = MEMORY[0x2318887D0](v28);
  v3 = [*(a1 + 32) deviceController];
  v4 = v3;
  if (v3 && ([v3 isRunning] & 1) != 0)
  {
    v5 = MEMORY[0x277CD5310];
    v6 = [*(a1 + 32) nodeID];
    v7 = [v6 unsignedLongLongValue];
    v8 = [*(a1 + 32) deviceController];
    v9 = [v5 deviceWithNodeID:v7 deviceController:v8];

    v10 = +[HMMTRDescriptorClusterManager sharedManager];
    v11 = [*(a1 + 32) nodeID];
    v12 = *(a1 + 32);
    v13 = *(a1 + 48);
    v14 = [v12 clientQueue];
    v26[0] = MEMORY[0x277D85DD0];
    v26[1] = 3221225472;
    v26[2] = __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_897;
    v26[3] = &unk_2786F0238;
    v27 = v2;
    [v10 fetchAccessoryConfigurationForDevice:v9 nodeId:v11 server:v12 reasonString:v13 callbackQueue:v14 completionHandler:v26];

    dispatch_group_leave(*(a1 + 40));
  }

  else
  {
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543362;
      v31 = v18;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to generate accessory configuration information", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v15);
    v19 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    (v2)[2](v2, 0, v19);

    dispatch_group_leave(*(a1 + 40));
    v20 = objc_autoreleasePoolPush();
    v21 = *(a1 + 32);
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      v24 = *(a1 + 64);
      *buf = 138543618;
      v31 = v23;
      v32 = 2048;
      v33 = v24;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate accessory configuration information job(%lu) complete.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v20);
  }

  v25 = *MEMORY[0x277D85DE8];
}

void __82__HMMTRAccessoryServer_generateAccessoryConfigurationForReason_completionHandler___block_invoke_2_899(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate accessory configuration information job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

- (id)protocolMappingStateForCharacteristic:(id)characteristic
{
  characteristicCopy = characteristic;
  characteristicProtocolMappingStates = [(HMMTRAccessoryServer *)self characteristicProtocolMappingStates];
  instanceID = [characteristicCopy instanceID];
  v7 = [characteristicProtocolMappingStates objectForKeyedSubscript:instanceID];

  if (!v7)
  {
    v7 = objc_alloc_init(HMMTRProtocolMappingState);
    characteristicProtocolMappingStates2 = [(HMMTRAccessoryServer *)self characteristicProtocolMappingStates];
    instanceID2 = [characteristicCopy instanceID];
    [characteristicProtocolMappingStates2 setObject:v7 forKeyedSubscript:instanceID2];
  }

  return v7;
}

- (void)_onThreadScanResults:(id)results
{
  v29 = *MEMORY[0x277D85DE8];
  resultsCopy = results;
  v21 = [MEMORY[0x277CBEB18] arrayWithCapacity:{objc_msgSend(resultsCopy, "count")}];
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  obj = resultsCopy;
  v22 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v22)
  {
    v20 = *v25;
    do
    {
      v4 = 0;
      do
      {
        if (*v25 != v20)
        {
          objc_enumerationMutation(obj);
        }

        v5 = *(*(&v24 + 1) + 8 * v4);
        v6 = objc_alloc(MEMORY[0x277CD55D8]);
        networkName = [v5 networkName];
        panId = [v5 panId];
        extendedPanId = [v5 extendedPanId];
        channel = [v5 channel];
        extendedAddress = [v5 extendedAddress];
        rssi = [v5 rssi];
        version = [v5 version];
        v14 = [v5 lqi];
        v15 = [v6 initWithNetworkName:networkName panID:panId extendedPANID:extendedPanId channel:channel extendedAddress:extendedAddress rssi:rssi version:version lqi:v14];
        [v21 addObject:v15];

        ++v4;
      }

      while (v22 != v4);
      v22 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v22);
  }

  stageThreadScanResultsHandler = [(HMMTRAccessoryServer *)self stageThreadScanResultsHandler];
  v23[0] = MEMORY[0x277D85DD0];
  v23[1] = 3221225472;
  v23[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke;
  v23[3] = &unk_2786F01E8;
  v23[4] = self;
  (stageThreadScanResultsHandler)[2](stageThreadScanResultsHandler, v21, v23);

  v17 = *MEMORY[0x277D85DE8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = [*(a1 + 32) clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2;
  v7[3] = &unk_2786EF328;
  v5 = *(a1 + 32);
  v8 = v3;
  v9 = v5;
  v6 = v3;
  dispatch_async(v4, v7);
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2(uint64_t a1)
{
  v53 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32))
  {
    v2 = dispatch_group_create();
    *&v48 = 0;
    *(&v48 + 1) = &v48;
    v49 = 0x3032000000;
    v50 = __Block_byref_object_copy__10189;
    v51 = __Block_byref_object_dispose__10190;
    v52 = 0;
    v42[0] = 0;
    v42[1] = v42;
    v42[2] = 0x3032000000;
    v42[3] = __Block_byref_object_copy__10189;
    v42[4] = __Block_byref_object_dispose__10190;
    v43 = 0;
    dispatch_group_enter(v2);
    v3 = *(a1 + 40);
    v39[0] = MEMORY[0x277D85DD0];
    v39[1] = 3221225472;
    v39[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_887;
    v39[3] = &unk_2786F0D68;
    v39[4] = v3;
    v41 = &v48;
    v4 = v2;
    v40 = v4;
    [v3 _fetchAdditionalThreadNetworkInformationWithCompletion:v39];
    v5 = objc_alloc_init(MEMORY[0x277CD5300]);
    v6 = [*(a1 + 40) browser];
    v7 = [v6 attestationStatus];
    [v7 populateDelegate:v5];

    if ([*(a1 + 40) _populateCommissioningParameterCountryCode:v5])
    {
      v8 = [objc_alloc(MEMORY[0x277CE1968]) initWithKeychainAccessGroup:@"com.apple.thread.network"];
      v9 = [*(a1 + 32) extendedPANID];
      v10 = [v9 unsignedLongLongValue];

      v38 = bswap64(v10);
      v24 = [MEMORY[0x277CBEA90] dataWithBytes:&v38 length:8];
      objc_initWeak(&location, *(a1 + 40));
      v31[0] = MEMORY[0x277D85DD0];
      v31[1] = 3221225472;
      v31[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_889;
      v31[3] = &unk_2786F0198;
      objc_copyWeak(&v36, &location);
      v11 = v4;
      v32 = v11;
      v34 = &v48;
      v35 = v42;
      v12 = v8;
      v33 = v12;
      v13 = MEMORY[0x2318887D0](v31);
      v14 = objc_autoreleasePoolPush();
      v15 = *(a1 + 40);
      v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        v17 = HMFGetLogIdentifier();
        *buf = 138543618;
        v45 = v17;
        v46 = 2112;
        v47 = v24;
        _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Retrieving Thread credentials for extended PANID: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v14);
      dispatch_group_enter(v11);
      [v12 retrieveActiveDataSetRecordInternallyForExtendedPANID:v24 completion:v13];
      v18 = [*(a1 + 40) clientQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_892;
      block[3] = &unk_2786F01C0;
      objc_copyWeak(&v30, &location);
      v28 = &v48;
      v26 = v5;
      v29 = v42;
      v27 = *(a1 + 32);
      dispatch_group_notify(v11, v18, block);

      objc_destroyWeak(&v30);
      objc_destroyWeak(&v36);
      objc_destroyWeak(&location);
    }

    _Block_object_dispose(v42, 8);
    _Block_object_dispose(&v48, 8);
  }

  else
  {
    v19 = objc_autoreleasePoolPush();
    v20 = *(a1 + 40);
    v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v22 = HMFGetLogIdentifier();
      LODWORD(v48) = 138543362;
      *(&v48 + 4) = v22;
      _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@No network selection from Thread scan result. Falling back to default network credentials collection.", &v48, 0xCu);
    }

    objc_autoreleasePoolPop(v19);
    [*(a1 + 40) _collectNetworkCredentials:0];
  }

  v23 = *MEMORY[0x277D85DE8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_887(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = *(a1 + 32);
  v8[0] = MEMORY[0x277D85DD0];
  v8[1] = 3221225472;
  v8[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2_888;
  v8[3] = &unk_2786F0148;
  v9 = v3;
  v10 = v4;
  v7 = *(a1 + 40);
  v5 = v7;
  v11 = v7;
  v6 = v3;
  [v4 dispatchBlock:v8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_889(uint64_t a1, void *a2, void *a3)
{
  v28 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 64));
  v8 = objc_autoreleasePoolPush();
  v9 = WeakRetained;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543618;
    v25 = v11;
    v26 = 2112;
    v27 = v6;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Thread credentials retrieved with error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v8);
  if (!v9)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543362;
      v25 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_ERROR, "%{public}@HMMTRAccessoryServer deallocated before receiving Thread credentials", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v12);
    dispatch_group_leave(*(a1 + 32));
  }

  v18[0] = MEMORY[0x277D85DD0];
  v18[1] = 3221225472;
  v18[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_890;
  v18[3] = &unk_2786F0170;
  v19 = v6;
  v20 = v5;
  v21 = v9;
  v23 = *(a1 + 48);
  v22 = *(a1 + 32);
  v15 = v5;
  v16 = v6;
  [v9 dispatchBlock:v18];

  v17 = *MEMORY[0x277D85DE8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_892(uint64_t a1)
{
  v44 = *MEMORY[0x277D85DE8];
  WeakRetained = objc_loadWeakRetained((a1 + 64));
  if (!*(*(*(a1 + 48) + 8) + 40))
  {
    v4 = objc_autoreleasePoolPush();
    v5 = WeakRetained;
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      *buf = 138543362;
      v39 = v7;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials from extended PAN ID", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    v8 = [*(*(*(a1 + 56) + 8) + 40) activeOperationalDataSet];
    [*(a1 + 32) setThreadOperationalDataset:v8];

    v9 = objc_autoreleasePoolPush();
    v10 = v5;
    v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = HMFGetLogIdentifier();
      v13 = [*(a1 + 32) threadOperationalDataset];
      *buf = 138543618;
      v39 = v12;
      v40 = 2112;
      v41 = v13;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_DEBUG, "%{public}@Using activeOperationalDataset buffer %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v9);
    v14 = objc_autoreleasePoolPush();
    v15 = v10;
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      v18 = [v15 nodeID];
      v19 = [*(a1 + 40) extendedPANID];
      *buf = 138543874;
      v39 = v17;
      v40 = 2112;
      v41 = v18;
      v42 = 2112;
      v43 = v19;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@) with selected network:%@", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v14);
    v20 = [v15 deviceController];
    if (v20)
    {
      v21 = [v15 nodeID];
      v22 = [v15 controllerWrapper];
      v23 = [v22 startupParams];
      v24 = [v23 operationalCertificateIssuer];

      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v25 = v24;
      }

      else
      {
        v25 = 0;
      }

      v26 = v25;

      [v26 setCommissioneeNodeID:v21];
      v27 = [v15 nodeID];
      v28 = [v27 unsignedLongLongValue];
      v29 = *(a1 + 32);
      v37 = 0;
      [v20 commissionDevice:v28 commissioningParams:v29 error:&v37];
      v30 = v37;

      v31 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:v30];
      if (v30)
      {
        [v15 setCommissionCompletePending:0];
LABEL_16:
        v32 = objc_autoreleasePoolPush();
        v33 = v15;
        v34 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          v35 = HMFGetLogIdentifier();
          *buf = 138543618;
          v39 = v35;
          v40 = 2112;
          v41 = v30;
          _os_log_impl(&dword_22AEAE000, v34, OS_LOG_TYPE_ERROR, "%{public}@Commissioning failed: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v32);
        [v33 _pairingComplete:v30 context:v31];

        goto LABEL_20;
      }

      [v15 setCommissionCompletePending:1];
    }

    else
    {
      v30 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      v31 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:6 error:v30];
      if (v30)
      {
        goto LABEL_16;
      }
    }

LABEL_20:

    goto LABEL_21;
  }

  v3 = [HMMTRAccessoryPairingEndContext otherContextWithStep:4 error:?];
  [WeakRetained _pairingComplete:*(*(*(a1 + 48) + 8) + 40) context:v3];

LABEL_21:
  v36 = *MEMORY[0x277D85DE8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_890(uint64_t a1)
{
  v16 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32) || (v8 = *(a1 + 40)) == 0)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 48);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 32);
      v12 = 138543618;
      v13 = v5;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory Server failed to obtain Thread credentials for selected extended PAN ID... Error: %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v2);
    if (*(a1 + 32))
    {
      [MEMORY[0x277CCA9B8] hapErrorWithCode:30 description:0 reason:0 suggestion:0 underlyingError:?];
    }

    else
    {
      [MEMORY[0x277CCA9B8] hapErrorWithCode:30];
    }
    v7 = ;
    v9 = *(*(a1 + 64) + 8);
    v10 = *(v9 + 40);
    *(v9 + 40) = v7;
  }

  else
  {
    objc_storeStrong((*(*(a1 + 72) + 8) + 40), v8);
  }

  dispatch_group_leave(*(a1 + 56));
  v11 = *MEMORY[0x277D85DE8];
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2_888(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32))
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 40);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 32);
      v8 = 138543618;
      v9 = v5;
      v10 = 2112;
      v11 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch additional Thread network information - aborting pairing: %@", &v8, 0x16u);
    }

    objc_autoreleasePoolPop(v2);
    objc_storeStrong((*(*(a1 + 56) + 8) + 40), *(a1 + 32));
  }

  dispatch_group_leave(*(a1 + 48));
  v7 = *MEMORY[0x277D85DE8];
}

- (void)_onWiFiScanResults:(id)results
{
  selfCopy = self;
  v36 = *MEMORY[0x277D85DE8];
  resultsCopy = results;
  v25 = [MEMORY[0x277CBEB18] arrayWithCapacity:{objc_msgSend(resultsCopy, "count")}];
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  obj = resultsCopy;
  v4 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
  if (v4)
  {
    v5 = v4;
    v6 = *v28;
    do
    {
      v7 = 0;
      do
      {
        if (*v28 != v6)
        {
          objc_enumerationMutation(obj);
        }

        v8 = *(*(&v27 + 1) + 8 * v7);
        v9 = objc_alloc(MEMORY[0x277CD55E8]);
        ssid = [v8 ssid];
        rssi = [v8 rssi];
        security = [v8 security];
        unsignedCharValue = [security unsignedCharValue];
        wiFiBand = [v8 wiFiBand];
        v15 = [v9 initWithSSID:ssid rssi:rssi security:unsignedCharValue band:{objc_msgSend(wiFiBand, "unsignedCharValue")}];
        [v25 addObject:v15];

        ++v7;
      }

      while (v5 != v7);
      v5 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
    }

    while (v5);
  }

  v16 = objc_autoreleasePoolPush();
  v17 = selfCopy;
  v18 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    v19 = HMFGetLogIdentifier();
    v20 = [v25 count];
    *buf = 138543618;
    v32 = v19;
    v33 = 2048;
    v34 = v20;
    _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Calling scan results handler with %lu scan results", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v16);
  stageWiFiScanResultsHandler = [(HMMTRAccessoryServer *)v17 stageWiFiScanResultsHandler];
  v26[0] = MEMORY[0x277D85DD0];
  v26[1] = 3221225472;
  v26[2] = __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke;
  v26[3] = &unk_2786F0120;
  v26[4] = v17;
  (stageWiFiScanResultsHandler)[2](stageWiFiScanResultsHandler, v25, v26);

  v22 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = [*(a1 + 32) clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke_2;
  v7[3] = &unk_2786EF328;
  v5 = *(a1 + 32);
  v8 = v3;
  v9 = v5;
  v6 = v3;
  dispatch_async(v4, v7);
}

void __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke_2(uint64_t a1)
{
  v44 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32))
  {
    v2 = objc_alloc_init(MEMORY[0x277CD5300]);
    v3 = [*(a1 + 40) browser];
    v4 = [v3 attestationStatus];
    [v4 populateDelegate:v2];

    if (![*(a1 + 40) _populateCommissioningParameterCountryCode:v2])
    {
LABEL_22:

      goto LABEL_23;
    }

    v5 = [*(a1 + 32) ssid];
    [v2 setWifiSSID:v5];

    v6 = [*(a1 + 32) credentials];
    [v2 setWifiCredentials:v6];

    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 40);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      v11 = [*(a1 + 40) nodeID];
      v12 = [*(a1 + 32) ssid];
      *buf = 138543874;
      v39 = v10;
      v40 = 2112;
      v41 = v11;
      v42 = 2112;
      v43 = v12;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@) with selected network:%@", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v7);
    v13 = [*(a1 + 40) deviceController];
    if (v13)
    {
      v14 = [*(a1 + 40) nodeID];
      v15 = [*(a1 + 40) controllerWrapper];
      v16 = [v15 startupParams];
      v17 = [v16 operationalCertificateIssuer];

      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v18 = v17;
      }

      else
      {
        v18 = 0;
      }

      v19 = v18;

      [v19 setCommissioneeNodeID:v14];
      v20 = [*(a1 + 40) nodeID];
      v37 = 0;
      [v13 commissionDevice:objc_msgSend(v20 commissioningParams:"unsignedLongLongValue") error:{v2, &v37}];
      v21 = v37;

      if (!v21)
      {
        [*(a1 + 40) setCommissionCompletePending:1];
        goto LABEL_21;
      }

      v22 = objc_autoreleasePoolPush();
      v23 = *(a1 + 40);
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v25 = HMFGetLogIdentifier();
        *buf = 138543618;
        v39 = v25;
        v40 = 2112;
        v41 = v21;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_ERROR, "%{public}@Commissioning failed: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v22);
      [*(a1 + 40) setCommissionCompletePending:0];
      v26 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:v21];
    }

    else
    {
      v31 = objc_autoreleasePoolPush();
      v32 = *(a1 + 40);
      v33 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        v34 = HMFGetLogIdentifier();
        *buf = 138543362;
        v39 = v34;
        _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to commission", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v31);
      v21 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      v26 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v21];
    }

    v35 = v26;
    [*(a1 + 40) _pairingComplete:v21 context:v26];

LABEL_21:
    goto LABEL_22;
  }

  v27 = objc_autoreleasePoolPush();
  v28 = *(a1 + 40);
  v29 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
  {
    v30 = HMFGetLogIdentifier();
    *buf = 138543362;
    v39 = v30;
    _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@No network selection from WiFi scan result. Falling back to default network credentials collection.", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v27);
  [*(a1 + 40) _collectNetworkCredentials:0];
LABEL_23:
  v36 = *MEMORY[0x277D85DE8];
}

- (void)_onNetworkScanResults:(id)results
{
  v18 = *MEMORY[0x277D85DE8];
  resultsCopy = results;
  wiFiScanResults = [resultsCopy wiFiScanResults];
  if (wiFiScanResults)
  {

    goto LABEL_4;
  }

  threadScanResults = [resultsCopy threadScanResults];

  if (threadScanResults)
  {
LABEL_4:
    wiFiScanResults2 = [resultsCopy wiFiScanResults];

    if (wiFiScanResults2)
    {
      wiFiScanResults3 = [resultsCopy wiFiScanResults];
      [(HMMTRAccessoryServer *)self _onWiFiScanResults:wiFiScanResults3];
    }

    else
    {
      threadScanResults2 = [resultsCopy threadScanResults];

      if (!threadScanResults2)
      {
        _HMFPreconditionFailure();
      }

      wiFiScanResults3 = [resultsCopy threadScanResults];
      [(HMMTRAccessoryServer *)self _onThreadScanResults:wiFiScanResults3];
    }

    goto LABEL_11;
  }

  v10 = objc_autoreleasePoolPush();
  selfCopy = self;
  v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v13 = HMFGetLogIdentifier();
    v16 = 138543362;
    v17 = v13;
    _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@Neither WiFi nor Thread scan results present in scan response", &v16, 0xCu);
  }

  objc_autoreleasePoolPop(v10);
  wiFiScanResults3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:11 userInfo:0];
  v14 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:wiFiScanResults3];
  [(HMMTRAccessoryServer *)selfCopy _pairingComplete:wiFiScanResults3 context:v14];

LABEL_11:
  v15 = *MEMORY[0x277D85DE8];
}

- (void)_requestAccessoryNetworkScanWithCompletionHandler:(id)handler
{
  v23 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  deviceController = [(HMMTRAccessoryServer *)self deviceController];
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  v18 = 0;
  v7 = [deviceController getDeviceBeingCommissioned:objc_msgSend(nodeID error:{"unsignedLongLongValue"), &v18}];
  v8 = v18;

  if (v7)
  {
    v15[0] = MEMORY[0x277D85DD0];
    v15[1] = 3221225472;
    v15[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke;
    v15[3] = &unk_2786F0F20;
    v15[4] = self;
    v17 = handlerCopy;
    v16 = v7;
    [(HMMTRAccessoryServer *)self _getCommissioneeNetworkCommissioningClusterEndpointWithDevice:v16 completion:v15];
  }

  else
  {
    v9 = objc_autoreleasePoolPush();
    selfCopy = self;
    v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = HMFGetLogIdentifier();
      *buf = 138543618;
      v20 = v12;
      v21 = 2112;
      v22 = v8;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get device being commissioned for network scanning: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v9);
    if (!v8)
    {
      v8 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
    }

    v13 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v8];
    (*(handlerCopy + 2))(handlerCopy, 0, v8, v13);
  }

  v14 = *MEMORY[0x277D85DE8];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v31 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v5)
  {
    v7 = objc_alloc(MEMORY[0x277CD5200]);
    v8 = *(a1 + 40);
    v9 = [v5 unsignedShortValue];
    v10 = [*(a1 + 32) clientQueue];
    v11 = [v7 initWithDevice:v8 endpoint:v9 queue:v10];

    if (v11)
    {
      v24[0] = MEMORY[0x277D85DD0];
      v24[1] = 3221225472;
      v24[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_871;
      v24[3] = &unk_2786F0F20;
      v24[4] = *(a1 + 32);
      v26 = *(a1 + 48);
      v12 = v11;
      v25 = v12;
      [v12 readAttributeFeatureMapWithCompletionHandler:v24];
    }

    else
    {
      v17 = objc_autoreleasePoolPush();
      v18 = *(a1 + 32);
      v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v20 = HMFGetLogIdentifier();
        *buf = 138543362;
        v28 = v20;
        _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@Network commissioning cluster init failed for scanning", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v17);
      v21 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:11 userInfo:0];
      v22 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:v21];
      (*(*(a1 + 48) + 16))();

      v12 = 0;
    }
  }

  else
  {
    v13 = objc_autoreleasePoolPush();
    v14 = *(a1 + 32);
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      *buf = 138543618;
      v28 = v16;
      v29 = 2112;
      v30 = v6;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster not found for scanning: %@. Returning empty scan results.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v13);
    v12 = objc_alloc_init(MEMORY[0x277CD5438]);
    [v12 setWiFiScanResults:MEMORY[0x277CBEBF8]];
    (*(*(a1 + 48) + 16))();
  }

  v23 = *MEMORY[0x277D85DE8];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_871(id *a1, void *a2, void *a3)
{
  v70 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (!v5)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = a1[4];
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v67 = v18;
      v68 = 2112;
      v69 = v6;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get network commissioning cluster features for scanning: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v19 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
    v20 = *(a1[6] + 2);
    goto LABEL_39;
  }

  v7 = [v5 unsignedIntegerValue];
  v8 = v7 & 1;
  v9 = [v5 unsignedIntegerValue];
  v10 = v9;
  if ((v7 & 1) == 0 || (v9 & 2) != 0)
  {
    if ((v9 & 2) != 0)
    {
      v21 = objc_autoreleasePoolPush();
      v22 = a1[4];
      v23 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        v24 = HMFGetLogIdentifier();
        *buf = 138543362;
        v67 = v24;
        _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_INFO, "%{public}@Setting linkLayerType to Thread", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v21);
      [a1[4] setLinkLayerType:4];
      if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
      {
        v25 = [a1[4] defaultThreadOperationalDataset];

        v26 = objc_autoreleasePoolPush();
        v27 = a1[4];
        v28 = HMFGetOSLogHandle();
        v29 = os_log_type_enabled(v28, OS_LOG_TYPE_INFO);
        if (!v25)
        {
          if (v29)
          {
            v57 = HMFGetLogIdentifier();
            *buf = 138543362;
            v67 = v57;
            _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_INFO, "%{public}@Default thread operational dataset is not available. Will inform browser later to start thread if needed when operational dataset is available", buf, 0xCu);
          }

          objc_autoreleasePoolPop(v26);
          [a1[4] setDeferStartThreadForPairing:1];
          if (!v8)
          {
            goto LABEL_21;
          }

          goto LABEL_19;
        }

        if (v29)
        {
          v30 = HMFGetLogIdentifier();
          *buf = 138543362;
          v67 = v30;
          _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_INFO, "%{public}@Default thread operational dataset is available. Proceed with informing browser to start thread if needed", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v26);
        v31 = [a1[4] browser];
        v32 = [a1[4] fabricUUID];
        v33 = [a1[4] nodeID];
        [v31 handlePairingForThreadAccessoryWithTargetFabricUUID:v32 nodeID:v33];
      }
    }

    if (!v8)
    {
      goto LABEL_21;
    }
  }

  else
  {
    v11 = objc_autoreleasePoolPush();
    v12 = a1[4];
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543362;
      v67 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Setting linkLayerType to WiFi", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v11);
    [a1[4] setLinkLayerType:1];
  }

LABEL_19:
  v34 = [a1[4] stageWiFiScanResultsHandler];
  if (v34 || ![a1[4] _controllerIsOnWiFiNetworkWhichSupportsBothBands])
  {

    goto LABEL_27;
  }

LABEL_21:
  v35 = [a1[4] stageThreadScanResultsHandler];

  if (!v35 || (v10 & 2) == 0)
  {
    v36 = objc_autoreleasePoolPush();
    v37 = a1[4];
    v38 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      v39 = HMFGetLogIdentifier();
      *buf = 138543618;
      v67 = v39;
      v68 = 2112;
      v69 = v5;
      _os_log_impl(&dword_22AEAE000, v38, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster feature (featureMap: %@) doesn't require scanning for current request. Returning empty scan results.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v36);
    v40 = objc_alloc_init(MEMORY[0x277CD5438]);
    v19 = v40;
    v41 = MEMORY[0x277CBEBF8];
LABEL_37:
    [v40 setWiFiScanResults:v41];
    goto LABEL_38;
  }

LABEL_27:
  if ([a1[4] stageNetworkScanRequested])
  {
    v62[0] = MEMORY[0x277D85DD0];
    v62[1] = 3221225472;
    v62[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_872;
    v62[3] = &unk_2786F0EA8;
    v42 = a1[5];
    v43 = a1[4];
    v63 = v42;
    v64 = v43;
    v65 = a1[6];
    v44 = MEMORY[0x2318887D0](v62);
    v45 = [a1[4] stageWiFiScanResultsHandler];
    v46 = v45;
    if (v45 && v8)
    {
    }

    else
    {
      v53 = [a1[4] stageThreadScanResultsHandler];

      if (!v53 || (v10 & 2) == 0)
      {
        v54 = a1[4];
        v55 = a1[5];
        v58[0] = MEMORY[0x277D85DD0];
        v58[1] = 3221225472;
        v58[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2_878;
        v58[3] = &unk_2786F00F8;
        v58[4] = v54;
        v61 = v8;
        v59 = a1[6];
        v60 = v44;
        [v54 _getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:v55 completion:v58];

        goto LABEL_44;
      }
    }

    v44[2](v44);
LABEL_44:

    v19 = v63;
    goto LABEL_45;
  }

  v47 = objc_autoreleasePoolPush();
  v48 = a1[4];
  v49 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
  {
    v50 = HMFGetLogIdentifier();
    v51 = v50;
    v52 = "WiFi";
    if (!v8)
    {
      v52 = "Thread";
    }

    *buf = 138543618;
    v67 = v50;
    v68 = 2080;
    v69 = v52;
    _os_log_impl(&dword_22AEAE000, v49, OS_LOG_TYPE_INFO, "%{public}@Network scanning was not requested by upper layer. Returning empty scan results for %s.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v47);
  v40 = objc_alloc_init(MEMORY[0x277CD5438]);
  v19 = v40;
  v41 = MEMORY[0x277CBEBF8];
  if (v8)
  {
    goto LABEL_37;
  }

  [v40 setThreadScanResults:MEMORY[0x277CBEBF8]];
LABEL_38:
  v20 = *(a1[6] + 2);
LABEL_39:
  v20();
LABEL_45:

  v56 = *MEMORY[0x277D85DE8];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_872(uint64_t a1)
{
  v4[0] = MEMORY[0x277D85DD0];
  v4[1] = 3221225472;
  v4[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2;
  v4[3] = &unk_2786F0F20;
  v3 = *(a1 + 32);
  v2 = v3.i64[0];
  v5 = vextq_s8(v3, v3, 8uLL);
  v6 = *(a1 + 48);
  [v2 readAttributeScanMaxTimeSecondsWithCompletionHandler:v4];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2_878(uint64_t a1, int a2, void *a3)
{
  v15 = *MEMORY[0x277D85DE8];
  v5 = a3;
  if (v5 || !a2)
  {
    (*(*(a1 + 48) + 16))();
  }

  else
  {
    v6 = objc_autoreleasePoolPush();
    v7 = *(a1 + 32);
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v13 = 138543362;
      v14 = v9;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Commissionee already has a commissioned network. Skip network scanning.", &v13, 0xCu);
    }

    objc_autoreleasePoolPop(v6);
    v10 = objc_alloc_init(MEMORY[0x277CD5438]);
    v11 = v10;
    if (*(a1 + 56) == 1)
    {
      [v10 setWiFiScanResults:MEMORY[0x277CBEBF8]];
    }

    else
    {
      [v10 setThreadScanResults:MEMORY[0x277CBEBF8]];
    }

    (*(*(a1 + 40) + 16))();
  }

  v12 = *MEMORY[0x277D85DE8];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v25 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v5)
  {
    v7 = v5;
  }

  else
  {
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543618;
      v22 = v11;
      v23 = 2112;
      v24 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get scan max time from device: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v8);
    v7 = &unk_283EE8C58;
  }

  v12 = objc_alloc_init(MEMORY[0x277CD5430]);
  [v12 setServerSideProcessingTimeout:v7];
  v13 = objc_autoreleasePoolPush();
  v14 = *(a1 + 32);
  v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    v16 = HMFGetLogIdentifier();
    *buf = 138543618;
    v22 = v16;
    v23 = 2112;
    v24 = v7;
    _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Sending scan network command with timeout: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v13);
  v19[0] = MEMORY[0x277D85DD0];
  v19[1] = 3221225472;
  v19[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_876;
  v19[3] = &unk_2786F00D0;
  v17 = *(a1 + 40);
  v20 = *(a1 + 48);
  [v17 scanNetworksWithParams:v12 completionHandler:v19];
  [*(a1 + 32) _notifyDelegateOfPairingProgress:17];

  v18 = *MEMORY[0x277D85DE8];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_876(uint64_t a1, void *a2, void *a3)
{
  v5 = a3;
  v6 = a2;
  v7 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v5];
  (*(*(a1 + 32) + 16))();
}

- (id)_convertFetchedCredentials:(id)credentials
{
  v27 = *MEMORY[0x277D85DE8];
  credentialsCopy = credentials;
  v5 = objc_alloc(MEMORY[0x277CD5540]);
  name = [credentialsCopy name];
  extendedPANID = [credentialsCopy extendedPANID];
  masterKey = [credentialsCopy masterKey];
  pSKc = [credentialsCopy PSKc];
  channel = [credentialsCopy channel];
  pANID = [credentialsCopy PANID];
  v12 = [v5 initWithNetworkName:name extendedPANID:extendedPANID masterKey:masterKey PSKc:pSKc channel:channel panID:pANID];

  v13 = objc_autoreleasePoolPush();
  selfCopy = self;
  v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    v16 = HMFGetLogIdentifier();
    networkName = [v12 networkName];
    panID = [v12 panID];
    v21 = 138543874;
    v22 = v16;
    v23 = 2112;
    v24 = networkName;
    v25 = 2112;
    v26 = panID;
    _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Converted HAPThreadNetworkMetadata to MTRThreadOperationalDataset. Got network with Name:%@ and PanID:%@", &v21, 0x20u);
  }

  objc_autoreleasePoolPop(v13);
  v19 = *MEMORY[0x277D85DE8];

  return v12;
}

- (id)_matterCredentialsFromTHCredentials:(id)credentials
{
  v22 = *MEMORY[0x277D85DE8];
  credentialsCopy = credentials;
  v5 = objc_alloc(MEMORY[0x277CD5540]);
  activeOperationalDataSet = [credentialsCopy activeOperationalDataSet];
  v7 = [v5 initWithData:activeOperationalDataSet];

  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    networkName = [v7 networkName];
    panID = [v7 panID];
    v16 = 138543874;
    v17 = v11;
    v18 = 2112;
    v19 = networkName;
    v20 = 2112;
    v21 = panID;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Converted THCredentials to MTRThreadOperationalDataset. Got network with Name:%@ and PanID:%@", &v16, 0x20u);
  }

  objc_autoreleasePoolPop(v8);
  v14 = *MEMORY[0x277D85DE8];

  return v7;
}

- (void)_populateThreadCredentials:(id)credentials completion:(id)completion
{
  v33 = *MEMORY[0x277D85DE8];
  credentialsCopy = credentials;
  completionCopy = completion;
  defaultThreadOperationalDatasetReceiveBlock = [(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetReceiveBlock];

  if (defaultThreadOperationalDatasetReceiveBlock)
  {
    defaultThreadOperationalDatasetReceiveBlock2 = [(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetReceiveBlock];
    v10 = [MEMORY[0x277CCA9B8] hapErrorWithCode:2];
    (defaultThreadOperationalDatasetReceiveBlock2)[2](defaultThreadOperationalDatasetReceiveBlock2, 0, v10);

    [(HMMTRAccessoryServer *)self setDefaultThreadOperationalDatasetReceiveBlock:0];
  }

  if ([(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetRetrieved])
  {
    defaultThreadOperationalDataset = [(HMMTRAccessoryServer *)self defaultThreadOperationalDataset];

    v12 = defaultThreadOperationalDataset == 0;
    v13 = objc_autoreleasePoolPush();
    selfCopy = self;
    v15 = HMFGetOSLogHandle();
    v16 = v15;
    if (v12)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543362;
        v30 = v21;
        _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_ERROR, "%{public}@Populating Thread credential collection error", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v13);
      v22 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:30 userInfo:0];
      v23 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v22];
      completionCopy[2](completionCopy, 0, v22, v23);
    }

    else
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        v17 = HMFGetLogIdentifier();
        defaultThreadOperationalDataset2 = [(HMMTRAccessoryServer *)selfCopy defaultThreadOperationalDataset];
        hmf_hexadecimalRepresentation = [defaultThreadOperationalDataset2 hmf_hexadecimalRepresentation];
        *buf = 138543618;
        v30 = v17;
        v31 = 2112;
        v32 = hmf_hexadecimalRepresentation;
        _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials - dataset: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v13);
      defaultThreadOperationalDataset3 = [(HMMTRAccessoryServer *)selfCopy defaultThreadOperationalDataset];
      [credentialsCopy setThreadOperationalDataset:defaultThreadOperationalDataset3];

      (completionCopy)[2](completionCopy, credentialsCopy, 0, 0);
    }
  }

  else
  {
    objc_initWeak(buf, self);
    v25[0] = MEMORY[0x277D85DD0];
    v25[1] = 3221225472;
    v25[2] = __62__HMMTRAccessoryServer__populateThreadCredentials_completion___block_invoke;
    v25[3] = &unk_2786F00A8;
    objc_copyWeak(&v28, buf);
    v26 = credentialsCopy;
    v27 = completionCopy;
    [(HMMTRAccessoryServer *)self setDefaultThreadOperationalDatasetReceiveBlock:v25];

    objc_destroyWeak(&v28);
    objc_destroyWeak(buf);
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __62__HMMTRAccessoryServer__populateThreadCredentials_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v17 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 48));
  v8 = objc_autoreleasePoolPush();
  v9 = WeakRetained;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    v15 = 138543362;
    v16 = v11;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials", &v15, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  if (v5)
  {
    [*(a1 + 32) setThreadOperationalDataset:v5];
  }

  if (v6)
  {
    v12 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v6];
  }

  else
  {
    v12 = 0;
  }

  if (v5)
  {
    v13 = *(a1 + 32);
  }

  else
  {
    v13 = 0;
  }

  (*(*(a1 + 40) + 16))(*(a1 + 40), v13, v6, v12);

  v14 = *MEMORY[0x277D85DE8];
}

- (void)_prepareThreadCredentials
{
  v18 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Collecting Thread Credentials...", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  [(HMMTRAccessoryServer *)selfCopy setDefaultThreadOperationalDataset:0];
  [(HMMTRAccessoryServer *)selfCopy setDefaultThreadOperationalDatasetRetrieved:0];
  [(HMMTRAccessoryServer *)selfCopy setDeferStartThreadForPairing:0];
  [(HMMTRAccessoryServer *)selfCopy _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameRetrieveThreadCredentials"];
  [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingProgress:30];
  if ([(HMMTRAccessoryServer *)selfCopy pairedState]== 1)
  {
    v7 = [objc_alloc(MEMORY[0x277CE1968]) initWithKeychainAccessGroup:@"com.apple.thread.network"];
    objc_initWeak(buf, selfCopy);
    v11[0] = MEMORY[0x277D85DD0];
    v11[1] = 3221225472;
    v11[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_864;
    v11[3] = &unk_2786F0080;
    objc_copyWeak(&v13, buf);
    v8 = v7;
    v12 = v8;
    [v8 retrievePreferredCredentialsInternally:v11];

    objc_destroyWeak(&v13);
    objc_destroyWeak(buf);
  }

  else
  {
    objc_initWeak(buf, selfCopy);
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    v14[0] = MEMORY[0x277D85DD0];
    v14[1] = 3221225472;
    v14[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke;
    v14[3] = &unk_2786F0058;
    objc_copyWeak(&v15, buf);
    [browser fetchPreferredThreadCredentialsForServer:selfCopy withCompletion:v14];

    objc_destroyWeak(&v15);
    objc_destroyWeak(buf);
  }

  v10 = *MEMORY[0x277D85DE8];
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke(uint64_t a1, void *a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v8 = WeakRetained;
  if (v5 && !v6 && WeakRetained)
  {
    if (isFeatureMatteriPhoneOnlyPairingControlEnabled() && ([v5 activeOperationalDataSet], v9 = objc_claimAutoreleasedReturnValue(), v9, v9))
    {
      v10 = [v5 activeOperationalDataSet];
      v11 = objc_autoreleasePoolPush();
      v12 = v8;
      v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = HMFGetLogIdentifier();
        v15 = [v10 hmf_hexadecimalRepresentation];
        *buf = 138543618;
        v26 = v14;
        v27 = 2112;
        v28 = v15;
        v16 = "%{public}@Retrieved Thread operational dataset (unpaired,activeOperationalDataSet): %@";
LABEL_12:
        _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, v16, buf, 0x16u);
      }
    }

    else
    {
      v18 = [v8 _convertFetchedCredentials:v5];
      v10 = [v18 data];

      v11 = objc_autoreleasePoolPush();
      v19 = v8;
      v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = HMFGetLogIdentifier();
        v15 = [v10 hmf_hexadecimalRepresentation];
        *buf = 138543618;
        v26 = v14;
        v27 = 2112;
        v28 = v15;
        v16 = "%{public}@Retrieved Thread operational dataset (unpaired,HAPThreadNetworkMetadata): %@";
        goto LABEL_12;
      }
    }

    objc_autoreleasePoolPop(v11);
    v20 = [v8 clientQueue];
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_861;
    v22[3] = &unk_2786EF328;
    v22[4] = v8;
    v23 = v10;
    v17 = v10;
    dispatch_async(v20, v22);

    goto LABEL_14;
  }

  [WeakRetained _notifyDelegateOfPairingProgress:32 error:v6];
  if (v8)
  {
    v17 = [v8 clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2;
    block[3] = &unk_2786F0CA8;
    block[4] = v8;
    dispatch_async(v17, block);
LABEL_14:
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_864(uint64_t a1, void *a2, void *a3, void *a4)
{
  v29 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((a1 + 40));
  v11 = WeakRetained;
  if (v7 && !v9 && WeakRetained)
  {
    v12 = [WeakRetained _matterCredentialsFromTHCredentials:v7];
    v13 = [v12 data];

    v14 = objc_autoreleasePoolPush();
    v15 = v11;
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      v18 = [v13 hmf_hexadecimalRepresentation];
      *buf = 138543618;
      v26 = v17;
      v27 = 2112;
      v28 = v18;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Retrieved Thread operational dataset (staging): %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v14);
    v19 = [v15 clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_866;
    block[3] = &unk_2786EF328;
    block[4] = v15;
    v23 = v13;
    v20 = v13;
    dispatch_async(v19, block);

    goto LABEL_9;
  }

  [WeakRetained _notifyDelegateOfPairingProgress:32 error:v9];
  if (v11)
  {
    v20 = [v11 clientQueue];
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2_865;
    v24[3] = &unk_2786F0CA8;
    v24[4] = v11;
    dispatch_async(v20, v24);
LABEL_9:
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2_865(uint64_t a1)
{
  [*(a1 + 32) setDefaultThreadOperationalDataset:0];
  [*(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  v2 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    v4 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    v3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:30 userInfo:0];
    v4[2](v4, 0, v3);
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_866(uint64_t a1)
{
  [*(a1 + 32) _notifyDelegateOfPairingProgress:31];
  [*(a1 + 32) setDefaultThreadOperationalDataset:*(a1 + 40)];
  [*(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  v2 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    v3 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    (*(v3 + 2))(v3, *(a1 + 40), 0);
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2(uint64_t a1)
{
  [*(a1 + 32) setDefaultThreadOperationalDataset:0];
  [*(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  v2 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    v4 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    v3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:30 userInfo:0];
    v4[2](v4, 0, v3);
  }
}

uint64_t __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_861(uint64_t a1)
{
  v15 = *MEMORY[0x277D85DE8];
  [*(a1 + 32) _notifyDelegateOfPairingProgress:31];
  [*(a1 + 32) setDefaultThreadOperationalDataset:*(a1 + 40)];
  [*(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  v2 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    v3 = [*(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    v3[2](v3, *(a1 + 40), 0);
  }

  result = isFeatureMatteriPhoneOnlyPairingControlEnabled();
  if (result)
  {
    result = [*(a1 + 32) deferStartThreadForPairing];
    if (result)
    {
      v5 = objc_autoreleasePoolPush();
      v6 = *(a1 + 32);
      v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        v8 = HMFGetLogIdentifier();
        v13 = 138543362;
        v14 = v8;
        _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Proceed to inform browser to start thread if needed since operational dataset is now available", &v13, 0xCu);
      }

      objc_autoreleasePoolPop(v5);
      v9 = [*(a1 + 32) browser];
      v10 = [*(a1 + 32) fabricUUID];
      v11 = [*(a1 + 32) nodeID];
      [v9 handlePairingForThreadAccessoryWithTargetFabricUUID:v10 nodeID:v11];

      result = [*(a1 + 32) setDeferStartThreadForPairing:0];
    }
  }

  v12 = *MEMORY[0x277D85DE8];
  return result;
}

- (id)_endCurrentMetricTimeWithName:(id)name
{
  v35 = *MEMORY[0x277D85DE8];
  nameCopy = name;
  v5 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  pairingDurationDictionary = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
  v7 = [pairingDurationDictionary objectForKey:nameCopy];

  if (v7)
  {
    pairingDurationDictionary2 = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
    [pairingDurationDictionary2 removeObjectForKey:nameCopy];

    v9 = MEMORY[0x277CCABB0];
    date = [MEMORY[0x277CBEAA8] date];
    [v7 durationWithDate:date];
    v11 = [v9 numberWithDouble:?];

    [v11 doubleValue];
    v13 = v12;
    maxMetricDuration = [(HMMTRAccessoryServer *)self maxMetricDuration];
    duration = [maxMetricDuration duration];
    [duration doubleValue];
    v17 = v16;

    if (v13 > v17)
    {
      v18 = [HMMTRDuration alloc];
      name = [v7 name];
      v20 = [(HMMTRDuration *)v18 initWithName:name duration:v11];
      [(HMMTRAccessoryServer *)self setMaxMetricDuration:v20];

      maxMetricDuration2 = [(HMMTRAccessoryServer *)self maxMetricDuration];
      name2 = [maxMetricDuration2 name];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventMaxDurationName" value:name2];

      maxMetricDuration3 = [(HMMTRAccessoryServer *)self maxMetricDuration];
      duration2 = [maxMetricDuration3 duration];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds" value:duration2];
    }

    os_unfair_lock_unlock((self + v5));
  }

  else
  {
    v25 = objc_autoreleasePoolPush();
    selfCopy = self;
    v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = HMFGetLogIdentifier();
      v31 = 138543618;
      v32 = v28;
      v33 = 2112;
      v34 = nameCopy;
      _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_ERROR, "%{public}@failed to find metric %@ to complete", &v31, 0x16u);
    }

    objc_autoreleasePoolPop(v25);
    os_unfair_lock_unlock((self + v5));
    v11 = 0;
  }

  v29 = *MEMORY[0x277D85DE8];

  return v11;
}

- (void)_startCurrentMetricTimeWithName:(id)name
{
  nameCopy = name;
  v4 = [HMMTRMetricBundle alloc];
  date = [MEMORY[0x277CBEAA8] date];
  v6 = [(HMMTRMetricBundle *)v4 initWithTime:date name:nameCopy];

  v7 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  pairingDurationDictionary = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
  [pairingDurationDictionary setObject:v6 forKeyedSubscript:nameCopy];

  os_unfair_lock_unlock((self + v7));
}

- (void)_populateWifiCredentials:(id)credentials scanResults:(id)results completion:(id)completion
{
  v119 = *MEMORY[0x277D85DE8];
  credentialsCopy = credentials;
  resultsCopy = results;
  completionCopy = completion;
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:5];
  currentWiFiNetworkInfo = [(HMMTRAccessoryServer *)self currentWiFiNetworkInfo];
  v10 = objc_autoreleasePoolPush();
  selfCopy = self;
  v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    v13 = HMFGetLogIdentifier();
    *buf = 138543362;
    v113 = v13;
    _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, "%{public}@Collecting WiFi credentials for the accessory", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v10);
  [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingProgress:14];
  v14 = [currentWiFiNetworkInfo objectForKey:@"ssid"];

  if (v14)
  {
    v87 = credentialsCopy;
    v15 = MEMORY[0x277CBEB18];
    wiFiScanResults = [resultsCopy wiFiScanResults];
    v17 = [v15 arrayWithCapacity:{objc_msgSend(wiFiScanResults, "count")}];

    v108 = 0u;
    v109 = 0u;
    v106 = 0u;
    v107 = 0u;
    v88 = resultsCopy;
    obj = [resultsCopy wiFiScanResults];
    v18 = [obj countByEnumeratingWithState:&v106 objects:v118 count:16];
    v93 = v17;
    if (v18)
    {
      v19 = v18;
      v20 = *v107;
      v21 = 0x277CCA000uLL;
      do
      {
        v22 = 0;
        v94 = v19;
        do
        {
          if (*v107 != v20)
          {
            objc_enumerationMutation(obj);
          }

          v23 = *(*(&v106 + 1) + 8 * v22);
          v24 = objc_alloc(*(v21 + 3240));
          ssid = [v23 ssid];
          v26 = [v24 initWithData:ssid encoding:4];

          if (v26)
          {
            [v17 addObject:v26];
          }

          else
          {
            v27 = v21;
            v28 = objc_autoreleasePoolPush();
            v29 = selfCopy;
            v30 = selfCopy;
            v31 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              v32 = HMFGetLogIdentifier();
              ssid2 = [v23 ssid];
              *buf = 138543618;
              v113 = v32;
              v114 = 2112;
              v115 = ssid2;
              _os_log_impl(&dword_22AEAE000, v31, OS_LOG_TYPE_ERROR, "%{public}@Unexpected non-UTF8 SSID was skipped: %@", buf, 0x16u);

              v17 = v93;
            }

            objc_autoreleasePoolPop(v28);
            selfCopy = v29;
            v21 = v27;
            v19 = v94;
          }

          ++v22;
        }

        while (v19 != v22);
        v19 = [obj countByEnumeratingWithState:&v106 objects:v118 count:16];
      }

      while (v19);
    }

    v34 = [currentWiFiNetworkInfo objectForKeyedSubscript:@"ssid"];
    v35 = objc_autoreleasePoolPush();
    v36 = selfCopy;
    v37 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      v38 = HMFGetLogIdentifier();
      *buf = 138543874;
      v113 = v38;
      v114 = 2112;
      v115 = v34;
      v116 = 2112;
      v117 = v17;
      _os_log_impl(&dword_22AEAE000, v37, OS_LOG_TYPE_INFO, "%{public}@Current network: %@, scanned networks: %@", buf, 0x20u);
    }

    v89 = v36;
    objc_autoreleasePoolPop(v35);
    if (([v17 containsObject:v34] & 1) != 0 || !objc_msgSend(v17, "count"))
    {
      v53 = currentWiFiNetworkInfo;
      credentialsCopy = v87;
    }

    else
    {
      v39 = [MEMORY[0x277CBEB18] arrayWithCapacity:{objc_msgSend(v17, "count")}];
      v102 = 0u;
      v103 = 0u;
      v104 = 0u;
      v105 = 0u;
      v40 = v17;
      v41 = [v40 countByEnumeratingWithState:&v102 objects:v111 count:16];
      if (v41)
      {
        v42 = v41;
        v43 = *v103;
        do
        {
          for (i = 0; i != v42; ++i)
          {
            if (*v103 != v43)
            {
              objc_enumerationMutation(v40);
            }

            v45 = *(*(&v102 + 1) + 8 * i);
            v46 = [v34 commonPrefixWithString:v45 options:10];
            if ([v46 length])
            {
              [v39 addObject:v45];
            }
          }

          v42 = [v40 countByEnumeratingWithState:&v102 objects:v111 count:16];
        }

        while (v42);
      }

      v47 = objc_autoreleasePoolPush();
      v48 = v89;
      v49 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
      {
        v50 = HMFGetLogIdentifier();
        *buf = 138543618;
        v113 = v50;
        v114 = 2112;
        v115 = v39;
        _os_log_impl(&dword_22AEAE000, v49, OS_LOG_TYPE_INFO, "%{public}@Possible compatible results: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v47);
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      obja = v39;
      v51 = [obja countByEnumeratingWithState:&v98 objects:v110 count:16];
      if (v51)
      {
        v52 = v51;
        v53 = 0;
        v54 = *v99;
        v92 = *v99;
        while (2)
        {
          v55 = 0;
          v95 = v52;
          do
          {
            if (*v99 != v54)
            {
              objc_enumerationMutation(obja);
            }

            v56 = [(HMMTRAccessoryServer *)v48 wifiNetworkInfoForSSID:*(*(&v98 + 1) + 8 * v55)];
            if (v56)
            {
              v57 = objc_autoreleasePoolPush();
              v58 = v48;
              v59 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
              {
                v60 = HMFGetLogIdentifier();
                [v56 objectForKeyedSubscript:@"ssid"];
                v61 = v48;
                v63 = v62 = v53;
                *buf = 138543618;
                v113 = v60;
                v114 = 2112;
                v115 = v63;
                _os_log_impl(&dword_22AEAE000, v59, OS_LOG_TYPE_INFO, "%{public}@Matched : %@", buf, 0x16u);

                v53 = v62;
                v48 = v61;
                v54 = v92;

                v52 = v95;
              }

              objc_autoreleasePoolPop(v57);
              if (v53)
              {

                goto LABEL_49;
              }

              v53 = v56;
            }

            ++v55;
          }

          while (v52 != v55);
          v52 = [obja countByEnumeratingWithState:&v98 objects:v110 count:16];
          if (v52)
          {
            continue;
          }

          break;
        }
      }

      else
      {
LABEL_49:
        v53 = 0;
      }

      credentialsCopy = v87;
      v17 = v93;
    }

    resultsCopy = v88;
    if (v53)
    {
      goto LABEL_55;
    }

    v69 = objc_autoreleasePoolPush();
    v70 = v89;
    v71 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
    {
      v72 = HMFGetLogIdentifier();
      *buf = 138543362;
      v113 = v72;
      _os_log_impl(&dword_22AEAE000, v71, OS_LOG_TYPE_INFO, "%{public}@No matching SSID among scan results", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v69);
    v53 = currentWiFiNetworkInfo;
    v73 = *MEMORY[0x277CFE770];
    v74 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:20 userInfo:0];
    [(HMMTRAccessoryServer *)v70 setCommissioningFailureOverridingError:v74];

    if (v53)
    {
LABEL_55:
      v75 = objc_autoreleasePoolPush();
      v76 = v89;
      v77 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
      {
        v78 = HMFGetLogIdentifier();
        v79 = [v53 objectForKeyedSubscript:@"ssid"];
        *buf = 138543618;
        v113 = v78;
        v114 = 2112;
        v115 = v79;
        _os_log_impl(&dword_22AEAE000, v77, OS_LOG_TYPE_INFO, "%{public}@Configuring with wifi ssid %@", buf, 0x16u);

        resultsCopy = v88;
      }

      objc_autoreleasePoolPop(v75);
      v80 = [v53 objectForKeyedSubscript:@"ssid"];
      v81 = [v80 dataUsingEncoding:4];
      [credentialsCopy setWifiSSID:v81];

      v82 = [v53 objectForKeyedSubscript:@"password"];
      v83 = [v82 dataUsingEncoding:4];
      [credentialsCopy setWifiCredentials:v83];

      [(HMMTRAccessoryServer *)v76 _notifyDelegateOfPairingProgress:15];
      v68 = completionCopy;
      (*(completionCopy + 2))(completionCopy, credentialsCopy, 0, 0);
    }

    else
    {
      v85 = [MEMORY[0x277CCA9B8] errorWithDomain:v73 code:20 userInfo:0];
      [(HMMTRAccessoryServer *)v70 _notifyDelegateOfPairingProgress:16 error:v85];
      v86 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v85];
      v68 = completionCopy;
      (*(completionCopy + 2))(completionCopy, 0, v85, v86);
    }
  }

  else
  {
    v64 = objc_autoreleasePoolPush();
    v65 = selfCopy;
    v66 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      v67 = HMFGetLogIdentifier();
      *buf = 138543362;
      v113 = v67;
      _os_log_impl(&dword_22AEAE000, v66, OS_LOG_TYPE_ERROR, "%{public}@Unable to send WiFi Credentials. No SSID available. Is WiFi connected?", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v64);
    v17 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CFE770] code:21 userInfo:0];
    [(HMMTRAccessoryServer *)v65 _notifyDelegateOfPairingProgress:16 error:v17];
    v34 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v17];
    v68 = completionCopy;
    (*(completionCopy + 2))(completionCopy, 0, v17, v34);
    v53 = 0;
  }

  v84 = *MEMORY[0x277D85DE8];
}

- (id)wifiNetworkInfoForSSID:(id)d
{
  v9[1] = *MEMORY[0x277D85DE8];
  v8 = @"ssid";
  v9[0] = d;
  v3 = MEMORY[0x277CBEAC0];
  dCopy = d;
  [v3 dictionaryWithObjects:v9 forKeys:&v8 count:1];

  v5 = WiFiCopyNetworkInfo();
  v6 = *MEMORY[0x277D85DE8];

  return v5;
}

- (id)currentWiFiNetworkInfo
{
  v2 = WiFiCopyCurrentNetworkInfoEx();

  return v2;
}

- (BOOL)_controllerIsOnWiFiNetworkWhichSupportsBothBands
{
  selfCopy = self;
  v41 = *MEMORY[0x277D85DE8];
  v31 = 0;
  v2 = WiFiCopyCurrentNetworkInfoEx();
  v26 = [v2 objectForKeyedSubscript:@"ssid"];
  v3 = [v2 objectForKeyedSubscript:@"rawRecord"];
  v4 = [v3 objectForKeyedSubscript:@"networkKnownBSSListKey"];

  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v5 = v4;
  v6 = [v5 countByEnumeratingWithState:&v27 objects:v40 count:16];
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = 0;
    v10 = *v28;
    while (2)
    {
      for (i = 0; i != v7; ++i)
      {
        if (*v28 != v10)
        {
          objc_enumerationMutation(v5);
        }

        v12 = [*(*(&v27 + 1) + 8 * i) objectForKeyedSubscript:{@"CHANNEL_FLAGS", selfCopy}];
        unsignedIntegerValue = [v12 unsignedIntegerValue];

        v9 |= (unsignedIntegerValue >> 3) & 1;
        v8 |= (unsignedIntegerValue >> 4) & 1;
        if (v9 & 1) != 0 && (v8)
        {
          LOBYTE(v8) = 1;
          LOBYTE(v9) = 1;
          goto LABEL_13;
        }
      }

      v7 = [v5 countByEnumeratingWithState:&v27 objects:v40 count:16];
      if (v7)
      {
        continue;
      }

      break;
    }
  }

  else
  {
    LOBYTE(v8) = 0;
    LOBYTE(v9) = 0;
  }

LABEL_13:

  v14 = objc_autoreleasePoolPush();
  v15 = selfCopy;
  v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    v17 = HMFGetLogIdentifier();
    v18 = v17;
    v19 = &stru_283ED2308;
    v20 = @" 2.4GHz";
    if ((v9 & 1) == 0)
    {
      v20 = &stru_283ED2308;
    }

    *buf = 138544130;
    v33 = v17;
    if (v8)
    {
      v19 = @" 5GHz";
    }

    v34 = 2112;
    v35 = v26;
    v36 = 2112;
    v37 = v20;
    v38 = 2112;
    v39 = v19;
    _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Current WiFi network(%@) bands%@%@", buf, 0x2Au);
  }

  objc_autoreleasePoolPop(v14);
  if (v31)
  {
    v21 = 1;
  }

  else
  {
    v21 = v26 == 0;
  }

  v22 = v21;

  v23 = *MEMORY[0x277D85DE8];
  return (v22 | v9 & v8) & 1;
}

- (id)removeNode:(id)node withPrivilge:(unsigned __int8)privilge fromExistingAclEntries:(id)entries
{
  privilgeCopy = privilge;
  v42 = *MEMORY[0x277D85DE8];
  nodeCopy = node;
  entriesCopy = entries;
  if (!nodeCopy || [nodeCopy isEqualToNumber:&unk_283EE89B8])
  {
    goto LABEL_11;
  }

  if (privilgeCopy != 5)
  {
    v10 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543362;
      v41 = v13;
      v14 = "%{public}@Current implementation is restricted to removal of admin nodes only";
      goto LABEL_9;
    }

LABEL_10:

    objc_autoreleasePoolPop(v10);
LABEL_11:
    v15 = entriesCopy;
    goto LABEL_12;
  }

  if ([HMMTRUtilities isValidCATSubject:nodeCopy])
  {
    v10 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543362;
      v41 = v13;
      v14 = "%{public}@Current implementation doesn't support removal of CAT IDs";
LABEL_9:
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, v14, buf, 0xCu);

      goto LABEL_10;
    }

    goto LABEL_10;
  }

  v34 = nodeCopy;
  array = [MEMORY[0x277CBEB18] array];
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v33 = entriesCopy;
  v19 = entriesCopy;
  v20 = [v19 countByEnumeratingWithState:&v35 objects:v39 count:16];
  if (v20)
  {
    v21 = v20;
    v22 = *v36;
    do
    {
      for (i = 0; i != v21; ++i)
      {
        if (*v36 != v22)
        {
          objc_enumerationMutation(v19);
        }

        v24 = *(*(&v35 + 1) + 8 * i);
        v25 = MEMORY[0x277CBEB58];
        subjects = [v24 subjects];
        v27 = [v25 setWithArray:subjects];

        privilege = [v24 privilege];
        integerValue = [privilege integerValue];

        if (integerValue == 5)
        {
          [v27 removeObject:v34];
        }

        allObjects = [v27 allObjects];
        [v24 setSubjects:allObjects];

        subjects2 = [v24 subjects];
        v32 = [subjects2 count];

        if (v32)
        {
          [array addObject:v24];
        }
      }

      v21 = [v19 countByEnumeratingWithState:&v35 objects:v39 count:16];
    }

    while (v21);
  }

  v15 = [array copy];
  entriesCopy = v33;
  nodeCopy = v34;
LABEL_12:

  v16 = *MEMORY[0x277D85DE8];

  return v15;
}

- (id)mergeExistingAclEntries:(id)entries withNewNodes:(id)nodes withPrivilege:(unsigned __int8)privilege
{
  privilegeCopy = privilege;
  v79 = *MEMORY[0x277D85DE8];
  entriesCopy = entries;
  nodesCopy = nodes;
  if ([nodesCopy count])
  {
    array = [MEMORY[0x277CBEB18] array];
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v74 = 0u;
    obj = nodesCopy;
    v52 = [obj countByEnumeratingWithState:&v71 objects:v78 count:16];
    if (!v52)
    {
      goto LABEL_47;
    }

    v9 = privilegeCopy;
    v48 = array;
    v49 = nodesCopy;
    v50 = *v72;
    while (1)
    {
      for (i = 0; i != v52; ++i)
      {
        if (*v72 != v50)
        {
          objc_enumerationMutation(obj);
        }

        v60 = *(*(&v71 + 1) + 8 * i);
        v59 = [HMMTRUtilities isValidCATSubject:?];
        v67 = 0u;
        v68 = 0u;
        v69 = 0u;
        v70 = 0u;
        v11 = entriesCopy;
        v12 = [v11 countByEnumeratingWithState:&v67 objects:v77 count:16];
        if (!v12)
        {

          [array addObjectsFromArray:v11];
LABEL_39:
          v34 = objc_alloc_init(MEMORY[0x277CD51A8]);
          v35 = [MEMORY[0x277CCABB0] numberWithUnsignedChar:privilegeCopy];
          [v34 setPrivilege:v35];

          [v34 setAuthMode:&unk_283EE8C28];
          v75 = v60;
          v36 = [MEMORY[0x277CBEA60] arrayWithObjects:&v75 count:1];
          [v34 setSubjects:v36];

          [array addObject:v34];
          goto LABEL_45;
        }

        v13 = v12;
        v54 = i;
        v51 = 0;
        v55 = 0;
        v14 = 0;
        v15 = *v68;
        v57 = *v68;
        v58 = v11;
        v16 = v59;
        do
        {
          v17 = 0;
          v53 = v14 + v13;
          do
          {
            if (*v68 != v15)
            {
              objc_enumerationMutation(v11);
            }

            v18 = *(*(&v67 + 1) + 8 * v17);
            privilege = [v18 privilege];
            if ([privilege integerValue] != v9)
            {
              goto LABEL_16;
            }

            v20 = v13;
            targets = [v18 targets];
            if ([targets count])
            {

LABEL_15:
              v13 = v20;
LABEL_16:

              goto LABEL_17;
            }

            authMode = [v18 authMode];
            integerValue = [authMode integerValue];

            v11 = v58;
            v24 = integerValue == 2;
            v15 = v57;
            v13 = v20;
            if (v24)
            {
              v65 = 0u;
              v66 = 0u;
              v63 = 0u;
              v64 = 0u;
              privilege = [v18 subjects];
              v25 = [privilege countByEnumeratingWithState:&v63 objects:v76 count:16];
              if (v25)
              {
                v26 = v25;
                v27 = 0;
                v28 = *v64;
                while (2)
                {
                  v29 = 0;
                  v56 = v27 + v26;
                  do
                  {
                    if (*v64 != v28)
                    {
                      objc_enumerationMutation(privilege);
                    }

                    v30 = *(*(&v63 + 1) + 8 * v29);
                    if ([v30 isEqualToNumber:v60])
                    {

                      v11 = v58;
                      array = v48;
                      [v48 addObjectsFromArray:v58];
                      nodesCopy = v49;
                      v9 = privilegeCopy;
                      i = v54;
                      goto LABEL_45;
                    }

                    if (v16)
                    {
                      if ([HMMTRUtilities isValidCATSubject:v30])
                      {
                        v62 = 0;
                        [HMMTRUtilities parseCaseAuthenticatedTag:v60 identifier:&v62 + 2 version:&v62];
                        v61 = 0;
                        v16 = v59;
                        [HMMTRUtilities parseCaseAuthenticatedTag:v30 identifier:&v61 + 2 version:&v61];
                        if (HIWORD(v62) == HIWORD(v61))
                        {

                          v32 = v58;
                          array = v48;
                          [v48 addObjectsFromArray:v58];
                          v33 = 1;
                          nodesCopy = v49;
                          v9 = privilegeCopy;
                          goto LABEL_41;
                        }
                      }
                    }

                    ++v27;
                    ++v29;
                  }

                  while (v26 != v29);
                  v26 = [privilege countByEnumeratingWithState:&v63 objects:v76 count:16];
                  v27 = v56;
                  if (v26)
                  {
                    continue;
                  }

                  break;
                }

                v55 = 1;
                v51 = v14;
                v9 = privilegeCopy;
                v15 = v57;
                v11 = v58;
              }

              else
              {
                v55 = 1;
                v51 = v14;
              }

              goto LABEL_15;
            }

LABEL_17:
            ++v14;
            ++v17;
          }

          while (v17 != v13);
          v31 = [v11 countByEnumeratingWithState:&v67 objects:v77 count:16];
          v13 = v31;
          v14 = v53;
        }

        while (v31);

        array = v48;
        [v48 addObjectsFromArray:v11];
        nodesCopy = v49;
        i = v54;
        if ((v55 & 1) == 0)
        {
          goto LABEL_39;
        }

        v27 = 0;
        v32 = v11;
        v33 = 0;
        v14 = v51;
LABEL_41:
        v37 = MEMORY[0x277CBEB18];
        v38 = [v32 objectAtIndexedSubscript:v14];
        subjects = [v38 subjects];
        v40 = [v37 arrayWithArray:subjects];

        if ((v59 & v33) == 1)
        {
          [v40 setObject:v60 atIndexedSubscript:v27];
        }

        else
        {
          [v40 addObject:v60];
        }

        v41 = [v40 copy];
        v42 = [array objectAtIndexedSubscript:v14];
        [v42 setSubjects:v41];

        i = v54;
        v11 = v58;
LABEL_45:
        entriesCopy = [array copy];

        [array removeAllObjects];
      }

      v52 = [obj countByEnumeratingWithState:&v71 objects:v78 count:16];
      if (!v52)
      {
LABEL_47:

        v43 = [entriesCopy copy];
        goto LABEL_49;
      }
    }
  }

  entriesCopy = entriesCopy;
  v43 = entriesCopy;
LABEL_49:

  v44 = *MEMORY[0x277D85DE8];

  return v43;
}

- (id)mergeExistingAclEntries:(id)entries withAdminNodes:(id)nodes regularUserNodes:(id)userNodes
{
  userNodesCopy = userNodes;
  v9 = [(HMMTRAccessoryServer *)self mergeExistingAclEntries:entries withNewNodes:nodes withPrivilege:5];
  v10 = [(HMMTRAccessoryServer *)self mergeExistingAclEntries:v9 withNewNodes:userNodesCopy withPrivilege:3];

  return v10;
}

- (void)updateAccessoryControlToRemoveAdministratorNode:(id)node completion:(id)completion
{
  v37 = *MEMORY[0x277D85DE8];
  nodeCopy = node;
  completionCopy = completion;
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543618;
    v34 = v11;
    v35 = 2112;
    v36 = nodeCopy;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to remove administrative access to %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v8);
  pairingRequest = [(HAPAccessoryServer *)selfCopy pairingRequest];
  if (pairingRequest && (v13 = pairingRequest, -[HAPAccessoryServer pairingRequest](selfCopy, "pairingRequest"), v14 = objc_claimAutoreleasedReturnValue(), v15 = [v14 isOwnerPairing], v14, v13, !v15))
  {
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
    v18 = [(HMMTRAccessoryServer *)selfCopy mtrBaseDeviceWithNodeID:nodeID controller:deviceController];

    if (v18)
    {
      v19 = objc_alloc(MEMORY[0x277CD51D8]);
      clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
      v21 = [v19 initWithDevice:v18 endpointID:&unk_283EE89B8 queue:clientQueue];

      v22 = objc_alloc_init(MEMORY[0x277CD54D8]);
      v29[0] = MEMORY[0x277D85DD0];
      v29[1] = 3221225472;
      v29[2] = __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke;
      v29[3] = &unk_2786F0030;
      v29[4] = selfCopy;
      v32 = completionCopy;
      v30 = nodeCopy;
      v31 = v21;
      v23 = v21;
      [v23 readAttributeACLWithParams:v22 completion:v29];
    }

    else
    {
      v24 = objc_autoreleasePoolPush();
      v25 = selfCopy;
      v26 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = HMFGetLogIdentifier();
        *buf = 138543362;
        v34 = v27;
        _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v24);
      v22 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
      (*(completionCopy + 2))(completionCopy, v22);
    }
  }

  else
  {
    (*(completionCopy + 2))(completionCopy, 0);
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v33 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543618;
      v30 = v11;
      v31 = 2112;
      v32 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    (*(*(a1 + 56) + 16))();
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      *buf = 138543618;
      v30 = v12;
      v31 = 2112;
      v32 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    [HMMTRUtilities printAccessControlList:v5];
    v13 = v5;
    v14 = [*(a1 + 32) removeNode:*(a1 + 40) withPrivilge:5 fromExistingAclEntries:v13];
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v30 = v18;
      v31 = 2112;
      v32 = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@New ACL entries %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    if (![v14 count])
    {
      v19 = objc_autoreleasePoolPush();
      v20 = *(a1 + 32);
      v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        v22 = HMFGetLogIdentifier();
        *buf = 138543362;
        v30 = v22;
        _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@Unexpected ACL remove operation", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v19);
      (*(*(a1 + 56) + 16))();
    }

    v26[0] = MEMORY[0x277D85DD0];
    v26[1] = 3221225472;
    v26[2] = __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke_838;
    v26[3] = &unk_2786F0C10;
    v26[4] = *(a1 + 32);
    v27 = v14;
    v23 = *(a1 + 48);
    v28 = *(a1 + 56);
    v24 = v14;
    [v23 writeAttributeACLWithValue:v24 completion:v26];
  }

  v25 = *MEMORY[0x277D85DE8];
}

void __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke_838(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v11 = 138543618;
      v12 = v8;
      v13 = 2112;
      v14 = v3;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to update ACL. Error: %@", &v11, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v11 = 138543362;
      v12 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully updated ACL to", &v11, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [HMMTRUtilities printAccessControlList:*(a1 + 40)];
  }

  (*(*(a1 + 48) + 16))();

  v10 = *MEMORY[0x277D85DE8];
}

- (void)updateAccessoryControlToIncludeAdministratorNodes:(id)nodes sharedUserNodes:(id)userNodes completion:(id)completion
{
  v50 = *MEMORY[0x277D85DE8];
  nodesCopy = nodes;
  userNodesCopy = userNodes;
  completionCopy = completion;
  isKnownToSystemCommissioner = [(HMMTRAccessoryServer *)self isKnownToSystemCommissioner];
  v12 = objc_autoreleasePoolPush();
  selfCopy = self;
  v14 = HMFGetOSLogHandle();
  v15 = v14;
  if (isKnownToSystemCommissioner)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v16 = HMFGetLogIdentifier();
      *buf = 138543362;
      v45 = v16;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Skipping ACL update for System Commissioner pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v12);
LABEL_5:
    completionCopy[2](completionCopy, 0);
    goto LABEL_23;
  }

  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    v17 = HMFGetLogIdentifier();
    *buf = 138543874;
    v45 = v17;
    v46 = 2112;
    v47 = nodesCopy;
    v48 = 2112;
    v49 = userNodesCopy;
    _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to include administrative access to %@ and view access to %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v12);
  pairingRequest = [(HAPAccessoryServer *)selfCopy pairingRequest];
  if (!pairingRequest || ([(HAPAccessoryServer *)selfCopy pairingRequest], v15 = objc_claimAutoreleasedReturnValue(), ([v15 isOwnerPairing]& 1) != 0))
  {
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    isCurrentDevicePrimaryResident = [browser isCurrentDevicePrimaryResident];

    if (pairingRequest)
    {
    }

    if ((isCurrentDevicePrimaryResident & 1) == 0 && (isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
    {
      goto LABEL_5;
    }
  }

  else
  {
  }

  if ([nodesCopy count] || objc_msgSend(userNodesCopy, "count"))
  {
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
    v23 = [(HMMTRAccessoryServer *)selfCopy mtrBaseDeviceWithNodeID:nodeID controller:deviceController];

    if (v23)
    {
      v24 = objc_alloc(MEMORY[0x277CD51D8]);
      clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
      v26 = [v24 initWithDevice:v23 endpointID:&unk_283EE89B8 queue:clientQueue];

      v27 = objc_alloc_init(MEMORY[0x277CD54D8]);
      v39[0] = MEMORY[0x277D85DD0];
      v39[1] = 3221225472;
      v39[2] = __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke;
      v39[3] = &unk_2786F0ED0;
      v39[4] = selfCopy;
      v43 = completionCopy;
      v40 = nodesCopy;
      v41 = userNodesCopy;
      v42 = v26;
      v28 = v26;
      [v28 readAttributeACLWithParams:v27 completion:v39];
    }

    else
    {
      v29 = objc_autoreleasePoolPush();
      v30 = selfCopy;
      v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        v32 = HMFGetLogIdentifier();
        *buf = 138543362;
        v45 = v32;
        _os_log_impl(&dword_22AEAE000, v31, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v29);
      v27 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
      (completionCopy)[2](completionCopy, v27);
    }
  }

  else
  {
    v34 = objc_autoreleasePoolPush();
    v35 = selfCopy;
    v36 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v37 = HMFGetLogIdentifier();
      *buf = 138543362;
      v45 = v37;
      _os_log_impl(&dword_22AEAE000, v36, OS_LOG_TYPE_ERROR, "%{public}@Invalid list of allowed nodes", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v34);
    v38 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:3];
    (completionCopy)[2](completionCopy, v38);
  }

LABEL_23:

  v33 = *MEMORY[0x277D85DE8];
}

void __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543618;
      v26 = v11;
      v27 = 2112;
      v28 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    (*(*(a1 + 64) + 16))();
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      *buf = 138543618;
      v26 = v12;
      v27 = 2112;
      v28 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    [HMMTRUtilities printAccessControlList:v5];
    v13 = v5;
    v14 = [*(a1 + 32) mergeExistingAclEntries:v13 withAdminNodes:*(a1 + 40) regularUserNodes:*(a1 + 48)];
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v26 = v18;
      v27 = 2112;
      v28 = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@New ACL entries %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke_837;
    v22[3] = &unk_2786F0C10;
    v22[4] = *(a1 + 32);
    v23 = v14;
    v19 = *(a1 + 56);
    v24 = *(a1 + 64);
    v20 = v14;
    [v19 writeAttributeACLWithValue:v20 completion:v22];
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke_837(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v11 = 138543618;
      v12 = v8;
      v13 = 2112;
      v14 = v3;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to update ACL. Error: %@", &v11, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v11 = 138543362;
      v12 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully updated ACL to", &v11, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [HMMTRUtilities printAccessControlList:*(a1 + 40)];
  }

  (*(*(a1 + 48) + 16))();

  v10 = *MEMORY[0x277D85DE8];
}

- (void)updateAccessoryControlToAdministratorNodes:(id)nodes sharedUserNodes:(id)userNodes completion:(id)completion
{
  v42 = *MEMORY[0x277D85DE8];
  nodesCopy = nodes;
  userNodesCopy = userNodes;
  completionCopy = completion;
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
LABEL_5:

      objc_autoreleasePoolPop(v11);
      completionCopy[2](completionCopy, 0);
      goto LABEL_20;
    }

    v14 = HMFGetLogIdentifier();
    *buf = 138543362;
    v41 = v14;
    v15 = "%{public}@Skipping ACL update for System Commissioner pairing";
    v16 = v13;
    v17 = OS_LOG_TYPE_DEBUG;
LABEL_4:
    _os_log_impl(&dword_22AEAE000, v16, v17, v15, buf, 0xCu);

    goto LABEL_5;
  }

  if (![nodesCopy count] && !objc_msgSend(userNodesCopy, "count"))
  {
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      goto LABEL_5;
    }

    v14 = HMFGetLogIdentifier();
    *buf = 138543362;
    v41 = v14;
    v15 = "%{public}@No ACL nodes to update on accessory";
    v16 = v13;
    v17 = OS_LOG_TYPE_INFO;
    goto LABEL_4;
  }

  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  deviceController = [(HMMTRAccessoryServer *)self deviceController];
  v20 = [(HMMTRAccessoryServer *)self mtrBaseDeviceWithNodeID:nodeID controller:deviceController];

  if (v20)
  {
    v21 = objc_alloc(MEMORY[0x277CD51D8]);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v23 = [v21 initWithDevice:v20 endpointID:&unk_283EE89B8 queue:clientQueue];

    array = [MEMORY[0x277CBEB18] array];
    if ([nodesCopy count])
    {
      v25 = objc_alloc_init(MEMORY[0x277CD51A8]);
      [v25 setPrivilege:&unk_283EE8C10];
      [v25 setAuthMode:&unk_283EE8C28];
      [v25 setSubjects:nodesCopy];
      [array addObject:v25];
    }

    if ([userNodesCopy count])
    {
      v26 = objc_alloc_init(MEMORY[0x277CD51A8]);
      [v26 setPrivilege:&unk_283EE8C40];
      [v26 setAuthMode:&unk_283EE8C28];
      [v26 setSubjects:userNodesCopy];
      [array addObject:v26];
    }

    v27 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v29 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      v30 = HMFGetLogIdentifier();
      *buf = 138543362;
      v41 = v30;
      _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v27);
    [HMMTRUtilities printAccessControlList:array];
    v37[0] = MEMORY[0x277D85DD0];
    v37[1] = 3221225472;
    v37[2] = __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke;
    v37[3] = &unk_2786F0C10;
    v37[4] = selfCopy3;
    v38 = v23;
    v39 = completionCopy;
    v31 = v23;
    [v31 writeAttributeACLWithValue:array completion:v37];
  }

  else
  {
    v32 = objc_autoreleasePoolPush();
    selfCopy4 = self;
    v34 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v35 = HMFGetLogIdentifier();
      *buf = 138543362;
      v41 = v35;
      _os_log_impl(&dword_22AEAE000, v34, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v32);
    array = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
    (completionCopy)[2](completionCopy, array);
  }

LABEL_20:
  v36 = *MEMORY[0x277D85DE8];
}

void __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke(uint64_t a1, void *a2)
{
  v21 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      goto LABEL_7;
    }

    v8 = HMFGetLogIdentifier();
    *buf = 138543618;
    v18 = v8;
    v19 = 2112;
    v20 = v3;
    v9 = "%{public}@Failed to update ACL. Error: %@";
    v10 = v7;
    v11 = OS_LOG_TYPE_ERROR;
    v12 = 22;
  }

  else
  {
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      goto LABEL_7;
    }

    v8 = HMFGetLogIdentifier();
    *buf = 138543362;
    v18 = v8;
    v9 = "%{public}@Successfully updated ACL";
    v10 = v7;
    v11 = OS_LOG_TYPE_INFO;
    v12 = 12;
  }

  _os_log_impl(&dword_22AEAE000, v10, v11, v9, buf, v12);

LABEL_7:
  objc_autoreleasePoolPop(v4);
  if (HAPIsInternalBuild())
  {
    v13 = objc_alloc_init(MEMORY[0x277CD54D8]);
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke_836;
    v16[3] = &unk_2786F0008;
    v14 = *(a1 + 40);
    v16[4] = *(a1 + 32);
    [v14 readAttributeACLWithParams:v13 completion:v16];
  }

  (*(*(a1 + 48) + 16))();

  v15 = *MEMORY[0x277D85DE8];
}

void __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke_836(uint64_t a1, void *a2, void *a3)
{
  v18 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      v14 = 138543618;
      v15 = v11;
      v16 = 2112;
      v17 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", &v14, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      v14 = 138543618;
      v15 = v12;
      v16 = 2112;
      v17 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", &v14, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    [HMMTRUtilities printAccessControlList:v5];
  }

  v13 = *MEMORY[0x277D85DE8];
}

- (void)_getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:(id)cluster completion:(id)completion
{
  clusterCopy = cluster;
  completionCopy = completion;
  commissioneeNetworks = [(HMMTRAccessoryServer *)self commissioneeNetworks];

  if (commissioneeNetworks)
  {
    completionCopy[2](completionCopy, [(HMMTRAccessoryServer *)self commissioneeHasActiveNetwork], 0);
  }

  else
  {
    v9[0] = MEMORY[0x277D85DD0];
    v9[1] = 3221225472;
    v9[2] = __99__HMMTRAccessoryServer__getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster_completion___block_invoke;
    v9[3] = &unk_2786EFA38;
    v9[4] = self;
    v10 = completionCopy;
    [clusterCopy readAttributeNetworksWithCompletion:v9];
  }
}

void __99__HMMTRAccessoryServer__getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543618;
      v26 = v10;
      v27 = 2112;
      v28 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to read networks attribute from commissionee: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  [*(a1 + 32) setCommissioneeNetworks:v5];
  [*(a1 + 32) setCommissioneeHasActiveNetwork:0];
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v11 = v5;
  v12 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v12)
  {
    v13 = v12;
    v14 = *v21;
    v15 = MEMORY[0x277CBEC38];
    do
    {
      v16 = 0;
      do
      {
        if (*v21 != v14)
        {
          objc_enumerationMutation(v11);
        }

        v17 = [*(*(&v20 + 1) + 8 * v16) connected];
        v18 = [v17 isEqual:v15];

        if (v18)
        {
          [*(a1 + 32) setCommissioneeHasActiveNetwork:1];
        }

        ++v16;
      }

      while (v13 != v16);
      v13 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }

    while (v13);
  }

  (*(*(a1 + 40) + 16))(*(a1 + 40), [*(a1 + 32) commissioneeHasActiveNetwork], v6);
  v19 = *MEMORY[0x277D85DE8];
}

- (void)_getCommissioneeNetworkCommissioningClusterEndpointWithDevice:(id)device completion:(id)completion
{
  deviceCopy = device;
  completionCopy = completion;
  commissioneeNetworkCommissioningClusterEndpoint = [(HMMTRAccessoryServer *)self commissioneeNetworkCommissioningClusterEndpoint];

  if (commissioneeNetworkCommissioningClusterEndpoint)
  {
    commissioneeNetworkCommissioningClusterEndpoint2 = [(HMMTRAccessoryServer *)self commissioneeNetworkCommissioningClusterEndpoint];
    completionCopy[2](completionCopy, commissioneeNetworkCommissioningClusterEndpoint2, 0);
  }

  else
  {
    v10[0] = MEMORY[0x277D85DD0];
    v10[1] = 3221225472;
    v10[2] = __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke;
    v10[3] = &unk_2786F1038;
    v13 = completionCopy;
    v11 = deviceCopy;
    selfCopy = self;
    [(HMMTRAccessoryServer *)self _retrieveRootEndpointPartsListWithDevice:v11 completion:v10];
  }
}

void __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  if (v3)
  {
    v4 = +[HMMTRDescriptorClusterManager sharedManager];
    v5 = *(a1 + 32);
    v6 = [*(a1 + 40) clientQueue];
    v8[0] = MEMORY[0x277D85DD0];
    v8[1] = 3221225472;
    v8[2] = __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke_2;
    v8[3] = &unk_2786F0F48;
    v7 = *(a1 + 48);
    v8[4] = *(a1 + 40);
    v9 = v7;
    [v4 endpointForClusterID:&unk_283EE8BC8 device:v5 partsList:v3 callbackQueue:v6 completionHandler:v8];
  }

  else
  {
    (*(*(a1 + 48) + 16))();
  }
}

void __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v5 = *(a1 + 32);
  v6 = a3;
  v7 = a2;
  [v5 setCommissioneeNetworkCommissioningClusterEndpoint:v7];
  (*(*(a1 + 40) + 16))();
}

- (void)_retrieveRootEndpointPartsListWithDevice:(id)device completion:(id)completion
{
  deviceCopy = device;
  completionCopy = completion;
  rootEndpointPartsList = [(HMMTRAccessoryServer *)self rootEndpointPartsList];

  if (rootEndpointPartsList)
  {
    rootEndpointPartsList2 = [(HMMTRAccessoryServer *)self rootEndpointPartsList];
    completionCopy[2](completionCopy, rootEndpointPartsList2, 0);
  }

  else
  {
    v10 = objc_alloc(MEMORY[0x277CD51F0]);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v12 = [v10 initWithDevice:deviceCopy endpoint:0 queue:clientQueue];

    v13[0] = MEMORY[0x277D85DD0];
    v13[1] = 3221225472;
    v13[2] = __76__HMMTRAccessoryServer__retrieveRootEndpointPartsListWithDevice_completion___block_invoke;
    v13[3] = &unk_2786EFA38;
    v13[4] = self;
    v14 = completionCopy;
    [v12 readAttributePartsListWithCompletionHandler:v13];
  }
}

void __76__HMMTRAccessoryServer__retrieveRootEndpointPartsListWithDevice_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v16 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (!v5)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to read parts list for endpoint 0: %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  [*(a1 + 32) setRootEndpointPartsList:v5];
  (*(*(a1 + 40) + 16))();

  v11 = *MEMORY[0x277D85DE8];
}

- (void)_collectNetworkCredentials:(id)credentials
{
  v34 = *MEMORY[0x277D85DE8];
  credentialsCopy = credentials;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543362;
    v31 = v8;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Checking what network technology is supported for the accessory.", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v5);
  [(HMMTRAccessoryServer *)selfCopy setPairingProgress:2];
  deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
  nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
  v29 = 0;
  v11 = [deviceController getDeviceBeingCommissioned:objc_msgSend(nodeID error:{"unsignedLongLongValue"), &v29}];
  v12 = v29;

  if (v11)
  {
    v13 = [v11 sessionTransportType] == 2;
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke;
    v27[3] = &unk_2786EFF68;
    v27[4] = selfCopy;
    v28 = deviceController;
    v14 = MEMORY[0x2318887D0](v27);
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_2;
    v22[3] = &unk_2786EFFE0;
    v22[4] = selfCopy;
    v25 = v14;
    v23 = v11;
    v26 = v13;
    v24 = credentialsCopy;
    v15 = v14;
    [(HMMTRAccessoryServer *)selfCopy _getCommissioneeNetworkCommissioningClusterEndpointWithDevice:v23 completion:v22];
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    v17 = selfCopy;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543618;
      v31 = v19;
      v32 = 2112;
      v33 = v12;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Failed to check supported network technologies for server. Error: %@...", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v16);
    v20 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v12];
    [(HMMTRAccessoryServer *)v17 _pairingComplete:v12 context:v20];
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  v24 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v8)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543618;
      v21 = v13;
      v22 = 2112;
      v23 = v8;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to collect required credentials for accessory. Error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    v14 = *(a1 + 40);
    v15 = [*(a1 + 32) nodeID];
    [v14 stopDevicePairing:objc_msgSend(v15 error:{"unsignedLongLongValue"), 0}];

    [*(a1 + 32) _pairingComplete:v8 context:v9];
  }

  else
  {
    v16 = *(a1 + 32);
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_819;
    v18[3] = &unk_2786EF9E0;
    v18[4] = v16;
    v19 = v7;
    [v16 _fetchAdditionalThreadNetworkInformationWithCompletion:v18];
  }

  v17 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v39 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543618;
      v36 = v10;
      v37 = 2112;
      v38 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to query endpoints for network commissioning cluster : %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v11 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
    [*(a1 + 32) _pairingComplete:v6 context:v11];
  }

  else
  {
    v11 = objc_alloc_init(MEMORY[0x277CD5300]);
    v12 = [*(a1 + 32) browser];
    v13 = [v12 attestationStatus];
    [v13 populateDelegate:v11];

    if ([*(a1 + 32) _populateCommissioningParameterCountryCode:v11])
    {
      v14 = objc_autoreleasePoolPush();
      v15 = *(a1 + 32);
      v16 = HMFGetOSLogHandle();
      v17 = v16;
      if (v5)
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v18 = HMFGetLogIdentifier();
          *buf = 138543618;
          v36 = v18;
          v37 = 2112;
          v38 = v5;
          _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_DEBUG, "%{public}@Found network commissioning cluster at endpoint: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v14);
        v19 = objc_alloc(MEMORY[0x277CD5200]);
        v20 = *(a1 + 40);
        v21 = [v5 unsignedIntValue];
        v22 = [*(a1 + 32) clientQueue];
        v23 = [v19 initWithDevice:v20 endpoint:v21 queue:v22];

        objc_initWeak(buf, *(a1 + 32));
        v24 = *(a1 + 32);
        v28[0] = MEMORY[0x277D85DD0];
        v28[1] = 3221225472;
        v28[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_823;
        v28[3] = &unk_2786EFFB8;
        v28[4] = v24;
        v34 = *(a1 + 64);
        v25 = v23;
        v29 = v25;
        objc_copyWeak(&v33, buf);
        v32 = *(a1 + 56);
        v11 = v11;
        v30 = v11;
        v31 = *(a1 + 48);
        [v24 _getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:v25 completion:v28];

        objc_destroyWeak(&v33);
        objc_destroyWeak(buf);
      }

      else
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          v26 = HMFGetLogIdentifier();
          *buf = 138543362;
          v36 = v26;
          _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster not found. Proceeding with on-network commissioning", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v14);
        (*(*(a1 + 56) + 16))();
      }
    }
  }

  v27 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_823(uint64_t a1, int a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  v5 = a3;
  v6 = objc_autoreleasePoolPush();
  v7 = *(a1 + 32);
  v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    v9 = HMFGetLogIdentifier();
    v10 = *(a1 + 80);
    v11 = HMFBooleanToString();
    v12 = HMFBooleanToString();
    *buf = 138543874;
    *&buf[4] = v9;
    *&buf[12] = 2112;
    *&buf[14] = v11;
    *&buf[22] = 2112;
    v28 = v12;
    _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Commissionee over BLE: %@, has active network: %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v6);
  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x2020000000;
  LOBYTE(v28) = 0;
  if (!v5 && a2 && (*(a1 + 80) & 1) == 0)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = *(a1 + 32);
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      *v25 = 138543362;
      v26 = v16;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Commissionee was already network commissioned. Skip network commissioning parameters.", v25, 0xCu);
    }

    objc_autoreleasePoolPop(v13);
    *(*&buf[8] + 24) = 1;
  }

  v17 = *(a1 + 40);
  v19[0] = MEMORY[0x277D85DD0];
  v19[1] = 3221225472;
  v19[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_824;
  v19[3] = &unk_2786EFF90;
  objc_copyWeak(&v24, (a1 + 72));
  v23 = buf;
  v22 = *(a1 + 64);
  v20 = *(a1 + 48);
  v21 = *(a1 + 56);
  [v17 readAttributeFeatureMapWithCompletionHandler:v19];

  objc_destroyWeak(&v24);
  _Block_object_dispose(buf, 8);

  v18 = *MEMORY[0x277D85DE8];
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_824(uint64_t a1, void *a2, void *a3)
{
  v41 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((a1 + 64));
  v8 = WeakRetained;
  if (!v6)
  {
    v16 = [WeakRetained getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:v5];
    [v8 _setSupportedLinkLayerTypes:v16];
    if (v16)
    {
      [v8 _notifyDelegateOfSupportedLinkLayerTypes:v16];
    }

    if (*(*(*(a1 + 56) + 8) + 24) == 1)
    {
      goto LABEL_9;
    }

    v20 = [v5 integerValue];
    if ((v20 & 1) == 0)
    {
      if ((v20 & 2) != 0)
      {
        [v8 setLinkLayerType:4];
        if ((isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled() & 1) != 0 || ![v8 shouldPairWithoutResident])
        {
          [v8 _populateThreadCredentials:*(a1 + 32) completion:*(a1 + 48)];
          goto LABEL_33;
        }

        v25 = [MEMORY[0x277CCA9B8] hapErrorWithCode:30];
        v26 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v25];
        (*(*(a1 + 48) + 16))();
      }

      else
      {
        if ((v20 & 4) != 0)
        {
          [v8 setLinkLayerType:2];
LABEL_9:
          v17 = *(a1 + 32);
          (*(*(a1 + 48) + 16))();
LABEL_33:

          goto LABEL_34;
        }

        v21 = objc_autoreleasePoolPush();
        v22 = v8;
        v23 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          v24 = HMFGetLogIdentifier();
          *buf = 138543618;
          v38 = v24;
          v39 = 2112;
          v40 = v5;
          _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_ERROR, "%{public}@Accessory NetworkCommissioning cluster feature map has unsupported value: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v21);
        v25 = [MEMORY[0x277CCA9B8] hapErrorWithCode:15];
        v26 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:v25];
        [v22 _pairingComplete:v25 context:v26];
      }

      goto LABEL_30;
    }

    [v8 setLinkLayerType:1];
    if (isFeatureMatterLocalFabricConfigEnabled() && ([v8 fabricUUID], (v27 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      v28 = v27;
      v36 = [v8 browser];
      v29 = [v36 storage];
      v30 = [v29 dataSource];
      v31 = [v8 fabricUUID];
      v25 = [v30 appleHomeFabricWithTargetFabricUUID:v31];

      if (v25)
      {
        if ((isFeatureMatteriPhoneOnlyPairingControlForIPEnabled() & 1) == 0)
        {
          v32 = [v25 delegate];
          v33 = [v32 requiresRemoteFabricDataUpdate];

          if ((v33 & 1) == 0)
          {
            v26 = [MEMORY[0x277CCA9B8] hapErrorWithCode:35];
            v34 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v26];
            (*(*(a1 + 48) + 16))();

LABEL_30:
            goto LABEL_31;
          }
        }
      }
    }

    else
    {
      v25 = 0;
    }

    [v8 _populateWifiCredentials:*(a1 + 32) scanResults:*(a1 + 40) completion:*(a1 + 48)];
LABEL_31:

    goto LABEL_33;
  }

  v9 = *(*(*(a1 + 56) + 8) + 24);
  v10 = objc_autoreleasePoolPush();
  v11 = v8;
  v12 = HMFGetOSLogHandle();
  v13 = v12;
  if (v9 == 1)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543618;
      v38 = v14;
      v39 = 2112;
      v40 = v6;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_ERROR, "%{public}@Failed to check supported network technologies for server, but commissionee was already network commissioned. Ignoring error and continuing with pairing. Error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    v15 = *(a1 + 32);
    (*(*(a1 + 48) + 16))();
  }

  else
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v38 = v18;
      v39 = 2112;
      v40 = v6;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Failed to check supported network technologies for server. Error: %@...", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    v19 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
    [v11 _pairingComplete:v6 context:v19];
  }

LABEL_34:

  v35 = *MEMORY[0x277D85DE8];
}

uint64_t __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_819(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = [MEMORY[0x277CCABB0] numberWithBool:{objc_msgSend(v2, "isWEDDevice")}];
  [v2 _notifyDelegateOfMatterAccessoryIsWEDAccessory:v3];

  v4 = *(a1 + 32);
  v5 = *(a1 + 40);

  return [v4 _commissionWithParams:v5];
}

- (void)_setSupportedLinkLayerTypes:(id)types
{
  v39 = *MEMORY[0x277D85DE8];
  typesCopy = types;
  v5 = typesCopy;
  if (!typesCopy)
  {
    v6 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = HMFGetLogIdentifier();
      nodeID = [(HMMTRAccessoryServer *)selfCopy2 nodeID];
      *buf = 138543618;
      v30 = v9;
      v31 = 2112;
      v32 = nodeID;
      v11 = "%{public}@Nil supported link layer types - cannot determine supported link layer for accessory with nodeID %@";
      goto LABEL_7;
    }

LABEL_8:

    objc_autoreleasePoolPop(v6);
    goto LABEL_12;
  }

  if ([typesCopy isEqualToValue:&unk_283EE89B8])
  {
    v6 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = HMFGetLogIdentifier();
      nodeID = [(HMMTRAccessoryServer *)selfCopy2 nodeID];
      *buf = 138543618;
      v30 = v9;
      v31 = 2112;
      v32 = nodeID;
      v11 = "%{public}@No supported link layer types - cannot determine supported link layer for accessory with nodeID %@";
LABEL_7:
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);

      goto LABEL_8;
    }

    goto LABEL_8;
  }

  [HMMTRUtilities supportedLinkLayerTypesContainsWiFi:v5];
  [HMMTRUtilities supportedLinkLayerTypesContainsEthernet:v5];
  [HMMTRUtilities supportedLinkLayerTypesContainsThread:v5];
  v12 = objc_autoreleasePoolPush();
  selfCopy3 = self;
  v14 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    v15 = HMFGetLogIdentifier();
    v16 = HMFBooleanToString();
    v17 = HMFBooleanToString();
    v18 = HMFBooleanToString();
    *buf = 138544386;
    v30 = v15;
    v31 = 2112;
    v32 = v5;
    v33 = 2112;
    v34 = v16;
    v35 = 2112;
    v36 = v17;
    v37 = 2112;
    v38 = v18;
    _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Accessory supported link layer types: %@ [WiFi:%@, Ethernet:%@, Thread:%@]", buf, 0x34u);
  }

  objc_autoreleasePoolPop(v12);
  [(HMMTRAccessoryServer *)selfCopy3 setSupportedLinkLayerTypes:v5];
  browser = [(HMMTRAccessoryServer *)selfCopy3 browser];
  storage = [browser storage];
  dataSource = [storage dataSource];
  fabricUUID = [(HMMTRAccessoryServer *)selfCopy3 fabricUUID];
  v23 = [dataSource storageDataSourceForFabricUUID:fabricUUID];

  nodeID2 = [(HMMTRAccessoryServer *)selfCopy3 nodeID];
  v25 = [v23 storageDataSourceForDeviceWithNodeID:nodeID2];
  supportedLinkLayerTypes = [(HMMTRAccessoryServer *)selfCopy3 supportedLinkLayerTypes];
  v28[0] = MEMORY[0x277D85DD0];
  v28[1] = 3221225472;
  v28[2] = __52__HMMTRAccessoryServer__setSupportedLinkLayerTypes___block_invoke;
  v28[3] = &unk_2786EF290;
  v28[4] = selfCopy3;
  [v25 updateSupportedLinkLayerTypes:supportedLinkLayerTypes completion:v28];

LABEL_12:
  v27 = *MEMORY[0x277D85DE8];
}

void __52__HMMTRAccessoryServer__setSupportedLinkLayerTypes___block_invoke(uint64_t a1, void *a2)
{
  v16 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v8 = [*(a1 + 32) supportedLinkLayerTypes];
      v10 = 138543874;
      v11 = v7;
      v12 = 2112;
      v13 = v8;
      v14 = 2112;
      v15 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update supported link layer types in storage to %@ with error: %@", &v10, 0x20u);
    }

    objc_autoreleasePoolPop(v4);
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)configureDefaultRequiresThreadRouter
{
  v28 = *MEMORY[0x277D85DE8];
  supportedLinkLayerTypes = [(HMMTRAccessoryServer *)self supportedLinkLayerTypes];
  v4 = [supportedLinkLayerTypes unsignedIntValue] & 0x10;

  isWEDDevice = [(HMMTRAccessoryServer *)self isWEDDevice];
  browser = [(HMMTRAccessoryServer *)self browser];
  threadRadioManager = [browser threadRadioManager];
  deviceSupportsThreadService = [threadRadioManager deviceSupportsThreadService];

  [(HMMTRAccessoryServer *)self setRequiresThreadRouter:(deviceSupportsThreadService & isWEDDevice ^ 1) & (v4 >> 4)];
  v9 = objc_autoreleasePoolPush();
  selfCopy = self;
  v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    v12 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)selfCopy requiresThreadRouter];
    v13 = HMFBooleanToString();
    v14 = HMFBooleanToString();
    v15 = HMFBooleanToString();
    v16 = HMFBooleanToString();
    v18 = 138544386;
    v19 = v12;
    v20 = 2112;
    v21 = v13;
    v22 = 2112;
    v23 = v14;
    v24 = 2112;
    v25 = v15;
    v26 = 2112;
    v27 = v16;
    _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_DEBUG, "%{public}@configureDefaultRequiresThreadRouter - accessory requires thread router = %@ (isAccessoryServerThreadCapable = %@, isDeviceThreadCapable = %@, isWEDDevice = %@", &v18, 0x34u);
  }

  objc_autoreleasePoolPop(v9);
  v17 = *MEMORY[0x277D85DE8];
}

- (void)setSupportedLinkLayerTypes:(id)types
{
  typesCopy = types;
  v5 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  supportedLinkLayerTypes = self->_supportedLinkLayerTypes;
  self->_supportedLinkLayerTypes = typesCopy;

  os_unfair_lock_unlock((self + v5));
}

- (NSNumber)supportedLinkLayerTypes
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = self->_supportedLinkLayerTypes;
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (NSDictionary)endpointToDeviceTypesMap
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = self->_endpointToDeviceTypesMap;
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (void)setEndpointToDeviceTypesMap:(id)map
{
  mapCopy = map;
  v4 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v5 = [mapCopy copy];
  endpointToDeviceTypesMap = self->_endpointToDeviceTypesMap;
  self->_endpointToDeviceTypesMap = v5;

  os_unfair_lock_unlock((self + v4));
}

- (BOOL)_populateCommissioningParameterCountryCode:(id)code
{
  v17 = *MEMORY[0x277D85DE8];
  codeCopy = code;
  browser = [(HMMTRAccessoryServer *)self browser];
  regulatoryInfo = [browser regulatoryInfo];
  countryCode = [regulatoryInfo countryCode];
  [codeCopy setCountryCode:countryCode];

  countryCode2 = [codeCopy countryCode];

  if (!countryCode2)
  {
    v9 = objc_autoreleasePoolPush();
    selfCopy = self;
    v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = HMFGetLogIdentifier();
      v15 = 138543362;
      v16 = v12;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_ERROR, "%{public}@Country code could not be estimated. Moving on with pairing without country code.", &v15, 0xCu);
    }

    objc_autoreleasePoolPop(v9);
  }

  v13 = *MEMORY[0x277D85DE8];
  return 1;
}

- (void)_commissionWithParams:(id)params
{
  v25 = *MEMORY[0x277D85DE8];
  paramsCopy = params;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    *buf = 138543618;
    v22 = v8;
    v23 = 2112;
    v24 = nodeID;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@).", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  [paramsCopy setReadEndpointInformation:1];
  [(HMMTRAccessoryServer *)selfCopy _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameCommissioningAccessory"];
  [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingProgress:27];
  [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingStep:6];
  nodeID2 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  controllerWrapper = [(HMMTRAccessoryServer *)selfCopy controllerWrapper];
  startupParams = [controllerWrapper startupParams];
  operationalCertificateIssuer = [startupParams operationalCertificateIssuer];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v14 = operationalCertificateIssuer;
  }

  else
  {
    v14 = 0;
  }

  v15 = v14;

  [v15 setCommissioneeNodeID:nodeID2];
  deviceController = [(HMMTRAccessoryServer *)selfCopy deviceController];
  nodeID3 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  v20 = 0;
  [deviceController commissionDevice:objc_msgSend(nodeID3 commissioningParams:"unsignedLongLongValue") error:{paramsCopy, &v20}];
  v18 = v20;

  if (v18)
  {
    [(HMMTRAccessoryServer *)selfCopy setCommissionCompletePending:0];
    [(HMMTRAccessoryServer *)selfCopy _notifyDelegateOfPairingProgress:29 error:v18];
  }

  else
  {
    [(HMMTRAccessoryServer *)selfCopy setCommissionCompletePending:1];
  }

  v19 = *MEMORY[0x277D85DE8];
}

- (void)_handlePairingFailureWithError:(id)error context:(id)context
{
  v59 = *MEMORY[0x277D85DE8];
  errorCopy = error;
  contextCopy = context;
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543874;
    v54 = v11;
    v55 = 2112;
    v56 = errorCopy;
    v57 = 2112;
    v58 = contextCopy;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Cleaning up state due to pairing failure error %@ context %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v8);
  [(HMMTRAccessoryServer *)selfCopy _clearCommissioneeInfoAfterPairingCompletion];
  v12 = [HMMTRAccessoryServer _convertPairingFailureError:errorCopy];

  [(HMMTRAccessoryServer *)selfCopy setPairingProgress:3];
  if ([(HMMTRAccessoryServer *)selfCopy pairedState]== 1)
  {
    stageCompletion = [(HMMTRAccessoryServer *)selfCopy stageCompletion];

    if (stageCompletion)
    {
      stageCompletion2 = [(HMMTRAccessoryServer *)selfCopy stageCompletion];
      (stageCompletion2)[2](stageCompletion2, 0, 0, v12);

      [(HMMTRAccessoryServer *)selfCopy setStageCompletion:0];
    }

    else
    {
      v15 = objc_autoreleasePoolPush();
      v16 = selfCopy;
      v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = HMFGetLogIdentifier();
        *buf = 138543362;
        v54 = v18;
        _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory is staged but has no stage completion handler set!", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v15);
    }
  }

  [(HMMTRAccessoryServer *)selfCopy setRemoveReason:v12 pairingEndContextWhenRemove:contextCopy];
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  [(HMMTRAccessoryServer *)selfCopy _unpair:clientQueue completion:0];

  delegateQueue = [(HAPAccessoryServer *)selfCopy delegateQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke;
  block[3] = &unk_2786EF3C8;
  block[4] = selfCopy;
  v21 = v12;
  v51 = v21;
  v22 = contextCopy;
  v52 = v22;
  dispatch_async(delegateQueue, block);

  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    v23 = objc_autoreleasePoolPush();
    v24 = selfCopy;
    v25 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v26 = HMFGetLogIdentifier();
      *buf = 138543362;
      v54 = v26;
      _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_DEBUG, "%{public}@Resetting storage state after pairing failure", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v23);
    browser = [(HMMTRAccessoryServer *)v24 browser];
    [browser setUpBrowserTargetFabricAndRediscoverAccessoriesForHomeFabricUUID:0];

    browser2 = [(HMMTRAccessoryServer *)v24 browser];
    [browser2 disableUnrestrictedOperationsForAccessoryServer:v24];

    browser3 = [(HMMTRAccessoryServer *)v24 browser];
    [browser3 resumeAllOperations];

    fabricUUID = [(HMMTRAccessoryServer *)v24 fabricUUID];
    if (fabricUUID)
    {
      browser4 = [(HMMTRAccessoryServer *)v24 browser];
      storage = [browser4 storage];
      dataSource = [storage dataSource];
      fabricUUID2 = [(HMMTRAccessoryServer *)v24 fabricUUID];
      v35 = [dataSource appleHomeFabricWithTargetFabricUUID:fabricUUID2];
    }

    else
    {
      v35 = 0;
    }

    browser5 = [(HMMTRAccessoryServer *)v24 browser];
    v37 = [browser5 isCurrentDeviceAllowedAccessoryControlDespiteReachableResidentForFabric:v35];

    if (v37)
    {
      browser6 = [(HMMTRAccessoryServer *)v24 browser];
      threadRadioManager = [browser6 threadRadioManager];
      v49[0] = MEMORY[0x277D85DD0];
      v49[1] = 3221225472;
      v49[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_817;
      v49[3] = &unk_2786EF290;
      v49[4] = v24;
      [threadRadioManager stopAccessoryPairingWithCompletion:v49];

      if ([(HMMTRAccessoryServer *)v24 isWEDDevice])
      {
        eMACAddress = [(HMMTRAccessoryServer *)v24 eMACAddress];

        if (eMACAddress)
        {
          v41 = objc_autoreleasePoolPush();
          v42 = v24;
          v43 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
          {
            v44 = HMFGetLogIdentifier();
            *buf = 138543618;
            v54 = v44;
            v55 = 2112;
            v56 = v42;
            _os_log_impl(&dword_22AEAE000, v43, OS_LOG_TYPE_INFO, "%{public}@Disconnecting from WED accessory %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v41);
          browser7 = [(HMMTRAccessoryServer *)v42 browser];
          threadRadioManager2 = [browser7 threadRadioManager];
          v48[0] = MEMORY[0x277D85DD0];
          v48[1] = 3221225472;
          v48[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_818;
          v48[3] = &unk_2786EF290;
          v48[4] = v42;
          [threadRadioManager2 disconnectFromWEDAccessory:v42 completion:v48];
        }
      }
    }
  }

  v47 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) delegate];
  if ([v2 conformsToProtocol:&unk_283F236B0])
  {
    v3 = v2;
  }

  else
  {
    v3 = 0;
  }

  v4 = v3;

  if (v4)
  {
    [v4 accessoryServer:*(a1 + 32) didStopPairingWithError:*(a1 + 40) matterPairingEndContext:*(a1 + 48)];
  }

  else
  {
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v10 = 138543362;
      v11 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Unable to find delegate confirming to HAPAccessoryServerMTRDelegatePrivate", &v10, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  v9 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_817(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Thread StopAccessoryPairing completed, error: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_818(uint64_t a1, void *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v8 = *(a1 + 32);
    v9 = [v8 eMACAddress];
    v11 = 138544130;
    v12 = v7;
    v13 = 2112;
    v14 = v8;
    v15 = 2112;
    v16 = v9;
    v17 = 2112;
    v18 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Disconnect from WED accessory %@ with emac %@ completed, error %@", &v11, 0x2Au);
  }

  objc_autoreleasePoolPop(v4);
  v10 = *MEMORY[0x277D85DE8];
}

- (void)_buildHAPCategoriesFromCHIPWithCompletionHandler:(id)handler
{
  v25 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v22 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting building HAP categories.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    v9 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    handlerCopy[2](handlerCopy, v9);
  }

  else
  {
    v10 = random();
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543618;
      v22 = v14;
      v23 = 2048;
      v24 = v10;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke;
    v18[3] = &unk_2786EFF18;
    v18[4] = selfCopy2;
    v20 = v10;
    v19 = handlerCopy;
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_816;
    v16[3] = &unk_2786F0BC0;
    v17 = v19;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v18 highPriority:0 completion:v16];
  }

  v15 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke(uint64_t a1)
{
  v40 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v37 = v5;
    v38 = 2048;
    v39 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v33[0] = MEMORY[0x277D85DD0];
  v33[1] = 3221225472;
  v33[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_811;
  v33[3] = &unk_2786EF8A0;
  v35 = *(a1 + 40);
  v8 = v7;
  v34 = v8;
  v9 = MEMORY[0x2318887D0](v33);
  v10 = [*(a1 + 32) deviceController];
  v11 = [v10 isRunning];
  v12 = *(a1 + 32);
  if (v11)
  {
    v13 = [*(a1 + 32) nodeID];
    v14 = [v12 mtrBaseDeviceWithNodeID:v13 controller:v10];

    if (v14)
    {
      v15 = *(a1 + 32);
      v27[0] = MEMORY[0x277D85DD0];
      v27[1] = 3221225472;
      v27[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_812;
      v27[3] = &unk_2786F0EA8;
      v27[4] = v15;
      v28 = v14;
      v29 = v9;
      [v15 dispatchBlock:v27];
    }

    else
    {
      v18 = objc_autoreleasePoolPush();
      v19 = *(a1 + 32);
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543362;
        v37 = v21;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_ERROR, "%{public}@Could not retrieve hap category because of no device", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v18);
      v22 = [MEMORY[0x277CCA9B8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:0 userInfo:0];
      (v9)[2](v9, v22);
    }

    v23 = [*(a1 + 32) clientQueue];
    v26[0] = MEMORY[0x277D85DD0];
    v26[1] = 3221225472;
    v26[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_815;
    v26[3] = &unk_2786EF620;
    v24 = *(a1 + 48);
    v26[4] = *(a1 + 32);
    v26[5] = v24;
    dispatch_group_notify(v8, v23, v26);
  }

  else
  {
    v16 = [*(a1 + 32) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2;
    block[3] = &unk_2786EFF18;
    v17 = v9;
    block[4] = *(a1 + 32);
    v31 = v17;
    v32 = *(a1 + 48);
    dispatch_async(v16, block);

    v14 = v31;
  }

  v25 = *MEMORY[0x277D85DE8];
}

uint64_t __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_816(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_811(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2(uint64_t a1)
{
  v14 = *MEMORY[0x277D85DE8];
  v2 = *(a1 + 40);
  v3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v2 + 16))(v2, v3);

  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v8 = *(a1 + 48);
    v10 = 138543618;
    v11 = v7;
    v12 = 2048;
    v13 = v8;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) complete.", &v10, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v9 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_812(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2_813;
  v7[3] = &unk_2786F1038;
  v4 = *(a1 + 48);
  v5 = *(a1 + 32);
  v6 = *(a1 + 40);
  v9 = v4;
  v7[4] = v5;
  v8 = v6;
  [v2 _retrieveRootEndpointPartsListWithDevice:v3 completion:v7];
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_815(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2_813(uint64_t a1, void *a2, uint64_t a3)
{
  v5 = a2;
  if (a3)
  {
    (*(*(a1 + 48) + 16))();
  }

  else
  {
    v6 = [*(a1 + 32) descriptorClusterManager];
    v7 = v6[2]();
    v8 = *(a1 + 40);
    v9 = [*(a1 + 32) nodeID];
    v10 = *(a1 + 32);
    v11 = [v10 clientQueue];
    v12[0] = MEMORY[0x277D85DD0];
    v12[1] = 3221225472;
    v12[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_3;
    v12[3] = &unk_2786EFF40;
    v12[4] = *(a1 + 32);
    v13 = *(a1 + 48);
    [v7 fetchHAPCategoryForCHIPDevice:v8 nodeId:v9 server:v10 partsList:v5 callbackQueue:v11 completionHandler:v12];
  }
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_3(uint64_t a1, void *a2, void *a3, void *a4)
{
  v9 = a2;
  v7 = a3;
  v8 = a4;
  if (v9)
  {
    [*(a1 + 32) _setCategoryForPrimaryAccessory:v9];
  }

  if (v7)
  {
    [*(a1 + 32) setEndpointToDeviceTypesMap:v7];
  }

  (*(*(a1 + 40) + 16))();
}

- (void)_rebuildHAPServicesFromCHIPWithCompletionHandler:(id)handler
{
  v37 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  operationDisabled = [(HMMTRAccessoryServer *)self operationDisabled];
  v6 = objc_autoreleasePoolPush();
  selfCopy = self;
  v8 = HMFGetOSLogHandle();
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
  if (operationDisabled)
  {
    if (v9)
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v36 = v10;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting rebuilding HAP services.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v6);
    if (handlerCopy)
    {
      v11 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      handlerCopy[2](handlerCopy, v11);
    }
  }

  else
  {
    if (v9)
    {
      v12 = HMFGetLogIdentifier();
      *buf = 138543362;
      v36 = v12;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Rebuilding HAP Services from MTRDevice cache", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v6);
    v33[0] = MEMORY[0x277D85DD0];
    v33[1] = 3221225472;
    v33[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke;
    v33[3] = &unk_2786EF8A0;
    v33[4] = selfCopy;
    v13 = handlerCopy;
    v34 = v13;
    v14 = MEMORY[0x2318887D0](v33);
    [(HMMTRAccessoryServer *)selfCopy _setupMatterDevice];
    matterDevice = [(HMMTRAccessoryServer *)selfCopy matterDevice];
    deviceCachePrimed = [matterDevice deviceCachePrimed];

    if (deviceCachePrimed)
    {
      [(HMMTRAccessoryServer *)selfCopy setServiceEnumerationInProgress:1];
      descriptorClusterManager = [(HMMTRAccessoryServer *)selfCopy descriptorClusterManager];
      v18 = descriptorClusterManager[2]();
      matterDevice2 = [(HMMTRAccessoryServer *)selfCopy matterDevice];
      nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
      clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
      v31[0] = MEMORY[0x277D85DD0];
      v31[1] = 3221225472;
      v31[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_789;
      v31[3] = &unk_2786EFEF0;
      v31[4] = selfCopy;
      v32 = v14;
      [v18 fetchHAPServicesWithMTRDevice:matterDevice2 nodeId:nodeID server:selfCopy callbackQueue:clientQueue completionHandler:v31];
    }

    else
    {
      v22 = objc_autoreleasePoolPush();
      v23 = selfCopy;
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        v25 = HMFGetLogIdentifier();
        *buf = 138543362;
        v36 = v25;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_INFO, "%{public}@Could not retrieve hap services because MTRDevice cache is not ready", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v22);
      [(HMMTRAccessoryServer *)v23 setFullServiceEnumerationPendingCachePrimedEvent:1];
      if (v13)
      {
        serviceEnumerationFromDeviceCompletionHandlers = [(HMMTRAccessoryServer *)v23 serviceEnumerationFromDeviceCompletionHandlers];
        v27 = MEMORY[0x2318887D0](v13);
        [serviceEnumerationFromDeviceCompletionHandlers addObject:v27];
      }

      v29[4] = v23;
      v30[0] = MEMORY[0x277D85DD0];
      v30[1] = 3221225472;
      v30[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_809;
      v30[3] = &unk_2786F0CA8;
      v30[4] = v23;
      v29[0] = MEMORY[0x277D85DD0];
      v29[1] = 3221225472;
      v29[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_810;
      v29[3] = &unk_2786EF290;
      [(HMMTRAccessoryServer *)v23 queueAccessoryOperation:v30 highPriority:0 completion:v29];
    }
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke(uint64_t a1, void *a2)
{
  v33 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = *(a1 + 32);
  if (!v3)
  {
    [v4 setServicesEnumerated:1];
    goto LABEL_5;
  }

  if (([v4 servicesEnumerated] & 1) == 0)
  {
LABEL_5:
    [*(a1 + 32) setServiceEnumerationFailed:v3 != 0];
  }

  [*(a1 + 32) setFullServiceEnumerationPendingCachePrimedEvent:0];
  v5 = objc_autoreleasePoolPush();
  v6 = *(a1 + 32);
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543618;
    v30 = v8;
    v31 = 2112;
    v32 = v3;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Completed rebuilding HAP services from MTRDevice cache with error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  v9 = [*(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  v10 = [v9 copy];

  v11 = [*(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  [v11 removeAllObjects];

  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v12 = v10;
  v13 = [v12 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v13)
  {
    v14 = v13;
    v15 = *v25;
    do
    {
      v16 = 0;
      do
      {
        if (*v25 != v15)
        {
          objc_enumerationMutation(v12);
        }

        (*(*(*(&v24 + 1) + 8 * v16++) + 16))();
      }

      while (v14 != v16);
      v14 = [v12 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v14);
  }

  v17 = *(a1 + 32);
  v21[0] = MEMORY[0x277D85DD0];
  v21[1] = 3221225472;
  v21[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_788;
  v21[3] = &unk_2786F0C10;
  v21[4] = v17;
  v18 = *(a1 + 40);
  v22 = v3;
  v23 = v18;
  v19 = v3;
  [v17 updateAllCharacteristicValuesPostHAPServiceEnumeration:v21];

  v20 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_789(uint64_t a1, void *a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  v177 = *MEMORY[0x277D85DE8];
  v13 = a2;
  v133 = a4;
  v134 = a5;
  v135 = a6;
  v139 = a7;
  v132 = a8;
  v136 = [HMMTRHAPServiceDescription descriptionsDictionaryFromAccessoryInfo:v13];
  v142 = objc_alloc_init(MEMORY[0x277CBEB38]);
  v143 = v13;
  v14 = MEMORY[0x277CBEB18];
  v15 = [v13 accessoryInfoDictionary];
  v16 = [v15 allKeys];
  v17 = [v14 arrayWithArray:v16];

  [v17 sortUsingComparator:&__block_literal_global_792];
  v163 = 0u;
  v164 = 0u;
  v161 = 0u;
  v162 = 0u;
  obj = v17;
  v18 = [obj countByEnumeratingWithState:&v161 objects:v176 count:16];
  if (v18)
  {
    v19 = v18;
    v20 = *v162;
    do
    {
      for (i = 0; i != v19; ++i)
      {
        if (*v162 != v20)
        {
          objc_enumerationMutation(obj);
        }

        v22 = *(*(&v161 + 1) + 8 * i);
        v23 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(v22, "integerValue")}];
        v24 = [v143 nameForEndpoint:v23];
        v25 = v24;
        if (v24 && ![v24 isEqual:&stru_283ED2308] || (objc_msgSend(MEMORY[0x277CCACA8], "stringWithFormat:", @"%@,%@", @"Matter Accessory", v22), v26 = objc_claimAutoreleasedReturnValue(), v25, (v25 = v26) != 0))
        {
          [v142 setObject:v25 forKey:v22];
        }
      }

      v19 = [obj countByEnumeratingWithState:&v161 objects:v176 count:16];
    }

    while (v19);
  }

  if (![v136 count] && !a3)
  {
    v27 = objc_autoreleasePoolPush();
    v28 = a1;
    v29 = *(a1 + 32);
    v30 = HMFGetOSLogHandle();
    v31 = v134;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      v32 = HMFGetLogIdentifier();
      *buf = 138543362;
      v171 = v32;
      _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_INFO, "%{public}@The accessory contains no valid HAP services in endpoint hierarchy", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v27);
    [*(a1 + 32) _setCategoryForPrimaryAccessory:&unk_283EE89E8];
    v33 = *(a1 + 32);
    v34 = [v33 matterDevice];
    v144[0] = MEMORY[0x277D85DD0];
    v144[1] = 3221225472;
    v144[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_807;
    v144[3] = &unk_2786F0C10;
    v35 = *(a1 + 40);
    v144[4] = *(a1 + 32);
    v146 = v35;
    v36 = v132;
    v145 = v132;
    [v33 _createFirmwareUpdateServiceWithInstanceID:10 device:v34 completionHandler:v144];

    v37 = v133;
    goto LABEL_81;
  }

  v28 = a1;
  v38 = [*(a1 + 32) nodeID];
  v31 = v134;
  v39 = [v134 storeForNodeId:v38 server:*(a1 + 32)];

  v40 = objc_autoreleasePoolPush();
  v41 = *(a1 + 32);
  v42 = HMFGetOSLogHandle();
  v43 = v42;
  v131 = v39;
  if (v39)
  {
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      v44 = HMFGetLogIdentifier();
      v45 = [*(a1 + 32) nodeID];
      *buf = 138543618;
      v171 = v44;
      v172 = 2112;
      v173 = v45;
      v46 = "%{public}@Failed to store device(%@) topology";
      v47 = v43;
      v48 = OS_LOG_TYPE_ERROR;
      v49 = 22;
LABEL_22:
      _os_log_impl(&dword_22AEAE000, v47, v48, v46, buf, v49);
    }
  }

  else if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
  {
    v44 = HMFGetLogIdentifier();
    v45 = [*(a1 + 32) nodeID];
    *buf = 138543874;
    v171 = v44;
    v172 = 2112;
    v173 = v45;
    v174 = 2112;
    v175 = v134;
    v46 = "%{public}@Successfully stored device(%@) topology: %@";
    v47 = v43;
    v48 = OS_LOG_TYPE_INFO;
    v49 = 32;
    goto LABEL_22;
  }

  objc_autoreleasePoolPop(v40);
  v50 = objc_autoreleasePoolPush();
  v51 = *(a1 + 32);
  v52 = HMFGetOSLogHandle();
  v53 = os_log_type_enabled(v52, OS_LOG_TYPE_INFO);
  if (a3)
  {
    if (v53)
    {
      v54 = HMFGetLogIdentifier();
      *buf = 138543618;
      v171 = v54;
      v172 = 2112;
      v173 = v143;
      _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_INFO, "%{public}@Bridge services dictionary: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v50);
    v55 = [v136 mutableCopy];
    v37 = v133;
    v56 = [v133 stringValue];
    [v55 removeObjectForKey:v56];

    v57 = [*(a1 + 32) hapEnumerator];
    v58 = [*(a1 + 32) primaryAccessory];
    v169 = v58;
    v59 = [MEMORY[0x277CBEA60] arrayWithObjects:&v169 count:1];
    v130 = v55;
    v60 = [v57 enumerateBridgedAccessoriesFromAccessories:v59 serviceDescriptionsDictionary:v55 namesDictionary:v142 topology:v134 server:*(a1 + 32) legacyInstanceIDAssignment:0];

    v138 = v60;
    [*(a1 + 32) setAccessories:v60];
    [*(a1 + 32) _distinctEndpointsHavingHapServicesForTopology:v134];
    v157 = 0u;
    v158 = 0u;
    v159 = 0u;
    v61 = v160 = 0u;
    v62 = [v61 countByEnumeratingWithState:&v157 objects:v168 count:16];
    if (v62)
    {
      v63 = v62;
      v64 = *v158;
      do
      {
        for (j = 0; j != v63; ++j)
        {
          if (*v158 != v64)
          {
            objc_enumerationMutation(v61);
          }

          [*(a1 + 32) _updateDefaultEntriesForBridgedClusterIDCharacteristicMap:*(*(&v157 + 1) + 8 * j)];
        }

        v63 = [v61 countByEnumeratingWithState:&v157 objects:v168 count:16];
      }

      while (v63);
    }

    if (v135)
    {
      v66 = [HMMTRHAPServiceDescription descriptionsDictionaryFromAccessoryInfo:?];
      if ([v66 count])
      {
        v67 = objc_autoreleasePoolPush();
        v68 = *(a1 + 32);
        v69 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
        {
          v70 = HMFGetLogIdentifier();
          *buf = 138543618;
          v171 = v70;
          v172 = 2112;
          v173 = v66;
          _os_log_impl(&dword_22AEAE000, v69, OS_LOG_TYPE_INFO, "%{public}@Bridge node native services dictionary: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v67);
        v71 = objc_autoreleasePoolPush();
        v72 = *(a1 + 32);
        v73 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
        {
          v74 = HMFGetLogIdentifier();
          *buf = 138543618;
          v171 = v74;
          v172 = 2112;
          v173 = v139;
          _os_log_impl(&dword_22AEAE000, v73, OS_LOG_TYPE_INFO, "%{public}@Bridge node native topology: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v71);
        v75 = [*(a1 + 32) hapEnumerator];
        v76 = [*(a1 + 32) primaryAccessory];
        v77 = [v76 services];
        v78 = [*(a1 + 32) nodeID];
        v79 = [*(a1 + 32) primaryAccessory];
        v80 = [v75 enumerateServicesFromServices:v77 serviceDescriptionsDictionary:v66 topology:v139 nodeID:v78 primaryAccessory:v79 legacyInstanceIDAssignment:0];

        v81 = objc_autoreleasePoolPush();
        v82 = *(a1 + 32);
        v83 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
        {
          v84 = HMFGetLogIdentifier();
          *buf = 138543618;
          v171 = v84;
          v172 = 2112;
          v173 = v80;
          _os_log_impl(&dword_22AEAE000, v83, OS_LOG_TYPE_INFO, "%{public}@Bridge node services updated with native Matter functionalities: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v81);
        if (v80)
        {
          v85 = [*(a1 + 32) primaryAccessory];
          [v85 setServices:v80];
        }

        v128 = v80;
        v129 = v66;
        v86 = [v66 allValues];
        v87 = [v86 na_flatMap:&__block_literal_global_801];

        v127 = v87;
        v126 = [MEMORY[0x277CBEB98] setWithArray:v87];
        v88 = [v126 allObjects];
        v89 = [MEMORY[0x277CCAC98] sortDescriptorWithKey:@"self" ascending:1];
        v167 = v89;
        v90 = [MEMORY[0x277CBEA60] arrayWithObjects:&v167 count:1];
        v91 = [v88 sortedArrayUsingDescriptors:v90];

        v155 = 0u;
        v156 = 0u;
        v153 = 0u;
        v154 = 0u;
        v92 = v91;
        v93 = [v92 countByEnumeratingWithState:&v153 objects:v166 count:16];
        if (v93)
        {
          v94 = v93;
          v95 = *v154;
          v96 = &unk_283EE8BF8;
          while (2)
          {
            for (k = 0; k != v94; ++k)
            {
              if (*v154 != v95)
              {
                objc_enumerationMutation(v92);
              }

              v98 = *(a1 + 32);
              v99 = [v139 getHAPCategoriesAtEndpoint:*(*(&v153 + 1) + 8 * k)];
              v100 = [v98 _getFirstNonOtherCategory:v99];

              if (v100)
              {
                v101 = v100;

                if (([v101 isEqual:&unk_283EE89E8] & 1) == 0)
                {

                  v96 = v101;
                  goto LABEL_77;
                }

                v96 = v101;
              }
            }

            v94 = [v92 countByEnumeratingWithState:&v153 objects:v166 count:16];
            if (v94)
            {
              continue;
            }

            break;
          }
        }

        else
        {
          v96 = &unk_283EE8BF8;
        }

LABEL_77:

        v37 = v133;
        v28 = a1;
        v66 = v129;
      }

      else
      {
        v96 = &unk_283EE8BF8;
      }
    }

    else
    {
      v96 = &unk_283EE8BF8;
    }

LABEL_79:
    v121 = v131;
    v36 = v132;
  }

  else
  {
    if (v53)
    {
      v102 = HMFGetLogIdentifier();
      *buf = 138543618;
      v171 = v102;
      v172 = 2112;
      v173 = v143;
      _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_INFO, "%{public}@Accessory services dictionary: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v50);
    [*(a1 + 32) _initAccessoriesForServer];
    v103 = [*(a1 + 32) hapEnumerator];
    v104 = [*(a1 + 32) primaryAccessory];
    v105 = [v104 services];
    v106 = [*(a1 + 32) nodeID];
    v107 = [*(a1 + 32) primaryAccessory];
    v108 = [v103 enumerateServicesFromServices:v105 serviceDescriptionsDictionary:v136 topology:v134 nodeID:v106 primaryAccessory:v107 legacyInstanceIDAssignment:0];

    v109 = objc_autoreleasePoolPush();
    v110 = *(a1 + 32);
    v111 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
    {
      v112 = HMFGetLogIdentifier();
      *buf = 138543618;
      v171 = v112;
      v172 = 2112;
      v173 = v108;
      _os_log_impl(&dword_22AEAE000, v111, OS_LOG_TYPE_INFO, "%{public}@Accessory services: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v109);
    if (v108)
    {
      v113 = [*(a1 + 32) primaryAccessory];
      [v113 setServices:v108];
    }

    v130 = v108;
    v151 = 0u;
    v152 = 0u;
    v149 = 0u;
    v150 = 0u;
    v138 = obj;
    v114 = [v138 countByEnumeratingWithState:&v149 objects:v165 count:16];
    if (v114)
    {
      v115 = v114;
      v96 = 0;
      v116 = *v150;
      while (2)
      {
        for (m = 0; m != v115; ++m)
        {
          if (*v150 != v116)
          {
            objc_enumerationMutation(v138);
          }

          v118 = *(a1 + 32);
          v119 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(*(*(&v149 + 1) + 8 * m), "integerValue")}];
          v120 = [v118 _categoryFromAccessoryInfo:v143 endpoint:v119];

          if (v120)
          {
            v61 = v120;

            v96 = v61;
            if (![v61 isEqual:&unk_283EE89E8])
            {
              v96 = v61;
              v37 = v133;
              v31 = v134;
              v28 = a1;
              goto LABEL_79;
            }
          }
        }

        v115 = [v138 countByEnumeratingWithState:&v149 objects:v165 count:16];
        if (v115)
        {
          continue;
        }

        break;
      }

      v37 = v133;
      v31 = v134;
      v28 = a1;
    }

    else
    {
      v96 = 0;
      v37 = v133;
    }

    v121 = v131;
    v36 = v132;
  }

  [*(v28 + 32) _setCategoryForPrimaryAccessory:v96];
  v122 = *(v28 + 32);
  v123 = [v122 matterDevice];
  v147[0] = MEMORY[0x277D85DD0];
  v147[1] = 3221225472;
  v147[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_806;
  v147[3] = &unk_2786EF8A0;
  v124 = *(v28 + 40);
  v147[4] = *(v28 + 32);
  v148 = v124;
  [v122 _createFirmwareUpdateServiceWithInstanceID:10 device:v123 completionHandler:v147];

LABEL_81:
  [*(v28 + 32) setServiceEnumerationInProgress:0];

  v125 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_809(uint64_t a1)
{
  v9 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v7 = 138543362;
    v8 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Queued accessory operation for MTRDevice caching for deferred full service enumeration is executed", &v7, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_810(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Accessory operation for MTRDevice caching for deferred full service enumeration completes with error: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_806(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543618;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Firmware update service not created: %@", &v9, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  (*(*(a1 + 40) + 16))();

  v8 = *MEMORY[0x277D85DE8];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_807(uint64_t a1, void *a2)
{
  v14 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      v10 = 138543618;
      v11 = v7;
      v12 = 2112;
      v13 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Firmware update service not created: %@", &v10, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  v8 = *(a1 + 40);
  (*(*(a1 + 48) + 16))();

  v9 = *MEMORY[0x277D85DE8];
}

uint64_t __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v4 = MEMORY[0x277CCABB0];
  v5 = a3;
  v6 = [v4 numberWithInteger:{objc_msgSend(a2, "integerValue")}];
  v7 = MEMORY[0x277CCABB0];
  v8 = [v5 integerValue];

  v9 = [v7 numberWithInteger:v8];
  v10 = [v6 compare:v9];

  return v10;
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_788(uint64_t a1, void *a2)
{
  v14 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v10 = 138543618;
    v11 = v7;
    v12 = 2112;
    v13 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristic values updated, error: %@", &v10, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *(a1 + 48);
  if (v8)
  {
    (*(v8 + 16))(v8, *(a1 + 40));
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory:(id)accessory completion:(id)completion
{
  v51 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  completionCopy = completion;
  v6 = objc_autoreleasePoolPush();
  selfCopy = self;
  v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    v9 = HMFGetLogIdentifier();
    *buf = 138543618;
    *&buf[4] = v9;
    *&buf[12] = 2112;
    *&buf[14] = accessoryCopy;
    _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Updating all characteristic values from MTRDevice cache for accessory %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v6);
  v10 = dispatch_group_create();
  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x3032000000;
  v48 = __Block_byref_object_copy__10189;
  v49 = __Block_byref_object_dispose__10190;
  v50 = 0;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  services = [accessoryCopy services];
  v12 = [services countByEnumeratingWithState:&v41 objects:v46 count:16];
  obj = services;
  if (v12)
  {
    v27 = *v42;
    do
    {
      v13 = 0;
      v28 = v12;
      do
      {
        if (*v42 != v27)
        {
          objc_enumerationMutation(obj);
        }

        v14 = *(*(&v41 + 1) + 8 * v13);
        v37 = 0u;
        v38 = 0u;
        v39 = 0u;
        v40 = 0u;
        characteristics = [v14 characteristics];
        v16 = [characteristics countByEnumeratingWithState:&v37 objects:v45 count:16];
        v29 = v13;
        if (v16)
        {
          v17 = *v38;
          do
          {
            v18 = 0;
            do
            {
              if (*v38 != v17)
              {
                objc_enumerationMutation(characteristics);
              }

              v19 = *(*(&v37 + 1) + 8 * v18);
              dispatch_group_enter(v10);
              v34[0] = MEMORY[0x277D85DD0];
              v34[1] = 3221225472;
              v34[2] = __102__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory_completion___block_invoke;
              v34[3] = &unk_2786EFE60;
              v34[4] = selfCopy;
              v34[5] = v19;
              v36 = buf;
              v35 = v10;
              [(HMMTRAccessoryServer *)selfCopy _readCharacteristicValueFromCacheWithCharacteristic:v19 responseHandler:v34];

              ++v18;
            }

            while (v16 != v18);
            v16 = [characteristics countByEnumeratingWithState:&v37 objects:v45 count:16];
          }

          while (v16);
        }

        v13 = v29 + 1;
      }

      while (v29 + 1 != v28);
      v12 = [obj countByEnumeratingWithState:&v41 objects:v46 count:16];
    }

    while (v12);
  }

  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __102__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory_completion___block_invoke_787;
  block[3] = &unk_2786EFE88;
  v31 = accessoryCopy;
  v32 = completionCopy;
  v33 = buf;
  v21 = completionCopy;
  v22 = accessoryCopy;
  dispatch_group_notify(v10, clientQueue, block);

  _Block_object_dispose(buf, 8);
  v23 = *MEMORY[0x277D85DE8];
}

void __102__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory_completion___block_invoke(uint64_t a1, void *a2)
{
  v28 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = v3;
  if (v3)
  {
    v5 = [v3 error];

    if (!v5)
    {
      v15 = objc_autoreleasePoolPush();
      v16 = *(a1 + 32);
      v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = HMFGetLogIdentifier();
        v19 = [*(a1 + 40) type];
        v20 = [v4 value];
        v22 = 138543874;
        v23 = v18;
        v24 = 2112;
        v25 = v19;
        v26 = 2112;
        v27 = v20;
        _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_DEBUG, "%{public}@Updated value for characteristic type: %@, value: %@", &v22, 0x20u);
      }

      objc_autoreleasePoolPop(v15);
      v14 = [v4 value];
      [*(a1 + 40) setValue:v14];
      goto LABEL_11;
    }
  }

  v6 = objc_autoreleasePoolPush();
  v7 = *(a1 + 32);
  v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v9 = HMFGetLogIdentifier();
    v10 = [*(a1 + 40) type];
    v22 = 138543618;
    v23 = v9;
    v24 = 2112;
    v25 = v10;
    _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Value update failed for characteristic type: %@", &v22, 0x16u);
  }

  objc_autoreleasePoolPop(v6);
  if (v4)
  {
    v11 = [v4 error];

    if (v11)
    {
      v12 = [v4 error];
      v13 = *(*(a1 + 56) + 8);
      v14 = *(v13 + 40);
      *(v13 + 40) = v12;
LABEL_11:
    }
  }

  dispatch_group_leave(*(a1 + 48));

  v21 = *MEMORY[0x277D85DE8];
}

uint64_t __102__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory_completion___block_invoke_787(void *a1)
{
  [HMMTRAccessoryServer propagateCharactersticValuesToAccessory:a1[4]];
  v2 = *(*(a1[6] + 8) + 40);
  v3 = *(a1[5] + 16);

  return v3();
}

- (void)updateAllCharacteristicValuesPostHAPServiceEnumeration:(id)enumeration
{
  v34 = *MEMORY[0x277D85DE8];
  enumerationCopy = enumeration;
  v4 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    LODWORD(buf) = 138543362;
    *(&buf + 4) = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Updating all characteristic values from MTRDevice cache", &buf, 0xCu);
  }

  objc_autoreleasePoolPop(v4);
  v7 = dispatch_group_create();
  *&buf = 0;
  *(&buf + 1) = &buf;
  v30 = 0x3032000000;
  v31 = __Block_byref_object_copy__10189;
  v32 = __Block_byref_object_dispose__10190;
  v33 = 0;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  accessories = [(HAPAccessoryServer *)selfCopy accessories];
  v9 = [accessories countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v9)
  {
    v10 = *v25;
    do
    {
      v11 = 0;
      do
      {
        if (*v25 != v10)
        {
          objc_enumerationMutation(accessories);
        }

        v12 = *(*(&v24 + 1) + 8 * v11);
        dispatch_group_enter(v7);
        v21[0] = MEMORY[0x277D85DD0];
        v21[1] = 3221225472;
        v21[2] = __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke;
        v21[3] = &unk_2786F0D18;
        p_buf = &buf;
        v22 = v7;
        [(HMMTRAccessoryServer *)selfCopy updateAllCharacteristicValuesPostHAPServiceEnumerationForAccessory:v12 completion:v21];

        ++v11;
      }

      while (v9 != v11);
      v9 = [accessories countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v9);
  }

  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke_2;
  block[3] = &unk_2786F0AF8;
  v19 = enumerationCopy;
  v20 = &buf;
  v14 = enumerationCopy;
  dispatch_group_notify(v7, clientQueue, block);

  _Block_object_dispose(&buf, 8);
  v15 = *MEMORY[0x277D85DE8];
}

void __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke(uint64_t a1, void *a2)
{
  v4 = a2;
  if (v4)
  {
    objc_storeStrong((*(*(a1 + 40) + 8) + 40), a2);
  }

  dispatch_group_leave(*(a1 + 32));
}

- (void)enumerateHAPServices:(id)services
{
  servicesCopy = services;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke;
  v7[3] = &unk_2786EF5A8;
  v7[4] = self;
  v8 = servicesCopy;
  v6 = servicesCopy;
  dispatch_async(clientQueue, v7);
}

void __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) fullServiceEnumerationPendingCachePrimedEvent];
  v3 = *(a1 + 32);
  if (v2)
  {
    v5 = [*(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
    v4 = MEMORY[0x2318887D0](*(a1 + 40));
    [v5 addObject:v4];
  }

  else
  {
    v6[0] = MEMORY[0x277D85DD0];
    v6[1] = 3221225472;
    v6[2] = __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke_2;
    v6[3] = &unk_2786EF8A0;
    v6[4] = v3;
    v7 = *(a1 + 40);
    [v3 _rebuildHAPServicesFromCHIPWithCompletionHandler:v6];
  }
}

void __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke_2(uint64_t a1, void *a2)
{
  v20 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v16 = 138543618;
      v17 = v8;
      v18 = 2112;
      v19 = v3;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to rebuild HAP services of CHIP Accessory with error %@", &v16, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v16 = 138543362;
      v17 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Triggering a discovery for Accessory server after enumerating...", &v16, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      v14 = [*(a1 + 32) clusterIDCharacteristicMap];
      v16 = 138543618;
      v17 = v13;
      v18 = 2112;
      v19 = v14;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, "%{public}@clusterIDCharacteristicMap : %@", &v16, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    [*(a1 + 32) discoverAccessories];
  }

  (*(*(a1 + 40) + 16))();

  v15 = *MEMORY[0x277D85DE8];
}

- (id)_distinctEndpointsHavingHapServicesForTopology:(id)topology
{
  v21 = *MEMORY[0x277D85DE8];
  hapServiceTypes = [topology hapServiceTypes];
  v4 = MEMORY[0x277CBEB18];
  allKeys = [hapServiceTypes allKeys];
  v6 = [v4 arrayWithArray:allKeys];

  v7 = objc_alloc_init(MEMORY[0x277CBEB18]);
  [v6 sortUsingComparator:&__block_literal_global_785];
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v8 = v6;
  v9 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v9)
  {
    v10 = v9;
    v11 = *v17;
    do
    {
      for (i = 0; i != v10; ++i)
      {
        if (*v17 != v11)
        {
          objc_enumerationMutation(v8);
        }

        v13 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(*(*(&v16 + 1) + 8 * i), "integerValue", v16)}];
        if (([v7 containsObject:v13] & 1) == 0)
        {
          [v7 addObject:v13];
        }
      }

      v10 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v10);
  }

  v14 = *MEMORY[0x277D85DE8];

  return v7;
}

uint64_t __71__HMMTRAccessoryServer__distinctEndpointsHavingHapServicesForTopology___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v4 = MEMORY[0x277CCABB0];
  v5 = a3;
  v6 = [v4 numberWithInteger:{objc_msgSend(a2, "integerValue")}];
  v7 = MEMORY[0x277CCABB0];
  v8 = [v5 integerValue];

  v9 = [v7 numberWithInteger:v8];
  v10 = [v6 compare:v9];

  return v10;
}

- (void)_createFirmwareUpdateServiceWithInstanceID:(int64_t)d device:(id)device completionHandler:(id)handler
{
  deviceCopy = device;
  handlerCopy = handler;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x2020000000;
  v19[3] = d;
  v10 = [HMMTRDeviceTopology alloc];
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  v12 = [(HMMTRDeviceTopology *)v10 initWithNodeId:nodeID server:self];

  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x277D85DD0];
  v15[1] = 3221225472;
  v15[2] = __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke;
  v15[3] = &unk_2786EFE18;
  v14 = handlerCopy;
  v15[4] = self;
  v16 = v14;
  v17 = v19;
  dCopy = d;
  [(HMMTRAccessoryServer *)self _endpointForOTARequestorWithTopology:v12 mtrDevice:deviceCopy callbackQueue:clientQueue completionHandler:v15];

  _Block_object_dispose(v19, 8);
}

void __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v67 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    (*(*(a1 + 40) + 16))();
  }

  else
  {
    if (v5)
    {
      v7 = objc_autoreleasePoolPush();
      v8 = *(a1 + 32);
      v9 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = HMFGetLogIdentifier();
        v11 = *(a1 + 56);
        *buf = 138543874;
        v62 = v10;
        v63 = 2048;
        v64 = v11;
        v65 = 2112;
        v66 = v5;
        _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Create firmware update service using instanceID: %lu for endpoint: %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v7);
      v12 = [MEMORY[0x277CFEBA0] getSharedInstance];
      v13 = [v12 getDefaultCharacteristicMetadata:@"00000234-0000-1000-8000-0026BB765291"];
      v14 = [v12 getDefaultCharacteristicProperties:@"00000234-0000-1000-8000-0026BB765291"];
      v15 = [v14 integerValue];

      v50 = *(a1 + 56);
      v55 = objc_alloc_init(MEMORY[0x277CFEB50]);
      v60 = 0;
      v53 = [v55 serializeWithError:&v60];
      v54 = v5;
      v16 = v60;
      v17 = objc_alloc(MEMORY[0x277CFEA68]);
      v18 = MEMORY[0x277CCABB0];
      ++*(*(*(a1 + 48) + 8) + 24);
      v19 = [v18 numberWithInteger:?];
      v56 = [v17 initWithType:@"00000234-0000-1000-8000-0026BB765291" instanceID:v19 value:v53 stateNumber:0 properties:v15 eventNotificationsEnabled:1 metadata:v13];

      v20 = [v12 getDefaultCharacteristicMetadata:@"00000235-0000-1000-8000-0026BB765291"];

      v21 = [v12 getDefaultCharacteristicProperties:@"00000235-0000-1000-8000-0026BB765291"];
      LOWORD(v19) = [v21 integerValue];

      v52 = objc_alloc_init(MEMORY[0x277CFEB58]);
      v59 = v16;
      v51 = [v52 serializeWithError:&v59];
      v22 = v59;

      v23 = objc_alloc(MEMORY[0x277CFEA68]);
      v24 = MEMORY[0x277CCABB0];
      ++*(*(*(a1 + 48) + 8) + 24);
      v25 = [v24 numberWithInteger:?];
      v45 = [v23 initWithType:@"00000235-0000-1000-8000-0026BB765291" instanceID:v25 value:v51 stateNumber:0 properties:v19 eventNotificationsEnabled:1 metadata:v20];

      v48 = [v12 getDefaultCharacteristicMetadata:@"0000026E-0000-1000-8000-0026BB765291"];

      v26 = [v12 getDefaultCharacteristicProperties:@"0000026E-0000-1000-8000-0026BB765291"];
      LOWORD(v23) = [v26 integerValue];

      v49 = objc_alloc_init(MEMORY[0x277CFEB98]);
      v58 = v22;
      v46 = [v49 serializeWithError:&v58];
      v47 = v58;

      v27 = objc_alloc(MEMORY[0x277CFEA68]);
      v28 = MEMORY[0x277CCABB0];
      ++*(*(*(a1 + 48) + 8) + 24);
      v29 = [v28 numberWithInteger:?];
      v30 = [v27 initWithType:@"0000026E-0000-1000-8000-0026BB765291" instanceID:v29 value:v46 stateNumber:0 properties:v23 eventNotificationsEnabled:1 metadata:v48];

      v31 = [MEMORY[0x277CBEA60] arrayWithObjects:{v56, v45, v30, 0}];
      v32 = [v12 getDefaultServiceProperties:@"00000236-0000-1000-8000-0026BB765291"];
      v33 = [v32 integerValue];

      v34 = objc_alloc(MEMORY[0x277CFEC40]);
      v35 = [MEMORY[0x277CCABB0] numberWithInteger:v50];
      v36 = [v34 initWithType:@"00000236-0000-1000-8000-0026BB765291" instanceID:v35 parsedCharacteristics:v31 serviceProperties:v33 linkedServices:0];

      v37 = [*(a1 + 32) primaryAccessory];
      [v36 setAccessory:v37];

      v38 = [*(a1 + 32) primaryAccessory];
      v39 = [v38 services];
      v57[0] = MEMORY[0x277D85DD0];
      v57[1] = 3221225472;
      v57[2] = __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke_780;
      v57[3] = &__block_descriptor_40_e20_B16__0__HAPService_8l;
      v57[4] = v50;
      v40 = [v39 na_filter:v57];

      v41 = [MEMORY[0x277CBEB18] arrayWithObject:v36];
      [v41 addObjectsFromArray:v40];
      v42 = [*(a1 + 32) primaryAccessory];
      [v42 setServices:v41];

      (*(*(a1 + 40) + 16))();
      v5 = v54;
    }

    else
    {
      v43 = *(a1 + 40);
      v12 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
      (*(v43 + 16))(v43, v12);
    }
  }

  v44 = *MEMORY[0x277D85DE8];
}

uint64_t __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke_780(uint64_t a1, void *a2)
{
  v3 = [a2 instanceID];
  v4 = [MEMORY[0x277CCABB0] numberWithInteger:*(a1 + 32)];
  v5 = [v3 isEqual:v4];

  return v5 ^ 1u;
}

- (void)_endpointForOTARequestorWithTopology:(id)topology mtrDevice:(id)device callbackQueue:(id)queue completionHandler:(id)handler
{
  v29 = *MEMORY[0x277D85DE8];
  topologyCopy = topology;
  deviceCopy = device;
  queueCopy = queue;
  handlerCopy = handler;
  getOTARequestorEndpoints = [topologyCopy getOTARequestorEndpoints];
  if (getOTARequestorEndpoints)
  {
    v15 = [topologyCopy getVersionForKey:@"EnumeratedProtocolMap"];
    intValue = [v15 intValue];

    if (intValue > 100)
    {
      getEnabledOTARequestorEndpoint = [topologyCopy getEnabledOTARequestorEndpoint];
      if (getEnabledOTARequestorEndpoint)
      {
        handlerCopy[2](handlerCopy, getEnabledOTARequestorEndpoint, 0);
      }

      else
      {
        v23 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
        (handlerCopy)[2](handlerCopy, 0, v23);
      }

LABEL_11:

      goto LABEL_12;
    }
  }

  if (!deviceCopy)
  {
    v19 = objc_autoreleasePoolPush();
    selfCopy = self;
    v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v22 = HMFGetLogIdentifier();
      *buf = 138543362;
      v28 = v22;
      _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to get the OTA requestor endpoint", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v19);
    getEnabledOTARequestorEndpoint = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
    (handlerCopy)[2](handlerCopy, 0, getEnabledOTARequestorEndpoint);
    goto LABEL_11;
  }

  v17 = +[HMMTRDescriptorClusterManager sharedManager];
  v25[0] = MEMORY[0x277D85DD0];
  v25[1] = 3221225472;
  v25[2] = __103__HMMTRAccessoryServer__endpointForOTARequestorWithTopology_mtrDevice_callbackQueue_completionHandler___block_invoke;
  v25[3] = &unk_2786EFDD0;
  v26 = handlerCopy;
  [v17 endpointForClusterID:&unk_283EE8A48 mtrDevice:deviceCopy callbackQueue:queueCopy completionHandler:v25];

LABEL_12:
  v24 = *MEMORY[0x277D85DE8];
}

- (id)_categoryFromTopology:(id)topology endpoint:(id)endpoint
{
  v5 = [topology getHAPCategoriesAtEndpoint:endpoint];
  v6 = [(HMMTRAccessoryServer *)self _getFirstNonOtherCategory:v5];

  return v6;
}

- (id)_categoryFromAccessoryInfo:(id)info endpoint:(id)endpoint
{
  v5 = [info categoriesForEndpoint:endpoint];
  v6 = [(HMMTRAccessoryServer *)self _getFirstNonOtherCategory:v5];

  return v6;
}

- (id)_getFirstNonOtherCategory:(id)category
{
  v22[1] = *MEMORY[0x277D85DE8];
  categoryCopy = category;
  v4 = categoryCopy;
  if (categoryCopy)
  {
    if ([categoryCopy count] == 1)
    {
      v5 = [v4 objectAtIndexedSubscript:0];
    }

    else
    {
      v6 = [MEMORY[0x277CCAC98] sortDescriptorWithKey:@"self" ascending:1];
      v22[0] = v6;
      v7 = [MEMORY[0x277CBEA60] arrayWithObjects:v22 count:1];
      v8 = [v4 sortedArrayUsingDescriptors:v7];

      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v9 = v8;
      v10 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v10)
      {
        v11 = v10;
        v12 = *v18;
        while (2)
        {
          for (i = 0; i != v11; ++i)
          {
            if (*v18 != v12)
            {
              objc_enumerationMutation(v9);
            }

            v14 = *(*(&v17 + 1) + 8 * i);
            if ([v14 integerValue] > 1)
            {
              v5 = v14;

              goto LABEL_15;
            }
          }

          v11 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
          if (v11)
          {
            continue;
          }

          break;
        }
      }

      v5 = [MEMORY[0x277CCABB0] numberWithInt:1];
LABEL_15:
    }
  }

  else
  {
    v5 = 0;
  }

  v15 = *MEMORY[0x277D85DE8];

  return v5;
}

- (void)_setCategoryForPrimaryAccessory:(id)accessory
{
  v14 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  if (accessoryCopy)
  {
    [(HAPAccessoryServer *)self setCategory:accessoryCopy];
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      v10 = 138543618;
      v11 = v8;
      v12 = 2112;
      v13 = accessoryCopy;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Set category to %@ for primary accessory", &v10, 0x16u);
    }

    objc_autoreleasePoolPop(v5);
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)disconnectWithError:(id)error
{
  errorCopy = error;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __44__HMMTRAccessoryServer_disconnectWithError___block_invoke;
  v7[3] = &unk_2786EF328;
  v7[4] = self;
  v8 = errorCopy;
  v6 = errorCopy;
  dispatch_async(clientQueue, v7);
}

- (void)_disconnectWithError:(id)error
{
  v21 = *MEMORY[0x277D85DE8];
  errorCopy = error;
  if ([(HMMTRAccessoryServer *)self isPaired])
  {
    if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
    {
      v5 = objc_autoreleasePoolPush();
      selfCopy = self;
      v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        v8 = HMFGetLogIdentifier();
        v17 = 138543618;
        v18 = v8;
        v19 = 2112;
        v20 = selfCopy;
        _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Keeping CHIP link alive for accessory:%@ till invalidated", &v17, 0x16u);
      }

      objc_autoreleasePoolPop(v5);
    }

    else
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      isCurrentDevicePrimaryResident = [browser isCurrentDevicePrimaryResident];

      if ((isCurrentDevicePrimaryResident & 1) == 0)
      {
        v11 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v13 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        {
          v14 = HMFGetLogIdentifier();
          v17 = 138543618;
          v18 = v14;
          v19 = 2112;
          v20 = selfCopy2;
          _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Terminating CHIP link for accessory:%@. Only the Primary Resident may communicate with it now.", &v17, 0x16u);
        }

        objc_autoreleasePoolPop(v11);
        controllerWrapper = [(HMMTRAccessoryServer *)selfCopy2 controllerWrapper];
        [(HMMTRAccessoryServer *)selfCopy2 disable];
        [controllerWrapper suspendOrShutdown];
      }
    }
  }

  v16 = *MEMORY[0x277D85DE8];
}

- (void)finishPairing
{
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __37__HMMTRAccessoryServer_finishPairing__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = self;
  dispatch_async(clientQueue, block);
}

void __37__HMMTRAccessoryServer_finishPairing__block_invoke(uint64_t a1)
{
  v20 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v19 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Finishing pairing now", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  [*(a1 + 32) _persistAccessoryServerData];
  [*(a1 + 32) _disconnectWithError:0];
  [*(a1 + 32) _finishMaximumDurationCollection];
  if ([*(a1 + 32) shouldPairWithoutResident])
  {
    v6 = [*(a1 + 32) browser];
    v7 = [v6 storage];
    v8 = [v7 dataSource];
    v9 = [*(a1 + 32) fabricUUID];
    v10 = [v8 storageDataSourceForFabricUUID:v9];

    v11 = [*(a1 + 32) nodeID];
    v12 = [v10 storageDataSourceForDeviceWithNodeID:v11];
    v13 = [*(a1 + 32) vendorID];
    v14 = [*(a1 + 32) productID];
    v17[0] = MEMORY[0x277D85DD0];
    v17[1] = 3221225472;
    v17[2] = __37__HMMTRAccessoryServer_finishPairing__block_invoke_767;
    v17[3] = &unk_2786EF290;
    v17[4] = *(a1 + 32);
    [v12 updateVendorID:v13 productID:v14 completion:v17];
  }

  [*(a1 + 32) setDelayDiscovery:0];
  v15 = [*(a1 + 32) browser];
  [v15 didFinishPairingAccessoryServer:*(a1 + 32) operationDisabled:{objc_msgSend(*(a1 + 32), "operationDisabled")}];

  v16 = *MEMORY[0x277D85DE8];
}

void __37__HMMTRAccessoryServer_finishPairing__block_invoke_767(uint64_t a1, void *a2)
{
  v21 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v8 = [*(a1 + 32) vendorID];
      v9 = [*(a1 + 32) productID];
      v11 = 138544386;
      v12 = v7;
      v13 = 2080;
      v14 = "[HMMTRAccessoryServer finishPairing]_block_invoke";
      v15 = 2112;
      v16 = v8;
      v17 = 2112;
      v18 = v9;
      v19 = 2112;
      v20 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@%s: Failed to update vendorID to %@ and productID to %@ with error: %@", &v11, 0x34u);
    }

    objc_autoreleasePoolPop(v4);
  }

  v10 = *MEMORY[0x277D85DE8];
}

- (void)_finishMaximumDurationCollection
{
  v35 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    maxMetricDuration = [(HMMTRAccessoryServer *)selfCopy maxMetricDuration];
    name = [maxMetricDuration name];
    maxMetricDuration2 = [(HMMTRAccessoryServer *)selfCopy maxMetricDuration];
    duration = [maxMetricDuration2 duration];
    *buf = 138544898;
    v22 = v6;
    v23 = 2114;
    v24 = @"hmmtrAccessoryServerPairingMaximumDuration";
    v25 = 2112;
    v26 = @"Maximum time segment of pairing";
    v27 = 2114;
    v28 = @"hmmtrAccessoryPairingEventMaxDurationName";
    v29 = 2112;
    v30 = name;
    v31 = 2114;
    v32 = @"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds";
    v33 = 2112;
    v34 = duration;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@ %{public}@=%@", buf, 0x48u);
  }

  objc_autoreleasePoolPop(v3);
  mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
  v12 = objc_alloc(MEMORY[0x277D17DF8]);
  maxMetricDuration3 = [(HMMTRAccessoryServer *)selfCopy maxMetricDuration];
  name2 = [maxMetricDuration3 name];
  maxMetricDuration4 = [(HMMTRAccessoryServer *)selfCopy maxMetricDuration];
  duration2 = [maxMetricDuration4 duration];
  v17 = HMDTaggedLoggingCreateDictionary();
  v18 = [v12 initWithTag:@"hmmtrAccessoryServerPairingMaximumDuration" data:{v17, @"hmmtrAccessoryPairingEventMaxDurationName", name2, @"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds", duration2}];
  tagProcessorList = [(HMFActivity *)selfCopy->_activity tagProcessorList];
  [mEMORY[0x277D17DE8] submitTaggedEvent:v18 processorList:tagProcessorList];

  [(HMMTRAccessoryServer *)selfCopy setMaxMetricDuration:0];
  v20 = *MEMORY[0x277D85DE8];
}

- (void)_reportPairingComplete
{
  v26 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543874;
    v21 = v6;
    v22 = 2080;
    v23 = "[HMMTRAccessoryServer _reportPairingComplete]";
    v24 = 1024;
    operationDisabled = [(HMMTRAccessoryServer *)selfCopy operationDisabled];
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@%s operationDisabled = %d", buf, 0x1Cu);
  }

  objc_autoreleasePoolPop(v3);
  if (![(HMMTRAccessoryServer *)selfCopy operationDisabled])
  {
    [(HMMTRAccessoryServer *)selfCopy setDelayDiscovery:1];
  }

  if (isFeatureMatteriPhoneOnlyPairingControlEnabled() && ![(HMMTRAccessoryServer *)selfCopy operationDisabled]&& ![(HMMTRAccessoryServer *)selfCopy knownToSystemCommissioner])
  {
    v7 = [objc_alloc(MEMORY[0x277D0F920]) initWithTimeInterval:0 options:60.0];
    [(HMMTRAccessoryServer *)selfCopy setResidentReachabilityUpdateWaitTimer:v7];

    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    residentReachabilityUpdateWaitTimer = [(HMMTRAccessoryServer *)selfCopy residentReachabilityUpdateWaitTimer];
    [residentReachabilityUpdateWaitTimer setDelegateQueue:clientQueue];

    residentReachabilityUpdateWaitTimer2 = [(HMMTRAccessoryServer *)selfCopy residentReachabilityUpdateWaitTimer];
    [residentReachabilityUpdateWaitTimer2 setDelegate:selfCopy];

    residentReachabilityUpdateWaitTimer3 = [(HMMTRAccessoryServer *)selfCopy residentReachabilityUpdateWaitTimer];
    [residentReachabilityUpdateWaitTimer3 resume];

    v12 = objc_autoreleasePoolPush();
    v13 = selfCopy;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543362;
      v21 = v15;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Kicked off timer to stay active while resident updates reachability state", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v12);
  }

  [(HMMTRAccessoryServer *)selfCopy setPairingProgress:4];
  [(HMMTRAccessoryServer *)selfCopy _clearCommissioneeInfoAfterPairingCompletion];
  delegateQueue = [(HAPAccessoryServer *)selfCopy delegateQueue];

  if (delegateQueue)
  {
    delegateQueue2 = [(HAPAccessoryServer *)selfCopy delegateQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __46__HMMTRAccessoryServer__reportPairingComplete__block_invoke;
    block[3] = &unk_2786F0CA8;
    block[4] = selfCopy;
    dispatch_async(delegateQueue2, block);
  }

  v18 = *MEMORY[0x277D85DE8];
}

void __46__HMMTRAccessoryServer__reportPairingComplete__block_invoke(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) delegate];
  if ([v2 conformsToProtocol:&unk_283F236B0])
  {
    v3 = v2;
  }

  else
  {
    v3 = 0;
  }

  v4 = v3;

  if (v4)
  {
    [v4 accessoryServer:*(a1 + 32) didStopPairingWithError:0 matterPairingEndContext:0];
  }

  else
  {
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v10 = 138543362;
      v11 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Unable to find delegate confirming to HMMTRHAPAccessoryServerPairingDelegate", &v10, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)_finalizePairing
{
  v33 = *MEMORY[0x277D85DE8];
  v30[0] = MEMORY[0x277D85DD0];
  v30[1] = 3221225472;
  v30[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke;
  v30[3] = &unk_2786F0CA8;
  v30[4] = self;
  v3 = MEMORY[0x2318887D0](v30, a2);
  v28[0] = 0;
  v28[1] = v28;
  v28[2] = 0x2020000000;
  v29 = 0;
  v26[0] = 0;
  v26[1] = v26;
  v26[2] = 0x3032000000;
  v26[3] = __Block_byref_object_copy__10189;
  v26[4] = __Block_byref_object_dispose__10190;
  v27 = 0;
  v4 = dispatch_group_create();
  [(HMMTRAccessoryServer *)self setBlockInvalidation:1];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    dispatch_group_enter(v4);
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2;
    v24[3] = &unk_2786EF9E0;
    v24[4] = self;
    v25 = v4;
    [(HMMTRAccessoryServer *)self _fetchSerialNumberWithCompletionHandler:v24];
  }

  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:9];
  dispatch_group_enter(v4);
  populateACLEntriesForPairing = [(HMMTRAccessoryServer *)self populateACLEntriesForPairing];
  v6 = [populateACLEntriesForPairing objectForKeyedSubscript:@"adminNodesForPairing"];
  v7 = [populateACLEntriesForPairing objectForKeyedSubscript:@"regularNodesForPairing"];
  v20[0] = MEMORY[0x277D85DD0];
  v20[1] = 3221225472;
  v20[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_642;
  v20[3] = &unk_2786EFD80;
  v20[4] = self;
  v22 = v28;
  v23 = v26;
  v8 = v4;
  v21 = v8;
  [(HMMTRAccessoryServer *)self updateAccessoryControlToAdministratorNodes:v6 sharedUserNodes:v7 completion:v20];
  delegateQueue = [(HAPAccessoryServer *)self delegateQueue];

  if (delegateQueue)
  {
    delegateQueue2 = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_653;
    block[3] = &unk_2786EFDA8;
    block[4] = self;
    v18 = v28;
    v19 = v26;
    v17 = v3;
    dispatch_group_notify(v8, delegateQueue2, block);
  }

  else
  {
    v11 = objc_autoreleasePoolPush();
    selfCopy = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543362;
      v32 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_ERROR, "%{public}@Browser died. Updating paired state but the accessory server must be removed soon.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v11);
    v3[2](v3);
  }

  _Block_object_dispose(v26, 8);
  _Block_object_dispose(v28, 8);

  v15 = *MEMORY[0x277D85DE8];
}

uint64_t __40__HMMTRAccessoryServer__finalizePairing__block_invoke(uint64_t a1)
{
  [*(a1 + 32) setStorageUpdatePending:1];
  [*(a1 + 32) setPairedState:3];
  v2 = *(a1 + 32);

  return [v2 setSecuritySessionOpen:1];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543618;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch serial number of CHIP Accessory with error %@", &v9, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  dispatch_group_leave(*(a1 + 40));

  v8 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_642(uint64_t a1, void *a2)
{
  v41 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      *buf = 138543618;
      *&buf[4] = v7;
      *&buf[12] = 2112;
      *&buf[14] = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update Access control List on device %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
    *(*(*(a1 + 48) + 8) + 24) = 1;
    if ([v3 hmmtr_isMatterError])
    {
      [HMMTRAccessoryPairingEndContext mtrContextWithStep:9 error:v3];
    }

    else
    {
      [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:9 error:v3];
    }
    v8 = ;
    v9 = *(*(a1 + 56) + 8);
    v10 = *(v9 + 40);
    *(v9 + 40) = v8;
  }

  dispatch_group_enter(*(a1 + 40));
  v11 = *(a1 + 32);
  v37[0] = MEMORY[0x277D85DD0];
  v37[1] = 3221225472;
  v37[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_643;
  v37[3] = &unk_2786EFCE0;
  v37[4] = v11;
  v38 = *(a1 + 40);
  [v11 _fetchCurrentPairingWithCompletionHandler:v37];
  v12 = [*(a1 + 32) knownToSystemCommissioner];
  v13 = *(a1 + 32);
  if (v12)
  {
    v14 = [v13 category];
    v15 = v14 == 0;

    if (v15)
    {
      [*(a1 + 32) _notifyDelegateOfPairingStep:11];
      dispatch_group_enter(*(a1 + 40));
      v26 = *(a1 + 32);
      v35[0] = MEMORY[0x277D85DD0];
      v35[1] = 3221225472;
      v35[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_644;
      v35[3] = &unk_2786EF9E0;
      v35[4] = v26;
      v36 = *(a1 + 40);
      [v26 _buildHAPCategoriesFromCHIPWithCompletionHandler:v35];
    }

    else
    {
      v16 = objc_autoreleasePoolPush();
      v17 = *(a1 + 32);
      v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        v19 = HMFGetLogIdentifier();
        v20 = [*(a1 + 32) category];
        *buf = 138543618;
        *&buf[4] = v19;
        *&buf[12] = 2112;
        *&buf[14] = v20;
        _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Inherited accessory category: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v16);
    }
  }

  else
  {
    [v13 _notifyDelegateOfPairingStep:12];
    dispatch_group_enter(*(a1 + 40));
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v40 = 0;
    v31[0] = MEMORY[0x277D85DD0];
    v31[1] = 3221225472;
    v31[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_645;
    v31[3] = &unk_2786EFD58;
    v21 = *(a1 + 32);
    v33 = buf;
    v31[4] = v21;
    v32 = *(a1 + 40);
    v34 = *(a1 + 48);
    v22 = MEMORY[0x2318887D0](v31);
    [*(a1 + 32) _rebuildHAPServicesFromCHIPWithCompletionHandler:v22];
    v23 = dispatch_time(0, 180000000000);
    v24 = [*(a1 + 32) clientQueue];
    v28[0] = MEMORY[0x277D85DD0];
    v28[1] = 3221225472;
    v28[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_652;
    v28[3] = &unk_2786EFE88;
    v29 = v22;
    v30 = buf;
    v28[4] = *(a1 + 32);
    v25 = v22;
    dispatch_after(v23, v24, v28);

    _Block_object_dispose(buf, 8);
  }

  dispatch_group_leave(*(a1 + 40));

  v27 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_653(uint64_t a1)
{
  v30 = *MEMORY[0x277D85DE8];
  [*(a1 + 32) setBlockInvalidation:0];
  if (![*(a1 + 32) pairingProgress] || objc_msgSend(*(a1 + 32), "pairingProgress") == 3)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      v5 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v5;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Pairing already failed or stopped when accessory information collection completed", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v2);
    goto LABEL_6;
  }

  v7 = *(a1 + 32);
  if (*(*(*(a1 + 48) + 8) + 24) != 1)
  {
    v11 = [*(a1 + 32) knownToSystemCommissioner];
    v12 = *(a1 + 32);
    if (v11)
    {
      v13 = [v12 clientQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_654;
      block[3] = &unk_2786EF5A8;
      v14 = *(a1 + 40);
      block[4] = *(a1 + 32);
      v27 = v14;
      dispatch_async(v13, block);

LABEL_6:
      v6 = *MEMORY[0x277D85DE8];
      return;
    }

    v15 = [v12 browser];
    if ([v15 isSystemCommissionerFeatureEnabled])
    {
      v16 = [*(a1 + 32) browser];
      v17 = [v16 isCurrentDevicePrimaryResident];

      if (v17)
      {
        v18 = 0;
LABEL_19:
        v19 = [*(a1 + 32) clientQueue];
        v23[0] = MEMORY[0x277D85DD0];
        v23[1] = 3221225472;
        v23[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_655;
        v23[3] = &unk_2786F0EA8;
        v20 = *(a1 + 40);
        v24 = v18;
        v25 = v20;
        v23[4] = *(a1 + 32);
        v21 = v18;
        dispatch_async(v19, v23);

        goto LABEL_6;
      }

      v15 = [*(a1 + 32) browser];
      v18 = [v15 systemCommissionerFabricRootPublicKey];
    }

    else
    {
      v18 = 0;
    }

    goto LABEL_19;
  }

  v8 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:11];
  v9 = *(*(*(a1 + 56) + 8) + 40);
  v22 = v8;
  [v7 _handlePairingFailureWithError:? context:?];
  v10 = *MEMORY[0x277D85DE8];
}

uint64_t __40__HMMTRAccessoryServer__finalizePairing__block_invoke_654(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  [*(a1 + 32) setPairingProgress:4];
  [*(a1 + 32) _finishMaximumDurationCollection];
  [*(a1 + 32) _persistAccessoryServerData];
  v2 = [*(a1 + 32) stageCompletion];

  if (v2)
  {
    v3 = [*(a1 + 32) stageCompletion];
    v3[2](v3, 1, *(a1 + 32), 0);
  }

  v4 = *(a1 + 32);

  return [v4 _clearCommissioneeInfoAfterPairingCompletion];
}

uint64_t __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_655(uint64_t a1)
{
  (*(*(a1 + 48) + 16))();
  if ([*(a1 + 32) isKnownToSystemCommissioner])
  {
    v2 = *(a1 + 32);

    return [v2 _reportPairingComplete];
  }

  else
  {
    v4 = *(a1 + 32);
    if (*(a1 + 40))
    {

      return [v4 _pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:?];
    }

    else
    {

      return [v4 _pairOnSystemCommissionerFabric];
    }
  }
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_643(uint64_t a1, void *a2, void *a3, void *a4)
{
  v34 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v7 && !v8 && [v7 count])
  {
    v29 = v9;
    v10 = [v7 firstObject];
    v11 = [HMMTRPairing alloc];
    v12 = [v10 nodeID];
    v13 = [v10 fabricID];
    v14 = [v10 fabricLabel];
    v15 = [v10 rootPublicKey];
    v16 = [v10 vendorID];
    v17 = [v10 vendorName];
    v18 = [(HMMTRPairing *)v11 initWithNodeID:v12 fabricID:v13 fabricLabel:v14 rootPublicKey:v15 vendorID:v16 vendorName:v17];
    [*(a1 + 32) setCurrentPairingInfo:v18];

    v19 = objc_autoreleasePoolPush();
    v20 = *(a1 + 32);
    v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v22 = HMFGetLogIdentifier();
      v23 = [*(a1 + 32) currentPairingInfo];
      *buf = 138543618;
      v31 = v22;
      v32 = 2112;
      v33 = v23;
      _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@Obtained current pairing info %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v19);
    dispatch_group_leave(*(a1 + 40));

    v9 = v29;
    v8 = 0;
  }

  else
  {
    v24 = objc_autoreleasePoolPush();
    v25 = *(a1 + 32);
    v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v27 = HMFGetLogIdentifier();
      *buf = 138543618;
      v31 = v27;
      v32 = 2112;
      v33 = v8;
      _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch current pairing information %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v24);
    dispatch_group_leave(*(a1 + 40));
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_644(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543618;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to build HAP categories of CHIP accessory with error %@", &v9, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
    [*(a1 + 32) _setCategoryForPrimaryAccessory:&unk_283EE89E8];
  }

  dispatch_group_leave(*(a1 + 40));

  v8 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_645(uint64_t a1, void *a2)
{
  v34 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = *(*(a1 + 48) + 8);
  if (*(v4 + 24))
  {
    goto LABEL_15;
  }

  *(v4 + 24) = 1;
  v5 = [*(a1 + 32) browser];
  if ([v5 isCurrentDevicePrimaryResident])
  {
  }

  else
  {
    v6 = [*(a1 + 32) browser];
    v7 = [v6 isCurrentDeviceAllowedAccessoryControlDespiteReachableResident];

    if (!v7)
    {
      goto LABEL_6;
    }
  }

  dispatch_group_enter(*(a1 + 40));
  v8 = *(a1 + 32);
  v28[0] = MEMORY[0x277D85DD0];
  v28[1] = 3221225472;
  v28[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_646;
  v28[3] = &unk_2786EFD08;
  v28[4] = v8;
  v29 = *(a1 + 40);
  [v8 fetchSoftwareVersion:1 completionHandler:v28];

LABEL_6:
  dispatch_group_enter(*(a1 + 40));
  v9 = *(a1 + 32);
  v26[0] = MEMORY[0x277D85DD0];
  v26[1] = 3221225472;
  v26[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_647;
  v26[3] = &unk_2786EFD08;
  v26[4] = v9;
  v27 = *(a1 + 40);
  [v9 fetchSoftwareVersion:0 completionHandler:v26];

  if (v3)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543618;
      v31 = v13;
      v32 = 2112;
      v33 = v3;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to rebuild HAP services of CHIP Accessory with error %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    *(*(*(a1 + 56) + 8) + 24) = 1;
    v14 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:12 error:v3];
    v15 = *(*(a1 + 64) + 8);
    v16 = *(v15 + 40);
    *(v15 + 40) = v14;

    dispatch_group_leave(*(a1 + 40));
  }

  else
  {
    dispatch_group_enter(*(a1 + 40));
    v17 = *(a1 + 32);
    v20 = MEMORY[0x277D85DD0];
    v21 = 3221225472;
    v22 = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_651;
    v23 = &unk_2786EFD30;
    v24 = v17;
    v25 = *(a1 + 40);
    [v17 generateAccessoryConfigurationForReason:@"DevicePaired" completionHandler:&v20];

    if ([*(a1 + 32) pairedState] == 2)
    {
      [*(a1 + 32) setPairedState:3];
    }

    v18 = [*(a1 + 32) _fetchSupportedThreadFeatures];
    if (v18)
    {
      [*(a1 + 32) _notifyDelegateOfMatterAccessoryThreadCapabilities:v18];
    }

    dispatch_group_leave(*(a1 + 40));
  }

LABEL_15:

  v19 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_652(uint64_t a1)
{
  v11 = *MEMORY[0x277D85DE8];
  if ((*(*(*(a1 + 48) + 8) + 24) & 1) == 0)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v9 = 138543362;
      v10 = v5;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Enumerating HAPServices timed out", &v9, 0xCu);
    }

    objc_autoreleasePoolPop(v2);
  }

  v6 = *(a1 + 40);
  v7 = [MEMORY[0x277CCA9B8] hapErrorWithCode:24];
  (*(v6 + 16))(v6, v7);

  v8 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_646(uint64_t a1, void *a2, void *a3)
{
  v19 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v15 = 138543618;
      v16 = v10;
      v17 = 2112;
      v18 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version number of CHIP Accessory with error %@", &v15, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  else if ([*(a1 + 32) pairingProgress] && objc_msgSend(*(a1 + 32), "pairingProgress") != 3)
  {
    v12 = v5;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v13 = v12;
    }

    else
    {
      v13 = 0;
    }

    v14 = v13;

    if (v14)
    {
      [*(a1 + 32) updateSoftwareVersion:v14];
    }
  }

  dispatch_group_leave(*(a1 + 40));

  v11 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_647(uint64_t a1, void *a2, void *a3)
{
  v18 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v14 = 138543618;
      v15 = v10;
      v16 = 2112;
      v17 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version string of CHIP Accessory with error %@", &v14, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v11 = v5;
    }

    else
    {
      v11 = 0;
    }

    v12 = v11;
    [*(a1 + 32) setSoftwareVersionString:v12];
  }

  dispatch_group_leave(*(a1 + 40));

  v13 = *MEMORY[0x277D85DE8];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_651(uint64_t a1, void *a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      v12 = *(a1 + 32);
      v17 = 138543874;
      v18 = v11;
      v19 = 2112;
      v20 = v12;
      v21 = 2112;
      v22 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Accessory Configuration: completed for server:%@ with Error: %@.", &v17, 0x20u);
LABEL_6:
    }
  }

  else if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    v13 = [*(a1 + 32) nodeID];
    v14 = [*(a1 + 32) fabricID];
    v15 = [*(a1 + 32) objectID];
    v17 = 138544386;
    v18 = v11;
    v19 = 2112;
    v20 = v13;
    v21 = 2112;
    v22 = v14;
    v23 = 2112;
    v24 = v15;
    v25 = 2112;
    v26 = v5;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration for %@/%@(%@) %@", &v17, 0x34u);

    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v7);
  dispatch_group_leave(*(a1 + 40));

  v16 = *MEMORY[0x277D85DE8];
}

- (id)populateACLEntriesForPairing
{
  v110 = *MEMORY[0x277D85DE8];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    v3 = objc_autoreleasePoolPush();
    selfCopy = self;
    v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = HMFGetLogIdentifier();
      *buf = 138543362;
      v105 = v6;
      _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_DEBUG, "%{public}@Not populating ACL entries for System Commissioner pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v3);
    dictionary = [MEMORY[0x277CBEAC0] dictionary];
  }

  else
  {
    array = [MEMORY[0x277CBEB18] array];
    array2 = [MEMORY[0x277CBEB18] array];
    if (isFeatureMatterLocalFabricConfigEnabled())
    {
      v100 = array2;
      v10 = MEMORY[0x277CD5230];
      controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
      startupParams = [controllerWrapper startupParams];
      operationalCertificate = [startupParams operationalCertificate];
      controllerNodeID3 = [v10 convertX509Certificate:operationalCertificate];

      v101 = [objc_alloc(MEMORY[0x277CD5228]) initWithTLVBytes:controllerNodeID3];
      browser = [(HMMTRAccessoryServer *)self browser];
      fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
      residentNodeID2 = [browser appleHomeFabricWithTargetFabricUUID:fabricUUID];

      delegate = [residentNodeID2 delegate];
      v19 = [delegate accessoryAdministerPrivilegeCATID:0];

      v99 = v19;
      if (v19)
      {
        integerValue = [v19 integerValue];
        0xFFFFFFFD00000000 = [MEMORY[0x277CCABB0] numberWithUnsignedLongLong:integerValue | 0xFFFFFFFD00000000];
        [array addObject:0xFFFFFFFD00000000];

        v22 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v24 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          v25 = HMFGetLogIdentifier();
          *buf = 138543874;
          v105 = v25;
          v106 = 2112;
          v107 = v99;
          v108 = 2048;
          integerValue2 = [v99 integerValue];
          _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX)", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v22);
      }

      delegate2 = [residentNodeID2 delegate];
      v27 = [delegate2 accessoryOperatePrivilegeCATID:0];

      if (v27)
      {
        integerValue3 = [v27 integerValue];
        0xFFFFFFFD000000002 = [MEMORY[0x277CCABB0] numberWithUnsignedLongLong:integerValue3 | 0xFFFFFFFD00000000];
        [v100 addObject:0xFFFFFFFD000000002];

        v30 = objc_autoreleasePoolPush();
        selfCopy3 = self;
        v32 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          v33 = HMFGetLogIdentifier();
          integerValue4 = [v27 integerValue];
          *buf = 138543874;
          v105 = v33;
          v106 = 2112;
          v107 = v27;
          v108 = 2048;
          integerValue2 = integerValue4;
          _os_log_impl(&dword_22AEAE000, v32, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX)", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v30);
      }

      delegate3 = [residentNodeID2 delegate];
      isCurrentUserOwner = [delegate3 isCurrentUserOwner];

      if (isCurrentUserOwner && v101)
      {
        subject = [v101 subject];
        caseAuthenticatedTags = [subject caseAuthenticatedTags];
        allObjects = [caseAuthenticatedTags allObjects];
        v103[0] = MEMORY[0x277D85DD0];
        v103[1] = 3221225472;
        v103[2] = __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke;
        v103[3] = &unk_2786EFCB8;
        v103[4] = self;
        v40 = [allObjects na_map:v103];
        [array addObjectsFromArray:v40];
      }

      pairingRequest = [(HAPAccessoryServer *)self pairingRequest];
      isOwnerPairing = [pairingRequest isOwnerPairing];

      if ((isOwnerPairing & 1) == 0)
      {
        if (v101)
        {
          subject2 = [v101 subject];
          caseAuthenticatedTags2 = [subject2 caseAuthenticatedTags];
          allObjects2 = [caseAuthenticatedTags2 allObjects];
          v102[0] = MEMORY[0x277D85DD0];
          v102[1] = 3221225472;
          v102[2] = __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke_640;
          v102[3] = &unk_2786EFCB8;
          v102[4] = self;
          v46 = [allObjects2 na_map:v102];
          [v100 addObjectsFromArray:v46];
        }

        deviceController = [(HMMTRAccessoryServer *)self deviceController];
        controllerNodeID = [deviceController controllerNodeID];

        if (controllerNodeID)
        {
          v49 = objc_autoreleasePoolPush();
          selfCopy4 = self;
          v51 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
          {
            v52 = HMFGetLogIdentifier();
            integerValue5 = [controllerNodeID integerValue];
            *buf = 138543874;
            v105 = v52;
            v106 = 2112;
            v107 = controllerNodeID;
            v108 = 2048;
            integerValue2 = integerValue5;
            _os_log_impl(&dword_22AEAE000, v51, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX)", buf, 0x20u);
          }

          objc_autoreleasePoolPop(v49);
          [array addObject:controllerNodeID];
        }
      }

      fabricUUID2 = [(HMMTRAccessoryServer *)self fabricUUID];

      if (fabricUUID2)
      {
        browser2 = [(HMMTRAccessoryServer *)self browser];
        fabricUUID3 = [(HMMTRAccessoryServer *)self fabricUUID];
        v57 = [browser2 fabricDataForPairingTargetFabricUUID:fabricUUID3];

        residentNodeID = [v57 residentNodeID];

        if (residentNodeID)
        {
          v59 = objc_autoreleasePoolPush();
          selfCopy5 = self;
          v61 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
          {
            v62 = HMFGetLogIdentifier();
            integerValue6 = [residentNodeID integerValue];
            *buf = 138543874;
            v105 = v62;
            v106 = 2112;
            v107 = residentNodeID;
            v108 = 2048;
            integerValue2 = integerValue6;
            _os_log_impl(&dword_22AEAE000, v61, OS_LOG_TYPE_INFO, "%{public}@ACL: adding resident's NodeID %@ (0x%lX)", buf, 0x20u);
          }

          objc_autoreleasePoolPop(v59);
          [array addObject:residentNodeID];
        }
      }

      else
      {
        residentNodeID = 0;
      }

      controllerWrapper2 = [(HMMTRAccessoryServer *)self controllerWrapper];
      startupParams2 = [controllerWrapper2 startupParams];
      operationalCertificate2 = [startupParams2 operationalCertificate];
      v75 = [HMMTRAccessoryServer certificateSubjectHasCATs:operationalCertificate2];

      if (!v75)
      {
        deviceController2 = [(HMMTRAccessoryServer *)self deviceController];
        controllerNodeID2 = [deviceController2 controllerNodeID];

        if (controllerNodeID2 && ([controllerNodeID2 isEqual:residentNodeID] & 1) == 0)
        {
          v78 = objc_autoreleasePoolPush();
          selfCopy6 = self;
          v80 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
          {
            v81 = HMFGetLogIdentifier();
            integerValue7 = [controllerNodeID2 integerValue];
            *buf = 138543874;
            v105 = v81;
            v106 = 2112;
            v107 = controllerNodeID2;
            v108 = 2048;
            integerValue2 = integerValue7;
            _os_log_impl(&dword_22AEAE000, v80, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX) because it couldn't find any CAT in NOC", buf, 0x20u);
          }

          objc_autoreleasePoolPop(v78);
          [array addObject:controllerNodeID2];
        }
      }

      array2 = v100;
    }

    else
    {
      fabricUUID4 = [(HMMTRAccessoryServer *)self fabricUUID];

      if (fabricUUID4)
      {
        browser3 = [(HMMTRAccessoryServer *)self browser];
        fabricUUID5 = [(HMMTRAccessoryServer *)self fabricUUID];
        v67 = [browser3 fabricDataForPairingTargetFabricUUID:fabricUUID5];

        residentNodeID2 = [v67 residentNodeID];

        if (residentNodeID2)
        {
          v68 = objc_autoreleasePoolPush();
          selfCopy7 = self;
          v70 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
          {
            v71 = HMFGetLogIdentifier();
            *buf = 138543874;
            v105 = v71;
            v106 = 2112;
            v107 = residentNodeID2;
            v108 = 2048;
            integerValue2 = [residentNodeID2 integerValue];
            _os_log_impl(&dword_22AEAE000, v70, OS_LOG_TYPE_INFO, "%{public}@ACL: adding resident's NodeID %@ (0x%lX)", buf, 0x20u);
          }

          objc_autoreleasePoolPop(v68);
          [array addObject:residentNodeID2];
        }
      }

      else
      {
        residentNodeID2 = 0;
      }

      deviceController3 = [(HMMTRAccessoryServer *)self deviceController];
      controllerNodeID3 = [deviceController3 controllerNodeID];

      if (controllerNodeID3 && ([controllerNodeID3 isEqual:residentNodeID2] & 1) == 0)
      {
        v84 = objc_autoreleasePoolPush();
        selfCopy8 = self;
        v86 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
        {
          v87 = HMFGetLogIdentifier();
          integerValue8 = [controllerNodeID3 integerValue];
          *buf = 138543874;
          v105 = v87;
          v106 = 2112;
          v107 = controllerNodeID3;
          v108 = 2048;
          integerValue2 = integerValue8;
          _os_log_impl(&dword_22AEAE000, v86, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX)", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v84);
        [array addObject:controllerNodeID3];
      }
    }

    dictionary = [MEMORY[0x277CBEB38] dictionary];
    v89 = MEMORY[0x277CBEB98];
    v90 = [array copy];
    v91 = [v89 setWithArray:v90];
    allObjects3 = [v91 allObjects];
    [dictionary setObject:allObjects3 forKeyedSubscript:@"adminNodesForPairing"];

    v93 = MEMORY[0x277CBEB98];
    v94 = [array2 copy];
    v95 = [v93 setWithArray:v94];
    allObjects4 = [v95 allObjects];
    [dictionary setObject:allObjects4 forKeyedSubscript:@"regularNodesForPairing"];
  }

  v97 = *MEMORY[0x277D85DE8];

  return dictionary;
}

id __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v11 = 138543874;
    v12 = v7;
    v13 = 2112;
    v14 = v3;
    v15 = 2048;
    v16 = [v3 integerValue];
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX) from NOC", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = [MEMORY[0x277CCABB0] numberWithUnsignedLong:{objc_msgSend(v3, "integerValue") | 0xFFFFFFFD00000000}];

  v9 = *MEMORY[0x277D85DE8];

  return v8;
}

id __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke_640(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v11 = 138543874;
    v12 = v7;
    v13 = 2112;
    v14 = v3;
    v15 = 2048;
    v16 = [v3 integerValue];
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX) from NOC", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = [MEMORY[0x277CCABB0] numberWithUnsignedLong:{objc_msgSend(v3, "integerValue") | 0xFFFFFFFD00000000}];

  v9 = *MEMORY[0x277D85DE8];

  return v8;
}

- (id)populateACLEntriesAfterPairing
{
  v82 = *MEMORY[0x277D85DE8];
  array = [MEMORY[0x277CBEB18] array];
  array2 = [MEMORY[0x277CBEB18] array];
  if (!isFeatureMatterLocalFabricConfigEnabled())
  {
    deviceController = [(HMMTRAccessoryServer *)self deviceController];
    controllerNodeID = [deviceController controllerNodeID];
    [array addObject:controllerNodeID];

LABEL_19:
    v19 = 0;
    v10 = 0;
    goto LABEL_30;
  }

  browser = [(HMMTRAccessoryServer *)self browser];
  fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
  v7 = [browser appleHomeFabricWithTargetFabricUUID:fabricUUID];

  delegate = [v7 delegate];
  LODWORD(fabricUUID) = [delegate isCurrentUserOwner];

  if (!fabricUUID)
  {
    v40 = objc_autoreleasePoolPush();
    selfCopy = self;
    v42 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      v43 = HMFGetLogIdentifier();
      fabricID = [(HMMTRAccessoryServer *)selfCopy fabricID];
      *buf = 138543618;
      v73 = v43;
      v74 = 2112;
      v75 = fabricID;
      _os_log_impl(&dword_22AEAE000, v42, OS_LOG_TYPE_DEBUG, "%{public}@Not owner for home with fabric %@ - Not updating ACLs and blocking invalidation", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v40);
    [(HMMTRAccessoryServer *)selfCopy setBlockInvalidation:1];

    goto LABEL_19;
  }

  delegate2 = [v7 delegate];
  v10 = [delegate2 accessoryAdministerPrivilegeCATID:0];

  if (v10)
  {
    integerValue = [v10 integerValue];
    0xFFFFFFFD00000000 = [MEMORY[0x277CCABB0] numberWithUnsignedLongLong:integerValue | 0xFFFFFFFD00000000];
    [array addObject:0xFFFFFFFD00000000];

    v13 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      v17 = v16 = v7;
      *buf = 138543874;
      v73 = v17;
      v74 = 2112;
      v75 = v10;
      v76 = 2048;
      integerValue2 = [v10 integerValue];
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX)", buf, 0x20u);

      v7 = v16;
    }

    objc_autoreleasePoolPop(v13);
  }

  delegate3 = [v7 delegate];
  v19 = [delegate3 accessoryOperatePrivilegeCATID:0];

  v71 = array2;
  if (v19)
  {
    v20 = v7;
    integerValue3 = [v19 integerValue];
    0xFFFFFFFD000000002 = [MEMORY[0x277CCABB0] numberWithUnsignedLongLong:integerValue3 | 0xFFFFFFFD00000000];
    [array2 addObject:0xFFFFFFFD000000002];

    v23 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v25 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      v26 = HMFGetLogIdentifier();
      integerValue4 = [v19 integerValue];
      *buf = 138543874;
      v73 = v26;
      v74 = 2112;
      v75 = v19;
      v76 = 2048;
      integerValue2 = integerValue4;
      _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX)", buf, 0x20u);

      array2 = v71;
    }

    objc_autoreleasePoolPop(v23);
    v7 = v20;
  }

  v70 = v7;
  targetFabricUUID = [v7 targetFabricUUID];
  if (targetFabricUUID)
  {
    browser2 = [(HMMTRAccessoryServer *)self browser];
    v30 = [browser2 fabricDataForPairingTargetFabricUUID:targetFabricUUID];

    residentNodeID = [v30 residentNodeID];

    if (residentNodeID)
    {
      v32 = objc_autoreleasePoolPush();
      selfCopy4 = self;
      v34 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
      {
        v35 = HMFGetLogIdentifier();
        integerValue5 = [residentNodeID integerValue];
        *buf = 138543874;
        v73 = v35;
        v74 = 2112;
        v75 = residentNodeID;
        v76 = 2048;
        integerValue2 = integerValue5;
        v37 = "%{public}@ACL: adding resident's NodeID %@ (0x%lX)";
LABEL_24:
        _os_log_impl(&dword_22AEAE000, v34, OS_LOG_TYPE_INFO, v37, buf, 0x20u);

        goto LABEL_25;
      }

      goto LABEL_25;
    }
  }

  productInfo = [MEMORY[0x277D0F8E8] productInfo];
  productPlatform = [productInfo productPlatform];

  if (productPlatform == 4)
  {
    deviceController2 = [(HMMTRAccessoryServer *)self deviceController];
    residentNodeID = [deviceController2 controllerNodeID];

    if (!residentNodeID)
    {
LABEL_26:

      goto LABEL_27;
    }

    v32 = objc_autoreleasePoolPush();
    selfCopy5 = self;
    v34 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      v35 = HMFGetLogIdentifier();
      integerValue6 = [residentNodeID integerValue];
      *buf = 138543874;
      v73 = v35;
      v74 = 2112;
      v75 = residentNodeID;
      v76 = 2048;
      integerValue2 = integerValue6;
      v37 = "%{public}@ACL: adding current device's NodeID %@ (0x%lX)";
      goto LABEL_24;
    }

LABEL_25:

    objc_autoreleasePoolPop(v32);
    [array addObject:residentNodeID];
    array2 = v71;
    goto LABEL_26;
  }

LABEL_27:
  v50 = objc_autoreleasePoolPush();
  selfCopy6 = self;
  v52 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
  {
    v53 = HMFGetLogIdentifier();
    browser3 = [(HMMTRAccessoryServer *)selfCopy6 browser];
    [browser3 currentFabricUUID];
    v55 = v69 = v50;
    [(HMMTRAccessoryServer *)selfCopy6 fabricID];
    v57 = v56 = targetFabricUUID;
    *buf = 138544386;
    v73 = v53;
    v74 = 2112;
    v75 = v10;
    v76 = 2112;
    integerValue2 = v19;
    v78 = 2112;
    v79 = v55;
    v80 = 2112;
    v81 = v57;
    _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_DEBUG, "%{public}@Updating CATs (admin %@, user %@) for FabricID (browser's fabric %@, server's %@", buf, 0x34u);

    targetFabricUUID = v56;
    v50 = v69;

    array2 = v71;
  }

  objc_autoreleasePoolPop(v50);
LABEL_30:
  dictionary = [MEMORY[0x277CBEB38] dictionary];
  v59 = MEMORY[0x277CBEB98];
  v60 = [array copy];
  v61 = [v59 setWithArray:v60];
  allObjects = [v61 allObjects];
  [dictionary setObject:allObjects forKeyedSubscript:@"adminNodesForPairing"];

  v63 = MEMORY[0x277CBEB98];
  v64 = [array2 copy];
  v65 = [v63 setWithArray:v64];
  allObjects2 = [v65 allObjects];
  [dictionary setObject:allObjects2 forKeyedSubscript:@"regularNodesForPairing"];

  v67 = *MEMORY[0x277D85DE8];

  return dictionary;
}

- (void)_pairingComplete:(id)complete context:(id)context
{
  v77 = *MEMORY[0x277D85DE8];
  completeCopy = complete;
  contextCopy = context;
  if ([(HMMTRAccessoryServer *)self pairingProgress]== 3 || [(HMMTRAccessoryServer *)self pairingProgress]== 4)
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543618;
      *&buf[4] = v11;
      *&buf[12] = 2112;
      *&buf[14] = completeCopy;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Pairing has already finished, ignoring pairing completion indication with error: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v8);
  }

  else
  {
    v53 = contextCopy;
    linkLayerType = self->_linkLayerType;
    primaryAccessory = [(HMMTRAccessoryServer *)self primaryAccessory];
    [primaryAccessory setLinkLayerType:linkLayerType];

    v15 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      v19 = HAPLinkLayerTypeDescription();
      *buf = 138544386;
      *&buf[4] = v18;
      *&buf[12] = 2114;
      *&buf[14] = @"accessoryTransport";
      *&buf[22] = 2112;
      *&buf[24] = @"accessory transport";
      v73 = 2114;
      v74 = @"transport";
      v75 = 2112;
      v76 = v19;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
    }

    objc_autoreleasePoolPop(v15);
    mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
    v21 = objc_alloc(MEMORY[0x277D17DF8]);
    v22 = HAPLinkLayerTypeDescription();
    if (v22)
    {
      v70 = @"transport";
      linkLayerType = HAPLinkLayerTypeDescription();
      v71 = linkLayerType;
      v23 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v71 forKeys:&v70 count:1];
    }

    else
    {
      v23 = MEMORY[0x277CBEC10];
    }

    v24 = [v21 initWithTag:@"accessoryTransport" data:v23];
    tagProcessorList = [(HMFActivity *)selfCopy2->_activity tagProcessorList];
    [mEMORY[0x277D17DE8] submitTaggedEvent:v24 processorList:tagProcessorList];

    if (v22)
    {
    }

    v26 = objc_autoreleasePoolPush();
    v27 = selfCopy2;
    v28 = HMFGetOSLogHandle();
    v29 = v28;
    if (completeCopy)
    {
      contextCopy = v53;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v30 = HMFGetLogIdentifier();
        *buf = 138543874;
        *&buf[4] = v30;
        *&buf[12] = 2112;
        *&buf[14] = completeCopy;
        *&buf[22] = 2112;
        *&buf[24] = v53;
        _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed: %@, %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v26);
      [(HMMTRAccessoryServer *)v27 _handlePairingFailureWithError:completeCopy context:v53];
    }

    else
    {
      contextCopy = v53;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        v31 = HMFGetLogIdentifier();
        *buf = 138543362;
        *&buf[4] = v31;
        _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory pairing succeeded", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v26);
      [(HMMTRAccessoryServer *)v27 _notifyDelegateOfPairingStep:8];
      memset(buf, 0, sizeof(buf));
      v68 = 0u;
      v69 = 0u;
      cced25519_make_key_pair_compat();
      v55 = [objc_alloc(MEMORY[0x277CBEA90]) initWithBytes:buf length:32];
      if ([(HMMTRAccessoryServer *)v27 pairedState]!= 1)
      {
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        obj = [(HAPAccessoryServer *)v27 accessories];
        v32 = [obj countByEnumeratingWithState:&v57 objects:v67 count:16];
        if (v32)
        {
          v33 = v32;
          v34 = *v58;
          while (2)
          {
            for (i = 0; i != v33; ++i)
            {
              if (*v58 != v34)
              {
                objc_enumerationMutation(obj);
              }

              v36 = *(*(&v57 + 1) + 8 * i);
              keyStore = [(HAPAccessoryServer *)v27 keyStore];
              identifier = [v36 identifier];
              v56 = 0;
              v39 = [keyStore savePublicKey:v55 forAccessoryName:identifier error:&v56];
              v40 = v56;

              if ((v39 & 1) == 0)
              {
                v42 = objc_autoreleasePoolPush();
                v43 = v27;
                v44 = HMFGetOSLogHandle();
                if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                {
                  v45 = HMFGetLogIdentifier();
                  *v61 = 138543874;
                  v62 = v45;
                  v63 = 2112;
                  v64 = v36;
                  v65 = 2112;
                  v66 = v40;
                  _os_log_impl(&dword_22AEAE000, v44, OS_LOG_TYPE_ERROR, "%{public}@Failed to save public key for paired accessory %@: %@", v61, 0x20u);
                }

                objc_autoreleasePoolPop(v42);
                v46 = [HMMTRAccessoryPairingEndContext hapContextWithStep:8 error:v40];
                [(HMMTRAccessoryServer *)v43 _handlePairingFailureWithError:v40 context:v46];

                contextCopy = v53;
                goto LABEL_43;
              }
            }

            v33 = [obj countByEnumeratingWithState:&v57 objects:v67 count:16];
            if (v33)
            {
              continue;
            }

            break;
          }
        }

        contextCopy = v53;
      }

      if ([(HMMTRAccessoryServer *)v27 pairedState]== 1)
      {
        [(HMMTRAccessoryServer *)v27 setPairedState:2];
        [(HMMTRAccessoryServer *)v27 setPairingProgress:4];
        if ([(HMMTRAccessoryServer *)v27 knownToSystemCommissioner])
        {
          [(HMMTRAccessoryServer *)v27 _notifyDelegateOfPairingProgress:13];
          browser = [(HMMTRAccessoryServer *)v27 browser];
          [browser commitStagedAccessoryServer:v27];
        }

        else
        {
          stageCompletion = [(HMMTRAccessoryServer *)v27 stageCompletion];

          if (stageCompletion)
          {
            stageCompletion2 = [(HMMTRAccessoryServer *)v27 stageCompletion];
            (stageCompletion2)[2](stageCompletion2, 1, v27, 0);

            [(HMMTRAccessoryServer *)v27 setStageCompletion:0];
          }

          else
          {
            v49 = objc_autoreleasePoolPush();
            v50 = v27;
            v51 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              v52 = HMFGetLogIdentifier();
              *v61 = 138543362;
              v62 = v52;
              _os_log_impl(&dword_22AEAE000, v51, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory is paired and staged but has no stage completion handler set!", v61, 0xCu);
            }

            objc_autoreleasePoolPop(v49);
          }

          [(HMMTRAccessoryServer *)v27 _clearCommissioneeInfoAfterPairingCompletion];
        }
      }

      else
      {
        [(HMMTRAccessoryServer *)v27 _finalizePairing];
      }

LABEL_43:
    }
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (id)_setupPayloadForLastCommissioning
{
  if ([(HMMTRAccessoryServer *)self pairingUsingMatterSupport])
  {
    [(HMMTRAccessoryServer *)self setupPayloadForPairingUsingMatterSupport];
  }

  else
  {
    [(HMMTRAccessoryServer *)self _pairingSetupPayload];
  }
  v3 = ;

  return v3;
}

- (id)_pairingSetupPayload
{
  v43 = *MEMORY[0x277D85DE8];
  setupPayloadString = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (setupPayloadString && (v4 = setupPayloadString, -[HMMTRAccessoryServer setupPayloadString](self, "setupPayloadString"), v5 = objc_claimAutoreleasedReturnValue(), v6 = [v5 isEqual:&stru_283ED2308], v5, v4, (v6 & 1) == 0))
  {
    v18 = objc_autoreleasePoolPush();
    selfCopy = self;
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      v21 = HMFGetLogIdentifier();
      nodeID = selfCopy->_nodeID;
      setupPayloadString2 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
      *buf = 138543874;
      v34 = v21;
      v35 = 2112;
      v36 = nodeID;
      v37 = 2112;
      v38 = setupPayloadString2;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Pairing node ID: %@, onboarding payload: %@", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v18);
    v24 = MEMORY[0x277CD5528];
    setupPayloadString3 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
    v32 = 0;
    v16 = [v24 setupPayloadWithOnboardingPayload:setupPayloadString3 error:&v32];
    v17 = v32;

    if (!v16)
    {
      v26 = objc_autoreleasePoolPush();
      v27 = selfCopy;
      v28 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v29 = HMFGetLogIdentifier();
        *buf = 138543618;
        v34 = v29;
        v35 = 2112;
        v36 = v17;
        _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_ERROR, "%{public}@Failed to parse onboarding payload: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v26);
      v16 = 0;
    }
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      v11 = v10;
      v12 = selfCopy2->_nodeID;
      discriminator = selfCopy2->_discriminator;
      if (selfCopy2->_discriminatorIsOriginatedFromShort)
      {
        v14 = @"YES";
      }

      else
      {
        v14 = @"NO";
      }

      setUpPINCode = selfCopy2->_setUpPINCode;
      *buf = 138544386;
      v34 = v10;
      v35 = 2112;
      v36 = v12;
      v37 = 2112;
      v38 = discriminator;
      v39 = 2112;
      v40 = v14;
      v41 = 2112;
      v42 = setUpPINCode;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Pairing node ID: %@, discriminator: %@, short: %@, setupPINCode: %@", buf, 0x34u);
    }

    objc_autoreleasePoolPop(v7);
    v16 = [objc_alloc(MEMORY[0x277CD5528]) initWithSetupPasscode:selfCopy2->_setUpPINCode discriminator:selfCopy2->_discriminator];
    [v16 setHasShortDiscriminator:selfCopy2->_discriminatorIsOriginatedFromShort];
    v17 = 0;
  }

  v30 = *MEMORY[0x277D85DE8];

  return v16;
}

- (void)_clearCommissioneeInfoAfterPairingCompletion
{
  [(HMMTRAccessoryServer *)self setCommissioneeInfo:0];
  browser = [(HMMTRAccessoryServer *)self browser];
  [browser setCommissioneeAccessoryServer:0];

  controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
  startupParams = [controllerWrapper startupParams];
  operationalCertificateIssuer = [startupParams operationalCertificateIssuer];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v7 = operationalCertificateIssuer;
  }

  else
  {
    v7 = 0;
  }

  v8 = v7;

  [v8 setCommissioneeNodeID:0];
}

- (void)_persistAccessoryServerData
{
  v89 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)selfCopy knownToSystemCommissioner];
    v7 = HMFBooleanToString();
    v83 = 138543874;
    v84 = v6;
    v85 = 2112;
    v86 = selfCopy;
    v87 = 2112;
    v88 = v7;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Persisting HomeKitMatter Data for Accessory: %@, system commissioner mode: %@", &v83, 0x20u);
  }

  objc_autoreleasePoolPop(v3);
  pairingRequest = [(HAPAccessoryServer *)selfCopy pairingRequest];
  isOwnerPairing = [pairingRequest isOwnerPairing];

  if (!isFeatureMatterLocalFabricConfigEnabled())
  {
    goto LABEL_8;
  }

  fabricUUID = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
  if (!fabricUUID)
  {
    goto LABEL_8;
  }

  v11 = fabricUUID;
  browser = [(HMMTRAccessoryServer *)selfCopy browser];
  storage = [browser storage];
  dataSource = [storage dataSource];
  fabricUUID2 = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
  v16 = [dataSource appleHomeFabricWithTargetFabricUUID:fabricUUID2];

  if (v16)
  {
    v17 = isOwnerPairing ^ 1;
    delegate = [v16 delegate];
    requiresRemoteFabricDataUpdateThroughPairingCompletionMessage = [delegate requiresRemoteFabricDataUpdateThroughPairingCompletionMessage];

    if (((requiresRemoteFabricDataUpdateThroughPairingCompletionMessage | v17) & 1) == 0)
    {
      goto LABEL_10;
    }
  }

  else
  {
LABEL_8:
    if (isOwnerPairing)
    {
      goto LABEL_10;
    }
  }

  if (![(HMMTRAccessoryServer *)selfCopy knownToSystemCommissioner])
  {
    browser2 = [(HMMTRAccessoryServer *)selfCopy browser];
    [browser2 notifyPairingCompletionForAccessoryServer:selfCopy];
    goto LABEL_44;
  }

LABEL_10:
  knownToSystemCommissioner = [(HMMTRAccessoryServer *)selfCopy knownToSystemCommissioner];
  browser3 = [(HMMTRAccessoryServer *)selfCopy browser];
  v22 = browser3;
  if (knownToSystemCommissioner)
  {
    browser2 = [browser3 storageForSystemCommissioner];
  }

  else
  {
    fabricUUID3 = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
    pairingRequest2 = [(HAPAccessoryServer *)selfCopy pairingRequest];
    if (pairingRequest2)
    {
      pairingRequest3 = [(HAPAccessoryServer *)selfCopy pairingRequest];
      browser2 = [v22 storageForFabricUUID:fabricUUID3 sharedAdmin:{objc_msgSend(pairingRequest3, "isOwnerPairing") ^ 1}];
    }

    else
    {
      browser2 = [v22 storageForFabricUUID:fabricUUID3 sharedAdmin:0];
    }
  }

  [browser2 clearStaleItems];
  [browser2 startLocalStorageMode];
  nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 addPairedNodeID:nodeID];

  vendorID = [(HMMTRAccessoryServer *)selfCopy vendorID];
  nodeID2 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setVendorID:vendorID forNode:nodeID2];

  fabricID = [(HMMTRAccessoryServer *)selfCopy fabricID];
  nodeID3 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setFabricID:fabricID forNode:nodeID3];

  productID = [(HMMTRAccessoryServer *)selfCopy productID];
  nodeID4 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setProductID:productID forNode:nodeID4];

  category = [(HAPAccessoryServer *)selfCopy category];
  nodeID5 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setCategory:category forNode:nodeID5];

  v36 = [MEMORY[0x277CCABB0] numberWithUnsignedInteger:{-[HAPAccessoryServer configNumber](selfCopy, "configNumber")}];
  nodeID6 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setConfigNumber:v36 forNode:nodeID6];

  isStaged = [(HMMTRAccessoryServer *)selfCopy isStaged];
  nodeID7 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setStaged:isStaged forNode:nodeID7];

  topology = [(HMMTRAccessoryServer *)selfCopy topology];

  if (topology)
  {
    topology2 = [(HMMTRAccessoryServer *)selfCopy topology];
    nodeID8 = [(HMMTRAccessoryServer *)selfCopy nodeID];
    [browser2 setTopology:topology2 forNode:nodeID8];
  }

  else if (![(HMMTRAccessoryServer *)selfCopy isKnownToSystemCommissioner])
  {
    _HMFPreconditionFailure();
    goto LABEL_46;
  }

  if (![(HMMTRAccessoryServer *)selfCopy isKnownToSystemCommissioner])
  {
    goto LABEL_39;
  }

  ensureCommissioningID = [(HMMTRAccessoryServer *)selfCopy ensureCommissioningID];
  nodeID9 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setSystemCommissionerFabricNodeID:nodeID9 forUuid:ensureCommissioningID];

  nodeID10 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setUuid:ensureCommissioningID forSystemCommissionerFabricNode:nodeID10];

  primaryAccessory = [(HMMTRAccessoryServer *)selfCopy primaryAccessory];
  serialNumber = [primaryAccessory serialNumber];

  if (serialNumber)
  {
    primaryAccessory2 = [(HMMTRAccessoryServer *)selfCopy primaryAccessory];
    serialNumber2 = [primaryAccessory2 serialNumber];
    nodeID11 = [(HMMTRAccessoryServer *)selfCopy nodeID];
    [browser2 setSerialNumber:serialNumber2 forSystemCommissionerFabricNode:nodeID11];
  }

  name = [(HAPAccessoryServer *)selfCopy name];
  nodeID12 = [(HMMTRAccessoryServer *)selfCopy nodeID];
  [browser2 setDeviceName:name forSystemCommissionerFabricNode:nodeID12];

  setupPayloadString = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
  if (setupPayloadString)
  {
    v54 = setupPayloadString;
    setupPayloadString2 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
    v56 = [setupPayloadString2 isEqual:&stru_283ED2308];

    if ((v56 & 1) == 0)
    {
      setupPayloadString3 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
      goto LABEL_29;
    }
  }

  onboardingSetupPayloadString = [(HMMTRAccessoryServer *)selfCopy onboardingSetupPayloadString];
  if (onboardingSetupPayloadString)
  {
    v58 = onboardingSetupPayloadString;
    onboardingSetupPayloadString2 = [(HMMTRAccessoryServer *)selfCopy onboardingSetupPayloadString];
    v60 = [onboardingSetupPayloadString2 isEqual:&stru_283ED2308];

    if ((v60 & 1) == 0)
    {
      setupPayloadString3 = [(HMMTRAccessoryServer *)selfCopy onboardingSetupPayloadString];
LABEL_29:
      v62 = setupPayloadString3;
      nodeID13 = [(HMMTRAccessoryServer *)selfCopy nodeID];
      [browser2 setSetupPayload:v62 forSystemCommissionerFabricNode:nodeID13];
    }
  }

  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    isWEDDevice = [(HMMTRAccessoryServer *)selfCopy isWEDDevice];
    nodeID14 = [(HMMTRAccessoryServer *)selfCopy nodeID];
    [browser2 setWEDSupported:isWEDDevice forSystemCommissionerFabricNode:nodeID14];

    if ([(HMMTRAccessoryServer *)selfCopy isWEDDevice])
    {
      eMACAddress = [(HMMTRAccessoryServer *)selfCopy eMACAddress];
      nodeID15 = [(HMMTRAccessoryServer *)selfCopy nodeID];
      [browser2 setExtendedMACAddress:eMACAddress forSystemCommissionerFabricNode:nodeID15];
    }
  }

  if (!_os_feature_enabled_impl())
  {
    goto LABEL_38;
  }

  commissioneeInfo = [(HMMTRAccessoryServer *)selfCopy commissioneeInfo];

  if (!commissioneeInfo)
  {
LABEL_46:
    _HMFPreconditionFailure();
  }

  v69 = MEMORY[0x277CD55B0];
  commissioneeInfo2 = [(HMMTRAccessoryServer *)selfCopy commissioneeInfo];
  rootEndpoint = [commissioneeInfo2 rootEndpoint];
  v72 = [v69 threadCredentialManagementEndpoint:rootEndpoint];

  if (v72)
  {
    nodeID16 = [(HMMTRAccessoryServer *)selfCopy nodeID];
    [browser2 setThreadCredentialManagementEndpoint:v72 forSystemCommissionerFabricNode:nodeID16];
  }

LABEL_38:
LABEL_39:
  [browser2 endLocalStorageModeBySyncingToRemote:1];
  if ([(HMMTRAccessoryServer *)selfCopy isKnownToSystemCommissioner])
  {
    browser4 = [(HMMTRAccessoryServer *)selfCopy browser];
    commissioningID = [(HMMTRAccessoryServer *)selfCopy commissioningID];
    vendorID2 = [(HMMTRAccessoryServer *)selfCopy vendorID];
    productID2 = [(HMMTRAccessoryServer *)selfCopy productID];
    primaryAccessory3 = [(HMMTRAccessoryServer *)selfCopy primaryAccessory];
    serialNumber3 = [primaryAccessory3 serialNumber];
    setupPayloadString4 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
    if ([setupPayloadString4 isEqual:&stru_283ED2308])
    {
      [browser4 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:commissioningID vendorID:vendorID2 productID:productID2 serialNumber:serialNumber3 setupPayload:0];
    }

    else
    {
      setupPayloadString5 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
      [browser4 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:commissioningID vendorID:vendorID2 productID:productID2 serialNumber:serialNumber3 setupPayload:setupPayloadString5];
    }
  }

LABEL_44:

  [(HMMTRAccessoryServer *)selfCopy setStorageUpdatePending:0];
  v82 = *MEMORY[0x277D85DE8];
}

- (void)_deleteAccessoryServerData
{
  if (![(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
    v6 = [browser storageForFabricUUID:fabricUUID sharedAdmin:0];

    nodeID = [(HMMTRAccessoryServer *)self nodeID];
    [v6 removeRecordsForNode:nodeID systemCommissionerFabric:0];
  }
}

- (void)_notifyDelegateOfPairingProgress:(int64_t)progress error:(id)error
{
  errorCopy = error;
  delegateQueue = [(HAPAccessoryServer *)self delegateQueue];
  if (delegateQueue)
  {
    v8 = delegateQueue;
    v9 = [(HMMTRAccessoryServer *)self _delegateRespondsToSelector:sel_accessoryServer_updatePairingProgress_];

    if (v9)
    {
      delegateQueue2 = [(HAPAccessoryServer *)self delegateQueue];
      v15[0] = MEMORY[0x277D85DD0];
      v15[1] = 3221225472;
      v15[2] = __63__HMMTRAccessoryServer__notifyDelegateOfPairingProgress_error___block_invoke;
      v15[3] = &unk_2786EF620;
      v15[4] = self;
      v15[5] = progress;
      dispatch_async(delegateQueue2, v15);
    }
  }

  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    stageCompletion = [(HMMTRAccessoryServer *)self stageCompletion];
    if (stageCompletion)
    {
      v12 = stageCompletion;
      stageProgressUpdateHandler = [(HMMTRAccessoryServer *)self stageProgressUpdateHandler];

      if (stageProgressUpdateHandler)
      {
        stageProgressUpdateHandler2 = [(HMMTRAccessoryServer *)self stageProgressUpdateHandler];
        stageProgressUpdateHandler2[2](stageProgressUpdateHandler2, progress);
      }
    }
  }

  [(HMMTRAccessoryServer *)self _updateMetricWithProgressState:progress error:errorCopy];
}

void __63__HMMTRAccessoryServer__notifyDelegateOfPairingProgress_error___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) delegate];
  [v2 accessoryServer:*(a1 + 32) updatePairingProgress:*(a1 + 40)];
}

- (void)_updateMetricWithProgressState:(int64_t)state error:(id)error
{
  v64 = *MEMORY[0x277D85DE8];
  errorCopy = error;
  v7 = [(HMMTRAccessoryServer *)self _progressStateToString:state];
  [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventLastProgressState" value:v7];
  if (errorCopy)
  {
    [(HMMTRAccessoryServer *)self _metricCollectionWithError:errorCopy description:@"Error in progress state" progressState:state];
  }

  else
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    v11 = 0x277CCA000;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      v13 = [MEMORY[0x277CCABB0] numberWithInteger:state];
      *buf = 138544898;
      v51 = v12;
      v52 = 2114;
      stateCopy = @"hmmtrAccessoryServerStateChange";
      v54 = 2112;
      v55 = @"Matter Progress Pairing State";
      v56 = 2114;
      v57 = @"state";
      v58 = 2112;
      v59 = v13;
      v60 = 2114;
      v61 = @"stateName";
      v62 = 2112;
      v63 = v7;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@ %{public}@=%@", buf, 0x48u);

      v11 = 0x277CCA000uLL;
    }

    objc_autoreleasePoolPop(v8);
    mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
    v15 = objc_alloc(MEMORY[0x277D17DF8]);
    v16 = [*(v11 + 2992) numberWithInteger:state];
    v17 = HMDTaggedLoggingCreateDictionary();
    v18 = [v15 initWithTag:@"hmmtrAccessoryServerStateChange" data:{v17, @"state", v16, @"stateName", v7}];
    tagProcessorList = [(HMFActivity *)selfCopy->_activity tagProcessorList];
    [mEMORY[0x277D17DE8] submitTaggedEvent:v18 processorList:tagProcessorList];
  }

  switch(state)
  {
    case 17:
    case 20:
    case 21:
    case 27:
    case 30:
    case 33:
      break;
    case 18:
      v20 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameNetworkScan"];
      v21 = @"hmmtrAccessoryPairingEventNetworkScanDurationInSeconds";
      goto LABEL_22;
    case 19:
      v22 = @"hmmtrAccessoryMetricNameNetworkScan";
      goto LABEL_28;
    case 22:
      v20 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindow"];
      v21 = @"hmmtrAccessoryPairingEventWindowOpenedDurationInSeconds";
      goto LABEL_22;
    case 23:
      v22 = @"hmmtrAccessoryMetricNamePairingWindow";
      goto LABEL_28;
    case 25:
      v20 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindowWithPasscode"];
      v21 = @"hmmtrAccessoryPairingEventWindowOpenedWithPassCodeDurationInSeconds";
      goto LABEL_22;
    case 26:
      v22 = @"hmmtrAccessoryMetricNamePairingWindowWithPasscode";
      goto LABEL_28;
    case 28:
      v20 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameCommissioningAccessory"];
      v21 = @"hmmtrAccessoryPairingEventCommissioningDurationInSeconds";
      goto LABEL_22;
    case 29:
      v22 = @"hmmtrAccessoryMetricNameCommissioningAccessory";
      goto LABEL_28;
    case 31:
      v20 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameRetrieveThreadCredentials"];
      v21 = @"hmmtrAccessoryPairingEventThreadCredentialSetupDurationInSeconds";
LABEL_22:
      [(HMMTRAccessoryServer *)self addMetricsWithDuration:v20 metricsKey:v21];

      break;
    case 32:
      v22 = @"hmmtrAccessoryMetricNameRetrieveThreadCredentials";
LABEL_28:
      v44 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:v22];
      break;
    case 34:
      v37 = MEMORY[0x277CBEC38];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"HMMTRAccessoryPairingEventCASESessionSanityCheckPassed" value:MEMORY[0x277CBEC38]];
      v38 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v39 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        v40 = HMFGetLogIdentifier();
        *buf = 138544386;
        v51 = v40;
        v52 = 2114;
        stateCopy = @"hmmtrAccessoryServerCaseSessionSanityCheck";
        v54 = 2112;
        v55 = @"Case Sanity Check";
        v56 = 2114;
        v57 = @"success";
        v58 = 2112;
        v59 = v37;
        _os_log_impl(&dword_22AEAE000, v39, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
      }

      objc_autoreleasePoolPop(v38);
      mEMORY[0x277D17DE8]2 = [MEMORY[0x277D17DE8] sharedInstance];
      v33 = objc_alloc(MEMORY[0x277D17DF8]);
      v46 = @"success";
      v47 = v37;
      v34 = MEMORY[0x277CBEAC0];
      v35 = &v47;
      v36 = &v46;
      goto LABEL_26;
    case 35:
      v27 = MEMORY[0x277CBEC28];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"HMMTRAccessoryPairingEventCASESessionSanityCheckPassed" value:MEMORY[0x277CBEC28]];
      v28 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v30 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        v31 = HMFGetLogIdentifier();
        *buf = 138544386;
        v51 = v31;
        v52 = 2114;
        stateCopy = @"hmmtrAccessoryServerCaseSessionSanityCheck";
        v54 = 2112;
        v55 = @"Case Sanity Check";
        v56 = 2114;
        v57 = @"success";
        v58 = 2112;
        v59 = v27;
        _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
      }

      objc_autoreleasePoolPop(v28);
      mEMORY[0x277D17DE8]2 = [MEMORY[0x277D17DE8] sharedInstance];
      v33 = objc_alloc(MEMORY[0x277D17DF8]);
      v48 = @"success";
      v49 = v27;
      v34 = MEMORY[0x277CBEAC0];
      v35 = &v49;
      v36 = &v48;
LABEL_26:
      v41 = [v34 dictionaryWithObjects:v35 forKeys:v36 count:1];
      v42 = [v33 initWithTag:@"hmmtrAccessoryServerCaseSessionSanityCheck" data:v41];
      tagProcessorList2 = [(HMFActivity *)selfCopy3->_activity tagProcessorList];
      [mEMORY[0x277D17DE8]2 submitTaggedEvent:v42 processorList:tagProcessorList2];

      break;
    default:
      v23 = objc_autoreleasePoolPush();
      selfCopy4 = self;
      v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        v26 = HMFGetLogIdentifier();
        *buf = 138543618;
        v51 = v26;
        v52 = 2048;
        stateCopy = state;
        _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_INFO, "%{public}@Unhandled progress state %ld", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v23);
      break;
  }

  v45 = *MEMORY[0x277D85DE8];
}

- (id)_progressStateToString:(int64_t)string
{
  v4 = string - 13;
  if (string - 13) < 0x1A && ((0x3FFFE7Fu >> v4))
  {
    string = off_2786F0488[v4];
  }

  else
  {
    string = [MEMORY[0x277CCACA8] stringWithFormat:@"Unknown progressState %ld", string];
  }

  return string;
}

- (void)addMetricsWithDuration:(id)duration metricsKey:(id)key
{
  v30 = *MEMORY[0x277D85DE8];
  durationCopy = duration;
  keyCopy = key;
  if (durationCopy)
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138544386;
      v21 = v11;
      v22 = 2114;
      v23 = keyCopy;
      v24 = 2112;
      v25 = keyCopy;
      v26 = 2114;
      v27 = @"duration";
      v28 = 2112;
      v29 = durationCopy;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
    }

    objc_autoreleasePoolPop(v8);
    mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
    v13 = objc_alloc(MEMORY[0x277D17DF8]);
    v18 = @"duration";
    v19 = durationCopy;
    v14 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    v15 = [v13 initWithTag:keyCopy data:v14];
    tagProcessorList = [(HMFActivity *)selfCopy->_activity tagProcessorList];
    [mEMORY[0x277D17DE8] submitTaggedEvent:v15 processorList:tagProcessorList];

    [(HAPAccessoryServer *)selfCopy setPairingMetricWithKey:keyCopy value:durationCopy];
  }

  v17 = *MEMORY[0x277D85DE8];
}

- (BOOL)_delegateRespondsToSelector:(SEL)selector
{
  delegate = [(HAPAccessoryServer *)self delegate];
  if (delegate)
  {
    delegateQueue = [(HAPAccessoryServer *)self delegateQueue];
    if (delegateQueue)
    {
      delegate2 = [(HAPAccessoryServer *)self delegate];
      v7 = objc_opt_respondsToSelector();
    }

    else
    {
      v7 = 0;
    }
  }

  else
  {
    v7 = 0;
  }

  return v7 & 1;
}

- (void)handleUpdatesForCharacteristics:(id)characteristics stateNumber:(id)number
{
  v15 = *MEMORY[0x277D85DE8];
  characteristicsCopy = characteristics;
  numberCopy = number;
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    v13 = 138543362;
    v14 = v11;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@UNIMPLEMENTED: CHIP Accessory doesn't implement handleUpdatesForCharacteristics", &v13, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  v12 = *MEMORY[0x277D85DE8];
}

- (void)identifyWithCompletion:(id)completion
{
  completionCopy = completion;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __47__HMMTRAccessoryServer_identifyWithCompletion___block_invoke;
  block[3] = &unk_2786EF878;
  v8 = completionCopy;
  v6 = completionCopy;
  dispatch_async(clientQueue, block);
}

void __47__HMMTRAccessoryServer_identifyWithCompletion___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1)
  {
    v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:3 marker:242];
    (*(v1 + 16))(v1, v2);
  }
}

- (void)enableEvents:(BOOL)events forCharacteristics:(id)characteristics withCompletionHandler:(id)handler queue:(id)queue
{
  handlerCopy = handler;
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __84__HMMTRAccessoryServer_enableEvents_forCharacteristics_withCompletionHandler_queue___block_invoke;
  block[3] = &unk_2786EF878;
  v10 = handlerCopy;
  v8 = handlerCopy;
  dispatch_async(queue, block);
}

void __84__HMMTRAccessoryServer_enableEvents_forCharacteristics_withCompletionHandler_queue___block_invoke(uint64_t a1)
{
  v1 = MEMORY[0x2318887D0](*(a1 + 32));
  if (v1)
  {
    v2 = v1;
    v1[2](v1, 0, 0);
    v1 = v2;
  }
}

- (void)_populateServiceForCharacteristic:(id)characteristic
{
  v55 = *MEMORY[0x277D85DE8];
  characteristicCopy = characteristic;
  primaryAccessory = [(HMMTRAccessoryServer *)self primaryAccessory];
  type = [characteristicCopy type];
  v7 = [primaryAccessory characteristicsOfType:type];

  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  obj = v7;
  v8 = [obj countByEnumeratingWithState:&v44 objects:v54 count:16];
  if (v8)
  {
    v10 = v8;
    v11 = *v45;
    *&v9 = 138543874;
    v42 = v9;
    do
    {
      for (i = 0; i != v10; ++i)
      {
        if (*v45 != v11)
        {
          objc_enumerationMutation(obj);
        }

        v13 = *(*(&v44 + 1) + 8 * i);
        service = [characteristicCopy service];

        if (!service)
        {
          v15 = objc_autoreleasePoolPush();
          selfCopy = self;
          v17 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            v18 = HMFGetLogIdentifier();
            *buf = 138543618;
            v49 = v18;
            v50 = 2112;
            v51 = characteristicCopy;
            _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@read/write is missing service for Characteristic %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v15);
          v19 = objc_autoreleasePoolPush();
          v20 = selfCopy;
          v21 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            v22 = HMFGetLogIdentifier();
            *buf = 138543618;
            v49 = v22;
            v50 = 2112;
            v51 = v13;
            _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_ERROR, "%{public}@current primary characteristic %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v19);
        }

        service2 = [v13 service];

        if (!service2)
        {
          v24 = objc_autoreleasePoolPush();
          selfCopy2 = self;
          v26 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            v27 = HMFGetLogIdentifier();
            *buf = 138543618;
            v49 = v27;
            v50 = 2112;
            v51 = v13;
            _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@No primary service for primary Characteristic %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v24);
        }

        instanceID = [v13 instanceID];
        instanceID2 = [characteristicCopy instanceID];
        v30 = [instanceID isEqualToNumber:instanceID2];

        if (v30)
        {
          service3 = [characteristicCopy service];
          if (!service3)
          {
            goto LABEL_19;
          }

          v32 = service3;
          service4 = [v13 service];
          service5 = [characteristicCopy service];
          v35 = [service4 isEqualToService:service5];

          if ((v35 & 1) == 0)
          {
LABEL_19:
            v36 = objc_autoreleasePoolPush();
            selfCopy3 = self;
            v38 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              v39 = HMFGetLogIdentifier();
              *buf = v42;
              v49 = v39;
              v50 = 2112;
              v51 = characteristicCopy;
              v52 = 2112;
              v53 = v13;
              _os_log_impl(&dword_22AEAE000, v38, OS_LOG_TYPE_INFO, "%{public}@Updating service for Characteristic %@ using local characteristic %@", buf, 0x20u);
            }

            objc_autoreleasePoolPop(v36);
            service6 = [v13 service];
            [characteristicCopy setService:service6];
          }
        }
      }

      v10 = [obj countByEnumeratingWithState:&v44 objects:v54 count:16];
    }

    while (v10);
  }

  v41 = *MEMORY[0x277D85DE8];
}

- (id)_populateHandlingForCharacteristics:(id)characteristics
{
  v64 = *MEMORY[0x277D85DE8];
  characteristicsCopy = characteristics;
  v57 = [MEMORY[0x277CBEB18] arrayWithCapacity:{objc_msgSend(characteristicsCopy, "count")}];
  if ([characteristicsCopy count])
  {
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v49 = characteristicsCopy;
    obj = characteristicsCopy;
    v58 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
    if (!v58)
    {
      v55 = 0;
      v4 = 0;
      uniqueIdentifier2 = 0;
      goto LABEL_42;
    }

    v53 = 0;
    v4 = 0;
    uniqueIdentifier2 = 0;
    v55 = 0;
    v56 = *v60;
    while (1)
    {
      for (i = 0; i != v58; ++i)
      {
        v7 = uniqueIdentifier2;
        if (*v60 != v56)
        {
          objc_enumerationMutation(obj);
        }

        v8 = *(*(&v59 + 1) + 8 * i);
        if (uniqueIdentifier2)
        {
          characteristic = [*(*(&v59 + 1) + 8 * i) characteristic];
          service = [characteristic service];
          accessory = [service accessory];
          uniqueIdentifier = [accessory uniqueIdentifier];
          v13 = [v7 isEqualToString:uniqueIdentifier];

          if ((v13 & 1) == 0)
          {

            v53 = 0;
            v55 = 0;
            v4 = 0;
          }
        }

        characteristic2 = [v8 characteristic];
        service2 = [characteristic2 service];
        accessory2 = [service2 accessory];
        uniqueIdentifier2 = [accessory2 uniqueIdentifier];

        v17 = [[HMMTRCharacteristicWriteRequestTuple alloc] initWithRequestTuple:v8];
        [(HMMTRCharacteristicWriteRequestTuple *)v17 setSecondary:0];
        characteristic3 = [v8 characteristic];
        type = [characteristic3 type];
        if ([type isEqualToString:@"00000013-0000-1000-8000-0026BB765291"])
        {

LABEL_13:
          if (!v4)
          {
            v23 = v17;
            v4 = v23;
LABEL_15:
            [(HMMTRCharacteristicWriteRequestTuple *)v23 setCharacteristicHandlingType:0];
            goto LABEL_38;
          }

          [(HMMTRCharacteristicWriteRequestTuple *)v4 setCharacteristicHandlingType:1];
          [(HMMTRCharacteristicWriteRequestTuple *)v17 setCharacteristicHandlingType:2];
          primary = [(HMMTRCharacteristicWriteRequestTuple *)v4 primary];
          [(HMMTRCharacteristicWriteRequestTuple *)v17 setSecondary:primary];

          v4 = 0;
          goto LABEL_38;
        }

        characteristic4 = [v8 characteristic];
        type2 = [characteristic4 type];
        v22 = [type2 isEqualToString:@"0000002F-0000-1000-8000-0026BB765291"];

        if (v22)
        {
          goto LABEL_13;
        }

        characteristic5 = [v8 characteristic];
        type3 = [characteristic5 type];
        v26 = [type3 isEqualToString:@"00000029-0000-1000-8000-0026BB765291"];

        if (v26)
        {
          [(HMMTRCharacteristicWriteRequestTuple *)v17 setCharacteristicHandlingType:0];
          if (v55)
          {
            [(HMMTRCharacteristicWriteRequestTuple *)v55 setCharacteristicHandlingType:3];
          }

          else
          {
            v55 = 0;
          }

          v53 = 1;
        }

        else
        {
          characteristic6 = [v8 characteristic];
          type4 = [characteristic6 type];
          v30 = [type4 isEqualToString:@"000000B0-0000-1000-8000-0026BB765291"];

          if (!v30)
          {
            v23 = v17;
            goto LABEL_15;
          }

          characteristic7 = [v8 characteristic];
          service3 = [characteristic7 service];

          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v33 = service3;
          }

          else
          {
            v33 = 0;
          }

          v34 = v33;

          endpoint = [v34 endpoint];

          v52 = v34;
          if (endpoint)
          {
            endpoint2 = [v34 endpoint];
          }

          else
          {
            endpoint2 = &unk_283EE89E8;
          }

          clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
          v51 = endpoint2;
          v38 = [clusterIDCharacteristicMap objectForKey:endpoint2];

          v39 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"000000B0-0000-1000-8000-0026BB765291"];
          v40 = [v38 objectForKey:v39];

          v41 = v40;
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            v42 = v41;
          }

          else
          {
            v42 = 0;
          }

          v43 = v42;

          [(HMMTRCharacteristicWriteRequestTuple *)v17 setCharacteristicHandlingType:0];
          v44 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 514];
          v45 = [v43 isEqualToString:v44];

          if (v45)
          {
            v46 = v17;

            if (v53)
            {
              [(HMMTRCharacteristicWriteRequestTuple *)v46 setCharacteristicHandlingType:3];
            }
          }

          else
          {
            v46 = v55;
          }

          v55 = v46;
        }

LABEL_38:
        [v57 addObject:v17];
      }

      v58 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
      if (!v58)
      {
LABEL_42:

        characteristicsCopy = v49;
        break;
      }
    }
  }

  v47 = *MEMORY[0x277D85DE8];

  return v57;
}

- (void)writeCharacteristicValues:(id)values timeout:(double)timeout expiry:(id)expiry completionQueue:(id)queue completionHandler:(id)handler
{
  v42 = *MEMORY[0x277D85DE8];
  valuesCopy = values;
  expiryCopy = expiry;
  queueCopy = queue;
  handlerCopy = handler;
  if (!queueCopy || (v16 = handlerCopy) == 0)
  {
    _HMFPreconditionFailure();
  }

  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v17 = objc_autoreleasePoolPush();
    selfCopy = self;
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      v37 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting writing characteristic.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v35 = v16;
    dispatch_async(queueCopy, block);
  }

  else
  {
    v21 = random();
    v22 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v24 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      v25 = HMFGetLogIdentifier();
      *buf = 138543874;
      v37 = v25;
      v38 = 2112;
      v39 = valuesCopy;
      v40 = 2048;
      v41 = v21;
      _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics(%@) job(%lu) queued.", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v22);
    objc_initWeak(buf, selfCopy2);
    v29[0] = MEMORY[0x277D85DD0];
    v29[1] = 3221225472;
    v29[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_515;
    v29[3] = &unk_2786EFC90;
    objc_copyWeak(v33, buf);
    v33[1] = v21;
    v33[2] = *&timeout;
    v32 = v16;
    v30 = queueCopy;
    v31 = valuesCopy;
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_524;
    v27[3] = &unk_2786F0BC0;
    v28 = v32;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v29 highPriority:1 completion:v27];

    objc_destroyWeak(v33);
    objc_destroyWeak(buf);
  }

  v26 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, 0, v2);
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_515(uint64_t a1)
{
  v28 = *MEMORY[0x277D85DE8];
  WeakRetained = objc_loadWeakRetained((a1 + 56));
  v3 = objc_autoreleasePoolPush();
  v4 = WeakRetained;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v7 = *(a1 + 64);
    *buf = 138543618;
    v25 = v6;
    v26 = 2048;
    v27 = v7;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v3);
  v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  v9 = [v4 clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_516;
  block[3] = &unk_2786EFC68;
  block[4] = v4;
  v22 = *(a1 + 72);
  v21 = *(a1 + 48);
  v18 = v8;
  v19 = *(a1 + 32);
  v10 = *(a1 + 40);
  v11 = *(a1 + 64);
  v20 = v10;
  v23 = v11;
  v12 = v8;
  dispatch_async(v9, block);

  v13 = [v4 clientQueue];
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_523;
  v16[3] = &unk_2786EF620;
  v14 = *(a1 + 64);
  v16[4] = v4;
  v16[5] = v14;
  dispatch_group_notify(v12, v13, v16);

  v15 = *MEMORY[0x277D85DE8];
}

uint64_t __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_524(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_516(uint64_t a1)
{
  v42 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 72)];
    *buf = 138543618;
    *&buf[4] = v5;
    *&buf[12] = 2112;
    *&buf[14] = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to send write requests with time out %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = [*(a1 + 32) deviceController];
  if (v7)
  {
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v41 = 0;
    v29[0] = MEMORY[0x277D85DD0];
    v29[1] = 3221225472;
    v29[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_2;
    v29[3] = &unk_2786EFC20;
    v8 = *(a1 + 32);
    v33 = buf;
    v29[4] = v8;
    v30 = *(a1 + 48);
    v32 = *(a1 + 64);
    v31 = *(a1 + 40);
    v9 = MEMORY[0x2318887D0](v29);
    v10 = [*(a1 + 56) sortedArrayUsingComparator:&__block_literal_global_522];
    v11 = [*(a1 + 32) _populateHandlingForCharacteristics:v10];
    v12 = [*(a1 + 32) matterDevice];

    if (v12)
    {
      [*(a1 + 32) _writeCharacteristicValues:v11 responseTuples:0 completionQueue:*(a1 + 48) completionHandler:v9];
      v13 = dispatch_time(0, 60000000000);
      v14 = [*(a1 + 32) clientQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_3;
      block[3] = &unk_2786EF878;
      v28 = v9;
      dispatch_after(v13, v14, block);

      v15 = v28;
    }

    else
    {
      v21 = objc_autoreleasePoolPush();
      v22 = *(a1 + 32);
      v23 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v24 = HMFGetLogIdentifier();
        v25 = *(a1 + 80);
        *v36 = 138543618;
        v37 = v24;
        v38 = 2048;
        v39 = v25;
        _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_ERROR, "%{public}@Write characteristics job(%lu) started without an available MTRDevice", v36, 0x16u);
      }

      objc_autoreleasePoolPop(v21);
      v15 = [MEMORY[0x277CCA9B8] hapErrorWithCode:13 marker:2203];
      (v9)[2](v9, 0, v15);
    }

    _Block_object_dispose(buf, 8);
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    v17 = *(a1 + 32);
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543362;
      *&buf[4] = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to write characteristics", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v16);
    v20 = [*(a1 + 32) clientQueue];
    v34[0] = MEMORY[0x277D85DD0];
    v34[1] = 3221225472;
    v34[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_517;
    v34[3] = &unk_2786EF878;
    v35 = *(a1 + 64);
    dispatch_async(v20, v34);

    dispatch_group_leave(*(a1 + 40));
  }

  v26 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_523(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_517(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, 0, v2);
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v54 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = *(*(a1 + 64) + 8);
  if ((*(v7 + 24) & 1) == 0)
  {
    *(v7 + 24) = 1;
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543618;
      v46 = v11;
      v47 = 2112;
      v48 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Write completion error: %@", buf, 0x16u);
    }

    v32 = v6;

    objc_autoreleasePoolPop(v8);
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v33 = v5;
    obj = v5;
    v12 = [obj countByEnumeratingWithState:&v41 objects:v53 count:16];
    if (v12)
    {
      v13 = v12;
      v14 = *v42;
      v35 = *v42;
      v34 = a1;
      do
      {
        for (i = 0; i != v13; ++i)
        {
          if (*v42 != v14)
          {
            objc_enumerationMutation(obj);
          }

          v16 = *(*(&v41 + 1) + 8 * i);
          v17 = objc_autoreleasePoolPush();
          v18 = *(a1 + 32);
          v19 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            v20 = HMFGetLogIdentifier();
            v21 = [v16 characteristic];
            v22 = [v21 instanceID];
            v23 = [v16 value];
            v24 = [v16 error];
            *buf = 138544130;
            v46 = v20;
            v47 = 2112;
            v48 = v22;
            v49 = 2112;
            v50 = v23;
            v51 = 2112;
            v52 = v24;
            _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Write completion contains tuple for characteristic %@ with value:%@ Error: %@", buf, 0x2Au);

            a1 = v34;
            v14 = v35;
          }

          objc_autoreleasePoolPop(v17);
        }

        v13 = [obj countByEnumeratingWithState:&v41 objects:v53 count:16];
      }

      while (v13);
    }

    v25 = *(a1 + 40);
    v6 = v32;
    if (v25)
    {
      v26 = *(a1 + 56);
      if (v26)
      {
        if (v32)
        {
          v27 = MEMORY[0x277CCA9B8];
          v28 = [v32 domain];
          v29 = [v27 errorWithDomain:v28 code:objc_msgSend(v32 userInfo:{"code"), 0}];

          v25 = *(a1 + 40);
          v26 = *(a1 + 56);
        }

        else
        {
          v29 = 0;
        }

        block[0] = MEMORY[0x277D85DD0];
        block[1] = 3221225472;
        block[2] = __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_518;
        block[3] = &unk_2786F0EA8;
        v40 = v26;
        v38 = obj;
        v39 = v29;
        v30 = v29;
        dispatch_async(v25, block);
      }
    }

    dispatch_group_leave(*(a1 + 48));
    v5 = v33;
  }

  v31 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_3(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(v1 + 16))(v1, 0, v2);
}

uint64_t __99__HMMTRAccessoryServer_writeCharacteristicValues_timeout_expiry_completionQueue_completionHandler___block_invoke_2_519(uint64_t a1, void *a2, void *a3)
{
  v4 = a3;
  v5 = [a2 characteristic];
  v6 = [v5 service];
  v7 = [v6 accessory];
  v8 = [v7 uniqueIdentifier];
  v9 = [v4 characteristic];

  v10 = [v9 service];
  v11 = [v10 accessory];
  v12 = [v11 uniqueIdentifier];
  v13 = [v8 compare:v12];

  return v13;
}

- (void)_writeCharacteristicValues:(id)values responseTuples:(id)tuples completionQueue:(id)queue completionHandler:(id)handler
{
  v78 = *MEMORY[0x277D85DE8];
  valuesCopy = values;
  tuplesCopy = tuples;
  queueCopy = queue;
  handlerCopy = handler;
  array = tuplesCopy;
  v15 = handlerCopy;
  v16 = objc_autoreleasePoolPush();
  selfCopy = self;
  v18 = HMFGetOSLogHandle();
  v56 = v15;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    v19 = HMFGetLogIdentifier();
    v20 = [valuesCopy count];
    v21 = MEMORY[0x2318887D0](v15);
    v22 = valuesCopy;
    v23 = v21;
    *buf = 138544642;
    v67 = v19;
    v68 = 2048;
    v69 = v20;
    v70 = 2112;
    v71 = v22;
    v72 = 2112;
    v73 = tuplesCopy;
    v74 = 2112;
    v75 = queueCopy;
    v76 = 2112;
    v77 = v21;
    _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@_writeCharacteristicValues count %lu, characteristicWriteRequests %@, responseTuples %@, completionQueue %@, completionHandler %@", buf, 0x3Eu);

    valuesCopy = v22;
    v15 = v56;
  }

  objc_autoreleasePoolPop(v16);
  v24 = +[HMMTRProtocolOperationManager sharedInstance];
  if ([valuesCopy count])
  {
    v54 = valuesCopy;
    v55 = v24;
    v52 = queueCopy;
    popFirstObject = [valuesCopy popFirstObject];
    if (!array)
    {
      array = [MEMORY[0x277CBEB18] array];
    }

    v53 = array;
    primary = [popFirstObject primary];
    characteristic = [primary characteristic];
    [(HMMTRAccessoryServer *)selfCopy _populateServiceForCharacteristic:characteristic];

    v28 = [HMMTRProtocolOperation alloc];
    characteristicHandlingType = [popFirstObject characteristicHandlingType];
    primary2 = [popFirstObject primary];
    characteristic2 = [primary2 characteristic];
    primary3 = [popFirstObject primary];
    value = [primary3 value];
    matterDevice = [(HMMTRAccessoryServer *)selfCopy matterDevice];
    clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)selfCopy clusterIDCharacteristicMap];
    v36 = [(HMMTRProtocolOperation *)v28 initWithOperationOfType:1 characteristicHandlingType:characteristicHandlingType targetCharacteristic:characteristic2 targetValue:value matterDevice:matterDevice clusterIDCharacteristicMap:clusterIDCharacteristicMap];

    primary4 = [popFirstObject primary];
    [(HMMTRProtocolOperation *)v36 setWritePrimaryRequestTuple:primary4];

    secondary = [popFirstObject secondary];
    [(HMMTRProtocolOperation *)v36 setWriteSecondaryRequestTuple:secondary];

    v39 = [HMMTRDeviceTopology alloc];
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    v41 = [(HMMTRDeviceTopology *)v39 initWithNodeId:nodeID server:selfCopy];
    [(HMMTRProtocolOperation *)v36 setTopology:v41];

    if (v36)
    {
      v57[0] = MEMORY[0x277D85DD0];
      v57[1] = 3221225472;
      v57[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke;
      v57[3] = &unk_2786EFBF8;
      v42 = popFirstObject;
      v58 = v42;
      array = v53;
      v59 = v53;
      v60 = selfCopy;
      valuesCopy = v54;
      v61 = v54;
      v62 = v52;
      v65 = v56;
      v63 = v55;
      v64 = v36;
      v43 = MEMORY[0x2318887D0](v57);
      primary5 = [v42 primary];
      characteristic3 = [primary5 characteristic];
      [(HMMTRAccessoryServer *)selfCopy _queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:characteristic3 completion:v43];

      queueCopy = v52;
      v15 = v56;

      v46 = v58;
    }

    else
    {
      v46 = [MEMORY[0x277CCA9B8] hapErrorWithCode:3 marker:241];
      v47 = MEMORY[0x277CFEA90];
      primary6 = [popFirstObject primary];
      characteristic4 = [primary6 characteristic];
      v50 = [v47 responseTupleForCharacteristic:characteristic4 error:v46];

      array = v53;
      [v53 addObject:v50];
      valuesCopy = v54;
      queueCopy = v52;
      v15 = v56;
      [(HMMTRAccessoryServer *)selfCopy _writeCharacteristicValues:v54 responseTuples:v53 completionQueue:v52 completionHandler:v56];
    }

    v24 = v55;
  }

  else
  {
    (*(v15 + 2))(v15, array, 0);
  }

  v51 = *MEMORY[0x277D85DE8];
}

void __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    v3 = MEMORY[0x277CFEA90];
    v4 = [*(a1 + 32) primary];
    v5 = [v4 characteristic];
    v6 = [MEMORY[0x277CCA9B8] hapIPErrorWithCode:-70402 marker:2402];
    v7 = [v3 responseTupleForCharacteristic:v5 error:v6];

    [*(a1 + 40) addObject:v7];
    v8 = [*(a1 + 48) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_2;
    block[3] = &unk_2786F0260;
    v22 = *(a1 + 48);
    v9 = *(&v22 + 1);
    v10 = *(a1 + 40);
    v11 = *(a1 + 64);
    *&v12 = v10;
    *(&v12 + 1) = v11;
    v30 = v22;
    v31 = v12;
    v32 = *(a1 + 88);
    dispatch_async(v8, block);
  }

  else
  {
    v13 = *(a1 + 72);
    v14 = *(a1 + 80);
    v15 = *(a1 + 48);
    v16 = [v15 clientQueue];
    v17 = [*(a1 + 48) reportDistributor];
    v25[0] = MEMORY[0x277D85DD0];
    v25[1] = 3221225472;
    v25[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_3;
    v25[3] = &unk_2786EF710;
    *&v18 = *(a1 + 40);
    *(&v18 + 1) = *(a1 + 48);
    v23 = v18;
    v19 = *(a1 + 56);
    v20 = *(a1 + 64);
    *&v21 = v19;
    *(&v21 + 1) = v20;
    v26 = v23;
    v27 = v21;
    v28 = *(a1 + 88);
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_4;
    v24[3] = &unk_2786EFBD0;
    v24[4] = *(a1 + 48);
    [v13 registerOperation:v14 accessoryServer:v15 clientQueue:v16 reportDistributor:v17 operationResponseHandler:v25 updatedAttributesHandler:v24];

    v7 = v26;
  }
}

uint64_t __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_3(uint64_t a1, uint64_t a2)
{
  [*(a1 + 32) addObject:a2];
  v4 = *(a1 + 32);
  v3 = *(a1 + 40);
  v5 = *(a1 + 48);
  v6 = *(a1 + 56);
  v7 = *(a1 + 64);

  return [v3 _writeCharacteristicValues:v5 responseTuples:v4 completionQueue:v6 completionHandler:v7];
}

void __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_4(uint64_t a1, void *a2)
{
  v2 = *(a1 + 32);
  v3 = a2;
  v4 = [v2 matterDevice];
  [v2 device:v4 receivedAttributeReport:v3];
}

- (void)_readCharacteristicValues:(id)values timeout:(double)timeout skipCache:(BOOL)cache sendNotification:(BOOL)notification completionQueue:(id)queue completionHandler:(id)handler
{
  v47 = *MEMORY[0x277D85DE8];
  valuesCopy = values;
  queueCopy = queue;
  handlerCopy = handler;
  if (!queueCopy || (v17 = handlerCopy) == 0)
  {
    _HMFPreconditionFailure();
  }

  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v18 = objc_autoreleasePoolPush();
    selfCopy = self;
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      v21 = HMFGetLogIdentifier();
      *buf = 138543362;
      v42 = v21;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting reading characteristic.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v18);
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v40 = v17;
    dispatch_async(queueCopy, block);
    v22 = v40;
  }

  else
  {
    v23 = random();
    v24 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      v27 = HMFGetLogIdentifier();
      *buf = 138543874;
      v42 = v27;
      v43 = 2112;
      v44 = valuesCopy;
      v45 = 2048;
      v46 = v23;
      _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics(%@) job(%lu) queued.", buf, 0x20u);
    }

    objc_autoreleasePoolPop(v24);
    v31[0] = MEMORY[0x277D85DD0];
    v31[1] = 3221225472;
    v31[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_504;
    v31[3] = &unk_2786EFBA8;
    v31[4] = selfCopy2;
    v35 = v23;
    timeoutCopy = timeout;
    v32 = valuesCopy;
    cacheCopy = cache;
    v33 = queueCopy;
    v34 = v17;
    notificationCopy = notification;
    v29[0] = MEMORY[0x277D85DD0];
    v29[1] = 3221225472;
    v29[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_514;
    v29[3] = &unk_2786F0BC0;
    v30 = v34;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v31 highPriority:0 completion:v29];

    v22 = v32;
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, 0, v2);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_504(uint64_t a1)
{
  v31 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 64);
    *buf = 138543618;
    v28 = v5;
    v29 = 2048;
    v30 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_505;
  block[3] = &unk_2786EFB80;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v23 = *(a1 + 72);
  v10 = v9;
  v25 = *(a1 + 80);
  v11 = *(a1 + 64);
  v19 = v10;
  v24 = v11;
  v20 = *(a1 + 48);
  v12 = *(a1 + 56);
  v26 = *(a1 + 81);
  v21 = v7;
  v22 = v12;
  v13 = v7;
  dispatch_async(v8, block);

  v14 = [*(a1 + 32) clientQueue];
  v17[0] = MEMORY[0x277D85DD0];
  v17[1] = 3221225472;
  v17[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3;
  v17[3] = &unk_2786EF620;
  v15 = *(a1 + 64);
  v17[4] = *(a1 + 32);
  v17[5] = v15;
  dispatch_group_notify(v13, v14, v17);

  v16 = *MEMORY[0x277D85DE8];
}

uint64_t __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_514(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_505(uint64_t a1)
{
  v59 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 72)];
    *buf = 138543618;
    *&buf[4] = v5;
    *&buf[12] = 2112;
    *&buf[14] = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to send read requests with time out %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  *buf = 0;
  *&buf[8] = buf;
  *&buf[16] = 0x3032000000;
  v56 = __Block_byref_object_copy__10189;
  v57 = __Block_byref_object_dispose__10190;
  v58 = [MEMORY[0x277CBEB18] array];
  v7 = dispatch_group_create();
  v8 = dispatch_group_create();
  v49[0] = 0;
  v49[1] = v49;
  v49[2] = 0x2020000000;
  v50 = 0;
  v47[0] = 0;
  v47[1] = v47;
  v47[2] = 0x2020000000;
  v48 = 0;
  v33[0] = MEMORY[0x277D85DD0];
  v33[1] = 3221225472;
  v33[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_506;
  v33[3] = &unk_2786EFB30;
  v41 = v47;
  v9 = *(a1 + 40);
  v10 = *(a1 + 32);
  v34 = v9;
  v35 = v10;
  v42 = buf;
  v45 = *(a1 + 88);
  v11 = v8;
  v12 = *(a1 + 80);
  v43 = v49;
  v44 = v12;
  v36 = v11;
  v13 = v7;
  v37 = v13;
  v38 = *(a1 + 48);
  v40 = *(a1 + 64);
  v46 = *(a1 + 89);
  v39 = *(a1 + 56);
  v14 = MEMORY[0x2318887D0](v33);
  if ([*(a1 + 32) isReadyToReadFromMTRDevice])
  {
    v14[2](v14);
  }

  else
  {
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      v19 = *(a1 + 80);
      *v51 = 138543618;
      v52 = v18;
      v53 = 2048;
      v54 = v19;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Read job(%lu) deferred till MTRDevice is ready to read from", v51, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v20 = MEMORY[0x2318887D0](v14);
    v21 = [*(a1 + 32) pendingMTRDeviceReadReadyHandlers];
    v22 = [MEMORY[0x277CCABB0] numberWithLong:*(a1 + 80)];
    [v21 setObject:v20 forKeyedSubscript:v22];

    v23 = *(a1 + 32);
    v24 = dispatch_time(0, 60000000000);
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_512;
    v27[3] = &unk_2786EFB58;
    v25 = *(a1 + 32);
    v31 = v47;
    v27[4] = v25;
    v32 = *(a1 + 80);
    v28 = *(a1 + 48);
    v30 = *(a1 + 64);
    v29 = *(a1 + 56);
    [v23 dispatchAfter:v24 block:v27];
  }

  _Block_object_dispose(v47, 8);
  _Block_object_dispose(v49, 8);

  _Block_object_dispose(buf, 8);
  v26 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_506(uint64_t a1)
{
  v63 = *MEMORY[0x277D85DE8];
  v1 = *(*(a1 + 88) + 8);
  if ((*(v1 + 24) & 1) == 0)
  {
    *(v1 + 24) = 1;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v3 = *(a1 + 32);
    v4 = [v3 countByEnumeratingWithState:&v58 objects:v62 count:16];
    if (v4)
    {
      v5 = *v59;
      v30 = v54;
      do
      {
        for (i = 0; i != v4; ++i)
        {
          if (*v59 != v5)
          {
            objc_enumerationMutation(v3);
          }

          v7 = *(*(&v58 + 1) + 8 * i);
          [*(a1 + 40) _populateServiceForCharacteristic:{v7, v30}];
          v8 = [*(a1 + 40) _readFixedCharacteristicValue:v7];
          if (v8)
          {
            v9 = [MEMORY[0x277CFEA90] responseTupleForCharacteristic:v7 error:0];
            [*(*(*(a1 + 96) + 8) + 40) addObject:v9];
          }

          else
          {
            v9 = [*(a1 + 40) _readLocallyMaintainedCharacteristicValue:v7];
            if (v9)
            {
              v10 = [MEMORY[0x277CFEA90] responseTupleForCharacteristic:v7 error:0];
              [*(*(*(a1 + 96) + 8) + 40) addObject:v10];
            }

            else
            {
              if (*(a1 + 120))
              {
                *(*(*(a1 + 104) + 8) + 24) = 1;
                v11 = *(*(*(a1 + 96) + 8) + 40);
                v12 = MEMORY[0x277CFEA90];
                v13 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:11];
                v14 = [v12 responseTupleForCharacteristic:v7 error:v13];
                [v11 addObject:v14];
              }

              else
              {
                dispatch_group_enter(*(a1 + 48));
                v15 = *(a1 + 40);
                v53[0] = MEMORY[0x277D85DD0];
                v53[1] = 3221225472;
                v54[0] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2;
                v54[1] = &unk_2786EFAB0;
                v54[2] = v15;
                v57 = *(a1 + 112);
                v56 = vextq_s8(*(a1 + 96), *(a1 + 96), 8uLL);
                v55 = *(a1 + 48);
                [v15 _readCharacteristicValueFromCacheWithCharacteristic:v7 responseHandler:v53];
              }

              v9 = 0;
            }
          }
        }

        v4 = [v3 countByEnumeratingWithState:&v58 objects:v62 count:16];
      }

      while (v4);
    }

    v51[0] = 0;
    v51[1] = v51;
    v51[2] = 0x2020000000;
    v52 = 0;
    dispatch_group_enter(*(a1 + 56));
    v16 = *(a1 + 48);
    v17 = [*(a1 + 40) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_507;
    block[3] = &unk_2786EFAD8;
    v18 = *(a1 + 40);
    v48 = *(a1 + 104);
    v49 = v51;
    block[4] = v18;
    v50 = *(a1 + 112);
    v47 = *(a1 + 56);
    dispatch_group_notify(v16, v17, block);

    v38[0] = MEMORY[0x277D85DD0];
    v38[1] = 3221225472;
    v38[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_508;
    v38[3] = &unk_2786EFB00;
    v43 = v51;
    v39 = *(a1 + 64);
    v42 = *(a1 + 80);
    v45 = *(a1 + 121);
    v31 = *(a1 + 32);
    v19 = v31.i64[0];
    v40 = vextq_s8(v31, v31, 8uLL);
    v44 = *(a1 + 112);
    v41 = *(a1 + 72);
    v20 = MEMORY[0x2318887D0](v38);
    v21 = dispatch_time(0, 60000000000);
    v22 = [*(a1 + 40) clientQueue];
    v35[0] = MEMORY[0x277D85DD0];
    v35[1] = 3221225472;
    v35[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_510;
    v35[3] = &unk_2786EFF18;
    v23 = *(a1 + 112);
    v35[4] = *(a1 + 40);
    v37 = v23;
    v24 = v20;
    v36 = v24;
    dispatch_after(v21, v22, v35);

    v25 = *(a1 + 56);
    v26 = [*(a1 + 40) clientQueue];
    v32[0] = MEMORY[0x277D85DD0];
    v32[1] = 3221225472;
    v32[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_511;
    v32[3] = &unk_2786F0AF8;
    v27 = *(a1 + 96);
    v33 = v24;
    v34 = v27;
    v28 = v24;
    dispatch_group_notify(v25, v26, v32);

    _Block_object_dispose(v51, 8);
  }

  v29 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_512(uint64_t a1)
{
  v1 = *(*(a1 + 64) + 8);
  if ((*(v1 + 24) & 1) == 0)
  {
    *(v1 + 24) = 1;
    v3 = [*(a1 + 32) pendingMTRDeviceReadReadyHandlers];
    v4 = [MEMORY[0x277CCABB0] numberWithLong:*(a1 + 72)];
    [v3 setObject:0 forKeyedSubscript:v4];

    v5 = *(a1 + 40);
    v6[0] = MEMORY[0x277D85DD0];
    v6[1] = 3221225472;
    v6[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_513;
    v6[3] = &unk_2786EF5A8;
    v8 = *(a1 + 56);
    v7 = *(a1 + 48);
    dispatch_async(v5, v6);
  }
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_513(uint64_t a1)
{
  v2 = *(a1 + 40);
  v3 = [MEMORY[0x277CCA9B8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(v2 + 16))(v2, 0, v3);

  v4 = *(a1 + 32);

  dispatch_group_leave(v4);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  v17 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7 = HMFGetLogIdentifier();
    v8 = *(a1 + 64);
    v11 = 138543874;
    v12 = v7;
    v13 = 2048;
    v14 = v8;
    v15 = 2112;
    v16 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_DEBUG, "%{public}@readCharacteristicValueFromCache(%lu) response: %@", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v4);
  v9 = [v3 error];

  if (v9)
  {
    *(*(*(a1 + 48) + 8) + 24) = 1;
  }

  [*(*(*(a1 + 56) + 8) + 40) addObject:v3];
  dispatch_group_leave(*(a1 + 40));

  v10 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_507(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  if (*(*(*(a1 + 48) + 8) + 24) == 1 && (*(*(*(a1 + 56) + 8) + 24) & 1) == 0)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v6 = *(a1 + 64);
      v8 = 138543618;
      v9 = v5;
      v10 = 2048;
      v11 = v6;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Cache read didn't succeed for all requests (%lu)", &v8, 0x16u);
    }

    objc_autoreleasePoolPop(v2);
  }

  dispatch_group_leave(*(a1 + 40));
  v7 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_508(uint64_t a1, void *a2, void *a3)
{
  v48 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = v6;
  v8 = *(*(a1 + 72) + 8);
  if ((*(v8 + 24) & 1) == 0)
  {
    *(v8 + 24) = 1;
    if (!*(a1 + 32) || !*(a1 + 64))
    {
      goto LABEL_24;
    }

    if (v6)
    {
      v9 = MEMORY[0x277CCA9B8];
      v10 = [v6 domain];
      v11 = [v9 errorWithDomain:v10 code:objc_msgSend(v7 userInfo:{"code"), 0}];

LABEL_23:
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_509;
      block[3] = &unk_2786F0288;
      v27 = *(a1 + 32);
      v28 = *(a1 + 80);
      block[4] = *(a1 + 40);
      v36 = v28;
      v33 = v5;
      v34 = v11;
      v35 = *(a1 + 64);
      v29 = v11;
      dispatch_async(v27, block);

LABEL_24:
      dispatch_group_leave(*(a1 + 56));
      goto LABEL_25;
    }

    if (*(a1 + 88) != 1)
    {
LABEL_22:
      v11 = 0;
      goto LABEL_23;
    }

    v12 = objc_alloc_init(MEMORY[0x277CBEB18]);
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v13 = v5;
    v14 = [v13 countByEnumeratingWithState:&v37 objects:v47 count:16];
    if (v14)
    {
      v15 = v14;
      v31 = v5;
      v16 = 0;
      v17 = *v38;
      do
      {
        for (i = 0; i != v15; ++i)
        {
          if (*v38 != v17)
          {
            objc_enumerationMutation(v13);
          }

          v19 = *(*(&v37 + 1) + 8 * i);
          v20 = [v19 error];

          if (!v20)
          {
            v21 = [v19 characteristic];
            [v12 addObject:v21];

            v16 = 1;
          }
        }

        v15 = [v13 countByEnumeratingWithState:&v37 objects:v47 count:16];
      }

      while (v15);

      v5 = v31;
      if ((v16 & 1) == 0)
      {
        goto LABEL_21;
      }

      v22 = objc_autoreleasePoolPush();
      v23 = *(a1 + 40);
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        v25 = HMFGetLogIdentifier();
        v26 = *(a1 + 48);
        *buf = 138543874;
        v42 = v25;
        v43 = 2112;
        v44 = v12;
        v45 = 2112;
        v46 = v26;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_DEBUG, "%{public}@Calling didUpdateValuesForCharacteristics for %@ from read requests %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v22);
      v13 = [*(a1 + 40) delegate];
      [v13 accessoryServer:*(a1 + 40) didUpdateValuesForCharacteristics:v12 stateNumber:0 broadcast:0];
    }

LABEL_21:
    goto LABEL_22;
  }

LABEL_25:

  v30 = *MEMORY[0x277D85DE8];
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_510(uint64_t a1)
{
  v2 = [*(a1 + 32) pendingMTRDeviceReadReadyHandlers];
  v3 = [MEMORY[0x277CCABB0] numberWithLong:*(a1 + 48)];
  [v2 setObject:0 forKeyedSubscript:v3];

  v4 = *(a1 + 40);
  v5 = [MEMORY[0x277CCA9B8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(v4 + 16))(v4, 0, v5);
}

uint64_t __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_509(uint64_t a1)
{
  v21 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 64);
    v7 = *(a1 + 40);
    v8 = *(a1 + 48);
    v13 = 138544130;
    v14 = v5;
    v15 = 2048;
    v16 = v6;
    v17 = 2112;
    v18 = v7;
    v19 = 2112;
    v20 = v8;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_DEBUG, "%{public}@readCharacteristicValues(%lu) response:%@, error:%@", &v13, 0x2Au);
  }

  objc_autoreleasePoolPop(v2);
  v9 = *(a1 + 48);
  v10 = *(a1 + 40);
  result = (*(*(a1 + 56) + 16))();
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

- (id)_readLocallyMaintainedCharacteristicValue:(id)value
{
  valueCopy = value;
  type = [valueCopy type];
  v6 = [type isEqual:@"0000026E-0000-1000-8000-0026BB765291"];

  if (v6)
  {
    matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    v8 = [matterFirmwareUpdateStatus readForMatterFirmwareUpdateStatusCharacteristic:valueCopy];
LABEL_7:
    v13 = v8;

    goto LABEL_8;
  }

  type2 = [valueCopy type];
  v10 = [type2 isEqual:@"00000235-0000-1000-8000-0026BB765291"];

  if (v10)
  {
    matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    v8 = [matterFirmwareUpdateStatus readForHAPFirmwareUpdateStatusCharacteristic:valueCopy];
    goto LABEL_7;
  }

  type3 = [valueCopy type];
  v12 = [type3 isEqual:@"00000234-0000-1000-8000-0026BB765291"];

  if (v12)
  {
    matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    v8 = [matterFirmwareUpdateStatus readForHAPFirmwareUpdateReadinessCharacteristic:valueCopy];
    goto LABEL_7;
  }

  v13 = 0;
LABEL_8:

  return v13;
}

- (void)_readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:(id)characteristic responseHandler:(id)handler
{
  v33 = *MEMORY[0x277D85DE8];
  characteristicCopy = characteristic;
  handlerCopy = handler;
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  v9 = objc_autoreleasePoolPush();
  selfCopy = self;
  v11 = HMFGetOSLogHandle();
  v12 = v11;
  if (matterDevice)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = HMFGetLogIdentifier();
      v29 = 138543618;
      v30 = v13;
      v31 = 2112;
      v32 = characteristicCopy;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Read cache operation starts for characteristic: %@", &v29, 0x16u);
    }

    objc_autoreleasePoolPop(v9);
    v14 = [HMMTRProtocolOperation alloc];
    matterDevice2 = [(HMMTRAccessoryServer *)selfCopy matterDevice];
    clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)selfCopy clusterIDCharacteristicMap];
    v17 = [(HMMTRProtocolOperation *)v14 initWithOperationOfType:4 characteristic:characteristicCopy matterDevice:matterDevice2 clusterIDCharacteristicMap:clusterIDCharacteristicMap];

    if (v17)
    {
      v18 = +[HMMTRProtocolOperationManager sharedInstance];
      clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
      reportDistributor = [(HMMTRAccessoryServer *)selfCopy reportDistributor];
      [v18 registerOperation:v17 accessoryServer:selfCopy clientQueue:clientQueue reportDistributor:reportDistributor operationResponseHandler:handlerCopy updatedAttributesHandler:0];
    }

    else
    {
      v23 = objc_autoreleasePoolPush();
      v24 = selfCopy;
      v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = HMFGetLogIdentifier();
        v29 = 138543618;
        v30 = v26;
        v31 = 2112;
        v32 = characteristicCopy;
        _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_DEBUG, "%{public}@Read cache operation failed to be created for characteristic: %@", &v29, 0x16u);
      }

      objc_autoreleasePoolPop(v23);
      v27 = MEMORY[0x277CFEA90];
      v18 = [MEMORY[0x277CCA9B8] hapErrorWithCode:14 marker:2304];
      clientQueue = [v27 responseTupleForCharacteristic:characteristicCopy error:v18];
      handlerCopy[2](handlerCopy, clientQueue);
    }
  }

  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v21 = HMFGetLogIdentifier();
      v29 = 138543618;
      v30 = v21;
      v31 = 2112;
      v32 = characteristicCopy;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to read characteristic value from cache for characteristic %@", &v29, 0x16u);
    }

    objc_autoreleasePoolPop(v9);
    v22 = MEMORY[0x277CFEA90];
    v17 = [MEMORY[0x277CCA9B8] hapErrorWithCode:14 marker:2305];
    v18 = [v22 responseTupleForCharacteristic:characteristicCopy error:v17];
    handlerCopy[2](handlerCopy, v18);
  }

  v28 = *MEMORY[0x277D85DE8];
}

- (void)_readCharacteristicValueFromCacheWithCharacteristic:(id)characteristic responseHandler:(id)handler
{
  characteristicCopy = characteristic;
  handlerCopy = handler;
  v10[0] = MEMORY[0x277D85DD0];
  v10[1] = 3221225472;
  v10[2] = __92__HMMTRAccessoryServer__readCharacteristicValueFromCacheWithCharacteristic_responseHandler___block_invoke;
  v10[3] = &unk_2786EFA88;
  v10[4] = self;
  v11 = characteristicCopy;
  v12 = handlerCopy;
  v8 = handlerCopy;
  v9 = characteristicCopy;
  [(HMMTRAccessoryServer *)self _queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:v9 completion:v10];
}

void __92__HMMTRAccessoryServer__readCharacteristicValueFromCacheWithCharacteristic_responseHandler___block_invoke(uint64_t a1, int a2)
{
  v23 = *MEMORY[0x277D85DE8];
  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    v4 = *(a1 + 32);
    v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = HMFGetLogIdentifier();
      v7 = *(a1 + 40);
      v19 = 138543618;
      v20 = v6;
      v21 = 2112;
      v22 = v7;
      _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_ERROR, "%{public}@Read cache operation aborted for characteristic since the bridged accessory is unreachable: %@", &v19, 0x16u);
    }

    objc_autoreleasePoolPop(v3);
    v8 = MEMORY[0x277CFEA90];
    v11 = a1 + 40;
    v9 = *(a1 + 40);
    v10 = *(v11 + 8);
    v12 = [MEMORY[0x277CCA9B8] hapIPErrorWithCode:-70402 marker:2401];
    v13 = [v8 responseTupleForCharacteristic:v9 error:v12];
    (*(v10 + 16))(v10, v13);

    v14 = *MEMORY[0x277D85DE8];
  }

  else
  {
    v15 = *(a1 + 32);
    v16 = *(a1 + 40);
    v17 = *(a1 + 48);
    v18 = *MEMORY[0x277D85DE8];

    [v15 _readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:v16 responseHandler:v17];
  }
}

- (id)_readFixedCharacteristicValue:(id)value
{
  v19 = *MEMORY[0x277D85DE8];
  valueCopy = value;
  type = [valueCopy type];
  if ([type isEqual:@"000000CB-0000-1000-8000-0026BB765291"])
  {
  }

  else
  {
    type2 = [valueCopy type];
    v7 = [type2 isEqual:@"000000CD-0000-1000-8000-0026BB765291"];

    if (!v7)
    {
      value = 0;
      goto LABEL_8;
    }
  }

  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    v11 = HMFGetLogIdentifier();
    v15 = 138543618;
    v16 = v11;
    v17 = 2112;
    v18 = valueCopy;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Read operation on fixed value characteristic: %@", &v15, 0x16u);
  }

  objc_autoreleasePoolPop(v8);
  value = [valueCopy value];
LABEL_8:

  v13 = *MEMORY[0x277D85DE8];

  return value;
}

- (void)removeAllPairingsWithCompletionHandler:(id)handler
{
  v28 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v25 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting removing all pairings.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v23 = handlerCopy;
    dispatch_async(clientQueue, block);

    v10 = v23;
  }

  else
  {
    v11 = random();
    v12 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v25 = v15;
      v26 = 2048;
      v27 = v11;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v12);
    v19[0] = MEMORY[0x277D85DD0];
    v19[1] = 3221225472;
    v19[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_484;
    v19[3] = &unk_2786EFF18;
    v19[4] = selfCopy2;
    v21 = v11;
    v20 = handlerCopy;
    v17[0] = MEMORY[0x277D85DD0];
    v17[1] = 3221225472;
    v17[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_489;
    v17[3] = &unk_2786F0BC0;
    v18 = v20;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v19 highPriority:1 completion:v17];

    v10 = v20;
  }

  v16 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_484(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_485;
  block[3] = &unk_2786F0EA8;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_488;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_489(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_485(id *a1)
{
  v35 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = a1[4];
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    *&buf[4] = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Removing all pairings", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v31[0] = MEMORY[0x277D85DD0];
  v31[1] = 3221225472;
  v31[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_486;
  v31[3] = &unk_2786EF8A0;
  v33 = a1[6];
  v32 = a1[5];
  v6 = MEMORY[0x2318887D0](v31);
  v7 = [a1[4] deviceController];
  if (v7)
  {
    v8 = a1[4];
    v9 = [v8 nodeID];
    v10 = [v8 mtrBaseDeviceWithNodeID:v9 controller:v7];

    if (v10)
    {
      v11 = objc_alloc(MEMORY[0x277D0F7A8]);
      v12 = [a1[4] clientQueue];
      v13 = [v11 initWithQueue:v12];

      *buf = _HMFThreadLocalAsyncContextPush();
      v14 = [a1[4] clientQueue];
      v15 = [a1[4] browser];
      v16 = [v15 vendorMetadataStore];
      v27[0] = MEMORY[0x277D85DD0];
      v27[1] = 3221225472;
      v27[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_2;
      v27[3] = &unk_2786EF8A0;
      v27[4] = a1[4];
      v28 = v6;
      [v10 removeAllPairingsForCallbackQueue:v14 vendorMetadataStore:v16 completionHandler:v27];

      _HMFThreadLocalAsyncContextPop();
    }

    else
    {
      v22 = objc_autoreleasePoolPush();
      v23 = a1[4];
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v25 = HMFGetLogIdentifier();
        *buf = 138543362;
        *&buf[4] = v25;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch pairings because of no device", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v22);
      v13 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      (v6)[2](v6, v13);
    }
  }

  else
  {
    v17 = objc_autoreleasePoolPush();
    v18 = a1[4];
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      *&buf[4] = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to remove all pairings", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    v21 = [a1[4] clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_487;
    block[3] = &unk_2786EF878;
    v30 = v6;
    dispatch_async(v21, block);

    v10 = v30;
  }

  v26 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_488(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_486(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_487(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  v15 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v11 = 138543618;
      v12 = v8;
      v13 = 2112;
      v14 = v3;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove all pairings: %@", &v11, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v11 = 138543362;
      v12 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed all pairings.", &v11, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [*(a1 + 32) setOperationDisabled:1];
    [*(a1 + 32) setOperationDisabledReason:2];
  }

  (*(*(a1 + 40) + 16))();

  v10 = *MEMORY[0x277D85DE8];
}

- (void)fetchExtendedMACAddressFromDevice:(id)device completion:(id)completion
{
  v32 = *MEMORY[0x277D85DE8];
  deviceCopy = device;
  completionCopy = completion;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching eMAC address.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke;
    block[3] = &unk_2786EF878;
    v27 = completionCopy;
    dispatch_async(clientQueue, block);

    v13 = v27;
  }

  else
  {
    v14 = random();
    v15 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v29 = v18;
      v30 = 2048;
      v31 = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_473;
    v22[3] = &unk_2786EF850;
    v22[4] = selfCopy2;
    v25 = v14;
    v24 = completionCopy;
    v23 = deviceCopy;
    v20[0] = MEMORY[0x277D85DD0];
    v20[1] = 3221225472;
    v20[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_483;
    v20[3] = &unk_2786F0BC0;
    v21 = v24;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v22 highPriority:0 completion:v20];

    v13 = v24;
  }

  v19 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, 0, v2);
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_473(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 56);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_474;
  block[3] = &unk_2786EFA60;
  block[4] = *(a1 + 32);
  v17 = *(a1 + 48);
  v15 = v7;
  v16 = *(a1 + 40);
  v9 = v7;
  dispatch_async(v8, block);

  v10 = [*(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x277D85DD0];
  v13[1] = 3221225472;
  v13[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_482;
  v13[3] = &unk_2786EF620;
  v11 = *(a1 + 56);
  v13[4] = *(a1 + 32);
  v13[5] = v11;
  dispatch_group_notify(v9, v10, v13);

  v12 = *MEMORY[0x277D85DE8];
}

uint64_t __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_483(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_474(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching eMAC address", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v13[0] = MEMORY[0x277D85DD0];
  v13[1] = 3221225472;
  v13[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_475;
  v13[3] = &unk_2786EFA08;
  v15 = *(a1 + 56);
  v14 = *(a1 + 40);
  v6 = MEMORY[0x2318887D0](v13);
  v7 = *(a1 + 48);
  v8 = [*(a1 + 32) clientQueue];
  v11[0] = MEMORY[0x277D85DD0];
  v11[1] = 3221225472;
  v11[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_478;
  v11[3] = &unk_2786EFA38;
  v11[4] = *(a1 + 32);
  v12 = v6;
  v9 = v6;
  [v7 readAttributesWithEndpointID:&unk_283EE89B8 clusterID:&unk_283EE8BE0 attributeID:&unk_283EE89B8 params:0 queue:v8 completion:v11];

  v10 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_482(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_475(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_478(uint64_t a1, void *a2, void *a3)
{
  v29 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      v25 = 138543618;
      v26 = v11;
      v27 = 2112;
      v28 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned values as %@", &v25, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v12 = *(a1 + 32);
    v13 = [v5 firstObject];
    v14 = [v13 objectForKeyedSubscript:*MEMORY[0x277CD50D8]];
    v15 = [v12 _getThreadHardwareAddressFromReadValue:v14];

    v16 = [v15 stringByReplacingOccurrencesOfString:@":" withString:&stru_283ED2308];
    [*(a1 + 32) setEMACAddress:v16];

    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      v20 = HMFGetLogIdentifier();
      v25 = 138543618;
      v26 = v20;
      v27 = 2112;
      v28 = v15;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Accessory returned eMAC address as %@", &v25, 0x16u);
    }

    objc_autoreleasePoolPop(v17);
    v21 = *(*(a1 + 40) + 16);
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v22 = HMFGetLogIdentifier();
      v25 = 138543618;
      v26 = v22;
      v27 = 2112;
      v28 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve eMAC address: %@", &v25, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v23 = *(a1 + 40);
    v15 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
    v21 = *(v23 + 16);
  }

  v21();

  v24 = *MEMORY[0x277D85DE8];
}

- (void)fetchWEDSupportInformationFromDevice:(id)device completion:(id)completion
{
  v32 = *MEMORY[0x277D85DE8];
  deviceCopy = device;
  completionCopy = completion;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching WED support information.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke;
    block[3] = &unk_2786EF878;
    v27 = completionCopy;
    dispatch_async(clientQueue, block);

    v13 = v27;
  }

  else
  {
    v14 = random();
    v15 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v29 = v18;
      v30 = 2048;
      v31 = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_467;
    v22[3] = &unk_2786EF850;
    v22[4] = selfCopy2;
    v25 = v14;
    v24 = completionCopy;
    v23 = deviceCopy;
    v20[0] = MEMORY[0x277D85DD0];
    v20[1] = 3221225472;
    v20[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_472;
    v20[3] = &unk_2786F0BC0;
    v21 = v24;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v22 highPriority:0 completion:v20];

    v13 = v24;
  }

  v19 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, 0, v2);
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_467(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 56);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_468;
  block[3] = &unk_2786EFA60;
  block[4] = *(a1 + 32);
  v17 = *(a1 + 48);
  v15 = v7;
  v16 = *(a1 + 40);
  v9 = v7;
  dispatch_async(v8, block);

  v10 = [*(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x277D85DD0];
  v13[1] = 3221225472;
  v13[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_471;
  v13[3] = &unk_2786EF620;
  v11 = *(a1 + 56);
  v13[4] = *(a1 + 32);
  v13[5] = v11;
  dispatch_group_notify(v9, v10, v13);

  v12 = *MEMORY[0x277D85DE8];
}

uint64_t __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_472(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_468(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching WED support information", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v13[0] = MEMORY[0x277D85DD0];
  v13[1] = 3221225472;
  v13[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_469;
  v13[3] = &unk_2786EFA08;
  v15 = *(a1 + 56);
  v14 = *(a1 + 40);
  v6 = MEMORY[0x2318887D0](v13);
  v7 = *(a1 + 48);
  v8 = [*(a1 + 32) clientQueue];
  v11[0] = MEMORY[0x277D85DD0];
  v11[1] = 3221225472;
  v11[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_2;
  v11[3] = &unk_2786EFA38;
  v11[4] = *(a1 + 32);
  v12 = v6;
  v9 = v6;
  [v7 readAttributesWithEndpointID:&unk_283EE89B8 clusterID:&unk_283EE7AA0 attributeID:&unk_283EE89E8 params:0 queue:v8 completion:v11];

  v10 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_471(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_469(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v27 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v11;
      v25 = 2112;
      v26 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned WED support information as %@", &v23, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    if ([v5 count])
    {
      v12 = [v5 firstObject];
      v13 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v12];

      [*(a1 + 32) setWedDevice:v13 != 0];
    }

    else
    {
      [*(a1 + 32) setWedDevice:0];
    }

    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      v20 = HMFGetLogIdentifier();
      [*(a1 + 32) isWEDDevice];
      v21 = HMFBooleanToString();
      v23 = 138543618;
      v24 = v20;
      v25 = 2112;
      v26 = v21;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Setting WED support to %@", &v23, 0x16u);
    }

    objc_autoreleasePoolPop(v17);
    (*(*(a1 + 40) + 16))();
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v14 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v14;
      v25 = 2112;
      v26 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve WED support information: %@", &v23, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v15 = *(a1 + 40);
    v16 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
    (*(v15 + 16))(v15, 0, v16);
  }

  v22 = *MEMORY[0x277D85DE8];
}

- (void)handleCommissioneeHasReceivedNetworkCredentials
{
  v15 = *MEMORY[0x277D85DE8];
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    if ([(HMMTRAccessoryServer *)self linkLayerType]== 4)
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      isCurrentDeviceAllowedAccessoryControlDespiteReachableResident = [browser isCurrentDeviceAllowedAccessoryControlDespiteReachableResident];

      if (isCurrentDeviceAllowedAccessoryControlDespiteReachableResident)
      {
        commissioneeHasActiveNetwork = [(HMMTRAccessoryServer *)self commissioneeHasActiveNetwork];
        v6 = objc_autoreleasePoolPush();
        selfCopy = self;
        v8 = HMFGetOSLogHandle();
        v9 = v8;
        if (commissioneeHasActiveNetwork)
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            v10 = HMFGetLogIdentifier();
            v13 = 138543362;
            v14 = v10;
            _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@setupThreadPairingAfterNetworkCredentials - Unexpected state - received commissioneeHasReceivedNetworkCredentials even though accessory was already on-network", &v13, 0xCu);
          }

          objc_autoreleasePoolPop(v6);
        }

        else
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            v11 = HMFGetLogIdentifier();
            v13 = 138543362;
            v14 = v11;
            _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@setupThreadPairingAfterNetworkCredentials - Network credentials sent to accessory", &v13, 0xCu);
          }

          objc_autoreleasePoolPop(v6);
          [(HMMTRAccessoryServer *)selfCopy _setupThreadPairing];
        }
      }
    }
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (void)handleAttestationComplete
{
  v15 = *MEMORY[0x277D85DE8];
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    if ([(HMMTRAccessoryServer *)self linkLayerType]== 4)
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      isCurrentDeviceAllowedAccessoryControlDespiteReachableResident = [browser isCurrentDeviceAllowedAccessoryControlDespiteReachableResident];

      if (isCurrentDeviceAllowedAccessoryControlDespiteReachableResident)
      {
        commissioneeHasActiveNetwork = [(HMMTRAccessoryServer *)self commissioneeHasActiveNetwork];
        v6 = objc_autoreleasePoolPush();
        selfCopy = self;
        v8 = HMFGetOSLogHandle();
        v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
        if (commissioneeHasActiveNetwork)
        {
          if (v9)
          {
            v10 = HMFGetLogIdentifier();
            v13 = 138543362;
            v14 = v10;
            _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@setupThreadPairing - On network commissioning", &v13, 0xCu);
          }

          objc_autoreleasePoolPop(v6);
          [(HMMTRAccessoryServer *)selfCopy _setupThreadPairing];
        }

        else
        {
          if (v9)
          {
            v11 = HMFGetLogIdentifier();
            v13 = 138543362;
            v14 = v11;
            _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@setupThreadPairing - Waiting for accessory to receive network credentials", &v13, 0xCu);
          }

          objc_autoreleasePoolPop(v6);
        }
      }
    }
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (void)_setupThreadPairing
{
  v24 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    eMACAddress = [(HMMTRAccessoryServer *)selfCopy eMACAddress];
    [(HMMTRAccessoryServer *)selfCopy isWEDDevice];
    v8 = HMFBooleanToString();
    *buf = 138543874;
    v19 = v6;
    v20 = 2112;
    v21 = eMACAddress;
    v22 = 2112;
    v23 = v8;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@_setupThreadPairing emac %@, isWED=%@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v3);
  eMACAddress2 = [(HMMTRAccessoryServer *)selfCopy eMACAddress];
  v10 = [eMACAddress2 dataUsingEncoding:4];

  browser = [(HMMTRAccessoryServer *)selfCopy browser];
  threadRadioManager = [browser threadRadioManager];
  isWEDDevice = [(HMMTRAccessoryServer *)selfCopy isWEDDevice];
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __43__HMMTRAccessoryServer__setupThreadPairing__block_invoke;
  v16[3] = &unk_2786EF9E0;
  v16[4] = selfCopy;
  v17 = v10;
  v14 = v10;
  [threadRadioManager startAccessoryPairingWithExtendedMACAddress:v14 isWedDevice:isWEDDevice accessoryServer:selfCopy completion:v16];

  v15 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer__setupThreadPairing__block_invoke(uint64_t a1, void *a2)
{
  v30 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (!v3 && [*(a1 + 32) isWEDDevice] && *(a1 + 40))
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      *buf = 138543362;
      v27 = v7;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Aborting operations to flush the non-WED device state", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    v8 = [*(a1 + 32) browser];
    v9 = *(a1 + 32);
    v10 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:9];
    [v8 abortOperationsForAccessoryServer:v9 reason:v10];

    v11 = objc_autoreleasePoolPush();
    v12 = *(a1 + 32);
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      v15 = *(a1 + 32);
      *buf = 138543618;
      v27 = v14;
      v28 = 2112;
      v29 = v15;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Connecting to WED accessory: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v16 = [*(a1 + 32) browser];
    v17 = [v16 threadRadioManager];
    v18 = *(a1 + 32);
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __43__HMMTRAccessoryServer__setupThreadPairing__block_invoke_466;
    v24[3] = &unk_2786EF9E0;
    v24[4] = v18;
    v25 = *(a1 + 40);
    [v17 connectToWEDAccessory:v18 completion:v24];
  }

  v19 = objc_autoreleasePoolPush();
  v20 = *(a1 + 32);
  v21 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    v22 = HMFGetLogIdentifier();
    *buf = 138543618;
    v27 = v22;
    v28 = 2112;
    v29 = v3;
    _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_INFO, "%{public}@startAccessoryPairingWithExtendedMACAddress completed, error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v19);
  v23 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer__setupThreadPairing__block_invoke_466(uint64_t a1, void *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v8 = *(a1 + 32);
      v9 = *(a1 + 40);
      v11 = 138544130;
      v12 = v7;
      v13 = 2112;
      v14 = v8;
      v15 = 2112;
      v16 = v9;
      v17 = 2112;
      v18 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to establish WED connection to accessory %@ with emac %@, error %@", &v11, 0x2Au);
    }

    objc_autoreleasePoolPop(v4);
  }

  v10 = *MEMORY[0x277D85DE8];
}

- (id)_fetchSupportedThreadFeatures
{
  v32 = *MEMORY[0x277D85DE8];
  matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

  if (matterDevice)
  {
    v4 = +[HMMTRDescriptorClusterManager sharedManager];
    matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
    v6 = [v4 endpointForClusterID:&unk_283EE8BC8 mtrDevice:matterDevice2];

    if (v6)
    {
      v7 = objc_alloc(MEMORY[0x277CD5278]);
      matterDevice3 = [(HMMTRAccessoryServer *)self matterDevice];
      clientQueue = [(HAPAccessoryServer *)self clientQueue];
      v10 = [v7 initWithDevice:matterDevice3 endpointID:v6 queue:clientQueue];

      v11 = objc_alloc_init(MEMORY[0x277CD54D8]);
      v12 = [v10 readAttributeSupportedThreadFeaturesWithParams:v11];

      v13 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReadResultValue:v12 forIdentify:@"supportedThreadFeatures"];
      v14 = v13;
      if (v13)
      {
        v15 = v13;
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          v27 = HMFGetLogIdentifier();
          v30 = 138543362;
          v31 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@SupportedThreadFeatures attribute was nil", &v30, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
      }
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = HMFGetLogIdentifier();
        v30 = 138543362;
        v31 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@No endpoint found to contain Network Commissioning Cluster to fetch SupportedThreadFeatures", &v30, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v14 = 0;
    }
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = HMFGetLogIdentifier();
      v30 = 138543362;
      v31 = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to fetch SupportedThreadFeatures", &v30, 0xCu);
    }

    objc_autoreleasePoolPop(v16);
    v14 = 0;
  }

  v28 = *MEMORY[0x277D85DE8];

  return v14;
}

- (void)readSpecificationVersionWithCompletionHandler:(id)handler
{
  handlerCopy = handler;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __70__HMMTRAccessoryServer_readSpecificationVersionWithCompletionHandler___block_invoke;
  v7[3] = &unk_2786EF5A8;
  v7[4] = self;
  v8 = handlerCopy;
  v6 = handlerCopy;
  dispatch_async(clientQueue, v7);
}

void __70__HMMTRAccessoryServer_readSpecificationVersionWithCompletionHandler___block_invoke(uint64_t a1)
{
  v27 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];
  if (v2 && (v3 = v2, v4 = [*(a1 + 32) isReadyToReadFromMTRDevice], v3, (v4 & 1) != 0))
  {
    v5 = objc_alloc(MEMORY[0x277CD5248]);
    v6 = [*(a1 + 32) matterDevice];
    v7 = [*(a1 + 32) clientQueue];
    v8 = [v5 initWithDevice:v6 endpointID:&unk_283EE89B8 queue:v7];

    v9 = objc_alloc_init(MEMORY[0x277CD54D8]);
    v10 = [v8 readAttributeSpecificationVersionWithParams:v9];

    v11 = objc_autoreleasePoolPush();
    v12 = *(a1 + 32);
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      v23 = 138543618;
      v24 = v14;
      v25 = 2112;
      v26 = v10;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Fetched specification number version data: %@", &v23, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v15 = *(a1 + 40);
    if (v10)
    {
      v16 = [v10 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
      (*(v15 + 16))(v15, v16, 0);
    }

    else
    {
      v16 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
      (*(v15 + 16))(v15, 0, v16);
    }
  }

  else
  {
    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      v23 = 138543362;
      v24 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to read specification version", &v23, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    v21 = *(a1 + 40);
    v8 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
    (*(v21 + 16))(v21, 0, v8);
  }

  v22 = *MEMORY[0x277D85DE8];
}

- (double)handleBusyImageResponseCounter
{
  v15 = *MEMORY[0x277D85DE8];
  v3 = exp2([(HMMTRAccessoryServer *)self busyImageResponseCounter]) * 120.0;
  v4 = objc_autoreleasePoolPush();
  selfCopy = self;
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v11 = 138543618;
    v12 = v7;
    v13 = 2048;
    v14 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Updating delay with exponential backoff to %.0f seconds", &v11, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  [(HMMTRAccessoryServer *)selfCopy setBusyImageResponseCounter:[(HMMTRAccessoryServer *)selfCopy busyImageResponseCounter]+ 1];
  notAvailableImageResponseCounter = [(HMMTRAccessoryServer *)selfCopy notAvailableImageResponseCounter];
  [notAvailableImageResponseCounter resetTimeBasedCounter];

  v9 = *MEMORY[0x277D85DE8];
  return v3;
}

- (BOOL)handleNotAvailableImageResponseCounter
{
  [(HMMTRAccessoryServer *)self setBusyImageResponseCounter:0];
  notAvailableImageResponseCounter = [(HMMTRAccessoryServer *)self notAvailableImageResponseCounter];
  incrementOrReset = [notAvailableImageResponseCounter incrementOrReset];

  return incrementOrReset;
}

- (void)resetNonAvailableCounters
{
  notAvailableImageResponseCounter = [(HMMTRAccessoryServer *)self notAvailableImageResponseCounter];
  [notAvailableImageResponseCounter resetTimeBasedCounter];

  [(HMMTRAccessoryServer *)self setBusyImageResponseCounter:0];
}

- (void)fetchSoftwareVersion:(BOOL)version completionHandler:(id)handler
{
  handlerCopy = handler;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer_fetchSoftwareVersion_completionHandler___block_invoke;
  block[3] = &unk_2786EF9B8;
  block[4] = self;
  v10 = handlerCopy;
  versionCopy = version;
  v8 = handlerCopy;
  dispatch_async(clientQueue, block);
}

void __63__HMMTRAccessoryServer_fetchSoftwareVersion_completionHandler___block_invoke(uint64_t a1)
{
  v25 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) matterDevice];

  if (v2)
  {
    v3 = objc_alloc(MEMORY[0x277CD5248]);
    v4 = [*(a1 + 32) matterDevice];
    v5 = [*(a1 + 32) clientQueue];
    v6 = [v3 initWithDevice:v4 endpointID:&unk_283EE89B8 queue:v5];

    LODWORD(v4) = *(a1 + 48);
    v7 = objc_alloc_init(MEMORY[0x277CD54D8]);
    if (v4 == 1)
    {
      [v6 readAttributeSoftwareVersionWithParams:v7];
    }

    else
    {
      [v6 readAttributeSoftwareVersionStringWithParams:v7];
    }
    v13 = ;

    v14 = objc_autoreleasePoolPush();
    v15 = *(a1 + 32);
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      v21 = 138543618;
      v22 = v17;
      v23 = 2112;
      v24 = v13;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Fetched software version data: %@", &v21, 0x16u);
    }

    objc_autoreleasePoolPop(v14);
    v18 = *(a1 + 40);
    if (v13)
    {
      v19 = [v13 objectForKeyedSubscript:*MEMORY[0x277CD51A0]];
      (*(v18 + 16))(v18, v19, 0);
    }

    else
    {
      v19 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
      (*(v18 + 16))(v18, 0, v19);
    }
  }

  else
  {
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      v21 = 138543362;
      v22 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to fetch software version", &v21, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    v12 = *(a1 + 40);
    v6 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:8];
    (*(v12 + 16))(v12, 0, v6);
  }

  v20 = *MEMORY[0x277D85DE8];
}

- (void)_fetchSerialNumberWithCompletionHandler:(id)handler
{
  v25 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v22 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching serial number.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    v9 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    handlerCopy[2](handlerCopy, v9);
  }

  else
  {
    v10 = random();
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543618;
      v22 = v14;
      v23 = 2048;
      v24 = v10;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke;
    v18[3] = &unk_2786EFF18;
    v18[4] = selfCopy2;
    v20 = v10;
    v19 = handlerCopy;
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_458;
    v16[3] = &unk_2786F0BC0;
    v17 = v19;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v18 highPriority:0 completion:v16];
  }

  v15 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_454;
  block[3] = &unk_2786F0EA8;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_457;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_458(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_454(id *a1)
{
  v32 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = a1[4];
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v31 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching serial number", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v27[0] = MEMORY[0x277D85DD0];
  v27[1] = 3221225472;
  v27[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_455;
  v27[3] = &unk_2786EF8A0;
  v29 = a1[6];
  v28 = a1[5];
  v6 = MEMORY[0x2318887D0](v27);
  v7 = [a1[4] deviceController];
  if (v7)
  {
    v8 = a1[4];
    v9 = [v8 nodeID];
    v10 = [v8 mtrBaseDeviceWithNodeID:v9 controller:v7];

    if (v10)
    {
      v11 = [a1[4] clientQueue];
      v23[0] = MEMORY[0x277D85DD0];
      v23[1] = 3221225472;
      v23[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_2;
      v23[3] = &unk_2786EF990;
      v23[4] = a1[4];
      v24 = v6;
      [v10 fetchSerialNumberWithCallbackQueue:v11 completionHandler:v23];
    }

    else
    {
      v17 = objc_autoreleasePoolPush();
      v18 = a1[4];
      v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v20 = HMFGetLogIdentifier();
        *buf = 138543362;
        v31 = v20;
        _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch serial number because of no device", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v17);
      v21 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      (v6)[2](v6, v21);

      v10 = 0;
    }
  }

  else
  {
    v12 = objc_autoreleasePoolPush();
    v13 = a1[4];
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543362;
      v31 = v15;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch serial number", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v12);
    v16 = [a1[4] clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_456;
    block[3] = &unk_2786EF878;
    v26 = v6;
    dispatch_async(v16, block);

    v10 = v26;
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_457(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_455(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_456(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, v2);
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  v21 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      v17 = 138543618;
      v18 = v11;
      v19 = 2112;
      v20 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned Serial Number as %@", &v17, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v12 = [*(a1 + 32) primaryAccessory];
    [v12 setSerialNumber:v5];

    (*(*(a1 + 40) + 16))();
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v13 = HMFGetLogIdentifier();
      v17 = 138543618;
      v18 = v13;
      v19 = 2112;
      v20 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve serial number: %@", &v17, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v14 = *(a1 + 40);
    if (v6)
    {
      (*(v14 + 16))(v14, v6);
    }

    else
    {
      v15 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:2];
      (*(v14 + 16))(v14, v15);
    }
  }

  v16 = *MEMORY[0x277D85DE8];
}

- (void)_fetchCurrentPairingWithCompletionHandler:(id)handler
{
  v25 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v22 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching current pairing.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    v9 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    (*(handlerCopy + 2))(handlerCopy, 0, v9, 0);
  }

  else
  {
    v10 = random();
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543618;
      v22 = v14;
      v23 = 2048;
      v24 = v10;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke;
    v18[3] = &unk_2786EFF18;
    v18[4] = selfCopy2;
    v20 = v10;
    v19 = handlerCopy;
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_453;
    v16[3] = &unk_2786F0BC0;
    v17 = v19;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v18 highPriority:0 completion:v16];
  }

  v15 = *MEMORY[0x277D85DE8];
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_449;
  block[3] = &unk_2786F0EA8;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_452;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_453(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_449(id *a1)
{
  v34 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = a1[4];
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v33 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching current pairing", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v29[0] = MEMORY[0x277D85DD0];
  v29[1] = 3221225472;
  v29[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_450;
  v29[3] = &unk_2786EF968;
  v31 = a1[6];
  v30 = a1[5];
  v6 = MEMORY[0x2318887D0](v29);
  v7 = [a1[4] deviceController];
  if (v7)
  {
    v8 = a1[4];
    v9 = [v8 nodeID];
    v10 = [v8 mtrBaseDeviceWithNodeID:v9 controller:v7];

    if (v10)
    {
      v11 = [a1[4] clientQueue];
      v12 = [a1[4] browser];
      v13 = [v12 vendorMetadataStore];
      v25[0] = MEMORY[0x277D85DD0];
      v25[1] = 3221225472;
      v25[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_2;
      v25[3] = &unk_2786EF968;
      v25[4] = a1[4];
      v26 = v6;
      [v10 fetchCurrentPairingWithCallbackQueue:v11 vendorMetadataStore:v13 completionHandler:v25];
    }

    else
    {
      v19 = objc_autoreleasePoolPush();
      v20 = a1[4];
      v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        v22 = HMFGetLogIdentifier();
        *buf = 138543362;
        v33 = v22;
        _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch current pairing because of no device", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v19);
      v23 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      (v6)[2](v6, 0, v23, 0);

      v10 = 0;
    }
  }

  else
  {
    v14 = objc_autoreleasePoolPush();
    v15 = a1[4];
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = HMFGetLogIdentifier();
      *buf = 138543362;
      v33 = v17;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch current pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v14);
    v18 = [a1[4] clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_451;
    block[3] = &unk_2786EF878;
    v28 = v6;
    dispatch_async(v18, block);

    v10 = v28;
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_452(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_450(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_451(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, 0, v2, 0);
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3, void *a4)
{
  v23 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = objc_autoreleasePoolPush();
  v11 = *(a1 + 32);
  v12 = HMFGetOSLogHandle();
  v13 = v12;
  if (v7)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      v19 = 138543618;
      v20 = v14;
      v21 = 2112;
      v22 = v7;
      v15 = "%{public}@Successfully retrieved pairing: %@";
      v16 = v13;
      v17 = OS_LOG_TYPE_INFO;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v16, v17, v15, &v19, 0x16u);
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v14 = HMFGetLogIdentifier();
    v19 = 138543618;
    v20 = v14;
    v21 = 2112;
    v22 = v8;
    v15 = "%{public}@Failed to retrieve pairing: %@";
    v16 = v13;
    v17 = OS_LOG_TYPE_ERROR;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v10);
  (*(*(a1 + 40) + 16))(*(a1 + 40), v7, v8, 0);

  v18 = *MEMORY[0x277D85DE8];
}

- (void)fetchLastKnownPairingsWithCompletionHandler:(id)handler
{
  v36 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v33 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching pairings.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v31 = handlerCopy;
    v10 = handlerCopy;
    dispatch_async(clientQueue, block);

    v11 = v31;
  }

  else
  {
    v12 = random();
    v13 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      *buf = 138543618;
      v33 = v16;
      v34 = 2048;
      v35 = v12;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings without connection job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v13);
    v17 = objc_autoreleasePoolPush();
    v18 = selfCopy2;
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543618;
      v33 = v20;
      v34 = 2048;
      v35 = v12;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings without connection job(%lu) started.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v17);
    v21 = dispatch_group_create();
    dispatch_group_enter(v21);
    clientQueue2 = [(HAPAccessoryServer *)v18 clientQueue];
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_443;
    v27[3] = &unk_2786F0EA8;
    v28 = v21;
    v29 = handlerCopy;
    v27[4] = v18;
    v11 = v21;
    v23 = handlerCopy;
    dispatch_async(clientQueue2, v27);

    clientQueue3 = [(HAPAccessoryServer *)v18 clientQueue];
    v26[0] = MEMORY[0x277D85DD0];
    v26[1] = 3221225472;
    v26[2] = __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_448;
    v26[3] = &unk_2786EF620;
    v26[4] = v18;
    v26[5] = v12;
    dispatch_group_notify(v11, clientQueue3, v26);
  }

  v25 = *MEMORY[0x277D85DE8];
}

void __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke(uint64_t a1)
{
  v3 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  v2 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(*(a1 + 32) + 16))();
}

void __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_443(id *a1)
{
  v43 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = a1[4];
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v40 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching pairings from MTRDevice", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v36[0] = MEMORY[0x277D85DD0];
  v36[1] = 3221225472;
  v36[2] = __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_444;
  v36[3] = &unk_2786EF968;
  v38 = a1[6];
  v37 = a1[5];
  v6 = MEMORY[0x2318887D0](v36);
  v7 = [a1[4] matterDevice];

  if (v7)
  {
    v8 = objc_alloc(MEMORY[0x277CD5280]);
    v9 = [a1[4] matterDevice];
    v10 = [a1[4] clientQueue];
    v11 = [v8 initWithDevice:v9 endpointID:&unk_283EE89B8 queue:v10];

    if (v11)
    {
      v12 = objc_alloc_init(MEMORY[0x277CD54D8]);
      v13 = [v11 readAttributeFabricsWithParams:v12];

      v14 = [a1[4] browser];
      v15 = [v14 vendorMetadataStore];
      v16 = [HMMTRUtilities hmmtrPairingsFromMTRClusterReadValue:v13 vendorMetadataStore:v15];

      v17 = objc_autoreleasePoolPush();
      v18 = a1[4];
      v19 = HMFGetOSLogHandle();
      v20 = v19;
      if (v16)
      {
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          v21 = HMFGetLogIdentifier();
          *buf = 138543618;
          v40 = v21;
          v41 = 2112;
          v42 = v16;
          v22 = "%{public}@Successfully retrieved pairings from MTRDevice: %@";
          v23 = v20;
          v24 = OS_LOG_TYPE_INFO;
          v25 = 22;
LABEL_13:
          _os_log_impl(&dword_22AEAE000, v23, v24, v22, buf, v25);
        }
      }

      else if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543362;
        v40 = v21;
        v22 = "%{public}@Failed to retrieve pairings from MTRDevice";
        v23 = v20;
        v24 = OS_LOG_TYPE_ERROR;
        v25 = 12;
        goto LABEL_13;
      }

      objc_autoreleasePoolPop(v17);
      v31 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      v32 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v31];
      (v6)[2](v6, v16, v31, v32);
    }
  }

  else
  {
    v26 = objc_autoreleasePoolPush();
    v27 = a1[4];
    v28 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      v29 = HMFGetLogIdentifier();
      *buf = 138543362;
      v40 = v29;
      _os_log_impl(&dword_22AEAE000, v28, OS_LOG_TYPE_ERROR, "%{public}@No MTRDevice available to fetch pairings", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v26);
    v30 = [a1[4] clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_445;
    block[3] = &unk_2786EF878;
    v35 = v6;
    dispatch_async(v30, block);

    v11 = v35;
  }

  v33 = *MEMORY[0x277D85DE8];
}

void __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_448(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings without connection job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_444(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __68__HMMTRAccessoryServer_fetchLastKnownPairingsWithCompletionHandler___block_invoke_445(uint64_t a1)
{
  v3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  v2 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(*(a1 + 32) + 16))();
}

- (void)fetchPairingsWithCompletionHandler:(id)handler
{
  v28 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v25 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching pairings.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v23 = handlerCopy;
    dispatch_async(clientQueue, block);

    v10 = v23;
  }

  else
  {
    v11 = random();
    v12 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v25 = v15;
      v26 = 2048;
      v27 = v11;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v12);
    v19[0] = MEMORY[0x277D85DD0];
    v19[1] = 3221225472;
    v19[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_436;
    v19[3] = &unk_2786EFF18;
    v19[4] = selfCopy2;
    v21 = v11;
    v20 = handlerCopy;
    v17[0] = MEMORY[0x277D85DD0];
    v17[1] = 3221225472;
    v17[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_442;
    v17[3] = &unk_2786F0BC0;
    v18 = v20;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v19 highPriority:0 completion:v17];

    v10 = v20;
  }

  v16 = *MEMORY[0x277D85DE8];
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke(uint64_t a1)
{
  v3 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  v2 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(*(a1 + 32) + 16))();
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_436(uint64_t a1)
{
  v22 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_437;
  block[3] = &unk_2786F0EA8;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_441;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_442(uint64_t a1, void *a2)
{
  if (a2)
  {
    v3 = a2;
    v4 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
    (*(*(a1 + 32) + 16))();
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_437(id *a1)
{
  v35 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = a1[4];
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v34 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching pairings", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v30[0] = MEMORY[0x277D85DD0];
  v30[1] = 3221225472;
  v30[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_438;
  v30[3] = &unk_2786EF968;
  v32 = a1[6];
  v31 = a1[5];
  v6 = MEMORY[0x2318887D0](v30);
  v7 = [a1[4] deviceController];
  if (v7)
  {
    v8 = a1[4];
    v9 = [v8 nodeID];
    v10 = [v8 mtrBaseDeviceWithNodeID:v9 controller:v7];

    if (v10)
    {
      v11 = [a1[4] clientQueue];
      v12 = [a1[4] browser];
      v13 = [v12 vendorMetadataStore];
      v26[0] = MEMORY[0x277D85DD0];
      v26[1] = 3221225472;
      v26[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_2;
      v26[3] = &unk_2786EF968;
      v26[4] = a1[4];
      v27 = v6;
      [v10 fetchPairingsWithCallbackQueue:v11 vendorMetadataStore:v13 completionHandler:v26];
    }

    else
    {
      v19 = objc_autoreleasePoolPush();
      v20 = a1[4];
      v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        v22 = HMFGetLogIdentifier();
        *buf = 138543362;
        v34 = v22;
        _os_log_impl(&dword_22AEAE000, v21, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch pairings because of no device", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v19);
      v23 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      v24 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:10 error:v23];
      (v6)[2](v6, 0, v23, v24);

      v10 = 0;
    }
  }

  else
  {
    v14 = objc_autoreleasePoolPush();
    v15 = a1[4];
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v17;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch pairings", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v14);
    v18 = [a1[4] clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_440;
    block[3] = &unk_2786EF878;
    v29 = v6;
    dispatch_async(v18, block);

    v10 = v29;
  }

  v25 = *MEMORY[0x277D85DE8];
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_441(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_438(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_440(uint64_t a1)
{
  v3 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  v2 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(*(a1 + 32) + 16))();
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3, void *a4)
{
  v23 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = objc_autoreleasePoolPush();
  v11 = *(a1 + 32);
  v12 = HMFGetOSLogHandle();
  v13 = v12;
  if (v7)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      v19 = 138543618;
      v20 = v14;
      v21 = 2112;
      v22 = v7;
      v15 = "%{public}@Successfully retrieved pairings: %@";
      v16 = v13;
      v17 = OS_LOG_TYPE_INFO;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v16, v17, v15, &v19, 0x16u);
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v14 = HMFGetLogIdentifier();
    v19 = 138543618;
    v20 = v14;
    v21 = 2112;
    v22 = v8;
    v15 = "%{public}@Failed to retrieve pairings: %@";
    v16 = v13;
    v17 = OS_LOG_TYPE_ERROR;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v10);
  (*(*(a1 + 40) + 16))(*(a1 + 40), v7, v8, v9);

  v18 = *MEMORY[0x277D85DE8];
}

- (void)updateAccessoryName:(id)name
{
  v51 = *MEMORY[0x277D85DE8];
  nameCopy = name;
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543618;
    v48 = v8;
    v49 = 2112;
    v50 = nameCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating accessory name to: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  [(HAPAccessoryServer *)selfCopy setName:nameCopy];
  primaryAccessory = [(HMMTRAccessoryServer *)selfCopy primaryAccessory];
  [primaryAccessory setName:nameCopy];

  v36 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  primaryAccessory2 = [(HMMTRAccessoryServer *)selfCopy primaryAccessory];
  services = [primaryAccessory2 services];

  v12 = [services countByEnumeratingWithState:&v41 objects:v46 count:16];
  if (v12)
  {
    v13 = v12;
    v14 = *v42;
    while (2)
    {
      for (i = 0; i != v13; ++i)
      {
        if (*v42 != v14)
        {
          objc_enumerationMutation(services);
        }

        v16 = *(*(&v41 + 1) + 8 * i);
        type = [v16 type];
        v18 = [type isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v18)
        {
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          characteristics = [v16 characteristics];
          v20 = [characteristics countByEnumeratingWithState:&v37 objects:v45 count:16];
          if (v20)
          {
            v21 = v20;
            v22 = *v38;
            v35 = nameCopy;
            while (2)
            {
              for (j = 0; j != v21; ++j)
              {
                if (*v38 != v22)
                {
                  objc_enumerationMutation(characteristics);
                }

                v24 = *(*(&v37 + 1) + 8 * j);
                type2 = [v24 type];
                v26 = [type2 isEqualToString:@"00000023-0000-1000-8000-0026BB765291"];

                if (v26)
                {
                  v27 = [v24 copy];
                  service = [v24 service];
                  [v27 setService:service];

                  nameCopy = v35;
                  [v27 setValue:v35];
                  v29 = objc_autoreleasePoolPush();
                  v30 = selfCopy;
                  v31 = HMFGetOSLogHandle();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
                  {
                    v32 = HMFGetLogIdentifier();
                    *buf = 138543618;
                    v48 = v32;
                    v49 = 2112;
                    v50 = v27;
                    _os_log_impl(&dword_22AEAE000, v31, OS_LOG_TYPE_INFO, "%{public}@Notification: Updated characteristic: %@", buf, 0x16u);
                  }

                  objc_autoreleasePoolPop(v29);
                  [v36 addObject:v27];

                  goto LABEL_24;
                }
              }

              v21 = [characteristics countByEnumeratingWithState:&v37 objects:v45 count:16];
              nameCopy = v35;
              if (v21)
              {
                continue;
              }

              break;
            }
          }

LABEL_24:

          goto LABEL_25;
        }
      }

      v13 = [services countByEnumeratingWithState:&v41 objects:v46 count:16];
      if (v13)
      {
        continue;
      }

      break;
    }
  }

LABEL_25:

  delegate = [(HAPAccessoryServer *)selfCopy delegate];
  [delegate accessoryServer:selfCopy didUpdateValuesForCharacteristics:v36 stateNumber:0 broadcast:0];

  v34 = *MEMORY[0x277D85DE8];
}

- (void)updateFabricLabel:(id)label completionHandler:(id)handler
{
  v39 = *MEMORY[0x277D85DE8];
  labelCopy = label;
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v36 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fabric label update.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v34 = handlerCopy;
    dispatch_async(clientQueue, block);

    v13 = v34;
  }

  else
  {
    v14 = random();
    v15 = [MEMORY[0x277CBEB18] arrayWithCapacity:1];
    v16 = *MEMORY[0x277CFECD8];
    os_unfair_lock_lock_with_options();
    lastPendingFabricLabel = [(HMMTRAccessoryServer *)self lastPendingFabricLabel];
    firstObject = [lastPendingFabricLabel firstObject];
    v19 = [firstObject isEqual:labelCopy];

    if ((v19 & 1) == 0)
    {
      [v15 addObject:labelCopy];
      [(HMMTRAccessoryServer *)self setLastPendingFabricLabel:v15];
    }

    os_unfair_lock_unlock((self + v16));
    v20 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      *buf = 138543618;
      v36 = v23;
      v37 = 2048;
      v38 = v14;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v20);
    v27[0] = MEMORY[0x277D85DD0];
    v27[1] = 3221225472;
    v27[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_430;
    v27[3] = &unk_2786EF940;
    v27[4] = selfCopy2;
    v31 = v14;
    v28 = labelCopy;
    v32 = v19;
    v29 = v15;
    v30 = handlerCopy;
    v25[0] = MEMORY[0x277D85DD0];
    v25[1] = 3221225472;
    v25[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_435;
    v25[3] = &unk_2786F0BC0;
    v26 = v30;
    v13 = v15;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v27 highPriority:0 completion:v25];
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, v2);
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_430(uint64_t a1)
{
  v29 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 64);
    *buf = 138543618;
    v26 = v5;
    v27 = 2048;
    v28 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_431;
  block[3] = &unk_2786EF8F0;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v21 = v9;
  v10 = *(a1 + 56);
  v22 = v7;
  v23 = v10;
  v24 = *(a1 + 72);
  v11 = v7;
  dispatch_async(v8, block);

  v12 = [*(a1 + 32) clientQueue];
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_434;
  v16[3] = &unk_2786EF918;
  v13 = *(a1 + 48);
  v14 = *(a1 + 32);
  v17 = v13;
  v18 = v14;
  v19 = *(a1 + 64);
  dispatch_group_notify(v11, v12, v16);

  v15 = *MEMORY[0x277D85DE8];
}

uint64_t __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_435(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_431(uint64_t a1)
{
  v42 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    *buf = 138543618;
    v39 = v5;
    v40 = 2112;
    v41 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to update fabric label to %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v35[0] = MEMORY[0x277D85DD0];
  v35[1] = 3221225472;
  v35[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_432;
  v35[3] = &unk_2786EF8A0;
  v37 = *(a1 + 56);
  v36 = *(a1 + 48);
  v7 = MEMORY[0x2318887D0](v35);
  if (*(a1 + 64) == 1)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = *(a1 + 32);
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v39 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Update fabric label job is redundant - do nothing.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    v12 = [*(a1 + 32) lastFabricLabelUpdateError];
    (v7)[2](v7, v12);
  }

  else
  {
    v12 = [*(a1 + 32) deviceController];
    if (v12)
    {
      v13 = *(a1 + 32);
      v14 = [v13 nodeID];
      v15 = [v13 mtrBaseDeviceWithNodeID:v14 controller:v12];

      v16 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      [*(a1 + 32) setLastFabricLabelUpdateError:v16];
      if (v15)
      {
        v17 = *(a1 + 40);
        v18 = [*(a1 + 32) clientQueue];
        v31[0] = MEMORY[0x277D85DD0];
        v31[1] = 3221225472;
        v31[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_433;
        v31[3] = &unk_2786EF8C8;
        v19 = *(a1 + 40);
        v31[4] = *(a1 + 32);
        v32 = v19;
        v34 = v7;
        v33 = v16;
        [v15 updateFabricLabel:v17 callbackQueue:v18 completionHandler:v31];
      }

      else
      {
        v25 = objc_autoreleasePoolPush();
        v26 = *(a1 + 32);
        v27 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          v28 = HMFGetLogIdentifier();
          v29 = *(a1 + 40);
          *buf = 138543618;
          v39 = v28;
          v40 = 2112;
          v41 = v29;
          _os_log_impl(&dword_22AEAE000, v27, OS_LOG_TYPE_ERROR, "%{public}@Could not update fabric label to %@ because of no device", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v25);
        (v7)[2](v7, v16);
      }
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      v21 = *(a1 + 32);
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = HMFGetLogIdentifier();
        *buf = 138543362;
        v39 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller to update fabric label job", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v24 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
      [*(a1 + 32) setLastFabricLabelUpdateError:v24];

      v15 = [*(a1 + 32) lastFabricLabelUpdateError];
      (v7)[2](v7, v15);
    }
  }

  v30 = *MEMORY[0x277D85DE8];
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_434(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  [*(a1 + 32) removeAllObjects];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 40);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_432(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_433(uint64_t a1, void *a2)
{
  v24 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v9 = *(a1 + 40);
      v18 = 138543874;
      v19 = v8;
      v20 = 2112;
      v21 = v9;
      v22 = 2112;
      v23 = v3;
      v10 = "%{public}@Failed to update fabric label to %@ with error %@";
      v11 = v7;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 32;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v11, v12, v10, &v18, v13);
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v14 = *(a1 + 40);
    v18 = 138543618;
    v19 = v8;
    v20 = 2112;
    v21 = v14;
    v10 = "%{public}@Successfully updated fabric label %@";
    v11 = v7;
    v12 = OS_LOG_TYPE_INFO;
    v13 = 22;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v4);
  (*(*(a1 + 56) + 16))(*(a1 + 56), *(a1 + 48), v15, v16);

  v17 = *MEMORY[0x277D85DE8];
}

- (void)removePairing:(id)pairing completionHandler:(id)handler
{
  v32 = *MEMORY[0x277D85DE8];
  pairingCopy = pairing;
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting remove-pairing.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke;
    block[3] = &unk_2786EF878;
    v27 = handlerCopy;
    dispatch_async(clientQueue, block);

    v13 = v27;
  }

  else
  {
    v14 = random();
    v15 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v29 = v18;
      v30 = 2048;
      v31 = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    v22[0] = MEMORY[0x277D85DD0];
    v22[1] = 3221225472;
    v22[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_424;
    v22[3] = &unk_2786EF850;
    v22[4] = selfCopy2;
    v25 = v14;
    v23 = pairingCopy;
    v24 = handlerCopy;
    v20[0] = MEMORY[0x277D85DD0];
    v20[1] = 3221225472;
    v20[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_429;
    v20[3] = &unk_2786F0BC0;
    v21 = v24;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v22 highPriority:0 completion:v20];

    v13 = v23;
  }

  v19 = *MEMORY[0x277D85DE8];
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v1 + 16))(v1, v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_424(uint64_t a1)
{
  v24 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 56);
    *buf = 138543618;
    v21 = v5;
    v22 = 2048;
    v23 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_425;
  block[3] = &unk_2786EFA60;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v17 = v9;
  v10 = *(a1 + 48);
  v18 = v7;
  v19 = v10;
  v11 = v7;
  dispatch_async(v8, block);

  v12 = [*(a1 + 32) clientQueue];
  v15[0] = MEMORY[0x277D85DD0];
  v15[1] = 3221225472;
  v15[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_428;
  v15[3] = &unk_2786EF620;
  v13 = *(a1 + 56);
  v15[4] = *(a1 + 32);
  v15[5] = v13;
  dispatch_group_notify(v11, v12, v15);

  v14 = *MEMORY[0x277D85DE8];
}

uint64_t __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_429(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_425(uint64_t a1)
{
  v41 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    *buf = 138543618;
    v38 = v5;
    v39 = 2112;
    v40 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Removing pairing: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v34[0] = MEMORY[0x277D85DD0];
  v34[1] = 3221225472;
  v34[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_426;
  v34[3] = &unk_2786EF8A0;
  v36 = *(a1 + 56);
  v35 = *(a1 + 48);
  v7 = MEMORY[0x2318887D0](v34);
  v8 = [*(a1 + 32) deviceController];
  if (v8)
  {
    v9 = *(a1 + 32);
    v10 = [v9 nodeID];
    v11 = [v9 mtrBaseDeviceWithNodeID:v10 controller:v8];

    if (v11)
    {
      v12 = *(a1 + 40);
      v13 = [*(a1 + 32) clientQueue];
      v14 = [*(a1 + 32) browser];
      v15 = [v14 vendorMetadataStore];
      v29[0] = MEMORY[0x277D85DD0];
      v29[1] = 3221225472;
      v29[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_2;
      v29[3] = &unk_2786F0C10;
      v16 = *(a1 + 40);
      v29[4] = *(a1 + 32);
      v30 = v16;
      v31 = v7;
      [v11 removePairing:v12 callbackQueue:v13 vendorMetadataStore:v15 completionHandler:v29];
    }

    else
    {
      v22 = objc_autoreleasePoolPush();
      v23 = *(a1 + 32);
      v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v25 = HMFGetLogIdentifier();
        v26 = *(a1 + 40);
        *buf = 138543618;
        v38 = v25;
        v39 = 2112;
        v40 = v26;
        _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_ERROR, "%{public}@Could not remove pairing %@ because of no device", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v22);
      v27 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      (v7)[2](v7, v27);

      v11 = 0;
    }
  }

  else
  {
    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      v38 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to remove pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    v21 = [*(a1 + 32) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_427;
    block[3] = &unk_2786EF878;
    v33 = v7;
    dispatch_async(v21, block);

    v11 = v33;
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_428(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_426(uint64_t a1)
{
  (*(*(a1 + 40) + 16))();
  v2 = *(a1 + 32);

  dispatch_group_leave(v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_427(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  (*(v1 + 16))(v1, v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  v24 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      v9 = *(a1 + 40);
      v18 = 138543874;
      v19 = v8;
      v20 = 2112;
      v21 = v9;
      v22 = 2112;
      v23 = v3;
      v10 = "%{public}@Failed to remove CHIP pairing %@: %@";
      v11 = v7;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 32;
LABEL_6:
      _os_log_impl(&dword_22AEAE000, v11, v12, v10, &v18, v13);
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v14 = *(a1 + 40);
    v18 = 138543618;
    v19 = v8;
    v20 = 2112;
    v21 = v14;
    v10 = "%{public}@Successfully removed CHIP pairing: %@";
    v11 = v7;
    v12 = OS_LOG_TYPE_INFO;
    v13 = 22;
    goto LABEL_6;
  }

  objc_autoreleasePoolPop(v4);
  (*(*(a1 + 48) + 16))(*(a1 + 48), v3, v15, v16);

  v17 = *MEMORY[0x277D85DE8];
}

- (void)readPairingWindowStatusWithCompletionHandler:(id)handler
{
  v25 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v5 = objc_autoreleasePoolPush();
    selfCopy = self;
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v22 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting reading pairing window status.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    v9 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    handlerCopy[2](handlerCopy, 0, v9);
  }

  else
  {
    v10 = random();
    v11 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543618;
      v22 = v14;
      v23 = 2048;
      v24 = v10;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v11);
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke;
    v18[3] = &unk_2786EFF18;
    v18[4] = selfCopy2;
    v20 = v10;
    v19 = handlerCopy;
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_423;
    v16[3] = &unk_2786F0BC0;
    v17 = v19;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v18 highPriority:0 completion:v16];
  }

  v15 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke(uint64_t a1)
{
  v23 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v20 = v5;
    v21 = 2048;
    v22 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_416;
  block[3] = &unk_2786EF850;
  v9 = *(a1 + 40);
  v18 = *(a1 + 48);
  block[4] = *(a1 + 32);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_422;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_423(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_416(uint64_t a1)
{
  v30 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) controllerWrapper];
  v3 = [v2 controller];

  if (v3)
  {
    v4 = *(a1 + 32);
    v5 = [v4 nodeID];
    v6 = [v4 mtrBaseDeviceWithNodeID:v5 controller:v3];

    if (v6)
    {
      v7 = objc_alloc(MEMORY[0x277CD51E0]);
      v8 = [*(a1 + 32) clientQueue];
      v9 = [v7 initWithDevice:v6 endpointID:&unk_283EE89B8 queue:v8];

      if (!v9)
      {
        _HMFPreconditionFailure();
      }

      v23[0] = MEMORY[0x277D85DD0];
      v23[1] = 3221225472;
      v23[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_421;
      v23[3] = &unk_2786F0F20;
      v23[4] = *(a1 + 32);
      v25 = *(a1 + 48);
      v24 = *(a1 + 40);
      [v9 readAttributeWindowStatusWithCompletion:v23];
    }

    else
    {
      v15 = objc_autoreleasePoolPush();
      v16 = *(a1 + 32);
      v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = HMFGetLogIdentifier();
        v19 = [*(a1 + 32) nodeID];
        *buf = 138543618;
        v27 = v18;
        v28 = 2112;
        v29 = v19;
        _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@Failed get a device to read pairing window status for node %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v15);
      v20 = *(a1 + 48);
      v21 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:1 userInfo:0];
      (*(v20 + 16))(v20, 0, v21);

      dispatch_group_leave(*(a1 + 40));
    }
  }

  else
  {
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = HMFGetLogIdentifier();
      v14 = *(a1 + 56);
      *buf = 138543618;
      v27 = v13;
      v28 = 2048;
      v29 = v14;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_ERROR, "%{public}@No device controller to execute read pairing window status job(%lu)", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v10);
    dispatch_group_leave(*(a1 + 40));
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_422(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_421(uint64_t a1, void *a2, void *a3)
{
  v16 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Reading AdministratorCommissioning cluster window status attribute failed: %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  (*(*(a1 + 48) + 16))();
  dispatch_group_leave(*(a1 + 40));

  v11 = *MEMORY[0x277D85DE8];
}

- (void)_queueOpenPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler
{
  v24 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  v7 = random();
  v8 = objc_autoreleasePoolPush();
  selfCopy = self;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    *buf = 138543618;
    v21 = v11;
    v22 = 2048;
    v23 = v7;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) queued.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v8);
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke;
  v16[3] = &unk_2786EF7D8;
  v16[4] = selfCopy;
  v18 = v7;
  durationCopy = duration;
  v17 = handlerCopy;
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_415;
  v14[3] = &unk_2786F0BC0;
  v15 = v17;
  v12 = v17;
  [(HMMTRAccessoryServer *)selfCopy queueAccessoryOperation:v16 highPriority:1 completion:v14];

  v13 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke(uint64_t a1)
{
  v23 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v20 = v5;
    v21 = 2048;
    v22 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  [*(a1 + 32) _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindowWithPasscode"];
  [*(a1 + 32) _notifyDelegateOfPairingProgress:24];
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_410;
  block[3] = &unk_2786EF850;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v18 = *(a1 + 56);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_414;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_415(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_410(uint64_t a1)
{
  v35 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 56)];
    *buf = 138543618;
    v32 = v5;
    v33 = 2112;
    v34 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to open the pairing window with PIN for a duration of %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = [MEMORY[0x277CD5528] generateRandomSetupPasscode];
  v8 = +[HMMTRUtilities randomDiscriminator];
  v9 = MEMORY[0x277CD5310];
  v10 = [*(a1 + 32) nodeID];
  v11 = [v10 unsignedLongLongValue];
  v12 = [*(a1 + 32) deviceController];
  v13 = [v9 deviceWithNodeID:v11 deviceController:v12];

  v14 = objc_alloc(MEMORY[0x277CD5238]);
  v15 = [*(a1 + 32) clientQueue];
  v16 = [v14 initWithDevice:v13 endpointID:&unk_283EE89B8 queue:v15];

  if (v16)
  {
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_411;
    v24[3] = &unk_2786EF828;
    v24[4] = *(a1 + 32);
    v25 = v13;
    v26 = v7;
    v29 = v8;
    v30 = *(a1 + 56);
    v28 = *(a1 + 48);
    v27 = *(a1 + 40);
    [v16 revokeCommissioningWithExpectedValues:MEMORY[0x277CBEBF8] expectedValueInterval:&unk_283EE89B8 completion:v24];
  }

  else
  {
    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      v32 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to open pairing window", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    v21 = *(a1 + 48);
    v22 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    (*(v21 + 16))(v21, 0, v22);

    dispatch_group_leave(*(a1 + 40));
  }

  v23 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_414(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_411(uint64_t a1, void *a2)
{
  v22 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    *buf = 138543618;
    v19 = v7;
    v20 = 2112;
    v21 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Revoked commissioning with error (expected): %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = *(a1 + 40);
  v9 = *(a1 + 48);
  v10 = [MEMORY[0x277CCABB0] numberWithUnsignedInteger:*(a1 + 72)];
  v11 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 80)];
  v12 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_412;
  v14[3] = &unk_2786EF800;
  v14[4] = *(a1 + 32);
  v17 = *(a1 + 80);
  v16 = *(a1 + 64);
  v15 = *(a1 + 56);
  [v8 openCommissioningWindowWithSetupPasscode:v9 discriminator:v10 duration:v11 queue:v12 completion:v14];

  v13 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__queueOpenPairingWindowWithPINForDuration_completionHandler___block_invoke_412(uint64_t a1, void *a2, void *a3)
{
  v28 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v5)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v25 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Successfully opened pairing window", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
    [*(a1 + 32) _notifyDelegateOfPairingProgress:25];
    v11 = [*(a1 + 32) vendorID];
    [v5 setVendorID:v11];

    v12 = [*(a1 + 32) productID];
    [v5 setProductID:v12];

    v23 = 0;
    v13 = [v5 qrCodeString:&v23];
    v14 = v23;
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    v18 = v17;
    if (v13)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        v19 = HMFGetLogIdentifier();
        *buf = 138543618;
        v25 = v19;
        v26 = 2112;
        v27 = v13;
        _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Returning setup payload = %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v15);
      v20 = [*(a1 + 32) browser];
      [v20 registerPairingWindowWithSetupPayload:v13 duration:*(a1 + 32) accessoryServer:*(a1 + 56)];
    }

    else
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543618;
        v25 = v21;
        v26 = 2112;
        v27 = v14;
        _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@QR code retrieval from setup payload failed: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v15);
      v14 = v14;

      v13 = 0;
      v6 = v14;
    }
  }

  else
  {
    [*(a1 + 32) _notifyDelegateOfPairingProgress:26 error:v6];
    v13 = 0;
    v14 = 0;
  }

  (*(*(a1 + 48) + 16))();
  dispatch_group_leave(*(a1 + 40));

  v22 = *MEMORY[0x277D85DE8];
}

- (void)_openPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler
{
  v31 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v30 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting open pairing window.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
    v11 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    handlerCopy[2](handlerCopy, 0, v11);
  }

  else
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    if (browser)
    {
      v11 = browser;
      if (isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled())
      {
        v13 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v15 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          v16 = HMFGetLogIdentifier();
          *buf = 138543362;
          v30 = v16;
          _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Aborting all thread connection requests due to external pairing request", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v13);
        v17 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:6];
        [v11 abortAndSuspendAllOperationsWithReason:v17];

        [v11 enableUnrestrictedOperationsForAccessoryServer:selfCopy2];
        threadRadioManager = [v11 threadRadioManager];
        if ([(HMMTRAccessoryServer *)selfCopy2 knownToSystemCommissioner]&& threadRadioManager)
        {
          fabricUUID = [(HMMTRAccessoryServer *)selfCopy2 fabricUUID];
          v26[0] = MEMORY[0x277D85DD0];
          v26[1] = 3221225472;
          v26[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke;
          v26[3] = &unk_2786EFF18;
          v26[4] = selfCopy2;
          durationCopy = duration;
          v27 = handlerCopy;
          [threadRadioManager startThreadRadioForSystemCommissionerFabricUUID:fabricUUID completion:v26];
        }

        else
        {
          [(HMMTRAccessoryServer *)selfCopy2 _queueOpenPairingWindowWithPINForDuration:handlerCopy completionHandler:duration];
        }
      }

      else
      {
        [(HMMTRAccessoryServer *)self _queueOpenPairingWindowWithPINForDuration:handlerCopy completionHandler:duration];
      }
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        v23 = HMFGetLogIdentifier();
        *buf = 138543362;
        v30 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Browser is nil", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v24 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
      handlerCopy[2](handlerCopy, 0, v24);

      v11 = 0;
    }
  }

  v25 = *MEMORY[0x277D85DE8];
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke(uint64_t a1)
{
  v1 = *(a1 + 32);
  v2[0] = MEMORY[0x277D85DD0];
  v2[1] = 3221225472;
  v2[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_2;
  v2[3] = &unk_2786EFF18;
  v2[4] = v1;
  v4 = *(a1 + 48);
  v3 = *(a1 + 40);
  [v1 dispatchBlock:v2];
}

- (void)openPairingWindowWithPINForDuration:(double)duration completionHandler:(id)handler
{
  handlerCopy = handler;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __78__HMMTRAccessoryServer_openPairingWindowWithPINForDuration_completionHandler___block_invoke;
  block[3] = &unk_2786EFF18;
  durationCopy = duration;
  block[4] = self;
  v10 = handlerCopy;
  v8 = handlerCopy;
  dispatch_async(clientQueue, block);
}

- (void)_openPairingWindowForDuration:(double)duration completionHandler:(id)handler
{
  v28 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v25 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting open pairing window.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
    v11 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    handlerCopy[2](handlerCopy, v11);
  }

  else
  {
    v12 = random();
    v13 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      *buf = 138543618;
      v25 = v16;
      v26 = 2048;
      v27 = v12;
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v13);
    v20[0] = MEMORY[0x277D85DD0];
    v20[1] = 3221225472;
    v20[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke;
    v20[3] = &unk_2786EF7D8;
    v20[4] = selfCopy2;
    v22 = v12;
    durationCopy = duration;
    v21 = handlerCopy;
    v18[0] = MEMORY[0x277D85DD0];
    v18[1] = 3221225472;
    v18[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_409;
    v18[3] = &unk_2786F0BC0;
    v19 = v21;
    [(HMMTRAccessoryServer *)selfCopy2 queueAccessoryOperation:v20 highPriority:1 completion:v18];
  }

  v17 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke(uint64_t a1)
{
  v23 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 48);
    *buf = 138543618;
    v20 = v5;
    v21 = 2048;
    v22 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  [*(a1 + 32) _notifyDelegateOfPairingProgress:21];
  [*(a1 + 32) _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindow"];
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_401;
  block[3] = &unk_2786EF850;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v18 = *(a1 + 56);
  v16 = v7;
  v17 = v9;
  v10 = v7;
  dispatch_async(v8, block);

  v11 = [*(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_408;
  v14[3] = &unk_2786EF620;
  v12 = *(a1 + 48);
  v14[4] = *(a1 + 32);
  v14[5] = v12;
  dispatch_group_notify(v10, v11, v14);

  v13 = *MEMORY[0x277D85DE8];
}

uint64_t __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_409(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    return (*(*(result + 32) + 16))();
  }

  return result;
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_401(uint64_t a1)
{
  v31 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 56)];
    *buf = 138543618;
    v28 = v5;
    v29 = 2112;
    v30 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to open the pairing window for a duration of %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = MEMORY[0x277CD5310];
  v8 = [*(a1 + 32) nodeID];
  v9 = [v8 unsignedLongLongValue];
  v10 = [*(a1 + 32) deviceController];
  v11 = [v7 deviceWithNodeID:v9 deviceController:v10];

  v12 = objc_alloc(MEMORY[0x277CD5238]);
  v13 = [*(a1 + 32) clientQueue];
  v14 = [v12 initWithDevice:v11 endpoint:0 queue:v13];

  v15 = objc_alloc_init(MEMORY[0x277CD51B8]);
  v16 = [MEMORY[0x277CCABB0] numberWithDouble:*(a1 + 56)];
  [v15 setCommissioningTimeout:v16];

  [v15 setTimedInvokeTimeoutMs:&unk_283EE8BB0];
  if (v14)
  {
    v24[0] = MEMORY[0x277D85DD0];
    v24[1] = 3221225472;
    v24[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_407;
    v24[3] = &unk_2786F0C10;
    v24[4] = *(a1 + 32);
    v26 = *(a1 + 48);
    v25 = *(a1 + 40);
    [v14 openBasicCommissioningWindowWithParams:v15 expectedValues:0 expectedValueInterval:0 completionHandler:v24];
  }

  else
  {
    v17 = objc_autoreleasePoolPush();
    v18 = *(a1 + 32);
    v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = HMFGetLogIdentifier();
      *buf = 138543362;
      v28 = v20;
      _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to open pairing window", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v17);
    v21 = *(a1 + 48);
    v22 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    (*(v21 + 16))(v21, v22);

    dispatch_group_leave(*(a1 + 40));
  }

  v23 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_408(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_407(uint64_t a1, void *a2)
{
  v11 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    [*(a1 + 32) _notifyDelegateOfPairingProgress:23 error:v3];
  }

  else
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      v9 = 138543362;
      v10 = v7;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Successfully opened pairing window", &v9, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    [*(a1 + 32) _notifyDelegateOfPairingProgress:22];
  }

  (*(*(a1 + 48) + 16))();
  dispatch_group_leave(*(a1 + 40));

  v8 = *MEMORY[0x277D85DE8];
}

- (void)_metricCollectionWithError:(id)error description:(id)description progressState:(int64_t)state
{
  errorCopy = error;
  v7 = [MEMORY[0x277CCABB0] numberWithInteger:state];
  activity = self->_activity;
  HMMLogTagActivityWithErrorAndField();

  userInfo = [errorCopy userInfo];
  v10 = userInfo;
  if (userInfo)
  {
    v11 = [userInfo objectForKey:*MEMORY[0x277CCA7E8]];
  }

  else
  {
    v11 = 0;
  }

  domain = [errorCopy domain];
  [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventErrorDomainKey" value:domain];

  v13 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(errorCopy, "code")}];
  [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventErrorCodeKey" value:v13];

  if (v11)
  {
    domain2 = [v11 domain];
    [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventUnderlyingErrorDomainKey" value:domain2];

    v15 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(v11, "code")}];
    [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventUnderlyingErrorCodeKey" value:v15];
  }
}

- (void)openPairingWindowForDuration:(double)duration completionHandler:(id)handler
{
  handlerCopy = handler;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __71__HMMTRAccessoryServer_openPairingWindowForDuration_completionHandler___block_invoke;
  block[3] = &unk_2786EFF18;
  durationCopy = duration;
  block[4] = self;
  v10 = handlerCopy;
  v8 = handlerCopy;
  dispatch_async(clientQueue, block);
}

- (void)_updateAttributeTimer:(id)timer report:(id)report timeout:(double)timeout server:(id)server
{
  v34 = *MEMORY[0x277D85DE8];
  timerCopy = timer;
  reportCopy = report;
  serverCopy = server;
  v13 = [timerCopy description];
  attributeTimers = [(HMMTRAccessoryServer *)self attributeTimers];
  v15 = [attributeTimers objectForKeyedSubscript:v13];

  v16 = objc_autoreleasePoolPush();
  selfCopy = self;
  v18 = HMFGetOSLogHandle();
  v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
  if (v15)
  {
    if (v19)
    {
      v20 = HMFGetLogIdentifier();
      v28 = 138543874;
      v29 = v20;
      v30 = 2112;
      v31 = v13;
      v32 = 2112;
      v33 = reportCopy;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Attribute timer found for %@ - reset timer and update report with %@", &v28, 0x20u);
    }

    objc_autoreleasePoolPop(v16);
    attributeTimers2 = [(HMMTRAccessoryServer *)selfCopy attributeTimers];
    v22 = [attributeTimers2 objectForKey:v13];

    [(HMMTRAttributeTimer *)v22 updateReport:reportCopy];
  }

  else
  {
    if (v19)
    {
      v23 = HMFGetLogIdentifier();
      v28 = 138543874;
      v29 = v23;
      v30 = 2112;
      v31 = v13;
      v32 = 2112;
      v33 = reportCopy;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Attribute timer NOT found for path %@ - Create timer with report %@", &v28, 0x20u);
    }

    objc_autoreleasePoolPop(v16);
    v24 = [HMMTRAttributeTimer alloc];
    clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
    v22 = [(HMMTRAttributeTimer *)v24 initWithServer:timerCopy report:reportCopy timeout:clientQueue queue:selfCopy server:timeout];

    attributeTimers3 = [(HMMTRAccessoryServer *)selfCopy attributeTimers];
    [attributeTimers3 setObject:v22 forKey:v13];

    [(HMMTRAttributeTimer *)v22 start];
  }

  v27 = *MEMORY[0x277D85DE8];
}

- (void)_updatedCharacteristicsForEventReport:(id)report completionHandler:(id)handler
{
  v128 = *MEMORY[0x277D85DE8];
  reportCopy = report;
  handlerCopy = handler;
  v94 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v95 = reportCopy;
  v7 = [reportCopy objectForKeyedSubscript:*MEMORY[0x277CD5140]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v8 = v7;
  }

  else
  {
    v8 = 0;
  }

  v9 = v8;

  cluster = [v9 cluster];
  v11 = [cluster isEqual:&unk_283EE8B80];

  if (!v11)
  {
    goto LABEL_12;
  }

  v12 = [v95 objectForKeyedSubscript:*MEMORY[0x277CD5130]];
  objc_opt_class();
  v13 = (objc_opt_isKindOfClass() & 1) != 0 ? v12 : 0;
  v14 = v13;

  v15 = [v14 isEqual:MEMORY[0x277CBEC38]];
  if (v15)
  {
    v16 = objc_autoreleasePoolPush();
    selfCopy = self;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543618;
      v116 = v19;
      v117 = 2112;
      v118 = v95;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Ignored switch event %@ in initial reports", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v16);
    v20 = handlerCopy;
    (*(handlerCopy + 2))(handlerCopy, MEMORY[0x277CBEBF8]);
    v21 = v94;
  }

  else
  {
LABEL_12:
    v113 = 0u;
    v114 = 0u;
    v111 = 0u;
    v112 = 0u;
    obj = [(HAPAccessoryServer *)self accessories];
    v88 = [obj countByEnumeratingWithState:&v111 objects:v127 count:16];
    if (v88)
    {
      v22 = 0x2786EB000uLL;
      v87 = *v112;
      v23 = 0x2786EB000uLL;
      v97 = v9;
      selfCopy2 = self;
      do
      {
        v24 = 0;
        do
        {
          if (*v112 != v87)
          {
            objc_enumerationMutation(obj);
          }

          v89 = v24;
          v25 = *(*(&v111 + 1) + 8 * v24);
          v107 = 0u;
          v108 = 0u;
          v109 = 0u;
          v110 = 0u;
          services = [v25 services];
          v27 = [services countByEnumeratingWithState:&v107 objects:v126 count:16];
          if (v27)
          {
            v28 = v27;
            v29 = *v108;
            v90 = *v108;
            v91 = services;
            do
            {
              v30 = 0;
              v92 = v28;
              do
              {
                if (*v108 != v29)
                {
                  objc_enumerationMutation(services);
                }

                v31 = *(*(&v107 + 1) + 8 * v30);
                v32 = *(v22 + 3520);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  [v31 endpoint];
                  v33 = v93 = v30;
                  [v9 endpoint];
                  v34 = v96 = v31;
                  v35 = [v33 isEqualToNumber:v34];

                  v30 = v93;
                  if (v35)
                  {
                    v105 = 0u;
                    v106 = 0u;
                    v103 = 0u;
                    v104 = 0u;
                    characteristics = [v96 characteristics];
                    v36 = [characteristics countByEnumeratingWithState:&v103 objects:v125 count:16];
                    if (v36)
                    {
                      v37 = v36;
                      v100 = *v104;
                      do
                      {
                        for (i = 0; i != v37; ++i)
                        {
                          if (*v104 != v100)
                          {
                            objc_enumerationMutation(characteristics);
                          }

                          v39 = *(*(&v103 + 1) + 8 * i);
                          protocolMap = [*(v23 + 3640) protocolMap];
                          endpoint = [v9 endpoint];
                          clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
                          v43 = [protocolMap reportDescriptionForCharacteristic:v39 endpointID:endpoint clusterIDCharacteristicMap:clusterIDCharacteristicMap];

                          if (v43)
                          {
                            clusterId = [v43 clusterId];
                            cluster2 = [v9 cluster];
                            if (([clusterId isEqualToNumber:cluster2] & 1) != 0 && (objc_msgSend(v43, "eventIds"), (v46 = objc_claimAutoreleasedReturnValue()) != 0))
                            {
                              v47 = v46;
                              eventIds = [v43 eventIds];
                              v101[0] = MEMORY[0x277D85DD0];
                              v101[1] = 3221225472;
                              v101[2] = __80__HMMTRAccessoryServer__updatedCharacteristicsForEventReport_completionHandler___block_invoke;
                              v101[3] = &unk_2786EF7B0;
                              v49 = v9;
                              v102 = v49;
                              v50 = [eventIds indexOfObjectPassingTest:v101];

                              v23 = 0x2786EB000;
                              v51 = v50 == 0x7FFFFFFFFFFFFFFFLL;
                              self = selfCopy2;
                              if (!v51)
                              {
                                type = [v96 type];
                                v53 = [type isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

                                if (!v53 || ([v49 cluster], v54 = objc_claimAutoreleasedReturnValue(), v55 = objc_msgSend(v54, "isEqual:", &unk_283EE8B98), v54, (v55 & 1) == 0))
                                {
                                  mapEvent = [v43 mapEvent];

                                  if (mapEvent)
                                  {
                                    mapEvent2 = [v43 mapEvent];
                                    event = [v49 event];
                                    v59 = (mapEvent2)[2](mapEvent2, event, v95);
                                  }

                                  else
                                  {
                                    v59 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v95];
                                  }

                                  v60 = objc_autoreleasePoolPush();
                                  v61 = selfCopy2;
                                  v62 = HMFGetOSLogHandle();
                                  v63 = v62;
                                  if (v59)
                                  {
                                    if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
                                    {
                                      v64 = HMFGetLogIdentifier();
                                      *buf = 138543874;
                                      v116 = v64;
                                      v117 = 2112;
                                      v118 = v39;
                                      v119 = 2112;
                                      v120 = v59;
                                      _os_log_impl(&dword_22AEAE000, v63, OS_LOG_TYPE_INFO, "%{public}@Updating characteristic: %@ from report with value: %@", buf, 0x20u);
                                    }

                                    objc_autoreleasePoolPop(v60);
                                    v65 = objc_autoreleasePoolPush();
                                    v66 = v61;
                                    v67 = HMFGetOSLogHandle();
                                    if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
                                    {
                                      v68 = HMFGetLogIdentifier();
                                      *buf = 138543618;
                                      v116 = v68;
                                      v117 = 2112;
                                      v118 = v39;
                                      _os_log_impl(&dword_22AEAE000, v67, OS_LOG_TYPE_INFO, "%{public}@Creating a copy for characteristic before modifying it %@", buf, 0x16u);
                                    }

                                    objc_autoreleasePoolPop(v65);
                                    v69 = [v39 copy];
                                    service = [v39 service];
                                    [v69 setService:service];

                                    [v69 setValue:v59];
                                    [v94 addObject:v69];
                                    v71 = +[HMMTRProtocolMap protocolMap];
                                    endpoint2 = [v49 endpoint];
                                    clusterIDCharacteristicMap2 = [(HMMTRAccessoryServer *)v66 clusterIDCharacteristicMap];
                                    v74 = [v71 getUpdatedLinkedCharacteristics:v69 endpointID:endpoint2 clusterIDCharacteristicMap:clusterIDCharacteristicMap2];

                                    [v94 addObjectsFromArray:v74];
                                    self = selfCopy2;
                                  }

                                  else
                                  {
                                    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
                                    {
                                      v75 = HMFGetLogIdentifier();
                                      *buf = 138543618;
                                      v116 = v75;
                                      v117 = 2112;
                                      v118 = v95;
                                      _os_log_impl(&dword_22AEAE000, v63, OS_LOG_TYPE_DEBUG, "%{public}@Ignored event %@ which doesn't derive a value", buf, 0x16u);

                                      self = selfCopy2;
                                    }

                                    objc_autoreleasePoolPop(v60);
                                  }

                                  v23 = 0x2786EB000;
                                }
                              }

                              clusterId = v102;
                              v9 = v97;
                            }

                            else
                            {
                            }
                          }
                        }

                        v37 = [characteristics countByEnumeratingWithState:&v103 objects:v125 count:16];
                      }

                      while (v37);
                    }

                    v22 = 0x2786EB000;
                    v29 = v90;
                    services = v91;
                    v28 = v92;
                    v30 = v93;
                  }
                }

                ++v30;
              }

              while (v30 != v28);
              v28 = [services countByEnumeratingWithState:&v107 objects:v126 count:16];
            }

            while (v28);
          }

          v24 = v89 + 1;
        }

        while (v89 + 1 != v88);
        v88 = [obj countByEnumeratingWithState:&v111 objects:v127 count:16];
      }

      while (v88);
    }

    v76 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v78 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
    {
      v79 = HMFGetLogIdentifier();
      endpoint3 = [v9 endpoint];
      cluster3 = [v9 cluster];
      [v9 event];
      v83 = v82 = v9;
      *buf = 138544386;
      v116 = v79;
      v117 = 2112;
      v118 = v94;
      v119 = 2112;
      v120 = endpoint3;
      v121 = 2112;
      v122 = cluster3;
      v123 = 2112;
      v124 = v83;
      _os_log_impl(&dword_22AEAE000, v78, OS_LOG_TYPE_DEBUG, "%{public}@Updated characteristics %@ for Report endpoint:%@ cluster:%@ event:%@", buf, 0x34u);

      v9 = v82;
    }

    objc_autoreleasePoolPop(v76);
    v20 = handlerCopy;
    v21 = v94;
    (*(handlerCopy + 2))(handlerCopy, v94);
  }

  v84 = *MEMORY[0x277D85DE8];
}

uint64_t __80__HMMTRAccessoryServer__updatedCharacteristicsForEventReport_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  v2 = *(a1 + 32);
  v3 = a2;
  v4 = [v2 event];
  v5 = [v3 isEqualToNumber:v4];

  return v5;
}

- (void)_updatedCharacteristicsForAttributeReport:(id)report completionHandler:(id)handler
{
  v129 = *MEMORY[0x277D85DE8];
  reportCopy = report;
  handlerCopy = handler;
  group = dispatch_group_create();
  v114 = 0;
  v115 = &v114;
  v116 = 0x3032000000;
  v117 = __Block_byref_object_copy__10189;
  v118 = __Block_byref_object_dispose__10190;
  v119 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v5 = [reportCopy objectForKeyedSubscript:*MEMORY[0x277CD50B8]];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v6 = v5;
  }

  else
  {
    v6 = 0;
  }

  v7 = v6;

  if (v7)
  {
    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    obj = [(HAPAccessoryServer *)self accessories];
    v67 = [obj countByEnumeratingWithState:&v110 objects:v128 count:16];
    if (!v67)
    {
      goto LABEL_57;
    }

    v68 = *v111;
    while (1)
    {
      for (i = 0; i != v67; ++i)
      {
        if (*v111 != v68)
        {
          objc_enumerationMutation(obj);
        }

        v8 = *(*(&v110 + 1) + 8 * i);
        v106 = 0u;
        v107 = 0u;
        v108 = 0u;
        v109 = 0u;
        services = [v8 services];
        v74 = [services countByEnumeratingWithState:&v106 objects:v127 count:16];
        if (v74)
        {
          v73 = *v107;
          do
          {
            for (j = 0; j != v74; ++j)
            {
              if (*v107 != v73)
              {
                objc_enumerationMutation(services);
              }

              v78 = *(*(&v106 + 1) + 8 * j);
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                endpoint = [v78 endpoint];
                endpoint2 = [v7 endpoint];
                v11 = [endpoint isEqualToNumber:endpoint2];

                if (v11)
                {
                  v104 = 0u;
                  v105 = 0u;
                  v102 = 0u;
                  v103 = 0u;
                  characteristics = [v78 characteristics];
                  v13 = [characteristics countByEnumeratingWithState:&v102 objects:v126 count:16];
                  if (!v13)
                  {
                    goto LABEL_52;
                  }

                  v83 = *v103;
                  v80 = characteristics;
                  while (1)
                  {
                    v84 = v13;
                    for (k = 0; k != v84; ++k)
                    {
                      if (*v103 != v83)
                      {
                        objc_enumerationMutation(v80);
                      }

                      v15 = *(*(&v102 + 1) + 8 * k);
                      v16 = +[HMMTRProtocolMap protocolMap];
                      endpoint3 = [v7 endpoint];
                      clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
                      v19 = [v16 reportDescriptionForCharacteristic:v15 endpointID:endpoint3 clusterIDCharacteristicMap:clusterIDCharacteristicMap];

                      if (v19)
                      {
                        clusterId = [v19 clusterId];
                        cluster = [v7 cluster];
                        if (clusterId == cluster || ([v19 clusterId], v85 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v7, "cluster"), v86 = objc_claimAutoreleasedReturnValue(), -[HMMTRAccessoryServer _isBridgedBasicInformation:reportClusterID:](self, "_isBridgedBasicInformation:reportClusterID:", v85, v86)))
                        {
                          attributeIds = [v19 attributeIds];
                          attribute = [v7 attribute];
                          v24 = [attributeIds containsObject:attribute];

                          if (clusterId == cluster)
                          {

                            if (!v24)
                            {
                              goto LABEL_46;
                            }

                            goto LABEL_30;
                          }
                        }

                        else
                        {
                          LOBYTE(v24) = 0;
                        }

                        if ((v24 & 1) == 0)
                        {
                          goto LABEL_46;
                        }

LABEL_30:
                        dispatch_group_enter(group);
                        clusterClass = [v19 clusterClass];
                        if (!clusterClass || ([v19 clusterSelector], v26 = objc_claimAutoreleasedReturnValue(), v27 = v26 == 0, v26, clusterClass, v27))
                        {
                          v40 = objc_autoreleasePoolPush();
                          selfCopy = self;
                          v42 = HMFGetOSLogHandle();
                          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
                          {
                            v43 = HMFGetLogIdentifier();
                            *buf = 138543874;
                            v121 = v43;
                            v122 = 2112;
                            v123 = v15;
                            v124 = 2112;
                            v125 = reportCopy;
                            _os_log_impl(&dword_22AEAE000, v42, OS_LOG_TYPE_DEBUG, "%{public}@Updating characteristic: %@ from report: %@", buf, 0x20u);
                          }

                          objc_autoreleasePoolPop(v40);
                          v44 = [v15 copy];
                          service = [v15 service];
                          [v44 setService:service];

                          mapValue = [v19 mapValue];
                          if (mapValue)
                          {
                            mapValue2 = [v19 mapValue];
                            v47 = (*(mapValue2 + 16))(mapValue2, reportCopy);
                            v76 = v47;
                          }

                          else
                          {
                            v47 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:reportCopy];
                            v77 = v47;
                          }

                          [v44 setValue:v47];
                          v48 = v77;
                          if (mapValue)
                          {

                            v48 = mapValue2;
                          }

                          v49 = objc_autoreleasePoolPush();
                          v50 = selfCopy;
                          v51 = HMFGetOSLogHandle();
                          if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
                          {
                            v52 = HMFGetLogIdentifier();
                            *buf = 138543874;
                            v121 = v52;
                            v122 = 2112;
                            v123 = v44;
                            v124 = 2112;
                            v125 = reportCopy;
                            _os_log_impl(&dword_22AEAE000, v51, OS_LOG_TYPE_INFO, "%{public}@Updated characteristic %@ from report: %@", buf, 0x20u);
                          }

                          objc_autoreleasePoolPop(v49);
                          [v115[5] addObject:v44];
                          v53 = +[HMMTRProtocolMap protocolMap];
                          endpoint4 = [v7 endpoint];
                          clusterIDCharacteristicMap2 = [(HMMTRAccessoryServer *)v50 clusterIDCharacteristicMap];
                          v56 = [v53 getUpdatedLinkedCharacteristics:v44 endpointID:endpoint4 clusterIDCharacteristicMap:clusterIDCharacteristicMap2];

                          [v115[5] addObjectsFromArray:v56];
                          v92[0] = MEMORY[0x277D85DD0];
                          v92[1] = 3221225472;
                          v92[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_389;
                          v92[3] = &unk_2786EF738;
                          v94 = &v114;
                          v93 = group;
                          [(HMMTRAccessoryServer *)v50 _updateAdditionalCharacteristicsFromCharacteristicUpdate:v44 service:v78 path:v7 completionHandler:v92];
                        }

                        else
                        {
                          v28 = objc_autoreleasePoolPush();
                          selfCopy2 = self;
                          v30 = HMFGetOSLogHandle();
                          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
                          {
                            v31 = HMFGetLogIdentifier();
                            *buf = 138543618;
                            v121 = v31;
                            v122 = 2112;
                            v123 = v15;
                            _os_log_impl(&dword_22AEAE000, v30, OS_LOG_TYPE_INFO, "%{public}@Attribute report needs custom handling for Characteristic %@", buf, 0x16u);
                          }

                          objc_autoreleasePoolPop(v28);
                          matterDevice = [(HMMTRAccessoryServer *)selfCopy2 matterDevice];

                          if (matterDevice)
                          {
                            v33 = [HMMTRProtocolOperation alloc];
                            matterDevice2 = [(HMMTRAccessoryServer *)selfCopy2 matterDevice];
                            clusterIDCharacteristicMap3 = [(HMMTRAccessoryServer *)selfCopy2 clusterIDCharacteristicMap];
                            v36 = [(HMMTRProtocolOperation *)v33 initWithOperationOfType:2 characteristic:v15 matterDevice:matterDevice2 primaryArgument:reportCopy clusterIDCharacteristicMap:clusterIDCharacteristicMap3];

                            v37 = +[HMMTRProtocolOperationManager sharedInstance];
                            clientQueue = [(HAPAccessoryServer *)selfCopy2 clientQueue];
                            reportDistributor = [(HMMTRAccessoryServer *)selfCopy2 reportDistributor];
                            v95[0] = MEMORY[0x277D85DD0];
                            v95[1] = 3221225472;
                            v95[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke;
                            v95[3] = &unk_2786EF760;
                            v95[4] = selfCopy2;
                            v96 = reportCopy;
                            v97 = v15;
                            v101 = &v114;
                            v98 = v7;
                            v99 = v78;
                            v100 = group;
                            [v37 registerOperation:v36 accessoryServer:selfCopy2 clientQueue:clientQueue reportDistributor:reportDistributor operationResponseHandler:v95 updatedAttributesHandler:0];
                          }

                          else
                          {
                            v57 = objc_autoreleasePoolPush();
                            v58 = selfCopy2;
                            v59 = HMFGetOSLogHandle();
                            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
                            {
                              v60 = HMFGetLogIdentifier();
                              *buf = 138543618;
                              v121 = v60;
                              v122 = 2112;
                              v123 = v15;
                              _os_log_impl(&dword_22AEAE000, v59, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to custom-handle the Attribute Report for characteristic %@", buf, 0x16u);
                            }

                            objc_autoreleasePoolPop(v57);
                            dispatch_group_leave(group);
                          }
                        }
                      }

LABEL_46:
                    }

                    characteristics = v80;
                    v13 = [v80 countByEnumeratingWithState:&v102 objects:v126 count:16];
                    if (!v13)
                    {
LABEL_52:

                      break;
                    }
                  }
                }
              }
            }

            v74 = [services countByEnumeratingWithState:&v106 objects:v127 count:16];
          }

          while (v74);
        }
      }

      v67 = [obj countByEnumeratingWithState:&v110 objects:v128 count:16];
      if (!v67)
      {
LABEL_57:

        clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
        block[0] = MEMORY[0x277D85DD0];
        block[1] = 3221225472;
        block[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_2;
        block[3] = &unk_2786EF788;
        block[4] = self;
        v91 = &v114;
        v89 = v7;
        v90 = handlerCopy;
        dispatch_group_notify(group, clientQueue2, block);

        goto LABEL_61;
      }
    }
  }

  v62 = objc_autoreleasePoolPush();
  selfCopy3 = self;
  v64 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
  {
    v65 = HMFGetLogIdentifier();
    *buf = 138543362;
    v121 = v65;
    _os_log_impl(&dword_22AEAE000, v64, OS_LOG_TYPE_ERROR, "%{public}@Attribute path missing from report. Cannot handle this report.", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v62);
  (*(handlerCopy + 2))(handlerCopy, v115[5]);
LABEL_61:

  _Block_object_dispose(&v114, 8);
  v66 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  v37 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = [v3 error];
  v5 = [v4 isEqual:&unk_283EE8B68];

  if (v5)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = *(a1 + 32);
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v10 = *(a1 + 40);
      v11 = *(a1 + 48);
      *buf = 138543874;
      v32 = v9;
      v33 = 2112;
      v34 = v10;
      v35 = 2112;
      v36 = v11;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Custom handler ignored report %@ for characteristic %@", buf, 0x20u);
LABEL_7:
    }
  }

  else
  {
    v12 = [v3 error];

    if (!v12)
    {
      v21 = *(*(*(a1 + 80) + 8) + 40);
      v22 = [v3 characteristic];
      [v21 addObject:v22];

      v23 = +[HMMTRProtocolMap protocolMap];
      v24 = [v3 characteristic];
      v25 = [*(a1 + 56) endpoint];
      v26 = [*(a1 + 32) clusterIDCharacteristicMap];
      v27 = [v23 getUpdatedLinkedCharacteristics:v24 endpointID:v25 clusterIDCharacteristicMap:v26];

      [*(*(*(a1 + 80) + 8) + 40) addObjectsFromArray:v27];
      goto LABEL_9;
    }

    v6 = objc_autoreleasePoolPush();
    v7 = *(a1 + 32);
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = HMFGetLogIdentifier();
      v13 = [v3 error];
      v14 = *(a1 + 48);
      *buf = 138543874;
      v32 = v9;
      v33 = 2112;
      v34 = v13;
      v35 = 2112;
      v36 = v14;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to handle a report for characteristic: %@", buf, 0x20u);

      goto LABEL_7;
    }
  }

  objc_autoreleasePoolPop(v6);
LABEL_9:
  v15 = *(a1 + 32);
  v16 = [v3 characteristic];
  v18 = *(a1 + 56);
  v17 = *(a1 + 64);
  v29[0] = MEMORY[0x277D85DD0];
  v29[1] = 3221225472;
  v29[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_387;
  v29[3] = &unk_2786EF738;
  v28 = *(a1 + 72);
  v19 = v28;
  v30 = v28;
  [v15 _updateAdditionalCharacteristicsFromCharacteristicUpdate:v16 service:v17 path:v18 completionHandler:v29];

  v20 = *MEMORY[0x277D85DE8];
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_389(uint64_t a1, uint64_t a2)
{
  [*(*(*(a1 + 40) + 8) + 40) addObjectsFromArray:a2];
  v3 = *(a1 + 32);

  dispatch_group_leave(v3);
}

uint64_t __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_2(uint64_t a1)
{
  v23 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(*(*(a1 + 56) + 8) + 40);
    v7 = [*(a1 + 40) endpoint];
    v8 = [*(a1 + 40) cluster];
    v9 = [*(a1 + 40) attribute];
    v13 = 138544386;
    v14 = v5;
    v15 = 2112;
    v16 = v6;
    v17 = 2112;
    v18 = v7;
    v19 = 2112;
    v20 = v8;
    v21 = 2112;
    v22 = v9;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Updated characteristics %@ for Report endpoint:%@ cluster:%@ attribute:%@", &v13, 0x34u);
  }

  objc_autoreleasePoolPop(v2);
  v10 = *(*(*(a1 + 56) + 8) + 40);
  result = (*(*(a1 + 48) + 16))();
  v12 = *MEMORY[0x277D85DE8];
  return result;
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_387(uint64_t a1, uint64_t a2)
{
  [*(*(*(a1 + 40) + 8) + 40) addObjectsFromArray:a2];
  v3 = *(a1 + 32);

  dispatch_group_leave(v3);
}

- (void)_updateAdditionalCharacteristicsFromCharacteristicUpdate:(id)update service:(id)service path:(id)path completionHandler:(id)handler
{
  v152 = *MEMORY[0x277D85DE8];
  updateCopy = update;
  serviceCopy = service;
  pathCopy = path;
  handlerCopy = handler;
  v13 = objc_alloc_init(MEMORY[0x277CBEB18]);
  cluster = [pathCopy cluster];
  if (![cluster isEqualToNumber:&unk_283EE8A78])
  {
    goto LABEL_12;
  }

  v120 = serviceCopy;
  attribute = [pathCopy attribute];
  if (([attribute isEqualToNumber:&unk_283EE8A90] & 1) == 0)
  {

    serviceCopy = v120;
LABEL_12:

LABEL_13:
    cluster2 = [pathCopy cluster];
    v22 = [cluster2 isEqualToNumber:&unk_283EE8AC0];

    if (v22)
    {
      v23 = serviceCopy;
      attribute2 = [pathCopy attribute];
      v25 = [attribute2 isEqualToNumber:&unk_283EE8AD8];
      v117 = v13;
      if (v25)
      {
        serviceCopy = [updateCopy type];
        if ([serviceCopy isEqualToString:@"00000013-0000-1000-8000-0026BB765291"])
        {

LABEL_44:
          v115 = handlerCopy;
          v132 = 0u;
          v133 = 0u;
          v130 = 0u;
          v131 = 0u;
          v120 = v23;
          characteristics = [v23 characteristics];
          v49 = [characteristics countByEnumeratingWithState:&v130 objects:v150 count:16];
          if (v49)
          {
            v50 = v49;
            v51 = *v131;
LABEL_46:
            v52 = updateCopy;
            v53 = 0;
            while (1)
            {
              if (*v131 != v51)
              {
                objc_enumerationMutation(characteristics);
              }

              v54 = *(*(&v130 + 1) + 8 * v53);
              type = [v54 type];
              v56 = [type isEqualToString:@"000000CE-0000-1000-8000-0026BB765291"];

              if (v56)
              {
                break;
              }

              if (v50 == ++v53)
              {
                v50 = [characteristics countByEnumeratingWithState:&v130 objects:v150 count:16];
                updateCopy = v52;
                if (v50)
                {
                  goto LABEL_46;
                }

                goto LABEL_52;
              }
            }

            v57 = v54;

            updateCopy = v52;
            if (!v57)
            {
              goto LABEL_57;
            }

            v58 = objc_autoreleasePoolPush();
            selfCopy = self;
            v60 = HMFGetOSLogHandle();
            handlerCopy = v115;
            v13 = v117;
            if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
            {
              v61 = HMFGetLogIdentifier();
              *buf = 138543874;
              v145 = v61;
              v146 = 2112;
              v147 = v57;
              v148 = 2112;
              v149 = updateCopy;
              _os_log_impl(&dword_22AEAE000, v60, OS_LOG_TYPE_INFO, "%{public}@Updated additional characteristic %@ \nbased on characteristic \n%@", buf, 0x20u);
            }

            objc_autoreleasePoolPop(v58);
            [v57 setValue:&unk_283EE8B08];
            [v117 addObject:v57];
            v115[2](v115, v117);
LABEL_65:

            goto LABEL_70;
          }

LABEL_52:

LABEL_57:
          v62 = objc_autoreleasePoolPush();
          selfCopy2 = self;
          v64 = HMFGetOSLogHandle();
          handlerCopy = v115;
          v13 = v117;
          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          {
            v65 = HMFGetLogIdentifier();
            endpoint = [pathCopy endpoint];
            *buf = 138543618;
            v145 = v65;
            v146 = 2112;
            v147 = endpoint;
            _os_log_impl(&dword_22AEAE000, v64, OS_LOG_TYPE_ERROR, "%{public}@Unexpected, color temperature characteristic not found on endpoint %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v62);
          goto LABEL_69;
        }
      }

      v32 = handlerCopy;
      attribute3 = [pathCopy attribute];
      if ([attribute3 isEqualToNumber:&unk_283EE8AF0])
      {
        type2 = [updateCopy type];
        v35 = [type2 isEqualToString:@"0000002F-0000-1000-8000-0026BB765291"];

        if (v25)
        {

          handlerCopy = v32;
          if (v35)
          {
            goto LABEL_44;
          }
        }

        else
        {

          handlerCopy = v32;
          if (v35)
          {
            goto LABEL_44;
          }
        }
      }

      else
      {

        if (v25)
        {
        }

        handlerCopy = v32;
      }

      v13 = v117;
      handlerCopy[2](handlerCopy, v117);
LABEL_29:
      serviceCopy = v23;
      goto LABEL_71;
    }

    cluster3 = [pathCopy cluster];
    v27 = [cluster3 isEqualToNumber:&unk_283EE8B20];

    if (v27)
    {
      attribute4 = [pathCopy attribute];
      if ([attribute4 isEqualToNumber:&unk_283EE8B38])
      {
        type3 = [updateCopy type];
        v30 = [type3 isEqualToString:@"0000007B-0000-1000-8000-0026BB765291"];

        if (v30)
        {
          v114 = handlerCopy;
          v118 = v13;
          v31 = @"0000007C-0000-1000-8000-0026BB765291";
LABEL_34:
          v128 = 0u;
          v129 = 0u;
          v126 = 0u;
          v127 = 0u;
          v120 = serviceCopy;
          characteristics2 = [serviceCopy characteristics];
          v40 = [characteristics2 countByEnumeratingWithState:&v126 objects:v143 count:16];
          if (!v40)
          {
LABEL_42:

LABEL_66:
            v75 = objc_autoreleasePoolPush();
            selfCopy3 = self;
            v77 = HMFGetOSLogHandle();
            v13 = v118;
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            {
              v78 = HMFGetLogIdentifier();
              endpoint2 = [pathCopy endpoint];
              *buf = 138543618;
              v145 = v78;
              v146 = 2112;
              v147 = endpoint2;
              _os_log_impl(&dword_22AEAE000, v77, OS_LOG_TYPE_ERROR, "%{public}@Unexpected, position characteristic not found on endpoint %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v75);
            handlerCopy = v114;
LABEL_69:
            handlerCopy[2](handlerCopy, v13);
LABEL_70:
            serviceCopy = v120;
            goto LABEL_71;
          }

          v41 = v40;
          v42 = *v127;
LABEL_36:
          v43 = updateCopy;
          v44 = 0;
          while (1)
          {
            if (*v127 != v42)
            {
              objc_enumerationMutation(characteristics2);
            }

            v45 = *(*(&v126 + 1) + 8 * v44);
            type4 = [v45 type];
            v47 = [type4 isEqualToString:v31];

            if (v47)
            {
              break;
            }

            if (v41 == ++v44)
            {
              v41 = [characteristics2 countByEnumeratingWithState:&v126 objects:v143 count:16];
              updateCopy = v43;
              if (v41)
              {
                goto LABEL_36;
              }

              goto LABEL_42;
            }
          }

          v67 = v45;

          updateCopy = v43;
          if (!v67)
          {
            goto LABEL_66;
          }

          matterDevice = [(HMMTRAccessoryServer *)self matterDevice];

          v13 = v118;
          if (matterDevice)
          {
            v69 = [HMMTRProtocolOperation alloc];
            matterDevice2 = [(HMMTRAccessoryServer *)self matterDevice];
            clusterIDCharacteristicMap = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
            v112 = [(HMMTRProtocolOperation *)v69 initWithOperationOfType:4 characteristic:v67 matterDevice:matterDevice2 clusterIDCharacteristicMap:clusterIDCharacteristicMap];

            v72 = +[HMMTRProtocolOperationManager sharedInstance];
            clientQueue = [(HAPAccessoryServer *)self clientQueue];
            reportDistributor = [(HMMTRAccessoryServer *)self reportDistributor];
            v121[0] = MEMORY[0x277D85DD0];
            v121[1] = 3221225472;
            v121[2] = __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke_380;
            v121[3] = &unk_2786EF710;
            v121[4] = self;
            v122 = v67;
            v123 = updateCopy;
            v124 = v118;
            v125 = v114;
            v57 = v67;
            [v72 registerOperation:v112 accessoryServer:self clientQueue:clientQueue reportDistributor:reportDistributor operationResponseHandler:v121 updatedAttributesHandler:0];

            handlerCopy = v114;
            goto LABEL_65;
          }

          v89 = objc_autoreleasePoolPush();
          selfCopy4 = self;
          v91 = HMFGetOSLogHandle();
          v23 = v120;
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          {
            v92 = HMFGetLogIdentifier();
            *buf = 138543618;
            v145 = v92;
            v146 = 2112;
            v147 = updateCopy;
            _os_log_impl(&dword_22AEAE000, v91, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to get Feature Map %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v89);
          handlerCopy = v114;
          v114[2](v114, v118);

          goto LABEL_29;
        }
      }

      else
      {
      }

      attribute5 = [pathCopy attribute];
      if ([attribute5 isEqualToNumber:&unk_283EE8B50])
      {
        type5 = [updateCopy type];
        v38 = [type5 isEqualToString:@"0000006C-0000-1000-8000-0026BB765291"];

        if (v38)
        {
          v114 = handlerCopy;
          v118 = v13;
          v31 = @"0000006D-0000-1000-8000-0026BB765291";
          goto LABEL_34;
        }
      }

      else
      {
      }
    }

    handlerCopy[2](handlerCopy, v13);
    goto LABEL_71;
  }

  type6 = [updateCopy type];
  v17 = [type6 isEqualToString:@"00000033-0000-1000-8000-0026BB765291"];

  serviceCopy = v120;
  if (!v17)
  {
    goto LABEL_13;
  }

  value = [updateCopy value];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    v19 = value;
  }

  else
  {
    v19 = 0;
  }

  v20 = v19;

  if (v20 && ([v20 isEqualToNumber:&unk_283EE89B8] & 1) == 0 && !objc_msgSend(v20, "isEqualToNumber:", &unk_283EE8AA8))
  {
    v111 = v20;
    v113 = updateCopy;
    v116 = handlerCopy;
    v141 = 0u;
    v142 = 0u;
    v139 = 0u;
    v140 = 0u;
    characteristics3 = [v120 characteristics];
    v82 = [characteristics3 countByEnumeratingWithState:&v139 objects:v151 count:16];
    if (v82)
    {
      v83 = v82;
      v84 = *v140;
LABEL_74:
      v85 = 0;
      while (1)
      {
        if (*v140 != v84)
        {
          objc_enumerationMutation(characteristics3);
        }

        v86 = *(*(&v139 + 1) + 8 * v85);
        type7 = [v86 type];
        v88 = [type7 isEqualToString:@"00000035-0000-1000-8000-0026BB765291"];

        if (v88)
        {
          break;
        }

        if (v83 == ++v85)
        {
          v83 = [characteristics3 countByEnumeratingWithState:&v139 objects:v151 count:16];
          if (v83)
          {
            goto LABEL_74;
          }

          goto LABEL_80;
        }
      }

      v93 = v86;

      if (!v93)
      {
        goto LABEL_87;
      }

      matterDevice3 = [(HMMTRAccessoryServer *)self matterDevice];

      updateCopy = v113;
      if (matterDevice3)
      {
        v95 = [HMMTRProtocolOperation alloc];
        matterDevice4 = [(HMMTRAccessoryServer *)self matterDevice];
        clusterIDCharacteristicMap2 = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
        v110 = [(HMMTRProtocolOperation *)v95 initWithOperationOfType:4 characteristic:v93 matterDevice:matterDevice4 clusterIDCharacteristicMap:clusterIDCharacteristicMap2];

        v98 = +[HMMTRProtocolOperationManager sharedInstance];
        clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
        reportDistributor2 = [(HMMTRAccessoryServer *)self reportDistributor];
        v134[0] = MEMORY[0x277D85DD0];
        v134[1] = 3221225472;
        v134[2] = __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke;
        v134[3] = &unk_2786EF710;
        v134[4] = self;
        v135 = v93;
        v136 = v113;
        v137 = v13;
        v138 = v116;
        v93 = v93;
        [v98 registerOperation:v110 accessoryServer:self clientQueue:clientQueue2 reportDistributor:reportDistributor2 operationResponseHandler:v134 updatedAttributesHandler:0];

        handlerCopy = v116;
      }

      else
      {
        v106 = objc_autoreleasePoolPush();
        selfCopy5 = self;
        v108 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
        {
          v109 = HMFGetLogIdentifier();
          *buf = 138543618;
          v145 = v109;
          v146 = 2112;
          v147 = v113;
          _os_log_impl(&dword_22AEAE000, v108, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to update additional target temperature characteristics %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v106);
        handlerCopy = v116;
        v116[2](v116, v13);
      }
    }

    else
    {
LABEL_80:

LABEL_87:
      v101 = objc_autoreleasePoolPush();
      selfCopy6 = self;
      v103 = HMFGetOSLogHandle();
      updateCopy = v113;
      handlerCopy = v116;
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
      {
        v104 = HMFGetLogIdentifier();
        endpoint3 = [pathCopy endpoint];
        *buf = 138543618;
        v145 = v104;
        v146 = 2112;
        v147 = endpoint3;
        _os_log_impl(&dword_22AEAE000, v103, OS_LOG_TYPE_ERROR, "%{public}@Unexpected, target temperature characteristic not found on endpoint %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v101);
      v116[2](v116, v13);
    }

    goto LABEL_70;
  }

  handlerCopy[2](handlerCopy, v13);

LABEL_71:
  v80 = *MEMORY[0x277D85DE8];
}

void __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  v25 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = [v3 error];

  v5 = objc_autoreleasePoolPush();
  v6 = *(a1 + 32);
  v7 = HMFGetOSLogHandle();
  v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = HMFGetLogIdentifier();
      v10 = [v3 error];
      v11 = *(a1 + 40);
      v19 = 138543874;
      v20 = v9;
      v21 = 2112;
      v22 = v10;
      v23 = 2112;
      v24 = v11;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to handle a report for characteristic: %@", &v19, 0x20u);
    }

    objc_autoreleasePoolPop(v5);
  }

  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      v13 = *(a1 + 40);
      v14 = *(a1 + 48);
      v19 = 138543874;
      v20 = v12;
      v21 = 2112;
      v22 = v13;
      v23 = 2112;
      v24 = v14;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Updated additional characteristic %@ based on characteristic %@", &v19, 0x20u);
    }

    objc_autoreleasePoolPop(v5);
    v15 = *(a1 + 56);
    v16 = [v3 characteristic];
    [v15 addObject:v16];
  }

  v17 = *(a1 + 56);
  (*(*(a1 + 64) + 16))();

  v18 = *MEMORY[0x277D85DE8];
}

void __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke_380(uint64_t a1, void *a2)
{
  v25 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = [v3 error];

  v5 = objc_autoreleasePoolPush();
  v6 = *(a1 + 32);
  v7 = HMFGetOSLogHandle();
  v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = HMFGetLogIdentifier();
      v10 = [v3 error];
      v11 = *(a1 + 40);
      v19 = 138543874;
      v20 = v9;
      v21 = 2112;
      v22 = v10;
      v23 = 2112;
      v24 = v11;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to handle a report for characteristic: %@", &v19, 0x20u);
    }

    objc_autoreleasePoolPop(v5);
  }

  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v12 = HMFGetLogIdentifier();
      v13 = *(a1 + 40);
      v14 = *(a1 + 48);
      v19 = 138543874;
      v20 = v12;
      v21 = 2112;
      v22 = v13;
      v23 = 2112;
      v24 = v14;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Updated additional characteristic %@ based on characteristic %@", &v19, 0x20u);
    }

    objc_autoreleasePoolPop(v5);
    v15 = *(a1 + 56);
    v16 = [v3 characteristic];
    [v15 addObject:v16];
  }

  v17 = *(a1 + 56);
  (*(*(a1 + 64) + 16))();

  v18 = *MEMORY[0x277D85DE8];
}

- (BOOL)_isBridgedBasicInformation:(id)information reportClusterID:(id)d
{
  dCopy = d;
  v6 = [information isEqualToNumber:&unk_283EE8A00] && (objc_msgSend(dCopy, "isEqualToNumber:", &unk_283EE8A60) & 1) != 0;

  return v6;
}

- (id)deviceTopology
{
  v3 = [HMMTRDeviceTopology alloc];
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:nodeID server:self];

  return v5;
}

- (BOOL)_handleUnmappedAttributeReport:(id)report
{
  reportCopy = report;
  v5 = [reportCopy objectForKeyedSubscript:*MEMORY[0x277CD50B8]];
  cluster = [v5 cluster];
  if ([cluster isEqualToNumber:&unk_283EE89D0])
  {
    attribute = [v5 attribute];
    v8 = [attribute isEqualToNumber:&unk_283EE89E8];

    if (v8)
    {
      chipDelegate = [(HMMTRAccessoryServer *)self chipDelegate];
      v10 = objc_opt_respondsToSelector();

      if (v10)
      {
        delegateQueue = [(HAPAccessoryServer *)self delegateQueue];
        block[0] = MEMORY[0x277D85DD0];
        block[1] = 3221225472;
        block[2] = __55__HMMTRAccessoryServer__handleUnmappedAttributeReport___block_invoke;
        block[3] = &unk_2786F0CA8;
        block[4] = self;
        dispatch_async(delegateQueue, block);
      }

      goto LABEL_22;
    }
  }

  else
  {
  }

  cluster2 = [v5 cluster];
  if ([cluster2 isEqualToNumber:&unk_283EE8A00])
  {
    attribute2 = [v5 attribute];
    v14 = [attribute2 isEqualToNumber:&unk_283EE8A18];

    if (v14)
    {
      v15 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:reportCopy];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v16 = v15;
      }

      else
      {
        v16 = 0;
      }

      v17 = v16;

      [(HMMTRAccessoryServer *)self updateSoftwareVersion:v17];
      goto LABEL_23;
    }
  }

  else
  {
  }

  cluster3 = [v5 cluster];
  if ([cluster3 isEqualToNumber:&unk_283EE8A00])
  {
    attribute3 = [v5 attribute];
    v20 = [attribute3 isEqualToNumber:&unk_283EE8A30];

    if (v20)
    {
      v21 = [HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:reportCopy];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v22 = v21;
      }

      else
      {
        v22 = 0;
      }

      v23 = v22;

      softwareVersionString = self->_softwareVersionString;
      self->_softwareVersionString = v23;

      goto LABEL_23;
    }
  }

  else
  {
  }

  cluster4 = [v5 cluster];
  v26 = [cluster4 isEqualToNumber:&unk_283EE8A48];

  if (!v26)
  {
LABEL_23:
    v28 = 0;
    goto LABEL_24;
  }

  matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
  [matterFirmwareUpdateStatus handleOTARequestorAttributeReport:reportCopy];

LABEL_22:
  v28 = 1;
LABEL_24:

  return v28;
}

void __55__HMMTRAccessoryServer__handleUnmappedAttributeReport___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) chipDelegate];
  [v2 didUpdatePairingsForAccessoryServer:*(a1 + 32)];
}

- (void)isDiscoverableWithCompletion:(id)completion
{
  completionCopy = completion;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __53__HMMTRAccessoryServer_isDiscoverableWithCompletion___block_invoke;
  v7[3] = &unk_2786EF5A8;
  v7[4] = self;
  v8 = completionCopy;
  v6 = completionCopy;
  dispatch_async(clientQueue, v7);
}

uint64_t __53__HMMTRAccessoryServer_isDiscoverableWithCompletion___block_invoke(uint64_t a1)
{
  v13 = *MEMORY[0x277D85DE8];
  if ([*(a1 + 32) removalInProgress])
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
LABEL_5:

      objc_autoreleasePoolPop(v2);
      result = (*(*(a1 + 40) + 16))(*(a1 + 40), 0);
      v8 = *MEMORY[0x277D85DE8];
      return result;
    }

    v5 = HMFGetLogIdentifier();
    v11 = 138543362;
    v12 = v5;
    v6 = "%{public}@Do not discover server - Removal in progress";
LABEL_4:
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, v6, &v11, 0xCu);

    goto LABEL_5;
  }

  if (([*(a1 + 32) mtrDeviceConnected] & 1) == 0 && objc_msgSend(*(a1 + 32), "_shouldUpdateUnreachableState"))
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      goto LABEL_5;
    }

    v5 = HMFGetLogIdentifier();
    v11 = 138543362;
    v12 = v5;
    v6 = "%{public}@Do not discover server - MTRDevice state is not reachable";
    goto LABEL_4;
  }

  v9 = *(*(a1 + 40) + 16);
  v10 = *MEMORY[0x277D85DE8];

  return v9();
}

- (void)triggerEstablishingMatterSubscription
{
  v2[0] = MEMORY[0x277D85DD0];
  v2[1] = 3221225472;
  v2[2] = __61__HMMTRAccessoryServer_triggerEstablishingMatterSubscription__block_invoke;
  v2[3] = &unk_2786F0CA8;
  v2[4] = self;
  [(HMMTRAccessoryServer *)self dispatchBlock:v2];
}

void __61__HMMTRAccessoryServer_triggerEstablishingMatterSubscription__block_invoke(uint64_t a1)
{
  v15 = *MEMORY[0x277D85DE8];
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    v2 = [*(a1 + 32) matterDevice];
    v3 = objc_opt_respondsToSelector();

    if (v3)
    {
      v4 = [*(a1 + 32) shouldReestablishSubscription];
      v5 = objc_autoreleasePoolPush();
      v6 = *(a1 + 32);
      v7 = HMFGetOSLogHandle();
      v8 = os_log_type_enabled(v7, OS_LOG_TYPE_INFO);
      if (v4)
      {
        if (v8)
        {
          v9 = HMFGetLogIdentifier();
          v13 = 138543362;
          v14 = v9;
          _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Calling MTRDevice _deviceMayBeReachable", &v13, 0xCu);
        }

        objc_autoreleasePoolPop(v5);
        v10 = [*(a1 + 32) matterDevice];
        [v10 _deviceMayBeReachable];
      }

      else
      {
        if (v8)
        {
          v11 = HMFGetLogIdentifier();
          v13 = 138543362;
          v14 = v11;
          _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Skipping calling _deviceMayBeReachable, no change in networking state since last successful subscription", &v13, 0xCu);
        }

        objc_autoreleasePoolPop(v5);
      }
    }
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (void)markAsSubscribed
{
  v10 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v8 = 138543362;
    v9 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Accessory marked as subscribed", &v8, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  [(HMMTRAccessoryServer *)selfCopy setShouldReestablishSubscription:0];
  v7 = *MEMORY[0x277D85DE8];
}

- (void)markForResubscription
{
  v10 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    v8 = 138543362;
    v9 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Accessory marked for resubscription", &v8, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  [(HMMTRAccessoryServer *)selfCopy setShouldReestablishSubscription:1];
  v7 = *MEMORY[0x277D85DE8];
}

- (void)_setupMatterDevice
{
  v30 = *MEMORY[0x277D85DE8];
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  dispatch_assert_queue_V2(clientQueue);

  isDisabled = [(HMMTRAccessoryServer *)self isDisabled];
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  v8 = os_log_type_enabled(v7, OS_LOG_TYPE_INFO);
  if (isDisabled)
  {
    if (v8)
    {
      v9 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v9;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Setup-reporting block called after server is disabled. Ignored.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  else
  {
    if (v8)
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v29 = v10;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Request to setup reporting", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    matterDevice = [(HMMTRAccessoryServer *)selfCopy matterDevice];
    v12 = matterDevice == 0;

    if (v12)
    {
      v27[0] = MEMORY[0x277D85DD0];
      v27[1] = 3221225472;
      v27[2] = __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke;
      v27[3] = &unk_2786EF6C0;
      v27[4] = selfCopy;
      v13 = MEMORY[0x2318887D0](v27);
      (v13)[2](v13, selfCopy);
      matterDevice2 = [(HMMTRAccessoryServer *)selfCopy matterDevice];
      v15 = matterDevice2 == 0;

      if (!v15 && ![(HMMTRAccessoryServer *)selfCopy controllerRevokeHandlerRegistered])
      {
        [(HMMTRAccessoryServer *)selfCopy setControllerRevokeHandlerRegistered:1];
        objc_initWeak(&location, selfCopy);
        controllerWrapper = [(HMMTRAccessoryServer *)selfCopy controllerWrapper];
        clientQueue2 = [(HAPAccessoryServer *)selfCopy clientQueue];
        v23[0] = MEMORY[0x277D85DD0];
        v23[1] = 3221225472;
        v23[2] = __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_308;
        v23[3] = &unk_2786EF6E8;
        objc_copyWeak(&v25, &location);
        v24 = v13;
        [controllerWrapper registerRevokeHandlerWithQueue:clientQueue2 handler:v23];

        v18 = objc_autoreleasePoolPush();
        v19 = selfCopy;
        v20 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          v21 = HMFGetLogIdentifier();
          *buf = 138543362;
          v29 = v21;
          _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Registered controller revoke handler", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v18);
        objc_destroyWeak(&v25);
        objc_destroyWeak(&location);
      }
    }
  }

  v22 = *MEMORY[0x277D85DE8];
}

void __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke(uint64_t a1, void *a2)
{
  v34 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = [v3 controllerWrapper];

  v5 = objc_autoreleasePoolPush();
  v6 = v3;
  v7 = HMFGetOSLogHandle();
  v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v32 = 138543362;
      v33 = v9;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Setting up MTRDevice", &v32, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
    [*(a1 + 32) markForResubscription];
    v10 = [v6 nodeID];
    v11 = [v6 deviceController];
    v12 = [v6 mtrDeviceWithNodeID:v10 controller:v11];
    [v6 setMatterDevice:v12];

    v13 = [v6 matterDevice];
    v14 = [v6 clientQueue];
    [v13 setDelegate:v6 queue:v14];

    v15 = [v6 matterDevice];
    LODWORD(v14) = [v15 deviceCachePrimed];

    v16 = [v6 reportDistributor];
    v17 = v16;
    if (v14)
    {
      [v16 allAttributesReady];
    }

    else
    {
      [v16 allAttributesNotReady];
    }

    v19 = [v6 matterDevice];
    v20 = [v19 state];
    v21 = v20 == 1;

    [v6 setMtrDeviceStateReported:v21];
    [v6 setMtrDeviceConnected:v21];
    if (v20 == 1)
    {
      v22 = [v6 browser];
      v23 = [v22 isCurrentDevicePrimaryResident];

      if (v23)
      {
        v24 = [v6 browser];
        [v24 notifyDiscoveredAccessoryServer:v6];
      }
    }

    else
    {
      v25 = [v6 matterDevice];
      v26 = [v25 deviceCachePrimed];

      if ((v26 & 1) == 0)
      {
        v27 = objc_autoreleasePoolPush();
        v28 = v6;
        v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          v30 = HMFGetLogIdentifier();
          v32 = 138543362;
          v33 = v30;
          _os_log_impl(&dword_22AEAE000, v29, OS_LOG_TYPE_INFO, "%{public}@Server starting as unreachable as MTRDevice is unreachable and its cache is not primed", &v32, 0xCu);
        }

        objc_autoreleasePoolPop(v27);
        [v28 setReachable:0];
      }
    }
  }

  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v18 = HMFGetLogIdentifier();
      v32 = 138543362;
      v33 = v18;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Not setting up MTRDevice for a disabled accessory server", &v32, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  v31 = *MEMORY[0x277D85DE8];
}

uint64_t __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_308(uint64_t a1, void *a2, char a3)
{
  v22 = *MEMORY[0x277D85DE8];
  v5 = a2;
  WeakRetained = objc_loadWeakRetained((a1 + 40));
  v7 = WeakRetained;
  if ((a3 & 1) == 0)
  {
    v13 = [WeakRetained reportDistributor];
    [v13 allAttributesNotReady];

    [v7 setMatterDevice:0];
    [v7 _flushMTRDeviceReadReadyHandlers];
    v14 = objc_autoreleasePoolPush();
    v15 = v7;
    v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      v20 = 138543362;
      v21 = v17;
      _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_INFO, "%{public}@Device controller wrapper is disabled.", &v20, 0xCu);
    }

    objc_autoreleasePoolPop(v14);
    if (v7)
    {
      goto LABEL_5;
    }

LABEL_9:
    v12 = 0;
    goto LABEL_10;
  }

  v8 = objc_autoreleasePoolPush();
  v9 = v7;
  v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = HMFGetLogIdentifier();
    v20 = 138543362;
    v21 = v11;
    _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Device controller wrapper is revoked and back online. Setting up MTRDevice again.", &v20, 0xCu);
  }

  objc_autoreleasePoolPop(v8);
  (*(*(a1 + 32) + 16))();
  if (!v7)
  {
    goto LABEL_9;
  }

LABEL_5:
  v12 = [v7 isDisabled] ^ 1;
LABEL_10:

  v18 = *MEMORY[0x277D85DE8];
  return v12;
}

- (void)setupReporting
{
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __38__HMMTRAccessoryServer_setupReporting__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = self;
  dispatch_async(clientQueue, block);
}

- (BOOL)isDisabled
{
  if ([(HAPAccessoryServer *)self isReachable])
  {
    return 0;
  }

  controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
  v3 = controllerWrapper == 0;

  return v3;
}

- (void)_flushMTRDeviceReadReadyHandlers
{
  v23 = *MEMORY[0x277D85DE8];
  pendingMTRDeviceReadReadyHandlers = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
  allValues = [pendingMTRDeviceReadReadyHandlers allValues];

  pendingMTRDeviceReadReadyHandlers2 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
  [pendingMTRDeviceReadReadyHandlers2 removeAllObjects];

  if (([allValues hmf_isEmpty] & 1) == 0)
  {
    v6 = objc_autoreleasePoolPush();
    selfCopy = self;
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      *buf = 138543362;
      v22 = v9;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Flushing all pending MTRDevice read-ready handlers", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v6);
  }

  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v10 = allValues;
  v11 = [v10 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v11)
  {
    v12 = v11;
    v13 = *v17;
    do
    {
      v14 = 0;
      do
      {
        if (*v17 != v13)
        {
          objc_enumerationMutation(v10);
        }

        (*(*(*(&v16 + 1) + 8 * v14) + 16))(*(*(&v16 + 1) + 8 * v14));
        ++v14;
      }

      while (v12 != v14);
      v12 = [v10 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v12);
  }

  v15 = *MEMORY[0x277D85DE8];
}

- (void)handleRemoveFromBrowser
{
  v12 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Handling remove from browser", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __47__HMMTRAccessoryServer_handleRemoveFromBrowser__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = selfCopy;
  dispatch_async(clientQueue, block);

  v8 = *MEMORY[0x277D85DE8];
}

uint64_t __47__HMMTRAccessoryServer_handleRemoveFromBrowser__block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) controllerWrapper];
  v3 = [*(a1 + 32) clientQueue];
  [v2 deregisterRevokeHandlersWithQueue:v3];

  v4 = [*(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  [v4 removeAllObjects];

  v5 = *(a1 + 32);

  return [v5 _flushMTRDeviceReadReadyHandlers];
}

- (void)disable
{
  v18 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v17 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@disabling", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)selfCopy matterFirmwareUpdateStatus];
  otaProviderState = [matterFirmwareUpdateStatus otaProviderState];

  if (otaProviderState == 4)
  {
    matterFirmwareUpdateStatus2 = [(HMMTRAccessoryServer *)selfCopy matterFirmwareUpdateStatus];
    [matterFirmwareUpdateStatus2 updateFirmwareUpdateStatus:0];
  }

  [(HAPAccessoryServer *)selfCopy setReachable:0];
  [(HAPAccessoryServer *)selfCopy setSecuritySessionOpen:0];
  controllerWrapper = [(HMMTRAccessoryServer *)selfCopy controllerWrapper];
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  [controllerWrapper deregisterRevokeHandlersWithQueue:clientQueue];

  [(HMMTRAccessoryServer *)selfCopy setControllerWrapper:0];
  [(HMMTRAccessoryServer *)selfCopy setMatterDevice:0];
  [(HMMTRAccessoryServer *)selfCopy setDoorLockCluster:0];
  [(HMMTRAccessoryServer *)selfCopy setDoorLockClusterFuture:0];
  reachabilityManager = [(HMMTRAccessoryServer *)selfCopy reachabilityManager];
  [reachabilityManager stop];

  clientQueue2 = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __31__HMMTRAccessoryServer_disable__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = selfCopy;
  dispatch_async(clientQueue2, block);

  v14 = *MEMORY[0x277D85DE8];
}

uint64_t __31__HMMTRAccessoryServer_disable__block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  [v2 removeAllObjects];

  v3 = *(a1 + 32);

  return [v3 _flushMTRDeviceReadReadyHandlers];
}

- (void)discoverAccessories
{
  v12 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@discoverAccessories", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = selfCopy;
  dispatch_async(clientQueue, block);

  v8 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke(uint64_t a1)
{
  v15 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) servicesEnumerated];
  v3 = *(a1 + 32);
  if (v2)
  {
    if ([v3 _delegateRespondsToSelector:sel_accessoryServer_didDiscoverAccessories_transaction_error_])
    {
      v4 = objc_autoreleasePoolPush();
      v5 = *(a1 + 32);
      v6 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        v7 = HMFGetLogIdentifier();
        *buf = 138543362;
        v14 = v7;
        _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Did discover accessories", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v4);
      v8 = [*(a1 + 32) delegateQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_303;
      block[3] = &unk_2786F0CA8;
      block[4] = *(a1 + 32);
      dispatch_async(v8, block);
    }

    if ([*(a1 + 32) mtrDeviceConnected])
    {
      [*(a1 + 32) _updateDelegateOfConnectionStatus:1 withError:0];
    }
  }

  else if ([v3 serviceEnumerationFailed] && objc_msgSend(*(a1 + 32), "_delegateRespondsToSelector:", sel_accessoryServer_didDiscoverAccessories_transaction_error_))
  {
    v9 = [*(a1 + 32) delegateQueue];
    v11[0] = MEMORY[0x277D85DD0];
    v11[1] = 3221225472;
    v11[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_2;
    v11[3] = &unk_2786F0CA8;
    v11[4] = *(a1 + 32);
    dispatch_async(v9, v11);
  }

  v10 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_303(uint64_t a1)
{
  v5 = [*(a1 + 32) delegate];
  v2 = *(a1 + 32);
  v3 = [v2 accessories];
  v4 = [v3 copy];
  [v5 accessoryServer:v2 didDiscoverAccessories:v4 transaction:0 error:0];
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_2(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v10 = 138543362;
    v11 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Did fail discovering accessories", &v10, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = [*(a1 + 32) delegate];
  v7 = *(a1 + 32);
  v8 = [MEMORY[0x277CCA9B8] hapErrorWithCode:19 description:@"Accessory enumeration failed" reason:0 suggestion:0 underlyingError:0];
  [v6 accessoryServer:v7 didDiscoverAccessories:0 transaction:0 error:v8];

  v9 = *MEMORY[0x277D85DE8];
}

- (void)listPairingsWithCompletionQueue:(id)queue completionHandler:(id)handler
{
  handlerCopy = handler;
  v8[0] = MEMORY[0x277D85DD0];
  v8[1] = 3221225472;
  v8[2] = __74__HMMTRAccessoryServer_listPairingsWithCompletionQueue_completionHandler___block_invoke;
  v8[3] = &unk_2786EF5A8;
  v8[4] = self;
  v9 = handlerCopy;
  v7 = handlerCopy;
  dispatch_async(queue, v8);
}

uint64_t __74__HMMTRAccessoryServer_listPairingsWithCompletionQueue_completionHandler___block_invoke(uint64_t a1)
{
  v10 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v8 = 138543362;
    v9 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory List Pairings a WIP", &v8, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  result = (*(*(a1 + 40) + 16))();
  v7 = *MEMORY[0x277D85DE8];
  return result;
}

- (BOOL)isPairedInStorage
{
  nodeID = [(HMMTRAccessoryServer *)self nodeID];
  if (!nodeID)
  {
    return 0;
  }

  v4 = nodeID;
  fabricID = [(HMMTRAccessoryServer *)self fabricID];

  if (!fabricID)
  {
    return 0;
  }

  knownToSystemCommissioner = [(HMMTRAccessoryServer *)self knownToSystemCommissioner];
  browser = [(HMMTRAccessoryServer *)self browser];
  v8 = browser;
  if (knownToSystemCommissioner)
  {
    storageForSystemCommissioner = [browser storageForSystemCommissioner];

    storage = [storageForSystemCommissioner pairedNodeIDsOnSystemCommissionerFabric:1];
    nodeID2 = [(HMMTRAccessoryServer *)self nodeID];
    v12 = [storage containsObject:nodeID2];
    v8 = storageForSystemCommissioner;
  }

  else
  {
    storage = [browser storage];
    nodeID2 = [storage dataSource];
    fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];
    v14 = [nodeID2 storageDataSourceForFabricUUID:fabricUUID];
    allNodeIDs = [v14 allNodeIDs];
    nodeID3 = [(HMMTRAccessoryServer *)self nodeID];
    v12 = [allNodeIDs containsObject:nodeID3];
  }

  return v12;
}

- (void)commitStagedPairing
{
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __43__HMMTRAccessoryServer_commitStagedPairing__block_invoke;
  block[3] = &unk_2786F0CA8;
  block[4] = self;
  dispatch_async(clientQueue, block);
}

void __43__HMMTRAccessoryServer_commitStagedPairing__block_invoke(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) pairedState];
  v3 = objc_autoreleasePoolPush();
  v4 = *(a1 + 32);
  v5 = HMFGetOSLogHandle();
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v2 == 2)
  {
    if (v6)
    {
      v7 = HMFGetLogIdentifier();
      v10 = 138543362;
      v11 = v7;
      _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Committing staged server by marking as paired and notifying the delegate", &v10, 0xCu);
    }

    objc_autoreleasePoolPop(v3);
    [*(a1 + 32) _finalizePairing];
  }

  else
  {
    if (v6)
    {
      v8 = HMFGetLogIdentifier();
      v10 = 138543362;
      v11 = v8;
      _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Ignoring attempt to commit a server that is not staged", &v10, 0xCu);
    }

    objc_autoreleasePoolPop(v3);
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)_onUnpairFinishedWithError:(id)error queue:(id)queue completion:(id)completion
{
  v45 = *MEMORY[0x277D85DE8];
  errorCopy = error;
  queueCopy = queue;
  completionCopy = completion;
  domain = [errorCopy domain];
  v12 = [domain isEqualToString:*MEMORY[0x277CD5120]];

  if (v12)
  {
    v13 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];

    errorCopy = v13;
  }

  [(HMMTRAccessoryServer *)self setPairedState:0];
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  accessories = [(HAPAccessoryServer *)self accessories];
  v15 = [accessories countByEnumeratingWithState:&v36 objects:v44 count:16];
  if (v15)
  {
    v16 = v15;
    v17 = *v37;
    do
    {
      for (i = 0; i != v16; ++i)
      {
        if (*v37 != v17)
        {
          objc_enumerationMutation(accessories);
        }

        v19 = *(*(&v36 + 1) + 8 * i);
        keyStore = [(HAPAccessoryServer *)self keyStore];
        identifier = [v19 identifier];
        [keyStore removeAccessoryKeyForName:identifier error:0];
      }

      v16 = [accessories countByEnumeratingWithState:&v36 objects:v44 count:16];
    }

    while (v16);
  }

  [(HMMTRAccessoryServer *)self _deleteAccessoryServerData];
  browser = [(HMMTRAccessoryServer *)self browser];
  v23 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [browser abortOperationsForAccessoryServer:self reason:v23];

  [(HMMTRAccessoryServer *)self disable];
  [(HMMTRAccessoryServer *)self setRemovalInProgress:0];
  v24 = objc_autoreleasePoolPush();
  selfCopy = self;
  v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    v27 = HMFGetLogIdentifier();
    *buf = 138543618;
    v41 = v27;
    v42 = 2112;
    v43 = errorCopy;
    _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory unpair completed. Error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v24);
  browser2 = [(HMMTRAccessoryServer *)selfCopy browser];
  v29 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [browser2 invalidateAccessoryServer:selfCopy reason:v29];

  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __68__HMMTRAccessoryServer__onUnpairFinishedWithError_queue_completion___block_invoke;
  block[3] = &unk_2786EF5A8;
  v34 = errorCopy;
  v35 = completionCopy;
  v30 = errorCopy;
  v31 = completionCopy;
  dispatch_async(queueCopy, block);

  v32 = *MEMORY[0x277D85DE8];
}

void __68__HMMTRAccessoryServer__onUnpairFinishedWithError_queue_completion___block_invoke(uint64_t a1)
{
  v2 = MEMORY[0x2318887D0](*(a1 + 40));
  if (v2)
  {
    v3 = v2;
    v2[2](v2, *(a1 + 32));
    v2 = v3;
  }
}

- (void)_unpair:(id)_unpair completion:(id)completion
{
  v33 = *MEMORY[0x277D85DE8];
  _unpairCopy = _unpair;
  completionCopy = completion;
  discriminator = self->_discriminator;
  self->_discriminator = 0;

  setUpPINCode = self->_setUpPINCode;
  self->_setUpPINCode = 0;

  deviceController = [(HMMTRAccessoryServer *)self deviceController];
  if ([(HMMTRAccessoryServer *)self isPaired]|| [(HMMTRAccessoryServer *)self commissioningCompleted])
  {
    [(HMMTRAccessoryServer *)self setRemovalInProgress:1];
    if (deviceController)
    {
      v11 = [(HMMTRAccessoryServer *)self mtrBaseDeviceWithNodeID:self->_nodeID controller:deviceController];
      if (v11)
      {
        v12 = objc_alloc(MEMORY[0x277D0F7A8]);
        clientQueue = [(HAPAccessoryServer *)self clientQueue];
        v14 = [v12 initWithQueue:clientQueue];

        *buf = _HMFThreadLocalAsyncContextPush();
        clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
        v25[0] = MEMORY[0x277D85DD0];
        v25[1] = 3221225472;
        v25[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_300;
        v25[3] = &unk_2786F0C10;
        v25[4] = self;
        v26 = _unpairCopy;
        v27 = completionCopy;
        [v11 unpairDevice:clientQueue2 completionHandler:v25];

        _HMFThreadLocalAsyncContextPop();
      }

      else
      {
        v20 = objc_autoreleasePoolPush();
        selfCopy = self;
        v22 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          v23 = HMFGetLogIdentifier();
          *buf = 138543362;
          *&buf[4] = v23;
          _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_ERROR, "%{public}@Failed to get device for unpairing. The device will not be notified of removal", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v20);
        v14 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
        [(HMMTRAccessoryServer *)selfCopy _onUnpairFinishedWithError:v14 queue:_unpairCopy completion:completionCopy];
      }
    }

    else
    {
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2;
      block[3] = &unk_2786EF5A8;
      block[4] = self;
      v29 = completionCopy;
      dispatch_async(_unpairCopy, block);
    }
  }

  else
  {
    v16 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543362;
      *&buf[4] = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@Ignoring unpair request as accessory is not paired", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v16);
    v30[0] = MEMORY[0x277D85DD0];
    v30[1] = 3221225472;
    v30[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke;
    v30[3] = &unk_2786EF5A8;
    v30[4] = selfCopy2;
    v31 = completionCopy;
    dispatch_async(_unpairCopy, v30);
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke(uint64_t a1)
{
  [*(a1 + 32) setRemoveReason:0 pairingEndContextWhenRemove:0];
  v2 = [*(a1 + 32) browser];
  v3 = *(a1 + 32);
  v4 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [v2 abortOperationsForAccessoryServer:v3 reason:v4];

  [*(a1 + 32) disable];
  v5 = [*(a1 + 32) browser];
  v6 = *(a1 + 32);
  v7 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [v5 invalidateAccessoryServer:v6 reason:v7];

  v8 = MEMORY[0x2318887D0](*(a1 + 40));
  if (v8)
  {
    v10 = v8;
    v9 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    v10[2](v10, v9);

    v8 = v10;
  }
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2(uint64_t a1)
{
  [*(a1 + 32) setRemoveReason:0 pairingEndContextWhenRemove:0];
  v2 = [*(a1 + 32) browser];
  v3 = *(a1 + 32);
  v4 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [v2 abortOperationsForAccessoryServer:v3 reason:v4];

  [*(a1 + 32) setRemovalInProgress:0];
  [*(a1 + 32) disable];
  v5 = [*(a1 + 32) browser];
  v6 = *(a1 + 32);
  v7 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [v5 invalidateAccessoryServer:v6 reason:v7];

  v8 = MEMORY[0x2318887D0](*(a1 + 40));
  if (v8)
  {
    v10 = v8;
    v9 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
    v10[2](v10, v9);

    v8 = v10;
  }
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke_300(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Unpair Status: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  [*(a1 + 32) _onUnpairFinishedWithError:v3 queue:*(a1 + 40) completion:*(a1 + 48)];

  v8 = *MEMORY[0x277D85DE8];
}

- (BOOL)removePairingForCurrentControllerOnQueue:(id)queue completion:(id)completion
{
  v57 = *MEMORY[0x277D85DE8];
  queueCopy = queue;
  completionCopy = completion;
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    v8 = objc_autoreleasePoolPush();
    selfCopy = self;
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      *&buf[4] = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server already disabled. Remove complete.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    v13 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
    [browser invalidateAccessoryServer:selfCopy reason:v13];

    completionCopy[2](completionCopy, 0);
  }

  else if ([(HMMTRAccessoryServer *)self operationDisabled]&& [(HMMTRAccessoryServer *)self operationDisabledReason]!= 1)
  {
    v23 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v25 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      v26 = HMFGetLogIdentifier();
      operationDisabledReason = [(HMMTRAccessoryServer *)selfCopy2 operationDisabledReason];
      v28 = "";
      if (operationDisabledReason == 2)
      {
        v28 = " because pairings are removed on accessory side";
      }

      *buf = 138543618;
      *&buf[4] = v26;
      *&buf[12] = 2080;
      *&buf[14] = v28;
      _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_INFO, "%{public}@Operation disabled%s. Proceeding with removing accessory on the controller side.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v23);
    browser2 = [(HMMTRAccessoryServer *)selfCopy2 browser];
    v30 = browser2;
    if (!browser2 || ([browser2 workQueue], v31 = objc_claimAutoreleasedReturnValue(), v32 = v31 == 0, v31, v32))
    {
      [(HMMTRAccessoryServer *)selfCopy2 _onUnpairFinishedWithError:0 queue:queueCopy completion:completionCopy];
    }

    else
    {
      workQueue = [v30 workQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke;
      block[3] = &unk_2786EFA60;
      v51 = v30;
      v52 = selfCopy2;
      v53 = queueCopy;
      v54 = completionCopy;
      dispatch_async(workQueue, block);
    }
  }

  else
  {
    v14 = random();
    v15 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      *&buf[4] = v18;
      *&buf[12] = 2048;
      *&buf[14] = v14;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) queued.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    *buf = 0;
    *&buf[8] = buf;
    *&buf[16] = 0x2020000000;
    v56 = 0;
    [(HMMTRAccessoryServer *)selfCopy3 setRemovalInProgress:1];
    browser3 = [(HMMTRAccessoryServer *)selfCopy3 browser];
    v20 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
    [browser3 removeAccessoryServer:selfCopy3 fromDiscoveredAccessoryServerListWithReason:v20];

    v45[0] = MEMORY[0x277D85DD0];
    v45[1] = 3221225472;
    v45[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_292;
    v45[3] = &unk_2786EF648;
    v45[4] = selfCopy3;
    v49 = v14;
    v46 = queueCopy;
    v48 = buf;
    v47 = completionCopy;
    v40[0] = MEMORY[0x277D85DD0];
    v40[1] = 3221225472;
    v40[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_296;
    v40[3] = &unk_2786EF670;
    v43 = buf;
    v44 = v14;
    v40[4] = selfCopy3;
    v41 = v46;
    v21 = v47;
    v42 = v21;
    [(HMMTRAccessoryServer *)selfCopy3 queueAccessoryOperation:v45 highPriority:1 completion:v40];
    v22 = dispatch_time(0, 5000000000);
    v36[0] = MEMORY[0x277D85DD0];
    v36[1] = 3221225472;
    v36[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_298;
    v36[3] = &unk_2786EF698;
    v36[4] = selfCopy3;
    v38 = buf;
    v39 = v14;
    v37 = v21;
    [(HMMTRAccessoryServer *)selfCopy3 dispatchAfter:v22 block:v36];

    _Block_object_dispose(buf, 8);
  }

  v34 = *MEMORY[0x277D85DE8];
  return 1;
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke(uint64_t a1)
{
  v2 = *(a1 + 32);
  v3 = *(a1 + 40);
  v4 = [MEMORY[0x277CCA9B8] hmmtrErrorWithCode:12];
  [v2 invalidateAccessoryServer:v3 reason:v4];

  v5 = [*(a1 + 40) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2;
  block[3] = &unk_2786F0EA8;
  v6 = *(a1 + 48);
  block[4] = *(a1 + 40);
  v8 = v6;
  v9 = *(a1 + 56);
  dispatch_async(v5, block);
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_292(uint64_t a1)
{
  v25 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 64);
    *buf = 138543618;
    v22 = v5;
    v23 = 2048;
    v24 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) started.", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v8 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_293;
  block[3] = &unk_2786EF5F8;
  v9 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v18 = v9;
  v15 = *(a1 + 48);
  v10 = v15;
  v20 = v15;
  v19 = v7;
  v11 = v7;
  dispatch_async(v8, block);

  v12 = [*(a1 + 32) clientQueue];
  v16[0] = MEMORY[0x277D85DD0];
  v16[1] = 3221225472;
  v16[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_3;
  v16[3] = &unk_2786EF620;
  v13 = *(a1 + 64);
  v16[4] = *(a1 + 32);
  v16[5] = v13;
  dispatch_group_notify(v11, v12, v16);

  v14 = *MEMORY[0x277D85DE8];
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_296(uint64_t a1, void *a2)
{
  v21 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      v8 = *(a1 + 64);
      *buf = 138543618;
      v18 = v7;
      v19 = 2048;
      v20 = v8;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) unscheduled.", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v4);
    v9 = *(a1 + 32);
    v10 = *MEMORY[0x277CFECD8];
    os_unfair_lock_lock_with_options();
    v11 = *(*(a1 + 56) + 8);
    if (*(v11 + 24))
    {
      os_unfair_lock_unlock((v9 + v10));
    }

    else
    {
      *(v11 + 24) = 1;
      os_unfair_lock_unlock((v9 + v10));
      v14[0] = MEMORY[0x277D85DD0];
      v14[1] = 3221225472;
      v14[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_297;
      v14[3] = &unk_2786EF5A8;
      v12 = *(a1 + 40);
      v16 = *(a1 + 48);
      v15 = v3;
      dispatch_async(v12, v14);
    }
  }

  v13 = *MEMORY[0x277D85DE8];
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_298(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  v2 = *(a1 + 32);
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = *(*(a1 + 48) + 8);
  if (*(v4 + 24))
  {
    v5 = *MEMORY[0x277D85DE8];

    os_unfair_lock_unlock((v2 + v3));
  }

  else
  {
    *(v4 + 24) = 1;
    os_unfair_lock_unlock((v2 + v3));
    v6 = objc_autoreleasePoolPush();
    v7 = *(a1 + 32);
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      v9 = HMFGetLogIdentifier();
      v10 = *(a1 + 56);
      v14 = 138543618;
      v15 = v9;
      v16 = 2048;
      v17 = v10;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_INFO, "%{public}@Characteristic Operation Queue: unpair job(%lu) timed out before completion", &v14, 0x16u);
    }

    objc_autoreleasePoolPop(v6);
    v11 = *(a1 + 40);
    v12 = [MEMORY[0x277CCA9B8] hmfErrorWithCode:13];
    (*(v11 + 16))(v11, v12);

    v13 = *MEMORY[0x277D85DE8];
  }
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_293(uint64_t a1)
{
  v17 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v16 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to remove pairing for current controller", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v11[0] = MEMORY[0x277D85DD0];
  v11[1] = 3221225472;
  v11[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_294;
  v11[3] = &unk_2786EF5D0;
  v14 = *(a1 + 64);
  v10 = *(a1 + 32);
  v6 = *(&v10 + 1);
  v7 = *(a1 + 56);
  *&v8 = *(a1 + 48);
  *(&v8 + 1) = v7;
  v12 = v10;
  v13 = v8;
  [v10 _unpair:v6 completion:v11];

  v9 = *MEMORY[0x277D85DE8];
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_3(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v8 = 138543618;
    v9 = v5;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) complete.", &v8, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  v7 = *MEMORY[0x277D85DE8];
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_294(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = *(a1 + 32);
  v5 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v6 = *(*(a1 + 64) + 8);
  if (*(v6 + 24))
  {
    os_unfair_lock_unlock((v4 + v5));
  }

  else
  {
    *(v6 + 24) = 1;
    os_unfair_lock_unlock((v4 + v5));
    v7 = *(a1 + 40);
    v8[0] = MEMORY[0x277D85DD0];
    v8[1] = 3221225472;
    v8[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_295;
    v8[3] = &unk_2786EF5A8;
    v10 = *(a1 + 56);
    v9 = v3;
    dispatch_async(v7, v8);
  }

  dispatch_group_leave(*(a1 + 48));
}

- (void)removePairing:(id)pairing completionQueue:(id)queue completionHandler:(id)handler
{
  pairingCopy = pairing;
  handlerCopy = handler;
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer_removePairing_completionQueue_completionHandler___block_invoke;
  block[3] = &unk_2786F0EA8;
  block[4] = self;
  v13 = pairingCopy;
  v14 = handlerCopy;
  v10 = handlerCopy;
  v11 = pairingCopy;
  dispatch_async(queue, block);
}

uint64_t __72__HMMTRAccessoryServer_removePairing_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  v13 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v9 = 138543618;
    v10 = v5;
    v11 = 2112;
    v12 = v6;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory Remove Pairing is a WIP. Removal requested for pairing identity %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v2);
  result = (*(*(a1 + 48) + 16))();
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

- (void)addPairing:(id)pairing completionQueue:(id)queue completionHandler:(id)handler
{
  handlerCopy = handler;
  v9[0] = MEMORY[0x277D85DD0];
  v9[1] = 3221225472;
  v9[2] = __69__HMMTRAccessoryServer_addPairing_completionQueue_completionHandler___block_invoke;
  v9[3] = &unk_2786EF5A8;
  v9[4] = self;
  v10 = handlerCopy;
  v8 = handlerCopy;
  dispatch_async(queue, v9);
}

uint64_t __69__HMMTRAccessoryServer_addPairing_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  v10 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v8 = 138543362;
    v9 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory Add Pairing is a WIP", &v8, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  result = (*(*(a1 + 40) + 16))();
  v7 = *MEMORY[0x277D85DE8];
  return result;
}

- (void)stopPairingWithError:(id *)error metricsReadyHandler:(id)handler
{
  handlerCopy = handler;
  objc_initWeak(&location, self);
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke;
  v7[3] = &unk_2786EF580;
  objc_copyWeak(&v9, &location);
  v6 = handlerCopy;
  v8 = v6;
  [(HMMTRAccessoryServer *)self dispatchBlock:v7];

  objc_destroyWeak(&v9);
  objc_destroyWeak(&location);
}

void __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke(uint64_t a1)
{
  v37 = *MEMORY[0x277D85DE8];
  WeakRetained = objc_loadWeakRetained((a1 + 40));
  v3 = objc_autoreleasePoolPush();
  v4 = WeakRetained;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    *buf = 138543362;
    v34 = v6;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@Attempting to stop pairing.", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v3);
  [v4 setPairingProgress:0];
  v30[0] = MEMORY[0x277D85DD0];
  v30[1] = 3221225472;
  v30[2] = __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke_289;
  v30[3] = &unk_2786EF558;
  v7 = *(a1 + 32);
  v30[4] = v4;
  v31 = v7;
  objc_copyWeak(&v32, (a1 + 40));
  v8 = MEMORY[0x2318887D0](v30);
  v9 = [v4 deviceController];
  v10 = [v4[56] unsignedLongLongValue];
  v29 = 0;
  [v9 stopDevicePairing:v10 error:&v29];
  v11 = v29;

  if (![v4 commissionCompletePending])
  {
    v12 = objc_autoreleasePoolPush();
    v16 = v4;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v17 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v17;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@stopPairing will not wait for metrics submission because commissioning complete callback is not guaranteed", buf, 0xCu);
    }

    goto LABEL_9;
  }

  if (v11)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = v4;
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v34 = v15;
      v35 = 2112;
      v36 = v11;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory failed to stop Pairing with Error: %@", buf, 0x16u);
    }

LABEL_9:

    objc_autoreleasePoolPop(v12);
    v8[2](v8);
    goto LABEL_10;
  }

  v19 = [v4 commissionMetricsReadyHandler];
  if (v19)
  {

    v20 = *(a1 + 32) == 0;
    v12 = objc_autoreleasePoolPush();
    v21 = v4;
    if (!v20)
    {
      v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v22 = HMFGetLogIdentifier();
        *buf = 138543362;
        v34 = v22;
        _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@Commission metrics ready handler was already set when another handler was requested. The second handler is called regardless of metrics readiness.", buf, 0xCu);
      }

      goto LABEL_9;
    }

LABEL_19:
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v28 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v28;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@stopPairing requested without metrics ready handler", buf, 0xCu);
    }

    goto LABEL_9;
  }

  v23 = *(a1 + 32) == 0;
  v12 = objc_autoreleasePoolPush();
  v24 = v4;
  if (v23)
  {
    goto LABEL_19;
  }

  v25 = v24;
  v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    v27 = HMFGetLogIdentifier();
    *buf = 138543362;
    v34 = v27;
    _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@stopPairing will wait for controller:commissioningComplete: callback before removing pairing so that Matter metrics can be propagated", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v12);
  [v25 setCommissionMetricsReadyHandler:v8];
LABEL_10:

  objc_destroyWeak(&v32);
  v18 = *MEMORY[0x277D85DE8];
}

void __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke_289(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (v2)
  {
    (*(v2 + 16))();
  }

  v3 = *(a1 + 32);
  v4 = [v3 clientQueue];
  v5[0] = MEMORY[0x277D85DD0];
  v5[1] = 3221225472;
  v5[2] = __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke_2;
  v5[3] = &unk_2786EF530;
  objc_copyWeak(&v6, (a1 + 48));
  [v3 removePairingForCurrentControllerOnQueue:v4 completion:v5];

  objc_destroyWeak(&v6);
}

void __65__HMMTRAccessoryServer_stopPairingWithError_metricsReadyHandler___block_invoke_2(uint64_t a1, void *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  v3 = a2;
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v5 = objc_autoreleasePoolPush();
  v6 = WeakRetained;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = HMFGetLogIdentifier();
    v15 = 138543618;
    v16 = v8;
    v17 = 2112;
    v18 = v3;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Pairing stopped and accessory pairing removed with error: %@", &v15, 0x16u);
  }

  objc_autoreleasePoolPop(v5);
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    v9 = objc_autoreleasePoolPush();
    v10 = v6;
    v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = HMFGetLogIdentifier();
      v15 = 138543362;
      v16 = v12;
      _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_DEBUG, "%{public}@Resetting storage state after pairing error", &v15, 0xCu);
    }

    objc_autoreleasePoolPop(v9);
    v13 = [v10 browser];
    [v13 setUpBrowserTargetFabricAndRediscoverAccessoriesForHomeFabricUUID:0];
  }

  v14 = *MEMORY[0x277D85DE8];
}

- (BOOL)tryPairingPassword:(id)password onboardingSetupPayloadString:(id)string error:(id *)error
{
  v22 = *MEMORY[0x277D85DE8];
  passwordCopy = password;
  stringCopy = string;
  locallyDiscovered = [(HMMTRAccessoryServer *)self locallyDiscovered];
  if (locallyDiscovered)
  {
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __78__HMMTRAccessoryServer_tryPairingPassword_onboardingSetupPayloadString_error___block_invoke;
    block[3] = &unk_2786EF3C8;
    block[4] = self;
    v18 = passwordCopy;
    v19 = stringCopy;
    dispatch_async(clientQueue, block);
  }

  else
  {
    v11 = objc_autoreleasePoolPush();
    selfCopy = self;
    v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = HMFGetLogIdentifier();
      *buf = 138543362;
      v21 = v14;
      _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory in current state cannot try pairing password.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v11);
  }

  v15 = *MEMORY[0x277D85DE8];
  return locallyDiscovered;
}

void __78__HMMTRAccessoryServer_tryPairingPassword_onboardingSetupPayloadString_error___block_invoke(uint64_t a1)
{
  v30 = *MEMORY[0x277D85DE8];
  v2 = MEMORY[0x277CCABB0];
  v3 = [*(a1 + 40) stringByReplacingOccurrencesOfString:@"-" withString:&stru_283ED2308];
  v4 = [v2 numberWithLongLong:{objc_msgSend(v3, "longLongValue")}];
  [*(a1 + 32) setSetUpPINCode:v4];

  [*(a1 + 32) setOnboardingSetupPayloadString:*(a1 + 48)];
  v5 = objc_autoreleasePoolPush();
  v6 = *(a1 + 32);
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    v9 = *(a1 + 40);
    v10 = [*(a1 + 32) setUpPINCode];
    v11 = *(a1 + 48);
    *buf = 138544130;
    v23 = v8;
    v24 = 2112;
    v25 = v9;
    v26 = 2112;
    v27 = v10;
    v28 = 2112;
    v29 = v11;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Move forward with pairing a discovered accessory with password: %@, used PIN code: %@, onboarding setup payload: %@", buf, 0x2Au);
  }

  objc_autoreleasePoolPop(v5);
  v12 = *(a1 + 32);
  v20 = 0;
  v21 = 0;
  [v12 _startPairingWithError:&v21 pairingEndContext:&v20];
  v13 = v21;
  v14 = v20;
  if (v13)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = *(a1 + 32);
    v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      *buf = 138543618;
      v23 = v18;
      v24 = 2112;
      v25 = v13;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v15);
    [*(a1 + 32) setPairedState:0];
    [*(a1 + 32) _handlePairingFailureWithError:v13 context:v14];
  }

  v19 = *MEMORY[0x277D85DE8];
}

- (void)setPrimaryAccessory:(id)accessory
{
  accessoryCopy = accessory;
  v5 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  if (self->_primaryAccessory)
  {
    _HMFPreconditionFailure();
    __break(1u);
  }

  else
  {
    self->_primaryAccessory = accessoryCopy;
    os_unfair_lock_unlock((self + v5));

    [(HMMTRAccessoryServer *)self _initAccessoriesForServer];
  }
}

- (void)_initAccessoriesForServer
{
  v6[1] = *MEMORY[0x277D85DE8];
  primaryAccessory = [(HMMTRAccessoryServer *)self primaryAccessory];
  v6[0] = primaryAccessory;
  v4 = [MEMORY[0x277CBEA60] arrayWithObjects:v6 count:1];
  [(HAPAccessoryServer *)self setAccessories:v4];

  v5 = *MEMORY[0x277D85DE8];
}

- (HAPAccessory)primaryAccessory
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = self->_primaryAccessory;
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (void)setPairingProgress:(unint64_t)progress
{
  v17 = *MEMORY[0x277D85DE8];
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = HMFGetLogIdentifier();
    v11 = 138543874;
    v12 = v8;
    v13 = 2048;
    progressCopy = progress;
    v15 = 2112;
    v16 = selfCopy;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Pairing progress updated: %tu for server: %@", &v11, 0x20u);
  }

  objc_autoreleasePoolPop(v5);
  v9 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  selfCopy->_pairingProgress = progress;
  os_unfair_lock_unlock((selfCopy + v9));
  v10 = *MEMORY[0x277D85DE8];
}

- (unint64_t)pairingProgress
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  pairingProgress = self->_pairingProgress;
  os_unfair_lock_unlock((self + v3));
  return pairingProgress;
}

- (BOOL)matchesSetupID:(id)d serverIdentifier:(id)identifier
{
  dCopy = d;
  identifierCopy = identifier;
  if (![(HMMTRAccessoryServer *)self isKnownToSystemCommissioner]&& dCopy | identifierCopy && [(HMMTRAccessoryServer *)self pairingProgress]!= 3)
  {
    if (dCopy)
    {
      v10 = [(HMMTRAccessoryServer *)self matchesSetupID:dCopy];
      if (identifierCopy)
      {
LABEL_8:
        identifier = [(HAPAccessoryServer *)self identifier];
        v12 = [identifier isEqualToString:identifierCopy];

LABEL_11:
        v8 = v10 & v12;
        goto LABEL_5;
      }
    }

    else
    {
      v10 = 1;
      if (identifierCopy)
      {
        goto LABEL_8;
      }
    }

    v12 = 1;
    goto LABEL_11;
  }

  v8 = 0;
LABEL_5:

  return v8;
}

- (BOOL)matchesSetupID:(id)d
{
  dCopy = d;
  if (![(HMMTRAccessoryServer *)self isDisabled])
  {
    v5 = *MEMORY[0x277CFECD8];
    os_unfair_lock_lock_with_options();
    discriminator = [(HMMTRAccessoryServer *)self discriminator];
    if (discriminator && ([(HMMTRAccessoryServer *)self setUpPINCode], v7 = objc_claimAutoreleasedReturnValue(), v7, discriminator, v7))
    {
      setUpPINCode = [(HMMTRAccessoryServer *)self setUpPINCode];
      discriminatorIsOriginatedFromShort = [(HMMTRAccessoryServer *)self discriminatorIsOriginatedFromShort];
      if (discriminatorIsOriginatedFromShort)
      {
        v10 = MEMORY[0x277CCABB0];
        discriminator2 = [(HMMTRAccessoryServer *)self discriminator];
        discriminator3 = [v10 numberWithUnsignedInteger:{objc_msgSend(discriminator2, "unsignedIntegerValue") >> 8}];
      }

      else
      {
        discriminator3 = [(HMMTRAccessoryServer *)self discriminator];
        discriminator2 = discriminator3;
      }

      v15 = [HMMTRUtilities setupIDFromSetupCode:setUpPINCode discriminator:discriminator3];
      if (discriminatorIsOriginatedFromShort)
      {
      }

      os_unfair_lock_unlock((self + v5));
      if (v15)
      {
        v13 = [v15 isEqualToString:dCopy];

        goto LABEL_8;
      }
    }

    else
    {
      os_unfair_lock_unlock((self + v5));
    }
  }

  v13 = 0;
LABEL_8:

  return v13;
}

- (void)_startLocallyDiscoveredAccessoryServerPairingWithRequest:(id)request fabricID:(id)d
{
  v61 = *MEMORY[0x277D85DE8];
  requestCopy = request;
  dCopy = d;
  vendorID = [(HMMTRAccessoryServer *)self vendorID];
  if (vendorID)
  {
  }

  else
  {
    productID = [(HMMTRAccessoryServer *)self productID];

    if (!productID)
    {
      goto LABEL_5;
    }
  }

  currentDeviceTypeFromDCL = [(HMMTRAccessoryServer *)self currentDeviceTypeFromDCL];
  vendorID2 = [(HMMTRAccessoryServer *)self vendorID];
  productID2 = [(HMMTRAccessoryServer *)self productID];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfMatterAccessoryVendorID:vendorID2 productID:productID2 deviceType:currentDeviceTypeFromDCL];

LABEL_5:
  fabricUUID = [(HMMTRAccessoryServer *)self fabricUUID];

  v14 = objc_autoreleasePoolPush();
  selfCopy = self;
  v16 = HMFGetOSLogHandle();
  v17 = v16;
  if (fabricUUID)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v18 = HMFGetLogIdentifier();
      fabricUUID2 = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
      *buf = 138543618;
      v54 = v18;
      v55 = 2112;
      v56 = fabricUUID2;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_INFO, "%{public}@Starting locally discovered accessory pairing for targetFabricUUID %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v14);
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    homeFabricControllers = [browser homeFabricControllers];
    fabricUUID3 = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
    v23 = [homeFabricControllers cachedWrapperWithTargetFabricUUID:fabricUUID3];
    [(HMMTRAccessoryServer *)selfCopy setControllerWrapper:v23];

    browser2 = [(HMMTRAccessoryServer *)selfCopy browser];
    [browser2 setCommissioneeAccessoryServer:selfCopy];

    controllerWrapper = [(HMMTRAccessoryServer *)selfCopy controllerWrapper];

    if (controllerWrapper)
    {
      controllerWrapper2 = [(HMMTRAccessoryServer *)selfCopy controllerWrapper];
      startupParams = [controllerWrapper2 startupParams];
      fabricID = [startupParams fabricID];

      if (dCopy && ([fabricID isEqual:dCopy] & 1) == 0)
      {
        v44 = objc_autoreleasePoolPush();
        v45 = selfCopy;
        v46 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          v47 = HMFGetLogIdentifier();
          fabricUUID4 = [(HMMTRAccessoryServer *)v45 fabricUUID];
          *buf = 138544130;
          v54 = v47;
          v55 = 2112;
          v56 = fabricUUID4;
          v57 = 2112;
          v58 = fabricID;
          v59 = 2112;
          v60 = dCopy;
          _os_log_impl(&dword_22AEAE000, v46, OS_LOG_TYPE_ERROR, "%{public}@fabricUUID %@ retrieved fabricID %@ while pairingRequest had fabricID %@", buf, 0x2Au);
        }

        objc_autoreleasePoolPop(v44);
        delegateQueue = [MEMORY[0x277CCA9B8] hmfErrorWithCode:11];
        v49 = [delegateQueue copy];
        v50 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v49];

        [(HMMTRAccessoryServer *)v45 _handlePairingFailureWithError:delegateQueue context:v50];
      }

      else
      {
        [(HMMTRAccessoryServer *)selfCopy setFabricID:fabricID];
        browser3 = [(HMMTRAccessoryServer *)selfCopy browser];
        fabricUUID5 = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
        [browser3 addFabricWithActiveClientForTargetFabricUUID:fabricUUID5];

        v31 = objc_autoreleasePoolPush();
        v32 = selfCopy;
        v33 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          v34 = HMFGetLogIdentifier();
          *buf = 138543362;
          v54 = v34;
          _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_INFO, "%{public}@Prompting for setup code for discovered accessory", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v31);
        delegateQueue = [(HAPAccessoryServer *)v32 delegateQueue];
        block[0] = MEMORY[0x277D85DD0];
        block[1] = 3221225472;
        block[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke;
        block[3] = &unk_2786F0CA8;
        block[4] = v32;
        dispatch_async(delegateQueue, block);
      }
    }

    else
    {
      v38 = objc_autoreleasePoolPush();
      v39 = selfCopy;
      v40 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v41 = HMFGetLogIdentifier();
        fabricUUID6 = [(HMMTRAccessoryServer *)v39 fabricUUID];
        *buf = 138543618;
        v54 = v41;
        v55 = 2112;
        v56 = fabricUUID6;
        _os_log_impl(&dword_22AEAE000, v40, OS_LOG_TYPE_ERROR, "%{public}@fabricUUID %@ didn't retrieve any fabric parameter", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v38);
      fabricID = [MEMORY[0x277CCA9B8] hmfErrorWithCode:11];
      v43 = [fabricID copy];
      delegateQueue = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v43];

      [(HMMTRAccessoryServer *)v39 _handlePairingFailureWithError:fabricID context:delegateQueue];
    }
  }

  else
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v36 = HMFGetLogIdentifier();
      *buf = 138543362;
      v54 = v36;
      _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@fabricUUID was not set before starting pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v14);
    browser = [MEMORY[0x277CCA9B8] hmfErrorWithCode:11];
    v37 = [browser copy];
    fabricID = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v37];

    [(HMMTRAccessoryServer *)selfCopy _handlePairingFailureWithError:browser context:fabricID];
  }

  v51 = *MEMORY[0x277D85DE8];
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke(uint64_t a1)
{
  v2 = [*(a1 + 32) delegate];
  [v2 accessoryServer:*(a1 + 32) promptUserForPasswordWithType:1];
}

- (void)startPairingWithRequest:(id)request
{
  requestCopy = request;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __48__HMMTRAccessoryServer_startPairingWithRequest___block_invoke;
  v7[3] = &unk_2786EF328;
  v7[4] = self;
  v8 = requestCopy;
  v6 = requestCopy;
  dispatch_async(clientQueue, v7);
}

void __48__HMMTRAccessoryServer_startPairingWithRequest___block_invoke(uint64_t a1)
{
  v29 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v6 = *(a1 + 40);
    v7 = [*(a1 + 32) fabricUUID];
    *buf = 138543874;
    v24 = v5;
    v25 = 2112;
    v26 = v6;
    v27 = 2112;
    v28 = v7;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Starting pairing with %@, server fabricUUID %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v2);
  [*(a1 + 32) setOnboardingSetupPayloadString:0];
  [*(a1 + 32) setPairingRequest:*(a1 + 40)];
  [*(a1 + 32) _setupPairingProperties];
  if ([*(a1 + 32) locallyDiscovered])
  {
    v8 = [*(a1 + 32) setupPayloadString];

    if (!v8)
    {
      if ([*(a1 + 32) _delegateRespondsToSelector:sel_accessoryServer_promptUserForPasswordWithType_])
      {
        v10 = [*(a1 + 40) chipFabricID];
        [*(a1 + 32) _startLocallyDiscoveredAccessoryServerPairingWithRequest:*(a1 + 40) fabricID:v10];
        goto LABEL_11;
      }

      v17 = objc_autoreleasePoolPush();
      v18 = *(a1 + 32);
      v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v20 = HMFGetLogIdentifier();
        *buf = 138543362;
        v24 = v20;
        _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_ERROR, "%{public}@Failed to dispatch setup code prompt request to delegate", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v17);
      v10 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277D0F1A0] code:11 userInfo:0];
      v11 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v10];
      goto LABEL_9;
    }
  }

  [*(a1 + 32) setStageNetworkScanRequested:{objc_msgSend(*(a1 + 40), "doNetworkScan")}];
  v9 = *(a1 + 32);
  v21 = 0;
  v22 = 0;
  [v9 _startPairingWithError:&v22 pairingEndContext:&v21];
  v10 = v22;
  v11 = v21;
  if (v10)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = *(a1 + 32);
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = HMFGetLogIdentifier();
      *buf = 138543618;
      v24 = v15;
      v25 = 2112;
      v26 = v10;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v12);
LABEL_9:
    [*(a1 + 32) _handlePairingFailureWithError:v10 context:v11];
  }

LABEL_11:
  v16 = *MEMORY[0x277D85DE8];
}

- (void)_setupPairingProperties
{
  v24 = *MEMORY[0x277D85DE8];
  v3 = objc_autoreleasePoolPush();
  selfCopy = self;
  v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = HMFGetLogIdentifier();
    isFeatureMatteriPhoneOnlyPairingControlEnabled();
    v7 = HMFBooleanToString();
    pairingTargetFabric = [(HMMTRAccessoryServer *)selfCopy pairingTargetFabric];
    pairingTargetFabric2 = [(HMMTRAccessoryServer *)selfCopy pairingTargetFabric];
    delegate = [pairingTargetFabric2 delegate];
    [delegate requiresRemoteFabricDataUpdate];
    v11 = HMFBooleanToString();
    v16 = 138544130;
    v17 = v6;
    v18 = 2112;
    v19 = v7;
    v20 = 2112;
    v21 = pairingTargetFabric;
    v22 = 2112;
    v23 = v11;
    _os_log_impl(&dword_22AEAE000, v5, OS_LOG_TYPE_INFO, "%{public}@_setupPairingProperties - iPhoneOnlyPairing: %@, pairingTargetFabric: %@, requiresRemoteFabricDataUpdate: %@", &v16, 0x2Au);
  }

  objc_autoreleasePoolPop(v3);
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    pairingTargetFabric3 = [(HMMTRAccessoryServer *)selfCopy pairingTargetFabric];
    if (pairingTargetFabric3)
    {
      pairingTargetFabric4 = [(HMMTRAccessoryServer *)selfCopy pairingTargetFabric];
      delegate2 = [pairingTargetFabric4 delegate];
      -[HMMTRAccessoryServer setShouldPairWithoutResident:](selfCopy, "setShouldPairWithoutResident:", [delegate2 requiresRemoteFabricDataUpdate] ^ 1);
    }

    else
    {
      [(HMMTRAccessoryServer *)selfCopy setShouldPairWithoutResident:0];
    }
  }

  else
  {
    [(HMMTRAccessoryServer *)selfCopy setShouldPairWithoutResident:0];
  }

  v15 = *MEMORY[0x277D85DE8];
}

- (void)abortStagingWithError:(id)error context:(id)context
{
  errorCopy = error;
  contextCopy = context;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __54__HMMTRAccessoryServer_abortStagingWithError_context___block_invoke;
  block[3] = &unk_2786EF3C8;
  block[4] = self;
  v12 = errorCopy;
  v13 = contextCopy;
  v9 = contextCopy;
  v10 = errorCopy;
  dispatch_async(clientQueue, block);
}

uint64_t __54__HMMTRAccessoryServer_abortStagingWithError_context___block_invoke(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v10 = 138543362;
    v11 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Aborting staging", &v10, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = [*(a1 + 32) deviceController];
  v7 = [*(a1 + 32) nodeID];
  [v6 stopDevicePairing:objc_msgSend(v7 error:{"unsignedLongLongValue"), 0}];

  result = [*(a1 + 32) _pairingComplete:*(a1 + 40) context:*(a1 + 48)];
  v9 = *MEMORY[0x277D85DE8];
  return result;
}

- (id)currentDeviceTypeFromDCL
{
  vendorID = [(HMMTRAccessoryServer *)self vendorID];

  if (vendorID)
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    vendorMetadataStore = [browser vendorMetadataStore];
    vendorID2 = [(HMMTRAccessoryServer *)self vendorID];
    productID = [(HMMTRAccessoryServer *)self productID];
    vendorID = [vendorMetadataStore retrieveVendorMetadataForVendorID:vendorID2 productID:productID];
  }

  productID2 = [(HMMTRAccessoryServer *)self productID];

  if (productID2)
  {
    productID3 = [(HMMTRAccessoryServer *)self productID];
    v10 = [vendorID productWithID:productID3];

    productID2 = [v10 deviceTypeID];

    if (productID2)
    {
      productID2 = [v10 deviceTypeID];
    }
  }

  return productID2;
}

- (BOOL)updateProductAttributes
{
  v98[1] = *MEMORY[0x277D85DE8];
  vendorID = [(HMMTRAccessoryServer *)self vendorID];

  if (vendorID)
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    vendorMetadataStore = [browser vendorMetadataStore];
    vendorID2 = [(HMMTRAccessoryServer *)self vendorID];
    productID = [(HMMTRAccessoryServer *)self productID];
    v9 = [vendorMetadataStore retrieveVendorMetadataForVendorID:vendorID2 productID:productID];

    name = [v9 name];
    [(HMMTRAccessoryServer *)self setVendorNameFromDcl:name];
  }

  else
  {
    v9 = 0;
  }

  productID2 = [(HMMTRAccessoryServer *)self productID];

  if (productID2)
  {
    productID3 = [(HMMTRAccessoryServer *)self productID];
    v73 = v9;
    v13 = [v9 productWithID:productID3];

    name2 = [v13 name];
    [(HMMTRAccessoryServer *)self setProductNameFromDcl:name2];

    categoryNumber = [v13 categoryNumber];
    LOBYTE(selfCopy2) = categoryNumber != 0;

    if (categoryNumber)
    {
      v17 = objc_autoreleasePoolPush();
      selfCopy = self;
      v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        v20 = HMFGetLogIdentifier();
        category = [(HAPAccessoryServer *)selfCopy category];
        categoryNumber2 = [v13 categoryNumber];
        *buf = 138543874;
        v76 = v20;
        v77 = 2112;
        v78 = category;
        v79 = 2112;
        v80 = categoryNumber2;
        _os_log_impl(&dword_22AEAE000, v19, OS_LOG_TYPE_INFO, "%{public}@Updating product category from %@ to %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v17);
      categoryNumber3 = [v13 categoryNumber];
      [(HAPAccessoryServer *)selfCopy setCategory:categoryNumber3];

      v23 = objc_autoreleasePoolPush();
      v24 = selfCopy;
      v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        v26 = HMFGetLogIdentifier();
        category = [v24 category];
        *buf = 138544386;
        v76 = v26;
        v77 = 2114;
        v78 = @"stagedPairingAccessoryInfo";
        v79 = 2112;
        v80 = @"Accessory Info";
        v81 = 2114;
        v82 = @"categoryNumber";
        v83 = 2112;
        v84 = category;
        _os_log_impl(&dword_22AEAE000, v25, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
      }

      objc_autoreleasePoolPop(v23);
      mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
      v28 = objc_alloc(MEMORY[0x277D17DF8]);
      category2 = [v24 category];
      if (category2)
      {
        v97 = @"categoryNumber";
        category = [v24 category];
        v98[0] = category;
        v30 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:v98 forKeys:&v97 count:1];
      }

      else
      {
        v30 = MEMORY[0x277CBEC10];
      }

      v31 = [v28 initWithTag:@"stagedPairingAccessoryInfo" data:v30];
      tagProcessorList = [v24[59] tagProcessorList];
      [mEMORY[0x277D17DE8] submitTaggedEvent:v31 processorList:tagProcessorList];

      if (category2)
      {
      }
    }

    deviceTypeID = [v13 deviceTypeID];

    if (deviceTypeID)
    {
      v34 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v35 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
      {
        v36 = HMFGetLogIdentifier();
        deviceTypeIDFromDcl = [(HMMTRAccessoryServer *)selfCopy2 deviceTypeIDFromDcl];
        deviceTypeID2 = [v13 deviceTypeID];
        *buf = 138543874;
        v76 = v36;
        v77 = 2112;
        v78 = deviceTypeIDFromDcl;
        v79 = 2112;
        v80 = deviceTypeID2;
        _os_log_impl(&dword_22AEAE000, v35, OS_LOG_TYPE_INFO, "%{public}@Updating product device type from %@ to %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v34);
      deviceTypeID3 = [v13 deviceTypeID];
      [(HMMTRAccessoryServer *)selfCopy2 setDeviceTypeIDFromDcl:deviceTypeID3];

      LOBYTE(selfCopy2) = 1;
    }

    label = [v13 label];

    if (label)
    {
      label2 = [v13 label];
      v42 = [HMMTRUtilities sanitizeHAPName:label2];

      v43 = objc_autoreleasePoolPush();
      selfCopy3 = self;
      v45 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
      {
        v46 = HMFGetLogIdentifier();
        name3 = [(HAPAccessoryServer *)selfCopy3 name];
        *buf = 138543874;
        v76 = v46;
        v77 = 2112;
        v78 = name3;
        v79 = 2112;
        v80 = v42;
        _os_log_impl(&dword_22AEAE000, v45, OS_LOG_TYPE_INFO, "%{public}@Updating product label from %@ to %@", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v43);
      if (selfCopy2)
      {
        LOBYTE(selfCopy2) = 1;
      }

      else
      {
        name4 = [(HAPAccessoryServer *)selfCopy3 name];
        LODWORD(selfCopy2) = [name4 isEqual:v42] ^ 1;
      }

      [(HAPAccessoryServer *)selfCopy3 setName:v42];
      primaryAccessory = [(HMMTRAccessoryServer *)selfCopy3 primaryAccessory];
      [primaryAccessory setName:v42];
    }

    v74 = selfCopy2;
    v72 = v13;
    v50 = objc_autoreleasePoolPush();
    selfCopy4 = self;
    v52 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
    {
      v53 = HMFGetLogIdentifier();
      v54 = [MEMORY[0x277CCABB0] numberWithInteger:{-[HMMTRAccessoryServer communicationProtocol](selfCopy4, "communicationProtocol")}];
      vendorID3 = [(HMMTRAccessoryServer *)selfCopy4 vendorID];
      productID4 = [(HMMTRAccessoryServer *)selfCopy4 productID];
      v57 = [MEMORY[0x277CCABB0] numberWithBool:{-[HMMTRAccessoryServer knownToSystemCommissioner](selfCopy4, "knownToSystemCommissioner")}];
      *buf = 138545922;
      v76 = v53;
      v77 = 2114;
      v78 = @"stagedPairingAccessoryInfo";
      v79 = 2112;
      v80 = @"Accessory Info";
      v81 = 2114;
      v82 = @"communicationProtocol";
      v83 = 2112;
      v84 = v54;
      v85 = 2114;
      v86 = @"vendorNumber";
      v87 = 2112;
      v88 = vendorID3;
      v89 = 2114;
      v90 = @"productID";
      v91 = 2112;
      v92 = productID4;
      v93 = 2114;
      v94 = @"accessoryKnownToSystemCommissioner";
      v95 = 2112;
      v96 = v57;
      _os_log_impl(&dword_22AEAE000, v52, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@", buf, 0x70u);
    }

    objc_autoreleasePoolPop(v50);
    mEMORY[0x277D17DE8]2 = [MEMORY[0x277D17DE8] sharedInstance];
    v59 = objc_alloc(MEMORY[0x277D17DF8]);
    v60 = [MEMORY[0x277CCABB0] numberWithInteger:{-[HMMTRAccessoryServer communicationProtocol](selfCopy4, "communicationProtocol")}];
    vendorID4 = [(HMMTRAccessoryServer *)selfCopy4 vendorID];
    productID5 = [(HMMTRAccessoryServer *)selfCopy4 productID];
    v63 = [MEMORY[0x277CCABB0] numberWithBool:{-[HMMTRAccessoryServer knownToSystemCommissioner](selfCopy4, "knownToSystemCommissioner")}];
    v64 = HMDTaggedLoggingCreateDictionary();
    v65 = [v59 initWithTag:@"stagedPairingAccessoryInfo" data:{v64, @"communicationProtocol", v60, @"vendorNumber", vendorID4, @"productID", productID5, @"accessoryKnownToSystemCommissioner", v63}];
    tagProcessorList2 = [(HMFActivity *)selfCopy4->_activity tagProcessorList];
    [mEMORY[0x277D17DE8]2 submitTaggedEvent:v65 processorList:tagProcessorList2];

    v9 = v73;
  }

  else
  {
    v74 = 0;
  }

  vendorID5 = [(HMMTRAccessoryServer *)self vendorID];
  productID6 = [(HMMTRAccessoryServer *)self productID];
  deviceTypeIDFromDcl2 = [(HMMTRAccessoryServer *)self deviceTypeIDFromDcl];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfMatterAccessoryVendorID:vendorID5 productID:productID6 deviceType:deviceTypeIDFromDcl2];

  v70 = *MEMORY[0x277D85DE8];
  return v74;
}

- (void)validateAttestationDeviceInfo:(id)info error:(id)error completion:(id)completion
{
  infoCopy = info;
  completionCopy = completion;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke;
  block[3] = &unk_2786F0EA8;
  block[4] = self;
  v13 = infoCopy;
  v14 = completionCopy;
  v10 = completionCopy;
  v11 = infoCopy;
  dispatch_async(clientQueue, block);
}

void __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke(id *a1)
{
  v20 = *MEMORY[0x277D85DE8];
  v2 = [a1[4] stageDeviceCredentialHandler];

  if (v2)
  {
    v3 = objc_alloc(MEMORY[0x277CD5568]);
    v4 = [a1[5] certificateDeclaration];
    v5 = [a1[5] dacCertificate];
    v6 = [a1[5] dacPAICertificate];
    v7 = [v3 initWithCertificationDeclaration:v4 deviceAttestationCertificate:v5 productAttestationIntermediateCertificate:v6];

    v8 = objc_autoreleasePoolPush();
    v9 = a1[4];
    v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v11 = HMFGetLogIdentifier();
      *buf = 138543362;
      v19 = v11;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Calling custom device credential validation handler", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v8);
    v12 = [a1[4] stageDeviceCredentialHandler];
    v16[0] = MEMORY[0x277D85DD0];
    v16[1] = 3221225472;
    v16[2] = __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke_279;
    v16[3] = &unk_2786EF8A0;
    v16[4] = a1[4];
    v17 = a1[6];
    (v12)[2](v12, v7, v16);

    v13 = *MEMORY[0x277D85DE8];
  }

  else
  {
    v14 = *(a1[6] + 2);
    v15 = *MEMORY[0x277D85DE8];

    v14();
  }
}

void __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke_279(uint64_t a1, void *a2)
{
  v13 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = *(a1 + 32);
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    v9 = 138543618;
    v10 = v7;
    v11 = 2112;
    v12 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Completed custom device credential validation with error: %@", &v9, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  (*(*(a1 + 40) + 16))();

  v8 = *MEMORY[0x277D85DE8];
}

- (void)updateVidPidWithAttestationDeviceInfo:(id)info
{
  v38 = *MEMORY[0x277D85DE8];
  infoCopy = info;
  vendorID = [(HMMTRAccessoryServer *)self vendorID];
  if (vendorID && (v6 = vendorID, [(HMMTRAccessoryServer *)self productID], v7 = objc_claimAutoreleasedReturnValue(), v7, v6, v7))
  {
    vendorID2 = [(HMMTRAccessoryServer *)self vendorID];
    basicInformationVendorID = [infoCopy basicInformationVendorID];
    if ([vendorID2 isEqualToNumber:basicInformationVendorID])
    {
      productID = [(HMMTRAccessoryServer *)self productID];
      basicInformationProductID = [infoCopy basicInformationProductID];
      v12 = [productID isEqualToNumber:basicInformationProductID];

      if (v12)
      {
        goto LABEL_13;
      }
    }

    else
    {
    }

    v13 = objc_autoreleasePoolPush();
    selfCopy = self;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      vendorID3 = [(HMMTRAccessoryServer *)selfCopy vendorID];
      productID2 = [(HMMTRAccessoryServer *)selfCopy productID];
      basicInformationVendorID2 = [infoCopy basicInformationVendorID];
      basicInformationProductID2 = [infoCopy basicInformationProductID];
      v26 = 138544642;
      v27 = v16;
      v28 = 2112;
      v29 = vendorID3;
      v30 = 2112;
      v31 = productID2;
      v32 = 2112;
      v33 = basicInformationVendorID2;
      v34 = 2112;
      v35 = basicInformationProductID2;
      v36 = 2112;
      v37 = selfCopy;
      v21 = "%{public}@Accessory vid/pid (%@/%@) mismatch with deviceAttestation. Using vid/pid from deviceAttestation (%@/%@) for accessoryServer %@";
      goto LABEL_11;
    }
  }

  else
  {
    v13 = objc_autoreleasePoolPush();
    selfCopy2 = self;
    v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v16 = HMFGetLogIdentifier();
      vendorID3 = [(HMMTRAccessoryServer *)selfCopy2 vendorID];
      productID2 = [(HMMTRAccessoryServer *)selfCopy2 productID];
      basicInformationVendorID2 = [infoCopy basicInformationVendorID];
      basicInformationProductID2 = [infoCopy basicInformationProductID];
      v26 = 138544642;
      v27 = v16;
      v28 = 2112;
      v29 = vendorID3;
      v30 = 2112;
      v31 = productID2;
      v32 = 2112;
      v33 = basicInformationVendorID2;
      v34 = 2112;
      v35 = basicInformationProductID2;
      v36 = 2112;
      v37 = selfCopy2;
      v21 = "%{public}@Accessory has nil vid/pid (%@/%@). Using vid/pid from deviceAttestation (%@/%@) for accessoryServer %@";
LABEL_11:
      _os_log_impl(&dword_22AEAE000, v15, OS_LOG_TYPE_INFO, v21, &v26, 0x3Eu);
    }
  }

  objc_autoreleasePoolPop(v13);
  basicInformationVendorID3 = [infoCopy basicInformationVendorID];
  [(HMMTRAccessoryServer *)self setVendorID:basicInformationVendorID3];

  basicInformationProductID3 = [infoCopy basicInformationProductID];
  [(HMMTRAccessoryServer *)self setProductID:basicInformationProductID3];

  [(HMMTRAccessoryServer *)self updateProductAttributes];
LABEL_13:

  v25 = *MEMORY[0x277D85DE8];
}

- (void)startStagedPairingWithDeviceCredentialHandler:(id)handler wifiScanResultsHandler:(id)resultsHandler threadScanResultsHandler:(id)scanResultsHandler readyToCancelHandler:(id)cancelHandler progressUpdateHandler:(id)updateHandler commissioneeInfoHandler:(id)infoHandler scanningNetworks:(BOOL)networks completion:(id)self0
{
  handlerCopy = handler;
  resultsHandlerCopy = resultsHandler;
  scanResultsHandlerCopy = scanResultsHandler;
  cancelHandlerCopy = cancelHandler;
  updateHandlerCopy = updateHandler;
  infoHandlerCopy = infoHandler;
  completionCopy = completion;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __213__HMMTRAccessoryServer_startStagedPairingWithDeviceCredentialHandler_wifiScanResultsHandler_threadScanResultsHandler_readyToCancelHandler_progressUpdateHandler_commissioneeInfoHandler_scanningNetworks_completion___block_invoke;
  block[3] = &unk_2786EF508;
  block[4] = self;
  v32 = handlerCopy;
  v33 = resultsHandlerCopy;
  v34 = scanResultsHandlerCopy;
  v35 = updateHandlerCopy;
  v36 = infoHandlerCopy;
  networksCopy = networks;
  v37 = completionCopy;
  v38 = cancelHandlerCopy;
  v24 = cancelHandlerCopy;
  v25 = completionCopy;
  v26 = infoHandlerCopy;
  v27 = updateHandlerCopy;
  v28 = scanResultsHandlerCopy;
  v29 = resultsHandlerCopy;
  v30 = handlerCopy;
  dispatch_async(clientQueue, block);
}

void __213__HMMTRAccessoryServer_startStagedPairingWithDeviceCredentialHandler_wifiScanResultsHandler_threadScanResultsHandler_readyToCancelHandler_progressUpdateHandler_commissioneeInfoHandler_scanningNetworks_completion___block_invoke(uint64_t a1)
{
  v15 = *MEMORY[0x277D85DE8];
  [*(a1 + 32) setPairedState:1];
  [*(a1 + 32) setStageDeviceCredentialHandler:*(a1 + 40)];
  [*(a1 + 32) setStageWiFiScanResultsHandler:*(a1 + 48)];
  [*(a1 + 32) setStageThreadScanResultsHandler:*(a1 + 56)];
  [*(a1 + 32) setStageProgressUpdateHandler:*(a1 + 64)];
  [*(a1 + 32) setStageCommissioneeInfoHandler:*(a1 + 72)];
  [*(a1 + 32) setStageNetworkScanRequested:*(a1 + 96)];
  [*(a1 + 32) setStageCompletion:*(a1 + 80)];
  v2 = *(a1 + 32);
  v3 = *(a1 + 88);
  v10 = 0;
  [v2 _startPairingWithReadyToCancelHandler:v3 error:&v10 pairingEndContext:0];
  v4 = v10;
  if (v4)
  {
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543618;
      v12 = v8;
      v13 = 2112;
      v14 = v4;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v5);
    (*(*(a1 + 80) + 16))();
    [*(a1 + 32) setPairedState:0];
    [*(a1 + 32) setStageWiFiScanResultsHandler:0];
    [*(a1 + 32) setStageThreadScanResultsHandler:0];
    [*(a1 + 32) setStageProgressUpdateHandler:0];
    [*(a1 + 32) setStageCommissioneeInfoHandler:0];
    [*(a1 + 32) setStageNetworkScanRequested:0];
    [*(a1 + 32) setStageCompletion:0];
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (void)startStagedPairingWithCompletion:(id)completion
{
  completionCopy = completion;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __57__HMMTRAccessoryServer_startStagedPairingWithCompletion___block_invoke;
  v7[3] = &unk_2786EF5A8;
  v7[4] = self;
  v8 = completionCopy;
  v6 = completionCopy;
  dispatch_async(clientQueue, v7);
}

void __57__HMMTRAccessoryServer_startStagedPairingWithCompletion___block_invoke(uint64_t a1)
{
  v18 = *MEMORY[0x277D85DE8];
  [*(a1 + 32) setPairedState:1];
  v2 = *(a1 + 32);
  v13 = 0;
  [v2 _startPairingWithError:&v13 pairingEndContext:0];
  v3 = v13;
  if (v3)
  {
    v4 = v3;
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543618;
      v15 = v8;
      v16 = 2112;
      v17 = v4;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v5);
    v9 = [v4 domain];
    v10 = [v9 isEqualToString:*MEMORY[0x277CD5120]];

    if (v10)
    {
      v11 = [MEMORY[0x277CCA9B8] hapErrorWithCode:15];

      v4 = v11;
    }

    (*(*(a1 + 40) + 16))();
    [*(a1 + 32) setPairedState:0];
  }

  else
  {
    [*(a1 + 32) setStageCompletion:*(a1 + 40)];
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (BOOL)hasNetworkProvisioningFailed:(unsigned int)failed
{
  v3 = self->_networkProvisioningFailures | failed;
  if ((~v3 & 3) == 0)
  {
    v3 |= 4u;
  }

  self->_networkProvisioningFailures = v3;
  return (v3 >> 2) & 1;
}

- (void)timerDidFire:(id)fire
{
  v27 = *MEMORY[0x277D85DE8];
  fireCopy = fire;
  residentReachabilityUpdateWaitTimer = [(HMMTRAccessoryServer *)self residentReachabilityUpdateWaitTimer];

  if (residentReachabilityUpdateWaitTimer == fireCopy)
  {
    v10 = objc_autoreleasePoolPush();
    selfCopy = self;
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      *buf = 138543362;
      v26 = v13;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, "%{public}@Waited long enough for resident to update reachability", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v10);
    [(HMMTRAccessoryServer *)selfCopy setResidentReachabilityUpdateWaitTimer:0];
  }

  else
  {
    stateCaptureConfigChangeTimer = [(HMMTRAccessoryServer *)self stateCaptureConfigChangeTimer];

    if (stateCaptureConfigChangeTimer == fireCopy)
    {
      [(HMMTRAccessoryServer *)self setStateCaptureConfigChangeTimer:0];
      v20 = MEMORY[0x277D85DD0];
      v21 = 3221225472;
      v22 = __37__HMMTRAccessoryServer_timerDidFire___block_invoke;
      v23 = &unk_2786EF4E0;
      selfCopy2 = self;
      v8 = @"ConfigurationChange";
      v9 = &v20;
      goto LABEL_9;
    }

    stateCaptureDeviceConnectedTimer = [(HMMTRAccessoryServer *)self stateCaptureDeviceConnectedTimer];

    if (stateCaptureDeviceConnectedTimer == fireCopy)
    {
      [(HMMTRAccessoryServer *)self setStateCaptureDeviceConnectedTimer:0];
      v15 = MEMORY[0x277D85DD0];
      v16 = 3221225472;
      v17 = __37__HMMTRAccessoryServer_timerDidFire___block_invoke_277;
      v18 = &unk_2786EF4E0;
      selfCopy3 = self;
      v8 = @"DeviceConnected";
      v9 = &v15;
LABEL_9:
      [(HMMTRAccessoryServer *)self generateAccessoryConfigurationForReason:v8 completionHandler:v9, v15, v16, v17, v18, selfCopy3, v20, v21, v22, v23, selfCopy2];
    }
  }

  v14 = *MEMORY[0x277D85DE8];
}

void __37__HMMTRAccessoryServer_timerDidFire___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v31 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      v12 = *(a1 + 32);
      v21 = 138543874;
      v22 = v11;
      v23 = 2112;
      v24 = v12;
      v25 = 2112;
      v26 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Accessory Configuration: completed for server:%@ with Error: %@.", &v21, 0x20u);
    }

    objc_autoreleasePoolPop(v7);
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      v14 = [*(a1 + 32) nodeID];
      v15 = [*(a1 + 32) fabricID];
      v16 = [*(a1 + 32) objectID];
      v21 = 138544386;
      v22 = v13;
      v23 = 2112;
      v24 = v14;
      v25 = 2112;
      v26 = v15;
      v27 = 2112;
      v28 = v16;
      v29 = 2112;
      v30 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration for %@/%@(%@) %@", &v21, 0x34u);
    }

    objc_autoreleasePoolPop(v7);
    v17 = [v5 copy];
    [*(a1 + 32) setPartsListStateCaptureInformation:v17];

    if ([*(a1 + 32) partsListStateCaptureHandle])
    {
      [*(a1 + 32) _deregisterPartsListStateCaptureHandler];
    }

    v18 = *(a1 + 32);
    v19 = [v18 partsListStateCaptureInformation];
    [*(a1 + 32) setPartsListStateCaptureHandle:{objc_msgSend(v18, "_registerStateCaptureHandlerWithStateCaptureInformation:", v19)}];
  }

  v20 = *MEMORY[0x277D85DE8];
}

void __37__HMMTRAccessoryServer_timerDidFire___block_invoke_277(uint64_t a1, void *a2, void *a3)
{
  v31 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 32);
  v9 = HMFGetOSLogHandle();
  v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = HMFGetLogIdentifier();
      v12 = *(a1 + 32);
      v21 = 138543874;
      v22 = v11;
      v23 = 2112;
      v24 = v12;
      v25 = 2112;
      v26 = v6;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_ERROR, "%{public}@Accessory Configuration: completed for server:%@ with Error: %@.", &v21, 0x20u);
    }

    objc_autoreleasePoolPop(v7);
  }

  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      v14 = [*(a1 + 32) nodeID];
      v15 = [*(a1 + 32) fabricID];
      v16 = [*(a1 + 32) objectID];
      v21 = 138544386;
      v22 = v13;
      v23 = 2112;
      v24 = v14;
      v25 = 2112;
      v26 = v15;
      v27 = 2112;
      v28 = v16;
      v29 = 2112;
      v30 = v5;
      _os_log_impl(&dword_22AEAE000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory Configuration for %@/%@(%@) %@", &v21, 0x34u);
    }

    objc_autoreleasePoolPop(v7);
    v17 = [v5 copy];
    [*(a1 + 32) setDeviceConnectedStateCaptureInformation:v17];

    if ([*(a1 + 32) deviceConnectedStateHandle])
    {
      [*(a1 + 32) _deregisterDeviceConnectedStateCaptureHandler];
    }

    v18 = *(a1 + 32);
    v19 = [v18 deviceConnectedStateCaptureInformation];
    [*(a1 + 32) setDeviceConnectedStateHandle:{objc_msgSend(v18, "_registerStateCaptureHandlerWithStateCaptureInformation:", v19)}];
  }

  v20 = *MEMORY[0x277D85DE8];
}

- (void)queueAccessoryOperation:(id)operation highPriority:(BOOL)priority completion:(id)completion
{
  operationCopy = operation;
  completionCopy = completion;
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke;
    block[3] = &unk_2786EF490;
    block[4] = self;
    v21 = completionCopy;
    v22 = operationCopy;
    priorityCopy = priority;
    v11 = completionCopy;
    v12 = operationCopy;
    dispatch_async(clientQueue, block);

    v13 = v21;
  }

  else
  {
    clientQueue2 = [(HAPAccessoryServer *)self clientQueue];
    v17[0] = MEMORY[0x277D85DD0];
    v17[1] = 3221225472;
    v17[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_269;
    v17[3] = &unk_2786EF4B8;
    v18 = operationCopy;
    v19 = completionCopy;
    v15 = completionCopy;
    v16 = operationCopy;
    dispatch_async(clientQueue2, v17);

    v13 = v18;
  }
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke(uint64_t a1)
{
  v35 = *MEMORY[0x277D85DE8];
  if ([*(a1 + 32) isDisabled])
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v5;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v2);
    v6 = *(a1 + 40);
    v7 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    (*(v6 + 16))(v6, v7);
  }

  else
  {
    v8 = [*(a1 + 32) browser];
    if (v8 && (v9 = v8, [*(a1 + 32) browser], v10 = objc_claimAutoreleasedReturnValue(), v11 = objc_opt_respondsToSelector(), v10, v9, (v11 & 1) != 0))
    {
      v12 = objc_autoreleasePoolPush();
      v13 = *(a1 + 32);
      v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        v15 = HMFGetLogIdentifier();
        *buf = 138543362;
        v34 = v15;
        _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_INFO, "%{public}@Connecting to an accessory for an operation", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v12);
      v16 = [*(a1 + 32) browser];
      v17 = *(a1 + 32);
      v18 = *(a1 + 56);
      v27[0] = MEMORY[0x277D85DD0];
      v27[1] = 3221225472;
      v27[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_267;
      v27[3] = &unk_2786EF468;
      v27[4] = v17;
      v28 = *(a1 + 40);
      v29 = *(a1 + 48);
      [v16 connectToAccessoryWhenAllowed:v17 highPriority:v18 completion:v27];

      v19 = v28;
    }

    else
    {
      v20 = objc_autoreleasePoolPush();
      v21 = *(a1 + 32);
      v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        v23 = HMFGetLogIdentifier();
        *buf = 138543362;
        v34 = v23;
        _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Executing an operation without connecting to the accessory", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v20);
      v24 = [*(a1 + 32) clientQueue];
      block[0] = MEMORY[0x277D85DD0];
      block[1] = 3221225472;
      block[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_266;
      block[3] = &unk_2786EF418;
      v25 = *(a1 + 40);
      block[4] = *(a1 + 32);
      v31 = v25;
      v32 = *(a1 + 48);
      dispatch_async(v24, block);

      v19 = v31;
    }
  }

  v26 = *MEMORY[0x277D85DE8];
}

uint64_t __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_269(uint64_t a1)
{
  (*(*(a1 + 32) + 16))();
  v2 = *(*(a1 + 40) + 16);

  return v2();
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_266(uint64_t a1)
{
  v13 = *MEMORY[0x277D85DE8];
  if ([*(a1 + 32) isDisabled])
  {
    v2 = objc_autoreleasePoolPush();
    v3 = *(a1 + 32);
    v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = HMFGetLogIdentifier();
      v11 = 138543362;
      v12 = v5;
      _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", &v11, 0xCu);
    }

    objc_autoreleasePoolPop(v2);
    v6 = *(a1 + 40);
    v7 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
    (*(v6 + 16))(v6, v7);

    v8 = *MEMORY[0x277D85DE8];
  }

  else
  {
    (*(*(a1 + 48) + 16))();
    v9 = *(*(a1 + 40) + 16);
    v10 = *MEMORY[0x277D85DE8];

    v9();
  }
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_267(id *a1, void *a2)
{
  v21 = *MEMORY[0x277D85DE8];
  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v5 = a1[4];
  v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = HMFGetLogIdentifier();
    *buf = 138543618;
    v18 = v7;
    v19 = 2112;
    v20 = v3;
    _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Connected to an accessory for an operation with error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v4);
  v8 = [a1[4] clientQueue];
  v12[0] = MEMORY[0x277D85DD0];
  v12[1] = 3221225472;
  v12[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_268;
  v12[3] = &unk_2786EF440;
  v13 = v3;
  v9 = a1[5];
  v14 = a1[4];
  v15 = v9;
  v16 = a1[6];
  v10 = v3;
  dispatch_async(v8, v12);

  v11 = *MEMORY[0x277D85DE8];
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_268(uint64_t a1)
{
  v15 = *MEMORY[0x277D85DE8];
  if (*(a1 + 32))
  {
    v2 = *(a1 + 48);
    v3 = *(*(a1 + 48) + 16);
    v4 = *MEMORY[0x277D85DE8];
LABEL_8:

    v3();
    return;
  }

  if (![*(a1 + 40) isDisabled])
  {
    (*(*(a1 + 56) + 16))();
    v3 = *(*(a1 + 48) + 16);
    v12 = *MEMORY[0x277D85DE8];
    goto LABEL_8;
  }

  v5 = objc_autoreleasePoolPush();
  v6 = *(a1 + 40);
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v8 = HMFGetLogIdentifier();
    v13 = 138543362;
    v14 = v8;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", &v13, 0xCu);
  }

  objc_autoreleasePoolPop(v5);
  v9 = *(a1 + 48);
  v10 = [MEMORY[0x277CCA9B8] hapErrorWithCode:1];
  (*(v9 + 16))(v9, v10);

  v11 = *MEMORY[0x277D85DE8];
}

- (void)_findSystemCommissionerPairingMatchingSetupPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager
{
  v40 = *MEMORY[0x277D85DE8];
  payloadCopy = payload;
  pairingsCopy = pairings;
  managerCopy = manager;
  if ([(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])
  {
    if ([pairingsCopy hmf_isEmpty])
    {
      v11 = objc_autoreleasePoolPush();
      selfCopy = self;
      v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = HMFGetLogIdentifier();
        *buf = 138543362;
        v37 = v14;
        _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Exhausted all system commissioner pairings to match onboarding setup payload", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v11);
      [(HMMTRAccessoryServer *)selfCopy _retryPairing];
    }

    else
    {
      v15 = [pairingsCopy objectAtIndexedSubscript:0];
      v16 = [MEMORY[0x277CCAA78] indexSetWithIndexesInRange:{1, objc_msgSend(pairingsCopy, "count") - 1}];
      v17 = [pairingsCopy objectsAtIndexes:v16];

      v18 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543618;
        v37 = v21;
        v38 = 2112;
        v39 = v15;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Checking %@ for onboarding setup payload match", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v18);
      setupPayload = [v15 setupPayload];
      v23 = [setupPayload isEqualAsOnboarding:payloadCopy];

      if (v23)
      {
        v24 = objc_autoreleasePoolPush();
        v25 = selfCopy2;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          v27 = HMFGetLogIdentifier();
          uuid = [v15 uuid];
          *buf = 138543618;
          v37 = v27;
          v38 = 2112;
          v39 = uuid;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@System commissioner pairing %@ matched onboarding payload. Checking whether it is connected.", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v24);
        uuid2 = [v15 uuid];
        v31[0] = MEMORY[0x277D85DD0];
        v31[1] = 3221225472;
        v31[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke;
        v31[3] = &unk_2786F0668;
        v31[4] = v25;
        v32 = payloadCopy;
        v33 = v17;
        v34 = managerCopy;
        v35 = v15;
        [v34 readCommissioningWindowStatusForSystemCommissionerPairingUUID:uuid2 completionHandler:v31];
      }

      else
      {
        [(HMMTRAccessoryServer *)selfCopy2 findSystemCommissionerPairingMatchingSetupPayload:payloadCopy systemCommissionerPairings:v17 pairingManager:managerCopy];
      }
    }
  }

  v30 = *MEMORY[0x277D85DE8];
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v23 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if ([*(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    if (v6)
    {
      v7 = objc_autoreleasePoolPush();
      v8 = *(a1 + 32);
      v9 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v10 = HMFGetLogIdentifier();
        *buf = 138543618;
        v20 = v10;
        v21 = 2112;
        v22 = v6;
        _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to read commissioning window status: %@. Moving on to next.", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v7);
      [*(a1 + 32) findSystemCommissionerPairingMatchingSetupPayload:*(a1 + 40) systemCommissionerPairings:*(a1 + 48) pairingManager:*(a1 + 56)];
    }

    else if ([v5 isEqual:&unk_283EE89B8])
    {
      v11 = [*(a1 + 32) clientQueue];
      v17[0] = MEMORY[0x277D85DD0];
      v17[1] = 3221225472;
      v17[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_260;
      v17[3] = &unk_2786EF328;
      v17[4] = *(a1 + 32);
      v18 = *(a1 + 64);
      dispatch_async(v11, v17);
    }

    else
    {
      v12 = objc_autoreleasePoolPush();
      v13 = *(a1 + 32);
      v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = HMFGetLogIdentifier();
        *buf = 138543618;
        v20 = v15;
        v21 = 2112;
        v22 = v5;
        _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_ERROR, "%{public}@System commissioner pairing commissioning window is open (%@). This must not be used as staged accessory for next pairing to avoid disrupting other on-going pairing attempt.", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v12);
      [*(a1 + 32) _retryPairing];
    }
  }

  v16 = *MEMORY[0x277D85DE8];
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_260(uint64_t a1)
{
  v20 = *MEMORY[0x277D85DE8];
  if ([*(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    v2 = [*(a1 + 32) browser];
    if (v2)
    {
      v3 = [*(a1 + 40) nodeID];
      v16[0] = MEMORY[0x277D85DD0];
      v16[1] = 3221225472;
      v16[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_261;
      v16[3] = &unk_2786EF3F0;
      v4 = *(a1 + 40);
      v16[4] = *(a1 + 32);
      v17 = v4;
      [v2 accessoryServerForSystemCommissionerDeviceWithNodeID:v3 completionHandler:v16];
    }

    else
    {
      v9 = objc_autoreleasePoolPush();
      v10 = *(a1 + 32);
      v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v12 = HMFGetLogIdentifier();
        *buf = 138543362;
        v19 = v12;
        _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_ERROR, "%{public}@No accessory server browser. Aborting attempt to return system commissioner accessory as staged accessory.", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v9);
      v13 = [MEMORY[0x277CCA9B8] hapErrorWithCode:15];
      v14 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v13];
      [*(a1 + 32) _handlePairingFailureWithError:v13 context:v14];
    }
  }

  else
  {
    v5 = objc_autoreleasePoolPush();
    v6 = *(a1 + 32);
    v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = HMFGetLogIdentifier();
      *buf = 138543362;
      v19 = v8;
      _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already when matching system commissioner pairing was verified to be connected.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v5);
  }

  v15 = *MEMORY[0x277D85DE8];
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_261(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = [*(a1 + 32) clientQueue];
  block[0] = MEMORY[0x277D85DD0];
  block[1] = 3221225472;
  block[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_2;
  block[3] = &unk_2786EF3C8;
  v5 = *(a1 + 40);
  block[4] = *(a1 + 32);
  v8 = v3;
  v9 = v5;
  v6 = v3;
  dispatch_async(v4, block);
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_2(uint64_t a1)
{
  v21 = *MEMORY[0x277D85DE8];
  if ([*(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    v2 = *(a1 + 40);
    v3 = objc_autoreleasePoolPush();
    v4 = *(a1 + 32);
    v5 = HMFGetOSLogHandle();
    v6 = v5;
    if (v2)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        v7 = HMFGetLogIdentifier();
        v8 = *(a1 + 40);
        v17 = 138543618;
        v18 = v7;
        v19 = 2112;
        v20 = v8;
        _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@Returning system commissioner device as staged accessory server: %@", &v17, 0x16u);
      }

      objc_autoreleasePoolPop(v3);
      [*(a1 + 32) setPairedState:3];
      v9 = [*(a1 + 32) stageCompletion];
      v9[2](v9, 1, *(a1 + 40), 0);

      [*(a1 + 32) setStageCompletion:0];
    }

    else
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v14 = HMFGetLogIdentifier();
        v15 = [*(a1 + 48) uuid];
        v17 = 138543618;
        v18 = v14;
        v19 = 2112;
        v20 = v15;
        _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch accessory server for system commissioner pairing %@", &v17, 0x16u);
      }

      objc_autoreleasePoolPop(v3);
      [*(a1 + 32) _retryPairing];
    }
  }

  else
  {
    v10 = objc_autoreleasePoolPush();
    v11 = *(a1 + 32);
    v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v13 = HMFGetLogIdentifier();
      v17 = 138543362;
      v18 = v13;
      _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already when connected staged server was retrieved", &v17, 0xCu);
    }

    objc_autoreleasePoolPop(v10);
  }

  v16 = *MEMORY[0x277D85DE8];
}

- (void)findSystemCommissionerPairingMatchingSetupPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager
{
  payloadCopy = payload;
  pairingsCopy = pairings;
  managerCopy = manager;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x277D85DD0];
  v15[1] = 3221225472;
  v15[2] = __116__HMMTRAccessoryServer_findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke;
  v15[3] = &unk_2786EF378;
  v15[4] = self;
  v16 = payloadCopy;
  v17 = pairingsCopy;
  v18 = managerCopy;
  v12 = managerCopy;
  v13 = pairingsCopy;
  v14 = payloadCopy;
  dispatch_async(clientQueue, v15);
}

- (void)_returnMatterSupportPairingAsStagedPairing
{
  v39 = *MEMORY[0x277D85DE8];
  setupPayloadString = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (setupPayloadString && (v4 = setupPayloadString, -[HMMTRAccessoryServer setupPayloadString](self, "setupPayloadString"), v5 = objc_claimAutoreleasedReturnValue(), v6 = [v5 isEqual:&stru_283ED2308], v5, v4, !v6))
  {
    v13 = MEMORY[0x277CD5528];
    setupPayloadString2 = [(HMMTRAccessoryServer *)self setupPayloadString];
    v32 = 0;
    v12 = [v13 setupPayloadWithOnboardingPayload:setupPayloadString2 error:&v32];
    v11 = v32;

    if (v11)
    {
      v15 = objc_autoreleasePoolPush();
      selfCopy = self;
      v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = HMFGetLogIdentifier();
        setupPayloadString3 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
        *buf = 138543874;
        v34 = v18;
        v35 = 2112;
        v36 = setupPayloadString3;
        v37 = 2112;
        v38 = v11;
        _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@Parsing setup payload %@ failed: %@. Failing pairing without looking for matching MatterSupport pairing", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v15);
      v20 = [MEMORY[0x277CCA9B8] hapErrorWithCode:9];
      v21 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v20];
      [(HMMTRAccessoryServer *)selfCopy _handlePairingFailureWithError:v20 context:v21];
    }

    else
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      systemCommissionerPairingManager = [browser systemCommissionerPairingManager];

      if (systemCommissionerPairingManager)
      {
        v29[0] = MEMORY[0x277D85DD0];
        v29[1] = 3221225472;
        v29[2] = __66__HMMTRAccessoryServer__returnMatterSupportPairingAsStagedPairing__block_invoke;
        v29[3] = &unk_2786EF350;
        v29[4] = self;
        v30 = v12;
        v20 = systemCommissionerPairingManager;
        v31 = v20;
        [v20 fetchSystemCommissionerPairingsWithCompletionHandler:v29];
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          *buf = 138543362;
          v34 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@No system commissioner pairing manager is available. Retrying pairing directly.", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
        [(HMMTRAccessoryServer *)selfCopy2 _retryPairing];
        v20 = 0;
      }
    }
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Pairing without onboarding payload. Hence, failing pairing without looking for matching MatterSupport pairing", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
    v11 = [MEMORY[0x277CCA9B8] hapErrorWithCode:9];
    v12 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v11];
    [(HMMTRAccessoryServer *)selfCopy3 _handlePairingFailureWithError:v11 context:v12];
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __66__HMMTRAccessoryServer__returnMatterSupportPairingAsStagedPairing__block_invoke(uint64_t a1, void *a2, void *a3)
{
  v16 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v5)
  {
    [*(a1 + 32) findSystemCommissionerPairingMatchingSetupPayload:*(a1 + 40) systemCommissionerPairings:v5 pairingManager:*(a1 + 48)];
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch system commissioner pairings as fallback for staged pairing: %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    [*(a1 + 32) _retryPairing];
  }

  v11 = *MEMORY[0x277D85DE8];
}

- (void)_tryPairingWithOnboardingPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager
{
  v39 = *MEMORY[0x277D85DE8];
  payloadCopy = payload;
  pairingsCopy = pairings;
  managerCopy = manager;
  if ([(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])
  {
    if ([pairingsCopy hmf_isEmpty])
    {
      v11 = objc_autoreleasePoolPush();
      selfCopy = self;
      v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = HMFGetLogIdentifier();
        *buf = 138543362;
        v36 = v14;
        _os_log_impl(&dword_22AEAE000, v13, OS_LOG_TYPE_INFO, "%{public}@Exhausted all system commissioner pairings to pair for onboarding setup payload", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v11);
      [(HMMTRAccessoryServer *)selfCopy _retryPairing];
    }

    else
    {
      v15 = [pairingsCopy objectAtIndexedSubscript:0];
      v16 = [MEMORY[0x277CCAA78] indexSetWithIndexesInRange:{1, objc_msgSend(pairingsCopy, "count") - 1}];
      v17 = [pairingsCopy objectsAtIndexes:v16];

      v18 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = HMFGetLogIdentifier();
        *buf = 138543618;
        v36 = v21;
        v37 = 2112;
        v38 = v15;
        _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Checking %@ for onboarding setup payload match", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v18);
      setupPayload = [v15 setupPayload];
      v23 = [setupPayload isEqualAsOnboarding:payloadCopy];

      if (v23)
      {
        v24 = objc_autoreleasePoolPush();
        v25 = selfCopy2;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          v27 = HMFGetLogIdentifier();
          uuid = [v15 uuid];
          *buf = 138543618;
          v36 = v27;
          v37 = 2112;
          v38 = uuid;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_INFO, "%{public}@System commissioner pairing %@ matched onboarding payload. Attempting to open commissioning window", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v24);
        uuid2 = [v15 uuid];
        v31[0] = MEMORY[0x277D85DD0];
        v31[1] = 3221225472;
        v31[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke;
        v31[3] = &unk_2786EF3A0;
        v31[4] = v25;
        v32 = payloadCopy;
        v33 = v17;
        v34 = managerCopy;
        [v34 openCommissioningWindowForSystemCommissionerPairingUUID:uuid2 duration:v31 completionHandler:180.0];
      }

      else
      {
        [(HMMTRAccessoryServer *)selfCopy2 tryPairingWithOnboardingPayload:payloadCopy systemCommissionerPairings:v17 pairingManager:managerCopy];
      }
    }
  }

  v30 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  v31 = *MEMORY[0x277D85DE8];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = objc_autoreleasePoolPush();
  v11 = *(a1 + 32);
  v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    v13 = HMFGetLogIdentifier();
    *buf = 138543618;
    v28 = v13;
    v29 = 2112;
    v30 = v9;
    _os_log_impl(&dword_22AEAE000, v12, OS_LOG_TYPE_DEBUG, "%{public}@System commissioner open commissioning window completed with error: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v10);
  if ([*(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    if (v9)
    {
      v14 = objc_autoreleasePoolPush();
      v15 = *(a1 + 32);
      v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = HMFGetLogIdentifier();
        *buf = 138543618;
        v28 = v17;
        v29 = 2112;
        v30 = v9;
        _os_log_impl(&dword_22AEAE000, v16, OS_LOG_TYPE_ERROR, "%{public}@Failed to open commissioning window using system commissioner pairing: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v14);
      [*(a1 + 32) tryPairingWithOnboardingPayload:*(a1 + 40) systemCommissionerPairings:*(a1 + 48) pairingManager:*(a1 + 56)];
    }

    else
    {
      v22 = [*(a1 + 32) browser];
      v23 = [*(a1 + 32) fabricUUID];
      v25[0] = MEMORY[0x277D85DD0];
      v25[1] = 3221225472;
      v25[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_257;
      v25[3] = &unk_2786EF328;
      v25[4] = *(a1 + 32);
      v26 = v7;
      [v22 setUpBrowserTargetFabricUUID:v23 completion:v25];
    }
  }

  else
  {
    v18 = objc_autoreleasePoolPush();
    v19 = *(a1 + 32);
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      v21 = HMFGetLogIdentifier();
      *buf = 138543362;
      v28 = v21;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already. Discarding open commissioning window completion.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v18);
  }

  v24 = *MEMORY[0x277D85DE8];
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_257(uint64_t a1)
{
  v2 = [*(a1 + 32) clientQueue];
  v5[0] = MEMORY[0x277D85DD0];
  v5[1] = 3221225472;
  v5[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_2;
  v5[3] = &unk_2786EF328;
  v3 = *(a1 + 40);
  v4 = *(a1 + 32);
  v6 = v3;
  v7 = v4;
  dispatch_async(v2, v5);
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_2(uint64_t a1)
{
  v31 = *MEMORY[0x277D85DE8];
  v2 = *(a1 + 32);
  v26 = 0;
  v3 = [MEMORY[0x277CD5528] setupPayloadWithOnboardingPayload:v2 error:&v26];
  v4 = v26;
  [*(a1 + 40) setSetupPayloadForPairingUsingMatterSupport:v3];
  v5 = *(a1 + 40);
  v6 = [v5 browser];
  [v6 setCommissioneeAccessoryServer:v5];

  v7 = objc_autoreleasePoolPush();
  v8 = *(a1 + 40);
  v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v10 = HMFGetLogIdentifier();
    v11 = *(a1 + 32);
    *buf = 138543618;
    v28 = v10;
    v29 = 2112;
    v30 = v11;
    _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempting to pair using new setup code as fallback: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v7);
  v12 = [*(a1 + 40) deviceController];
  if (v12)
  {
    v13 = *(a1 + 40);
    v14 = [v13 clientQueue];
    [v12 setDeviceControllerDelegate:v13 queue:v14];

    v15 = *(*(a1 + 40) + 448);
    v25 = v4;
    [v12 setupCommissioningSessionWithPayload:v3 newNodeID:v15 error:&v25];
    v16 = v25;
  }

  else
  {
    v16 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
  }

  v17 = v16;

  if (v17)
  {
    v18 = objc_autoreleasePoolPush();
    v19 = *(a1 + 40);
    v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = HMFGetLogIdentifier();
      *buf = 138543618;
      v28 = v21;
      v29 = 2112;
      v30 = v17;
      _os_log_impl(&dword_22AEAE000, v20, OS_LOG_TYPE_ERROR, "%{public}@Failed to setup commissioning session with MatterSupport ECM: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v18);
    v22 = [*(a1 + 40) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_258;
    block[3] = &unk_2786F0CA8;
    block[4] = *(a1 + 40);
    dispatch_async(v22, block);
  }

  v23 = *MEMORY[0x277D85DE8];
}

- (void)tryPairingWithOnboardingPayload:(id)payload systemCommissionerPairings:(id)pairings pairingManager:(id)manager
{
  payloadCopy = payload;
  pairingsCopy = pairings;
  managerCopy = manager;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x277D85DD0];
  v15[1] = 3221225472;
  v15[2] = __98__HMMTRAccessoryServer_tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke;
  v15[3] = &unk_2786EF378;
  v15[4] = self;
  v16 = payloadCopy;
  v17 = pairingsCopy;
  v18 = managerCopy;
  v12 = managerCopy;
  v13 = pairingsCopy;
  v14 = payloadCopy;
  dispatch_async(clientQueue, v15);
}

- (void)_tryPairingUsingMatterSupport
{
  v39 = *MEMORY[0x277D85DE8];
  setupPayloadString = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (setupPayloadString && (v4 = setupPayloadString, -[HMMTRAccessoryServer setupPayloadString](self, "setupPayloadString"), v5 = objc_claimAutoreleasedReturnValue(), v6 = [v5 isEqual:&stru_283ED2308], v5, v4, !v6))
  {
    v11 = MEMORY[0x277CD5528];
    setupPayloadString2 = [(HMMTRAccessoryServer *)self setupPayloadString];
    v32 = 0;
    v13 = [v11 setupPayloadWithOnboardingPayload:setupPayloadString2 error:&v32];
    v14 = v32;

    if (v14)
    {
      v15 = objc_autoreleasePoolPush();
      selfCopy = self;
      v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = HMFGetLogIdentifier();
        setupPayloadString3 = [(HMMTRAccessoryServer *)selfCopy setupPayloadString];
        *buf = 138543874;
        v34 = v18;
        v35 = 2112;
        v36 = setupPayloadString3;
        v37 = 2112;
        v38 = v14;
        _os_log_impl(&dword_22AEAE000, v17, OS_LOG_TYPE_ERROR, "%{public}@Parsing setup payload %@ failed: %@. Failing pairing without trying with MatterSupport", buf, 0x20u);
      }

      objc_autoreleasePoolPop(v15);
      v20 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:2 error:v14];
      v21 = [MEMORY[0x277CCA9B8] hapErrorWithCode:9];
      [(HMMTRAccessoryServer *)selfCopy _handlePairingFailureWithError:v21 context:v20];
    }

    else
    {
      browser = [(HMMTRAccessoryServer *)self browser];
      systemCommissionerPairingManager = [browser systemCommissionerPairingManager];

      if (systemCommissionerPairingManager)
      {
        [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:1];
        v29[0] = MEMORY[0x277D85DD0];
        v29[1] = 3221225472;
        v29[2] = __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke;
        v29[3] = &unk_2786EF350;
        v29[4] = self;
        v30 = v13;
        v20 = systemCommissionerPairingManager;
        v31 = v20;
        [v20 fetchSystemCommissionerPairingsWithCompletionHandler:v29];
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          *buf = 138543362;
          v34 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@No system commissioner pairing manager is available. Retrying pairing directly.", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
        [(HMMTRAccessoryServer *)selfCopy2 _retryPairing];
        v20 = 0;
      }
    }
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    selfCopy3 = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543362;
      v34 = v10;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_INFO, "%{public}@Nearby accessory pairing flow. Hence, cannot try with MatterSupport. Retrying pairing directly.", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v7);
    [(HMMTRAccessoryServer *)selfCopy3 _retryPairing];
  }

  v28 = *MEMORY[0x277D85DE8];
}

void __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke(uint64_t a1, void *a2, void *a3)
{
  v18 = *MEMORY[0x277D85DE8];
  v5 = a2;
  v6 = a3;
  if (v5)
  {
    [*(a1 + 32) tryPairingWithOnboardingPayload:*(a1 + 40) systemCommissionerPairings:v5 pairingManager:*(a1 + 48)];
  }

  else
  {
    v7 = objc_autoreleasePoolPush();
    v8 = *(a1 + 32);
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = HMFGetLogIdentifier();
      *buf = 138543618;
      v15 = v10;
      v16 = 2112;
      v17 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch system commissioner pairings to try matching setup payload: %@", buf, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
    v11 = [*(a1 + 32) clientQueue];
    block[0] = MEMORY[0x277D85DD0];
    block[1] = 3221225472;
    block[2] = __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke_254;
    block[3] = &unk_2786F0CA8;
    block[4] = *(a1 + 32);
    dispatch_async(v11, block);
  }

  v12 = *MEMORY[0x277D85DE8];
}

- (void)_retryPairing
{
  v40 = *MEMORY[0x277D85DE8];
  if (![(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])
  {
    goto LABEL_26;
  }

  [(HMMTRAccessoryServer *)self _clearCommissioneeInfoAfterPairingCompletion];
  [(HMMTRAccessoryServer *)self setCommissioningFailureOverridingError:0];
  if ([(HMMTRAccessoryServer *)self pairingUsingMatterSupport])
  {
    goto LABEL_3;
  }

  [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:1];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    stageCompletion = [(HMMTRAccessoryServer *)self stageCompletion];

    v15 = objc_autoreleasePoolPush();
    selfCopy = self;
    v17 = HMFGetOSLogHandle();
    v18 = v17;
    if (!stageCompletion)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v34 = HMFGetLogIdentifier();
        *buf = 138543362;
        v37 = v34;
        _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_ERROR, "%{public}@No fallback for failed pairing system commissioner with no staging interface. Will keep retrying with original setup payload.", buf, 0xCu);
      }

      objc_autoreleasePoolPop(v15);
LABEL_3:
      [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:0];
      [(HMMTRAccessoryServer *)self setSetupPayloadForPairingUsingMatterSupport:0];
      browser = [(HMMTRAccessoryServer *)self browser];
      if (browser)
      {
        _pairingSetupPayload = [(HMMTRAccessoryServer *)self _pairingSetupPayload];
        v5 = objc_autoreleasePoolPush();
        selfCopy2 = self;
        v7 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          v8 = HMFGetLogIdentifier();
          *buf = 138543618;
          v37 = v8;
          v38 = 2112;
          v39 = _pairingSetupPayload;
          _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Retrying pairing with setup payload: %@", buf, 0x16u);
        }

        objc_autoreleasePoolPop(v5);
        [browser setCommissioneeAccessoryServer:selfCopy2];
        deviceController = [(HMMTRAccessoryServer *)selfCopy2 deviceController];
        if (deviceController)
        {
          clientQueue = [(HAPAccessoryServer *)selfCopy2 clientQueue];
          [deviceController setDeviceControllerDelegate:selfCopy2 queue:clientQueue];

          nodeID = selfCopy2->_nodeID;
          v35 = 0;
          [deviceController setupCommissioningSessionWithPayload:_pairingSetupPayload newNodeID:nodeID error:&v35];
          v12 = v35;
          v13 = [HMMTRAccessoryPairingEndContext mtrContextWithStep:2 error:v12];
        }

        else
        {
          v12 = [MEMORY[0x277CCA9B8] errorWithDomain:*MEMORY[0x277CD5120] code:6 userInfo:0];
          v13 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v12];
        }

        v28 = v13;
        if (v12)
        {
          v29 = objc_autoreleasePoolPush();
          v30 = selfCopy2;
          v31 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            v32 = HMFGetLogIdentifier();
            *buf = 138543618;
            v37 = v32;
            v38 = 2112;
            v39 = v12;
            _os_log_impl(&dword_22AEAE000, v31, OS_LOG_TYPE_ERROR, "%{public}@Failed to setup commissioning session: %@", buf, 0x16u);
          }

          objc_autoreleasePoolPop(v29);
          [(HMMTRAccessoryServer *)v30 _pairingComplete:v12 context:v28];
        }
      }

      else
      {
        v24 = objc_autoreleasePoolPush();
        selfCopy3 = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          *buf = 138543362;
          v37 = v27;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Browser is gone. Stopping pairing attempt.", buf, 0xCu);
        }

        objc_autoreleasePoolPop(v24);
        _pairingSetupPayload = [MEMORY[0x277CCA9B8] hapErrorWithCode:15];
        v12 = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:_pairingSetupPayload];
        [(HMMTRAccessoryServer *)selfCopy3 _handlePairingFailureWithError:_pairingSetupPayload context:v12];
      }

      goto LABEL_26;
    }

    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      v19 = HMFGetLogIdentifier();
      *buf = 138543362;
      v37 = v19;
      _os_log_impl(&dword_22AEAE000, v18, OS_LOG_TYPE_INFO, "%{public}@Trying to find an existing System Commissioner pairing as a fallback", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v15);
    [(HMMTRAccessoryServer *)selfCopy _returnMatterSupportPairingAsStagedPairing];
  }

  else
  {
    v20 = objc_autoreleasePoolPush();
    selfCopy4 = self;
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      *buf = 138543362;
      v37 = v23;
      _os_log_impl(&dword_22AEAE000, v22, OS_LOG_TYPE_INFO, "%{public}@Trying to pair using MatterSupport", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v20);
    [(HMMTRAccessoryServer *)selfCopy4 _tryPairingUsingMatterSupport];
  }

LABEL_26:
  v33 = *MEMORY[0x277D85DE8];
}

- (void)startPairingMetricWithActivity:(id)activity
{
  activityCopy = activity;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x277D85DD0];
  v7[1] = 3221225472;
  v7[2] = __55__HMMTRAccessoryServer_startPairingMetricWithActivity___block_invoke;
  v7[3] = &unk_2786EF328;
  v7[4] = self;
  v8 = activityCopy;
  v6 = activityCopy;
  dispatch_async(clientQueue, v7);
}

void __55__HMMTRAccessoryServer_startPairingMetricWithActivity___block_invoke(uint64_t a1)
{
  v68 = *MEMORY[0x277D85DE8];
  objc_storeStrong((*(a1 + 32) + 472), *(a1 + 40));
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    v34 = v2;
    v6 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(*(a1 + 32), "communicationProtocol")}];
    v7 = [*(a1 + 32) category];
    v8 = [*(a1 + 32) vendorID];
    v9 = [*(a1 + 32) productID];
    v10 = [MEMORY[0x277CCABB0] numberWithBool:{objc_msgSend(*(a1 + 32), "discoveredOverBLE")}];
    v11 = [MEMORY[0x277CCABB0] numberWithBool:{objc_msgSend(*(a1 + 32), "knownToSystemCommissioner")}];
    *buf = 138546946;
    v39 = v5;
    v40 = 2114;
    v41 = @"stagedPairingAccessoryInfo";
    v42 = 2112;
    v43 = @"Accessory Info";
    v44 = 2114;
    v45 = @"communicationProtocol";
    v46 = 2112;
    v47 = v6;
    v48 = 2114;
    v49 = @"categoryNumber";
    v50 = 2112;
    v51 = v7;
    v52 = 2114;
    v53 = @"vendorNumber";
    v54 = 2112;
    v55 = v8;
    v56 = 2114;
    v57 = @"productID";
    v58 = 2112;
    v59 = v9;
    v60 = 2114;
    v61 = @"accessoryDiscoveredOverBLE";
    v62 = 2112;
    v63 = v10;
    v64 = 2114;
    v65 = @"accessoryKnownToSystemCommissioner";
    v66 = 2112;
    v67 = v11;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@ %{public}@=%@", buf, 0x98u);

    v2 = v34;
  }

  objc_autoreleasePoolPop(v2);
  v35 = [MEMORY[0x277D17DE8] sharedInstance];
  v12 = objc_alloc(MEMORY[0x277D17DF8]);
  v33 = [MEMORY[0x277CCABB0] numberWithInteger:{objc_msgSend(*(a1 + 32), "communicationProtocol")}];
  v13 = [*(a1 + 32) category];
  v14 = [*(a1 + 32) vendorID];
  v15 = [*(a1 + 32) productID];
  v16 = [MEMORY[0x277CCABB0] numberWithBool:{objc_msgSend(*(a1 + 32), "discoveredOverBLE")}];
  v17 = [MEMORY[0x277CCABB0] numberWithBool:{objc_msgSend(*(a1 + 32), "knownToSystemCommissioner")}];
  v18 = HMDTaggedLoggingCreateDictionary();
  v19 = [v12 initWithTag:@"stagedPairingAccessoryInfo" data:{v18, @"communicationProtocol", v33, @"categoryNumber", v13, @"vendorNumber", v14, @"productID", v15, @"accessoryDiscoveredOverBLE", v16, @"accessoryKnownToSystemCommissioner", v17}];
  v20 = [*(*(a1 + 32) + 472) tagProcessorList];
  [v35 submitTaggedEvent:v19 processorList:v20];

  v21 = objc_autoreleasePoolPush();
  v22 = *(a1 + 32);
  v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    v24 = HMFGetLogIdentifier();
    v25 = [*(a1 + 32) softwareVersionString];
    *buf = 138544386;
    v39 = v24;
    v40 = 2114;
    v41 = @"firmwareVersion";
    v42 = 2112;
    v43 = @"Firmware version";
    v44 = 2114;
    v45 = @"firmwareVersion";
    v46 = 2112;
    v47 = v25;
    _os_log_impl(&dword_22AEAE000, v23, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
  }

  objc_autoreleasePoolPop(v21);
  v26 = [MEMORY[0x277D17DE8] sharedInstance];
  v27 = objc_alloc(MEMORY[0x277D17DF8]);
  v28 = [*(a1 + 32) softwareVersionString];
  if (v28)
  {
    v36 = @"firmwareVersion";
    v23 = [*(a1 + 32) softwareVersionString];
    v37 = v23;
    v29 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v37 forKeys:&v36 count:1];
  }

  else
  {
    v29 = MEMORY[0x277CBEC10];
  }

  v30 = [v27 initWithTag:@"firmwareVersion" data:v29];
  v31 = [*(*(a1 + 32) + 472) tagProcessorList];
  [v26 submitTaggedEvent:v30 processorList:v31];

  if (v28)
  {
  }

  v32 = *MEMORY[0x277D85DE8];
}

- (void)_startPairingWithReadyToCancelHandler:(id)handler error:(id *)error pairingEndContext:(id *)context
{
  v66 = *MEMORY[0x277D85DE8];
  handlerCopy = handler;
  browser = [(HMMTRAccessoryServer *)self browser];
  attestationStatus = [browser attestationStatus];
  [attestationStatus setAccessoryServer:self];

  browser2 = [(HMMTRAccessoryServer *)self browser];
  [browser2 setCommissioneeAccessoryServer:self];

  vendorID = [(HMMTRAccessoryServer *)self vendorID];
  if (vendorID)
  {
  }

  else
  {
    productID = [(HMMTRAccessoryServer *)self productID];

    if (!productID)
    {
      goto LABEL_5;
    }
  }

  currentDeviceTypeFromDCL = [(HMMTRAccessoryServer *)self currentDeviceTypeFromDCL];
  vendorID2 = [(HMMTRAccessoryServer *)self vendorID];
  productID2 = [(HMMTRAccessoryServer *)self productID];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfMatterAccessoryVendorID:vendorID2 productID:productID2 deviceType:currentDeviceTypeFromDCL];

LABEL_5:
  controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
  [controllerWrapper resume];

  deviceController = [(HMMTRAccessoryServer *)self deviceController];
  if ([deviceController isRunning])
  {
    v19 = [objc_alloc(MEMORY[0x277D0F770]) initWithName:@"CHIP Accessory Pairing"];
    activity = self->_activity;
    self->_activity = v19;

    if (![(HMMTRAccessoryServer *)self hasPriorSuccessfulPairing])
    {
      [(HMMTRAccessoryServer *)self _prepareThreadCredentials];
    }

    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    [deviceController setDeviceControllerDelegate:self queue:clientQueue];

    _pairingSetupPayload = [(HMMTRAccessoryServer *)self _pairingSetupPayload];
    if (_pairingSetupPayload)
    {
      v23 = _pairingSetupPayload;
      [(HMMTRAccessoryServer *)self setCommissioningSessionEstablished:0];
      [(HMMTRAccessoryServer *)self setCommissioningCompleted:0];
      [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:0];
      [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:2];
      if ([(HMMTRAccessoryServer *)self accessoryWithSameDiscriminatorDiscovered])
      {
        [(HMMTRAccessoryServer *)self _notifyDelegateOfAccessoryMatchingCommissioningDiscriminatorDiscovered];
      }

      [deviceController setupCommissioningSessionWithPayload:v23 newNodeID:self->_nodeID error:error];
      v52 = handlerCopy;
      if (*error)
      {
        if (context)
        {
          *context = [HMMTRAccessoryPairingEndContext mtrContextWithStep:2 error:?];
        }

        v24 = objc_autoreleasePoolPush();
        selfCopy = self;
        v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          v27 = HMFGetLogIdentifier();
          v28 = v27;
          v29 = *error;
          if (context)
          {
            v30 = *context;
          }

          else
          {
            v30 = 0;
          }

          *buf = 138543874;
          v57 = v27;
          v58 = 2112;
          v59 = v29;
          v60 = 2112;
          v61 = v30;
          _os_log_impl(&dword_22AEAE000, v26, OS_LOG_TYPE_ERROR, "%{public}@Error setup commissioning session %@, context %@", buf, 0x20u);
        }

        objc_autoreleasePoolPop(v24);
      }

      v37 = objc_autoreleasePoolPush();
      selfCopy2 = self;
      v39 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        v40 = HMFGetLogIdentifier();
        *buf = 138543618;
        v57 = v40;
        v58 = 2112;
        v59 = selfCopy2;
        _os_log_impl(&dword_22AEAE000, v39, OS_LOG_TYPE_INFO, "%{public}@Starting pairing for accessory: %@", buf, 0x16u);
      }

      objc_autoreleasePoolPop(v37);
      if (isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled())
      {
        browser3 = [(HMMTRAccessoryServer *)selfCopy2 browser];
        [browser3 enableUnrestrictedOperationsForAccessoryServer:selfCopy2];
      }

      v42 = objc_autoreleasePoolPush();
      v43 = selfCopy2;
      v44 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
      {
        v45 = HMFGetLogIdentifier();
        *buf = 138544386;
        v57 = v45;
        v58 = 2114;
        v59 = @"hmmtrAccessoryPairingStart";
        v60 = 2112;
        v61 = @"Pairing start";
        v62 = 2114;
        v63 = @"transport";
        v64 = 2112;
        v65 = @"unknown";
        _os_log_impl(&dword_22AEAE000, v44, OS_LOG_TYPE_INFO, "%{public}@tag=%{public}@ desc=%@ %{public}@=%@", buf, 0x34u);
      }

      objc_autoreleasePoolPop(v42);
      mEMORY[0x277D17DE8] = [MEMORY[0x277D17DE8] sharedInstance];
      v47 = objc_alloc(MEMORY[0x277D17DF8]);
      v54 = @"transport";
      v55 = @"unknown";
      v48 = [MEMORY[0x277CBEAC0] dictionaryWithObjects:&v55 forKeys:&v54 count:1];
      v49 = [v47 initWithTag:@"hmmtrAccessoryPairingStart" data:v48];
      tagProcessorList = [(HMFActivity *)self->_activity tagProcessorList];
      [mEMORY[0x277D17DE8] submitTaggedEvent:v49 processorList:tagProcessorList];

      [(HMMTRAccessoryServer *)v43 setCommissioningFailureOverridingError:0];
      [(HMMTRAccessoryServer *)v43 setPairingProgress:1];
      handlerCopy = v52;
      if (v52)
      {
        v53[0] = MEMORY[0x277D85DD0];
        v53[1] = 3221225472;
        v53[2] = __86__HMMTRAccessoryServer__startPairingWithReadyToCancelHandler_error_pairingEndContext___block_invoke;
        v53[3] = &unk_2786F0CA8;
        v53[4] = v43;
        (*(v52 + 2))(v52, v53);
      }
    }

    else
    {
      v36 = [MEMORY[0x277CCA9B8] hapErrorWithCode:9];
      *error = v36;
      if (context)
      {
        *context = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v36];
      }

      v23 = 0;
    }

LABEL_36:

    goto LABEL_37;
  }

  v31 = objc_autoreleasePoolPush();
  selfCopy3 = self;
  v33 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    v34 = HMFGetLogIdentifier();
    controllerWrapper2 = [(HMMTRAccessoryServer *)selfCopy3 controllerWrapper];
    *buf = 138543618;
    v57 = v34;
    v58 = 2112;
    v59 = controllerWrapper2;
    _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_ERROR, "%{public}@CHIP Stack is not running. Controller wrapper: %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v31);
  if (error)
  {
    v23 = [MEMORY[0x277CCA9B8] hapErrorWithCode:3 marker:240];
    *error = v23;
    if (context)
    {
      *context = [HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v23];
    }

    goto LABEL_36;
  }

LABEL_37:

  v51 = *MEMORY[0x277D85DE8];
}

uint64_t __86__HMMTRAccessoryServer__startPairingWithReadyToCancelHandler_error_pairingEndContext___block_invoke(uint64_t a1)
{
  v12 = *MEMORY[0x277D85DE8];
  v2 = objc_autoreleasePoolPush();
  v3 = *(a1 + 32);
  v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    *buf = 138543362;
    v11 = v5;
    _os_log_impl(&dword_22AEAE000, v4, OS_LOG_TYPE_INFO, "%{public}@Staging is cancelled", buf, 0xCu);
  }

  objc_autoreleasePoolPop(v2);
  v6 = *(a1 + 32);
  v9 = 0;
  result = [v6 stopPairingWithError:&v9];
  v8 = *MEMORY[0x277D85DE8];
  return result;
}

- (NSData)rootPublicKey
{
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    browser = [(HMMTRAccessoryServer *)self browser];
    systemCommissionerFabricRootPublicKey = [browser systemCommissionerFabricRootPublicKey];
  }

  else
  {
    browser = [(HMMTRAccessoryServer *)self controllerWrapper];
    startupParams = [browser startupParams];
    systemCommissionerFabricRootPublicKey = [startupParams rootPublicKey];
  }

  return systemCommissionerFabricRootPublicKey;
}

- (void)notifyMatterFirmwareRevisionNumberCharacteristicChanged
{
  if (self->_softwareVersionNumber)
  {
    objc_initWeak(&location, self);
    v3 = dispatch_time(0, 100000000);
    clientQueue = [(HAPAccessoryServer *)self clientQueue];
    v5[0] = MEMORY[0x277D85DD0];
    v5[1] = 3221225472;
    v5[2] = __79__HMMTRAccessoryServer_notifyMatterFirmwareRevisionNumberCharacteristicChanged__block_invoke;
    v5[3] = &unk_2786EF2B8;
    objc_copyWeak(&v6, &location);
    dispatch_after(v3, clientQueue, v5);

    objc_destroyWeak(&v6);
    objc_destroyWeak(&location);
  }
}

void __79__HMMTRAccessoryServer_notifyMatterFirmwareRevisionNumberCharacteristicChanged__block_invoke(uint64_t a1)
{
  v44 = *MEMORY[0x277D85DE8];
  WeakRetained = objc_loadWeakRetained((a1 + 32));
  v2 = objc_alloc_init(MEMORY[0x277CBEB18]);
  v34 = 0u;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v3 = [WeakRetained primaryAccessory];
  v4 = [v3 services];

  v5 = [v4 countByEnumeratingWithState:&v34 objects:v43 count:16];
  if (v5)
  {
    v6 = v5;
    v7 = *v35;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*v35 != v7)
        {
          objc_enumerationMutation(v4);
        }

        v9 = *(*(&v34 + 1) + 8 * i);
        v10 = [v9 type];
        v11 = [v10 isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v11)
        {
          v32 = 0u;
          v33 = 0u;
          v30 = 0u;
          v31 = 0u;
          v12 = [v9 characteristics];
          v13 = [v12 countByEnumeratingWithState:&v30 objects:v42 count:16];
          if (v13)
          {
            v14 = v13;
            v15 = *v31;
            v29 = v2;
            while (2)
            {
              for (j = 0; j != v14; ++j)
              {
                if (*v31 != v15)
                {
                  objc_enumerationMutation(v12);
                }

                v17 = *(*(&v30 + 1) + 8 * j);
                v18 = [v17 type];
                v19 = [v18 isEqualToString:@"0000026D-0000-1000-8000-0026BB765291"];

                if (v19)
                {
                  v20 = [v17 copy];
                  v21 = [v17 service];
                  [v20 setService:v21];

                  [v20 setValue:WeakRetained[71]];
                  v2 = v29;
                  [v29 addObject:v20];
                  v22 = objc_autoreleasePoolPush();
                  v23 = WeakRetained;
                  v24 = HMFGetOSLogHandle();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
                  {
                    v25 = HMFGetLogIdentifier();
                    v26 = WeakRetained[71];
                    *buf = 138543618;
                    v39 = v25;
                    v40 = 2112;
                    v41 = v26;
                    _os_log_impl(&dword_22AEAE000, v24, OS_LOG_TYPE_INFO, "%{public}@sending notification for software version = %@", buf, 0x16u);
                  }

                  objc_autoreleasePoolPop(v22);
                  v27 = [v23 delegate];
                  [v27 accessoryServer:v23 didUpdateValuesForCharacteristics:v29 stateNumber:0 broadcast:0];

                  goto LABEL_22;
                }
              }

              v14 = [v12 countByEnumeratingWithState:&v30 objects:v42 count:16];
              v2 = v29;
              if (v14)
              {
                continue;
              }

              break;
            }
          }

LABEL_22:

          goto LABEL_23;
        }
      }

      v6 = [v4 countByEnumeratingWithState:&v34 objects:v43 count:16];
      if (v6)
      {
        continue;
      }

      break;
    }
  }

LABEL_23:

  v28 = *MEMORY[0x277D85DE8];
}

- (void)updateSoftwareVersion:(id)version
{
  v29 = *MEMORY[0x277D85DE8];
  versionCopy = version;
  v6 = objc_autoreleasePoolPush();
  selfCopy = self;
  v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v9 = HMFGetLogIdentifier();
    softwareVersionNumber = [(HMMTRAccessoryServer *)selfCopy softwareVersionNumber];
    *buf = 138543874;
    v24 = v9;
    v25 = 2112;
    v26 = softwareVersionNumber;
    v27 = 2112;
    v28 = versionCopy;
    _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Updating software version number from %@ to %@", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v6);
  objc_storeStrong(&selfCopy->_softwareVersionNumber, version);
  browser = [(HMMTRAccessoryServer *)selfCopy browser];
  storage = [browser storage];
  dataSource = [storage dataSource];
  fabricUUID = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
  v15 = [dataSource storageDataSourceForFabricUUID:fabricUUID];

  nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
  v17 = [v15 storageDataSourceForDeviceWithNodeID:nodeID];
  softwareVersionNumber2 = [(HMMTRAccessoryServer *)selfCopy softwareVersionNumber];
  v22[0] = MEMORY[0x277D85DD0];
  v22[1] = 3221225472;
  v22[2] = __46__HMMTRAccessoryServer_updateSoftwareVersion___block_invoke;
  v22[3] = &unk_2786EF290;
  v22[4] = selfCopy;
  [v17 updateSoftwareVersionNumber:softwareVersionNumber2 completion:v22];

  matterFirmwareUpdateStatus = [(HMMTRAccessoryServer *)selfCopy matterFirmwareUpdateStatus];

  if (matterFirmwareUpdateStatus)
  {
    matterFirmwareUpdateStatus2 = [(HMMTRAccessoryServer *)selfCopy matterFirmwareUpdateStatus];
    [matterFirmwareUpdateStatus2 checkCurrentFirmwareVersionNumber:versionCopy];
  }

  v21 = *MEMORY[0x277D85DE8];
}

void __46__HMMTRAccessoryServer_updateSoftwareVersion___block_invoke(uint64_t a1, void *a2)
{
  v16 = *MEMORY[0x277D85DE8];
  v3 = a2;
  if (v3)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = *(a1 + 32);
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = HMFGetLogIdentifier();
      v8 = [*(a1 + 32) softwareVersionNumber];
      v10 = 138543874;
      v11 = v7;
      v12 = 2112;
      v13 = v8;
      v14 = 2112;
      v15 = v3;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update version number in storage to %@ with error: %@", &v10, 0x20u);
    }

    objc_autoreleasePoolPop(v4);
  }

  v9 = *MEMORY[0x277D85DE8];
}

- (BOOL)hasPreferredLocalLink
{
  v23 = *MEMORY[0x277D85DE8];
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    v3 = 0;
  }

  else
  {
    residentReachabilityUpdateWaitTimer = [(HMMTRAccessoryServer *)self residentReachabilityUpdateWaitTimer];
    v3 = residentReachabilityUpdateWaitTimer != 0;
  }

  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)selfCopy isDisabled];
    v9 = HMFBooleanToString();
    residentReachabilityUpdateWaitTimer2 = [(HMMTRAccessoryServer *)selfCopy residentReachabilityUpdateWaitTimer];
    v11 = HMFBooleanToString();
    v12 = HMFBooleanToString();
    v15 = 138544130;
    v16 = v8;
    v17 = 2112;
    v18 = v9;
    v19 = 2112;
    v20 = v11;
    v21 = 2112;
    v22 = v12;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_DEBUG, "%{public}@disabled %@, timer running %@ -> local link preferred: %@", &v15, 0x2Au);
  }

  objc_autoreleasePoolPop(v5);
  v13 = *MEMORY[0x277D85DE8];
  return v3;
}

- (void)setLinkLayerType:(int64_t)type
{
  v5 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  self->_linkLayerType = type;

  os_unfair_lock_unlock((self + v5));
}

- (int64_t)linkLayerType
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  linkLayerType = self->_linkLayerType;
  os_unfair_lock_unlock((self + v3));
  if (!linkLayerType)
  {
    if ([(HAPAccessoryServer *)self isReachable])
    {
      primaryAccessory = [(HMMTRAccessoryServer *)self primaryAccessory];
      linkLayerType = [(HMMTRAccessoryServer *)self getLinkLayerTypeForAccessory:primaryAccessory];
      [(HMMTRAccessoryServer *)self setLinkLayerType:linkLayerType];
      [primaryAccessory setLinkLayerType:linkLayerType];
    }

    else
    {
      return 0;
    }
  }

  return linkLayerType;
}

- (void)setPairedState:(int64_t)state
{
  v22 = *MEMORY[0x277D85DE8];
  v5 = objc_autoreleasePoolPush();
  selfCopy = self;
  v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = HMFGetLogIdentifier();
    *buf = 138543874;
    v17 = v8;
    v18 = 2048;
    pairedState = [(HMMTRAccessoryServer *)selfCopy pairedState];
    v20 = 2048;
    stateCopy = state;
    _os_log_impl(&dword_22AEAE000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating paired state from %ld to %ld", buf, 0x20u);
  }

  objc_autoreleasePoolPop(v5);
  isStaged = [(HMMTRAccessoryServer *)selfCopy isStaged];
  v10 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  selfCopy->_pairedState = state;
  os_unfair_lock_unlock((selfCopy + v10));
  if (state >= 3)
  {
    if (state == 3)
    {
      v11 = 1;
      goto LABEL_9;
    }
  }

  else if ([(HAPAccessoryServer *)selfCopy isSecuritySessionOpen]|| [(HMMTRAccessoryServer *)selfCopy locallyDiscovered])
  {
    v11 = 0;
LABEL_9:
    [(HAPAccessoryServer *)selfCopy setHasPairings:v11];
  }

  clientQueue = [(HAPAccessoryServer *)selfCopy clientQueue];
  v14[0] = MEMORY[0x277D85DD0];
  v14[1] = 3221225472;
  v14[2] = __39__HMMTRAccessoryServer_setPairedState___block_invoke;
  v14[3] = &unk_2786F0C80;
  v14[4] = selfCopy;
  v15 = isStaged;
  dispatch_async(clientQueue, v14);

  v13 = *MEMORY[0x277D85DE8];
}

void __39__HMMTRAccessoryServer_setPairedState___block_invoke(uint64_t a1)
{
  v24 = *MEMORY[0x277D85DE8];
  v2 = [*(a1 + 32) isStaged];
  if (*(a1 + 40) != v2)
  {
    v3 = v2;
    v4 = [*(a1 + 32) knownToSystemCommissioner];
    v5 = [*(a1 + 32) browser];
    v6 = v5;
    if (v4)
    {
      v7 = [v5 storageForSystemCommissioner];
    }

    else
    {
      v8 = [*(a1 + 32) fabricUUID];
      v9 = [*(a1 + 32) pairingRequest];
      if (v9)
      {
        v10 = [*(a1 + 32) pairingRequest];
        v7 = [v6 storageForFabricUUID:v8 sharedAdmin:{objc_msgSend(v10, "isOwnerPairing") ^ 1}];
      }

      else
      {
        v7 = [v6 storageForFabricUUID:v8 sharedAdmin:0];
      }
    }

    v11 = [*(a1 + 32) nodeID];
    [v7 setStaged:v3 forNode:v11];

    v12 = objc_autoreleasePoolPush();
    v13 = *(a1 + 32);
    v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15 = HMFGetLogIdentifier();
      v16 = *(a1 + 32);
      v18 = 138543874;
      v19 = v15;
      v20 = 1024;
      v21 = v3;
      v22 = 2112;
      v23 = v16;
      _os_log_impl(&dword_22AEAE000, v14, OS_LOG_TYPE_DEBUG, "%{public}@Stored Staged State:%d for server:%@", &v18, 0x1Cu);
    }

    objc_autoreleasePoolPop(v12);
  }

  v17 = *MEMORY[0x277D85DE8];
}

- (int64_t)pairedState
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  pairedState = self->_pairedState;
  os_unfair_lock_unlock((self + v3));
  return pairedState;
}

- (HMMTRPairing)currentPairing
{
  v51 = *MEMORY[0x277D85DE8];
  currentPairingInfo = [(HMMTRAccessoryServer *)self currentPairingInfo];

  if (!currentPairingInfo)
  {
    v4 = objc_autoreleasePoolPush();
    selfCopy = self;
    v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = HMFGetLogIdentifier();
      *buf = 138543362;
      v48 = v7;
      _os_log_impl(&dword_22AEAE000, v6, OS_LOG_TYPE_INFO, "%{public}@CurrentPairingInfo is not cached, fetching info from storage", buf, 0xCu);
    }

    objc_autoreleasePoolPop(v4);
    browser = [(HMMTRAccessoryServer *)selfCopy browser];
    storage = [browser storage];
    dataSource = [storage dataSource];
    fabricUUID = [(HMMTRAccessoryServer *)selfCopy fabricUUID];
    v12 = [dataSource storageDataSourceForFabricUUID:fabricUUID];
    nodeID = [(HMMTRAccessoryServer *)selfCopy nodeID];
    v14 = [v12 storageDataSourceForDeviceWithNodeID:nodeID];
    pairings = [v14 pairings];

    objectEnumerator = [pairings objectEnumerator];
    nextObject = [objectEnumerator nextObject];
    if (nextObject)
    {
      v18 = nextObject;
      do
      {
        nodeID2 = [v18 nodeID];
        nodeID3 = [(HMMTRAccessoryServer *)selfCopy nodeID];
        if ([nodeID2 isEqual:nodeID3])
        {
          rootPublicKey = [v18 rootPublicKey];
          rootPublicKey2 = [(HMMTRAccessoryServer *)selfCopy rootPublicKey];
          v23 = [rootPublicKey isEqual:rootPublicKey2];

          if (v23)
          {
            v46 = pairings;
            v44 = [HMMTRPairing alloc];
            nodeID4 = [v18 nodeID];
            fabricID = [v18 fabricID];
            fabricLabel = [v18 fabricLabel];
            rootPublicKey3 = [v18 rootPublicKey];
            vendorID = [v18 vendorID];
            vendorName = [v18 vendorName];
            v30 = [(HMMTRPairing *)v44 initWithNodeID:nodeID4 fabricID:fabricID fabricLabel:fabricLabel rootPublicKey:rootPublicKey3 vendorID:vendorID vendorName:vendorName];
            [(HMMTRAccessoryServer *)selfCopy setCurrentPairingInfo:v30];

            v31 = objc_autoreleasePoolPush();
            v32 = selfCopy;
            v33 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
            {
              v35 = HMFGetLogIdentifier();
              *buf = 138543618;
              v48 = v35;
              v49 = 2112;
              v50 = v18;
              _os_log_impl(&dword_22AEAE000, v33, OS_LOG_TYPE_INFO, "%{public}@Updated currentPairingInfo with pairing from storage: %@", buf, 0x16u);
            }

            objc_autoreleasePoolPop(v31);
            pairings = v46;
            break;
          }
        }

        else
        {
        }

        nextObject2 = [objectEnumerator nextObject];

        v18 = nextObject2;
      }

      while (nextObject2);
    }
  }

  v36 = objc_autoreleasePoolPush();
  selfCopy2 = self;
  v38 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
  {
    v39 = HMFGetLogIdentifier();
    currentPairingInfo2 = [(HMMTRAccessoryServer *)selfCopy2 currentPairingInfo];
    *buf = 138543618;
    v48 = v39;
    v49 = 2112;
    v50 = currentPairingInfo2;
    _os_log_impl(&dword_22AEAE000, v38, OS_LOG_TYPE_INFO, "%{public}@Returning current pairing info %@", buf, 0x16u);
  }

  objc_autoreleasePoolPop(v36);
  currentPairingInfo3 = [(HMMTRAccessoryServer *)selfCopy2 currentPairingInfo];
  v42 = *MEMORY[0x277D85DE8];

  return currentPairingInfo3;
}

- (void)setRemoveReason:(id)reason pairingEndContextWhenRemove:(id)remove
{
  v29 = *MEMORY[0x277D85DE8];
  reasonCopy = reason;
  removeCopy = remove;
  v8 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v9 = objc_autoreleasePoolPush();
  selfCopy = self;
  v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = HMFGetLogIdentifier();
    removeReason = selfCopy->_removeReason;
    pairingEndContextWhenRemove = selfCopy->_pairingEndContextWhenRemove;
    v19 = 138544386;
    v20 = v12;
    v21 = 2112;
    v22 = removeReason;
    v23 = 2112;
    v24 = reasonCopy;
    v25 = 2112;
    v26 = pairingEndContextWhenRemove;
    v27 = 2112;
    v28 = removeCopy;
    _os_log_impl(&dword_22AEAE000, v11, OS_LOG_TYPE_INFO, "%{public}@Setting removeReason %@ -> %@, context %@ -> %@", &v19, 0x34u);
  }

  objc_autoreleasePoolPop(v9);
  v15 = selfCopy->_removeReason;
  selfCopy->_removeReason = reasonCopy;
  v16 = reasonCopy;

  v17 = selfCopy->_pairingEndContextWhenRemove;
  selfCopy->_pairingEndContextWhenRemove = removeCopy;

  os_unfair_lock_unlock((self + v8));
  v18 = *MEMORY[0x277D85DE8];
}

- (HMMTRAccessoryPairingEndContext)pairingEndContextWhenRemove
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = self->_pairingEndContextWhenRemove;
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (NSError)removeReason
{
  v3 = *MEMORY[0x277CFECD8];
  os_unfair_lock_lock_with_options();
  v4 = self->_removeReason;
  os_unfair_lock_unlock((self + v3));

  return v4;
}

- (id)ensureCommissioningID
{
  v17 = *MEMORY[0x277D85DE8];
  commissioningID = self->_commissioningID;
  if (!commissioningID)
  {
    uUID = [MEMORY[0x277CCAD78] UUID];
    v5 = self->_commissioningID;
    self->_commissioningID = uUID;

    v6 = objc_autoreleasePoolPush();
    selfCopy = self;
    v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v9 = HMFGetLogIdentifier();
      v10 = self->_commissioningID;
      v13 = 138543618;
      v14 = v9;
      v15 = 2112;
      v16 = v10;
      _os_log_impl(&dword_22AEAE000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Generated System Commissioner pairing UUID %@", &v13, 0x16u);
    }

    objc_autoreleasePoolPop(v6);
    commissioningID = self->_commissioningID;
  }

  v11 = *MEMORY[0x277D85DE8];

  return commissioningID;
}

- (void)setCommissioningID:(id)d
{
  v16 = *MEMORY[0x277D85DE8];
  dCopy = d;
  if (self->_commissioningID)
  {
    _HMFPreconditionFailure();
  }

  v6 = dCopy;
  if (dCopy)
  {
    objc_storeStrong(&self->_commissioningID, d);
    v7 = objc_autoreleasePoolPush();
    selfCopy = self;
    v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v10 = HMFGetLogIdentifier();
      v12 = 138543618;
      v13 = v10;
      v14 = 2112;
      v15 = v6;
      _os_log_impl(&dword_22AEAE000, v9, OS_LOG_TYPE_DEBUG, "%{public}@Assigned System Commissioner pairing UUID %@", &v12, 0x16u);
    }

    objc_autoreleasePoolPop(v7);
  }

  v11 = *MEMORY[0x277D85DE8];
}

- (void)setClusterIDForCharacteristic:(id)characteristic endpointID:(id)d clusterID:(id)iD
{
  dCopy = d;
  clusterIDCharacteristicMap = self->_clusterIDCharacteristicMap;
  iDCopy = iD;
  characteristicCopy = characteristic;
  v11 = [(NSMutableDictionary *)clusterIDCharacteristicMap objectForKeyedSubscript:dCopy];

  if (!v11)
  {
    v12 = objc_alloc_init(MEMORY[0x277CBEB38]);
    [(NSMutableDictionary *)self->_clusterIDCharacteristicMap setObject:v12 forKeyedSubscript:dCopy];
  }

  v13 = [(NSMutableDictionary *)self->_clusterIDCharacteristicMap objectForKeyedSubscript:dCopy];
  [v13 setValue:iDCopy forKey:characteristicCopy];
}

- (id)deviceID
{
  v3 = objc_alloc(MEMORY[0x277CFEB48]);
  identifier = [(HAPAccessoryServer *)self identifier];
  v5 = [v3 initWithDeviceIDString:identifier];

  return v5;
}

- (void)_updateDefaultEntriesForBridgedClusterIDCharacteristicMap:(id)map
{
  mapCopy = map;
  v5 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000023-0000-1000-8000-0026BB765291"];
  v6 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 57];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v5 endpointID:mapCopy clusterID:v6];

  v7 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000021-0000-1000-8000-0026BB765291"];
  v8 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 57];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v7 endpointID:mapCopy clusterID:v8];

  v9 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000020-0000-1000-8000-0026BB765291"];
  v10 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 57];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v9 endpointID:mapCopy clusterID:v10];

  v12 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000030-0000-1000-8000-0026BB765291"];
  v11 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 57];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v12 endpointID:mapCopy clusterID:v11];
}

- (void)_updateDefaultEntriesForClusterIDCharacteristicMap:(id)map
{
  v4 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000023-0000-1000-8000-0026BB765291"];
  v5 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v4 endpointID:&unk_283EE89B8 clusterID:v5];

  v6 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000021-0000-1000-8000-0026BB765291"];
  v7 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v6 endpointID:&unk_283EE89B8 clusterID:v7];

  v8 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000020-0000-1000-8000-0026BB765291"];
  v9 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v8 endpointID:&unk_283EE89B8 clusterID:v9];

  v10 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000014-0000-1000-8000-0026BB765291"];
  v11 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 3];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v10 endpointID:&unk_283EE89B8 clusterID:v11];

  v12 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000030-0000-1000-8000-0026BB765291"];
  v13 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v12 endpointID:&unk_283EE89B8 clusterID:v13];

  v14 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000052-0000-1000-8000-0026BB765291"];
  v15 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v14 endpointID:&unk_283EE89B8 clusterID:v15];

  v16 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"0000026D-0000-1000-8000-0026BB765291"];
  v17 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 40];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v16 endpointID:&unk_283EE89B8 clusterID:v17];

  v18 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000234-0000-1000-8000-0026BB765291"];
  v19 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 42];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v18 endpointID:&unk_283EE89B8 clusterID:v19];

  v21 = [HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000235-0000-1000-8000-0026BB765291"];
  v20 = [MEMORY[0x277CCACA8] stringWithFormat:@"%0X", 42];
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v21 endpointID:&unk_283EE89B8 clusterID:v20];
}

- (MTRDeviceController)deviceController
{
  controllerWrapper = [(HMMTRAccessoryServer *)self controllerWrapper];
  controller = [controllerWrapper controller];

  return controller;
}

- (void)dispatchBlock:(id)block
{
  blockCopy = block;
  clientQueue = [(HAPAccessoryServer *)self clientQueue];
  dispatch_async(clientQueue, blockCopy);
}

- (void)dealloc
{
  [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlers];
  v3.receiver = self;
  v3.super_class = HMMTRAccessoryServer;
  [(HMMTRAccessoryServer *)&v3 dealloc];
}

- (HMMTRAccessoryServer)initWithKeystore:(id)keystore browser:(id)browser
{
  browserCopy = browser;
  v44.receiver = self;
  v44.super_class = HMMTRAccessoryServer;
  v7 = [(HAPAccessoryServer *)&v44 initWithKeystore:keystore];
  if (v7)
  {
    v8 = [MEMORY[0x277CCABB0] numberWithUnsignedInt:arc4random()];
    objectID = v7->_objectID;
    v7->_objectID = v8;

    objc_storeWeak(&v7->_browser, browserCopy);
    v10 = [[HMMTRTimeBasedCounter alloc] initTimeBasedCounter:10];
    notAvailableImageResponseCounter = v7->_notAvailableImageResponseCounter;
    v7->_notAvailableImageResponseCounter = v10;

    v7->_busyImageResponseCounter = 0;
    v7->_pairedState = 0;
    v7->_pairingProgress = 0;
    v7->_storageUpdatePending = 0;
    v7->_removalInProgress = 0;
    v7->_blockInvalidation = 0;
    v7->_locallyDiscovered = 0;
    v7->_discoveredOverBLE = 0;
    v7->_bleScanPending = 0;
    v7->_linkLayerType = 0;
    v7->_certified = 0;
    v7->_requiresThreadRouter = 0;
    v7->_delayDiscovery = 0;
    v7->_wedDevice = 0;
    supportedLinkLayerTypes = v7->_supportedLinkLayerTypes;
    v7->_supportedLinkLayerTypes = 0;

    v7->_operationDisabled = 0;
    v7->_operationDisabledReason = 0;
    v7->_hasPriorSuccessfulPairing = 0;
    maxMetricDuration = v7->_maxMetricDuration;
    v7->_maxMetricDuration = 0;

    softwareVersionNumber = v7->_softwareVersionNumber;
    v7->_softwareVersionNumber = 0;

    softwareVersionString = v7->_softwareVersionString;
    v7->_softwareVersionString = @"unknown";

    v16 = objc_alloc_init(MEMORY[0x277CBEB38]);
    [(HMMTRAccessoryServer *)v7 setPairingDurationDictionary:v16];

    v17 = objc_alloc_init(MEMORY[0x277CBEB38]);
    clusterIDCharacteristicMap = v7->_clusterIDCharacteristicMap;
    v7->_clusterIDCharacteristicMap = v17;

    v19 = [[HMMTRHAPEnumerator alloc] initWithClusterIDCharacteristicMap:v7->_clusterIDCharacteristicMap];
    hapEnumerator = v7->_hapEnumerator;
    v7->_hapEnumerator = v19;

    v21 = objc_alloc_init(MEMORY[0x277CBEB38]);
    attributeTimers = v7->_attributeTimers;
    v7->_attributeTimers = v21;

    v23 = objc_alloc_init(HMMTRAttributeReportDistributor);
    reportDistributor = v7->_reportDistributor;
    v7->_reportDistributor = v23;

    commissioneeNetworkCommissioningClusterEndpoint = v7->_commissioneeNetworkCommissioningClusterEndpoint;
    v7->_commissioneeNetworkCommissioningClusterEndpoint = 0;

    commissioneeNetworks = v7->_commissioneeNetworks;
    v7->_commissioneeNetworks = 0;

    v7->_commissioneeHasActiveNetwork = 0;
    weakObjectsHashTable = [MEMORY[0x277CCAA50] weakObjectsHashTable];
    reportObservers = v7->_reportObservers;
    v7->_reportObservers = weakObjectsHashTable;

    v29 = [objc_alloc(MEMORY[0x277CFEC10]) initWithValue:1];
    v30 = [objc_alloc(MEMORY[0x277CFEB98]) initWithOTAProviderState:v29 downloadedFirmwareVersionNumber:0 accessoryDownloadProgressPercent:0];
    v31 = [[HMMTRFirmwareUpdateStatus alloc] initWithFirmwareUpdateStatus:v30 accessoryServer:v7 browser:browserCopy];
    matterFirmwareUpdateStatus = v7->_matterFirmwareUpdateStatus;
    v7->_matterFirmwareUpdateStatus = v31;

    defaultCenter = [MEMORY[0x277CCAB98] defaultCenter];
    [defaultCenter addObserver:v7 selector:sel_handleThreadNetworkStateChangedNotification_ name:@"HMMTRThreadRadioStateChangedNotification" object:0];

    v7->_deferStartThreadForPairing = 0;
    v34 = objc_alloc_init(MEMORY[0x277CBEB38]);
    characteristicProtocolMappingStates = v7->_characteristicProtocolMappingStates;
    v7->_characteristicProtocolMappingStates = v34;

    [(HMMTRAccessoryServer *)v7 _updateDefaultEntriesForClusterIDCharacteristicMap:v7->_clusterIDCharacteristicMap];
    deviceConnectedStateCaptureInformation = v7->_deviceConnectedStateCaptureInformation;
    v7->_deviceConnectedStateCaptureInformation = 0;

    partsListStateCaptureInformation = v7->_partsListStateCaptureInformation;
    v7->_partsListStateCaptureInformation = 0;

    descriptorClusterManager = v7->_descriptorClusterManager;
    v7->_descriptorClusterManager = &__block_literal_global_10655;

    array = [MEMORY[0x277CBEB18] array];
    serviceEnumerationFromDeviceCompletionHandlers = v7->_serviceEnumerationFromDeviceCompletionHandlers;
    v7->_serviceEnumerationFromDeviceCompletionHandlers = array;

    dictionary = [MEMORY[0x277CBEB38] dictionary];
    pendingMTRDeviceReadReadyHandlers = v7->_pendingMTRDeviceReadReadyHandlers;
    v7->_pendingMTRDeviceReadReadyHandlers = dictionary;
  }

  return v7;
}

+ (id)shortDescription
{
  v2 = objc_opt_class();

  return NSStringFromClass(v2);
}

+ (id)logCategory
{
  if (logCategory__hmf_once_t688 != -1)
  {
    dispatch_once(&logCategory__hmf_once_t688, &__block_literal_global_984);
  }

  v3 = logCategory__hmf_once_v689;

  return v3;
}

uint64_t __35__HMMTRAccessoryServer_logCategory__block_invoke()
{
  v0 = *MEMORY[0x277D0F1A8];
  v1 = HMFCreateOSLogHandle();
  v2 = logCategory__hmf_once_v689;
  logCategory__hmf_once_v689 = v1;

  return MEMORY[0x2821F96F8](v1, v2);
}

+ (id)_convertPairingFailureError:(id)error
{
  errorCopy = error;
  domain = [errorCopy domain];
  v5 = [domain isEqualToString:*MEMORY[0x277CD5120]];

  if (v5)
  {
    code = [errorCopy code];
    v7 = MEMORY[0x277CCA9B8];
    if (code == 11)
    {
      v8 = 18;
LABEL_7:
      v11 = [v7 hapErrorWithCode:v8 description:0 reason:0 suggestion:0 underlyingError:errorCopy];

      errorCopy = v11;
      goto LABEL_8;
    }

LABEL_6:
    v8 = 15;
    goto LABEL_7;
  }

  domain2 = [errorCopy domain];
  v10 = [domain2 isEqualToString:*MEMORY[0x277CD5158]];

  if (v10)
  {
    v7 = MEMORY[0x277CCA9B8];
    goto LABEL_6;
  }

LABEL_8:
  if ([errorCopy isHMFError] && objc_msgSend(errorCopy, "code") == 11)
  {
    v12 = [MEMORY[0x277CCA9B8] hapErrorWithCode:15 description:0 reason:0 suggestion:0 underlyingError:errorCopy];

    errorCopy = v12;
  }

  return errorCopy;
}

+ (void)propagateCharactersticValuesToAccessory:(id)accessory
{
  v50 = *MEMORY[0x277D85DE8];
  accessoryCopy = accessory;
  v44 = 0u;
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  obj = [accessoryCopy services];
  v4 = [obj countByEnumeratingWithState:&v44 objects:v49 count:16];
  if (v4)
  {
    v5 = v4;
    v6 = *v45;
    v36 = *v45;
    do
    {
      v7 = 0;
      v37 = v5;
      do
      {
        if (*v45 != v6)
        {
          objc_enumerationMutation(obj);
        }

        v8 = *(*(&v44 + 1) + 8 * v7);
        type = [v8 type];
        v10 = [type isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v10)
        {
          v39 = v7;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          characteristics = [v8 characteristics];
          v12 = [characteristics countByEnumeratingWithState:&v40 objects:v48 count:16];
          if (v12)
          {
            v13 = v12;
            v14 = *v41;
            do
            {
              for (i = 0; i != v13; ++i)
              {
                if (*v41 != v14)
                {
                  objc_enumerationMutation(characteristics);
                }

                v16 = *(*(&v40 + 1) + 8 * i);
                value = [v16 value];
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  v18 = value;
                }

                else
                {
                  v18 = 0;
                }

                v19 = v18;

                if (v19)
                {
                  type2 = [v16 type];
                  v21 = [type2 isEqual:@"00000023-0000-1000-8000-0026BB765291"];

                  if (v21)
                  {
                    [accessoryCopy setName:v19];
                  }

                  else
                  {
                    type3 = [v16 type];
                    v23 = [type3 isEqual:@"00000021-0000-1000-8000-0026BB765291"];

                    if (v23)
                    {
                      [accessoryCopy setModel:v19];
                    }

                    else
                    {
                      type4 = [v16 type];
                      v25 = [type4 isEqual:@"00000020-0000-1000-8000-0026BB765291"];

                      if (v25)
                      {
                        [accessoryCopy setManufacturer:v19];
                      }

                      else
                      {
                        type5 = [v16 type];
                        v27 = [type5 isEqual:@"0000026D-0000-1000-8000-0026BB765291"];

                        if (v27)
                        {
                          value2 = [v16 value];
                          objc_opt_class();
                          if (objc_opt_isKindOfClass())
                          {
                            v29 = value2;
                          }

                          else
                          {
                            v29 = 0;
                          }

                          v30 = v29;

                          if (v30)
                          {
                            v31 = [objc_alloc(MEMORY[0x277D0F8F8]) initWithMajorVersion:objc_msgSend(v30 minorVersion:"unsignedLongValue") updateVersion:{0, 0}];
                            versionString = [v31 versionString];
                            [accessoryCopy setFirmwareVersion:versionString];
                          }
                        }

                        else
                        {
                          type6 = [v16 type];
                          v34 = [type6 isEqual:@"00000030-0000-1000-8000-0026BB765291"];

                          if (v34)
                          {
                            [accessoryCopy setSerialNumber:v19];
                          }
                        }
                      }
                    }
                  }
                }
              }

              v13 = [characteristics countByEnumeratingWithState:&v40 objects:v48 count:16];
            }

            while (v13);
          }

          v6 = v36;
          v5 = v37;
          v7 = v39;
        }

        ++v7;
      }

      while (v7 != v5);
      v5 = [obj countByEnumeratingWithState:&v44 objects:v49 count:16];
    }

    while (v5);
  }

  v35 = *MEMORY[0x277D85DE8];
}

+ (BOOL)certificateSubjectHasCATs:(id)ts
{
  v3 = [MEMORY[0x277CD5230] convertX509Certificate:ts];
  v4 = [objc_alloc(MEMORY[0x277CD5228]) initWithTLVBytes:v3];
  subject = [v4 subject];
  caseAuthenticatedTags = [subject caseAuthenticatedTags];
  v7 = [caseAuthenticatedTags count] != 0;

  return v7;
}

@end