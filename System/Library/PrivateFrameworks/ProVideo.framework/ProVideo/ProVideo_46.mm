uint64_t emit(uint64_t a1, uint64_t a2, float *a3, unint64_t a4, unsigned int a5, int a6, float a7, float32x2_t a8, __n128 a9, float32_t a10, int32x4_t a11, __n128 a12, __n128 a13, float32x4_t a14, uint64_t a15, uint64_t a16, unsigned __int32 a17, __int32 a18, __int32 a19, __int32 a20)
{
  v33 = a3;
  v395 = a8.f32[0];
  v396 = a12.n128_f32[0];
  v30.i32[0] = a11.i32[0];
  v34.i32[0] = a9.n128_u32[0];
  k = a2;
  v36 = a1;
  v37 = a1 + 8 * (a6 != 0);
  if (a6)
  {
    v38 = *(a1 + 144) == 0;
    v39 = -2.0;
    v40 = -1.0;
    goto LABEL_5;
  }

  if (*(a1 + 140))
  {
    v38 = *(a1 + 144) == 0;
    v39 = 1.0;
    v40 = 0.0;
LABEL_5:
    if (v38)
    {
      v41 = v39;
    }

    else
    {
      v41 = v40;
    }

    v387 = LODWORD(v41);
    v42 = *(v37 + 96);
    v43 = a3[15];
    if (v43 == 0.0)
    {
      goto LABEL_33;
    }

    goto LABEL_9;
  }

  v39 = 1.0;
  v40 = 0.0;
  v387 = 0;
  v42 = *(v37 + 96);
  v43 = a3[15];
  if (v43 == 0.0)
  {
    goto LABEL_33;
  }

LABEL_9:
  v44 = a3[16];
  if (v44 != 0.0)
  {
    v46 = a3[13];
    v45 = a3[14];
    if (v395 >= 0.0)
    {
      v50 = fminf(fmaxf(v395 - v46, 0.0), v45);
    }

    else
    {
      v23.i32[1] = 0;
      v47 = fminf(fmaxf((v395 + 1.0) - v46, 0.0), v45) - v45;
      v48 = v46 - (v45 + -1.0);
      if (v48 <= v395)
      {
        v49 = 0.0;
      }

      else
      {
        v49 = v395 - v48;
      }

      if (v45 > 1.0)
      {
        v50 = v49;
      }

      else
      {
        v50 = v47;
      }
    }

    v51 = 1.0 / (v50 * v50);
    v52 = v43 + v51;
    v21.i32[1] = 0;
    if ((v43 + v51) > 0.0)
    {
      v52 = 0.0;
    }

    v53 = v43 - v51;
    if ((v43 - v51) < 0.0)
    {
      v53 = 0.0;
    }

    if (v43 >= 0.0)
    {
      v54 = v53;
    }

    else
    {
      v54 = v52;
    }

    v55 = v44 + v51;
    if ((v44 + v51) > 0.0)
    {
      v55 = 0.0;
    }

    v56 = v44 - v51;
    if (v56 < 0.0)
    {
      v56 = 0.0;
    }

    if (v44 >= 0.0)
    {
      v57 = v56;
    }

    else
    {
      v57 = v55;
    }

    a3[15] = v54;
    a3[16] = v57;
  }

LABEL_33:
  v20.n128_u32[0] = a17;
  v58.i32[0] = a18;
  a8.i32[0] = a20;
  if (a5 == 4)
  {
    v166 = v42 + 576 * *(a1 + 64) + 2 * (a2 - v42);
    v167 = 1.0;
    v34.f32[1] = a10;
    v58.i32[1] = a19;
    v168 = v395 + 1.0;
    for (i = a3 + 14; ; i += 29)
    {
      v170 = *(i - 1);
      a9.n128_u32[1] = 0;
      v171 = fminf(fmaxf(v395 - v170, 0.0), *i);
      v172 = fminf(fmaxf(v168 - v170, 0.0), *i) - *i;
      v173 = v170 - (*i + -1.0);
      if (v173 <= v395)
      {
        v174 = 0.0;
      }

      else
      {
        v174 = v395 - v173;
      }

      if (*i <= v167)
      {
        v174 = v172;
      }

      if (v395 < 0.0)
      {
        *a11.i32 = v174;
      }

      else
      {
        *a11.i32 = v171;
      }

      v175 = *(v36 + 168) + (fabsf(*a11.i32) * (*(v36 + 172) - *(v36 + 168)));
      v176 = v175 * a7;
      a9.n128_f32[0] = (v175 * a7) * 0.5;
      if (a4 && *a11.i32 == 0.0)
      {
        v177.i64[0] = *(i - 7);
        v177.i64[1] = v177.i64[0];
        v24 = vaddq_f32(v177, vmulq_n_f32(vsubq_f32(vextq_s8(*(i + 7), *(i + 7), 8uLL), v177), v175));
        a14 = vdupq_lane_s32(a9.n128_u64[0], 0);
        v178 = vaddq_f32(v177, vmulq_n_f32(vsubq_f32(vextq_s8(*(i + 11), *(i + 11), 8uLL), v177), v175));
        v179 = 1.0;
        v180 = 0.0;
        v181 = 0.0;
        v182 = 0.0;
        v183 = 1.0;
      }

      else
      {
        a13.n128_f32[0] = *(i - 14);
        if (a4)
        {
          v391 = v175;
          v382 = a13;
          v385 = a9;
          v399.n128_u64[0] = a11.i64[0];
          v184 = __sincosf_stret((*a11.i32 * (*(i - 3) * 6.2832)) * 0.5);
          a8.f32[0] = v184.__cosval;
          a13 = v382;
          v185.f32[0] = *(i - 7);
          v20.n128_f32[0] = *(i - 6) * v184.__sinval;
          v186.f32[0] = *(i - 10);
          v23.f32[0] = *(i - 13);
          a14.i32[1] = v399.n128_i32[1];
          *v30.i32 = v399.n128_f32[0] * (v185.f32[0] * *(i - 8));
          v186.i32[1] = v185.i32[0];
          v185.f32[1] = *(i - 9);
          v58 = vmul_n_f32(*(i - 5), v184.__sinval);
          v175 = v391;
          v34 = vadd_f32(vadd_f32(__PAIR64__(v23.u32[0], v382.n128_u32[0]), vmul_n_f32(vmul_f32(v186, v185), v399.n128_f32[0])), vmul_n_f32(vmul_n_f32(*(i + 1), v399.n128_f32[0]), v399.n128_f32[0]));
          v396 = 1.0;
          a9 = v385;
        }

        else
        {
          v23.f32[0] = *(i - 13);
        }

        *v187.f32 = v58;
        *&v187.u32[2] = v58;
        *v188.f32 = v34;
        *&v188.u32[2] = v34;
        a14.f32[0] = i[5];
        *v24.i32 = a9.n128_f32[0] - a14.f32[0];
        a11.i32[1] = 0;
        v26.f32[0] = (a9.n128_f32[0] - a14.f32[0]) * v58.f32[0];
        v27.f32[0] = v20.n128_f32[0] * (a9.n128_f32[0] - a14.f32[0]);
        v183 = i[6] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - i[6])));
        v189.f32[0] = i[13];
        v190.f32[0] = i[14];
        v189.f32[1] = i[9];
        v189.f32[2] = i[11];
        v189.f32[3] = i[7];
        v190.f32[1] = i[10];
        v190.f32[2] = i[12];
        v190.f32[3] = i[8];
        v191.i32[0] = vdupq_lane_s32(v58, 1).u32[0];
        v192.i64[0] = *(i + 3);
        v192.i64[1] = v192.i64[0];
        v193 = vsubq_f32(vmulq_n_f32(vsubq_f32(v189, vdupq_lane_s32(a13.n128_u64[0], 0)), v175), vdupq_lane_s32(*v192.f32, 0));
        v194 = vsubq_f32(vmulq_n_f32(vsubq_f32(v190, vdupq_lane_s32(v23, 0)), v175), vdupq_lane_s32(*v192.f32, 1));
        v195 = vsubq_f32(vmulq_n_f32(v194, v20.n128_f32[0]), vmulq_n_f32(v193, v58.f32[0]));
        v196 = vaddq_f32(v195, v195);
        v197 = vsubq_f32(vmulq_lane_f32(v193, v58, 1), vdupq_lane_s32(*v27.f32, 0));
        v27 = vaddq_f32(v197, v197);
        v198 = vsubq_f32(vdupq_lane_s32(*v26.f32, 0), vmulq_lane_f32(v194, v58, 1));
        v26 = vaddq_f32(v198, v198);
        v199 = vmulq_f32(v187, vtrn1q_s32(v196, v26));
        v191.i32[1] = v20.n128_u32[0];
        v191.i64[1] = v191.i64[0];
        v200 = vsubq_f32(vmulq_f32(v187, vtrn2q_s32(v196, v26)), vmulq_f32(v191, vtrn2q_s32(v27, v196)));
        v201 = vsubq_f32(v199, vmulq_f32(v191, vtrn1q_s32(v27, v196)));
        v202 = vtrn1q_s32(v193, v194);
        v203 = vaddq_f32(vtrn2q_s32(v193, v194), v200);
        v204 = vaddq_f32(v188, vaddq_f32(vmulq_n_f32(vtrn1q_s32(v26, v27), a8.f32[0]), vaddq_f32(v202, v201)));
        v205 = vaddq_f32(v188, vaddq_f32(vmulq_n_f32(vtrn2q_s32(v26, v27), a8.f32[0]), v203));
        v206 = vaddq_f32(vdupq_lane_s32(*v30.i8, 0), vaddq_f32(vmulq_n_f32(v196, a8.f32[0]), vaddq_f32(vdupq_lane_s32(*v24.i8, 0), vsubq_f32(vmulq_n_f32(v27, v20.n128_f32[0]), vmulq_n_f32(v26, v58.f32[0])))));
        v24 = vaddq_f32(v192, v205);
        v178 = vaddq_f32(v192, v204);
        a14 = vaddq_f32(vdupq_lane_s32(*a14.f32, 0), v206);
        v206.f32[0] = vmuls_lane_f32(0.0, v58, 1);
        v204.f32[0] = (v58.f32[0] - v206.f32[0]) + (v58.f32[0] - v206.f32[0]);
        v206.f32[0] = (v206.f32[0] - v20.n128_f32[0]) + (v206.f32[0] - v20.n128_f32[0]);
        v193.f32[0] = ((v20.n128_f32[0] * 0.0) - (0.0 * v58.f32[0])) + ((v20.n128_f32[0] * 0.0) - (0.0 * v58.f32[0]));
        v180 = (a8.f32[0] * v204.f32[0]) + (((v193.f32[0] * v58.f32[0]) - vmuls_lane_f32(v206.f32[0], v58, 1)) + 0.0);
        v181 = (a8.f32[0] * v206.f32[0]) + ((vmuls_lane_f32(v204.f32[0], v58, 1) - (v20.n128_f32[0] * v193.f32[0])) + 0.0);
        v179 = (a8.f32[0] * v193.f32[0]) + (((v20.n128_f32[0] * v206.f32[0]) - (v204.f32[0] * v58.f32[0])) + v167);
        v182 = (a8.f32[0] * 0.0) + 0.0;
      }

      v207 = vextq_s8(v24, v24, 8uLL).u64[0];
      *k = v207;
      *(k + 8) = a14.i32[3];
      *(k + 12) = v183;
      *(k + 16) = v180;
      *(k + 20) = v181;
      *(k + 24) = v179;
      *(k + 28) = v40;
      *(k + 48) = v24.i64[0];
      *(k + 56) = a14.i32[1];
      *(k + 60) = v183;
      *(k + 64) = v180;
      *(k + 68) = v181;
      *(k + 72) = v179;
      *(k + 76) = v40;
      v23 = vextq_s8(v178, v178, 8uLL).u64[0];
      *(k + 96) = v23;
      *(k + 104) = a14.i32[2];
      *(k + 108) = v183;
      *(k + 112) = v180;
      *(k + 116) = v181;
      *(k + 120) = v179;
      *(k + 124) = v40;
      *(k + 152) = a14.i32[2];
      *(k + 144) = v23;
      *(k + 156) = v183;
      *(k + 160) = v180;
      *(k + 164) = v181;
      *(k + 168) = v179;
      *(k + 172) = v40;
      *(k + 192) = v178.i64[0];
      *(k + 200) = a14.i32[0];
      *(k + 204) = v183;
      *(k + 208) = v180;
      *(k + 212) = v181;
      *(k + 216) = v179;
      *(k + 220) = v40;
      *(k + 240) = v207;
      *(k + 248) = a14.i32[3];
      *(k + 252) = v183;
      *(k + 256) = v180;
      v208 = (k + 288);
      *(k + 260) = v181;
      *(k + 264) = v179;
      *(k + 268) = v40;
      if (v176 <= 0.0)
      {
        k += 288;
        if (a4 < 2)
        {
          return k;
        }
      }

      else
      {
        v392 = v30;
        v209 = v176 * v180;
        v23.i32[1] = v34.i32[1];
        v210 = v20;
        v211 = v176 * v181;
        v212 = v176 * v179;
        v213 = v176 * v182;
        v214 = *&v24.i32[2] - (v176 * v180);
        v215 = *&v24.i32[3] - v211;
        v216 = a14.f32[3] - v212;
        v217 = v183 - v213;
        *(k + 288) = v214;
        *(k + 292) = *&v24.i32[3] - v211;
        *(k + 296) = a14.f32[3] - v212;
        *(k + 300) = v217;
        *(k + 304) = v180;
        *(k + 308) = v181;
        *(k + 312) = v179;
        *(k + 316) = v387;
        *(k + 336) = *&v178.i32[2] - v209;
        *(k + 340) = *&v178.i32[3] - v211;
        *(k + 344) = a14.f32[2] - v212;
        *(k + 348) = v217;
        *(k + 352) = v180;
        *(k + 356) = v181;
        *(k + 360) = v179;
        *(k + 364) = v387;
        *(k + 384) = *v24.i32 - v209;
        *(k + 388) = *&v24.i32[1] - v211;
        *(k + 392) = a14.f32[1] - v212;
        *(k + 396) = v217;
        *(k + 400) = v180;
        *(k + 404) = v181;
        *(k + 408) = v179;
        *(k + 412) = v387;
        *(k + 432) = *(k + 336);
        *(k + 448) = v180;
        *(k + 452) = v181;
        *(k + 456) = v179;
        *(k + 460) = v387;
        a13 = *v208;
        *(k + 480) = *v208;
        *(k + 496) = v180;
        *(k + 500) = v181;
        *(k + 504) = v179;
        *(k + 508) = v387;
        a13.n128_f32[0] = *v178.i32 - v209;
        v218 = *&v178.i32[1] - v211;
        v20 = v210;
        v219 = a14.f32[0] - v212;
        v167 = 1.0;
        *(k + 528) = a13.n128_u32[0];
        *(k + 532) = v218;
        *(k + 536) = v219;
        *(k + 540) = v217;
        *(k + 544) = v180;
        *(k + 548) = v181;
        *(k + 552) = v179;
        *(k + 556) = v387;
        v220 = v215 - *&v24.i32[1];
        v168 = v395 + 1.0;
        v221 = ((*&v24.i32[3] - *&v24.i32[1]) * (v216 - a14.f32[1])) - ((a14.f32[3] - a14.f32[1]) * v220);
        v222 = ((v214 - *v24.i32) * (a14.f32[3] - a14.f32[1])) - ((*&v24.i32[2] - *v24.i32) * (v216 - a14.f32[1]));
        a13.n128_f32[0] = ((*&v24.i32[2] - *v24.i32) * v220) - ((*&v24.i32[3] - *&v24.i32[1]) * (v214 - *v24.i32));
        v223 = sqrtf((a13.n128_f32[0] * a13.n128_f32[0]) + ((v221 * v221) + (v222 * v222)));
        v224 = v222 / v223;
        a13.n128_f32[0] = a13.n128_f32[0] / v223;
        *v166 = v24.i64[0];
        *(v166 + 8) = a14.i32[1];
        *(v166 + 12) = v183;
        *(v166 + 16) = v221 / v223;
        *(v166 + 20) = v224;
        *(v166 + 24) = a13.n128_u32[0];
        *(v166 + 28) = v39;
        *(v166 + 48) = v24.i32[2];
        *(v166 + 52) = v24.i32[3];
        *(v166 + 56) = a14.i32[3];
        *(v166 + 60) = v183;
        *(v166 + 64) = v221 / v223;
        *(v166 + 68) = v224;
        *(v166 + 72) = a13.n128_u32[0];
        *(v166 + 76) = v39;
        *(v166 + 96) = *v208;
        *(v166 + 112) = v221 / v223;
        *(v166 + 116) = v224;
        *(v166 + 120) = a13.n128_u32[0];
        *(v166 + 124) = v39;
        *(v166 + 144) = *v208;
        *(v166 + 160) = v221 / v223;
        *(v166 + 164) = v224;
        *(v166 + 168) = a13.n128_u32[0];
        *(v166 + 172) = v39;
        *(v166 + 192) = *(k + 384);
        *(v166 + 208) = v221 / v223;
        *(v166 + 212) = v224;
        *(v166 + 216) = a13.n128_u32[0];
        *(v166 + 220) = v39;
        *(v166 + 240) = v24.i64[0];
        *(v166 + 248) = a14.i32[1];
        *(v166 + 252) = v183;
        *(v166 + 256) = v221 / v223;
        *(v166 + 260) = v224;
        *(v166 + 264) = a13.n128_u32[0];
        *(v166 + 268) = v39;
        v225 = *(k + 384) - *&v178.i32[2];
        v226 = *(k + 388) - *&v178.i32[3];
        v227 = *(k + 392) - a14.f32[2];
        v228 = ((*&v24.i32[1] - *&v178.i32[3]) * v227) - ((a14.f32[1] - a14.f32[2]) * v226);
        v229 = ((a14.f32[1] - a14.f32[2]) * v225) - ((*v24.i32 - *&v178.i32[2]) * v227);
        a13.n128_f32[0] = ((*v24.i32 - *&v178.i32[2]) * v226) - ((*&v24.i32[1] - *&v178.i32[3]) * v225);
        v230 = sqrtf((a13.n128_f32[0] * a13.n128_f32[0]) + ((v228 * v228) + (v229 * v229)));
        v231 = v228 / v230;
        v30 = v392;
        v232 = v229 / v230;
        a13.n128_f32[0] = a13.n128_f32[0] / v230;
        *(v166 + 288) = v178.i64[1];
        *(v166 + 296) = a14.i32[2];
        *(v166 + 300) = v183;
        *(v166 + 304) = v231;
        *(v166 + 308) = v232;
        *(v166 + 312) = a13.n128_u32[0];
        *(v166 + 316) = v39;
        *(v166 + 336) = v24.i64[0];
        *(v166 + 344) = a14.i32[1];
        *(v166 + 348) = v183;
        *(v166 + 352) = v231;
        *(v166 + 356) = v232;
        *(v166 + 360) = a13.n128_u32[0];
        *(v166 + 364) = v39;
        *(v166 + 384) = *(k + 384);
        *(v166 + 400) = v231;
        *(v166 + 404) = v232;
        *(v166 + 408) = a13.n128_u32[0];
        *(v166 + 412) = v39;
        *(v166 + 432) = *(k + 384);
        *(v166 + 448) = v231;
        *(v166 + 452) = v232;
        *(v166 + 456) = a13.n128_u32[0];
        *(v166 + 460) = v39;
        *(v166 + 480) = *(k + 336);
        *(v166 + 496) = v231;
        *(v166 + 500) = v232;
        *(v166 + 504) = a13.n128_u32[0];
        *(v166 + 508) = v39;
        *(v166 + 528) = v178.i64[1];
        *(v166 + 536) = a14.i32[2];
        *(v166 + 540) = v183;
        *(v166 + 544) = v231;
        *(v166 + 548) = v232;
        *(v166 + 552) = a13.n128_u32[0];
        *(v166 + 556) = v39;
        v233 = *(k + 336) - *v178.i32;
        v234 = *(k + 340) - *&v178.i32[1];
        v235 = *(k + 344) - a14.f32[0];
        v236 = ((*&v178.i32[3] - *&v178.i32[1]) * v235) - ((a14.f32[2] - a14.f32[0]) * v234);
        *v24.i32 = ((a14.f32[2] - a14.f32[0]) * v233) - ((*&v178.i32[2] - *v178.i32) * v235);
        a13.n128_f32[0] = ((*&v178.i32[2] - *v178.i32) * v234) - ((*&v178.i32[3] - *&v178.i32[1]) * v233);
        v237 = sqrtf((a13.n128_f32[0] * a13.n128_f32[0]) + ((v236 * v236) + (*v24.i32 * *v24.i32)));
        *v24.i32 = *v24.i32 / v237;
        a13.n128_f32[0] = a13.n128_f32[0] / v237;
        *(v166 + 576) = v178.i64[0];
        *(v166 + 584) = a14.i32[0];
        *(v166 + 588) = v183;
        *(v166 + 592) = v236 / v237;
        *(v166 + 596) = v24.i32[0];
        *(v166 + 600) = a13.n128_u32[0];
        *(v166 + 604) = v39;
        *(v166 + 624) = v178.i64[1];
        *(v166 + 632) = a14.i32[2];
        *(v166 + 636) = v183;
        *(v166 + 640) = v236 / v237;
        *(v166 + 644) = v24.i32[0];
        *(v166 + 648) = a13.n128_u32[0];
        *(v166 + 652) = v39;
        *(v166 + 672) = *(k + 336);
        *(v166 + 688) = v236 / v237;
        *(v166 + 692) = v24.i32[0];
        *(v166 + 696) = a13.n128_u32[0];
        *(v166 + 700) = v39;
        *(v166 + 720) = *(k + 336);
        *(v166 + 736) = v236 / v237;
        *(v166 + 740) = v24.i32[0];
        *(v166 + 744) = a13.n128_u32[0];
        *(v166 + 748) = v39;
        *(v166 + 768) = *(k + 528);
        *(v166 + 784) = v236 / v237;
        *(v166 + 788) = v24.i32[0];
        *(v166 + 792) = a13.n128_u32[0];
        *(v166 + 796) = v39;
        *(v166 + 816) = v178.i64[0];
        *(v166 + 824) = a14.i32[0];
        *(v166 + 828) = v183;
        *(v166 + 832) = v236 / v237;
        *(v166 + 836) = v24.i32[0];
        *(v166 + 840) = a13.n128_u32[0];
        *(v166 + 844) = v39;
        v238 = *(k + 528) - *&v24.i32[2];
        v239 = *(k + 532) - *&v24.i32[3];
        v240 = *(k + 536) - a14.f32[3];
        v241 = ((*&v178.i32[1] - *&v24.i32[3]) * v240) - ((a14.f32[0] - a14.f32[3]) * v239);
        *v24.i32 = ((a14.f32[0] - a14.f32[3]) * v238) - ((*v178.i32 - *&v24.i32[2]) * v240);
        a13.n128_f32[0] = ((*v178.i32 - *&v24.i32[2]) * v239) - ((*&v178.i32[1] - *&v24.i32[3]) * v238);
        v242 = sqrtf((a13.n128_f32[0] * a13.n128_f32[0]) + ((v241 * v241) + (*v24.i32 * *v24.i32)));
        *v24.i32 = *v24.i32 / v242;
        *(v166 + 864) = v24.i32[2];
        *(v166 + 868) = v24.i32[3];
        *(v166 + 872) = a14.i32[3];
        *(v166 + 876) = v183;
        *(v166 + 880) = v241 / v242;
        *(v166 + 884) = v24.i32[0];
        a13.n128_f32[0] = a13.n128_f32[0] / v242;
        *(v166 + 888) = a13.n128_u32[0];
        *(v166 + 892) = v39;
        *(v166 + 912) = v178.i64[0];
        *(v166 + 920) = a14.i32[0];
        *(v166 + 924) = v183;
        *(v166 + 928) = v241 / v242;
        *(v166 + 932) = v24.i32[0];
        *(v166 + 936) = a13.n128_u32[0];
        *(v166 + 940) = v39;
        *(v166 + 960) = *(k + 528);
        *(v166 + 976) = v241 / v242;
        *(v166 + 980) = v24.i32[0];
        *(v166 + 984) = a13.n128_u32[0];
        *(v166 + 988) = v39;
        *(v166 + 1008) = *(k + 528);
        *(v166 + 1024) = v241 / v242;
        *(v166 + 1028) = v24.i32[0];
        *(v166 + 1032) = a13.n128_u32[0];
        *(v166 + 1036) = v39;
        a11 = *v208;
        *(v166 + 1056) = *v208;
        *(v166 + 1072) = v241 / v242;
        *(v166 + 1076) = v24.i32[0];
        *(v166 + 1080) = a13.n128_u32[0];
        *(v166 + 1084) = v39;
        *(v166 + 1104) = v24.i32[2];
        *(v166 + 1108) = v24.i32[3];
        *(v166 + 1112) = a14.i32[3];
        *(v166 + 1116) = v183;
        *(v166 + 1120) = v241 / v242;
        *(v166 + 1124) = v24.i32[0];
        *(v166 + 1128) = a13.n128_u32[0];
        *(v166 + 1132) = v39;
        k += 576;
        v166 += 1152;
        if (a4 < 2)
        {
          return k;
        }
      }

      --a4;
    }
  }

  if (a5 == 3)
  {
    v96 = v42 + 288 * *(a1 + 64) + 48 * ((a2 - v42) >> 4);
    v97 = 1.0;
    v34.f32[1] = a10;
    v58.i32[1] = a19;
    for (j = a3 + 13; ; j += 27)
    {
      v99 = j[1];
      v100 = fminf(fmaxf(v395 - *j, 0.0), v99);
      v101 = fminf(fmaxf((v395 + 1.0) - *j, 0.0), v99) - v99;
      v102 = *j - (v99 + -1.0);
      if (v102 <= v395)
      {
        v103 = 0.0;
      }

      else
      {
        v103 = v395 - v102;
      }

      if (v99 <= v97)
      {
        v103 = v101;
      }

      if (v395 < 0.0)
      {
        *a11.i32 = v103;
      }

      else
      {
        *a11.i32 = v100;
      }

      a12.n128_f32[0] = *(v36 + 168) + (fabsf(*a11.i32) * (*(v36 + 172) - *(v36 + 168)));
      v104 = a12.n128_f32[0] * a7;
      a9.n128_f32[0] = (a12.n128_f32[0] * a7) * 0.5;
      if (a4 && *a11.i32 == 0.0)
      {
        v21.f32[0] = COERCE_FLOAT(*(j - 13)) + (a12.n128_f32[0] * (j[8] - COERCE_FLOAT(*(j - 13))));
        v105.i64[0] = *(j - 13);
        v105.i64[1] = v105.i64[0];
        a14.f32[0] = v105.f32[1] + (a12.n128_f32[0] * (j[9] - v105.f32[1]));
        *&v22 = vdup_lane_s32(a9.n128_u64[0], 0);
        v106 = vaddq_f32(v105, vmulq_n_f32(vsubq_f32(vextq_s8(*(j + 10), *(j + 10), 8uLL), v105), a12.n128_f32[0]));
        v107 = 1.0;
        v108 = 0.0;
        v109 = 0.0;
        v110 = 0.0;
        v111 = 1.0;
      }

      else
      {
        a13.n128_f32[0] = *(j - 13);
        if (a4)
        {
          v390 = a9;
          v381 = a13.n128_u64[0];
          v384 = a12;
          v398 = a11.i64[0];
          v112 = __sincosf_stret((*a11.i32 * (*(j - 2) * 6.2832)) * 0.5);
          a8.f32[0] = v112.__cosval;
          v113.f32[0] = *(j - 6);
          v20.n128_f32[0] = *(j - 5) * v112.__sinval;
          v114.f32[0] = *(j - 9);
          a14.f32[0] = *(j - 12);
          v21.i32[1] = HIDWORD(v398);
          *a11.i32 = *&v398 * (v113.f32[0] * *(j - 7));
          v114.i32[1] = v113.i32[0];
          v113.f32[1] = *(j - 8);
          v58 = vmul_n_f32(*(j - 4), v112.__sinval);
          a13.n128_u64[0] = v381;
          a12 = v384;
          v34 = vadd_f32(vadd_f32(__PAIR64__(a14.u32[0], v381), vmul_n_f32(vmul_f32(v114, v113), *&v398)), vmul_n_f32(vmul_n_f32(*(j + 2), *&v398), *&v398));
          a9 = v390;
          v396 = 1.0;
        }

        else
        {
          a14.f32[0] = *(j - 12);
          a11 = v30;
        }

        v115 = a12.n128_f32[0] * (j[9] - a14.f32[0]);
        *&v22 = j[6];
        v21.f32[0] = a9.n128_f32[0] - *&v22;
        *v24.i32 = (a9.n128_f32[0] - *&v22) * v58.f32[0];
        *v25.i32 = v20.n128_f32[0] * (a9.n128_f32[0] - *&v22);
        v111 = j[7] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - j[7])));
        v116.f32[0] = j[12];
        v27.f32[0] = j[13];
        v116.f32[1] = j[10];
        *v26.f32 = vmul_n_f32(vsub_f32(v116, vdup_lane_s32(a13.n128_u64[0], 0)), a12.n128_f32[0]);
        v27.f32[1] = j[11];
        *a14.f32 = vsub_f32(*v27.f32, vdup_lane_s32(*a14.f32, 0));
        *v27.f32 = vmul_n_f32(*a14.f32, a12.n128_f32[0]);
        v117.i64[0] = *(j + 2);
        a14.f32[0] = (a12.n128_f32[0] * (j[8] - a13.n128_f32[0])) - v117.f32[0];
        v118 = v115 - v117.f32[1];
        v119 = vmuls_lane_f32(v118, v58, 1);
        v120 = vmuls_lane_f32(a14.f32[0], v58, 1);
        v121 = (*v24.i32 - v119) + (*v24.i32 - v119);
        v122 = (v120 - *v25.i32) + (v120 - *v25.i32);
        v123 = ((v20.n128_f32[0] * v118) - (a14.f32[0] * v58.f32[0])) + ((v20.n128_f32[0] * v118) - (a14.f32[0] * v58.f32[0]));
        v124 = vmuls_lane_f32(v121, v58, 1) - (v20.n128_f32[0] * v123);
        a13 = v20;
        v125 = (v20.n128_f32[0] * v122) - (v121 * v58.f32[0]);
        *v126.f32 = v58;
        *&v126.u32[2] = v58;
        *v127.f32 = v34;
        *&v127.u32[2] = v34;
        v128 = v118 + v124;
        v129.i32[0] = vdup_lane_s32(v58, 1).u32[0];
        v130 = (a8.f32[0] * v121) + (a14.f32[0] + ((v123 * v58.f32[0]) - vmuls_lane_f32(v122, v58, 1)));
        a14.f32[0] = (a8.f32[0] * v122) + v128;
        v131 = (a8.f32[0] * v123) + ((a9.n128_f32[0] - *&v22) + v125);
        a14.f32[0] = v117.f32[1] + (v34.f32[1] + a14.f32[0]);
        *v26.f32 = vsub_f32(*v26.f32, vdup_lane_s32(*v117.f32, 0));
        *v27.f32 = vsub_f32(*v27.f32, vdup_lane_s32(*v117.f32, 1));
        *v28.i8 = vsub_f32(vmul_n_f32(*v27.f32, a13.n128_f32[0]), vmul_n_f32(*v26.f32, v58.f32[0]));
        *v28.i8 = vadd_f32(*v28.i8, *v28.i8);
        *v25.i8 = vsub_f32(vmul_lane_f32(*v26.f32, v58, 1), vdup_lane_s32(*v25.i8, 0));
        *v25.i8 = vadd_f32(*v25.i8, *v25.i8);
        *v24.i8 = vsub_f32(vdup_lane_s32(*v24.i8, 0), vmul_lane_f32(*v27.f32, v58, 1));
        *v24.i8 = vadd_f32(*v24.i8, *v24.i8);
        v132 = vmulq_f32(v126, vzip1q_s32(v28, v24));
        v20 = a13;
        v129.i32[1] = a13.n128_u32[0];
        v129.i64[1] = v129.i64[0];
        v133 = vmulq_f32(v129, vzip1q_s32(v25, v28));
        *v129.f32 = vdup_lane_s32(*v21.f32, 0);
        v21 = vaddq_f32(vzip1q_s32(v26, v27), vsubq_f32(v132, v133));
        v134 = vaddq_f32(vmulq_n_f32(vzip1q_s32(v24, v25), a8.f32[0]), v21);
        v21.f32[0] = v117.f32[0] + (v34.f32[0] + v130);
        v117.i64[1] = v117.i64[0];
        v26 = vaddq_f32(v127, v134);
        a9.n128_f32[0] = *&v22 + (*a11.i32 + v131);
        v135 = vadd_f32(*v129.f32, vsub_f32(vmul_n_f32(*v25.i8, a13.n128_f32[0]), vmul_n_f32(*v24.i8, v58.f32[0])));
        *v25.i8 = vmul_f32(*&vdupq_lane_s32(a8, 0), *v28.i8);
        *v24.i8 = vadd_f32(vdup_lane_s32(*a11.i8, 0), vadd_f32(*v25.i8, v135));
        v106 = vaddq_f32(v117, v26);
        *&v22 = vadd_f32(vdup_lane_s32(*&v22, 0), *v24.i8);
        *v24.i32 = vmuls_lane_f32(0.0, v58, 1);
        *v25.i32 = (v58.f32[0] - *v24.i32) + (v58.f32[0] - *v24.i32);
        *v24.i32 = (*v24.i32 - a13.n128_f32[0]) + (*v24.i32 - a13.n128_f32[0]);
        v26.f32[0] = ((a13.n128_f32[0] * 0.0) - (0.0 * v58.f32[0])) + ((a13.n128_f32[0] * 0.0) - (0.0 * v58.f32[0]));
        v108 = (a8.f32[0] * *v25.i32) + (((v26.f32[0] * v58.f32[0]) - vmuls_lane_f32(*v24.i32, v58, 1)) + 0.0);
        v109 = (a8.f32[0] * *v24.i32) + ((vmuls_lane_f32(*v25.i32, v58, 1) - (a13.n128_f32[0] * v26.f32[0])) + 0.0);
        v107 = (a8.f32[0] * v26.f32[0]) + (((a13.n128_f32[0] * *v24.i32) - (*v25.i32 * v58.f32[0])) + v97);
        v110 = (a8.f32[0] * 0.0) + 0.0;
        v30 = a11;
      }

      *k = v21.i32[0];
      *(k + 4) = a14.i32[0];
      *(k + 8) = a9.n128_u32[0];
      *(k + 12) = v111;
      *(k + 16) = v108;
      *(k + 20) = v109;
      *(k + 24) = v107;
      *(k + 28) = v40;
      *(k + 48) = vextq_s8(v106, v106, 8uLL).u64[0];
      *(k + 56) = DWORD1(v22);
      *(k + 60) = v111;
      *(k + 64) = v108;
      *(k + 68) = v109;
      *(k + 72) = v107;
      *(k + 76) = v40;
      *(k + 96) = v106.i64[0];
      *(k + 104) = v22;
      *(k + 108) = v111;
      *(k + 112) = v108;
      *(k + 116) = v109;
      v136 = (k + 144);
      *(k + 120) = v107;
      *(k + 124) = v40;
      if (v104 <= 0.0)
      {
        k += 144;
        if (a4 < 2)
        {
          return k;
        }
      }

      else
      {
        v137 = v21.f32[0] - (v104 * v108);
        a11 = v30;
        v138 = a14.f32[0] - (v104 * v109);
        a13.n128_u32[1] = v34.u32[1];
        v139 = v20;
        v140 = a9.n128_f32[0] - (v104 * v107);
        v141 = v111 - (v104 * v110);
        *(k + 144) = v137;
        *(k + 148) = v138;
        *(k + 152) = v140;
        *(k + 156) = v141;
        *(k + 160) = v108;
        *(k + 164) = v109;
        *(k + 168) = v107;
        *(k + 172) = v387;
        *(k + 192) = *v106.i32 - (v104 * v108);
        *(k + 196) = *&v106.i32[1] - (v104 * v109);
        v97 = 1.0;
        *(k + 200) = *&v22 - (v104 * v107);
        *(k + 204) = v141;
        *(k + 208) = v108;
        *(k + 212) = v109;
        *(k + 216) = v107;
        *(k + 220) = v387;
        *(k + 240) = *&v106.i32[2] - (v104 * v108);
        *(k + 244) = *&v106.i32[3] - (v104 * v109);
        *(k + 248) = *(&v22 + 1) - (v104 * v107);
        *(k + 252) = v141;
        *(k + 256) = v108;
        *(k + 260) = v109;
        *(k + 264) = v107;
        *(k + 268) = v387;
        v142 = v138 - *&v106.i32[3];
        v30 = a11;
        v143 = v140 - *(&v22 + 1);
        v20 = v139;
        v144 = ((a14.f32[0] - *&v106.i32[3]) * v143) - ((a9.n128_f32[0] - *(&v22 + 1)) * v142);
        v145 = ((v137 - *&v106.i32[2]) * (a9.n128_f32[0] - *(&v22 + 1))) - ((v21.f32[0] - *&v106.i32[2]) * v143);
        v146 = ((v21.f32[0] - *&v106.i32[2]) * v142) - ((a14.f32[0] - *&v106.i32[3]) * (v137 - *&v106.i32[2]));
        v147 = sqrtf((v146 * v146) + ((v144 * v144) + (v145 * v145)));
        v148 = v145 / v147;
        v149 = v146 / v147;
        *v96 = v106.i64[1];
        *(v96 + 8) = DWORD1(v22);
        *(v96 + 12) = v111;
        *(v96 + 16) = v144 / v147;
        *(v96 + 20) = v148;
        *(v96 + 24) = v149;
        *(v96 + 28) = v39;
        *(v96 + 48) = v21.i32[0];
        *(v96 + 52) = a14.i32[0];
        *(v96 + 56) = a9.n128_u32[0];
        *(v96 + 60) = v111;
        a12 = a9;
        *(v96 + 64) = v144 / v147;
        *(v96 + 68) = v148;
        *(v96 + 72) = v149;
        *(v96 + 76) = v39;
        *(v96 + 96) = *v136;
        *(v96 + 112) = v144 / v147;
        *(v96 + 116) = v148;
        *(v96 + 120) = v149;
        *(v96 + 124) = v39;
        *(v96 + 144) = *v136;
        *(v96 + 160) = v144 / v147;
        *(v96 + 164) = v148;
        *(v96 + 168) = v149;
        *(v96 + 172) = v39;
        *(v96 + 192) = *(k + 240);
        *(v96 + 208) = v144 / v147;
        *(v96 + 212) = v148;
        *(v96 + 216) = v149;
        *(v96 + 220) = v39;
        *(v96 + 240) = v106.i64[1];
        *(v96 + 248) = DWORD1(v22);
        *(v96 + 252) = v111;
        *(v96 + 256) = v144 / v147;
        *(v96 + 260) = v148;
        *(v96 + 264) = v149;
        *(v96 + 268) = v39;
        v150 = *(k + 240) - *v106.i32;
        v151 = *(k + 244) - *&v106.i32[1];
        v152 = *(k + 248) - *&v22;
        v153 = ((*&v106.i32[3] - *&v106.i32[1]) * v152) - ((*(&v22 + 1) - *&v22) * v151);
        v154 = ((*(&v22 + 1) - *&v22) * v150) - ((*&v106.i32[2] - *v106.i32) * v152);
        v155 = ((*&v106.i32[2] - *v106.i32) * v151) - ((*&v106.i32[3] - *&v106.i32[1]) * v150);
        v156 = sqrtf((v155 * v155) + ((v153 * v153) + (v154 * v154)));
        v157 = v154 / v156;
        v158 = v155 / v156;
        *(v96 + 288) = v106.i64[0];
        *(v96 + 296) = v22;
        *(v96 + 300) = v111;
        *(v96 + 304) = v153 / v156;
        *(v96 + 308) = v157;
        *(v96 + 312) = v158;
        *(v96 + 316) = v39;
        *(v96 + 336) = v106.i64[1];
        *(v96 + 344) = DWORD1(v22);
        *(v96 + 348) = v111;
        *(v96 + 352) = v153 / v156;
        *(v96 + 356) = v157;
        *(v96 + 360) = v158;
        *(v96 + 364) = v39;
        *(v96 + 384) = *(k + 240);
        *(v96 + 400) = v153 / v156;
        *(v96 + 404) = v157;
        *(v96 + 408) = v158;
        *(v96 + 412) = v39;
        *(v96 + 432) = *(k + 240);
        *(v96 + 448) = v153 / v156;
        *(v96 + 452) = v157;
        *(v96 + 456) = v158;
        *(v96 + 460) = v39;
        v24 = *(k + 192);
        *(v96 + 480) = v24;
        *(v96 + 496) = v153 / v156;
        *(v96 + 500) = v157;
        *(v96 + 504) = v158;
        *(v96 + 508) = v39;
        *(v96 + 528) = v106.i64[0];
        *(v96 + 536) = v22;
        *(v96 + 540) = v111;
        *(v96 + 544) = v153 / v156;
        *(v96 + 548) = v157;
        *(v96 + 552) = v158;
        *(v96 + 556) = v39;
        v159 = *(k + 192) - v21.f32[0];
        v160 = *(k + 196) - a14.f32[0];
        v161 = *(k + 200) - a9.n128_f32[0];
        v162 = ((*&v106.i32[1] - a14.f32[0]) * v161) - ((*&v22 - a9.n128_f32[0]) * v160);
        v163 = ((*&v22 - a9.n128_f32[0]) * v159) - ((*v106.i32 - v21.f32[0]) * v161);
        *v24.i32 = ((*v106.i32 - v21.f32[0]) * v160) - ((*&v106.i32[1] - a14.f32[0]) * v159);
        v164 = sqrtf((*v24.i32 * *v24.i32) + ((v162 * v162) + (v163 * v163)));
        v165 = v163 / v164;
        *(v96 + 576) = v21.i32[0];
        *(v96 + 580) = a14.i32[0];
        *(v96 + 584) = a9.n128_u32[0];
        *(v96 + 588) = v111;
        *(v96 + 592) = v162 / v164;
        *(v96 + 596) = v165;
        *v24.i32 = *v24.i32 / v164;
        *(v96 + 600) = v24.i32[0];
        *(v96 + 604) = v39;
        *(v96 + 624) = v106.i64[0];
        *(v96 + 632) = v22;
        *(v96 + 636) = v111;
        *(v96 + 640) = v162 / v164;
        *(v96 + 644) = v165;
        *(v96 + 648) = v24.i32[0];
        *(v96 + 652) = v39;
        *(v96 + 672) = *(k + 192);
        *(v96 + 688) = v162 / v164;
        *(v96 + 692) = v165;
        *(v96 + 696) = v24.i32[0];
        *(v96 + 700) = v39;
        *(v96 + 720) = *(k + 192);
        *(v96 + 736) = v162 / v164;
        *(v96 + 740) = v165;
        *(v96 + 744) = v24.i32[0];
        *(v96 + 748) = v39;
        v22 = *v136;
        *(v96 + 768) = *v136;
        *(v96 + 784) = v162 / v164;
        *(v96 + 788) = v165;
        *(v96 + 792) = v24.i32[0];
        *(v96 + 796) = v39;
        *(v96 + 816) = v21.i32[0];
        *(v96 + 820) = a14.i32[0];
        *(v96 + 824) = a9.n128_u32[0];
        *(v96 + 828) = v111;
        *(v96 + 832) = v162 / v164;
        *(v96 + 836) = v165;
        *(v96 + 840) = v24.i32[0];
        *(v96 + 844) = v39;
        k += 288;
        v96 += 864;
        if (a4 < 2)
        {
          return k;
        }
      }

      --a4;
    }
  }

  v59 = a5 - 1;
  if (a5 != 1)
  {
    v243 = 3 * a5;
    v244 = 6 * a5;
    v245 = 48 * *(v36 + 64) * v244 + a2;
    v246 = 1.0;
    v247 = 8 * (a5 - 4);
    v248 = 3 * a5 - 3;
    v34.f32[1] = a10;
    v58.i32[1] = a19;
    v249 = v59 - 1;
    v250 = v33 + 26;
    v251 = v247 + 116;
    v252 = 6 * a5;
    v253 = -1.0;
    v378 = v36;
    v377 = v248;
    v375 = v252;
    v376 = 3 * a5;
    while (1)
    {
      v254 = v33[13];
      v255 = v33[14];
      v256 = fminf(fmaxf(v395 - v254, 0.0), v255);
      v257 = fminf(fmaxf((v395 + 1.0) - v254, 0.0), v255) - v255;
      v258 = v254 - (v255 + v253);
      if (v258 <= v395)
      {
        v259 = 0.0;
      }

      else
      {
        v259 = v395 - v258;
      }

      if (v255 <= v246)
      {
        v259 = v257;
      }

      if (v395 < 0.0)
      {
        a12.n128_f32[0] = v259;
      }

      else
      {
        a12.n128_f32[0] = v256;
      }

      v260 = *(v36 + 168) + (fabsf(a12.n128_f32[0]) * (*(v36 + 172) - *(v36 + 168)));
      v393 = v260;
      v261 = v260 * a7;
      *&v29 = (v260 * a7) * 0.5;
      v262 = a4 - 1;
      if (a4 && a12.n128_f32[0] == 0.0)
      {
        a8 = *v33;
        v263 = v260;
        v264 = vadd_f32(*v33, vmul_n_f32(vsub_f32(*(v33 + 21), *v33), v260));
        v34 = 0;
        v20.n128_u32[0] = 0;
        v265 = 1.0;
        *&v22 = (v260 * a7) * 0.5;
        a8.i32[0] = 1.0;
        v30.i32[0] = 0;
        v396 = 1.0;
        v266 = xmmword_2603429D0;
        v58 = 0;
      }

      else
      {
        if (a4)
        {
          v386 = a4;
          v267 = v244;
          v268 = v249;
          v380 = v262;
          v383 = v250;
          v269 = v251;
          v379 = v29;
          v400 = a12;
          v270 = __sincosf_stret((a12.n128_f32[0] * (v33[11] * 6.2832)) * 0.5);
          a8.f32[0] = v270.__cosval;
          v29 = v379;
          v253 = -1.0;
          v252 = v375;
          v243 = v376;
          v251 = v269;
          v262 = v380;
          v250 = v383;
          v249 = v268;
          v248 = v377;
          v244 = v267;
          v36 = v378;
          a4 = v386;
          v271.f32[0] = v33[7];
          v20.n128_f32[0] = v33[8] * v270.__sinval;
          v58 = vmul_n_f32(*(v33 + 9), v270.__sinval);
          v272.f32[0] = v33[4];
          a12 = v400;
          *v30.i32 = v400.n128_f32[0] * (v271.f32[0] * v33[6]);
          v272.i32[1] = v271.i32[0];
          v271.f32[1] = v33[5];
          v34 = vadd_f32(vadd_f32(*v33, vmul_n_f32(vmul_f32(v272, v271), v400.n128_f32[0])), vmul_n_f32(vmul_n_f32(*(v33 + 15), v400.n128_f32[0]), v400.n128_f32[0]));
          v396 = 1.0;
        }

        *&v22 = v33[19];
        v273 = *(v33 + 17);
        v274 = vrev64_s32(v58);
        v275 = vsub_f32(v29, vzip1_s32(*&v22, v273));
        v276 = vdup_lane_s32(v275, 0);
        v277.i32[1] = v276.i32[1];
        v277.f32[0] = 0.0 - v273.f32[1];
        v278 = vsub_f32(vmul_f32(v58, v275), vmul_f32(__PAIR64__(v20.n128_u32[0], v274.u32[0]), v277));
        *v26.f32 = vadd_f32(v278, v278);
        v279 = vdup_lane_s32(*v26.f32, 0);
        v280.i32[1] = v26.i32[1];
        v280.f32[0] = 0.0 - v273.f32[1];
        *a11.i8 = vsub_f32(vmul_n_f32(v280, v20.n128_f32[0]), vmul_n_f32(vext_s8(v275, *v26.f32, 4uLL), v58.f32[0]));
        v276.i32[0] = a11.i32[0];
        *a11.i8 = vadd_f32(v276, *a11.i8);
        v279.i32[0] = a11.i32[0];
        v264 = vadd_f32(v273, vadd_f32(v34, vadd_f32(vmul_f32(*&vdupq_lane_s32(a8, 0), *v26.f32), vadd_f32(vext_s8(v275, v277, 4uLL), vsub_f32(vmul_f32(v58, v279), vmul_f32(__PAIR64__(v20.n128_u32[0], v274.u32[0]), vext_s8(*v26.f32, v279, 4uLL)))))));
        *&v22 = *&v22 + (*v30.i32 + ((a8.f32[0] * *a11.i32) + *&a11.i32[1]));
        v281 = vmul_f32(v58, 0);
        v277.i32[1] = v274.i32[1];
        v277.f32[0] = v20.n128_f32[0] * 0.0;
        *a11.i8 = vsub_f32(v277, v281);
        *a11.i8 = vadd_f32(*a11.i8, *a11.i8);
        v282 = vdup_lane_s32(*a11.i8, 0);
        v282.f32[0] = (v281.f32[1] - v20.n128_f32[0]) + (v281.f32[1] - v20.n128_f32[0]);
        v283 = vsub_f32(vmul_f32(v58, *a11.i8), vmul_f32(__PAIR64__(v20.n128_u32[0], v274.u32[0]), v282));
        v274.i32[0] = v20.n128_u32[0];
        v284 = vtrn2q_s32(a11, 0);
        v284.f32[1] = v282.f32[0];
        v284.i32[2] = a11.i32[0];
        *a11.i32 = v282.f32[0];
        v285 = vmul_f32(v274, *a11.i8);
        *v286.f32 = vadd_f32(v283, 0);
        v287 = vmulq_n_f32(v284, a8.f32[0]);
        v265 = v33[20] + (v396 + (v287.f32[3] + (0.0 - v33[20])));
        v286.i64[1] = COERCE_UNSIGNED_INT(vsub_f32(v285, vdup_lane_s32(v285, 1)).f32[0] + v246);
        v266 = vaddq_f32(v287, v286);
        v263 = v393;
      }

      *k = v264;
      *(k + 8) = v22;
      *(k + 12) = v265;
      *(k + 16) = v266.i64[0];
      *(k + 24) = v266.i32[2];
      *(k + 28) = v40;
      v26.f32[0] = v33[19];
      v288 = *(v33 + 17);
      v289.i32[0] = v29;
      v289.f32[1] = v263 * (v33[21] - *v33);
      v290 = vsub_f32(v289, vzip1_s32(*v26.f32, v288));
      v295 = vrev64_s32(v58);
      v291 = __PAIR64__(v20.n128_u32[0], v295.u32[0]);
      v292 = vdup_lane_s32(v290, 0);
      v292.f32[0] = (v263 * (v33[22] - v33[1])) - v288.f32[1];
      v293 = vsub_f32(vmul_f32(v58, v290), vmul_f32(__PAIR64__(v20.n128_u32[0], v295.u32[0]), v292));
      v294 = vadd_f32(v293, v293);
      v295.i32[0] = v20.n128_u32[0];
      v296 = vext_s8(v290, v292, 4uLL);
      v297 = v290.f32[0] + (vmuls_lane_f32(v20.n128_f32[0], v294, 1) - vmul_f32(v58, v294).f32[0]);
      v290.f32[0] = (v263 * (v33[22] - v33[1])) - v288.f32[1];
      v298 = v33[20] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - v33[20])));
      v299 = vmul_f32(v295, v290);
      v300 = vsub_f32(v299, vdup_lane_s32(v299, 1));
      v301 = vdup_lane_s32(v294, 0);
      v301.f32[0] = vadd_f32(v300, v300).f32[0];
      *(k + 48) = vadd_f32(v288, vadd_f32(v34, vadd_f32(vmul_n_f32(v294, a8.f32[0]), vadd_f32(v296, vsub_f32(vmul_f32(v58, v301), vmul_f32(v291, vext_s8(v294, v301, 4uLL)))))));
      v302 = (k + 48);
      *(k + 56) = v26.f32[0] + (*v30.i32 + ((a8.f32[0] * v301.f32[0]) + v297));
      *(k + 60) = v298;
      *(k + 64) = v266.i64[0];
      *(k + 72) = v266.i32[2];
      *(k + 76) = v40;
      v26.f32[0] = v33[19];
      v288.f32[0] = v33[20] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - v33[20])));
      v303 = *(v33 + 17);
      v301.i32[0] = v29;
      v301.f32[1] = v263 * (v33[23] - *v33);
      v304 = vsub_f32(v301, vzip1_s32(*v26.f32, v303));
      v305 = vdup_lane_s32(v304, 0);
      v305.f32[0] = (v263 * (v33[24] - v33[1])) - v303.f32[1];
      v306 = vsub_f32(vmul_f32(v58, v304), vmul_f32(v291, v305));
      v307 = vadd_f32(v306, v306);
      v308 = vext_s8(v304, v305, 4uLL);
      v296.f32[0] = v304.f32[0] + (vmuls_lane_f32(v20.n128_f32[0], v307, 1) - vmul_f32(v58, v307).f32[0]);
      v304.f32[0] = (v263 * (v33[24] - v33[1])) - v303.f32[1];
      v309 = vmul_f32(v295, v304);
      v310 = vsub_f32(v309, vdup_lane_s32(v309, 1));
      v311 = vdup_lane_s32(v307, 0);
      v311.f32[0] = vadd_f32(v310, v310).f32[0];
      *(k + 96) = vadd_f32(v303, vadd_f32(v34, vadd_f32(vmul_n_f32(v307, a8.f32[0]), vadd_f32(v308, vsub_f32(vmul_f32(v58, v311), vmul_f32(v291, vext_s8(v307, v311, 4uLL)))))));
      *(k + 104) = v26.f32[0] + (*v30.i32 + ((a8.f32[0] * v311.f32[0]) + v296.f32[0]));
      *(k + 108) = v288.i32[0];
      *(k + 112) = v266.i64[0];
      *(k + 120) = v266.i32[2];
      *(k + 124) = v40;
      if (v59 < 2)
      {
        v329 = 3;
      }

      else
      {
        v312.i32[0] = vdup_lane_s32(v58, 1).u32[0];
        v312.i32[1] = v20.n128_u32[0];
        v313 = 2;
        v314 = v250;
        v315 = v249;
        do
        {
          v316 = (k + 48 * (v313 + 1));
          *v316 = v264;
          v316[1].i32[0] = v22;
          v316[1].f32[1] = v265;
          v316[2] = *v266.f32;
          v316[3].i32[0] = v266.i32[2];
          v316[3].f32[1] = v40;
          v317 = k + 48 * (v313 + 2);
          v318 = *(k + 48 * v313);
          *(v317 + 16) = v266.i64[0];
          *v317 = v318;
          *(v317 + 24) = v266.i32[2];
          *(v317 + 28) = v40;
          v26.f32[0] = v33[19];
          v319 = *(v33 + 17);
          v320.i32[0] = v29;
          v320.f32[1] = v263 * (*(v314 - 1) - *v33);
          v321 = vsub_f32(v320, vzip1_s32(*v26.f32, v319));
          v322 = vdup_lane_s32(v321, 0);
          v322.f32[0] = (v263 * (*v314 - v33[1])) - v319.f32[1];
          v323 = vsub_f32(vmul_f32(v58, v321), vmul_f32(v312, v322));
          v324 = vadd_f32(v323, v323);
          v325 = vext_s8(v321, v322, 4uLL);
          v326 = v321.f32[0] + (vmuls_lane_f32(v20.n128_f32[0], v324, 1) - vmul_f32(v58, v324).f32[0]);
          v321.f32[0] = (v263 * (*v314 - v33[1])) - v319.f32[1];
          v313 += 3;
          *&v318 = vmul_f32(v295, v321);
          *&v318 = vsub_f32(*&v318, vdup_lane_s32(*&v318, 1));
          v327 = vdup_lane_s32(v324, 0);
          v327.f32[0] = vadd_f32(*&v318, *&v318).f32[0];
          v328 = (k + 48 * v313);
          v321.f32[0] = v33[20] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - v33[20])));
          v328[1].f32[0] = v26.f32[0] + (*v30.i32 + ((a8.f32[0] * v327.f32[0]) + v326));
          v328[1].i32[1] = v321.i32[0];
          *v328 = vadd_f32(v319, vadd_f32(v34, vadd_f32(vmul_n_f32(v324, a8.f32[0]), vadd_f32(v325, vsub_f32(vmul_f32(v58, v327), vmul_f32(v312, vext_s8(v324, v327, 4uLL)))))));
          v328[2] = *v266.f32;
          v328[3].i32[0] = v266.i32[2];
          v328[3].f32[1] = v40;
          v314 += 2;
          --v315;
        }

        while (v315);
        v329 = v248;
        v246 = 1.0;
      }

      v330 = (k + 48 * v329);
      *v330 = v264;
      v330[1].i32[0] = v22;
      v330[1].f32[1] = v265;
      v330[2] = *v266.f32;
      v330[3].i32[0] = v266.i32[2];
      v330[3].f32[1] = v40;
      v331 = k + 48 * (v329 + 1);
      *v331 = *(k + 48 * (v329 - 1));
      *(v331 + 16) = v266.i64[0];
      *(v331 + 24) = v266.i32[2];
      *(v331 + 28) = v40;
      v332 = k + 48 * (v329 + 2);
      a11 = *v302;
      *v332 = *v302;
      *(v332 + 16) = v266.i64[0];
      *(v332 + 24) = v266.i32[2];
      *(v332 + 28) = v40;
      v333 = k + 48 * v243;
      if (v261 == 0.0)
      {
        k += 48 * v243;
        if (a4 < 2)
        {
          return k;
        }
      }

      else
      {
        v334 = vmulq_n_f32(v266, v261);
        *v333 = vsub_f32(v264, *v334.f32);
        *(v333 + 8) = *&v22 - v334.f32[2];
        *(v333 + 12) = v265 - v334.f32[3];
        *(v333 + 48) = vsubq_f32(*(k + 96), v334);
        *(v333 + 96) = vsubq_f32(*(k + 48), v334);
        *(v333 + 16) = v266.i64[0];
        *(v333 + 24) = v266.i32[2];
        *(v333 + 28) = v387;
        *(v333 + 64) = v266.i64[0];
        *(v333 + 72) = v266.i32[2];
        *(v333 + 76) = v387;
        *(v333 + 112) = v266.i64[0];
        *(v333 + 120) = v266.i32[2];
        *(v333 + 124) = v387;
        if (v59 < 2)
        {
          v340 = 3;
        }

        else
        {
          v335 = 5;
          v336 = v249;
          do
          {
            v337 = v333 + 48 * (v335 - 2);
            *v337 = *v333;
            *(v337 + 16) = v266.i64[0];
            *(v337 + 24) = v266.i32[2];
            *(v337 + 28) = v387;
            v338 = (v333 + 48 * (v335 - 1));
            *v338 = vsubq_f32(*(k + 48 * v335), v334);
            v338[1].i64[0] = v266.i64[0];
            v338[1].i32[2] = v266.i32[2];
            v338[1].i32[3] = v387;
            v339 = v333 + 48 * v335;
            *v339 = *(v333 + 48 * (v335 - 4));
            *(v339 + 16) = v266.i64[0];
            *(v339 + 24) = v266.i32[2];
            *(v339 + 28) = v387;
            v335 += 3;
            --v336;
          }

          while (v336);
          v340 = v248;
        }

        v341 = v333 + 48 * v340;
        *v341 = *v333;
        *(v341 + 16) = v266.i64[0];
        *(v341 + 24) = v266.i32[2];
        *(v341 + 28) = v387;
        v342 = v333 + 48 * (v340 + 1);
        *v342 = *(v333 + 96);
        *(v342 + 16) = v266.i64[0];
        *(v342 + 24) = v266.i32[2];
        *(v342 + 28) = v387;
        v343 = 48 * (v340 - 2);
        v344 = (v333 + 48 * (v340 + 2));
        a11 = *(v333 + v343);
        *v344 = a11;
        v344[1].n128_u64[0] = v266.i64[0];
        v344[1].n128_u32[2] = v266.u32[2];
        v344[1].n128_u32[3] = v387;
        if (a5)
        {
          v345 = 0;
          v346 = 2;
          do
          {
            v347 = (k + 48 * (v346 - 1));
            v348 = (k + 48 * v346);
            v349 = v348[1];
            v350 = *v347 - *v348;
            v351 = v348[2];
            v352 = v347[1] - v349;
            v353 = (v333 + 48 * v346);
            v354 = *v353 - *v348;
            v355 = v353[1] - v349;
            v356 = v347[2] - v351;
            v357 = v353[2] - v351;
            v358 = (v352 * v357) - (v356 * v355);
            v359 = (v356 * v354) - (v350 * v357);
            v360 = (v350 * v355) - (v352 * v354);
            v361 = sqrtf((v360 * v360) + ((v358 * v358) + (v359 * v359)));
            v362 = v358 / v361;
            v363 = v359 / v361;
            v364 = v360 / v361;
            v365 = v245 + 48 * v345;
            *v365 = *v348;
            *(v365 + 16) = v358 / v361;
            *(v365 + 20) = v363;
            *(v365 + 24) = v364;
            *(v365 + 28) = v39;
            v366 = v245 + 48 * (v345 + 1);
            v367 = *v347;
            *(v366 + 16) = v362;
            *(v366 + 20) = v363;
            *(v366 + 24) = v364;
            *(v366 + 28) = v39;
            *v366 = v367;
            v368 = v245 + 48 * (v345 + 2);
            v369 = *v353;
            *(v368 + 16) = v362;
            *(v368 + 20) = v363;
            *v368 = v369;
            *(v368 + 24) = v364;
            *(v368 + 28) = v39;
            v370 = v245 + 48 * (v345 + 3);
            *v370 = *v353;
            *(v370 + 16) = v362;
            *(v370 + 20) = v363;
            *(v370 + 24) = v364;
            *(v370 + 28) = v39;
            v371 = v245 + 48 * (v345 + 4);
            v372 = *(v333 + 48 * (v346 - 1));
            *(v371 + 16) = v362;
            *(v371 + 20) = v363;
            *(v371 + 24) = v364;
            *(v371 + 28) = v39;
            *v371 = v372;
            a11 = *v348;
            v373 = (v245 + 48 * (v345 + 5));
            v373[1].n128_f32[0] = v362;
            v373[1].n128_f32[1] = v363;
            *v373 = a11;
            v373[1].n128_f32[2] = v364;
            v373[1].n128_f32[3] = v39;
            v345 += 6;
            v346 += 3;
          }

          while (v252 != v345);
        }

        k = v333 + 48 * v243;
        v245 += 48 * v244;
        if (a4 < 2)
        {
          return k;
        }
      }

      v33 = (v33 + v247 + 116);
      v250 = (v250 + v251);
      a4 = v262;
    }
  }

  v60 = v20;
  v34.f32[1] = a10;
  v58.i32[1] = a19;
  for (k = a2 + 48; ; k += 48)
  {
    v61 = v33[13];
    v62 = v33[14];
    v63 = fminf(fmaxf(v395 - v61, 0.0), v62);
    v64 = fminf(fmaxf((v395 + 1.0) - v61, 0.0), v62) - v62;
    v65 = v61 - (v62 + -1.0);
    if (v65 <= v395)
    {
      v66 = 0.0;
    }

    else
    {
      v66 = v395 - v65;
    }

    if (v62 <= 1.0)
    {
      v66 = v64;
    }

    v67 = v395 < 0.0 ? v66 : v63;
    *a11.i32 = ((*(v36 + 168) + (fabsf(v67) * (*(v36 + 172) - *(v36 + 168)))) * a7) * 0.5;
    if (a4 && v67 == 0.0)
    {
      v68 = *(v33 + 21);
      v69 = 1.0;
      v70 = 0.0;
      v71 = 0x3F80000000000000;
    }

    else
    {
      *&v22 = *v33;
      if (a4)
      {
        v388 = v22;
        v389 = a11;
        v397 = v67;
        v72 = __sincosf_stret((v67 * (v33[11] * 6.2832)) * 0.5);
        a8.f32[0] = v72.__cosval;
        v73.f32[0] = v33[7];
        v74.n128_f32[0] = v33[8] * v72.__sinval;
        v75.f32[0] = v33[4];
        v76 = v33[1];
        *v30.i32 = v397 * (v73.f32[0] * v33[6]);
        v22 = v388;
        a11 = v389;
        v75.i32[1] = v73.i32[0];
        v73.f32[1] = v33[5];
        v58 = vmul_n_f32(*(v33 + 9), v72.__sinval);
        v34 = vadd_f32(vadd_f32(__PAIR64__(LODWORD(v76), v388), vmul_n_f32(vmul_f32(v75, v73), v397)), vmul_n_f32(vmul_n_f32(*(v33 + 15), v397), v397));
        v396 = 1.0;
      }

      else
      {
        v76 = v33[1];
        v74 = v60;
      }

      v23.f32[0] = v33[19];
      v77 = *(v33 + 17);
      *&v78 = (v33[22] - v76) - v77.f32[1];
      *&a11.i32[1] = v33[21] - *&v22;
      v79 = vsub_f32(*a11.i8, vzip1_s32(v23, v77));
      v80 = vrev64_s32(v58);
      v81 = __PAIR64__(v74.n128_u32[0], v80.u32[0]);
      v82 = vdup_lane_s32(v79, 0);
      v83 = __PAIR64__(v82.u32[1], v78);
      v84 = vsub_f32(vmul_f32(v58, v79), vmul_f32(__PAIR64__(v74.n128_u32[0], v80.u32[0]), __PAIR64__(v82.u32[1], v78)));
      v85 = vadd_f32(v84, v84);
      v86 = vdup_lane_s32(v85, 0);
      v87 = vsub_f32(vmul_n_f32(__PAIR64__(v85.u32[1], v78), v74.n128_f32[0]), vmul_n_f32(vext_s8(v79, v85, 4uLL), v58.f32[0]));
      v82.i32[0] = v87.i32[0];
      v88 = vadd_f32(v82, v87);
      v86.i32[0] = v88.i32[0];
      v68 = vadd_f32(v77, vadd_f32(v34, vadd_f32(vmul_n_f32(v85, a8.f32[0]), vadd_f32(vext_s8(v79, v83, 4uLL), vsub_f32(vmul_f32(v58, v86), vmul_f32(__PAIR64__(v74.n128_u32[0], v80.u32[0]), vext_s8(v85, v86, 4uLL)))))));
      *a11.i32 = v23.f32[0] + (*v30.i32 + ((a8.f32[0] * v88.f32[0]) + v88.f32[1]));
      v69 = v33[20] + (v396 + ((a8.f32[0] * 0.0) + (0.0 - v33[20])));
      v89 = vmul_f32(__PAIR64__(v74.n128_u32[0], v80.u32[0]), 0);
      v90 = vsub_f32(v58, v89);
      v79.i32[0] = v74.n128_u32[0];
      v79.f32[1] = 0.0 * v58.f32[0];
      v91 = vsub_f32(v89, v79);
      v89.f32[0] = vadd_f32(v90, v90).f32[0];
      v92 = vadd_f32(v91, v91);
      v93 = vrev64_s32(v92);
      v94 = vmul_f32(v58, v93);
      v93.i32[0] = v89.i32[0];
      v60 = v74;
      v80.i32[0] = v74.n128_u32[0];
      v95 = vadd_f32(vsub_f32(vmul_f32(v81, v93), vmul_f32(v80, vext_s8(v92, v93, 4uLL))), 0x3F80000000000000);
      v23 = vmul_n_f32(v92, a8.f32[0]);
      v70 = (a8.f32[0] * v89.f32[0]) + (vsub_f32(v94, vdup_lane_s32(v94, 1)).f32[0] + 0.0);
      v71 = vadd_f32(v23, v95);
    }

    *(k - 48) = v68;
    *(k - 40) = a11.i32[0];
    *(k - 36) = v69;
    *(k - 32) = v70;
    *(k - 28) = v71;
    *(k - 20) = v40;
    if (a4 < 2)
    {
      break;
    }

    v33 += 23;
    --a4;
  }

  return k;
}

uint64_t HGFractured::Effect::apply_polar(uint64_t this, HGFractured::Effect *a2, float a3, int a4, double a5, __n128 a6, double a7, int32x4_t a8, __n128 a9, __n128 a10, float32x4_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (*(this + 64))
  {
    v16 = a2;
    v18 = this;
    v19 = 0;
    v20 = *(this + 8 * (a2 != 0) + 96);
    v21 = *(this + 56);
    v22 = a3 + 1.0;
    do
    {
      a6.n128_f32[0] = *v21;
      v24 = v21[1];
      v26 = v21[13];
      v25 = v21[14];
      if (a3 >= 0.0)
      {
        v28 = fminf(fmaxf(a3 - v26, 0.0), v25);
        if (v28 != 0.0)
        {
          goto LABEL_13;
        }
      }

      else if (v25 <= 1.0)
      {
        v28 = fminf(fmaxf(v22 - v26, 0.0), v25) - v25;
        if (v28 != 0.0)
        {
          goto LABEL_13;
        }
      }

      else
      {
        v27 = v26 - (v25 + -1.0);
        if (v27 > a3)
        {
          v28 = a3 - v27;
          if ((a3 - v27) != 0.0)
          {
LABEL_13:
            v29 = v21[7];
            v30 = sqrtf((a6.n128_f32[0] * a6.n128_f32[0]) + (v24 * v24)) + (v28 * (v21[4] * v29));
            v31 = atan2f(v21[1], *v21);
            v32 = __sincosf_stret(v31 + (v28 * (v29 * v21[5])));
            v33 = v30 * v32.__cosval;
            v34 = v30 * v32.__sinval;
            v35 = v28 * (v29 * v21[6]);
            v36 = (v28 * (v28 * v21[15])) + v33;
            v37 = v34 + (v28 * (v28 * v21[16]));
            v38 = __sincosf_stret((v28 * (v21[11] * 6.2832)) * 0.5);
            cosval = v38.__cosval;
            *a8.i32 = v35;
            v24 = v37;
            a6.n128_f32[0] = v36;
            a10.n128_f32[0] = v21[8] * v38.__sinval;
            a11.f32[0] = v21[9] * v38.__sinval;
            a9.n128_f32[0] = v21[10] * v38.__sinval;
            goto LABEL_4;
          }
        }
      }

      cosval = 1.0;
      a10.n128_u64[0] = 0;
      a11.i64[0] = 0;
      a9.n128_u64[0] = 0;
      a8.i64[0] = 0;
LABEL_4:
      v39 = a9.n128_u32[0];
      a9.n128_u32[0] = 1.0;
      this = emit(v18, v20, v21, 0, *(v18 + 124), v16, *(v18 + 136), 0, a6, v24, a8, a9, a10, a11, a15, a16, a10.n128_u32[0], a11.i32[0], v39, SLODWORD(cosval));
      v20 = this;
      v21 += 2 * *(v18 + 124) + 21;
      ++v19;
    }

    while (v19 < *(v18 + 64));
  }

  return this;
}

uint64_t apply_whirl(uint64_t result, float a2, int a3)
{
  if (*(result + 64))
  {
    v4 = result;
    v5 = 0;
    v6 = *(result + 8 * (a3 != 0) + 96);
    v7 = *(result + 56);
    v8 = 1.0;
    v9 = 0.5;
    v10 = 0.25;
    do
    {
      v74 = *v7;
      v45 = v7[6].f32[1];
      v46 = v7[7].f32[0];
      v47 = fminf(fmaxf(a2 - v45, 0.0), v46);
      v48 = fminf(fmaxf((a2 + 1.0) - v45, 0.0), v46) - v46;
      v49 = v45 - (v46 + -1.0);
      v50 = v49 > a2;
      v51 = a2 - v49;
      if (!v50)
      {
        v51 = 0.0;
      }

      if (v46 <= v8)
      {
        v51 = v48;
      }

      if (a2 < 0.0)
      {
        v52 = v51;
      }

      else
      {
        v52 = v47;
      }

      v53 = -(v7[3].f32[1] * -3.14159265 * v52);
      if (a3 >= 0)
      {
        v53 = v7[3].f32[1] * -3.14159265 * v52;
      }

      v54 = v53;
      v57 = __sincosf_stret(v54 * v9);
      v58 = v7[2];
      v59 = v7[3].f32[0];
      if (v52 < v10)
      {
        v11.f32[0] = v10 - v52;
        if (v52 < 0.125)
        {
          v11.f32[0] = v52;
        }

        v12 = fminf(fmaxf(v52 * 4.0, 0.0), v8);
        v11.f32[1] = v12 * v12;
        v56.i32[0] = 1036831949;
        v13.i32[0] = vdup_lane_s32(v56, 0).u32[0];
        v13.f32[1] = 3.0 - (v12 + v12);
        v14 = vmul_f32(v11, v13);
        v15 = vadd_f32(vmul_lane_f32(v58, v14, 1), vmul_n_f32(v74, v8 - v14.f32[1]));
        v16 = vmuls_lane_f32(v59, v14, 1) + ((v8 - v14.f32[1]) * 0.0);
        v75 = v14.f32[1] + (v8 - v14.f32[1]);
        v17 = vmul_f32(v14, 0x3E80000041000000);
        v13.i32[0] = vadd_f32(v17, __PAIR64__(v15.u32[1], COERCE_UNSIGNED_INT(vmuls_lane_f32(v15.f32[0], v17, 1)))).u32[0];
        v13.i32[1] = vmul_f32(v17, v15).i32[1];
        v73 = vsub_f32(v15, v13);
        v18 = v16 - vmuls_lane_f32(v16, v17, 1);
        v19 = v74.f32[0];
      }

      else
      {
        if (v52 < 0.75)
        {
          __asm { FMOV            V1.2S, #-0.25 }

          v73 = vadd_f32(v58, vmul_f32(v58, _D1));
          v18 = v59 + (v59 * -0.25);
          v20 = v74.f32[0] * 3.14159265;
          v75 = 1.0;
          goto LABEL_7;
        }

        v65 = v8 - v52;
        if (v52 < 0.875)
        {
          v65 = v52 + -0.75;
        }

        *v55.i32 = fminf(fmaxf((v52 + -0.75) * 4.0, 0.0), v8);
        v66 = (*v55.i32 * *v55.i32) * (3.0 - (*v55.i32 + *v55.i32));
        *v55.i32 = v8 - v66;
        v67 = (v66 * 0.0) + (v59 * (v8 - v66));
        v75 = v66 + (v8 - v66);
        v68 = vdup_lane_s32(v55, 0);
        v68.f32[0] = v65 * 0.1;
        v69 = vadd_f32(vmul_n_f32(v74, v66), vmul_n_f32(v58, v8 - v66));
        v70 = vmul_f32(v68, 0x3E80000041000000);
        v71.i32[0] = vadd_f32(v70, __PAIR64__(v69.u32[1], COERCE_UNSIGNED_INT(vmuls_lane_f32(v69.f32[0], v70, 1)))).u32[0];
        v71.i32[1] = vmul_f32(v70, v69).i32[1];
        v73 = vsub_f32(v69, v71);
        v18 = v67 - vmuls_lane_f32(v67, v70, 1);
        v19 = v74.f32[0];
      }

      v20 = v19 * 3.14159265 * v7[5].f32[1];
LABEL_7:
      v22 = v7[4].f32[0];
      v21 = v7[4].f32[1];
      v23 = v22 * v57.__sinval;
      v24 = v21 * v57.__sinval;
      v25 = v7[5].f32[0];
      v26 = v25 * v57.__sinval;
      v27 = v20 * v57.__cosval;
      v28 = __sincosf_stret(v27 * 0.5);
      v29.f32[0] = v25 * v28.__sinval;
      v30.n128_f32[0] = v21 * v28.__sinval;
      v31 = v22 * v28.__sinval;
      v32 = vmuls_lane_f32(v25 * v57.__sinval, v73, 1);
      v33 = vmuls_lane_f32(v22 * v57.__sinval, v73, 1);
      v34 = ((v24 * v18) - v32) + ((v24 * v18) - v32);
      v35 = ((v26 * v73.f32[0]) - (v23 * v18)) + ((v26 * v73.f32[0]) - (v23 * v18));
      v36 = (v33 - (v24 * v73.f32[0])) + (v33 - (v24 * v73.f32[0]));
      v37 = v73.f32[1] + (((v25 * v57.__sinval) * v34) - ((v22 * v57.__sinval) * v36));
      v38 = v18 + (((v22 * v57.__sinval) * v35) - ((v21 * v57.__sinval) * v34));
      v39.n128_f32[0] = (v57.__cosval * v34) + (v73.f32[0] + (((v21 * v57.__sinval) * v36) - ((v25 * v57.__sinval) * v35)));
      v40 = (v57.__cosval * v35) + v37;
      *v41.i32 = (v57.__cosval * v36) + v38;
      v42.n128_f32[0] = (v57.__cosval * 0.0) + v75;
      result = emit(v4, v6, v7, 0, *(v4 + 124), a3, *(v4 + 136), 0, v39, v40, v41, v42, v30, v29, v43, v44, COERCE_UNSIGNED_INT32(((v23 * v28.__cosval) + ((v24 * v29.f32[0]) + (v57.__cosval * v31))) - (v26 * v30.n128_f32[0])), COERCE__INT32(((v26 * v31) + ((v24 * v28.__cosval) + (v57.__cosval * v30.n128_f32[0]))) - (v23 * v29.f32[0])), COERCE__INT32(((v57.__cosval * v29.f32[0]) + ((v26 * v28.__cosval) + (v23 * v30.n128_f32[0]))) - (v24 * v31)), COERCE__INT32((((v57.__cosval * v28.__cosval) - (v23 * v31)) - (v26 * v29.f32[0])) - (v24 * v30.n128_f32[0])));
      v9 = 0.5;
      v6 = result;
      v7 = (v7 + 8 * *(v4 + 124) + 84);
      ++v5;
      v8 = 1.0;
      v10 = 0.25;
    }

    while (v5 < *(v4 + 64));
  }

  return result;
}

uint64_t apply_twirl(uint64_t result, float a2, int a3)
{
  if (*(result + 64))
  {
    v4 = result;
    v5 = 0;
    v6 = *(result + 8 * (a3 != 0) + 96);
    v7 = 1.0;
    v8 = *(result + 56);
    v9 = 0.5;
    do
    {
      v56 = *v8;
      v41 = v8[6].f32[1];
      v42 = v8[7].f32[0];
      v43 = fminf(fmaxf(a2 - v41, 0.0), v42);
      v44 = fminf(fmaxf((a2 + 1.0) - v41, 0.0), v42) - v42;
      v45 = v41 - (v42 + -1.0);
      v46 = v45 > a2;
      v47 = a2 - v45;
      if (!v46)
      {
        v47 = 0.0;
      }

      if (v42 <= v7)
      {
        v47 = v44;
      }

      if (a2 < 0.0)
      {
        v48 = v47;
      }

      else
      {
        v48 = v43;
      }

      v49 = -(v8[3].f32[1] * -3.14159265 * v48);
      if (a3 >= 0)
      {
        v49 = v8[3].f32[1] * -3.14159265 * v48;
      }

      v50 = v49;
      v51 = __sincosf_stret(v50 * v9);
      v52 = v8[2];
      v13 = v8[3].f32[0];
      if (v48 < 0.25)
      {
        v10 = fminf(fmaxf(v48 * 4.0, 0.0), v7);
        v11 = (v10 * v10) * (3.0 - (v10 + v10));
        v12 = v56.f32[0];
        v57 = vadd_f32(vmul_n_f32(v52, v11), vmul_n_f32(v56, v7 - v11));
        v13 = (v13 * v11) + ((v7 - v11) * 0.0);
        v14 = v11 + (v7 - v11);
      }

      else
      {
        if (v48 < 0.75)
        {
          v15 = v56.f32[0] * 3.14159265;
          v58 = 1.0;
          v16 = 0.5;
          v57 = v8[2];
          goto LABEL_5;
        }

        v53 = fminf(fmaxf((v48 + -0.75) * 4.0, 0.0), v7);
        v54 = (v53 * v53) * (3.0 - (v53 + v53));
        v12 = v56.f32[0];
        v57 = vadd_f32(vmul_n_f32(v56, v54), vmul_n_f32(v52, v7 - v54));
        v13 = (v54 * 0.0) + (v13 * (v7 - v54));
        v14 = v54 + (v7 - v54);
      }

      v58 = v14;
      v15 = v12 * 3.14159265 * v8[5].f32[1];
      v16 = 0.5;
LABEL_5:
      v18 = v8[4].f32[0];
      v17 = v8[4].f32[1];
      v19 = v18 * v51.__sinval;
      v20 = v17 * v51.__sinval;
      v21 = v8[5].f32[0];
      v22 = v21 * v51.__sinval;
      v23 = v15 * v51.__cosval;
      v24 = __sincosf_stret(v23 * v16);
      v25.f32[0] = v21 * v24.__sinval;
      v26.n128_f32[0] = v17 * v24.__sinval;
      v27 = v18 * v24.__sinval;
      v28 = vmuls_lane_f32(v21 * v51.__sinval, v57, 1);
      v29 = vmuls_lane_f32(v18 * v51.__sinval, v57, 1);
      v30 = ((v20 * v13) - v28) + ((v20 * v13) - v28);
      v31 = ((v22 * v57.f32[0]) - (v19 * v13)) + ((v22 * v57.f32[0]) - (v19 * v13));
      v32 = (v29 - (v20 * v57.f32[0])) + (v29 - (v20 * v57.f32[0]));
      v33 = v57.f32[1] + (((v21 * v51.__sinval) * v30) - ((v18 * v51.__sinval) * v32));
      v34 = v13 + (((v18 * v51.__sinval) * v31) - ((v17 * v51.__sinval) * v30));
      v35.n128_f32[0] = (v51.__cosval * v30) + (v57.f32[0] + (((v17 * v51.__sinval) * v32) - ((v21 * v51.__sinval) * v31)));
      v36 = (v51.__cosval * v31) + v33;
      *v37.i32 = (v51.__cosval * v32) + v34;
      v38.n128_f32[0] = (v51.__cosval * 0.0) + v58;
      result = emit(v4, v6, v8, 0, *(v4 + 124), a3, *(v4 + 136), 0, v35, v36, v37, v38, v26, v25, v39, v40, COERCE_UNSIGNED_INT32(((v19 * v24.__cosval) + ((v20 * v25.f32[0]) + (v51.__cosval * v27))) - (v22 * v26.n128_f32[0])), COERCE__INT32(((v22 * v27) + ((v20 * v24.__cosval) + (v51.__cosval * v26.n128_f32[0]))) - (v19 * v25.f32[0])), COERCE__INT32(((v51.__cosval * v25.f32[0]) + ((v22 * v24.__cosval) + (v19 * v26.n128_f32[0]))) - (v20 * v27)), COERCE__INT32((((v51.__cosval * v24.__cosval) - (v19 * v27)) - (v22 * v25.f32[0])) - (v20 * v26.n128_f32[0])));
      v9 = 0.5;
      v6 = result;
      v8 = (v8 + 8 * *(v4 + 124) + 84);
      ++v5;
      v7 = 1.0;
    }

    while (v5 < *(v4 + 64));
  }

  return result;
}

uint64_t apply_test(uint64_t result, float a2, int a3)
{
  if (*(result + 64))
  {
    v5 = result;
    v6 = 0;
    v7 = *(result + 8 * (a3 != 0) + 96);
    v8 = *(result + 56);
    v31 = a2 + 1.0;
    do
    {
      v9 = v8[1];
      v32 = *v8;
      v10 = v8[13];
      v11 = v8[14];
      v12 = fminf(fmaxf(a2 - v10, 0.0), v11);
      v13 = fminf(fmaxf(v31 - v10, 0.0), v11) - v11;
      v14 = v10 - (v11 + -1.0);
      if (v14 <= a2)
      {
        v15 = 0.0;
      }

      else
      {
        v15 = a2 - v14;
      }

      if (v11 <= 1.0)
      {
        v15 = v13;
      }

      if (a2 < 0.0)
      {
        v16 = v15;
      }

      else
      {
        v16 = v12;
      }

      v17 = -(v8[11] * 6.28318531 * v16);
      if (a3 >= 0)
      {
        v17 = v8[11] * 6.28318531 * v16;
      }

      v18 = v17;
      v19 = __sincosf_stret(v18 * 0.5);
      *&v20 = v8[8] * v19.__sinval;
      *&v21 = v8[9] * v19.__sinval;
      *&v22 = v8[10] * v19.__sinval;
      v23 = sin((v16 + v16) * 3.14159265);
      *v24.i32 = 0.0 - v23;
      v25.n128_u32[0] = 1.0;
      v26.n128_f32[0] = v32;
      result = emit(v5, v7, v8, 0, *(v5 + 124), a3, *(v5 + 136), 0, v26, v9 * ((v23 * 0.35) + 1.0), v24, v25, v29, v30, v27, v28, v20, v21, v22, SLODWORD(v19.__cosval));
      v7 = result;
      v8 += 2 * *(v5 + 124) + 21;
      ++v6;
    }

    while (v6 < *(v5 + 64));
  }

  return result;
}

int8x16_t HGColorGammaLUTInfo::HGColorGammaLUTInfo(uint64_t a1, uint64_t a2, int a3, int a4, float a5, float a6, __n128 a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, __n128 a11, int8x16_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17)
{
  v18 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *v18 = &unk_287226628;
  v19 = a7;
  v19.n128_u32[3] = a8.i32[0];
  *(v18 + 36) = a3;
  *(v18 + 40) = v19;
  *(v18 + 56) = vextq_s8(vextq_s8(a8, a8, 0xCuLL), a9, 8uLL);
  *(v18 + 72) = vextq_s8(vuzp1q_s32(a9, a9), a10, 0xCuLL);
  v20 = a11;
  v20.n128_u32[3] = a12.i32[0];
  *(v18 + 88) = v20;
  result = vextq_s8(vextq_s8(a12, a12, 0xCuLL), a17, 8uLL);
  *(v18 + 104) = result;
  *(v18 + 120) = a17.i32[2];
  return result;
}

float *HGColorGammaLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (result)
  {
    v4 = result;
    result = HGApplyNDLUTInfo::isEqual(a1, result);
    if (result)
    {
      if (*(a1 + 36) == *(v4 + 9))
      {
        if (*(a1 + 40) == v4[10] && *(a1 + 44) == v4[11] && *(a1 + 48) == v4[12] && *(a1 + 52) == v4[13] && *(a1 + 56) == v4[14] && *(a1 + 60) == v4[15] && *(a1 + 64) == v4[16] && *(a1 + 68) == v4[17] && *(a1 + 72) == v4[18] && *(a1 + 76) == v4[19] && *(a1 + 80) == v4[20] && *(a1 + 84) == v4[21] && *(a1 + 88) == v4[22] && *(a1 + 92) == v4[23] && *(a1 + 96) == v4[24] && *(a1 + 100) == v4[25] && *(a1 + 104) == v4[26] && *(a1 + 108) == v4[27] && *(a1 + 112) == v4[28] && *(a1 + 116) == v4[29])
        {
          return (*(a1 + 120) == v4[30]);
        }

        else
        {
          return 0;
        }
      }

      else
      {
        return 0;
      }
    }
  }

  return result;
}

void HGColorGammaLUTInfo::colorAtIndex(HGColorGammaLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v14 = *(this + 9);
  if (v14 <= 1)
  {
    if (!v14)
    {
      if (a2 >= 0.0)
      {
        *a5 = powf(a2, *(this + 10));
        *a6 = powf(a2, *(this + 11));
        v26 = powf(a2, *(this + 12));
      }

      else
      {
        v32 = -a2;
        *a5 = -powf(-a2, *(this + 10));
        *a6 = -powf(v32, *(this + 11));
        v26 = -powf(v32, *(this + 12));
      }

      goto LABEL_41;
    }

    if (v14 != 1)
    {
      goto LABEL_42;
    }

    v17 = a2;
    v18 = *(this + 16);
    v19 = *(this + 13);
    v20 = 0.0;
    v21 = 0.0;
    if (-v18 / v19 <= a2)
    {
      v21 = powf(v18 + (v19 * a2), *(this + 10));
    }

    *a5 = v21;
    v22 = *(this + 17);
    v23 = *(this + 14);
    if (-v22 / v23 <= v17)
    {
      v20 = powf(v22 + (v23 * a2), *(this + 11));
    }

    *a6 = v20;
    v24 = *(this + 18);
    v25 = *(this + 15);
    v26 = 0.0;
    if (-v24 / v25 > v17)
    {
      goto LABEL_41;
    }

    v27 = v24 + (v25 * a2);
    goto LABEL_23;
  }

  switch(v14)
  {
    case 2:
      v28 = a2;
      v29 = *(this + 16);
      v30 = *(this + 13);
      if (-v29 / v30 <= a2)
      {
        v31 = powf(v29 + (v30 * a2), *(this + 10)) + *(this + 19);
      }

      else
      {
        v31 = *(this + 19);
      }

      *a5 = v31;
      v33 = *(this + 17);
      v34 = *(this + 14);
      if (-v33 / v34 <= v28)
      {
        v35 = powf(v33 + (v34 * a2), *(this + 11)) + *(this + 20);
      }

      else
      {
        v35 = *(this + 20);
      }

      *a6 = v35;
      v36 = *(this + 18);
      v37 = *(this + 15);
      if (-v36 / v37 <= v28)
      {
        v15 = powf(v36 + (v37 * a2), *(this + 12));
        v16 = *(this + 21);
        goto LABEL_40;
      }

      v26 = *(this + 21);
LABEL_41:
      *a7 = v26;
      break;
    case 3:
      if (*(this + 22) <= a2)
      {
        *a5 = powf((*(this + 13) * a2) + *(this + 16), *(this + 10));
        if (*(this + 23) <= a2)
        {
LABEL_21:
          *a6 = powf((*(this + 14) * a2) + *(this + 17), *(this + 11));
          if (*(this + 24) <= a2)
          {
LABEL_22:
            v27 = (*(this + 15) * a2) + *(this + 18);
LABEL_23:
            v26 = powf(v27, *(this + 12));
            goto LABEL_41;
          }

LABEL_35:
          v26 = *(this + 21) * a2;
          goto LABEL_41;
        }
      }

      else
      {
        *a5 = *(this + 19) * a2;
        if (*(this + 23) <= a2)
        {
          goto LABEL_21;
        }
      }

      *a6 = *(this + 20) * a2;
      if (*(this + 24) <= a2)
      {
        goto LABEL_22;
      }

      goto LABEL_35;
    case 4:
      if (*(this + 22) <= a2)
      {
        *a5 = powf((*(this + 13) * a2) + *(this + 16), *(this + 10)) + *(this + 25);
        if (*(this + 23) <= a2)
        {
LABEL_7:
          *a6 = powf((*(this + 14) * a2) + *(this + 17), *(this + 11)) + *(this + 26);
          if (*(this + 24) <= a2)
          {
LABEL_8:
            v15 = powf((*(this + 15) * a2) + *(this + 18), *(this + 12));
            v16 = *(this + 27);
LABEL_40:
            v26 = v15 + v16;
            goto LABEL_41;
          }

LABEL_39:
          v15 = *(this + 21) * a2;
          v16 = *(this + 30);
          goto LABEL_40;
        }
      }

      else
      {
        *a5 = (*(this + 19) * a2) + *(this + 28);
        if (*(this + 23) <= a2)
        {
          goto LABEL_7;
        }
      }

      *a6 = (*(this + 20) * a2) + *(this + 29);
      if (*(this + 24) <= a2)
      {
        goto LABEL_8;
      }

      goto LABEL_39;
  }

LABEL_42:
  *a8 = 1.0;
}

double HGArriLogCDefaultToneCurveLUTInfo::HGArriLogCDefaultToneCurveLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  v7 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *v7 = &unk_287226678;
  *(v7 + 120) = a3;
  *(v7 + 40) = xmmword_260817AC0;
  *(v7 + 88) = xmmword_260817AD0;
  *(v7 + 56) = xmmword_260817AE0;
  *(v7 + 104) = xmmword_260817AF0;
  result = -4.04163265;
  *(v7 + 72) = xmmword_260817B00;
  return result;
}

unsigned __int8 *HGArriLogCDefaultToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (result)
  {
    v4 = result;
    result = HGApplyNDLUTInfo::isEqual(a1, result);
    if (result)
    {
      return (*(a1 + 120) == v4[120]);
    }
  }

  return result;
}

void HGArriLogCDefaultToneCurveLUTInfo::colorAtIndex(HGArriLogCDefaultToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v8 = 0.0;
  if (a2 > 0.0)
  {
    v8 = 1.0;
    if (a2 < 1.0)
    {
      v9 = a2;
      if (a2 >= 0.256)
      {
        if (v9 >= 0.391)
        {
          if (v9 >= 0.57)
          {
            if (v9 >= 0.65)
            {
              v10 = 4;
              if (a2 >= 1.0)
              {
                v10 = 5;
              }
            }

            else
            {
              v10 = 3;
            }
          }

          else
          {
            v10 = 2;
          }
        }

        else
        {
          v10 = 1;
        }
      }

      else
      {
        v10 = 0;
      }

      v11 = v10;
      v12 = *&HGArriLogCDefaultToneCurveLUTInfo::a0[v11] + (v9 - *&HGArriLogCDefaultToneCurveLUTInfo::xi[v11]) * (*&HGArriLogCDefaultToneCurveLUTInfo::a1[v11] + (v9 - *&HGArriLogCDefaultToneCurveLUTInfo::xi[v11]) * (*(this + v11 * 8 + 80) * (v9 - *&HGArriLogCDefaultToneCurveLUTInfo::xi[v11]) + *(this + v11 * 8 + 40)));
      if (*(this + 120) != 1)
      {
        v18 = a5;
        v19 = a6;
        v20 = a7;
        v21 = a8;
        if (v12 >= 0.0)
        {
          v17 = pow(v12, 2.4);
        }

        else
        {
          v17 = -pow(-v12, 2.4);
        }

        a8 = v21;
        a7 = v20;
        a6 = v19;
        a5 = v18;
        goto LABEL_23;
      }

      if (atomic_load_explicit(&qword_280C5E4E8, memory_order_acquire))
      {
        if (v12 > 0.0562318841)
        {
LABEL_16:
          v13 = a8;
          v14 = a7;
          v15 = a6;
          v16 = a5;
          v17 = pow((v12 + 0.097) / 1.097, 2.725);
          a5 = v16;
          a6 = v15;
          a7 = v14;
          a8 = v13;
LABEL_23:
          v8 = v17;
          goto LABEL_24;
        }
      }

      else
      {
        v22 = a8;
        v23 = a7;
        v24 = a6;
        v25 = a5;
        v26 = v12;
        HGArriLogCDefaultToneCurveLUTInfo::colorAtIndex();
        v12 = v26;
        a5 = v25;
        a6 = v24;
        a7 = v23;
        a8 = v22;
        if (v26 > 0.0562318841)
        {
          goto LABEL_16;
        }
      }

      v17 = v12 / 0.0562318841 * *&_MergedGlobals_26;
      goto LABEL_23;
    }
  }

LABEL_24:
  *a5 = v8;
  *a6 = v8;
  *a7 = v8;
  *a8 = 1.0;
}

uint64_t HGArriLogCLinearizationLUTInfo::HGArriLogCLinearizationLUTInfo(uint64_t a1, uint64_t a2, unsigned int a3, int a4, float a5, float a6)
{
  v8 = 1;
  v9 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *v9 = &unk_2872266C8;
  *(v9 + 36) = 0;
  if (a3 >= 0xB4)
  {
    *(a1 + 36) = 1;
    if (a3 >= 0xE1)
    {
      v8 = 2;
      *(a1 + 36) = 2;
      if (a3 >= 0x11D)
      {
        v8 = 3;
        *(a1 + 36) = 3;
        if (a3 >= 0x168)
        {
          v8 = 4;
          *(a1 + 36) = 4;
          if (a3 >= 0x1C2)
          {
            v8 = 5;
            *(a1 + 36) = 5;
            if (a3 >= 0x23A)
            {
              v8 = 6;
              *(a1 + 36) = 6;
              if (a3 >= 0x2D0)
              {
                v8 = 7;
                *(a1 + 36) = 7;
                if (a3 >= 0x384)
                {
                  v8 = 8;
                  *(a1 + 36) = 8;
                  if (a3 >= 0x474)
                  {
                    if (a3 < 0x5A0)
                    {
                      v10 = 9;
                    }

                    else
                    {
                      v10 = 10;
                    }

                    *(a1 + 36) = v10;
                    if (a3 < 0x5A0)
                    {
                      v8 = 9;
                    }

                    else
                    {
                      v8 = 10;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  else
  {
    v8 = 0;
  }

  v11 = (&HGArriLogCLinearizationLUTInfo::linearizationParameters + 56 * v8);
  v12 = v11[1];
  v13 = v11[3];
  v14 = v11[4];
  v15 = v11[5];
  v16 = v11[6];
  *(a1 + 40) = (v14 + v13 * log10(v12 * 5.55555556 + v11[2]) + v12 * v15 + v16) * 0.5;
  *(a1 + 48) = 2.30258509 / v13;
  return a1;
}

_DWORD *HGArriLogCLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (result)
  {
    v4 = result;
    result = HGApplyNDLUTInfo::isEqual(a1, result);
    if (result)
    {
      return (*(a1 + 36) == v4[9]);
    }
  }

  return result;
}

float HGArriLogCLinearizationLUTInfo::colorAtIndex(HGArriLogCLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v12 = a2;
  if (a2 > 1.0)
  {
    v12 = 1.0;
  }

  if (a2 >= 0.0)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0.0;
  }

  v14 = (&HGArriLogCLinearizationLUTInfo::linearizationParameters + 56 * *(this + 9));
  if (v13 <= *(this + 5))
  {
    v16 = (v13 - v14[6]) / v14[5];
  }

  else
  {
    v15 = v14[2];
    v16 = (exp((v13 - v14[4]) * *(this + 6)) - v15) / 5.55555556;
  }

  result = v16 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGArriLogC4LinearizationLUTInfo::HGArriLogC4LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226718;
  return result;
}

void *HGArriLogC4LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGArriLogC4LinearizationLUTInfo::colorAtIndex(HGArriLogC4LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E4F8, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E508, memory_order_acquire))
    {
      goto LABEL_3;
    }

LABEL_8:
    v16 = a2;
    HGArriLogC4LinearizationLUTInfo::colorAtIndex();
    a2 = v16;
    v12 = 0.0;
    if (v16 >= 0.0)
    {
      goto LABEL_4;
    }

LABEL_9:
    v13 = (exp2((v12 + -0.0928641251) * 14.0 / 0.907135875 + 6.0) + -64.0) / 2231.82631;
    goto LABEL_10;
  }

  v15 = a2;
  HGArriLogC4LinearizationLUTInfo::colorAtIndex();
  a2 = v15;
  if ((atomic_load_explicit(&qword_280C5E508, memory_order_acquire) & 1) == 0)
  {
    goto LABEL_8;
  }

LABEL_3:
  v12 = 0.0;
  if (a2 < 0.0)
  {
    goto LABEL_9;
  }

LABEL_4:
  v12 = 1.0;
  if (a2 > 1.0)
  {
    goto LABEL_9;
  }

  v12 = a2;
  if (a2 >= 0.0)
  {
    goto LABEL_9;
  }

  v13 = *&qword_280C5E4F0 * v12 + *&qword_280C5E500;
LABEL_10:
  result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

double HGCanonLogToneCurveLUTInfo::kMinLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  if ((atomic_load_explicit(&qword_280C5E518, memory_order_acquire) & 1) == 0)
  {
    HGCanonLogToneCurveLUTInfo::kMinLogGamma();
  }

  return *&qword_280C5E510;
}

double HGCanonLogToneCurveLUTInfo::kMaxLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  if (atomic_load_explicit(&qword_280C5E528, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E538, memory_order_acquire))
    {
      return *&qword_280C5E530;
    }
  }

  else
  {
    HGCanonLogToneCurveLUTInfo::kMaxLogGamma();
    if (atomic_load_explicit(&qword_280C5E538, memory_order_acquire))
    {
      return *&qword_280C5E530;
    }
  }

  HGCanonLogToneCurveLUTInfo::kMaxLogGamma();
  return *&qword_280C5E530;
}

void *HGCanonLogToneCurveLUTInfo::HGCanonLogToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226768;
  return result;
}

void *HGCanonLogToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLogToneCurveLUTInfo::colorAtIndex(HGCanonLogToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit(&qword_280C5E548, memory_order_acquire) & 1) == 0)
  {
    v24 = a2;
    HGCanonLogToneCurveLUTInfo::colorAtIndex();
    a2 = v24;
  }

  v12 = a2;
  v13 = v12 < 0.0730597;
  v14 = v12 < 0.0730597;
  v15 = 0.0730597 - v12;
  v16 = v12 + -0.0730597;
  if (v13)
  {
    v16 = v15;
  }

  v17 = dbl_260817B10[v14];
  v18 = (exp(v16 * *&qword_280C5E540) + -1.0) / v17;
  if (v18 >= 0.018)
  {
    v20 = pow(v18, 0.45) * 1.099 + -0.099;
    v21 = 1.09474886;
    if (v20 > 1.09474886)
    {
LABEL_12:
      v22 = pow(v21, 1.956);
      goto LABEL_13;
    }
  }

  else
  {
    v19 = -0.0730593607;
    if (v18 <= -0.018)
    {
      goto LABEL_11;
    }

    v20 = v18 * 4.5;
    if (v18 * 4.5 < -0.0730593607)
    {
      goto LABEL_11;
    }
  }

  v21 = v20;
  v19 = v20;
  if (v20 >= 0.0)
  {
    goto LABEL_12;
  }

LABEL_11:
  v22 = -pow(-v19, 1.956);
LABEL_13:
  result = v22;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLogLinearizationLUTInfo::HGCanonLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_2872267B8;
  return result;
}

void *HGCanonLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLogLinearizationLUTInfo::colorAtIndex(HGCanonLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v12 = a2;
  v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    v13 = v12;
    if (v12 > 1.09474886)
    {
      v13 = 1.09474886;
    }
  }

  if ((atomic_load_explicit(&qword_280C5E558, memory_order_acquire) & 1) == 0)
  {
    v20 = v13;
    HGCanonLogLinearizationLUTInfo::colorAtIndex();
    v13 = v20;
  }

  v14 = v13 < 0.0730597;
  v15 = v13 < 0.0730597;
  v16 = 0.0730597 - v13;
  v17 = v13 + -0.0730597;
  if (v14)
  {
    v17 = v16;
  }

  v18 = dbl_260817B10[v15];
  result = (exp(v17 * *&qword_280C5E550) + -1.0) / v18;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLog2LinearizationLUTInfo::HGCanonLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226808;
  return result;
}

void *HGCanonLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLog2LinearizationLUTInfo::colorAtIndex(HGCanonLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v12 = a2;
  v13 = -0.0730593607;
  if (v12 < -0.0730593607 || (v16 = 1.09474886, v12 <= 1.09474886) && (v16 = v12, v13 = v12, v12 < 0.035388128))
  {
    v14 = 0.035388128 - v13;
    v15 = -87.0993755;
  }

  else
  {
    v14 = v16 + -0.035388128;
    v15 = 87.0993755;
  }

  result = (exp(v14 / 0.122411586) + -1.0) / v15;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLog3LinearizationLUTInfo::HGCanonLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226858;
  return result;
}

void *HGCanonLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLog3LinearizationLUTInfo::colorAtIndex(HGCanonLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E568, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E578, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v17 = a2;
    HGCanonLog3LinearizationLUTInfo::colorAtIndex();
    a2 = v17;
    if (atomic_load_explicit(&qword_280C5E578, memory_order_acquire))
    {
LABEL_3:
      if (atomic_load_explicit(&qword_280C5E588, memory_order_acquire))
      {
        goto LABEL_4;
      }

LABEL_15:
      v19 = a2;
      HGCanonLog3LinearizationLUTInfo::colorAtIndex();
      v12 = v19;
      v13 = -0.0730593607;
      if (v19 < -0.0730593607)
      {
        goto LABEL_7;
      }

      goto LABEL_5;
    }
  }

  v18 = a2;
  HGCanonLog3LinearizationLUTInfo::colorAtIndex();
  a2 = v18;
  if ((atomic_load_explicit(&qword_280C5E588, memory_order_acquire) & 1) == 0)
  {
    goto LABEL_15;
  }

LABEL_4:
  v12 = a2;
  v13 = -0.0730593607;
  if (v12 < -0.0730593607)
  {
    goto LABEL_7;
  }

LABEL_5:
  v13 = v12;
  if (v12 > 1.09474886)
  {
    v13 = 1.09474886;
  }

LABEL_7:
  if (v13 >= *&qword_280C5E560)
  {
    if (v13 <= *&qword_280C5E570)
    {
      v14 = v13 + -0.073059361;
      v15 = 2.3069815;
    }

    else
    {
      v14 = exp((v13 + -0.069886632) * *&qword_280C5E580) + -1.0;
      v15 = 14.98325;
    }
  }

  else
  {
    v14 = exp((0.07623209 - v13) * *&qword_280C5E580) + -1.0;
    v15 = -14.98325;
  }

  result = v14 / v15;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGSonySLog2LinearizationLUTInfo::HGSonySLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_2872268A8;
  return result;
}

void *HGSonySLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGSonySLog2LinearizationLUTInfo::colorAtIndex(HGSonySLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v12 = a2;
  v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    v13 = v12;
    if (v12 > 1.09474886)
    {
      v13 = 1.09474886;
    }
  }

  if (atomic_load_explicit(&qword_280C5E598, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E5A8, memory_order_acquire))
    {
      goto LABEL_6;
    }

LABEL_9:
    v19 = v13;
    HGSonySLog2LinearizationLUTInfo::colorAtIndex();
    v13 = v19;
    v14 = *&qword_280C5E590;
    if (v19 < *&qword_280C5E590)
    {
      goto LABEL_7;
    }

LABEL_10:
    v15 = exp((v13 + -0.646596) * *&qword_280C5E5A0) + -0.037584;
    v16 = 1.41290323;
    goto LABEL_11;
  }

  v18 = v13;
  HGSonySLog2LinearizationLUTInfo::colorAtIndex();
  v13 = v18;
  if ((atomic_load_explicit(&qword_280C5E5A8, memory_order_acquire) & 1) == 0)
  {
    goto LABEL_9;
  }

LABEL_6:
  v14 = *&qword_280C5E590;
  if (v13 >= *&qword_280C5E590)
  {
    goto LABEL_10;
  }

LABEL_7:
  v15 = v13 - v14;
  v16 = 0.282580645;
LABEL_11:
  result = v15 * v16;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGSonySLog3LinearizationLUTInfo::HGSonySLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_2872268F8;
  return result;
}

void *HGSonySLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGSonySLog3LinearizationLUTInfo::colorAtIndex(HGSonySLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E5B8, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E5C8, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v16 = a2;
    HGSonySLog3LinearizationLUTInfo::colorAtIndex();
    a2 = v16;
    if (atomic_load_explicit(&qword_280C5E5C8, memory_order_acquire))
    {
LABEL_3:
      if (atomic_load_explicit(&qword_280C5E5D8, memory_order_acquire))
      {
        goto LABEL_4;
      }

      goto LABEL_14;
    }
  }

  v17 = a2;
  HGSonySLog3LinearizationLUTInfo::colorAtIndex();
  a2 = v17;
  if (atomic_load_explicit(&qword_280C5E5D8, memory_order_acquire))
  {
LABEL_4:
    v12 = 0.0;
    if (a2 >= 0.0)
    {
      goto LABEL_5;
    }

    goto LABEL_8;
  }

LABEL_14:
  v18 = a2;
  HGSonySLog3LinearizationLUTInfo::colorAtIndex();
  a2 = v18;
  v12 = 0.0;
  if (v18 >= 0.0)
  {
LABEL_5:
    if (a2 <= 1.0)
    {
      v12 = a2;
    }

    else
    {
      v12 = 1.0;
    }
  }

LABEL_8:
  v13 = v12 * 1023.0;
  if (v12 * 1023.0 >= *&qword_280C5E5B0)
  {
    v14 = exp((v13 + -420.0) * *&qword_280C5E5D0) * 0.19 + -0.01;
  }

  else
  {
    v14 = (v13 + -95.0) / *&qword_280C5E5C0 * 0.01125;
  }

  result = v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGPanasonicVLogLinearizationLUTInfo::HGPanasonicVLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226948;
  return result;
}

void *HGPanasonicVLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGPanasonicVLogLinearizationLUTInfo::colorAtIndex(HGPanasonicVLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E5E8, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E5F8, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v15 = a2;
    HGPanasonicVLogLinearizationLUTInfo::colorAtIndex();
    a2 = v15;
    if (atomic_load_explicit(&qword_280C5E5F8, memory_order_acquire))
    {
LABEL_3:
      v12 = 0.0;
      if (a2 < 0.0)
      {
        goto LABEL_4;
      }

LABEL_8:
      if (a2 <= 1.0)
      {
        v12 = a2;
        if (a2 < *&qword_280C5E5E0)
        {
          goto LABEL_5;
        }
      }

      else
      {
        v12 = 1.0;
        if (*&qword_280C5E5E0 > 1.0)
        {
          goto LABEL_5;
        }
      }

LABEL_10:
      v13 = exp((v12 + -0.598206) * *&qword_280C5E5F0) + -0.00873;
      goto LABEL_11;
    }
  }

  v16 = a2;
  HGPanasonicVLogLinearizationLUTInfo::colorAtIndex();
  a2 = v16;
  v12 = 0.0;
  if (v16 >= 0.0)
  {
    goto LABEL_8;
  }

LABEL_4:
  if (*&qword_280C5E5E0 <= 0.0)
  {
    goto LABEL_10;
  }

LABEL_5:
  v13 = (v12 + -0.125) / 5.6;
LABEL_11:
  result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGNikonNLogLinearizationLUTInfo::HGNikonNLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226998;
  return result;
}

void *HGNikonNLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGNikonNLogLinearizationLUTInfo::colorAtIndex(HGNikonNLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E608, memory_order_acquire))
  {
    v12 = 0.0;
    if (a2 < 0.0)
    {
      goto LABEL_3;
    }

LABEL_6:
    if (a2 <= 1.0)
    {
      v12 = a2;
      if (a2 < *&qword_280C5E600)
      {
        goto LABEL_4;
      }
    }

    else
    {
      v12 = 1.0;
      if (*&qword_280C5E600 > 1.0)
      {
        goto LABEL_4;
      }
    }

LABEL_8:
    v13 = exp((v12 + -0.605083089) / 0.146627566);
    goto LABEL_9;
  }

  v15 = a2;
  HGNikonNLogLinearizationLUTInfo::colorAtIndex();
  a2 = v15;
  v12 = 0.0;
  if (v15 >= 0.0)
  {
    goto LABEL_6;
  }

LABEL_3:
  if (*&qword_280C5E600 <= 0.0)
  {
    goto LABEL_8;
  }

LABEL_4:
  v13 = v12 / 0.635386119 * (v12 / 0.635386119 * (v12 / 0.635386119)) + -0.0075;
LABEL_9:
  result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

uint64_t HGBMDFilmLinearizationLUTInfo::HGBMDFilmLinearizationLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *result = &unk_2872269E8;
  *(result + 36) = a3;
  return result;
}

unsigned __int8 *HGBMDFilmLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (result)
  {
    v4 = result;
    result = HGApplyNDLUTInfo::isEqual(a1, result);
    if (result)
    {
      return (*(a1 + 36) == v4[36]);
    }
  }

  return result;
}

float HGBMDFilmLinearizationLUTInfo::colorAtIndex(HGBMDFilmLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v12 = 0.0;
  if (a2 < 0.0)
  {
LABEL_4:
    if (*(this + 36))
    {
      goto LABEL_5;
    }

LABEL_10:
    if (atomic_load_explicit(&qword_280C5E618, memory_order_acquire))
    {
      if (atomic_load_explicit(&qword_280C5E628, memory_order_acquire))
      {
        goto LABEL_12;
      }
    }

    else
    {
      v21 = v12;
      HGBMDFilmLinearizationLUTInfo::colorAtIndex();
      v12 = v21;
      if (atomic_load_explicit(&qword_280C5E628, memory_order_acquire))
      {
LABEL_12:
        if (v12 < *&qword_280C5E610)
        {
LABEL_13:
          v13 = v12 + -0.0928641251;
          v14 = 0.7659482;
          goto LABEL_14;
        }

LABEL_20:
        v16 = exp((v12 + -0.3644932) * *&qword_280C5E620);
        v17 = -0.1806583;
        goto LABEL_21;
      }
    }

    v22 = v12;
    HGBMDFilmLinearizationLUTInfo::colorAtIndex();
    v12 = v22;
    if (v22 < *&qword_280C5E610)
    {
      goto LABEL_13;
    }

    goto LABEL_20;
  }

  if (a2 > 1.0)
  {
    v12 = 1.0;
    goto LABEL_4;
  }

  v12 = a2;
  if ((*(this + 36) & 1) == 0)
  {
    goto LABEL_10;
  }

LABEL_5:
  if (atomic_load_explicit(&qword_280C5E638, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E648, memory_order_acquire))
    {
      goto LABEL_7;
    }

LABEL_16:
    v20 = v12;
    HGBMDFilmLinearizationLUTInfo::colorAtIndex();
    v12 = v20;
    if (v20 < *&qword_280C5E630)
    {
      goto LABEL_8;
    }

    goto LABEL_17;
  }

  v19 = v12;
  HGBMDFilmLinearizationLUTInfo::colorAtIndex();
  v12 = v19;
  if ((atomic_load_explicit(&qword_280C5E648, memory_order_acquire) & 1) == 0)
  {
    goto LABEL_16;
  }

LABEL_7:
  if (v12 >= *&qword_280C5E630)
  {
LABEL_17:
    v16 = exp((v12 + -0.2982706) * *&qword_280C5E640);
    v17 = -0.4430254;
LABEL_21:
    v15 = v16 + v17;
    goto LABEL_22;
  }

LABEL_8:
  v13 = v12 + -0.0928641251;
  v14 = 0.5370933;
LABEL_14:
  v15 = v13 / v14;
LABEL_22:
  result = v15 * 0.200222469;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGAppleLogLinearizationLUTInfo::HGAppleLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226A38;
  return result;
}

void *HGAppleLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGAppleLogLinearizationLUTInfo::colorAtIndex(HGAppleLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E658, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E668, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v18 = a2;
    HGAppleLogLinearizationLUTInfo::colorAtIndex();
    a2 = v18;
    if (atomic_load_explicit(&qword_280C5E668, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  v19 = a2;
  HGAppleLogLinearizationLUTInfo::colorAtIndex();
  a2 = v19;
LABEL_3:
  v12 = a2;
  if (a2 > 1.0)
  {
    v12 = 1.0;
  }

  if (a2 >= 0.0)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0.0;
  }

  if (v13 >= *&qword_280C5E650)
  {
    v15 = exp((v13 + -0.69336945) * *&qword_280C5E660);
    v16 = -0.00964052;
LABEL_13:
    v14 = v15 + v16;
    goto LABEL_14;
  }

  if (v13 >= 0.0)
  {
    v15 = sqrt(v13 / 47.2871124);
    v16 = -0.05641088;
    goto LABEL_13;
  }

  v14 = -0.05641088;
LABEL_14:
  result = v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGDJIDLogLinearizationLUTInfo::HGDJIDLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226A88;
  return result;
}

void *HGDJIDLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGDJIDLogLinearizationLUTInfo::colorAtIndex(HGDJIDLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E678, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E688, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v16 = a2;
    HGDJIDLogLinearizationLUTInfo::colorAtIndex();
    a2 = v16;
    if (atomic_load_explicit(&qword_280C5E688, memory_order_acquire))
    {
LABEL_3:
      v12 = 0.0;
      if (a2 < 0.0)
      {
        goto LABEL_4;
      }

LABEL_8:
      if (a2 <= 1.0)
      {
        v12 = a2;
        if (a2 > *&qword_280C5E670)
        {
          goto LABEL_5;
        }
      }

      else
      {
        v12 = 1.0;
        if (*&qword_280C5E670 < 1.0)
        {
          goto LABEL_5;
        }
      }

LABEL_10:
      v13 = v12 + -0.0929;
      v14 = 6.025;
      goto LABEL_11;
    }
  }

  v17 = a2;
  HGDJIDLogLinearizationLUTInfo::colorAtIndex();
  a2 = v17;
  v12 = 0.0;
  if (v17 >= 0.0)
  {
    goto LABEL_8;
  }

LABEL_4:
  if (*&qword_280C5E670 >= 0.0)
  {
    goto LABEL_10;
  }

LABEL_5:
  v13 = exp((v12 + -0.584555) * *&qword_280C5E680) + -0.0108;
  v14 = 0.9892;
LABEL_11:
  result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGFujifilmFLogLinearizationLUTInfo::HGFujifilmFLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226AD8;
  return result;
}

void *HGFujifilmFLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGFujifilmFLogLinearizationLUTInfo::colorAtIndex(HGFujifilmFLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E698, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E6A8, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v16 = a2;
    HGFujifilmFLogLinearizationLUTInfo::colorAtIndex();
    a2 = v16;
    if (atomic_load_explicit(&qword_280C5E6A8, memory_order_acquire))
    {
LABEL_3:
      v12 = 0.0;
      if (a2 < 0.0)
      {
        goto LABEL_4;
      }

LABEL_8:
      if (a2 <= 1.0)
      {
        v12 = a2;
        if (a2 < *&qword_280C5E690)
        {
          goto LABEL_5;
        }
      }

      else
      {
        v12 = 1.0;
        if (*&qword_280C5E690 > 1.0)
        {
          goto LABEL_5;
        }
      }

LABEL_10:
      v13 = exp((v12 + -0.790453) * *&qword_280C5E6A0) + -0.009468;
      v14 = 0.555555556;
      goto LABEL_11;
    }
  }

  v17 = a2;
  HGFujifilmFLogLinearizationLUTInfo::colorAtIndex();
  a2 = v17;
  v12 = 0.0;
  if (v17 >= 0.0)
  {
    goto LABEL_8;
  }

LABEL_4:
  if (*&qword_280C5E690 <= 0.0)
  {
    goto LABEL_10;
  }

LABEL_5:
  v13 = v12 + -0.092864;
  v14 = 8.735631;
LABEL_11:
  result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGFujifilmFLog2LinearizationLUTInfo::HGFujifilmFLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226B28;
  return result;
}

void *HGFujifilmFLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex(HGFujifilmFLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (atomic_load_explicit(&qword_280C5E6B8, memory_order_acquire))
  {
    if (atomic_load_explicit(&qword_280C5E6C8, memory_order_acquire))
    {
      goto LABEL_3;
    }
  }

  else
  {
    v16 = a2;
    HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex();
    a2 = v16;
    if (atomic_load_explicit(&qword_280C5E6C8, memory_order_acquire))
    {
LABEL_3:
      v12 = 0.0;
      if (a2 < 0.0)
      {
        goto LABEL_4;
      }

LABEL_8:
      if (a2 <= 1.0)
      {
        v12 = a2;
        if (a2 < *&qword_280C5E6B0)
        {
          goto LABEL_5;
        }
      }

      else
      {
        v12 = 1.0;
        if (*&qword_280C5E6B0 > 1.0)
        {
          goto LABEL_5;
        }
      }

LABEL_10:
      v13 = exp((v12 + -0.384316) * *&qword_280C5E6C0) + -0.064829;
      v14 = 5.55555556;
      goto LABEL_11;
    }
  }

  v17 = a2;
  HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex();
  a2 = v17;
  v12 = 0.0;
  if (v17 >= 0.0)
  {
    goto LABEL_8;
  }

LABEL_4:
  if (*&qword_280C5E6B0 <= 0.0)
  {
    goto LABEL_10;
  }

LABEL_5:
  v13 = v12 + -0.092864;
  v14 = 8.799461;
LABEL_11:
  result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGAYCCToneCurveToLinearLUTInfo::HGAYCCToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226B78;
  return result;
}

void *HGAYCCToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGAYCCToneCurveToLinearLUTInfo::colorAtIndex(HGAYCCToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v12 = powf(a2, 1.956);
    }

    else
    {
      v12 = (((a2 + -1.0) * 0.225) / 0.08) + 1.0;
    }
  }

  else
  {
    v12 = powf(a2 / -0.08, 2.2) * -0.225;
  }

  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

void *HGLinearToAYCCToneCurveLUTInfo::HGLinearToAYCCToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226BC8;
  return result;
}

void *HGLinearToAYCCToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGLinearToAYCCToneCurveLUTInfo::colorAtIndex(HGLinearToAYCCToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      v12 = powf(a2, 0.51125);
    }

    else
    {
      v12 = (((a2 + -1.0) * 0.08) / 0.225) + 1.0;
    }
  }

  else
  {
    v12 = powf(a2 / -0.225, 0.45455) * -0.08;
  }

  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

void *HG_ERsRGBToneCurveToLinearLUTInfo::HG_ERsRGBToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226C18;
  return result;
}

void *HG_ERsRGBToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HG_ERsRGBToneCurveToLinearLUTInfo::colorAtIndex(HG_ERsRGBToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v13 = fabsf(a2);
  if (v13 >= 0.04045)
  {
    v14 = powf((v13 * 0.94787) + 0.05213, 2.4);
  }

  else
  {
    v14 = v13 * 0.07734;
  }

  if (a2 < 0.0)
  {
    v14 = -v14;
  }

  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

void *HGLinearToERsRGBToneCurveLUTInfo::HGLinearToERsRGBToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *result = &unk_287226C68;
  return result;
}

void *HGLinearToERsRGBToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc)
  {
    return 0;
  }

  if (!v3)
  {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGLinearToERsRGBToneCurveLUTInfo::colorAtIndex(HGLinearToERsRGBToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  v13 = fabsf(a2);
  if (v13 >= 0.0031308)
  {
    v14 = powf(v13 * 1.1371, 0.41667) + -0.055;
  }

  else
  {
    v14 = v13 * 12.92;
  }

  if (a2 < 0.0)
  {
    v14 = -v14;
  }

  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

void HGArriLogCDefaultToneCurveLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E4E8))
  {
    _MergedGlobals_26 = 0x3F732E5BF55474D3;

    __cxa_guard_release(&qword_280C5E4E8);
  }
}

void HGArriLogC4LinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E4F8))
  {
    qword_280C5E4F0 = 0x3FBD14B4E7E63D19;

    __cxa_guard_release(&qword_280C5E4F8);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E508))
  {
    qword_280C5E500 = 0xBF927D887F3231C4;

    __cxa_guard_release(&qword_280C5E508);
  }
}

void HGCanonLogToneCurveLUTInfo::kMinLogGamma()
{
  if (__cxa_guard_acquire(&qword_280C5E518))
  {
    qword_280C5E510 = 0x3FA371775C883CCDLL;

    __cxa_guard_release(&qword_280C5E518);
  }
}

void HGCanonLogToneCurveLUTInfo::kMaxLogGamma()
{
  if (__cxa_guard_acquire(&qword_280C5E528))
  {
    qword_280C5E520 = 0x3FF33A573B3EED8ALL;

    __cxa_guard_release(&qword_280C5E528);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E538))
  {
    *&qword_280C5E530 = log10(*&qword_280C5E520 * 10.1596 + 1.0) * 0.529136 + 0.0730597;

    __cxa_guard_release(&qword_280C5E538);
  }
}

void HGCanonLogToneCurveLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E548))
  {
    v0 = OUTLINED_FUNCTION_0_12(&qword_280C5E540);

    __cxa_guard_release(v0);
  }
}

void HGCanonLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E558))
  {
    v0 = OUTLINED_FUNCTION_0_12(&qword_280C5E550);

    __cxa_guard_release(v0);
  }
}

void HGCanonLog3LinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E568))
  {
    qword_280C5E560 = 0x3FA4DEB50262DEBFLL;

    __cxa_guard_release(&qword_280C5E568);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E578))
  {
    qword_280C5E570 = 0x3FBAF8AEDB215573;

    __cxa_guard_release(&qword_280C5E578);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E588))
  {
    qword_280C5E580 = 0x401579709D43F5C0;

    __cxa_guard_release(&qword_280C5E588);
  }
}

void HGSonySLog2LinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E598))
  {
    qword_280C5E590 = 0x3F9EB8A3FBF49AE0;

    __cxa_guard_release(&qword_280C5E598);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E5A8))
  {
    qword_280C5E5A0 = 0x4015492995272697;

    __cxa_guard_release(&qword_280C5E5A8);
  }
}

void HGSonySLog3LinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E5B8))
  {
    qword_280C5E5B0 = 0x406566BABBEF8B7ALL;

    __cxa_guard_release(&qword_280C5E5B8);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E5C8))
  {
    *&qword_280C5E5C0 = *&qword_280C5E5B0 + -95.0;

    __cxa_guard_release(&qword_280C5E5C8);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E5D8))
  {
    qword_280C5E5D0 = 0x3F820882EBA5480ALL;

    __cxa_guard_release(&qword_280C5E5D8);
  }
}

void HGPanasonicVLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E5E8))
  {
    qword_280C5E5E0 = 0x3FC72B00BE1A1A7DLL;

    __cxa_guard_release(&qword_280C5E5E8);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E5F8))
  {
    qword_280C5E5F0 = 0x402311635B128422;

    __cxa_guard_release(&qword_280C5E5F8);
  }
}

void HGNikonNLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E608))
  {
    qword_280C5E600 = 0x3FDC42A6121F81AALL;

    __cxa_guard_release(&qword_280C5E608);
  }
}

void HGBMDFilmLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E618))
  {
    qword_280C5E610 = 0x3FBD384ED1A78752;

    __cxa_guard_release(&qword_280C5E618);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E628))
  {
    qword_280C5E620 = 0x40190DFAF2EFA06ALL;

    __cxa_guard_release(&qword_280C5E628);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E638))
  {
    qword_280C5E630 = 0x3FBB97B1767A8EEALL;

    __cxa_guard_release(&qword_280C5E638);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E648))
  {
    qword_280C5E640 = 0x400FA32D714B55AELL;

    __cxa_guard_release(&qword_280C5E648);
  }
}

void HGAppleLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E658))
  {
    qword_280C5E650 = 0x3FCAB1F0CDAACC3ELL;

    __cxa_guard_release(&qword_280C5E658);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E668))
  {
    qword_280C5E660 = 0x4020368B277C7D96;

    __cxa_guard_release(&qword_280C5E668);
  }
}

void HGDJIDLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E678))
  {
    qword_280C5E670 = 0x3FC1E81CC48A70B5;

    __cxa_guard_release(&qword_280C5E678);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E688))
  {
    qword_280C5E680 = 0x4021F1463A0B6A33;

    __cxa_guard_release(&qword_280C5E688);
  }
}

void HGFujifilmFLogLinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E698))
  {
    qword_280C5E690 = 0x3FB9C026A3080D26;

    __cxa_guard_release(&qword_280C5E698);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E6A8))
  {
    qword_280C5E6A0 = 0x401AB8C38E6C7294;

    __cxa_guard_release(&qword_280C5E6A8);
  }
}

void HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex()
{
  if (__cxa_guard_acquire(&qword_280C5E6B8))
  {
    qword_280C5E6B0 = 0x3FB9C69A8FA91FF2;

    __cxa_guard_release(&qword_280C5E6B8);
  }
}

{
  if (__cxa_guard_acquire(&qword_280C5E6C8))
  {
    qword_280C5E6C0 = 0x4022C66B961C7A0CLL;

    __cxa_guard_release(&qword_280C5E6C8);
  }
}

void HGColorClamp::HGColorClamp(HGColorClamp *this)
{
  HGNode::HGNode(this);
  *v1 = &unk_287226CB8;
  v2 = HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v2);
}

void sub_25FD493D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::HGColorClamp(HGColorClamp *this, float a2, float a3)
{
  HGNode::HGNode(this);
  *v3 = &unk_287226CB8;
  v4 = HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v4);
}

void sub_25FD49480(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::~HGColorClamp(HGColorClamp *this)
{
  *this = &unk_287226CB8;
  (*(**(this + 51) + 24))(*(this + 51));

  HGNode::~HGNode(this);
}

{
  *this = &unk_287226CB8;
  (*(**(this + 51) + 24))(*(this + 51));
  HGNode::~HGNode(this);

  HGObject::operator delete(v2);
}

uint64_t HGColorClamp::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (!a2)
  {
    v7 = 428;
    v8 = 424;
    v9 = 420;
    v10 = 416;
    goto LABEL_5;
  }

  if (a2 == 1)
  {
    v7 = 444;
    v8 = 440;
    v9 = 436;
    v10 = 432;
LABEL_5:
    *(this + v10) = a3;
    *(this + v9) = a4;
    *(this + v8) = a5;
    *(this + v7) = a6;
    HGNode::ClearBits(this, a2, a7);
    return 1;
  }

  return 0xFFFFFFFFLL;
}

float *HGColorClamp::SetClampMaxValues(float *this, float a2, float a3, float a4, float a5)
{
  this[104] = a2;
  this[105] = a3;
  this[106] = a4;
  this[107] = a5;
  return this;
}

float *HGColorClamp::SetClampMinValues(float *this, float a2, float a3, float a4, float a5)
{
  this[108] = a2;
  this[109] = a3;
  this[110] = a4;
  this[111] = a5;
  return this;
}

uint64_t HGColorClamp::GetOutput(HGColorClamp *this, HGRenderer *a2)
{
  v3 = *(this + 51);
  v4 = (*(*this + 128))(this, 0);
  (*(*v3 + 120))(v3, 0, v4);
  (*(**(this + 51) + 96))(*(this + 51), 0, *(this + 104), *(this + 105), *(this + 106), *(this + 107));
  (*(**(this + 51) + 96))(*(this + 51), 1, *(this + 108), *(this + 109), *(this + 110), *(this + 111));
  return *(this + 51);
}

void HFDenseCRFInterface::~HFDenseCRFInterface(HFDenseCRFInterface *this)
{
  *this = &unk_287226F20;
  v1 = *(this + 1);
  if (v1)
  {
    (*(*v1 + 8))(*(this + 1));
  }
}

{
  *this = &unk_287226F20;
  v2 = *(this + 1);
  if (v2)
  {
    (*(*v2 + 8))(*(this + 1));
    v1 = vars8;
  }

  JUMPOUT(0x2666E9F00);
}

uint64_t HgcSampler::Destroy(uint64_t result)
{
  if (result)
  {
    JUMPOUT(0x2666E9F00);
  }

  return result;
}

uint64_t (*HgcSampler::Init(uint64_t a1, uint64_t a2, int a3))(int32x4_t *a1, float32x4_t *a2)
{
  v19 = *MEMORY[0x277D85DE8];
  (*(*a2 + 48))(a2, v15);
  v5 = vcvt_hight_f32_f64(vcvt_f32_f64(v15[0]), v15[1]);
  v6 = vcvt_hight_f32_f64(vcvt_f32_f64(v15[2]), v15[3]);
  *a1 = v5;
  *(a1 + 16) = v6;
  v7 = vcvt_f32_f64(v16);
  v8 = vcvt_f32_f64(v18);
  *&v9 = vcvt_f32_f64(v17);
  *(&v9 + 1) = v8;
  *(a1 + 32) = vcvt_hight_f32_f64(vcvt_f32_f64(v15[4]), v16);
  *(a1 + 48) = v9;
  v10.i64[0] = vuzp2q_s32(vuzp2q_s32(v5, v6), v5).u64[0];
  v10.i64[1] = __PAIR64__(v8.u32[1], v7.u32[1]);
  v11 = vaddvq_s32(vbicq_s8(xmmword_260347A70, vceqq_f32(v10, xmmword_2603427D0)));
  if (a3 <= 0)
  {
    v12 = GetAffineNearestTile;
  }

  else
  {
    v12 = GetAffineLinearTile;
  }

  v13 = GetPerspNearestTile;
  if (a3 > 0)
  {
    v13 = GetPerspLinearTile;
  }

  if ((v11 & 0xF) != 0)
  {
    return v13;
  }

  else
  {
    return v12;
  }
}

uint64_t GetAffineLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = (a1->i32[2] - a1->i32[0]);
    v4 = vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    v6 = vdupq_lane_s64(v5.i64[0], 0);
    v7 = vaddq_f32(a2[7], v4);
    v8 = vsubq_f32(vdupq_laneq_s64(v5, 1), a2[6]);
    v9 = a1[5].i64[0];
    v10 = a1[5].i32[2];
    v11 = a1[1].i64[0];
    i64 = a2[1].i64;
    v13 = vld1q_dup_f64(i64);
    v14 = a2[3].i64;
    v15 = vld1q_dup_f64(v14);
    v16.i64[0] = a2[4].i64[0];
    v16.i64[1] = a2->i64[0];
    v17 = vaddq_f32(v16, vsubq_f32(vaddq_f32(vmulq_f32(v13, vsriq_n_s64(v7, v7, 0x20uLL)), vaddq_f32(v15, vmulq_f32(vdupq_lane_s64(a2->i64[0], 0), vsliq_n_s64(v7, v7, 0x20uLL)))), v7));
    v18 = a1[1].i32[2];
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        do
        {
          v52 = vmaxq_f32(v17, v6);
          v53 = vminq_f32(v52, v8);
          v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
          v55 = vaddq_f32(v54, vcvtq_f32_s32(vcgtq_f32(v54, v53)));
          v56 = vshlq_n_s32(vcvtq_s32_f32(v55), 2uLL).u64[0];
          v57 = (v9 + 4 * (v56 + HIDWORD(v56) * v10));
          v52.i64[0] = vminq_f32(vsubq_f32(v52, v55), a2[5]).u64[0];
          v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v52.f32[0]));
          *v11 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v10], vmulq_n_f32(vsubq_f32(v57[v10 + 1], v57[v10]), v52.f32[0])), v58), *v52.f32, 1));
          v17 = vaddq_f32(v13, v17);
          v11 += v18;
          --v2;
        }

        while (v2);
      }
    }

    else
    {
      v19 = 0;
      v20 = vdupq_lane_s64(vaddq_f32(*a2, *a2).i64[0], 0);
      v21 = vdup_n_s32(v10);
      v22 = 16 * v18;
      v23 = v11 + 2;
      do
      {
        v24 = 0;
        v25 = v23;
        v26 = v3;
        v27 = v17;
        do
        {
          v28 = vmaxq_f32(v27, v6);
          v29 = vminq_f32(v28, v8);
          v30 = vcvtq_f32_s32(vcvtq_s32_f32(v29));
          v31 = vaddq_f32(v30, vcvtq_f32_s32(vcgtq_f32(v30, v29)));
          v32 = vsubq_f32(v28, v31);
          v33 = vshlq_n_s32(vcvtq_s32_f32(v31), 2uLL);
          v34 = vextq_s8(v33, v33, 8uLL).u64[0];
          *v33.i8 = vmla_s32(vzip1_s32(*v33.i8, v34), vzip2_s32(*v33.i8, v34), v21);
          v35 = vminq_f32(v32, a2[5]);
          v36 = v33.i32[1];
          v37 = (v9 + 4 * v33.i32[0]);
          v38 = vaddq_f32(*v37, vmulq_n_f32(vsubq_f32(v37[1], *v37), v35.f32[0]));
          v39 = vmulq_lane_f32(vsubq_f32(vaddq_f32(v37[v10], vmulq_n_f32(vsubq_f32(v37[v10 + 1], v37[v10]), v35.f32[0])), v38), *v35.f32, 1);
          v40 = &v11[v24];
          *v40 = vaddq_f32(v38, v39);
          v41 = (v9 + 4 * v36);
          v42 = vaddq_f32(*v41, vmulq_laneq_f32(vsubq_f32(v41[1], *v41), v35, 2));
          v43 = vaddq_f32(v42, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v41[v10], vmulq_laneq_f32(vsubq_f32(v41[v10 + 1], v41[v10]), v35, 2)), v42), v35, 3));
          v44 = v25;
          v40[1] = v43;
          v27 = vaddq_f32(v20, v27);
          v24 += 2;
          v26 -= 2;
          v25 += 2;
        }

        while (v26 > 1);
        if (v3 > v24)
        {
          do
          {
            v45 = vmaxq_f32(v27, v6);
            v46 = vminq_f32(v45, v8);
            v47 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
            v48 = vaddq_f32(v47, vcvtq_f32_s32(vcgtq_f32(v47, v46)));
            v49 = vsubq_f32(v45, v48);
            v48.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v48), 2uLL).u64[0];
            v49.i64[0] = vminq_f32(v49, a2[5]).u64[0];
            v50 = (v9 + 4 * (v48.i32[0] + v48.i32[1] * v10));
            v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v49.f32[0]));
            *v44++ = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v10], vmulq_n_f32(vsubq_f32(v50[v10 + 1], v50[v10]), v49.f32[0])), v51), *v49.f32, 1));
            v27 = vaddq_f32(v27, *a2);
            ++v24;
          }

          while (v24 < v3);
        }

        v17 = vaddq_f32(v13, v17);
        ++v19;
        v11 = (v11 + v22);
        v23 = (v23 + v22);
      }

      while (v19 != v2);
    }
  }

  return 0;
}

uint64_t GetAffineNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = (a1->i32[2] - a1->i32[0]);
    v4 = vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = vaddq_f32(a2[7], v4);
    v6 = vaddq_f32(a2[8], vsubq_f32(vcvtq_f32_s32(a1[13]), v4));
    v7 = vdupq_lane_s64(v6.i64[0], 0);
    v8 = vdupq_laneq_s64(v6, 1);
    v9 = a1[5].i64[0];
    v10 = a1[5].u32[2];
    i64 = a2[1].i64;
    v12 = vld1q_dup_f64(i64);
    v13 = a1[1].i64[0];
    v14 = a2[3].i64;
    v15 = vld1q_dup_f64(v14);
    v16 = vsubq_f32(vaddq_f32(vmulq_f32(v12, vsriq_n_s64(v5, v5, 0x20uLL)), vaddq_f32(v15, vmulq_f32(vdupq_lane_s64(a2->i64[0], 0), vsliq_n_s64(v5, v5, 0x20uLL)))), v4);
    v5.i64[0] = a2[4].i64[0];
    v5.i64[1] = a2->i64[0];
    v17 = vaddq_f32(v5, v16);
    v18 = a1[1].i32[2];
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v41 = 0;
        v42 = 16 * (a1->i32[2] - a1->i32[0]);
        do
        {
          v43 = 0;
          v44 = v17;
          do
          {
            v45 = vminq_f32(vmaxq_f32(v44, v7), v8);
            v46 = vcvtq_s32_f32(v45);
            v45.i64[0] = vshlq_n_s32(vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)), 2uLL).u64[0];
            *(v13 + v43) = *(v9 + 4 * (v45.i32[0] + v45.i32[1] * v10));
            v44 = vaddq_f32(v44, *a2);
            v43 += 16;
          }

          while (v42 != v43);
          v17 = vaddq_f32(v12, v17);
          ++v41;
          v13 += 16 * v18;
        }

        while (v41 != v2);
      }
    }

    else
    {
      v19 = 0;
      v20 = vaddq_f32(*a2, *a2);
      v21 = vdupq_lane_s64(v20.i64[0], 0);
      v22 = vdupq_lane_s64(vaddq_f32(v20, v20).i64[0], 0);
      v23 = vdupq_n_s32(v10);
      v24 = (v13 + 32);
      v25 = 16 * v18;
      v26 = (v13 + 64);
      do
      {
        v27 = 0;
        v28 = v26;
        v29 = v24;
        v30 = v17;
        do
        {
          v31 = vminq_f32(vmaxq_f32(v30, v7), v8);
          v32 = vminq_f32(vmaxq_f32(vaddq_f32(v21, v30), v7), v8);
          v33 = vcvtq_s32_f32(v31);
          v34 = vcvtq_s32_f32(v32);
          v35 = vshlq_n_s32(vaddq_s32(v33, vcgtq_f32(vcvtq_f32_s32(v33), v31)), 2uLL);
          v36 = vshlq_n_s32(vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v32)), 2uLL);
          v37 = vmlaq_s32(vuzp1q_s32(v35, v36), vuzp2q_s32(v35, v36), v23);
          *(v29 - 2) = *(v9 + 4 * v37.i32[0]);
          *(v29 - 1) = *(v9 + 4 * v37.i32[1]);
          v38 = v28;
          *v29 = *(v9 + 4 * v37.i32[2]);
          v29[1] = *(v9 + 4 * v37.i32[3]);
          v30 = vaddq_f32(v22, v30);
          v27 += 4;
          v29 += 4;
          v28 += 4;
        }

        while (v27 < (v3 - 3));
        if (v3 > v27)
        {
          do
          {
            v39 = vminq_f32(vmaxq_f32(v30, v7), v8);
            v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vshlq_n_s32(vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)), 2uLL).u64[0];
            *v38++ = *(v9 + 4 * (v39.i32[0] + v39.i32[1] * v10));
            v30 = vaddq_f32(v30, *a2);
            ++v27;
          }

          while (v27 < v3);
        }

        v17 = vaddq_f32(v12, v17);
        ++v19;
        v24 = (v24 + v25);
        v26 = (v26 + v25);
      }

      while (v19 != v2);
    }
  }

  return 0;
}

uint64_t GetPerspLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = a1->i32[2] - a1->i32[0];
    v5 = vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v6 = vsubq_f32(vcvtq_f32_s32(a1[13]), v5);
    v7 = vdupq_lane_s64(v6.i64[0], 0);
    v8 = vaddq_f32(a2[7], v5);
    v9 = vsubq_f32(vdupq_laneq_s64(v6, 1), a2[6]);
    v10 = a1[5].i64[0];
    v11 = a1[5].i32[2];
    v12 = a2[1];
    v13 = vdupq_lane_s64(v12.i64[0], 0);
    v14 = vdupq_laneq_s32(v12, 3);
    v15 = vaddq_f32(*a2, *a2);
    v16 = vdupq_lane_s64(v15.i64[0], 0);
    v17 = vdupq_laneq_s32(v15, 3);
    v18 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v8.f32[0])), vmulq_lane_f32(v12, *v8.f32, 1));
    v19 = vaddq_f32(*a2, v18);
    v20 = vuzp2q_s32(v18, v19);
    v21.i64[0] = v18.i64[0];
    v21.i64[1] = v19.i64[0];
    v22 = vtrn2q_s32(v20, v20);
    v23 = a1[1].i64[0];
    v24 = vdup_n_s32(v11);
    v25 = 16 * a1[1].i32[2];
    while (v4 < 2)
    {
      v26 = 0;
      v29 = v22;
      v28 = v21;
      if (v4 > 0)
      {
        goto LABEL_10;
      }

LABEL_3:
      v21 = vaddq_f32(v13, v21);
      v22 = vaddq_f32(v14, v22);
      ++v3;
      v23 += v25;
      if (v3 == v2)
      {
        return 0;
      }
    }

    v26 = 0;
    v27 = v4;
    v28 = v21;
    v29 = v22;
    do
    {
      v30 = vrecpeq_f32(v29);
      v31 = vmulq_f32(v30, vrecpsq_f32(v29, v30));
      v32 = vmaxq_f32(vsubq_f32(vmulq_f32(v28, vmulq_f32(v31, vrecpsq_f32(v29, v31))), v8), v7);
      v33 = vminq_f32(v32, v9);
      v34 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      v35 = vaddq_f32(v34, vcvtq_f32_s32(vcgtq_f32(v34, v33)));
      v36 = vshlq_n_s32(vcvtq_s32_f32(v35), 2uLL);
      v37 = vextq_s8(v36, v36, 8uLL).u64[0];
      *v36.i8 = vmla_s32(vzip1_s32(*v36.i8, v37), vzip2_s32(*v36.i8, v37), v24);
      v38 = v36.i32[1];
      v39 = (v10 + 4 * v36.i32[0]);
      v40 = vminq_f32(vsubq_f32(v32, v35), a2[5]);
      v41 = vaddq_f32(*v39, vmulq_n_f32(vsubq_f32(v39[1], *v39), v40.f32[0]));
      v42 = vsubq_f32(vaddq_f32(v39[v11], vmulq_n_f32(vsubq_f32(v39[v11 + 1], v39[v11]), v40.f32[0])), v41);
      v43 = (v23 + 16 * v26);
      *v43 = vaddq_f32(v41, vmulq_lane_f32(v42, *v40.f32, 1));
      v44 = (v10 + 4 * v38);
      v45 = vaddq_f32(*v44, vmulq_laneq_f32(vsubq_f32(v44[1], *v44), v40, 2));
      v43[1] = vaddq_f32(v45, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v44[v11], vmulq_laneq_f32(vsubq_f32(v44[v11 + 1], v44[v11]), v40, 2)), v45), v40, 3));
      v28 = vaddq_f32(v16, v28);
      v29 = vaddq_f32(v17, v29);
      v26 += 2;
      v27 -= 2;
    }

    while (v27 > 1);
    v26 = v26;
    if (v26 >= v4)
    {
      goto LABEL_3;
    }

    do
    {
LABEL_10:
      v46 = vrecpeq_f32(v29);
      v47 = vmulq_f32(v46, vrecpsq_f32(v29, v46));
      v48 = vmaxq_f32(vsubq_f32(vmulq_f32(v28, vmulq_f32(v47, vrecpsq_f32(v29, v47))), v8), v7);
      v49 = vminq_f32(v48, v9);
      v50 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      v51 = vaddq_f32(v50, vcvtq_f32_s32(vcgtq_f32(v50, v49)));
      v48.i64[0] = vminq_f32(vsubq_f32(v48, v51), a2[5]).u64[0];
      v51.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v51), 2uLL).u64[0];
      v52 = (v10 + 4 * (v51.i32[0] + v51.i32[1] * v11));
      v53 = vaddq_f32(*v52, vmulq_n_f32(vsubq_f32(v52[1], *v52), v48.f32[0]));
      *(v23 + 16 * v26) = vaddq_f32(v53, vmulq_lane_f32(vsubq_f32(vaddq_f32(v52[v11], vmulq_n_f32(vsubq_f32(v52[v11 + 1], v52[v11]), v48.f32[0])), v53), *v48.f32, 1));
      v28 = vaddq_f32(v28, *a2);
      v29 = vaddq_f32(v29, vdupq_laneq_s32(*a2, 3));
      ++v26;
    }

    while (v26 < v4);
    goto LABEL_3;
  }

  return 0;
}

uint64_t GetPerspNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    v3 = (a1->i32[2] - a1->i32[0]);
    v4 = vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    v5 = vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    v6 = vdupq_lane_s64(v5.i64[0], 0);
    v7 = vaddq_f32(a2[7], v4);
    v8 = vsubq_f32(vdupq_laneq_s64(v5, 1), a2[5]);
    v9 = a1[5].i64[0];
    v10 = a1[5].u32[2];
    v11 = a1[1].i64[0];
    v12 = a2[1];
    v16 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v7.f32[0])), vmulq_lane_f32(v12, *v7.f32, 1));
    v13 = vaddq_f32(*a2, v16);
    v14 = vuzp2q_s32(v16, v13);
    v15 = vtrn2q_s32(v14, v14);
    v16.i64[1] = v13.i64[0];
    v17 = vdupq_lane_s64(v12.i64[0], 0);
    v18 = vdupq_laneq_s32(v12, 3);
    v19 = a1[1].i32[2];
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        do
        {
          v43 = vrecpeq_f32(v15);
          v44 = vmulq_f32(v43, vrecpsq_f32(v15, v43));
          v45 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v16, vmulq_f32(v44, vrecpsq_f32(v15, v44))), v7), v6), v8), a2[7]);
          v46 = vcvtq_s32_f32(v45);
          v45.i64[0] = vshlq_n_s32(vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)), 2uLL).u64[0];
          *v11 = *(v9 + 4 * (v45.i32[0] + v45.i32[1] * v10));
          v16 = vaddq_f32(v17, v16);
          v15 = vaddq_f32(v18, v15);
          v11 += v19;
          --v2;
        }

        while (v2);
      }
    }

    else
    {
      v20 = 0;
      v21 = vaddq_f32(*a2, *a2);
      v22 = vdupq_lane_s64(v21.i64[0], 0);
      v23 = vdupq_laneq_s32(v21, 3);
      v24 = vdup_n_s32(v10);
      v25 = 16 * v19;
      v26 = v11 + 2;
      do
      {
        v27 = 0;
        v28 = v26;
        v29 = v3;
        v30 = v16;
        v31 = v15;
        do
        {
          v32 = v28;
          v33 = vrecpeq_f32(v31);
          v34 = vmulq_f32(v33, vrecpsq_f32(v31, v33));
          v35 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v30, vmulq_f32(v34, vrecpsq_f32(v31, v34))), v7), v6), v8), a2[7]);
          v36 = vcvtq_s32_f32(v35);
          v37 = vshlq_n_s32(vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)), 2uLL);
          v36.i64[0] = vextq_s8(v37, v37, 8uLL).u64[0];
          *v37.i8 = vmla_s32(vzip1_s32(*v37.i8, *v36.i8), vzip2_s32(*v37.i8, *v36.i8), v24);
          v38 = &v11[v27];
          *v38 = *(v9 + 4 * v37.i32[0]);
          v38[1] = *(v9 + 4 * v37.i32[1]);
          v30 = vaddq_f32(v22, v30);
          v31 = vaddq_f32(v23, v31);
          v27 += 2;
          v29 -= 2;
          v28 += 2;
        }

        while (v29 > 1);
        if (v3 > v27)
        {
          do
          {
            v39 = vrecpeq_f32(v31);
            v40 = vmulq_f32(v39, vrecpsq_f32(v31, v39));
            v41 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v30, vmulq_f32(v40, vrecpsq_f32(v31, v40))), v7), v6), v8), a2[7]);
            v42 = vcvtq_s32_f32(v41);
            v41.i64[0] = vshlq_n_s32(vaddq_s32(v42, vcgtq_f32(vcvtq_f32_s32(v42), v41)), 2uLL).u64[0];
            *v32++ = *(v9 + 4 * (v41.i32[0] + v41.i32[1] * v10));
            v30 = vaddq_f32(v30, *a2);
            v31 = vaddq_f32(v31, vdupq_laneq_s32(*a2, 3));
            ++v27;
          }

          while (v27 < v3);
        }

        v16 = vaddq_f32(v17, v16);
        v15 = vaddq_f32(v18, v15);
        ++v20;
        v11 = (v11 + v25);
        v26 = (v26 + v25);
      }

      while (v20 != v2);
    }
  }

  return 0;
}

const char *GetApply1DProgram(HGRenderer *a1, int a2, int a3)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (a3)
  {
    if (a2)
    {
      if (Target == 396048)
      {
        if ((*(*a1 + 128))(a1, 20) == 27)
        {
          return "//Metal1.0     \n//LEN=0000000695\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, half4(hg_Params[1]));\n    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n    return output;\n}\n//MD5=088a2ea0:e59dd2d6:fba2ff6e:81cad2ec\n//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
        }

        else
        {
          return "//Metal1.0     \n//LEN=0000000601\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r2.xyz = r1.xyz*hg_Params[0].www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n//MD5=9263a2c0:8288b26d:8fbddfa1:77a5bd13\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
        }
      }

      if (Target > 0x6060F && !(*(*a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n//LEN=000000068d\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform mediump vec4 hg_ProgramLocal0;\nuniform mediump vec4 hg_ProgramLocal1;\nuniform mediump vec4 hg_ProgramLocal2;\nuniform mediump vec4 hg_ProgramLocal3;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    mediump vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n    r1 = max(r1, c0.xxxx);\n    r1 = min(r1, hg_ProgramLocal1);\n    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.x = texture2D(hg_Texture1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.y = texture2D(hg_Texture1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.z = texture2D(hg_Texture1, r3.xy).z;\n    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n}\n//MD5=a5cfaee8:157e3765:82b70125:1b812651\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }

      return 0;
    }

    if (Target != 396048)
    {
      if (Target > 0x6060F && !(*(*a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n//LEN=0000000715\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform mediump vec4 hg_ProgramLocal0;\nuniform mediump vec4 hg_ProgramLocal1;\nuniform mediump vec4 hg_ProgramLocal2;\nuniform mediump vec4 hg_ProgramLocal3;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    mediump vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n    r1 = max(r1, c0.xxxx);\n    r1 = min(r1, hg_ProgramLocal1);\n    r2 = r1*hg_ProgramLocal0.wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.x = texture2D(hg_Texture1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.y = texture2D(hg_Texture1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.z = texture2D(hg_Texture1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.w = texture2D(hg_Texture1, r3.xy).w;\n    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n}\n//MD5=7949d19f:647deb0d:606cf61d:25a04486\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }

      return 0;
    }

    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000073b\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, half4(hg_Params[1]));\n    r2 = r1*half4(hg_Params[0].wwww);\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n    return output;\n}\n//MD5=b5146dd3:d04f9178:3aab6ef7:97b6a091\n//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=000000068a\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r2 = r1*hg_Params[0].wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n//MD5=aa6d9d69:00cc6589:b7bb52c4:fb672a48\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }
  }

  else if (a2)
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F && !(*(*a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n//LEN=00000006b2\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform mediump vec4 hg_ProgramLocal0;\nuniform mediump vec4 hg_ProgramLocal1;\nuniform mediump vec4 hg_ProgramLocal2;\nuniform mediump vec4 hg_ProgramLocal3;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    mediump vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n    r1 = max(r1, c0.xxxx);\n    r1 = min(r1, hg_ProgramLocal1);\n    r1 = floor(r1 + vec4(0.500000));\n    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.x = texture2D(hg_Texture1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.y = texture2D(hg_Texture1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.z = texture2D(hg_Texture1, r3.xy).z;\n    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n}\n//MD5=fe9c2870:f4fd6520:781b2d50:b5800b8f\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }

      return 0;
    }

    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=00000006a9\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, half4(hg_Params[1]));\n    r1 = round(r1);\n    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n    return output;\n}\n//MD5=ba2b5020:e21a8fc7:4195c0d3:4952a624\n//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000615\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r1 = round(r1);\n    r2.xyz = r1.xyz*hg_Params[0].www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n//MD5=3489e71d:d8b87767:07e113d5:dac13266\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }
  }

  else
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F && !(*(*a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n//LEN=000000073a\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform mediump vec4 hg_ProgramLocal0;\nuniform mediump vec4 hg_ProgramLocal1;\nuniform mediump vec4 hg_ProgramLocal2;\nuniform mediump vec4 hg_ProgramLocal3;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    mediump vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n    r1 = max(r1, c0.xxxx);\n    r1 = min(r1, hg_ProgramLocal1);\n    r1 = floor(r1 + vec4(0.500000));\n    r2 = r1*hg_ProgramLocal0.wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.x = texture2D(hg_Texture1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.y = texture2D(hg_Texture1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.z = texture2D(hg_Texture1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n    r1.w = texture2D(hg_Texture1, r3.xy).w;\n    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n}\n//MD5=cf4b61f8:5234da11:e8d20cae:98f38ab4\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }

      return 0;
    }

    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000074f\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, half4(hg_Params[1]));\n    r1 = round(r1);\n    r2 = r1*half4(hg_Params[0].wwww);\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + half2(hg_Params[3].xy);\n    r3.xy = r3.xy*half2(hg_Params[3].zw);\n    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n    return output;\n}\n//MD5=131ada21:fe61a7dd:c3645ed8:df8b231e\n//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=000000069e\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r1 = round(r1);\n    r2 = r1*hg_Params[0].wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n//MD5=52ea6efa:ae1d09bb:5ff0d6c3:c1f69c84\n//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    }
  }
}

void InitApply1DProgramDescriptor(HGProgramDescriptor *this, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=00000004bb\n[[ visible ]] FragmentOut Apply1Dx3LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = color0;\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r2.xyz = r1.xyz*hg_Params[0].www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n");
      HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx3LUTLinear");
    }

    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=0000000544\n[[ visible ]] FragmentOut Apply1Dx4LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = color0;\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r2 = r1*hg_Params[0].wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n");
    HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx4LUTLinear");
  }

  if (a2)
  {
    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=00000004d0\n[[ visible ]] FragmentOut Apply1Dx3LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = color0;\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r1 = round(r1);\n    r2.xyz = r1.xyz*hg_Params[0].www;\n    r2.xyz = floor(r2.xyz);\n    r2.xyz = r2.xyz + c0.yyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n");
    HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx3LUTNearest");
  }

  HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=0000000559\n[[ visible ]] FragmentOut Apply1Dx4LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = color0;\n    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n    r1 = fmax(r1, c0.xxxx);\n    r1 = fmin(r1, hg_Params[1]);\n    r1 = round(r1);\n    r2 = r1*hg_Params[0].wwww;\n    r2 = floor(r2);\n    r2 = r2 + c0.yyyy;\n    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n    r1 = r1 + c0.yyyy;\n    r3.x = r1.x;\n    r3.y = r2.x;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n    r3.x = r1.y;\n    r3.y = r2.y;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n    r3.x = r1.z;\n    r3.y = r2.z;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n    r3.x = r1.w;\n    r3.y = r2.w;\n    r3.xy = r3.xy + hg_Params[3].xy;\n    r3.xy = r3.xy*hg_Params[3].zw;\n    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n    return output;\n}\n");
  HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx4LUTNearest");
}

void sub_25FD4B41C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4B490(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4B488);
}

uint64_t Get1DLUTLinearTile(HGTile *a1, const float *a2, float32x4_t *a3, float32x4_t *a4, int a5)
{
  v8 = *(a1 + 2) - *a1;
  v9 = a4->f32[3];
  v10 = *(a1 + 3) - *(a1 + 1);
  v11 = *a2;
  v12 = *a3;
  v13 = *a4;
  v14 = vdupq_lane_s32(*a2, 1);
  v15 = *(a1 + 12);
  if (a5)
  {
    if (v9 >= 0.0)
    {
      if (v10 >= 1 && v8 >= 1)
      {
        v48 = 0;
        v49 = *(a1 + 10);
        v50 = *(a1 + 2);
        v51 = 16 * (*(a1 + 2) - *a1);
        v52 = 16 * *(a1 + 6);
        v53 = 16 * *(a1 + 22);
        v54 = vcltzq_f32(v13);
        do
        {
          v55 = 0;
          do
          {
            v56 = *(v49 + v55);
            v57 = vminq_f32(vmaxq_f32(vaddq_f32(v14, vmulq_n_f32(v56, *&v11)), 0), v12);
            v58 = vcvtq_s32_f32(v57);
            v59 = vcvtq_f32_s32(v58);
            v60 = vshlq_n_s32(v58, 2uLL);
            v61 = vsubq_f32(v57, v59);
            v62 = (v15 + 4 * v60.i32[0]);
            v63 = (v15 + 4 * v60.i32[1]);
            v64 = v15 + 4 * v60.i32[2];
            v65 = v15 + 4 * v60.i32[3];
            v60.i64[0] = vslid_n_s64(*v62, *(v64 + 8), 0x20uLL);
            v59.i64[0] = vsrid_n_s64(*(v65 + 8), *v63, 0x20uLL);
            v66 = vzip1q_s32(v60, v59);
            v59.i64[0] = vslid_n_s64(v62[2], *(v64 + 24), 0x20uLL);
            v6.i64[0] = vsrid_n_s64(*(v65 + 24), v63[2], 0x20uLL);
            *(v50 + v55) = vbslq_s8(v54, v56, vaddq_f32(v66, vmulq_f32(v61, vsubq_f32(vzip1q_s32(v59, v6), v66))));
            v55 += 16;
          }

          while (v51 != v55);
          ++v48;
          v50 += v52;
          v49 += v53;
        }

        while (v48 != v10);
      }
    }

    else if (v10 >= 1 && v8 >= 1)
    {
      v16 = 0;
      v17 = *(a1 + 10);
      v18 = *(a1 + 2);
      v19 = 16 * (*(a1 + 2) - *a1);
      v20 = 16 * *(a1 + 6);
      v21 = 16 * *(a1 + 22);
      v22 = vcltzq_f32(v13);
      do
      {
        v23 = 0;
        do
        {
          v24 = *(v17 + v23);
          v25 = vminq_f32(vmaxq_f32(vaddq_f32(v14, vmulq_n_f32(v24, *&v11)), 0), v12);
          v26 = vcvtq_s32_f32(v25);
          v27 = vcvtq_f32_s32(v26);
          v28 = vshlq_n_s32(v26, 2uLL);
          v29 = vsubq_f32(v25, v27);
          v30 = (v15 + 4 * v28.i32[0]);
          v31 = (v15 + 4 * v28.i32[1]);
          v32 = v15 + 4 * v28.i32[2];
          v28.i64[0] = vslid_n_s64(*v30, *(v32 + 8), 0x20uLL);
          v33 = vextq_s8(v24, v24, 8uLL);
          v7.i64[0] = vsrid_n_s64(v33.i64[0], *v31, 0x20uLL);
          v34 = vzip1q_s32(v28, v7);
          v6.i64[0] = vslid_n_s64(v30[2], *(v32 + 24), 0x20uLL);
          v33.i64[0] = vsrid_n_s64(v33.i64[0], v31[2], 0x20uLL);
          *(v18 + v23) = vbslq_s8(v22, v24, vaddq_f32(v34, vmulq_f32(v29, vsubq_f32(vzip1q_s32(v6, v33), v34))));
          v23 += 16;
        }

        while (v19 != v23);
        ++v16;
        v18 += v20;
        v17 += v21;
      }

      while (v16 != v10);
    }
  }

  else if (v9 >= 0.0)
  {
    if (v10 >= 1 && v8 >= 1)
    {
      v67 = 0;
      v68 = v15 + 8;
      v69 = *(a1 + 10);
      v70 = *(a1 + 2);
      v71 = 16 * (*(a1 + 2) - *a1);
      v72 = 16 * *(a1 + 6);
      v73 = 16 * *(a1 + 22);
      v74 = vcltzq_f32(v13);
      v75.i64[0] = 0x3F0000003F000000;
      v75.i64[1] = 0x3F0000003F000000;
      do
      {
        v76 = 0;
        do
        {
          v77 = *(v69 + v76);
          v78 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v14, vmulq_n_f32(v77, *&v11)), 0), v12), v75)), 2uLL);
          v79 = 4 * v78.i32[1];
          v78.i64[0] = vslid_n_s64(*(v15 + 4 * v78.i32[0]), *(v68 + 4 * v78.i32[2]), 0x20uLL);
          v5.i64[0] = vsrid_n_s64(*(v68 + 4 * v78.i32[3]), *(v15 + v79), 0x20uLL);
          *(v70 + v76) = vbslq_s8(v74, v77, vzip1q_s32(v78, v5));
          v76 += 16;
        }

        while (v71 != v76);
        ++v67;
        v70 += v72;
        v69 += v73;
      }

      while (v67 != v10);
    }
  }

  else if (v10 >= 1 && v8 >= 1)
  {
    v35 = 0;
    v36 = *(a1 + 10);
    v37 = *(a1 + 2);
    v38 = 16 * (*(a1 + 2) - *a1);
    v39 = 16 * *(a1 + 6);
    v40 = 16 * *(a1 + 22);
    v41 = vcltzq_f32(v13);
    v42.i64[0] = 0x3F0000003F000000;
    v42.i64[1] = 0x3F0000003F000000;
    do
    {
      v43 = 0;
      do
      {
        v44 = *(v36 + v43);
        v45 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v14, vmulq_n_f32(v44, *&v11)), 0), v12), v42)), 2uLL);
        v46 = 4 * v45.i32[1];
        v45.i64[0] = vslid_n_s64(*(v15 + 4 * v45.i32[0]), *(v15 + 8 + 4 * v45.i32[2]), 0x20uLL);
        v47 = vextq_s8(v44, v44, 8uLL);
        v47.i64[0] = vsrid_n_s64(v47.i64[0], *(v15 + v46), 0x20uLL);
        *(v37 + v43) = vbslq_s8(v41, v44, vzip1q_s32(v45, v47));
        v43 += 16;
      }

      while (v38 != v43);
      ++v35;
      v37 += v39;
      v36 += v40;
    }

    while (v35 != v10);
  }

  return 0;
}

void HGLegacyBlend::HGLegacyBlend(HGLegacyBlend *this)
{
  HGNode::HGNode(this);
  *v1 = &unk_287226F50;
  v1[51] = 0;
  operator new();
}

void sub_25FD4B90C(_Unwind_Exception *a1)
{
  v3 = *(v1 + 408);
  if (v3)
  {
    (*(*v3 + 24))(v3);
  }

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

uint64_t HGLegacyBlend::SetParameter(HGLegacyBlend *this, uint64_t a2, double a3, double a4, float a5, float a6, char *a7)
{
  v7 = 0xFFFFFFFFLL;
  if (a2 <= 1)
  {
    if (a2)
    {
      if (a2 == 1)
      {
        *(this + 104) = LODWORD(a3);
        **(this + 55) = vdupq_lane_s32(*&a3, 0);
LABEL_15:
        HGNode::ClearBits(this, a2, a7);
        return 1;
      }

      return v7;
    }

    v8 = vcvtms_s32_f32(*&a3);
    if (v8 <= 8)
    {
      if (*(this + 106) == v8)
      {
        return 0;
      }

      *(this + 106) = v8;
      goto LABEL_15;
    }

    return 0xFFFFFFFFLL;
  }

  if (a2 == 2)
  {
    v10 = vcvtms_s32_f32(*&a3);
    v11 = v10 != 0;
    if (*(this + 107) != v11)
    {
      *(this + 107) = v11;
      *(this + 108) = v10 == 0;
      goto LABEL_15;
    }

    return 0xFFFFFFFFLL;
  }

  if (a2 == 5)
  {
    *(this + 105) = LODWORD(a3);
    *&a4 = 1.0 / *&a3;
    *(*(this + 55) + 16) = vdupq_lane_s32(*&a4, 0);
    *(*(this + 55) + 32) = vdupq_lane_s32(*&a3, 0);
    goto LABEL_15;
  }

  return v7;
}

void HGLegacyBlend::~HGLegacyBlend(HGNode *this)
{
  *this = &unk_287226F50;
  v2 = *(this + 55);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C404247E4FDLL);
  }

  v3 = *(this + 51);
  if (v3)
  {
    (*(*v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  *this = &unk_287226F50;
  v2 = *(this + 55);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C404247E4FDLL);
  }

  v3 = *(this + 51);
  if (v3)
  {
    (*(*v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  *this = &unk_287226F50;
  v2 = *(this + 55);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C404247E4FDLL);
  }

  v3 = *(this + 51);
  if (v3)
  {
    (*(*v3 + 24))(v3);
  }

  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGLegacyBlend::GetParameter(HGLegacyBlend *this, int a2, float *a3)
{
  result = 0xFFFFFFFFLL;
  if (a2 <= 1)
  {
    if (a2)
    {
      if (a2 != 1)
      {
        return result;
      }

      v5 = *(this + 55);
      *a3 = *v5;
      a3[1] = *(v5 + 4);
      a3[2] = *(v5 + 8);
      v6 = *(v5 + 12);
      goto LABEL_11;
    }

    v8 = *(this + 106);
    goto LABEL_10;
  }

  if (a2 == 2)
  {
    v8 = *(this + 107);
LABEL_10:
    *a3 = v8;
    a3[1] = 0.0;
    a3[2] = 0.0;
    v6 = 0;
    goto LABEL_11;
  }

  if (a2 != 5)
  {
    return result;
  }

  v7 = *(this + 55);
  *a3 = *(v7 + 32);
  a3[1] = *(v7 + 36);
  a3[2] = *(v7 + 40);
  v6 = *(v7 + 44);
LABEL_11:
  result = 0;
  *(a3 + 3) = v6;
  return result;
}

HGNode *HGLegacyBlend::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, *(this + 107));
  result = HGRenderer::GetInput(a2, this, *(this + 108));
  if (Input)
  {
    if (result)
    {
      v6 = *(this + 104);
      if (v6 == 0.0)
      {
        return Input;
      }

      else if (v6 != 1.0 || *(this + 106) != 8)
      {
        if (*(this + 107))
        {
          v7 = result;
          v8 = (*(*this + 576))(this);
          v9 = *(this + 51);
          if (v9 == v8)
          {
            if (v8)
            {
              (*(*v8 + 24))(v8);
              v9 = *(this + 51);
            }
          }

          else
          {
            if (v9)
            {
              (*(*v9 + 24))(v9);
            }

            *(this + 51) = v8;
            v9 = v8;
          }

          (*(*v9 + 96))(v9, 2, 0.0, 0.0, 0.0, 0.0);
          (*(**(this + 51) + 120))(*(this + 51), 0, Input);
          (*(**(this + 51) + 120))(*(this + 51), 1, v7);
          v10 = *(this + 51);
          v11 = (*(*this + 152))(this, 1);
          (*(*v10 + 136))(v10, 0, v11);
          v12 = *(this + 51);
          v13 = (*(*this + 152))(this, 0);
          (*(*v12 + 136))(v12, 1, v13);
          v14 = *(this + 51);
          v15 = (*(*this + 152))(this, 0xFFFFFFFFLL);
          (*(*v14 + 136))(v14, 0xFFFFFFFFLL, v15);
          return *(this + 51);
        }

        else
        {
          return this;
        }
      }
    }

    else
    {
      return Input;
    }
  }

  return result;
}

void sub_25FD4C0D4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    (*(*v1 + 24))(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t HGLegacyBlend::GetDOD(HGLegacyBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
  {
    return 0;
  }

  else
  {
    return *&a4.var0;
  }
}

uint64_t HGLegacyBlend::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 > 1)
  {
    return 0;
  }

  v4 = *&a4.var2;
  v5 = *&a4.var0;
  Input = HGRenderer::GetInput(a2, this, a3);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = HGRectIntersection(DOD, v9, v5, v4);
  if (HGRectIsNull(v10, v11))
  {
    return 0;
  }

  return v5;
}

uint64_t HGLegacyBlend::RenderTile(HGLegacyBlend *this, HGTile *a2, int a3, float *a4)
{
  if (!a4)
  {
    return 1;
  }

  v4 = *(this + 55);
  v105[0] = *v4;
  v5 = v4[4];
  v105[3] = v4[3];
  v105[4] = v5;
  *&v5 = *a4;
  v105[0] = vdupq_lane_s32(*&v5, 0);
  v6 = a4 + 4;
  v7 = vld1q_dup_f32(v6);
  v105[1] = v7;
  v8 = a4 + 8;
  v9 = vld1q_dup_f32(v8);
  v105[2] = v9;
  v10 = *(a2 + 10);
  v11 = *(a2 + 12);
  if (v10)
  {
    if (v11)
    {
      (s_func_blend_table[a3])(a2, v105, this);
    }

    else if (a3 == 8)
    {
      v34 = *(a2 + 3) - *(a2 + 1);
      if (v34 >= 1)
      {
        v35 = (*(a2 + 2) - *a2);
        v36 = *(a2 + 2);
        v37 = *(a2 + 6);
        v38 = *(a2 + 22);
        if (v35 < 4)
        {
          if (v35 >= 1)
          {
            v95 = 0;
            v96 = 16 * (*(a2 + 2) - *a2);
            v97 = 16 * v37;
            v98 = 16 * v38;
            do
            {
              v99 = 0;
              do
              {
                v36[v99 / 0x10] = vsubq_f32(v10[v99 / 0x10], vmulq_n_f32(v10[v99 / 0x10], *&v5));
                v99 += 16;
              }

              while (v96 != v99);
              ++v95;
              v36 = (v36 + v97);
              v10 = (v10 + v98);
            }

            while (v95 != v34);
          }
        }

        else
        {
          v39 = 0;
          v40 = 16 * v38;
          v41 = 16 * v37;
          v42 = v36 + 4;
          v43 = v10 + 4;
          do
          {
            v44 = 0;
            v45 = v43;
            v46 = v42;
            v47 = 3;
            do
            {
              v48 = v46;
              v49 = v45;
              v50 = vsubq_f32(v10[v47 - 2], vmulq_n_f32(v10[v47 - 2], *&v5));
              v51 = vsubq_f32(v10[v47 - 1], vmulq_n_f32(v10[v47 - 1], *&v5));
              v52 = vsubq_f32(v10[v47], vmulq_n_f32(v10[v47], *&v5));
              v53 = &v36[v47];
              v53[-3] = vsubq_f32(v10[v47 - 3], vmulq_n_f32(v10[v47 - 3], *&v5));
              v53[-2] = v50;
              v44 += 4;
              v53[-1] = v51;
              *v53 = v52;
              v47 += 4;
              v46 += 4;
              v45 = v49 + 4;
            }

            while (v44 < (v35 - 3));
            if (v35 > v44)
            {
              do
              {
                v54 = *v49++;
                *v48++ = vsubq_f32(v54, vmulq_n_f32(v54, *&v5));
                ++v44;
              }

              while (v44 < v35);
            }

            ++v39;
            v10 = (v10 + v40);
            v36 = (v36 + v41);
            v42 = (v42 + v41);
            v43 = (v43 + v40);
          }

          while (v39 != v34);
        }
      }
    }

    else
    {
      v67 = *(a2 + 2);
      if (v67 != v10)
      {
        v68 = *(a2 + 3) - *(a2 + 1);
        if (v68 >= 1)
        {
          v69 = (*(a2 + 2) - *a2);
          v70 = *(a2 + 6);
          v71 = *(a2 + 22);
          if (v69 < 4)
          {
            if (v69 >= 1)
            {
              v100 = 0;
              v101 = 16 * (*(a2 + 2) - *a2);
              v102 = 16 * v70;
              v103 = 16 * v71;
              do
              {
                v104 = 0;
                do
                {
                  *(v67 + v104) = v10[v104 / 0x10];
                  v104 += 16;
                }

                while (v101 != v104);
                ++v100;
                v67 += v102;
                v10 = (v10 + v103);
              }

              while (v100 != v68);
            }
          }

          else
          {
            v72 = 0;
            v73 = 16 * v71;
            v74 = 16 * v70;
            v75 = (v67 + 64);
            v76 = &v10[4];
            do
            {
              v77 = 0;
              v78 = v76;
              v79 = v75;
              v80 = 3;
              do
              {
                v81 = v79;
                v82 = v78;
                v83 = v10[v80 - 2];
                v84 = v10[v80 - 1];
                v85 = v10[v80];
                v86 = (v67 + v80 * 16);
                v86[-3] = v10[v80 - 3];
                v86[-2] = v83;
                v77 += 4;
                v86[-1] = v84;
                *v86 = v85;
                v80 += 4;
                v79 += 4;
                v78 = v82 + 4;
              }

              while (v77 < (v69 - 3));
              if (v69 > v77)
              {
                do
                {
                  v87 = *v82++;
                  *v81++ = v87;
                  ++v77;
                }

                while (v77 < v69);
              }

              ++v72;
              v10 = (v10 + v73);
              v67 += v74;
              v75 = (v75 + v74);
              v76 = (v76 + v73);
            }

            while (v72 != v68);
          }
        }
      }
    }
  }

  else if (v11)
  {
    v13 = *(a2 + 2);
    if (*&v5 != 1.0 || v13 != v11)
    {
      v14 = *(a2 + 3) - *(a2 + 1);
      if (v14 >= 1)
      {
        v15 = (*(a2 + 2) - *a2);
        v16 = *(a2 + 6);
        v17 = *(a2 + 26);
        if (v15 < 4)
        {
          if (v15 >= 1)
          {
            v90 = 0;
            v91 = 16 * (*(a2 + 2) - *a2);
            v92 = 16 * v16;
            v93 = 16 * v17;
            do
            {
              v94 = 0;
              do
              {
                v13[v94 / 0x10] = vmulq_n_f32(v11[v94 / 0x10], *&v5);
                v94 += 16;
              }

              while (v91 != v94);
              ++v90;
              v13 = (v13 + v92);
              v11 = (v11 + v93);
            }

            while (v90 != v14);
          }
        }

        else
        {
          v18 = 0;
          v19 = 16 * v17;
          v20 = 16 * v16;
          v21 = v13 + 4;
          v22 = v11 + 4;
          do
          {
            v23 = 0;
            v24 = v22;
            v25 = v21;
            v26 = 3;
            do
            {
              v27 = v25;
              v28 = v24;
              v29 = vmulq_n_f32(v11[v26 - 2], *&v5);
              v30 = vmulq_n_f32(v11[v26 - 1], *&v5);
              v31 = vmulq_n_f32(v11[v26], *&v5);
              v32 = &v13[v26];
              v32[-3] = vmulq_n_f32(v11[v26 - 3], *&v5);
              v32[-2] = v29;
              v23 += 4;
              v32[-1] = v30;
              *v32 = v31;
              v26 += 4;
              v25 += 4;
              v24 = v28 + 4;
            }

            while (v23 < (v15 - 3));
            if (v15 > v23)
            {
              do
              {
                v33 = *v28++;
                *v27++ = vmulq_n_f32(v33, *&v5);
                ++v23;
              }

              while (v23 < v15);
            }

            ++v18;
            v11 = (v11 + v19);
            v13 = (v13 + v20);
            v21 = (v21 + v20);
            v22 = (v22 + v19);
          }

          while (v18 != v14);
        }
      }
    }
  }

  else
  {
    v55 = (*(a2 + 3) - *(a2 + 1));
    if (v55 >= 1)
    {
      v56 = *(a2 + 2);
      v57 = v56 - *a2;
      v58 = *(a2 + 2);
      v59 = *(a2 + 6);
      v60 = v57 - 4;
      if (v57 < 4)
      {
        if (v57 >= 1)
        {
          v88 = 16 * (v56 + ~*a2);
          v89 = 16 * v59;
          do
          {
            bzero(v58, v88 + 16);
            v58 += v89;
            LODWORD(v55) = v55 - 1;
          }

          while (v55);
        }
      }

      else
      {
        v61 = ((v60 >> 2) << 6) + 64;
        v62 = 16 * v59;
        v63 = v60 & 0xFFFFFFFC;
        v64 = (v60 & 0xFFFFFFFC) + 5;
        if (v57 > v64)
        {
          v64 = v57;
        }

        v65 = 16 * (v64 - v63 - 5);
        v66 = v63 + 4;
        do
        {
          bzero(v58, v61);
          if (v57 > v66)
          {
            bzero(&v58[v61], v65 + 16);
          }

          v58 += v62;
          --v55;
        }

        while (v55);
      }
    }
  }

  return 0;
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)0>(HGNode *a1, HGRect *a2)
{
  v4 = *&a2->var0;
  v5 = (*(*a1 + 400))(a1, *&a2->var0, *(a1 + 108), *&a2[1].var0, *&a2[1].var2);
  if (HGRectIsNull(v5, v6))
  {
    v7 = *(a1 + 107);
LABEL_3:
    Input = HGRenderer::GetInput(v4, a1, v7);
    v9 = a2[1];
    v10 = *&a2->var2;

    return HGGPURenderer::GetNodeBitmap(v4, Input, v9, v10, 1u);
  }

  if (*(a1 + 104) == 1.0)
  {
    v12 = (*(*a1 + 400))(a1, v4, *(a1 + 107), *&a2[1].var0, *&a2[1].var2);
    if (HGRectIsNull(v12, v13))
    {
      v7 = *(a1 + 108);
      goto LABEL_3;
    }
  }

  return HGNode::RenderPage(a1, a2);
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)1>(HGNode *a1, HGPage *a2)
{
  v4 = *a2;
  v5 = (*(*a1 + 400))(a1, *a2, *(a1 + 108), *(a2 + 2), *(a2 + 3));
  if (HGRectIsNull(v5, v6))
  {
    v7 = *(a1 + 107);
LABEL_3:
    Input = HGRenderer::GetInput(v4, a1, v7);
    v9 = *(a2 + 1);
    v10 = *(a2 + 1);

    return HGGPURenderer::GetNodeBitmap(v4, Input, v9, v10, 1u);
  }

  if (*(a1 + 104) == 1.0)
  {
    v12 = (*(*a1 + 400))(a1, v4, *(a1 + 107), *(a2 + 2), *(a2 + 3));
    if (HGRectIsNull(v12, v13))
    {
      v7 = *(a1 + 108);
      goto LABEL_3;
    }
  }

  return HGNode::RenderPageMetal(a1, a2);
}

uint64_t HGLegacyBlend::InitProgramDescriptor(HGNode *this, HGProgramDescriptor *a2)
{
  v2 = *(this + 106);
  if (v2 < 9)
  {
    s_programdesc_blend_table[v2](a2);
  }

  return HGNode::InitProgramDescriptor(this, a2);
}

uint64_t HGLegacyBlend::BindTexture(HGLegacyBlend *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(**(a2 + 18) + 128))(*(a2 + 18), 46))
  {
    (*(*a2 + 168))(a2);
  }

  return 0;
}

uint64_t GetHGBlendNormalTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v38 = 0;
        v39 = 16 * v9;
        v40 = 16 * v8;
        v41 = 16 * v7;
        v42 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v43 = 0;
          do
          {
            v44 = vmulq_f32(v5[v43 / 0x10], *a2);
            v6[v43 / 0x10] = vaddq_f32(v44, vmulq_f32(v4[v43 / 0x10], vsubq_f32(a2[3], vdupq_laneq_s32(v44, 3))));
            v43 += 16;
          }

          while (v42 != v43);
          ++v38;
          v4 = (v4 + v39);
          v5 = (v5 + v40);
          v6 = (v6 + v41);
        }

        while (v38 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = a2[3];
          v30 = vaddq_f32(v26, vmulq_f32(v4[v17 + 1], vsubq_f32(v29, vdupq_laneq_s32(v26, 3))));
          v31 = vaddq_f32(v27, vmulq_f32(v4[v17 + 2], vsubq_f32(v29, vdupq_laneq_s32(v27, 3))));
          v32 = vaddq_f32(v28, vmulq_f32(v4[v17 + 3], vsubq_f32(v29, vdupq_laneq_s32(v28, 3))));
          v33 = &v6[v17];
          *v33 = vaddq_f32(v25, vmulq_f32(v4[v17], vsubq_f32(v29, vdupq_laneq_s32(v25, 3))));
          v33[1] = v30;
          v18 += 4;
          v17 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v34 = *v22++;
            v35 = v34;
            v36 = *v23++;
            v37 = vmulq_f32(v36, *a2);
            *v24++ = vaddq_f32(v37, vmulq_f32(v35, vsubq_f32(a2[3], vdupq_laneq_s32(v37, 3))));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendAddTile(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v45 = 0;
        v46 = 16 * v9;
        v47 = 16 * v8;
        v48 = 16 * v7;
        v49 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v50 = 0;
          do
          {
            v51 = v4[v50 / 0x10];
            v52 = vmulq_f32(v5[v50 / 0x10], *a2);
            v53 = vaddq_f32(v51, v52);
            v6[v50 / 0x10] = vbslq_s8(*(a2 + 64), vsubq_f32(v53, vmulq_f32(v51, v52)), v53);
            v50 += 16;
          }

          while (v49 != v50);
          ++v45;
          v4 = (v4 + v46);
          v5 = (v5 + v47);
          v6 = (v6 + v48);
        }

        while (v45 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = v4[v17];
          v26 = v4[v17 + 1];
          v27 = v4[v17 + 2];
          v28 = v4[v17 + 3];
          v29 = vmulq_f32(v5[v17], *a2);
          v30 = vmulq_f32(v5[v17 + 1], *a2);
          v31 = vmulq_f32(v5[v17 + 2], *a2);
          v32 = vmulq_f32(v5[v17 + 3], *a2);
          v33 = vaddq_f32(v25, v29);
          v34 = vaddq_f32(v26, v30);
          v35 = vaddq_f32(v27, v31);
          v36 = vaddq_f32(v28, v32);
          v37 = vsubq_f32(v33, vmulq_f32(v25, v29));
          v38 = *(a2 + 64);
          v39 = &v6[v17];
          *v39 = vbslq_s8(v38, v37, v33);
          v39[1] = vbslq_s8(v38, vsubq_f32(v34, vmulq_f32(v26, v30)), v34);
          v18 += 4;
          v17 += 4;
          v39[2] = vbslq_s8(v38, vsubq_f32(v35, vmulq_f32(v27, v31)), v35);
          v39[3] = vbslq_s8(v38, vsubq_f32(v36, vmulq_f32(v28, v32)), v36);
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v40 = *v22++;
            v41 = v40;
            v42 = *v23++;
            v43 = vmulq_f32(v42, *a2);
            v44 = vaddq_f32(v41, v43);
            *v24++ = vbslq_s8(*(a2 + 64), vsubq_f32(v44, vmulq_f32(v41, v43)), v44);
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendBehindTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v33 = 0;
        v34 = 16 * v9;
        v35 = 16 * v8;
        v36 = 16 * v7;
        v37 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(v4[v38 / 0x10], vmulq_f32(vmulq_f32(v5[v38 / 0x10], *a2), vsubq_f32(a2[3], vdupq_laneq_s32(v4[v38 / 0x10], 3))));
            v38 += 16;
          }

          while (v37 != v38);
          ++v33;
          v4 = (v4 + v34);
          v5 = (v5 + v35);
          v6 = (v6 + v36);
        }

        while (v33 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = a2[3];
          v26 = vaddq_f32(v4[v17 + 1], vmulq_f32(vmulq_f32(v5[v17 + 1], *a2), vsubq_f32(v25, vdupq_laneq_s32(v4[v17 + 1], 3))));
          v27 = vaddq_f32(v4[v17 + 2], vmulq_f32(vmulq_f32(v5[v17 + 2], *a2), vsubq_f32(v25, vdupq_laneq_s32(v4[v17 + 2], 3))));
          v28 = vaddq_f32(v4[v17 + 3], vmulq_f32(vmulq_f32(v5[v17 + 3], *a2), vsubq_f32(v25, vdupq_laneq_s32(v4[v17 + 3], 3))));
          v29 = &v6[v17];
          *v29 = vaddq_f32(v4[v17], vmulq_f32(vmulq_f32(v5[v17], *a2), vsubq_f32(v25, vdupq_laneq_s32(v4[v17], 3))));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v30 = *v22++;
            v31 = v30;
            v32 = *v23++;
            *v24++ = vaddq_f32(v31, vmulq_f32(vmulq_f32(v32, *a2), vsubq_f32(a2[3], vdupq_laneq_s32(v31, 3))));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendDarkenTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 3)
    {
      if (v3 >= 1)
      {
        v46 = 0;
        v47 = 16 * v9;
        v48 = 16 * v8;
        v49 = 16 * v7;
        v50 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v51 = 0;
          do
          {
            v52 = v4[v51 / 0x10];
            v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            v54 = vmulq_laneq_f32(v53, v52, 3);
            v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vminq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }

          while (v50 != v51);
          ++v46;
          v4 = (v4 + v47);
          v5 = (v5 + v48);
          v6 = (v6 + v49);
        }

        while (v46 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 3;
      v15 = v5 + 3;
      v16 = v6 + 3;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = 3;
        v20 = v16;
        v21 = v15;
        v22 = v14;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v19;
          v27 = v4[v17];
          v28 = v4[v17 + 1];
          v29 = v4[v17 + 2];
          v30 = vmulq_f32(v5[v17], *a2);
          v31 = vmulq_f32(v5[v17 + 1], *a2);
          v32 = vmulq_f32(v5[v17 + 2], *a2);
          v33 = vmulq_laneq_f32(v30, v27, 3);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v27, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *v39 = vaddq_f32(vminq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vminq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vminq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          v19 = v26 + 3;
        }

        while (v18 < v3 - 2);
        if (v3 > v18)
        {
          do
          {
            v40 = *v23++;
            v41 = v40;
            v42 = *v24++;
            v43 = vmulq_f32(v42, *a2);
            v44 = vmulq_laneq_f32(v43, v41, 3);
            v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vminq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }

          while (v3 > v26);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendDifferenceTile(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v54 = 0;
        v55 = 16 * v9;
        v56 = 16 * v8;
        v57 = 16 * v7;
        v58 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v59 = 0;
          do
          {
            v60 = v4[v59 / 0x10];
            v61 = vmulq_f32(v5[v59 / 0x10], *a2);
            v62 = vmulq_laneq_f32(v61, v60, 3);
            v63 = vmulq_laneq_f32(v60, v61, 3);
            v64 = vsubq_f32(vaddq_f32(v60, v61), v62);
            v6[v59 / 0x10] = vaddq_f32(vabdq_f32(v62, v63), vbslq_s8(*(a2 + 64), v64, vsubq_f32(v64, v63)));
            v59 += 16;
          }

          while (v58 != v59);
          ++v54;
          v4 = (v4 + v55);
          v5 = (v5 + v56);
          v6 = (v6 + v57);
        }

        while (v54 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = v4[v17];
          v26 = v4[v17 + 1];
          v27 = v4[v17 + 2];
          v28 = v4[v17 + 3];
          v29 = vmulq_f32(v5[v17], *a2);
          v30 = vmulq_f32(v5[v17 + 1], *a2);
          v31 = vmulq_f32(v5[v17 + 2], *a2);
          v32 = vmulq_f32(v5[v17 + 3], *a2);
          v33 = vmulq_laneq_f32(v29, v25, 3);
          v34 = vmulq_laneq_f32(v30, v26, 3);
          v35 = vmulq_laneq_f32(v31, v27, 3);
          v36 = vmulq_laneq_f32(v32, v28, 3);
          v37 = vmulq_laneq_f32(v25, v29, 3);
          v38 = vmulq_laneq_f32(v26, v30, 3);
          v39 = vmulq_laneq_f32(v27, v31, 3);
          v40 = vmulq_laneq_f32(v28, v32, 3);
          v41 = vsubq_f32(vaddq_f32(v25, v29), v33);
          v42 = vsubq_f32(vaddq_f32(v26, v30), v34);
          v43 = vsubq_f32(vaddq_f32(v27, v31), v35);
          v44 = vsubq_f32(vaddq_f32(v28, v32), v36);
          v45 = *(a2 + 64);
          v46 = &v6[v17];
          *v46 = vaddq_f32(vabdq_f32(v33, v37), vbslq_s8(v45, v41, vsubq_f32(v41, v37)));
          v46[1] = vaddq_f32(vabdq_f32(v34, v38), vbslq_s8(v45, v42, vsubq_f32(v42, v38)));
          v18 += 4;
          v17 += 4;
          v46[2] = vaddq_f32(vabdq_f32(v35, v39), vbslq_s8(v45, v43, vsubq_f32(v43, v39)));
          v46[3] = vaddq_f32(vabdq_f32(v36, v40), vbslq_s8(v45, v44, vsubq_f32(v44, v40)));
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v47 = *v22++;
            v48 = v47;
            v49 = *v23++;
            v50 = vmulq_f32(v49, *a2);
            v51 = vmulq_laneq_f32(v50, v48, 3);
            v52 = vmulq_laneq_f32(v48, v50, 3);
            v53 = vsubq_f32(vaddq_f32(v48, v50), v51);
            *v24++ = vaddq_f32(vabdq_f32(v51, v52), vbslq_s8(*(a2 + 64), v53, vsubq_f32(v53, v52)));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendLightenTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 3)
    {
      if (v3 >= 1)
      {
        v46 = 0;
        v47 = 16 * v9;
        v48 = 16 * v8;
        v49 = 16 * v7;
        v50 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v51 = 0;
          do
          {
            v52 = v4[v51 / 0x10];
            v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            v54 = vmulq_laneq_f32(v53, v52, 3);
            v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vmaxq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }

          while (v50 != v51);
          ++v46;
          v4 = (v4 + v47);
          v5 = (v5 + v48);
          v6 = (v6 + v49);
        }

        while (v46 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 3;
      v15 = v5 + 3;
      v16 = v6 + 3;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = 3;
        v20 = v16;
        v21 = v15;
        v22 = v14;
        do
        {
          v23 = v22;
          v24 = v21;
          v25 = v20;
          v26 = v19;
          v27 = v4[v17];
          v28 = v4[v17 + 1];
          v29 = v4[v17 + 2];
          v30 = vmulq_f32(v5[v17], *a2);
          v31 = vmulq_f32(v5[v17 + 1], *a2);
          v32 = vmulq_f32(v5[v17 + 2], *a2);
          v33 = vmulq_laneq_f32(v30, v27, 3);
          v34 = vmulq_laneq_f32(v31, v28, 3);
          v35 = vmulq_laneq_f32(v32, v29, 3);
          v36 = vmulq_laneq_f32(v27, v30, 3);
          v37 = vmulq_laneq_f32(v28, v31, 3);
          v38 = vmulq_laneq_f32(v29, v32, 3);
          v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *v39 = vaddq_f32(vmaxq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vmaxq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vmaxq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          v19 = v26 + 3;
        }

        while (v18 < v3 - 2);
        if (v3 > v18)
        {
          do
          {
            v40 = *v23++;
            v41 = v40;
            v42 = *v24++;
            v43 = vmulq_f32(v42, *a2);
            v44 = vmulq_laneq_f32(v43, v41, 3);
            v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vmaxq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }

          while (v3 > v26);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendMultiplyTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v37 = 0;
        v38 = 16 * v9;
        v39 = 16 * v8;
        v40 = 16 * v7;
        v41 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v42 = 0;
          do
          {
            v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vaddq_f32(vaddq_f32(vmulq_f32(v4[v42 / 0x10], v43), vsubq_f32(v43, vmulq_laneq_f32(v43, v4[v42 / 0x10], 3))), vsubq_f32(v4[v42 / 0x10], vmulq_laneq_f32(v4[v42 / 0x10], v43, 3)));
            v42 += 16;
          }

          while (v41 != v42);
          ++v37;
          v4 = (v4 + v38);
          v5 = (v5 + v39);
          v6 = (v6 + v40);
        }

        while (v37 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 1], v26), vsubq_f32(v26, vmulq_laneq_f32(v26, v4[v17 + 1], 3))), vsubq_f32(v4[v17 + 1], vmulq_laneq_f32(v4[v17 + 1], v26, 3)));
          v30 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 2], v27), vsubq_f32(v27, vmulq_laneq_f32(v27, v4[v17 + 2], 3))), vsubq_f32(v4[v17 + 2], vmulq_laneq_f32(v4[v17 + 2], v27, 3)));
          v31 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 3], v28), vsubq_f32(v28, vmulq_laneq_f32(v28, v4[v17 + 3], 3))), vsubq_f32(v4[v17 + 3], vmulq_laneq_f32(v4[v17 + 3], v28, 3)));
          v32 = &v6[v17];
          *v32 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17], v25), vsubq_f32(v25, vmulq_laneq_f32(v25, v4[v17], 3))), vsubq_f32(v4[v17], vmulq_laneq_f32(v4[v17], v25, 3)));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v33 = *v22++;
            v34 = v33;
            v35 = *v23++;
            v36 = vmulq_f32(v35, *a2);
            *v24++ = vaddq_f32(vaddq_f32(vmulq_f32(v34, v36), vsubq_f32(v36, vmulq_laneq_f32(v36, v34, 3))), vsubq_f32(v34, vmulq_laneq_f32(v34, v36, 3)));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendScreenTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v37 = 0;
        v38 = 16 * v9;
        v39 = 16 * v8;
        v40 = 16 * v7;
        v41 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v42 = 0;
          do
          {
            v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vsubq_f32(vaddq_f32(v4[v42 / 0x10], v43), vminq_f32(vminq_f32(vmulq_f32(v4[v42 / 0x10], v43), v43), v4[v42 / 0x10]));
            v42 += 16;
          }

          while (v41 != v42);
          ++v37;
          v4 = (v4 + v38);
          v5 = (v5 + v39);
          v6 = (v6 + v40);
        }

        while (v37 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vmulq_f32(v5[v17], *a2);
          v26 = vmulq_f32(v5[v17 + 1], *a2);
          v27 = vmulq_f32(v5[v17 + 2], *a2);
          v28 = vmulq_f32(v5[v17 + 3], *a2);
          v29 = vsubq_f32(vaddq_f32(v4[v17 + 1], v26), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 1], v26), v26), v4[v17 + 1]));
          v30 = vsubq_f32(vaddq_f32(v4[v17 + 2], v27), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 2], v27), v27), v4[v17 + 2]));
          v31 = vsubq_f32(vaddq_f32(v4[v17 + 3], v28), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 3], v28), v28), v4[v17 + 3]));
          v32 = &v6[v17];
          *v32 = vsubq_f32(vaddq_f32(v4[v17], v25), vminq_f32(vminq_f32(vmulq_f32(v4[v17], v25), v25), v4[v17]));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v33 = *v22++;
            v34 = v33;
            v35 = *v23++;
            v36 = vmulq_f32(v35, *a2);
            *v24++ = vsubq_f32(vaddq_f32(v34, v36), vminq_f32(vminq_f32(vmulq_f32(v34, v36), v36), v34));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

uint64_t GetHGBlendDissolveTile(uint64_t a1, float32x4_t *a2)
{
  v2 = *(a1 + 12) - *(a1 + 4);
  if (v2 >= 1)
  {
    v3 = (*(a1 + 8) - *a1);
    v4 = *(a1 + 80);
    v5 = *(a1 + 96);
    v6 = *(a1 + 16);
    v7 = *(a1 + 24);
    v8 = *(a1 + 104);
    v9 = *(a1 + 88);
    if (v3 < 4)
    {
      if (v3 >= 1)
      {
        v32 = 0;
        v33 = 16 * v9;
        v34 = 16 * v8;
        v35 = 16 * v7;
        v36 = 16 * (*(a1 + 8) - *a1);
        do
        {
          v37 = 0;
          do
          {
            v6[v37 / 0x10] = vaddq_f32(v4[v37 / 0x10], vmulq_f32(*a2, vsubq_f32(v5[v37 / 0x10], v4[v37 / 0x10])));
            v37 += 16;
          }

          while (v36 != v37);
          ++v32;
          v4 = (v4 + v33);
          v5 = (v5 + v34);
          v6 = (v6 + v35);
        }

        while (v32 != v2);
      }
    }

    else
    {
      v10 = 0;
      v11 = 16 * v8;
      v12 = 16 * v7;
      v13 = 16 * v9;
      v14 = v4 + 4;
      v15 = v5 + 4;
      v16 = v6 + 4;
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = v16;
        v20 = v15;
        v21 = v14;
        do
        {
          v22 = v21;
          v23 = v20;
          v24 = v19;
          v25 = vaddq_f32(v4[v17 + 1], vmulq_f32(vsubq_f32(v5[v17 + 1], v4[v17 + 1]), *a2));
          v26 = vaddq_f32(v4[v17 + 2], vmulq_f32(vsubq_f32(v5[v17 + 2], v4[v17 + 2]), *a2));
          v27 = vaddq_f32(v4[v17 + 3], vmulq_f32(*a2, vsubq_f32(v5[v17 + 3], v4[v17 + 3])));
          v28 = &v6[v17];
          *v28 = vaddq_f32(v4[v17], vmulq_f32(vsubq_f32(v5[v17], v4[v17]), *a2));
          v28[1] = v25;
          v18 += 4;
          v17 += 4;
          v28[2] = v26;
          v28[3] = v27;
          v21 += 4;
          v20 += 4;
          v19 = v24 + 4;
        }

        while (v18 < (v3 - 3));
        if (v3 > v18)
        {
          do
          {
            v29 = *v22++;
            v30 = v29;
            v31 = *v23++;
            *v24++ = vaddq_f32(v30, vmulq_f32(*a2, vsubq_f32(v31, v30)));
            ++v18;
          }

          while (v18 < v3);
        }

        ++v10;
        v5 = (v5 + v11);
        v6 = (v6 + v12);
        v4 = (v4 + v13);
        v14 = (v14 + v13);
        v15 = (v15 + v11);
        v16 = (v16 + v12);
      }

      while (v10 != v2);
    }
  }

  return 0;
}

const char *GetHGBlendNormalProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000037c\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = c0.xxxx - r1.wwww;\n    output.color0 = float4(r0)*float4(r2) + float4(r1);\n    return output;\n}\n//MD5=a17166cb:4ae482ef:781fc3b7:6143d1a9\n//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000352\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = c0.xxxx - r1.wwww;\n    output.color0 = r0*r2 + r1;\n    return output;\n}\n//MD5=72391b35:a8654f9f:aaa4f0df:bd71ee76\n//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000301\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    defaultp vec4 r0, r1, r2;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = c0.xxxx - r1.wwww;\n    gl_FragColor = r0*r2 + r1;\n}\n//MD5=542a3d1f:8a8f31c6:53e2357c:1b7afc62\n//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendAddProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000328\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = r1 + r0;\n    r2.w = -r1.w*r0.w + r2.w;\n    output.color0 = float4(r2);\n    return output;\n}\n//MD5=d59c4393:5faec818:b66c0166:a5b8df3a\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=000000030c\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = r1 + r0;\n    r2.w = -r1.w*r0.w + r2.w;\n    output.color0 = r2;\n    return output;\n}\n//MD5=2ed547af:707bae93:26dfb645:16dfb2b5\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=00000002b6\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = r1 + r0;\n    r2.w = -r1.w*r0.w + r2.w;\n    gl_FragColor = r2;\n}\n//MD5=c7321b02:0ada01d2:252b971a:900e277b\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendBehindProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000037c\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    half4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = c0.xxxx - r0.wwww;\n    output.color0 = float4(r1)*float4(r2) + float4(r0);\n    return output;\n}\n//MD5=c58d73cf:5abaf669:0ed24989:47f4d1f7\n//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000352\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    float4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = c0.xxxx - r0.wwww;\n    output.color0 = r1*r2 + r0;\n    return output;\n}\n//MD5=02fd7083:75fd7153:81b391cd:51351952\n//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000301\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n    defaultp vec4 r0, r1, r2;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = c0.xxxx - r0.wwww;\n    gl_FragColor = r1*r2 + r0;\n}\n//MD5=82fdf0d8:1de86e49:9e296160:488420c6\n//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDarkenProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000384\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2, r3, r4;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = fmin(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    output.color0 = float4(r1) + float4(r4);\n    return output;\n}\n//MD5=c27f10d4:1c0c8ccb:86556908:22917918\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000360\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2, r3, r4;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = fmin(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    output.color0 = r1 + r4;\n    return output;\n}\n//MD5=fdd9d0ee:dddc8b61:10b27a4f:f7a7aa8e\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000309\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2, r3, r4;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = min(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    gl_FragColor = r1 + r4;\n}\n//MD5=c6b1e65f:1950bd8f:9345f58d:ea3a6afc\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDifferenceProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000038d\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r1 = r1 + r0;\n    r0 = r2 - r3;\n    r1 = r1 - r2;\n    r1.xyz = r1.xyz - r3.xyz;\n    output.color0 = float4(r1) + float4(fabs(r0));\n    return output;\n}\n//MD5=28640d6b:a7f4cbd7:1398d5ad:4f2b97e5\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000369\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r1 = r1 + r0;\n    r0 = r2 - r3;\n    r1 = r1 - r2;\n    r1.xyz = r1.xyz - r3.xyz;\n    output.color0 = r1 + fabs(r0);\n    return output;\n}\n//MD5=78eeb002:cd99131f:366f4560:2b2f0811\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000312\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r1 = r1 + r0;\n    r0 = r2 - r3;\n    r1 = r1 - r2;\n    r1.xyz = r1.xyz - r3.xyz;\n    gl_FragColor = r1 + abs(r0);\n}\n//MD5=167e3881:cda035d5:2b7bb7d9:07a634d1\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendLightenProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000384\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2, r3, r4;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = fmax(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    output.color0 = float4(r1) + float4(r4);\n    return output;\n}\n//MD5=255abd10:393d4261:149de1f9:66e2ba1d\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000360\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2, r3, r4;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = fmax(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    output.color0 = r1 + r4;\n    return output;\n}\n//MD5=a08d3b39:c090c511:0017968a:c922b48e\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000309\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2, r3, r4;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = r1*r0.wwww;\n    r3 = r0*r1.wwww;\n    r4 = max(r2, r3);\n    r1 = r1 + r0;\n    r1 = r1 - r2;\n    r1 = r1 - r3;\n    gl_FragColor = r1 + r4;\n}\n//MD5=10f025ae:65373697:69030409:e5173d3b\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendMultiplyProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000354\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = -r1*r0.wwww + r1;\n    r3 = -r0*r1.wwww + r0;\n    r1 = r1*r0 + r2;\n    output.color0 = float4(r1) + float4(r3);\n    return output;\n}\n//MD5=7ab80faf:802a2960:6882b435:6d1cc9dc\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000330\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2, r3;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = -r1*r0.wwww + r1;\n    r3 = -r0*r1.wwww + r0;\n    r1 = r1*r0 + r2;\n    output.color0 = r1 + r3;\n    return output;\n}\n//MD5=d348d950:6657c859:55f8ae41:7b9824a8\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=00000002da\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2, r3;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = -r1*r0.wwww + r1;\n    r3 = -r0*r1.wwww + r0;\n    r1 = r1*r0 + r2;\n    gl_FragColor = r1 + r3;\n}\n//MD5=f723a021:2cc26bfb:5b7402aa:6e437a60\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendScreenProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000355\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*half4(hg_Params[0]);\n    r2 = r1*r0;\n    r2 = fmin(r2, r1);\n    r2 = fmin(r2, r0);\n    r1 = r1 + r0;\n    output.color0 = float4(r1) - float4(r2);\n    return output;\n}\n//MD5=9771d01d:626a2747:a548b6f1:28e1d417\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000331\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1, r2;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    r1 = r1*hg_Params[0];\n    r2 = r1*r0;\n    r2 = fmin(r2, r1);\n    r2 = fmin(r2, r0);\n    r1 = r1 + r0;\n    output.color0 = r1 - r2;\n    return output;\n}\n//MD5=31490d41:d9f1dc14:0dca0a9a:b384361c\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=00000002d9\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1, r2;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    r1 = r1*hg_ProgramLocal0;\n    r2 = r1*r0;\n    r2 = min(r2, r1);\n    r2 = min(r2, r0);\n    r1 = r1 + r0;\n    gl_FragColor = r1 - r2;\n}\n//MD5=8190ca66:f656822d:4e06b98f:6e1ba269\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDissolveProgram(HGRenderer *a1)
{
  Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(*a1 + 128))(a1, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=00000002f2\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< half > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    half4 r0, r1;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    output.color0 = mix(float4(r0), float4(r1), hg_Params[0]);\n    return output;\n}\n//MD5=71e089ca:82dc604d:921d323b:8c63d522\n//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=00000002d5\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]], \n    texture2d< float > hg_Texture1 [[ texture(1) ]], \n    sampler hg_Sampler1 [[ sampler(1) ]])\n{\n    float4 r0, r1;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n    output.color0 = mix(r0, r1, hg_Params[0]);\n    return output;\n}\n//MD5=19049a07:c1b7d36e:88d051c2:edb06ce9\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a1 + 128))(a1, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=000000027f\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp sampler2D hg_Texture1;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    defaultp vec4 r0, r1;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n    gl_FragColor = mix(r0, r1, hg_ProgramLocal0);\n}\n//MD5=e59d54b8:dcfffceb:e9177f14:9c43910d\n//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void sub_25FD4E7D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4E804(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4E7FCLL);
}

void sub_25FD4EAA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4EAD4(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4EACCLL);
}

void sub_25FD4ED70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4EDA4(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4ED9CLL);
}

void sub_25FD4F040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4F074(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4F06CLL);
}

void sub_25FD4F310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4F344(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4F33CLL);
}

void sub_25FD4F5E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4F614(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4F60CLL);
}

void sub_25FD4F8B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4F8E4(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4F8DCLL);
}

void sub_25FD4FB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4FBB4(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4FBACLL);
}

void sub_25FD4FE50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD4FE84(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD4FE7CLL);
}

uint64_t HGColorMatrix::RenderTile(HGColorMatrix *this, HGTile *a2)
{
  v4 = HGGetTBC();
  if (!(*(**(*(a2 + 42) + 152) + 128))(*(*(a2 + 42) + 152), 28))
  {
    v6 = *(a2 + 3) - *(a2 + 1);
    if (v6 >= 1)
    {
      v7 = *(this + 52);
      v8 = (*(a2 + 2) - *a2);
      v9 = *(a2 + 10);
      v10 = *(a2 + 2);
      v11 = *(a2 + 6);
      v12 = *(a2 + 22);
      if (v8 < 4)
      {
        if (v8 >= 1)
        {
          v37 = 0;
          v38 = 16 * (*(a2 + 2) - *a2);
          v39 = 16 * v11;
          v40 = 16 * v12;
          do
          {
            v41 = 0;
            do
            {
              v10[v41 / 0x10] = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, COERCE_FLOAT(*&v9[v41 / 0x10])), vmulq_lane_f32(v7[1], *v9[v41 / 0x10].f32, 1)), vmulq_laneq_f32(v7[2], v9[v41 / 0x10], 2)), vmulq_laneq_f32(v7[3], v9[v41 / 0x10], 3));
              v41 += 16;
            }

            while (v38 != v41);
            ++v37;
            v10 = (v10 + v39);
            v9 = (v9 + v40);
          }

          while (v37 != v6);
        }
      }

      else
      {
        v13 = 0;
        v14 = 16 * v12;
        v15 = 16 * v11;
        v16 = v10 + 4;
        v17 = v9 + 4;
        do
        {
          v18 = 0;
          v19 = v17;
          v20 = v16;
          v21 = 3;
          do
          {
            v22 = v9[v21 - 3];
            v23 = v9[v21 - 2];
            v24 = v9[v21 - 1];
            v25 = v9[v21];
            v26 = v7[1];
            v27 = vaddq_f32(vmulq_n_f32(*v7, v22.f32[0]), vmulq_lane_f32(v26, *v22.f32, 1));
            v28 = vaddq_f32(vmulq_n_f32(*v7, v23.f32[0]), vmulq_lane_f32(v26, *v23.f32, 1));
            v29 = vaddq_f32(vmulq_n_f32(*v7, v24.f32[0]), vmulq_lane_f32(v26, *v24.f32, 1));
            v30 = vaddq_f32(vmulq_n_f32(*v7, v25.f32[0]), vmulq_lane_f32(v26, *v25.f32, 1));
            v31 = v7[2];
            v32 = v7[3];
            v33 = v20;
            v34 = v19;
            v35 = &v10[v21];
            v35[-3] = vaddq_f32(vaddq_f32(v27, vmulq_laneq_f32(v31, v22, 2)), vmulq_laneq_f32(v32, v22, 3));
            v35[-2] = vaddq_f32(vaddq_f32(v28, vmulq_laneq_f32(v31, v23, 2)), vmulq_laneq_f32(v32, v23, 3));
            v18 += 4;
            v35[-1] = vaddq_f32(vaddq_f32(v29, vmulq_laneq_f32(v31, v24, 2)), vmulq_laneq_f32(v32, v24, 3));
            *v35 = vaddq_f32(vaddq_f32(v30, vmulq_laneq_f32(v31, v25, 2)), vmulq_laneq_f32(v32, v25, 3));
            v21 += 4;
            v20 += 4;
            v19 = v34 + 4;
          }

          while (v18 < (v8 - 3));
          if (v8 > v18)
          {
            do
            {
              v36 = *v34++;
              *v33++ = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, v36.f32[0]), vmulq_lane_f32(v7[1], *v36.f32, 1)), vmulq_laneq_f32(v7[2], v36, 2)), vmulq_laneq_f32(v7[3], v36, 3));
              ++v18;
            }

            while (v18 < v8);
          }

          ++v13;
          v9 = (v9 + v14);
          v10 = (v10 + v15);
          v16 = (v16 + v15);
          v17 = (v17 + v14);
        }

        while (v13 != v6);
      }
    }
  }

  *(*(*(a2 + 42) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGColorMatrix::GetProgram(HGColorMatrix *this, HGRenderer *a2)
{
  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(*a2 + 128))(a2, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=00000002dd\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    half4 r0;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    output.color0.x = dot(hg_Params[0], float4(r0));\n    output.color0.y = dot(hg_Params[1], float4(r0));\n    output.color0.z = dot(hg_Params[2], float4(r0));\n    output.color0.w = dot(hg_Params[3], float4(r0));\n    return output;\n}\n//MD5=72217420:491e0715:a85d6da8:94aef8d2\n//SIG=00400000:00000001:00000001:00000001:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=00000002b7\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    float4 r0;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    output.color0.x = dot(hg_Params[0], r0);\n    output.color0.y = dot(hg_Params[1], r0);\n    output.color0.z = dot(hg_Params[2], r0);\n    output.color0.w = dot(hg_Params[3], r0);\n    return output;\n}\n//MD5=f59a11f6:3c3dcb91:f1061cc0:3190f271\n//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a2 + 128))(a2, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=0000000306\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp vec4 hg_ProgramLocal0;\nuniform defaultp vec4 hg_ProgramLocal1;\nuniform defaultp vec4 hg_ProgramLocal2;\nuniform defaultp vec4 hg_ProgramLocal3;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    defaultp vec4 r0;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    gl_FragColor.x = dot(hg_ProgramLocal0, r0);\n    gl_FragColor.y = dot(hg_ProgramLocal1, r0);\n    gl_FragColor.z = dot(hg_ProgramLocal2, r0);\n    gl_FragColor.w = dot(hg_ProgramLocal3, r0);\n}\n//MD5=8fc18786:e8a829e3:4774e200:4d62edae\n//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void sub_25FD503DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD5040C(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD50404);
}

uint64_t HGColorMatrix::RenderFragment(float32x4_t *a1, float32x4_t *a2, HGTile *this)
{
  v6 = HGTile::Renderer(this);
  v7 = (*(*v6 + 128))(v6, 23);
  *v8.f32 = vadd_f32(vcvt_f32_s32(*this), 0x3F0000003F000000);
  v8.i64[1] = 0x3F80000000000000;
  v9 = *(this + 10);
  v10 = *(this + 22);
  v11 = vsubq_f32(a2[1], v8);
  if (v7)
  {
    v12 = vaddq_s32(vcvtq_s32_f32(v11), vcltzq_f32(v11));
    v13 = vsubq_f32(v11, vcvtq_f32_s32(v12)).u64[0];
    v14 = (v9 + 16 * (v12.i32[0] + v12.i32[1] * v10));
    v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v13.f32[0]));
    v16 = vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v10], vmulq_n_f32(vsubq_f32(v14[v10 + 1], v14[v10]), v13.f32[0])), v15), v13, 1));
  }

  else
  {
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    v18 = vaddq_f32(v11, v17);
    v19 = vcvtq_s32_f32(v18);
    v18.i64[0] = vaddq_s32(v19, vcgtq_f32(vcvtq_f32_s32(v19), v18)).u64[0];
    v16 = *(v9 + 16 * (v18.i32[0] + v18.i32[1] * v10));
  }

  **(this + 2) = vaddq_f32(vmulq_laneq_f32(a1[30], v16, 3), vaddq_f32(vmulq_laneq_f32(a1[29], v16, 2), vaddq_f32(vmulq_n_f32(a1[27], v16.f32[0]), vmulq_lane_f32(a1[28], *v16.f32, 1))));
  return 0;
}

uint64_t HGColorMatrix::Bind(HGColorMatrix *this, HGHandler *a2)
{
  (*(*a2 + 136))(a2, 0, *(this + 108), *(this + 112), *(this + 116), *(this + 120));
  (*(*a2 + 136))(a2, 1, *(this + 109), *(this + 113), *(this + 117), *(this + 121));
  (*(*a2 + 136))(a2, 2, *(this + 110), *(this + 114), *(this + 118), *(this + 122));
  (*(*a2 + 136))(a2, 3, *(this + 111), *(this + 115), *(this + 119), *(this + 123));
  return 0;
}

uint64_t HGColorMatrix::BindTexture(HGColorMatrix *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(**(a2 + 18) + 128))(*(a2 + 18), 46))
  {
    (*(*a2 + 168))(a2);
  }

  return 0;
}

void HGColorMatrix::HGColorMatrix(HGColorMatrix *this)
{
  HGNode3D::HGNode3D(this);
  *v1 = &unk_2872272A0;
  operator new();
}

{
  HGNode3D::HGNode3D(this);
  *v1 = &unk_2872272A0;
  operator new();
}

void HGColorMatrix::~HGColorMatrix(HGColorMatrix *this)
{
  *this = &unk_2872272A0;
  v2 = *(this + 51);
  if (v2)
  {
    (*(*v2 + 24))(v2);
  }

  v3 = *(this + 52);
  if (v3)
  {
    MEMORY[0x2666E9F00](v3, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  *this = &unk_2872272A0;
  v2 = *(this + 51);
  if (v2)
  {
    (*(*v2 + 24))(v2);
  }

  v3 = *(this + 52);
  if (v3)
  {
    MEMORY[0x2666E9F00](v3, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  *this = &unk_2872272A0;
  v2 = *(this + 51);
  if (v2)
  {
    (*(*v2 + 24))(v2);
  }

  v3 = *(this + 52);
  if (v3)
  {
    MEMORY[0x2666E9F00](v3, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);

  HGObject::operator delete(v4);
}

__n128 HGColorMatrix::ParameterizeMatrix(__n128 *this, HGRenderer *a2)
{
  *this[26].n128_u64[0] = this[27];
  *(this[26].n128_u64[0] + 16) = this[28];
  *(this[26].n128_u64[0] + 32) = this[29];
  result = this[30];
  *(this[26].n128_u64[0] + 48) = result;
  return result;
}

const char *HgcCropShaderBlend::GetProgram(HgcCropShaderBlend *this, HGRenderer *a2)
{
  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(*a2 + 128))(a2, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000037c\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    half4 r0;\n    float4 s0;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n    s0 = float4(s0 < float4(c0.xxxx));\n    s0 = float4(dot(s0, 1.00000f));\n    s0 = float4(s0 <= float4(c0.xxxx));\n    s0 = float4(r0)*s0;\n    output.color0 = s0*hg_Params[1];\n    return output;\n}\n//MD5=f9b56c77:153e25ee:692c907c:ff332280\n//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000355\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    float4 r0, r1;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n    r1 = float4(r1 < c0.xxxx);\n    r1 = float4(dot(r1, 1.00000f));\n    r1 = float4(r1 <= c0.xxxx);\n    r0 = r0*r1;\n    output.color0 = r0*hg_Params[1];\n    return output;\n}\n//MD5=71c0cb25:36879384:725a4797:f8967426\n//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a2 + 128))(a2, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=000000037c\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform highp vec4 hg_ProgramLocal0;\nuniform highp vec4 hg_ProgramLocal1;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    highp vec4 r0, r1;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n    r1 = vec4(lessThan(r1, c0.xxxx));\n    r1 = vec4(dot(r1, vec4(1.00000)));\n    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n    r0 = r0*r1;\n    gl_FragColor = r0*hg_ProgramLocal1;\n}\n//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void sub_25FD50E0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD50E40(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD50E38);
}

uint64_t HgcCropShaderBlend::BindTexture(HgcCropShaderBlend *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    return 0xFFFFFFFFLL;
  }

  (*(*a2 + 72))(a2, 0);
  (*(*a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(**(a2 + 18) + 128))(*(a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(*a2 + 168))(a2);
    return 0;
  }

  return result;
}

uint64_t HgcCropShaderBlend::Bind(HgcCropShaderBlend *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(*a2 + 144))(a2, 0, *(this + 51), 1);
  (*(*a2 + 144))(a2, 1, *(this + 51) + 16, 1);
  (*(*this + 192))(this, a2);
  return 0;
}

uint64_t HgcCropShaderBlend::GetDOD(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    return 0;
  }

  else
  {
    return *&a4.var0;
  }
}

uint64_t HgcCropShaderBlend::GetROI(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    return 0;
  }

  else
  {
    return *&a4.var0;
  }
}

void HgcCropShaderBlend::~HgcCropShaderBlend(HgcCropShaderBlend *this)
{
  *this = &unk_287227518;
  if (*(this + 51))
  {
    v2 = this;
    MEMORY[0x2666E9F00](*(this + 51), 0x1000C40E0EAB150);
    this = v2;
    v1 = vars8;
  }

  HGNode::~HGNode(this);
}

void HgcCropShaderBlend::~HgcCropShaderBlend(HGNode *this)
{
  *this = &unk_287227518;
  v2 = *(this + 51);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCropShaderBlend::SetParameter(HgcCropShaderBlend *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1)
  {
    return 0xFFFFFFFFLL;
  }

  v7 = (*(this + 51) + 16 * a2);
  if (*v7 == a3 && v7[1] == a4 && v7[2] == a5 && v7[3] == a6)
  {
    return 0;
  }

  *v7 = a3;
  v7[1] = a4;
  v7[2] = a5;
  v7[3] = a6;
  HGNode::ClearBits(this, a2, a7);
  return 1;
}

uint64_t HgcCropShaderBlend::GetParameter(HgcCropShaderBlend *this, unsigned int a2, float *a3)
{
  if (a2 > 1)
  {
    return 0xFFFFFFFFLL;
  }

  result = 0;
  v5 = (*(this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HGCropNode::SetParameter@<X0>(HGCropNode *this@<X0>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>, int a6@<W1>, uint64_t a7@<X8>)
{
  if (a6)
  {
    return 0xFFFFFFFFLL;
  }

  v9 = HGRectMake4f(a7, a2, a3, a4, a5);
  v11 = v10;
  if (HGRectIsEqual(v9, v10, *(this + 52), *(this + 53)))
  {
    return 0;
  }

  *(this + 52) = v9;
  *(this + 53) = v11;
  HGNode::ClearBits(this, v12, v13);
  return 1;
}

uint64_t HGCropNode::BindTexture(HGCropNode *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    return 0xFFFFFFFFLL;
  }

  (*(*a2 + 72))(a2, 0);
  (*(*a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(**(a2 + 18) + 128))(*(a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(*a2 + 168))(a2);
    return 0;
  }

  return result;
}

uint64_t HGCropNode::Bind(HGCropNode *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(*a2 + 136))(a2, 0, *(this + 104), *(this + 105), *(this + 106), *(this + 107));
  v4 = (*(*this + 288))(this);
  (*(*a2 + 136))(a2, 1, v4, *&v4, *&v4, *&v4);
  return 0;
}

uint64_t HGCropNode::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    return 0;
  }

  Input = HGRenderer::GetInput(a2, this, a3);
  DOD = HGRenderer::GetDOD(a2, Input);
  return HGRectIntersection(DOD, v9, *(this + 52), *(this + 53));
}

HGNode *HGCropNode::GetOutput(HGNode *this, HGRenderer *a2)
{
  v3 = this;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v7 = v6;
  v8 = HGRectIntersection(DOD, v6, *(v3 + 52), *(v3 + 53));
  if (Input && HGRectIsEqual(DOD, v7, v8, v9))
  {
    (*(*Input + 136))(Input, 0xFFFFFFFFLL, 32);
    return Input;
  }

  return v3;
}

uint64_t HGCropNode::RenderPage(HGNode *this, HGPage *a2)
{
  v4 = (*(*this + 168))(this, 23, 0);
  HGPagePullTexturesGuard::HGPagePullTexturesGuard(&v8, this, a2);
  v5 = *(a2 + 21);
  if (!v5 || !HGRectIsEqual(*(v5 + 20), *(v5 + 28), *(a2 + 2), *(a2 + 3)) || *(a2 + 1) || v4)
  {
    v6 = HGNode::RenderPage(this, a2);
  }

  else
  {
    (*(**(a2 + 21) + 16))(*(a2 + 21));
    v6 = *(a2 + 21);
  }

  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v8);
  return v6;
}

void sub_25FD51714(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(va);
  _Unwind_Resume(a1);
}

uint64_t HGCropNode::RenderPageMetal(HGNode *this, HGPage *a2)
{
  v4 = (*(*this + 168))(this, 23, 0);
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard(&v8, this, a2);
  v5 = *(a2 + 21);
  if (!v5 || !HGRectIsEqual(*(v5 + 20), *(v5 + 28), *(a2 + 2), *(a2 + 3)) || *(a2 + 1) || v4)
  {
    v6 = HGNode::RenderPageMetal(this, a2);
  }

  else
  {
    (*(**(a2 + 21) + 16))(*(a2 + 21));
    v6 = *(a2 + 21);
  }

  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v8);
  return v6;
}

void sub_25FD51810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(va);
  _Unwind_Resume(a1);
}

const char *HGCropNode::GetProgram(HGCropNode *this, HGRenderer *a2)
{
  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(*a2 + 128))(a2, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=000000037c\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    half4 r0;\n    float4 s0;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n    s0 = float4(s0 < float4(c0.xxxx));\n    s0 = float4(dot(s0, 1.00000f));\n    s0 = float4(s0 <= float4(c0.xxxx));\n    s0 = float4(r0)*s0;\n    output.color0 = s0*hg_Params[1];\n    return output;\n}\n//MD5=f9b56c77:153e25ee:692c907c:ff332280\n//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000355\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    float4 r0, r1;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n    r1 = float4(r1 < c0.xxxx);\n    r1 = float4(dot(r1, 1.00000f));\n    r1 = float4(r1 <= c0.xxxx);\n    r0 = r0*r1;\n    output.color0 = r0*hg_Params[1];\n    return output;\n}\n//MD5=71c0cb25:36879384:725a4797:f8967426\n//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    }
  }

  else if (Target <= 0x6060F || (*(*a2 + 128))(a2, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=000000037c\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform highp vec4 hg_ProgramLocal0;\nuniform highp vec4 hg_ProgramLocal1;\nvarying highp vec4 hg_TexCoord0;\nvarying highp vec4 hg_TexCoord1;\nvoid main()\n{\n    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n    highp vec4 r0, r1;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n    r1 = vec4(lessThan(r1, c0.xxxx));\n    r1 = vec4(dot(r1, vec4(1.00000)));\n    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n    r0 = r0*r1;\n    gl_FragColor = r0*hg_ProgramLocal1;\n}\n//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HGCrop::HGCrop(HGCrop *this)
{
  HGNode::HGNode(this);
  *v1 = &unk_287227768;
  v1[51] = 0;
  v2 = HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v2);
  *v2 = &unk_287227518;
  operator new();
}

void sub_25FD51A3C(_Unwind_Exception *a1)
{
  (*(*v2 + 24))(v2);
  v4 = *(v1 + 408);
  if (v4)
  {
    (*(*v4 + 24))(v4);
  }

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

uint64_t HGCrop::GetOutput(HGNode *this, HGRenderer *a2)
{
  v3 = *(this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(*v3 + 120))(v3, 0, Input);
  v5 = *(this + 51);
  v6 = (*(*this + 152))(this, 0);
  (*(*v5 + 136))(v5, 0, v6);
  v7 = *(this + 51);
  v8 = (*(*this + 152))(this, 0xFFFFFFFFLL);
  (*(*v7 + 136))(v7, 0xFFFFFFFFLL, v8);
  return *(this + 51);
}

void HGCrop::~HGCrop(HGCrop *this)
{
  *this = &unk_287227768;
  v1 = *(this + 51);
  if (v1)
  {
    v2 = this;
    (*(*v1 + 24))(*(this + 51));
    this = v2;
  }

  HGNode::~HGNode(this);
}

void HGCrop::~HGCrop(HGNode *this)
{
  *this = &unk_287227768;
  v2 = *(this + 51);
  if (v2)
  {
    (*(*v2 + 24))(v2);
  }

  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

void HGCropNode::~HGCropNode(HGCropNode *this)
{
  *this = &unk_287227518;
  if (*(this + 51))
  {
    v2 = this;
    MEMORY[0x2666E9F00](*(this + 51), 0x1000C40E0EAB150);
    this = v2;
    v1 = vars8;
  }

  HGNode::~HGNode(this);
}

void HGCropNode::~HGCropNode(HGNode *this)
{
  *this = &unk_287227518;
  v2 = *(this + 51);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

const char *HGFlipAndOffset::GetProgram(HGFlipAndOffset *this, HGRenderer *a2)
{
  Target = HGRenderer::GetTarget(a2, 393216);
  v4 = Target != 396048 && Target > 0x6060F;
  if (v4 && !(*(*a2 + 128))(a2, 46) && !(*(*a2 + 128))(a2, 21))
  {
    return "//GLfs2.0      \n//LEN=00000003a8\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform highp vec4 hg_ProgramLocal0;\nuniform highp vec4 hg_ProgramLocal1;\nuniform highp vec4 hg_ProgramLocal2;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    const highp vec4 c0 = vec4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n    highp vec4 r0, r1, r2;\n\n    r1.xy = hg_TexCoord0.xy + hg_ProgramLocal1.xy;\n    r1.xy = r1.xy*hg_ProgramLocal1.zw;\n    r2.xy = r1.xy - c0.xy;\n    r2.xy = r2.xy*hg_ProgramLocal2.zw;\n    r2.xy = clamp(hg_ProgramLocal2.xy - abs(r2.xy), vec2(0.00000), vec2(1.00000));\n    r2.x = r2.x*r2.y;\n    r1 = texture2D(hg_Texture0, r1.xy);\n    r0 = r1*r2.xxxx;\n    gl_FragColor = r0*hg_ProgramLocal0;\n}\n//MD5=42327dac:13de7175:fffb9b2f:8f6d6d8c\n//SIG=00000000:00000000:00000000:00000000:000c:0003:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }

  v5 = HGRenderer::GetTarget(a2, 393216);
  if (v5 == 396048)
  {
    if ((*(*a2 + 128))(a2, 20) == 27)
    {
      return "//Metal1.0     \n//LEN=0000000236\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< half > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    half4 r0;\n    FragmentOut output;\n\n    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    output.color0 = float4(r0)*hg_Params[0];\n    return output;\n}\n//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    }

    else
    {
      return "//Metal1.0     \n//LEN=0000000228\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n    const constant float4* hg_Params [[ buffer(0) ]], \n    texture2d< float > hg_Texture0 [[ texture(0) ]], \n    sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    float4 r0;\n    FragmentOut output;\n\n    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n    output.color0 = r0*hg_Params[0];\n    return output;\n}\n//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    }
  }

  else if (v5 <= 0x6060F || (*(*a2 + 128))(a2, 46))
  {
    return 0;
  }

  else
  {
    return "//GLfs2.0      \n//LEN=00000001f6\n#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp mediump\nuniform defaultp sampler2D hg_Texture0;\nuniform defaultp vec4 hg_ProgramLocal0;\nvarying highp vec4 hg_TexCoord0;\nvoid main()\n{\n    defaultp vec4 r0;\n\n    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n    gl_FragColor = r0*hg_ProgramLocal0;\n}\n//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void sub_25FD52180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21)
{
  if (a18 < 0)
  {
    operator delete(__p);
  }

  std::vector<HGBinding>::~vector[abi:ne200100](&a21);
  _Unwind_Resume(a1);
}

void sub_25FD521B0(_Unwind_Exception *a1)
{
  if (*(v1 - 33) < 0)
  {
    operator delete(*(v1 - 56));
    _Unwind_Resume(a1);
  }

  JUMPOUT(0x25FD521A8);
}

void HGToneCurve::HGToneCurve(HGToneCurve *this)
{
  HGNode::HGNode(this);
  *v1 = &unk_287227C50;
  *(v1 + 16) |= 0x400u;
  *(v1 + 408) = 0;
  *(v1 + 416) = 1;
  __asm { FMOV            V0.2S, #1.0 }

  *(v1 + 440) = _D0;
  *(v1 + 424) = 0;
  *(v1 + 448) = 0;
  *(v1 + 456) = 0;
  *(v1 + 464) = 0;
  operator new();
}

void sub_25FD52260(_Unwind_Exception *a1)
{
  v3 = v2;
  MEMORY[0x2666E9F00](v3, 0x1000C40BF75E1D5);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGToneCurve::~HGToneCurve(HGToneCurve *this)
{
  *this = &unk_287227C50;
  if (*(this + 54))
  {
    v2 = this;
    MEMORY[0x2666E9F00](*(this + 54), 0x1000C40BF75E1D5);
    this = v2;
    v1 = vars8;
  }

  HGNode::~HGNode(this);
}

void HGToneCurve::~HGToneCurve(HGNode *this)
{
  *this = &unk_287227C50;
  v2 = *(this + 54);
  if (v2)
  {
    MEMORY[0x2666E9F00](v2, 0x1000C40BF75E1D5);
  }

  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGToneCurve::GetDOD(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    return 0;
  }

  else
  {
    return *&a4.var0;
  }
}

uint64_t HGToneCurve::GetROI(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    return 0;
  }

  else
  {
    return *&a4.var0;
  }
}

uint64_t HGToneCurve::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  switch(a2)
  {
    case 2:
      *(this + 114) = a3;
      *(this + 115) = a4;
      *(this + 116) = a5;
      goto LABEL_20;
    case 1:
      *(this + 110) = a3;
      *(this + 111) = a4;
      *(this + 112) = a5;
      *(this + 113) = a6;
LABEL_20:
      HGNode::ClearBits(this, a2, a7);
      *(this + 106) = HGToneCurve::AcceleratedState(*(this + 102), *(this + 110), *(this + 111), *(this + 112), *(this + 113), *(this + 114), *(this + 115), *(this + 116));
      return 1;
    case 0:
      v8 = a3 > 4.0 || a3 < 0.0;
      v9 = a3;
      if (v8)
      {
        v9 = 0;
      }

      v10 = 7.0;
      if (a4 <= 7.0)
      {
        v10 = a4;
      }

      if (a4 < 0.0)
      {
        v10 = 0.0;
      }

      v11 = v10;
      v12 = 1.0;
      if (a5 <= 1.0)
      {
        v12 = a5;
      }

      if (a5 < 0.0)
      {
        v12 = 0.0;
      }

      *(this + 102) = v9;
      *(this + 103) = v11;
      *(this + 416) = v12 != 0;
      goto LABEL_20;
  }

  return 0xFFFFFFFFLL;
}

uint64_t HGToneCurve::AcceleratedState(int a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  switch(a1)
  {
    case 4:
      if (fabsf(a2 + -0.45) < 0.01)
      {
        v18 = fabsf(a3 + -1.23);
        v19 = a4 == 0.0 && v18 < 0.01;
        v20 = fabsf(a5 + -4.5);
        v21 = v19 && v20 < 0.1;
        v22 = fabsf(a6 + -0.018);
        v23 = v21 && v22 < 0.001;
        if (v23 && a8 == 0.0 && fabsf(a7 + 0.099) < 0.001)
        {
          return 2;
        }
      }

      result = 0;
      if (fabsf(a2 + -0.41667) < 0.01 && a4 == 0.0 && fabsf(a3 + -1.1371) < 0.01)
      {
        if (fabsf(a5 + -12.92) >= 0.1 || fabsf(a6 + -0.0031308) >= 0.0001)
        {
          return 0;
        }

        if (fabsf(a7 + 0.055) < 0.0005 && a8 == 0.0)
        {
          return 6;
        }

        else
        {
          return 0;
        }
      }

      break;
    case 3:
      v9 = fabsf(a3 + -0.909);
      v10 = fabsf(a2 + -2.22) < 0.01 && v9 < 0.001;
      v11 = fabsf(a4 + -0.09);
      v12 = v10 && v11 < 0.01;
      v13 = fabsf(a5 + -0.222);
      v14 = v12 && v13 < 0.001;
      if (v14 && a8 == 0.0 && a7 == 0.0 && fabsf(a6 + -0.0809) < 0.001)
      {
        return 1;
      }

      if (fabsf(a2 + -2.4) >= 0.01 || fabsf(a3 + -0.94787) >= 0.001 || fabsf(a4 + -0.052133) >= 0.001 || fabsf(a5 + -0.077399) >= 0.0001)
      {
        return 0;
      }

      v15 = fabsf(a6 + -0.04045) < 0.0001;
      v17 = a8 == 0.0 && a7 == 0.0;
      if (v17 && v15)
      {
        return 5;
      }

      else
      {
        return 0;
      }

    case 0:
      if (a8 == 0.0 && a7 == 0.0 && a6 == 0.0 && a5 == 0.0 && a4 == 0.0 && a3 == 0.0 && fabsf(a2 + -1.956) < 0.01)
      {
        return 7;
      }

      v30 = fabsf(a2 + -0.51125) < 0.01 && a4 == 0.0 && a3 == 0.0 && a5 == 0.0 && a6 == 0.0 && a7 == 0.0;
      if (a8 == 0.0 && v30)
      {
        return 8;
      }

      else
      {
        return 0;
      }

    default:
      return 0;
  }

  return result;
}

uint64_t HGToneCurve::GetParameter(HGToneCurve *this, int a2, float *a3)
{
  if (a2 == 2)
  {
    *a3 = *(this + 114);
    a3[1] = *(this + 115);
    v6 = *(this + 116);
    result = 0;
    *(a3 + 2) = v6;
    a3[3] = 0.0;
  }

  else if (a2 == 1)
  {
    *a3 = *(this + 110);
    a3[1] = *(this + 111);
    a3[2] = *(this + 112);
    v5 = *(this + 113);
    result = 0;
    *(a3 + 3) = v5;
  }

  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    v3 = vcvt_f32_u32(*(this + 408));
    *a3 = v3;
    v3.i8[0] = *(this + 416);
    a3[2] = v3.u32[0];
    v3.f32[0] = *(this + 106);
    result = 0;
    a3[3] = v3.f32[0];
  }

  return result;
}

double HGToneCurve::SetShaderParams(HGToneCurve *this, double result)
{
  v3 = *(this + 54);
  v4 = *(this + 102);
  if (v4 > 1)
  {
    if (v4 == 2)
    {
      *v3 = *(this + 110);
      *(v3 + 4) = *(this + 112) / *(this + 111);
      *(v3 + 8) = 0;
      *(v3 + 12) = powf(*(this + 111), *(this + 110));
      v8 = *(this + 105);
      if (v8 > 0x1B || (LODWORD(result) = 2.0, ((1 << v8) & 0x80C0000) == 0))
      {
        LODWORD(result) = 1.0;
      }

      *(v3 + 16) = 0;
      v6 = -*(this + 112) / *(this + 111);
LABEL_16:
      *(v3 + 20) = v6;
      *(v3 + 24) = 0;
      *(v3 + 28) = LODWORD(result);
      *(v3 + 32) = 0;
      return result;
    }

    if (v4 != 3)
    {
      if (v4 != 4)
      {
        return result;
      }

      *v3 = *(this + 110);
      *(v3 + 4) = *(this + 112) / *(this + 111);
      *(v3 + 8) = *(this + 115) - *(this + 116);
      *(v3 + 12) = powf(*(this + 111), *(this + 110));
      v5 = *(this + 105) - 32;
      *(v3 + 16) = *(this + 113);
      LODWORD(result) = 1.0;
      if (v5 < 3)
      {
        *&result = 2.0;
      }

      v6 = *(this + 114);
      goto LABEL_16;
    }

    *v3 = *(this + 110);
    *(v3 + 4) = *(this + 112) / *(this + 111);
    *(v3 + 8) = 0;
    *(v3 + 12) = powf(*(this + 111), *(this + 110));
    v9 = *(this + 105) - 25;
    *(v3 + 16) = *(this + 113);
    LODWORD(result) = *(this + 114);
    *(v3 + 20) = LODWORD(result);
    *(v3 + 24) = 0;
    if (v9 <= 2)
    {
LABEL_19:
      *(v3 + 28) = 0x40000000;
      return result;
    }

LABEL_11:
    *(v3 + 28) = 1065353216;
    return result;
  }

  if (v4)
  {
    if (v4 != 1)
    {
      return result;
    }

    *v3 = *(this + 110);
    *(v3 + 4) = *(this + 112) / *(this + 111);
    *(v3 + 8) = 0;
    *(v3 + 12) = powf(*(this + 111), *(this + 110));
    v7 = *(this + 105) - 11;
    *(v3 + 16) = 0;
    *&result = -*(this + 112) / *(this + 111);
    *(v3 + 20) = LODWORD(result);
    *(v3 + 24) = 0;
    if (v7 <= 2)
    {
      goto LABEL_19;
    }

    goto LABEL_11;
  }

  *v3 = *(this + 110);
  v10 = *(this + 105) - 4;
  *(v3 + 4) = xmmword_2603429D0;
  *(v3 + 20) = 0;
  if (v10 > 2)
  {
    result = 0.0078125;
    *(v3 + 24) = 0x3F80000000000000;
  }

  else
  {
    result = 2.00000047;
    *(v3 + 24) = 0x400000003F800000;
  }

  return result;
}

uint64_t HGToneCurve::BindTexture(HGToneCurve *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    return 0xFFFFFFFFLL;
  }

  (*(*a2 + 72))(a2, 0);
  (*(*a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(**(a2 + 18) + 128))(*(a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(*a2 + 168))(a2);
    return 0;
  }

  return result;
}

uint64_t HGToneCurve::Bind(HGToneCurve *this, HGHandler *a2)
{
  if (*(this + 106))
  {
    return 0;
  }

  v5 = *(this + 102);
  if (v5 > 2)
  {
    if (v5 != 3)
    {
      if (v5 != 4)
      {
        goto LABEL_11;
      }

LABEL_9:
      (*(*a2 + 144))(a2, 2, *(this + 54) + 32, 1);
    }
  }

  else if (v5 != 1)
  {
    if (v5 != 2)
    {
      goto LABEL_11;
    }

    goto LABEL_9;
  }

  (*(*a2 + 144))(a2, 1, *(this + 54) + 16, 1);
LABEL_11:
  (*(*a2 + 144))(a2, 0, *(this + 54), 1);
  return 0;
}

uint64_t HGToneCurve::GetProgram(HGToneCurve *this, HGRenderer *a2)
{
  if (*(this + 416))
  {
    v2 = hgtonecurve_getprogram;
  }

  else
  {
    v2 = hgtonecurve_getprogram_unpremult;
  }

  return v2[*(this + 105)](a2);
}

uint64_t HGToneCurve::InitProgramDescriptor(HGToneCurve *this, HGProgramDescriptor *a2)
{
  if (*(this + 416))
  {
    v2 = hgtonecurve_initprogramdesc;
  }

  else
  {
    v2 = hgtonecurve_initprogramdesc_unpremult;
  }

  return v2[*(this + 105)](a2);
}

uint64_t HGToneCurve::RenderTile(HGToneCurve *this, HGTile *a2)
{
  if (*(this + 416))
  {
    v2 = hgtonecurve_rendertile;
  }

  else
  {
    v2 = hgtonecurve_rendertile_unpremult;
  }

  return v2[*(this + 105)](a2, *(this + 54), this);
}

uint64_t HGToneCurve::SetToneCurveParams(uint64_t a1, uint64_t a2, char *a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  v17 = a2;
  HGNode::ClearBits(a1, a2, a3);
  if ((v17 & ~(v17 >> 31)) >= 4)
  {
    v19 = 4;
  }

  else
  {
    v19 = v17 & ~(v17 >> 31);
  }

  *(a1 + 408) = v19;
  *(a1 + 440) = a4;
  *(a1 + 444) = a5;
  *(a1 + 448) = a6;
  *(a1 + 452) = a7;
  *(a1 + 456) = a8;
  *(a1 + 460) = a9;
  *(a1 + 464) = a10;
  result = HGToneCurve::AcceleratedState(v19, a4, a5, a6, a7, a8, a9, a10);
  *(a1 + 424) = result;
  return result;
}

HGNode *HGToneCurve::SetToneCurveQuality(uint64_t a1, uint64_t a2, char *a3)
{
  v3 = a2;
  result = HGNode::ClearBits(a1, a2, a3);
  v6 = v3 & ~(v3 >> 31);
  if (v6 >= 7)
  {
    v6 = 7;
  }

  *(a1 + 412) = v6;
  return result;
}

HGNode *HGToneCurve::SetPremultiplyState(HGNode *this, uint64_t a2, char *a3)
{
  v3 = a2;
  result = HGNode::ClearBits(this, a2, a3);
  *(this + 416) = v3;
  return result;
}

uint64_t HGToneCurve::CanProcess(HGToneCurve *this)
{
  v1 = *(this + 106);
  if (v1 <= 4)
  {
    if (v1 > 2)
    {
      if (v1 == 3)
      {
        v2 = *(this + 103);
        if (v2 > 3)
        {
          if ((v2 - 6) < 2)
          {
            v2 = 1;
            v3 = 58;
            goto LABEL_222;
          }

          if (v2 != 4)
          {
            if (v2 == 5)
            {
              v2 = 1;
              v3 = 57;
              goto LABEL_222;
            }

            goto LABEL_98;
          }
        }

        else
        {
          if (v2 <= 1)
          {
            if (!v2)
            {
              v2 = 1;
              v3 = 53;
              goto LABEL_222;
            }

            if (v2 == 1)
            {
              v3 = 54;
              goto LABEL_222;
            }

            goto LABEL_98;
          }

          if (v2 == 2)
          {
            v2 = 1;
            v3 = 56;
            goto LABEL_222;
          }
        }

        v2 = 1;
        v3 = 55;
        goto LABEL_222;
      }

      v2 = *(this + 103);
      if (v2 > 3)
      {
        if ((v2 - 6) < 2)
        {
          v2 = 1;
          v3 = 52;
          goto LABEL_222;
        }

        if (v2 != 4)
        {
          if (v2 == 5)
          {
            v2 = 1;
            v3 = 51;
            goto LABEL_222;
          }

          goto LABEL_98;
        }
      }

      else
      {
        if (v2 <= 1)
        {
          if (!v2)
          {
            v2 = 1;
            v3 = 47;
            goto LABEL_222;
          }

          if (v2 == 1)
          {
            v3 = 48;
            goto LABEL_222;
          }

          goto LABEL_98;
        }

        if (v2 == 2)
        {
          v2 = 1;
          v3 = 50;
          goto LABEL_222;
        }
      }

      v2 = 1;
      v3 = 49;
      goto LABEL_222;
    }

    if (v1 == 1)
    {
      v2 = *(this + 103);
      if (v2 > 3)
      {
        if ((v2 - 6) < 2)
        {
          v2 = 1;
          v3 = 46;
          goto LABEL_222;
        }

        if (v2 != 4)
        {
          if (v2 == 5)
          {
            v2 = 1;
            v3 = 45;
            goto LABEL_222;
          }

          goto LABEL_98;
        }
      }

      else
      {
        if (v2 <= 1)
        {
          if (!v2)
          {
            v2 = 1;
            v3 = 41;
            goto LABEL_222;
          }

          if (v2 == 1)
          {
            v3 = 42;
            goto LABEL_222;
          }

          goto LABEL_98;
        }

        if (v2 == 2)
        {
          v2 = 1;
          v3 = 44;
          goto LABEL_222;
        }
      }

      v2 = 1;
      v3 = 43;
      goto LABEL_222;
    }

    if (v1 != 2)
    {
      goto LABEL_98;
    }

    v2 = *(this + 103);
    if (v2 > 3)
    {
      if ((v2 - 6) < 2)
      {
        v2 = 1;
        v3 = 40;
        goto LABEL_222;
      }

      if (v2 != 4)
      {
        if (v2 == 5)
        {
          v2 = 1;
          v3 = 39;
          goto LABEL_222;
        }

        goto LABEL_98;
      }
    }

    else
    {
      if (v2 <= 1)
      {
        if (!v2)
        {
          v2 = 1;
          v3 = 35;
          goto LABEL_222;
        }

        if (v2 == 1)
        {
          v3 = 36;
LABEL_222:
          *(this + 105) = v3;
          return v2;
        }

        goto LABEL_98;
      }

      if (v2 == 2)
      {
        v2 = 1;
        v3 = 38;
        goto LABEL_222;
      }
    }

    v2 = 1;
    v3 = 37;
    goto LABEL_222;
  }

  if (v1 > 6)
  {
    if (v1 == 7)
    {
      v2 = *(this + 103);
      if (v2 > 3)
      {
        if ((v2 - 6) < 2)
        {
          v2 = 1;
          v3 = 82;
          goto LABEL_222;
        }

        if (v2 != 4)
        {
          if (v2 == 5)
          {
            v2 = 1;
            v3 = 81;
            goto LABEL_222;
          }

          goto LABEL_98;
        }
      }

      else
      {
        if (v2 <= 1)
        {
          if (!v2)
          {
            v2 = 1;
            v3 = 77;
            goto LABEL_222;
          }

          if (v2 == 1)
          {
            v3 = 78;
            goto LABEL_222;
          }

          goto LABEL_98;
        }

        if (v2 == 2)
        {
          v2 = 1;
          v3 = 80;
          goto LABEL_222;
        }
      }

      v2 = 1;
      v3 = 79;
      goto LABEL_222;
    }

    if (v1 != 8)
    {
      goto LABEL_98;
    }

    v2 = *(this + 103);
    if (v2 > 3)
    {
      if ((v2 - 6) < 2)
      {
        v2 = 1;
        v3 = 76;
        goto LABEL_222;
      }

      if (v2 != 4)
      {
        if (v2 == 5)
        {
          v2 = 1;
          v3 = 75;
          goto LABEL_222;
        }

        goto LABEL_98;
      }
    }

    else
    {
      if (v2 <= 1)
      {
        if (!v2)
        {
          v2 = 1;
          v3 = 71;
          goto LABEL_222;
        }

        if (v2 == 1)
        {
          v3 = 72;
          goto LABEL_222;
        }

        goto LABEL_98;
      }

      if (v2 == 2)
      {
        v2 = 1;
        v3 = 74;
        goto LABEL_222;
      }
    }

    v2 = 1;
    v3 = 73;
    goto LABEL_222;
  }

  if (v1 == 5)
  {
    v2 = *(this + 103);
    if (v2 > 3)
    {
      if ((v2 - 6) < 2)
      {
        v2 = 1;
        v3 = 70;
        goto LABEL_222;
      }

      if (v2 != 4)
      {
        if (v2 == 5)
        {
          v2 = 1;
          v3 = 69;
          goto LABEL_222;
        }

        goto LABEL_98;
      }
    }

    else
    {
      if (v2 <= 1)
      {
        if (!v2)
        {
          v2 = 1;
          v3 = 65;
          goto LABEL_222;
        }

        if (v2 == 1)
        {
          v3 = 66;
          goto LABEL_222;
        }

        goto LABEL_98;
      }

      if (v2 == 2)
      {
        v2 = 1;
        v3 = 68;
        goto LABEL_222;
      }
    }

    v2 = 1;
    v3 = 67;
    goto LABEL_222;
  }

  v2 = *(this + 103);
  if (v2 > 3)
  {
    if ((v2 - 6) < 2)
    {
      v2 = 1;
      v3 = 64;
      goto LABEL_222;
    }

    if (v2 != 4)
    {
      if (v2 == 5)
      {
        v2 = 1;
        v3 = 63;
        goto LABEL_222;
      }

      goto LABEL_98;
    }

LABEL_93:
    v2 = 1;
    v3 = 61;
    goto LABEL_222;
  }

  if (v2 > 1)
  {
    if (v2 == 2)
    {
      v2 = 1;
      v3 = 62;
      goto LABEL_222;
    }

    goto LABEL_93;
  }

  if (!v2)
  {
    v2 = 1;
    v3 = 59;
    goto LABEL_222;
  }

  if (v2 == 1)
  {
    v3 = 60;
    goto LABEL_222;
  }

LABEL_98:
  v4 = *(this + 102);
  v2 = 1;
  if (v4 <= 1)
  {
    if (!v4)
    {
      v2 = *(this + 110) != 1.0;
      v3 = *(this + 103);
      if (v3 > 3)
      {
        if (v3 > 5)
        {
          if (v3 == 6)
          {
            v3 = 5;
            goto LABEL_222;
          }

          if (v3 == 7)
          {
            v3 = 6;
            goto LABEL_222;
          }

          return v2;
        }

        if (v3 != 4)
        {
          v3 = 4;
          goto LABEL_222;
        }
      }

      else
      {
        if (v3 < 2)
        {
          goto LABEL_222;
        }

        if (v3 == 2)
        {
          v3 = 3;
          goto LABEL_222;
        }

        if (v3 != 3)
        {
          return v2;
        }
      }

      v3 = 2;
      goto LABEL_222;
    }

    if (v4 != 1)
    {
      return v2;
    }

    if (*(this + 110) == 1.0 && *(this + 112) == 0.0)
    {
      v2 = *(this + 111) != 1.0;
    }

    v6 = *(this + 103);
    if (v6 > 3)
    {
      if (v6 > 5)
      {
        if (v6 == 6)
        {
          v3 = 12;
          goto LABEL_222;
        }

        if (v6 == 7)
        {
          v3 = 13;
          goto LABEL_222;
        }

        return v2;
      }

      if (v6 != 4)
      {
        v3 = 11;
        goto LABEL_222;
      }
    }

    else
    {
      if (v6 <= 1)
      {
        if (!v6)
        {
          v3 = 7;
          goto LABEL_222;
        }

        if (v6 == 1)
        {
          v3 = 8;
          goto LABEL_222;
        }

        return v2;
      }

      if (v6 == 2)
      {
        v3 = 10;
        goto LABEL_222;
      }
    }

    v3 = 9;
    goto LABEL_222;
  }

  if (v4 == 2)
  {
    if (*(this + 110) == 1.0 && *(this + 112) == 0.0 && *(this + 111) == 1.0)
    {
      v2 = *(this + 113) != 0.0;
    }

    v7 = *(this + 103);
    if (v7 > 3)
    {
      if (v7 > 5)
      {
        if (v7 == 6)
        {
          v3 = 19;
          goto LABEL_222;
        }

        if (v7 == 7)
        {
          v3 = 20;
          goto LABEL_222;
        }

        return v2;
      }

      if (v7 != 4)
      {
        v3 = 18;
        goto LABEL_222;
      }
    }

    else
    {
      if (v7 <= 1)
      {
        if (!v7)
        {
          v3 = 14;
          goto LABEL_222;
        }

        if (v7 == 1)
        {
          v3 = 15;
          goto LABEL_222;
        }

        return v2;
      }

      if (v7 == 2)
      {
        v3 = 17;
        goto LABEL_222;
      }
    }

    v3 = 16;
    goto LABEL_222;
  }

  if (v4 == 3)
  {
    if (*(this + 110) == 1.0 && *(this + 112) == 0.0 && *(this + 111) == 1.0)
    {
      v2 = *(this + 113) != 1.0;
    }

    v8 = *(this + 103);
    if (v8 > 3)
    {
      if (v8 > 5)
      {
        if (v8 == 6)
        {
          v3 = 26;
          goto LABEL_222;
        }

        if (v8 == 7)
        {
          v3 = 27;
          goto LABEL_222;
        }

        return v2;
      }

      if (v8 != 4)
      {
        v3 = 25;
        goto LABEL_222;
      }
    }

    else
    {
      if (v8 <= 1)
      {
        if (!v8)
        {
          v3 = 21;
          goto LABEL_222;
        }

        if (v8 == 1)
        {
          v3 = 22;
          goto LABEL_222;
        }

        return v2;
      }

      if (v8 == 2)
      {
        v3 = 24;
        goto LABEL_222;
      }
    }

    v3 = 23;
    goto LABEL_222;
  }

  if (v4 != 4)
  {
    return v2;
  }

  if (*(this + 110) == 1.0 && *(this + 111) == 1.0 && (*(this + 112) + *(this + 115)) == 0.0 && *(this + 113) == 1.0)
  {
    v2 = *(this + 116) != 0.0;
  }

  v5 = *(this + 103);
  if (v5 > 3)
  {
    if (v5 > 5)
    {
      if (v5 == 6)
      {
        v3 = 33;
        goto LABEL_222;
      }

      if (v5 == 7)
      {
        v3 = 34;
        goto LABEL_222;
      }

      return v2;
    }

    if (v5 != 4)
    {
      v3 = 32;
      goto LABEL_222;
    }

LABEL_198:
    v3 = 30;
    goto LABEL_222;
  }

  if (v5 > 1)
  {
    if (v5 == 2)
    {
      v3 = 31;
      goto LABEL_222;
    }

    goto LABEL_198;
  }

  if (!v5)
  {
    v3 = 28;
    goto LABEL_222;
  }

  if (v5 == 1)
  {
    v3 = 29;
    goto LABEL_222;
  }

  return v2;
}

HGNode *HGToneCurve::GetOutput(HGNode *this, HGRenderer *a2)
{
  if (HGRenderer::IsMergeable(a2, this, 0, 0))
  {
    Input = HGRenderer::GetInput(a2, this, 0);
    if (Input)
    {
      if (v5)
      {
        v6 = v5;
        if (HGToneCurve::CanBypass(this, v5))
        {
          v7 = a2;
          v8 = v6;

          return HGRenderer::GetInput(v7, v8, 0);
        }
      }
    }
  }

  if (!HGToneCurve::CanProcess(this))
  {
    v7 = a2;
    v8 = this;

    return HGRenderer::GetInput(v7, v8, 0);
  }

  HGToneCurve::SetShaderParams(this, v10);
  return this;
}

BOOL HGToneCurve::CanBypass(HGToneCurve *this, HGToneCurve *a2)
{
  v11 = *MEMORY[0x277D85DE8];
  (*(*a2 + 104))(a2, 0, v9);
  if (v9[1] != *(this + 103))
  {
    return 0;
  }

  v4.n128_f32[0] = v10;
  v6 = *(this + 106);
  if (v6 == 2 && v10 == 1.0)
  {
    return 1;
  }

  v8 = v6 == 1 && v10 == 2.0;
  if (v8 || v6 == 4 && v10 == 3.0 || v6 == 3 && v10 == 4.0 || v6 == 6 && v10 == 5.0 || v6 == 5 && v10 == 6.0 || v6 == 8 && v10 == 7.0 || v6 == 7 && v10 == 8.0)
  {
    return 1;
  }

  (*(*a2 + 104))(a2, 1, v9, v4);
  if (*(this + 102))
  {
    return 0;
  }

  return fabsf((v9[0] * *(this + 110)) + -1.0) < 0.000001;
}

char *HGToneCurve::label_B(HGToneCurve *this)
{
  if (*(this + 416))
  {
    v1 = hgtonecurve_read_label;
  }

  else
  {
    v1 = hgtonecurve_unpremult_read_label;
  }

  return v1[*(this + 105)];
}

double HGToneCurve::State::State(HGToneCurve::State *this)
{
  *this = 0u;
  *(this + 1) = 0u;
  *(this + 2) = 0u;
  *(this + 3) = xmmword_2603427D0;
  *(this + 4) = xmmword_2603444B0;
  *(this + 5) = xmmword_260344BA0;
  *(this + 6) = xmmword_260818550;
  *(this + 7) = xmmword_260818560;
  *(this + 8) = xmmword_260818570;
  *(this + 9) = xmmword_260818580;
  *(this + 10) = xmmword_260818590;
  *(this + 11) = xmmword_2608185A0;
  *(this + 12) = xmmword_2608185B0;
  *(this + 13) = xmmword_260817940;
  *(this + 14) = xmmword_2608185C0;
  *(this + 15) = xmmword_260344600;
  *(this + 16) = vdupq_n_s32(0x358637BDu);
  *(this + 17) = xmmword_260344B20;
  *(this + 18) = vdupq_n_s32(0x3F804020u);
  *(this + 19) = xmmword_260344C10;
  v1.i64[0] = 0x7F0000007FLL;
  v1.i64[1] = 0x7F0000007FLL;
  *(this + 20) = xmmword_260344C20;
  *(this + 21) = vnegq_f32(v1);
  *(this + 22) = xmmword_260344C40;
  *(this + 23) = xmmword_260344C50;
  *(this + 24) = xmmword_260344B50;
  *(this + 25) = xmmword_260344C60;
  *(this + 26) = xmmword_260344C70;
  *(this + 27) = xmmword_260344C80;
  *(this + 28) = xmmword_260344C90;
  *(this + 29) = xmmword_260344CA0;
  *(this + 30) = xmmword_260344CB0;
  *(this + 31) = xmmword_260344CC0;
  *(this + 32) = xmmword_260344CD0;
  *(this + 33) = xmmword_260344CE0;
  *(this + 34) = xmmword_260345890;
  *(this + 35) = xmmword_260344B60;
  *(this + 36) = xmmword_260346D20;
  *(this + 37) = xmmword_2608185D0;
  *(this + 38) = xmmword_2608185E0;
  *(this + 39) = xmmword_2608185F0;
  *(this + 40) = xmmword_260818600;
  *(this + 41) = xmmword_260818610;
  *(this + 42) = xmmword_260818620;
  *(this + 43) = xmmword_260818630;
  *(this + 44) = xmmword_260818640;
  *(this + 45) = xmmword_260818650;
  *(this + 46) = xmmword_260818660;
  *(this + 47) = xmmword_260818670;
  *(this + 48) = xmmword_260818680;
  *(this + 49) = xmmword_260818690;
  *&v2 = 0x3F0000003FLL;
  *(&v2 + 1) = 0x3F0000003FLL;
  *(this + 50) = 0u;
  *(this + 51) = v2;
  *(this + 52) = xmmword_2608186A0;
  *(this + 53) = xmmword_2608186B0;
  *(this + 54) = xmmword_2608186C0;
  *(this + 55) = xmmword_2608186D0;
  *(this + 56) = xmmword_2608186E0;
  *(this + 57) = xmmword_2608186F0;
  *(this + 58) = xmmword_260818700;
  *(this + 59) = xmmword_260818710;
  *(this + 60) = xmmword_260818720;
  *(this + 61) = xmmword_260818730;
  *(this + 62) = xmmword_260818740;
  *(this + 63) = xmmword_260818750;
  *(this + 64) = xmmword_260818760;
  *(this + 65) = xmmword_260818770;
  *(this + 66) = xmmword_260818780;
  *(this + 67) = xmmword_260818790;
  *(this + 68) = xmmword_2608187A0;
  *(this + 69) = xmmword_2608187B0;
  *(this + 70) = xmmword_2608187C0;
  *(this + 71) = xmmword_2608187D0;
  *(this + 72) = xmmword_2608187E0;
  v3.i64[0] = 0x80000000800000;
  v3.i64[1] = 0x80000000800000;
  *(this + 73) = vnegq_f32(v3);
  *(this + 74) = xmmword_260344670;
  *(this + 75) = xmmword_260342770;
  *(this + 76) = xmmword_260344610;
  *(this + 77) = xmmword_2608187F0;
  *(this + 78) = xmmword_260818800;
  *(this + 79) = xmmword_260818810;
  *(this + 80) = xmmword_260818820;
  *(this + 81) = xmmword_260818830;
  *(this + 82) = xmmword_260818840;
  *(this + 83) = xmmword_260818850;
  *(this + 84) = xmmword_260818860;
  *(this + 85) = xmmword_260818870;
  *(this + 86) = xmmword_260818880;
  *(this + 87) = xmmword_260818890;
  *(this + 88) = xmmword_2608188A0;
  *(this + 89) = xmmword_2608188B0;
  *(this + 90) = xmmword_2608188C0;
  *(this + 91) = xmmword_2608188D0;
  *(this + 92) = xmmword_2608188E0;
  *(this + 93) = xmmword_260346190;
  *(this + 94) = xmmword_2608188F0;
  *(this + 95) = xmmword_260818900;
  *(this + 96) = xmmword_260818910;
  *(this + 97) = xmmword_260818920;
  *(this + 98) = xmmword_260818930;
  *(this + 99) = xmmword_260818940;
  *(this + 100) = xmmword_260818950;
  *(this + 101) = xmmword_2603917E0;
  *(this + 102) = xmmword_260818960;
  *(this + 103) = xmmword_2603917C0;
  *(this + 104) = xmmword_2603917D0;
  *(this + 105) = xmmword_260818970;
  *(this + 106) = xmmword_260818980;
  *(this + 107) = xmmword_260818990;
  *(this + 108) = xmmword_2608189A0;
  *(this + 109) = xmmword_26034C6A0;
  *(this + 110) = xmmword_2608189B0;
  *(this + 111) = xmmword_2608189C0;
  *(this + 112) = xmmword_260391850;
  *(this + 113) = xmmword_2608189D0;
  *(this + 114) = xmmword_2608189E0;
  *(this + 115) = xmmword_2608189F0;
  result = 1.648;
  *(this + 116) = xmmword_26034C6E0;
  return result;
}