void sub_1B32D13FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31, uint64_t a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, char a40)
{
  if (a40 == 1)
  {
    if (a38 < 0)
    {
      v43 = mdm::zone_mallocator::instance(v42);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v43, a33);
    }

    if (a31 < 0)
    {
      v44 = mdm::zone_mallocator::instance(v42);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v44, a26);
    }
  }

  _Unwind_Resume(a1);
}

__n128 std::__optional_storage_base<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,false>::__assign_from[abi:nn200100]<std::__optional_move_assign_base<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,false>>(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 64) == *(a2 + 64))
  {
    if (*(a1 + 64))
    {
      v3 = std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::operator=[abi:nn200100](a1, a2) + 32;

      std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::operator=[abi:nn200100](v3, (a2 + 32));
    }
  }

  else if (*(a1 + 64))
  {

    std::__optional_destruct_base<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,false>::reset[abi:nn200100](a1);
  }

  else
  {
    v5 = *a2;
    *(a1 + 16) = *(a2 + 16);
    *a1 = v5;
    *(a1 + 24) = *(a2 + 24);
    *a2 = 0;
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    result = *(a2 + 32);
    *(a1 + 48) = *(a2 + 48);
    *(a1 + 32) = result;
    *(a1 + 56) = *(a2 + 56);
    *(a2 + 32) = 0;
    *(a2 + 40) = 0;
    *(a2 + 48) = 0;
    *(a1 + 64) = 1;
  }

  return result;
}

void std::__optional_destruct_base<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,false>::reset[abi:nn200100](uint64_t a1)
{
  if (*(a1 + 64) == 1)
  {
    if (*(a1 + 55) < 0)
    {
      v2 = *(a1 + 32);
      v3 = mdm::zone_mallocator::instance(a1);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v3, v2);
    }

    if (*(a1 + 23) < 0)
    {
      v4 = *a1;
      v5 = mdm::zone_mallocator::instance(a1);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v5, v4);
    }

    *(a1 + 64) = 0;
  }
}

uint64_t md::PointLabelFeature::imageTextIndex(uint64_t a1, uint64_t *a2)
{
  if (!(*(*a1 + 64))(a1))
  {
    return 255;
  }

  v4 = *a2;

  return md::PointLabelFeature::externalFeatureTextIndex(a1, 3, v4);
}

uint64_t md::PointLabelFeature::primaryChildTextIndex(uint64_t a1, void *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  v3 = a2[8];
  v4 = atomic_load((*a2 + 3426));
  md::PointLabelFeatureElement::getSummaryIconInfos(v18, v3, 2, v4 & 1);
  if (v19 != 1)
  {
    return 255;
  }

  if (v18[0] == v18[1])
  {
    goto LABEL_17;
  }

  v5 = (v18[0] + 8);
  if ((*(v18[0] + 31) & 0x80000000) == 0)
  {
    if (!*(v18[0] + 31))
    {
      goto LABEL_17;
    }

    goto LABEL_9;
  }

  if (!*(v18[0] + 16))
  {
LABEL_17:
    v6 = 255;
LABEL_18:
    v14[0] = v18;
    std::vector<md::PointLabelSummaryIconInfo,geo::allocator_adapter<md::PointLabelSummaryIconInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v14);
    return v6;
  }

  v5 = *v5;
LABEL_9:
  v7 = (v18[0] + 32);
  if (*(v18[0] + 55) < 0)
  {
    v7 = *v7;
  }

  md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>::StringWithLocaleImp(v14, v5, v7);
  v8 = md::PointLabelFeature::indexForTextEntry(a1, v14);
  v6 = v8;
  if (v17 < 0)
  {
    v9 = v16;
    v10 = mdm::zone_mallocator::instance(v8);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v10, v9);
  }

  if (v15 < 0)
  {
    v11 = v14[0];
    v12 = mdm::zone_mallocator::instance(v8);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v12, v11);
  }

  if (v19)
  {
    goto LABEL_18;
  }

  return v6;
}

void sub_1B32D1824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  if (a21 < 0)
  {
    v28 = a16;
    v29 = mdm::zone_mallocator::instance(exception_object);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v29, v28);
  }

  if (a14 < 0)
  {
    v30 = a9;
    v31 = mdm::zone_mallocator::instance(exception_object);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v31, v30);
  }

  if (a27 == 1)
  {
    a9 = &a23;
    std::vector<md::PointLabelSummaryIconInfo,geo::allocator_adapter<md::PointLabelSummaryIconInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a9);
  }

  _Unwind_Resume(exception_object);
}

uint64_t md::PointLabelFeature::newMultiPoiIconPart(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 16);
  v3 = *(v2 + 296);
  if (!v3)
  {
    v4 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(a2 + 16), 0);
    v3 = *v4;
    *(v2 + 296) = *v4;
  }

  if (*(v3 + 68))
  {
    _ZNSt3__115allocate_sharedB8nn200100I22FeatureStyleAttributesNS_9allocatorIS1_EEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_();
  }

  return 0;
}

void sub_1B32D1BC4(mdm::zone_mallocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  v31 = mdm::zone_mallocator::instance(a1);
  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v31, v28);
  a16 = v29 - 128;
  std::vector<std::shared_ptr<md::LabelIcon>,geo::allocator_adapter<std::shared_ptr<md::LabelIcon>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a16);
  if (v27)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v27);
  }

  _Unwind_Resume(a1);
}

void *md::PointLabelFeature::updateZoomRanks(void *this)
{
  v1 = this[60];
  if (v1)
  {
    v2 = this[54];
    if (v2 != this + 55)
    {
      v3 = 72;
      if (*(v1 + 112))
      {
        v3 = 76;
      }

      v4 = (v1 + v3);
      do
      {
        *(v2 + 34) = *(v1 + 80);
        v5 = vld1q_dup_f32(v4);
        *(v2 + 15) = v5;
        v6 = v2[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = *v6;
          }

          while (v6);
        }

        else
        {
          do
          {
            v7 = v2[2];
            v8 = *v7 == v2;
            v2 = v7;
          }

          while (!v8);
        }

        v2 = v7;
      }

      while (v7 != this + 55);
    }
  }

  return this;
}

void md::PointLabelFeature::debugPopulateAttributeStrings(md::PointLabelFeature *this, NSMutableSet *a2, const md::LabelManager *a3, const md::LabelIdentifier *a4)
{
  v12 = a2;
  if (*(this + 74) - *(this + 73) >= 0x21uLL)
  {
    v8 = md::PointLabelFeature::styleEntryForIdentifier(this, *a4);
    if (v8)
    {
      v9 = MEMORY[0x1E696AEC0];
      v10 = md::HighlightHelper::debugAttributesToString(v8);
      v11 = [v9 stringWithFormat:@"{%@}[ACTIVE]", v10];
      [(NSMutableSet *)v12 addObject:v11];
    }
  }

  md::PointLabelFeatureBase::debugPopulateAttributeStrings(this, v12, a3, v7);
}

uint64_t md::PointLabelFeature::debugString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, char a4@<W3>, _BYTE *a5@<X8>)
{
  v200 = *MEMORY[0x1E69E9840];
  v9 = *(a2 + 464);
  std::ostringstream::basic_ostringstream[abi:nn200100](&v185);
  v183 = a1;
  LODWORD(v194.__r_.__value_.__l.__data_) = *a3;
  *(v194.__r_.__value_.__r.__words + 4) = -1;
  HIDWORD(v194.__r_.__value_.__r.__words[1]) = -1;
  v194.__r_.__value_.__r.__words[2] = 0;
  md::LabelFeature::debugString(a1, a2, &v194, a4, &v196);
  if (v197 >= 0)
  {
    v10 = &v196;
  }

  else
  {
    v10 = v196;
  }

  if (v197 >= 0)
  {
    v11 = HIBYTE(v197);
  }

  else
  {
    v11 = *(&v196 + 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v10, v11);
  if (SHIBYTE(v197) < 0)
  {
    operator delete(v196);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " Point:\n", 8);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "  layoutZ:", 10);
  MEMORY[0x1B8C61C80](&v185, v9);
  if (*(a1 + 244) != 255)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " flexZone=", 10);
    MEMORY[0x1B8C61C80](&v185, *(a1 + 244));
  }

  if (atomic_load((a1 + 693)))
  {
    v13 = *(a1 + 440);
    if (v13)
    {
      v14 = *a3;
      v15 = a1 + 440;
      do
      {
        v16 = *(v13 + 32);
        v17 = v16 >= v14;
        v18 = v16 < v14;
        if (v17)
        {
          v15 = v13;
        }

        v13 = *(v13 + 8 * v18);
      }

      while (v13);
      if (v15 != a1 + 440 && v14 >= *(v15 + 32))
      {
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " MZR Default=", 13);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " Active(", 8);
        v19 = atomic_load((a1 + 693));
        v20 = MEMORY[0x1B8C61C80](&v185, v19);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v20, ")=", 2);
        atomic_load((a1 + 693));
        std::ostream::operator<<();
      }
    }
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
  if (*(a1 + 688) == 1)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "  venueID=", 10);
    v21 = MEMORY[0x1B8C61CF0](&v185, *(a1 + 648));
    v22 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v21, " bldg=", 6);
    v23 = MEMORY[0x1B8C61CF0](v22, *(a1 + 656));
    v24 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, " level=", 7);
    v25 = MEMORY[0x1B8C61CF0](v24, *(a1 + 664));
    v26 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v25, " floor=", 7);
    v27 = MEMORY[0x1B8C61CC0](v26, *(a1 + 680));
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v27, "\n", 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " positions=", 11);
  MEMORY[0x1B8C61CB0](&v185, *(a1 + 456));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " Versions update=", 17);
  v28 = MEMORY[0x1B8C61CF0](&v185, *(a1 + 408));
  v29 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v28, " remove=", 8);
  v30 = MEMORY[0x1B8C61CF0](v29, *(a1 + 416));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, "\n", 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " [text]\n", 8);
  v31 = *(a1 + 520);
  v32 = *(a1 + 528);
  if (v31 != v32)
  {
    v33 = 0;
    v34 = v31 + 32;
    do
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "   ", 3);
      MEMORY[0x1B8C61C80](&v185, v33);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, ": ", 2);
      v35 = *(v34 - 9);
      if (v35 >= 0)
      {
        v36 = v34 - 32;
      }

      else
      {
        v36 = *(v34 - 32);
      }

      if (v35 >= 0)
      {
        v37 = *(v34 - 9);
      }

      else
      {
        v37 = *(v34 - 24);
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v36, v37);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "(", 1);
      v38 = *(v34 + 23);
      if (v38 >= 0)
      {
        v39 = v34;
      }

      else
      {
        v39 = *v34;
      }

      if (v38 >= 0)
      {
        v40 = *(v34 + 23);
      }

      else
      {
        v40 = *(v34 + 8);
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v39, v40);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, ")\n", 2);
      v33 = (v33 + 1);
      v41 = v34 + 32;
      v34 += 64;
    }

    while (v41 != v32);
  }

  v42 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " [placement]\n", 13);
  v43 = a1;
  v44 = *(a1 + 552);
  v45 = *(a1 + 560);
  if (v44 != v45)
  {
    v46 = 0;
    do
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "   ", 3);
      MEMORY[0x1B8C61C80](&v185, v46);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, ": ", 2);
      if (*v44 == *(v44 + 8))
      {
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "<none>", 6);
      }

      else
      {
        v196 = 0uLL;
        v197 = 0;
        v47 = *v44;
        v48 = *(v44 + 8);
        if (*v44 != v48)
        {
          v49 = 1;
          do
          {
            if ((v49 & 1) == 0)
            {
              std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::append(&v196, " ", 1uLL);
            }

            LabelPlacementToShortString(&v194, v47);
            if ((v194.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v50 = &v194;
            }

            else
            {
              v50 = v194.__r_.__value_.__r.__words[0];
            }

            if ((v194.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              size = HIBYTE(v194.__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = v194.__r_.__value_.__l.__size_;
            }

            std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::append(&v196, v50, size);
            if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v194.__r_.__value_.__l.__data_);
            }

            v49 = 0;
            v47 += 5;
          }

          while (v47 != v48);
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "<", 1);
        if (v197 >= 0)
        {
          v52 = &v196;
        }

        else
        {
          v52 = v196;
        }

        if (v197 >= 0)
        {
          v53 = HIBYTE(v197);
        }

        else
        {
          v53 = *(&v196 + 1);
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v52, v53);
        v54 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, ">", 1);
        v43 = v183;
        if (SHIBYTE(v197) < 0)
        {
          v55 = v196;
          v56 = mdm::zone_mallocator::instance(v54);
          v57 = v55;
          v43 = v183;
          geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v56, v57);
        }
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " clientAlternates:", 18);
      MEMORY[0x1B8C61C50](&v185, *(v44 + 24));
      v42 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
      v46 = (v46 + 1);
      v44 += 32;
    }

    while (v44 != v45);
  }

  v58 = *(v43 + 440);
  if (!v58)
  {
    goto LABEL_136;
  }

  v59 = *a3;
  v60 = v43 + 440;
  do
  {
    v61 = *(v58 + 32);
    v17 = v61 >= v59;
    v62 = v61 < v59;
    if (v17)
    {
      v60 = v58;
    }

    v58 = *(v58 + 8 * v62);
  }

  while (v58);
  if (v60 == v43 + 440 || v59 < *(v60 + 32))
  {
    goto LABEL_136;
  }

  v64 = *(v60 + 40);
  v63 = *(v60 + 48);
  v65 = v185;
  *(&v185 + *(v185 - 24) + 8) = *(&v185 + *(v185 - 24) + 8) & 0xFFFFFEFB | 4;
  *(&v187[0].__locale_ + *(v65 - 24)) = 2;
  v66 = *(v60 + 146);
  if ((v66 & 1) == 0)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " demElevation(", 14);
    v67 = MEMORY[0x1B8C61C80](&v185, *(v60 + 148));
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v67, ")=", 2);
    v42 = std::ostream::operator<<();
  }

  v68 = *(v60 + 48);
  if (*(v60 + 40) == v68)
  {
    v184 = 0;
    goto LABEL_88;
  }

  v69 = *(v68 - 8);
  if (v69)
  {
    v70 = v69 + 8;
  }

  else
  {
    v70 = 0;
  }

  v42 = md::PointLabelFeatureElement::extendedPosition(&v184, v70);
  v71 = v184;
  if (!v184)
  {
LABEL_88:
    v71 = 0;
    if (v66)
    {
      goto LABEL_90;
    }

    goto LABEL_89;
  }

  if (v184[4] == 1)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " elevation=", 11);
    if ((v71[4] & 1) == 0)
    {
      goto LABEL_265;
    }

    std::ostream::operator<<();
  }

  if (v71[12] != 1)
  {
    goto LABEL_85;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " buildingHeight=", 16);
  if ((v71[12] & 1) == 0)
  {
LABEL_265:
    v179 = std::__throw_bad_optional_access[abi:nn200100]();
    if (SHIBYTE(v197) < 0)
    {
      operator delete(v196);
    }

    v185 = *MEMORY[0x1E69E54E8];
    *(&v185 + *(v185 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v186 = MEMORY[0x1E69E5548] + 16;
    if (v190 < 0)
    {
      operator delete(__p);
    }

    v186 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v187);
    std::ostream::~ostream();
    MEMORY[0x1B8C620C0](v193);
    _Unwind_Resume(v179);
  }

  std::ostream::operator<<();
LABEL_85:
  if (v71[28] == 1)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " normalAzimuth:", 15);
    std::ostream::operator<<();
  }

LABEL_89:
  v42 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
LABEL_90:
  v72 = 0;
  v73 = (v63 - v64) >> 3;
  while (1)
  {
    memset(&v194, 0, sizeof(v194));
    if (v72 >= v73)
    {
      break;
    }

    v74 = *(*(v60 + 40) + 8 * v72);
    v75 = v74 + 8;
    if (v74)
    {
      v76 = v74 + 8;
    }

    else
    {
      v76 = 0;
    }

    v77 = *(v76 + 130);
    if (*(v74 + 138) == v77)
    {
      v78 = 0;
      v79 = *(v76 + 131);
      v80 = *(v76 + 72);
      v81 = v72 + 1;
      v82 = 1;
      v83 = v72;
      v180 = *(v183 + 408);
      v181 = v71;
      while (1)
      {
        v72 = v81;
        if (*(v75 + 72) != v80)
        {
          v72 = v81 - 1;
          goto LABEL_121;
        }

        v84 = *(v75 + 129);
        if (v78 >= v194.__r_.__value_.__r.__words[2])
        {
          v85 = &v78[-v194.__r_.__value_.__r.__words[0]];
          v86 = (v85 + 1);
          if ((v85 + 1) < 0)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          v87 = v194.__r_.__value_.__r.__words[2] - v194.__r_.__value_.__r.__words[0];
          if (2 * (v194.__r_.__value_.__r.__words[2] - v194.__r_.__value_.__r.__words[0]) > v86)
          {
            v86 = 2 * v87;
          }

          if (v87 >= 0x3FFFFFFFFFFFFFFFLL)
          {
            v88 = 0x7FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v88 = v86;
          }

          v199 = &v195;
          if (v88)
          {
            v89 = mdm::zone_mallocator::instance(v42);
            v90 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v89, v88);
          }

          else
          {
            v90 = 0;
          }

          v91 = &v85[v90];
          *v91 = v84;
          v78 = &v85[v90 + 1];
          v92 = v90 + v88;
          v93 = &v91[v194.__r_.__value_.__r.__words[0] - v194.__r_.__value_.__l.__size_];
          memcpy(v93, v194.__r_.__value_.__l.__data_, v194.__r_.__value_.__l.__size_ - v194.__r_.__value_.__r.__words[0]);
          v94 = v194.__r_.__value_.__r.__words[0];
          v95 = v194.__r_.__value_.__r.__words[2];
          v194.__r_.__value_.__r.__words[0] = v93;
          v194.__r_.__value_.__l.__size_ = v78;
          v194.__r_.__value_.__r.__words[2] = v92;
          v197 = v94;
          v198 = v95;
          *&v196 = v94;
          *(&v196 + 1) = v94;
          v42 = std::__split_buffer<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator> &>::~__split_buffer(&v196);
        }

        else
        {
          *v78++ = v84;
        }

        v194.__r_.__value_.__l.__size_ = v78;
        v82 = v72 < v73;
        if (v73 == v72)
        {
          v72 = v73;
          goto LABEL_121;
        }

        v96 = *(*(v60 + 40) + 8 * v72);
        ++v83;
        v75 = v96 + 8;
        v97 = v96 ? v96 + 8 : 0;
        if (v79 != *(v97 + 131))
        {
          break;
        }

        v98 = *(v96 + 138);
        v81 = v72 + 1;
        if (v98 != v77)
        {
          goto LABEL_121;
        }
      }

      v72 = v83;
LABEL_121:
      if (v194.__r_.__value_.__l.__data_ != v78)
      {
        if (v80 != v180)
        {
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " [expired] vers=", 16);
          MEMORY[0x1B8C61CF0](&v185, v80);
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " [element] Z:", 13);
        v100 = v194.__r_.__value_.__l.__size_;
        v99 = v194.__r_.__value_.__r.__words[0];
        if (v194.__r_.__value_.__r.__words[0] != v194.__r_.__value_.__l.__size_)
        {
          v101 = 1;
          do
          {
            v102 = *v99;
            if ((v101 & 1) == 0)
            {
              std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, ",", 1);
            }

            MEMORY[0x1B8C61C90](&v185, v102);
            v101 = 0;
            ++v99;
          }

          while (v99 != v100);
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " text:", 6);
        MEMORY[0x1B8C61C90](&v185, v77);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " placement:", 11);
        MEMORY[0x1B8C61C90](&v185, v79);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v194);
      v71 = v181;
      if (!v82)
      {
        goto LABEL_133;
      }
    }

    else
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v194);
    }
  }

  std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v194);
LABEL_133:
  v184 = 0;
  if (v71)
  {
    MEMORY[0x1B8C62190](v71, 0x1000C40383AD44DLL);
  }

  v43 = v183;
LABEL_136:
  v103 = *(v43 + 80);
  if (!v103 || *(v103 + 125) != 1 || *(v103 + 136) == 255)
  {
    goto LABEL_247;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " [style]", 8);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " <icon>", 7);
  v104 = *(v43 + 80);
  v105 = *(v104 + 296);
  if (!v105)
  {
    v106 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
    v105 = *v106;
    *(v104 + 296) = *v106;
  }

  v107 = *(v105 + 88);
  if (v107 > 0xB)
  {
    v108 = "";
  }

  else
  {
    v108 = off_1E7B3DE78[v107];
  }

  v109 = std::string::basic_string[abi:nn200100]<0>(&v194, v108);
  v110 = std::string::insert(v109, 0, " style:", 7uLL);
  v111 = *&v110->__r_.__value_.__l.__data_;
  v197 = v110->__r_.__value_.__r.__words[2];
  v196 = v111;
  v110->__r_.__value_.__l.__size_ = 0;
  v110->__r_.__value_.__r.__words[2] = 0;
  v110->__r_.__value_.__r.__words[0] = 0;
  if (v197 >= 0)
  {
    v112 = &v196;
  }

  else
  {
    v112 = v196;
  }

  if (v197 >= 0)
  {
    v113 = HIBYTE(v197);
  }

  else
  {
    v113 = *(&v196 + 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v112, v113);
  if (SHIBYTE(v197) < 0)
  {
    operator delete(v196);
  }

  if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v194.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " textSource:", 12);
  v114 = *(v43 + 80);
  v115 = *(v114 + 296);
  if (!v115)
  {
    v116 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
    v115 = *v116;
    *(v114 + 296) = *v116;
  }

  v117 = *(v115 + 90);
  if (v117 > 0xB)
  {
    v118 = "";
  }

  else
  {
    v118 = off_1E7B3DED8[v117];
  }

  std::string::basic_string[abi:nn200100]<0>(&v196, v118);
  if (v197 >= 0)
  {
    v119 = &v196;
  }

  else
  {
    v119 = v196;
  }

  if (v197 >= 0)
  {
    v120 = HIBYTE(v197);
  }

  else
  {
    v120 = *(&v196 + 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v119, v120);
  if (SHIBYTE(v197) < 0)
  {
    operator delete(v196);
  }

  v121 = *(v43 + 80);
  v122 = *(v121 + 296);
  if (!v122)
  {
    v123 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
    v122 = *v123;
    *(v121 + 296) = *v123;
  }

  v124 = *(v122 + 92) + 1;
  if (v124 > 0xAu)
  {
    v125 = "";
  }

  else
  {
    v125 = off_1E7B3DF38[v124];
  }

  v126 = std::string::basic_string[abi:nn200100]<0>(&v194, v125);
  v127 = std::string::insert(v126, 0, " size:", 6uLL);
  v128 = *&v127->__r_.__value_.__l.__data_;
  v197 = v127->__r_.__value_.__r.__words[2];
  v196 = v128;
  v127->__r_.__value_.__l.__size_ = 0;
  v127->__r_.__value_.__r.__words[2] = 0;
  v127->__r_.__value_.__r.__words[0] = 0;
  if (v197 >= 0)
  {
    v129 = &v196;
  }

  else
  {
    v129 = v196;
  }

  if (v197 >= 0)
  {
    v130 = HIBYTE(v197);
  }

  else
  {
    v130 = *(&v196 + 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v129, v130);
  if (SHIBYTE(v197) < 0)
  {
    operator delete(v196);
  }

  if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v194.__r_.__value_.__l.__data_);
  }

  v131 = md::LabelStyle::iconContentScale(*(v43 + 80));
  v132 = *(v43 + 80);
  if (v131 != *(v132 + 88))
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " scale:", 7);
    v133 = v185;
    *(&v185 + *(v185 - 24) + 8) = *(&v185 + *(v185 - 24) + 8) & 0xFFFFFEFB | 4;
    *(&v187[0].__locale_ + *(v133 - 24)) = 1;
    md::LabelStyle::iconContentScale(*(v43 + 80));
    std::ostream::operator<<();
    v132 = *(v43 + 80);
  }

  v134 = *(v132 + 296);
  if (!v134)
  {
    v135 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v132, 0);
    v134 = *v135;
    *(v132 + 296) = *v135;
  }

  if (*(v134 + 68))
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " MSrcKey:", 9);
    v136 = *(v43 + 80);
    v137 = *(v136 + 296);
    if (!v137)
    {
      v138 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
      v137 = *v138;
      *(v136 + 296) = *v138;
    }

    MEMORY[0x1B8C61C90](&v185, *(v137 + 68));
  }

  v139 = *(v43 + 80);
  v140 = *(v139 + 296);
  if (!v140)
  {
    v141 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
    v140 = *v141;
    *(v139 + 296) = *v141;
  }

  if (*(v140 + 64))
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " srcKey:", 8);
    v142 = *(v43 + 80);
    v143 = *(v142 + 296);
    if (!v143)
    {
      v144 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
      v143 = *v144;
      *(v142 + 296) = *v144;
    }

    MEMORY[0x1B8C61C90](&v185, *(v143 + 64));
  }

  v145 = *(v43 + 80);
  v146 = *(v145 + 272);
  if (!v146)
  {
    v147 = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>(*(v43 + 80));
    v146 = *v147;
    *(v145 + 272) = *v147;
  }

  if ((*(v146 + 103) & 0x8000000000000000) == 0)
  {
    if (!*(v146 + 103))
    {
      goto LABEL_211;
    }

LABEL_202:
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " name:", 6);
    v148 = *(v43 + 80);
    v149 = *(v148 + 272);
    if (!v149)
    {
      v150 = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>(*(v43 + 80));
      v149 = *v150;
      *(v148 + 272) = *v150;
    }

    v153 = *(v149 + 80);
    v151 = v149 + 80;
    v152 = v153;
    v154 = *(v151 + 23);
    if (v154 >= 0)
    {
      v155 = v151;
    }

    else
    {
      v155 = v152;
    }

    if (v154 >= 0)
    {
      v156 = *(v151 + 23);
    }

    else
    {
      v156 = *(v151 + 8);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v155, v156);
    goto LABEL_211;
  }

  if (*(v146 + 88))
  {
    goto LABEL_202;
  }

LABEL_211:
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
  v157 = *(*(v43 + 80) + 144);
  if (v157 > 0xB)
  {
    v158 = "";
  }

  else
  {
    v158 = off_1E7B3DED8[*(*(v43 + 80) + 144)];
  }

  v159 = std::string::basic_string[abi:nn200100]<0>(&v194, v158);
  v160 = std::string::insert(v159, 0, "  <text> source:", 0x10uLL);
  v161 = *&v160->__r_.__value_.__l.__data_;
  v197 = v160->__r_.__value_.__r.__words[2];
  v196 = v161;
  v160->__r_.__value_.__l.__size_ = 0;
  v160->__r_.__value_.__r.__words[2] = 0;
  v160->__r_.__value_.__r.__words[0] = 0;
  if (v197 >= 0)
  {
    v162 = &v196;
  }

  else
  {
    v162 = v196;
  }

  if (v197 >= 0)
  {
    v163 = HIBYTE(v197);
  }

  else
  {
    v163 = *(&v196 + 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v162, v163);
  if (SHIBYTE(v197) < 0)
  {
    operator delete(v196);
  }

  if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v194.__r_.__value_.__l.__data_);
  }

  v165 = (*(*(v43 + 80) + 250) & 0x10) == 0 && v157 != 6;
  if ((*(*(v43 + 80) + 250) & 8) != 0 || !v165)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " shieldThreshold:", 17);
    MEMORY[0x1B8C61C80](&v185, *(*(v43 + 80) + 160));
    if (!v165)
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, " icon-size:", 11);
      v166 = *(v43 + 80);
      v167 = *(v166 + 296);
      if (!v167)
      {
        v168 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*(v43 + 80), 0);
        v167 = *v168;
        *(v166 + 296) = *v168;
      }

      v169 = *(v167 + 93) + 1;
      if (v169 > 0xAu)
      {
        v170 = "";
      }

      else
      {
        v170 = off_1E7B3DF38[v169];
      }

      std::string::basic_string[abi:nn200100]<0>(&v196, v170);
      if (v197 >= 0)
      {
        v171 = &v196;
      }

      else
      {
        v171 = v196;
      }

      if (v197 >= 0)
      {
        v172 = HIBYTE(v197);
      }

      else
      {
        v172 = *(&v196 + 1);
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, v171, v172);
      if (SHIBYTE(v197) < 0)
      {
        operator delete(v196);
      }
    }
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v185, "\n", 1);
LABEL_247:
  if ((v192 & 0x10) != 0)
  {
    v175 = v191;
    if (v191 < v188)
    {
      v191 = v188;
      v175 = v188;
    }

    locale = v187[4].__locale_;
  }

  else
  {
    if ((v192 & 8) == 0)
    {
      v173 = 0;
      v174 = a5;
      a5[23] = 0;
      goto LABEL_260;
    }

    locale = v187[1].__locale_;
    v175 = v187[3].__locale_;
  }

  v173 = v175 - locale;
  if ((v175 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v173 >= 0x17)
  {
    operator new();
  }

  a5[23] = v173;
  if (v173)
  {
    v177 = locale;
    v174 = a5;
    memmove(a5, v177, v173);
  }

  else
  {
    v174 = a5;
  }

LABEL_260:
  v174[v173] = 0;
  v185 = *MEMORY[0x1E69E54E8];
  *(&v185 + *(v185 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v186 = MEMORY[0x1E69E5548] + 16;
  if (v190 < 0)
  {
    operator delete(__p);
  }

  v186 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v187);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](v193);
}

uint64_t md::PointLabelFeature::newPoint(uint64_t a1, unsigned int *a2, md::LabelPoint *a3)
{
  v3 = *(a1 + 440);
  if (!v3)
  {
    return 0;
  }

  v4 = *a2;
  v5 = a1 + 440;
  do
  {
    v6 = *(v3 + 32);
    v7 = v6 >= v4;
    v8 = v6 < v4;
    if (v7)
    {
      v5 = v3;
    }

    v3 = *(v3 + 8 * v8);
  }

  while (v3);
  if (v5 == a1 + 440 || v4 < *(v5 + 32))
  {
    return 0;
  }

  md::PointPosition::setLabelPoint(v5 + 40, a3);
  return 1;
}

uint64_t md::PointLabelFeature::didLiveMetadataChange(uint64_t a1, uint64_t a2)
{
  if (*(a1 + 695) == 1)
  {
    *(a1 + 695) = 0;
  }

  if (!a2)
  {
    v4 = 0;
    goto LABEL_34;
  }

  v3 = *(a2 + 24);
  v5 = *v3;
  v4 = *(v3 + 8);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (!v5 || (v6 = geo::codec::VectorTile::liveMetadataForID(v5, *(a1 + 472))) == 0)
  {
LABEL_34:
    if (*(a1 + 376))
    {
      *(a1 + 376) = 0;
      if ((*(a1 + 384) & 1) == 0)
      {
LABEL_39:
        if (*(a1 + 389) == 1)
        {
          *(a1 + 389) = 0;
        }

        v22 = 1;
        if (v4)
        {
          goto LABEL_62;
        }

        return v22;
      }
    }

    else if ((*(a1 + 384) & 1) == 0)
    {
      v22 = 0;
      if (!v4)
      {
        return v22;
      }

      goto LABEL_62;
    }

    *(a1 + 384) = 0;
    goto LABEL_39;
  }

  v7 = *v6;
  v8 = v6[1];
  if (*v6 == v8)
  {
    v13 = 0.0;
    v11 = 1;
    v12 = 0.0;
  }

  else
  {
    v9 = v5[82];
    v10 = *&v9 + 8;
    v11 = 1;
    v12 = 0.0;
    v13 = 0.0;
    do
    {
      v14 = *v7;
      v15 = *(v7 + 1);
      v16 = *(v7 + 4);
      if (*v7)
      {
        if (v14 == 1)
        {
          if (*(v7 + 4))
          {
            v17 = (v10 + 16 * v15);
            do
            {
              if ((*(a1 + 400) & *(v17 - 1)) != 0)
              {
                v18 = *v17;
              }

              else
              {
                v18 = 0.0;
              }

              v13 = v18 + v13;
              v17 += 4;
              --v16;
            }

            while (v16);
          }
        }

        else if (v14 == 2 && v16 != 0)
        {
          v11 = *(*&v9 + 16 * v15);
        }
      }

      else if (*(v7 + 4))
      {
        v19 = (v10 + 16 * v15);
        do
        {
          if ((*(a1 + 400) & *(v19 - 1)) != 0)
          {
            v20 = *v19;
          }

          else
          {
            v20 = 0.0;
          }

          v12 = v20 + v12;
          v19 += 4;
          --v16;
        }

        while (v16);
      }

      v7 += 12;
    }

    while (v7 != v8);
  }

  v23 = *(a1 + 376) == 1 && *(a1 + 372) == v13;
  if (v23 && *(a1 + 384) == 1 && *(a1 + 380) == v12 && *(a1 + 389) == 1 && *(a1 + 388) == v11)
  {
    v22 = 0;
    v13 = *(a1 + 372);
  }

  else
  {
    *(a1 + 372) = v13;
    v22 = 1;
    *(a1 + 376) = 1;
    *(a1 + 380) = v12;
    *(a1 + 384) = 1;
    *(a1 + 388) = v11 | 0x100;
  }

  if (v11 == 2)
  {
    v24 = 257;
  }

  else if (v13 == 0.0)
  {
    v24 = 258;
  }

  else
  {
    v24 = 259;
  }

  *(a1 + 694) = v24;
  if (v4)
  {
LABEL_62:
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  return v22;
}

void md::PointLabelFeature::updateText(md::PointLabelFeature *this, const void *a2, char a3)
{
  md::PointLabelFeature::updatePositions(this);
  *(this + 689) = a3;
  v5 = *(this + 66);
  v6 = *(this + 65);
  while (v5 != v6)
  {
    v5 -= 64;
    std::allocator_traits<geo::allocator_adapter<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,mdm::zone_mallocator>>::destroy[abi:nn200100]<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,void,0>(v5);
  }

  *(this + 66) = v6;
  v7 = *(this + 54);
  if (v7 != (this + 440))
  {
    do
    {
      v8 = *(v7 + 5);
      v9 = *(v7 + 6);
      if (v8 != v9)
      {
        v10 = *(this + 689);
        do
        {
          v11 = *v8++;
          v12 = (v11 + 8);
          if (v11)
          {
            v13 = v12;
          }

          else
          {
            v13 = 0;
          }

          md::PointLabelFeatureElement::updateText(v13, this, v10);
        }

        while (v8 != v9);
      }

      v14 = *(v7 + 1);
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          v15 = *(v7 + 2);
          v16 = *v15 == v7;
          v7 = v15;
        }

        while (!v16);
      }

      v7 = v15;
    }

    while (v15 != (this + 440));
  }
}

void std::vector<md::PointLabelFeature::WorkUnit,geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](mdm::zone_mallocator *a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v3 = v1[1];
    v4 = **a1;
    if (v3 != v2)
    {
      v5 = a1;
      do
      {
        v3 -= 48;
        a1 = std::__destroy_at[abi:nn200100]<md::PointLabelFeature::WorkUnit,0>(v3);
      }

      while (v3 != v2);
      v4 = **v5;
    }

    v1[1] = v2;
    v6 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::PointLabelFeature::WorkUnit>(v6, v4);
  }
}

void **std::__destroy_at[abi:nn200100]<md::PointLabelFeature::WorkUnit,0>(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  return geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::~fast_shared_ptr((a1 + 8));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::PointLabelFeature::WorkUnit>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void md::PointLabelFeature::~PointLabelFeature(md::PointLabelFeature *this)
{
  md::PointLabelFeature::~PointLabelFeature(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A564A0;
  if (md::DebugStreamingPOIFeatureID)
  {
    v2 = md::DebugStreamingPOIFeatureID == *(this + 59);
  }

  else
  {
    v2 = 0;
  }

  if (v2)
  {
    if (GEOGetVectorKitStreamingPOILog_onceToken != -1)
    {
      dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_69);
    }

    v3 = GEOGetVectorKitStreamingPOILog_log;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_1B2754000, v3, OS_LOG_TYPE_DEBUG, "PointLabelFeature::~PointLabelFeature", v6, 2u);
    }
  }

  v4 = *(this + 88);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  geo::small_vector_base<md::PointLabelStyleEntry>::~small_vector_base(this + 73);
  v6[0] = (this + 552);
  std::vector<md::LabelFeaturePlacementInfo,geo::allocator_adapter<md::LabelFeaturePlacementInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v6);
  v6[0] = (this + 520);
  std::vector<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,geo::allocator_adapter<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v6);
  *(this + 62) = &unk_1F2A567C0;

  v5 = *(this + 61);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::__tree<std::__value_type<md::LabelIdentifier,md::PointPosition>,std::__map_value_compare<md::LabelIdentifier,std::__value_type<md::LabelIdentifier,md::PointPosition>,std::less<md::LabelIdentifier>,true>,geo::allocator_adapter<std::__value_type<md::LabelIdentifier,md::PointPosition>,mdm::zone_mallocator>>::destroy(*(this + 55));
  v6[0] = (this + 320);
  std::vector<md::PointLabelFeature::WorkUnit,geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v6);
  std::mutex::~mutex((this + 248));
  md::LabelFeature::~LabelFeature(this);
}

uint64_t *geo::small_vector_base<md::PointLabelStyleEntry>::~small_vector_base(uint64_t *a1)
{
  geo::small_vector_base<md::PointLabelStyleEntry>::runDestructors(*a1, a1[1]);
  if (*a1 != a1[2])
  {
    free(*a1);
  }

  return a1;
}

void std::vector<md::LabelFeaturePlacementInfo,geo::allocator_adapter<md::LabelFeaturePlacementInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v3 = v1[1];
    v4 = **a1;
    if (v3 != v2)
    {
      v5 = a1;
      v6 = v1[1];
      do
      {
        v7 = *(v6 - 4);
        v6 -= 32;
        a1 = v7;
        if (v7)
        {
          *(v3 - 3) = a1;
          operator delete(a1);
        }

        v3 = v6;
      }

      while (v6 != v2);
      v4 = **v5;
    }

    v1[1] = v2;
    v8 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::LabelFeaturePlacementInfo>(v8, v4);
  }
}

uint64_t md::PointLabelFeatureElement::PointLabelFeatureElement(uint64_t a1, uint64_t a2, uint64_t *a3, char a4, char a5, char a6)
{
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  v12 = *(*a3 + 192);
  if (*(*a3 + 200) == v12)
  {
    md::LabelPoint::NullPoint(a1);
    v12 = &md::LabelPoint::NullPoint(void)::kNullLabelPoint;
  }

  v13 = *v12;
  *(a1 + 40) = *(v12 + 2);
  *(a1 + 24) = v13;
  *(a1 + 48) = *(v12 + 24);
  v14 = *(v12 + 10);
  *(a1 + 67) = *(v12 + 43);
  *(a1 + 64) = v14;
  *(a1 + 100) = 0;
  *(a1 + 104) = 0;
  *(a1 + 108) = 0;
  *(a1 + 128) = 0;
  *(a1 + 80) = 0;
  *(a1 + 88) = 0;
  *(a1 + 72) = 0;
  *(a1 + 96) = 0;
  *(a1 + 129) = a4;
  *(a1 + 130) = 255;
  *(a1 + 134) = a5;
  *(a1 + 135) = a6;
  *(a1 + 136) = 1;
  *(a1 + 138) = 0;
  v15 = *a3;
  *(a1 + 112) = *(*a3 + 232);
  v16 = *(v15 + 216);
  *(a1 + 100) = *(v15 + 220);
  *(a1 + 96) = v16;
  v17 = *(*a3 + 224);
  LOBYTE(v15) = *(*a3 + 228);
  *(a1 + 108) = v15;
  *(a1 + 104) = v17;
  if (v15 == 1)
  {
    md::LabelFeature::vectorFromAzimuth((a1 + 24), *(a1 + 104), *(a2 + 368));
    *(a1 + 116) = v18;
    *(a1 + 120) = v19;
    *(a1 + 124) = v20;
  }

  return a1;
}

mdm::zone_mallocator *std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::push_back[abi:nn200100](mdm::zone_mallocator *result, _BYTE *a2)
{
  v3 = result;
  v5 = *(result + 1);
  v4 = *(result + 2);
  if (v5 >= v4)
  {
    v7 = &v5[-*result];
    v8 = (v7 + 1);
    if ((v7 + 1) < 0)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v9 = v4 - *result;
    if (2 * v9 > v8)
    {
      v8 = 2 * v9;
    }

    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    v19[4] = result + 24;
    if (v10)
    {
      v11 = mdm::zone_mallocator::instance(result);
      v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v11, v10);
    }

    else
    {
      v12 = 0;
    }

    v13 = &v7[v12];
    *v13 = *a2;
    v6 = &v7[v12 + 1];
    v14 = v12 + v10;
    v15 = *(v3 + 1);
    v16 = &v13[*v3 - v15];
    memcpy(v16, *v3, v15 - *v3);
    v17 = *v3;
    *v3 = v16;
    *(v3 + 1) = v6;
    v18 = *(v3 + 2);
    *(v3 + 2) = v14;
    v19[2] = v17;
    v19[3] = v18;
    v19[0] = v17;
    v19[1] = v17;
    result = std::__split_buffer<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator> &>::~__split_buffer(v19);
  }

  else
  {
    *v5 = *a2;
    v6 = (v5 + 1);
  }

  *(v3 + 1) = v6;
  return result;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::_fast_shared_ptr_control>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x98uLL, 0x10600400F1BC7FBuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<md::PointLabelZoomPosition>>(unint64_t a1)
{
  if (!(a1 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

double std::__stable_sort<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  v40 = *MEMORY[0x1E69E9840];
  if (a3 >= 2)
  {
    v7 = a1;
    if (a3 == 2)
    {
      v8 = *(a2 - 32);
      v9 = *a1;
      if (v8 < v9)
      {
        v10 = 0;
        *v39 = *(a1 + 1);
        *&v39[15] = *(a1 + 1);
        *a1 = v8;
        v11 = a2 - 24;
        do
        {
          *&a1[v10 + 8] = *&v11[v10];
          v10 += 8;
        }

        while (v10 != 24);
        *(a2 - 32) = v9;
        a6.n128_u64[0] = *&v39[7];
        *v11 = *&v39[7];
        *(a2 - 1) = *&v39[23];
      }
    }

    else if (a3 <= 0)
    {
      if (a1 != a2)
      {
        v18 = a1 + 32;
        if (a1 + 32 != a2)
        {
          v19 = a1;
          do
          {
            v20 = v18;
            if (*v18 < *v19)
            {
              v21 = v18[1];
              *v39 = *v18;
              *&v39[16] = v21;
              LOBYTE(v22) = *v19;
              v23 = v18;
              while (1)
              {
                v24 = 0;
                v25 = v19;
                *v23 = v22;
                do
                {
                  *&v19[v24 + 40] = *&v19[v24 + 8];
                  v24 += 8;
                }

                while (v24 != 24);
                if (v19 == a1)
                {
                  break;
                }

                v19 -= 32;
                v22 = *(v25 - 32);
                v23 = v25;
                if (v39[0] >= v22)
                {
                  v26 = v25;
                  goto LABEL_24;
                }
              }

              v26 = a1;
LABEL_24:
              *v26 = v39[0];
              for (i = 8; i != 32; i += 8)
              {
                a6.n128_u64[0] = *&v39[i];
                *&v25[i] = a6.n128_u64[0];
              }
            }

            v18 = v20 + 2;
            v19 = v20;
          }

          while (v20 + 2 != a2);
        }
      }
    }

    else
    {
      v14 = a4;
      v15 = a3 >> 1;
      v16 = &a1[32 * (a3 >> 1)];
      v17 = a3 >> 1;
      if (a3 <= a5)
      {
        v28 = std::__stable_sort_move<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(a1, v16, v17, a4, a6);
        v29 = &v14[32 * v15];
        a6.n128_u64[0] = std::__stable_sort_move<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(&v7[32 * (a3 >> 1)], a2, a3 - (a3 >> 1), v29, v28).n128_u64[0];
        v30 = &v14[32 * a3];
        v31 = v29;
        while (v31 != v30)
        {
          v32 = *v31;
          v33 = *v14;
          if (v32 >= v33)
          {
            *v7 = v33;
            for (j = 8; j != 32; j += 8)
            {
              a6.n128_u64[0] = *&v14[j];
              *&v7[j] = a6.n128_u64[0];
            }

            v14 += 32;
          }

          else
          {
            *v7 = v32;
            for (k = 8; k != 32; k += 8)
            {
              a6.n128_u64[0] = *&v31[k];
              *&v7[k] = a6.n128_u64[0];
            }

            v31 += 32;
          }

          v7 += 32;
          if (v14 == v29)
          {
            while (v31 != v30)
            {
              *v7 = *v31;
              for (m = 8; m != 32; m += 8)
              {
                a6.n128_u64[0] = *&v31[m];
                *&v7[m] = a6.n128_u64[0];
              }

              v31 += 32;
              v7 += 32;
            }

            return a6.n128_f64[0];
          }
        }

        while (v14 != v29)
        {
          *v7 = *v14;
          for (n = 8; n != 32; n += 8)
          {
            a6.n128_u64[0] = *&v14[n];
            *&v7[n] = a6.n128_u64[0];
          }

          v14 += 32;
          v7 += 32;
        }
      }

      else
      {
        std::__stable_sort<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(a1, v16, v17, a4, a5);
        std::__stable_sort<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(&v7[32 * (a3 >> 1)], a2, a3 - (a3 >> 1), v14, a5);

        a6.n128_f64[0] = std::__inplace_merge<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(v7, &v7[32 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v14, a5);
      }
    }
  }

  return a6.n128_f64[0];
}

__n128 std::__stable_sort_move<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, __n128 result)
{
  if (a3)
  {
    v5 = a4;
    v8 = a1;
    if (a3 == 2)
    {
      v10 = (a2 - 32);
      if (*(a2 - 32) >= *a1)
      {
        v27 = *(a1 + 1);
        *a4 = *a1;
        *(a4 + 16) = v27;
        result = *v10;
        v12 = *(a2 - 1);
      }

      else
      {
        v11 = *(a2 - 1);
        *a4 = *v10;
        *(a4 + 16) = v11;
        result = *a1;
        v12 = *(a1 + 1);
      }

      *(a4 + 32) = result;
      *(a4 + 48) = v12;
    }

    else if (a3 == 1)
    {
      result = *a1;
      v9 = *(a1 + 1);
      *a4 = *a1;
      *(a4 + 16) = v9;
    }

    else if (a3 > 8)
    {
      v28 = &a1[32 * (a3 >> 1)];
      std::__stable_sort<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(a1, v28, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(&v8[32 * (a3 >> 1)], a2, a3 - (a3 >> 1), v5 + 32 * (a3 >> 1), a3 - (a3 >> 1));
      v29 = &v8[32 * (a3 >> 1)];
      while (v29 != a2)
      {
        if (*v29 >= *v8)
        {
          result = *v8;
          v30 = *(v8 + 1);
          v8 += 32;
        }

        else
        {
          result = *v29;
          v30 = *(v29 + 1);
          v29 += 32;
        }

        *v5 = result;
        *(v5 + 16) = v30;
        v5 += 32;
        if (v8 == v28)
        {
          while (v29 != a2)
          {
            result = *v29;
            v32 = *(v29 + 1);
            v29 += 32;
            *v5 = result;
            *(v5 + 16) = v32;
            v5 += 32;
          }

          return result;
        }
      }

      while (v8 != v28)
      {
        result = *v8;
        v31 = *(v8 + 1);
        v8 += 32;
        *v5 = result;
        *(v5 + 16) = v31;
        v5 += 32;
      }
    }

    else if (a1 != a2)
    {
      result = *a1;
      v13 = *(a1 + 1);
      *a4 = *a1;
      *(a4 + 16) = v13;
      v14 = a1 + 32;
      if (a1 + 32 != a2)
      {
        v15 = a4;
        v16 = a4;
        do
        {
          v17 = *v16;
          v16 += 2;
          if (*v14 >= v17)
          {
            result = *v14;
            v24 = *(v14 + 1);
            *v16 = *v14;
            v16[1] = v24;
          }

          else
          {
            v18 = v15[1];
            *v16 = *v15;
            v16[1] = v18;
            v19 = a4;
            if (v15 != a4)
            {
              v20 = v15;
              while (1)
              {
                v22 = *(v20 - 32);
                v20 -= 2;
                v21 = v22;
                if (*v14 >= v22)
                {
                  break;
                }

                v23 = 0;
                *v15 = v21;
                do
                {
                  *(v15 + v23 + 8) = *(v15 + v23 - 24);
                  v23 += 8;
                }

                while (v23 != 24);
                v15 = v20;
                if (v20 == a4)
                {
                  v19 = a4;
                  goto LABEL_21;
                }
              }

              v19 = v15;
            }

LABEL_21:
            *v19 = *v14;
            v25 = v19 + 8;
            for (i = 5; i != 8; ++i)
            {
              result.n128_u64[0] = *&v8[8 * i];
              *v25++ = result.n128_u64[0];
            }
          }

          v14 += 32;
          v8 += 32;
          v15 = v16;
        }

        while (v14 != a2);
      }
    }
  }

  return result;
}

double std::__inplace_merge<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, _BYTE *a6, uint64_t a7)
{
  if (a5)
  {
    v8 = a5;
    while (v8 > a7 && a4 > a7)
    {
      if (!a4)
      {
        return *&v38;
      }

      v12 = *a2;
      while (1)
      {
        v13 = *a1;
        if (v12 < v13)
        {
          break;
        }

        a1 += 32;
        if (!--a4)
        {
          return *&v38;
        }
      }

      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *&v71[15] = *(a1 + 1);
          *v71 = *(a1 + 1);
          *a1 = v12;
          for (i = 8; i != 32; i += 8)
          {
            *&a1[i] = *&a2[i];
          }

          *a2 = v13;
          *&v38 = *&v71[7];
          *(a2 + 8) = *&v71[7];
          *(a2 + 3) = *&v71[23];
          return *&v38;
        }

        v22 = a4 / 2;
        v16 = &a1[32 * (a4 / 2)];
        v15 = a2;
        if (a2 != a3)
        {
          v23 = (a3 - a2) >> 5;
          v15 = a2;
          do
          {
            v24 = v23 >> 1;
            v25 = &v15[32 * (v23 >> 1)];
            v27 = *v25;
            v26 = v25 + 32;
            v23 += ~(v23 >> 1);
            if (v27 < *v16)
            {
              v15 = v26;
            }

            else
            {
              v23 = v24;
            }
          }

          while (v23);
        }

        v14 = (v15 - a2) >> 5;
      }

      else
      {
        v14 = v8 / 2;
        v15 = &a2[32 * (v8 / 2)];
        v16 = a2;
        if (a2 != a1)
        {
          v17 = (a2 - a1) >> 5;
          v16 = a1;
          do
          {
            v18 = v17 >> 1;
            v19 = &v16[32 * (v17 >> 1)];
            v21 = *v19;
            v20 = v19 + 32;
            v17 += ~(v17 >> 1);
            if (*v15 < v21)
            {
              v17 = v18;
            }

            else
            {
              v16 = v20;
            }
          }

          while (v17);
        }

        v22 = (v16 - a1) >> 5;
      }

      v28 = v15;
      if (v16 != a2)
      {
        v28 = v16;
        if (a2 != v15)
        {
          v28 = v16;
          for (j = a2; ; j += 32)
          {
            v30 = *v28;
            *v69 = *(v28 + 1);
            *&v69[15] = *(v28 + 1);
            *v28 = v12;
            for (k = 8; k != 32; k += 8)
            {
              *&v28[k] = *&j[k];
            }

            *j = v30;
            *(j + 8) = *&v69[7];
            *(j + 3) = *&v69[23];
            v28 += 32;
            if (j + 32 == v15)
            {
              break;
            }

            if (v28 == a2)
            {
              a2 = j + 32;
            }

            LOBYTE(v12) = j[32];
          }

          if (v28 != a2)
          {
            v32 = v28;
            v33 = a2;
            do
            {
              while (1)
              {
                v34 = *v32;
                *&v70[15] = *(v32 + 1);
                *v70 = *(v32 + 1);
                v35 = v33 + 8;
                *v32 = *v33;
                for (m = 8; m != 32; m += 8)
                {
                  *&v32[m] = *&v33[m];
                }

                *v33 = v34;
                v33 += 32;
                *(v35 + 2) = *&v70[23];
                *v35 = *&v70[7];
                v32 += 32;
                if (v33 == v15)
                {
                  break;
                }

                if (v32 == a2)
                {
                  a2 = v33;
                }
              }

              v33 = a2;
            }

            while (v32 != a2);
          }
        }
      }

      a4 -= v22;
      v8 -= v14;
      if (v22 + v14 >= a4 + v8)
      {
        v39 = a3;
        v40 = v22;
        v41 = a4;
        v42 = v14;
        v37 = a7;
        std::__inplace_merge<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(v28, v15, v39, v41, v8, a6);
        v15 = v16;
        v8 = v42;
        a4 = v40;
        a3 = v28;
      }

      else
      {
        v37 = a7;
        std::__inplace_merge<std::_RangeAlgPolicy,md::PointPosition::zoomPositions(BOOL)::$_0 &,std::__wrap_iter<md::PointLabelZoomPosition *>>(a1, v16, v28, v22, v14, a6);
        a1 = v28;
      }

      a2 = v15;
      a7 = v37;
      if (!v8)
      {
        return *&v38;
      }
    }

    if (a4 <= v8)
    {
      if (a2 != a1)
      {
        v56 = a6;
        v57 = a1;
        do
        {
          v58 = v56;
          v59 = *v57;
          v60 = *(v57 + 1);
          v57 += 32;
          *v56 = v59;
          v56[1] = v60;
          v56 += 2;
        }

        while (v57 != a2);
        while (a2 != a3)
        {
          v61 = *a2;
          v62 = *a6;
          if (v61 >= v62)
          {
            *a1 = v62;
            for (n = 8; n != 32; n += 8)
            {
              *&v38 = *&a6[n];
              *&a1[n] = v38;
            }

            a6 += 32;
          }

          else
          {
            *a1 = v61;
            for (ii = 8; ii != 32; ii += 8)
            {
              *&v38 = *&a2[ii];
              *&a1[ii] = v38;
            }

            a2 += 32;
          }

          a1 += 32;
          if (a6 == v56)
          {
            return *&v38;
          }
        }

        do
        {
          *a1 = *a6;
          for (jj = 8; jj != 32; jj += 8)
          {
            *&v38 = *&a6[jj];
            *&a1[jj] = v38;
          }

          a1 += 32;
          v66 = a6 == v58;
          a6 += 32;
        }

        while (!v66);
      }
    }

    else if (a2 != a3)
    {
      v43 = a6;
      v44 = a2;
      do
      {
        v38 = *v44;
        v45 = *(v44 + 1);
        v44 += 32;
        *v43 = v38;
        v43[1] = v45;
        v43 += 2;
      }

      while (v44 != a3);
      while (a2 != a1)
      {
        v46 = *(a2 - 32);
        v47 = v43 - 2;
        v48 = *(v43 - 32);
        v49 = a3 - 32;
        if (v48 >= v46)
        {
          *v49 = v48;
          v51 = -24;
          do
          {
            *&v38 = *(v43 + v51);
            *&a3[v51] = v38;
            v51 += 8;
          }

          while (v51);
          v43 -= 2;
        }

        else
        {
          *v49 = v46;
          v50 = -24;
          do
          {
            *&v38 = *&a2[v50];
            *&a3[v50] = v38;
            v50 += 8;
          }

          while (v50);
          a2 -= 32;
          v47 = v43;
        }

        a3 -= 32;
        if (v47 == a6)
        {
          return *&v38;
        }
      }

      if (v43 != a6)
      {
        v52 = v43;
        v53 = a3;
        do
        {
          v54 = *(v52 - 32);
          v52 -= 2;
          *(v53 - 32) = v54;
          v53 -= 32;
          v55 = -24;
          do
          {
            *&v38 = *(v43 + v55);
            *&a3[v55] = v38;
            v55 += 8;
          }

          while (v55);
          v43 = v52;
          a3 = v53;
        }

        while (v52 != a6);
      }
    }
  }

  return *&v38;
}

uint64_t md::PointLabelFeature::PointLabelFeature(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, int a5)
{
  v7 = a2;
  v113 = *MEMORY[0x1E69E9840];
  v9 = a1 + 369;
  v10 = *(*a2 + 192);
  if (*(*a2 + 200) == v10)
  {
    md::LabelPoint::NullPoint(a1);
    v10 = &md::LabelPoint::NullPoint(void)::kNullLabelPoint;
  }

  *(a1 + 16) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 112) = 0;
  *(a1 + 128) = 0x100000000;
  *(a1 + 136) = 0;
  *(a1 + 141) = 0;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0u;
  *a1 = &unk_1F2A48440;
  *(a1 + 8) = 850045863;
  v11 = *v10;
  *(a1 + 208) = *(v10 + 2);
  *(a1 + 192) = v11;
  *(a1 + 216) = *(v10 + 24);
  v12 = *(v10 + 10);
  *(a1 + 235) = *(v10 + 43);
  *(a1 + 232) = v12;
  *(a1 + 240) = 0;
  *(a1 + 242) = *(v10 + 10) != 3.4028e38;
  *(a1 + 243) = -256;
  *a1 = &unk_1F2A564A0;
  *(a1 + 248) = 850045863;
  *(a1 + 328) = 0;
  *(a1 + 336) = 0;
  *(a1 + 320) = 0;
  *(a1 + 256) = 0u;
  *(a1 + 272) = 0u;
  *(a1 + 288) = 0u;
  *(a1 + 297) = 0u;
  *(a1 + 352) = *(*v7 + 184);
  *(a1 + 360) = 0;
  *(a1 + 368) = *(*(a4 + 232) + 17) ^ 1;
  *(a1 + 376) = 0;
  *(a1 + 380) = 0;
  *(a1 + 384) = 0;
  *(a1 + 388) = 0;
  *(a1 + 392) = 0;
  *(a1 + 456) = 0;
  *v9 = 0;
  *(a1 + 424) = 0;
  *(a1 + 408) = 0;
  *(a1 + 416) = 0;
  *(a1 + 400) = 0;
  *(a1 + 432) = a1 + 440;
  *(a1 + 440) = 0;
  *(a1 + 464) = 1;
  v13 = *v7;
  *(a1 + 472) = *(*v7 + 16);
  *(a1 + 480) = v13;
  v14 = v7[1];
  *(a1 + 488) = v14;
  if (v14)
  {
    atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 496) = &unk_1F2A567C0;
  *(a1 + 504) = 0;
  *(a1 + 520) = 0;
  *(a1 + 536) = 0;
  *(a1 + 528) = 0;
  *(a1 + 552) = 0;
  *(a1 + 568) = 0;
  *(a1 + 560) = 0;
  *(a1 + 584) = a1 + 616;
  *(a1 + 592) = a1 + 616;
  *(a1 + 600) = a1 + 616;
  *(a1 + 608) = 1;
  v15 = *v7;
  *(v9 + 279) = *(*v7 + 248);
  *(a1 + 664) = *(v15 + 264);
  *(a1 + 672) = *(v15 + 272);
  *(a1 + 680) = *(v15 + 280);
  *(a1 + 682) = 0;
  *(a1 + 684) = 0;
  v16 = *v7;
  *(a1 + 686) = *(*v7 + 282);
  *(a1 + 687) = 0;
  v17 = 1;
  if ((*(v16 + 237) & 1) == 0)
  {
    v17 = *(v16 + 248) != 0;
  }

  *(a1 + 688) = v17;
  *(a1 + 689) = 1;
  v18 = (v9 + 327);
  *(a1 + 694) = 0;
  *(a1 + 690) = 0;
  v19 = *v7;
  v20 = *(*v7 + 32);
  *(a1 + 696) = v20;
  v21 = *(v19 + 40);
  *(a1 + 704) = v21;
  if (v21)
  {
    atomic_fetch_add_explicit((v21 + 8), 1uLL, memory_order_relaxed);
    v20 = *v18;
  }

  if (!v20)
  {
    _ZNSt3__115allocate_sharedB8nn200100I22FeatureStyleAttributesNS_9allocatorIS1_EEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_();
  }

  if (a5)
  {
    v98 = xmmword_1B34182D8;
    v99 = unk_1B34182E8;
    v100 = xmmword_1B34182F8;
    std::vector<GeoCodecsFeatureStylePair,geo::allocator_adapter<GeoCodecsFeatureStylePair,geo::mallocator>>::vector[abi:nn200100](&v110, &v98, 6uLL);
    std::allocate_shared[abi:nn200100]<FeatureStyleAttributes,std::allocator<FeatureStyleAttributes>,std::vector<GeoCodecsFeatureStylePair,geo::allocator_adapter<GeoCodecsFeatureStylePair,geo::mallocator>> &,0>();
  }

  v22 = *v18;
  if (!*v18 || (v23 = *(v22 + 33), !*(v22 + 33)))
  {
LABEL_24:
    v87 = 0;
    *(a1 + 240) = 0;
    goto LABEL_25;
  }

  v24 = *v22;
  if (*v24 != 65572)
  {
    v25 = 0;
    v27 = v24 + 2;
    while (v23 - 1 != v25)
    {
      v28 = *v27;
      v27 += 2;
      ++v25;
      if (v28 == 65572)
      {
        if (v25 < v23)
        {
          goto LABEL_17;
        }

        goto LABEL_24;
      }
    }

    goto LABEL_24;
  }

  v25 = 0;
LABEL_17:
  v26 = LOWORD(v24[2 * v25 + 1]) == 1;
  *(a1 + 240) = v26;
  v87 = v26 && *(a4 + 184) != 0;
LABEL_25:
  *(a1 + 241) = v87;
  v29 = *v7;
  v94 = 0;
  v95 = 0;
  v93 = 0;
  std::vector<double>::resize(&v93, 0xAAAAAAAAAAAAAAABLL * ((*(v29 + 200) - *(v29 + 192)) >> 4));
  v31 = v93;
  v32 = v94;
  if (v93 != v94)
  {
    v33 = 0;
    v34 = (v94 - v93 - 8) >> 3;
    v35 = vdupq_n_s64(v34);
    v36 = (v34 + 2) & 0x3FFFFFFFFFFFFFFELL;
    v37 = xmmword_1B33B0560;
    v38 = vdupq_n_s64(2uLL);
    do
    {
      v39 = vmovn_s64(vcgeq_u64(v35, v37));
      if (v39.i8[0])
      {
        v31[v33] = v33;
      }

      if (v39.i8[4])
      {
        v31[v33 + 1] = v33 + 1;
      }

      v33 += 2;
      v37 = vaddq_s64(v37, v38);
    }

    while (v36 != v33);
    v91 = v7;
    v88 = v32;
    do
    {
      v40 = *v31;
      v41 = *(a1 + 464);
      *(a1 + 464) = v41 + 1;
      v92 = v41;
      v98 = 0uLL;
      *&v99 = 0;
      v42 = *(*v7 + 192);
      if (0xAAAAAAAAAAAAAAABLL * ((*(*v7 + 200) - v42) >> 4) <= v40)
      {
        md::LabelPoint::NullPoint(v30);
        v43 = &md::LabelPoint::NullPoint(void)::kNullLabelPoint;
      }

      else
      {
        v43 = (v42 + 48 * v40);
      }

      v44 = *v43;
      v101 = *(v43 + 2);
      v100 = v44;
      v102 = *(v43 + 24);
      v45 = *(v43 + 10);
      *(v103 + 3) = *(v43 + 43);
      v103[0] = v45;
      v104 = 0uLL;
      v105 = -3162570752;
      v106 = 0;
      (*(*a1 + 600))(&v110, a1, 1);
      HIDWORD(v105) = md::PointLabelFeature::styleIndexForAttributes(a1, &v110);
      v46 = v111;
      if (v111)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v111);
      }

      v47 = *v7;
      LODWORD(v105) = *(*v7 + 80);
      v48 = 72;
      if (*(v47 + 112))
      {
        v48 = 76;
      }

      v49 = (v47 + v48);
      v50 = vld1q_dup_f32(v49);
      v104 = v50;
      BYTE1(v106) = v103[0] != 3.4028e38;
      v52 = *(v47 + 48);
      v51 = *(v47 + 56);
      if (v52 != v51)
      {
        v53 = 0;
        v110 = 0;
        v111 = 0;
        v112 = 0;
        v107 = 0;
        v108 = 0;
        v109 = 0;
        v97 = 0;
        do
        {
          if (!v52[1])
          {
            std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::push_back[abi:nn200100](&v107, &v97);
            std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::push_back[abi:nn200100](&v110, v52);
          }

          v97 = ++v53;
          v52 += 104;
        }

        while (v52 != v51);
        v54 = *(v47 + 376);
        v55 = *(v47 + 384);
        if (v54 != v55)
        {
          v56 = **(v47 + 48);
          v57 = v54 + 26;
          do
          {
            if (*v57 >= v56)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::push_back[abi:nn200100](&v110, v57);
            }

            v58 = v57 + 6;
            v57 += 32;
          }

          while (v58 != v55);
        }

        v59 = std::__sort<std::__less<unsigned char,unsigned char> &,unsigned char *>();
        v60 = v111;
        if (v110 != v111)
        {
          v61 = (v110 + 1);
          while (v61 != v111)
          {
            shared_weak_owners_high = HIBYTE(v61[-1].__shared_weak_owners_);
            v63 = LOBYTE(v61->__vftable);
            v61 = (v61 + 1);
            if (shared_weak_owners_high == v63)
            {
              v64 = (v61 - 2);
              goto LABEL_56;
            }
          }

          v64 = v111;
LABEL_56:
          if (v64 != v111)
          {
            v65 = (&v64->__vftable + 2);
            if ((&v64->__vftable + 2) != v111)
            {
              v66 = LOBYTE(v64->__vftable);
              do
              {
                v67 = v66;
                v66 = LOBYTE(v65->__vftable);
                if (v67 != v66)
                {
                  BYTE1(v64->__vftable) = v66;
                  v64 = (v64 + 1);
                }

                v65 = (v65 + 1);
              }

              while (v65 != v60);
              v60 = v111;
            }

            if ((&v64->__vftable + 1) != v60)
            {
              v60 = (&v64->__vftable + 1);
              v111 = (&v64->__vftable + 1);
            }
          }
        }

        v89 = v31;
        if (v107 == v108)
        {
          v68 = 0;
        }

        else
        {
          v68 = *v107;
        }

        v69 = v110;
        if (v110 != v60)
        {
          v70 = 0;
          v71 = 0;
          do
          {
            v72 = *v69;
            v73 = v70 + 1;
            v74 = *(v47 + 376);
            v75 = *(v47 + 384) - v74;
            if (v73 < v75 >> 5)
            {
              v76 = v75 >> 5;
              do
              {
                if (*(v74 + 32 * v73 + 26) > v72)
                {
                  break;
                }

                v73 = ++v70 + 1;
              }

              while (v73 < v76);
            }

            for (i = v71 + 1; i < v108 - v107; i = v71 + 1)
            {
              if (*(*(v47 + 48) + 104 * v107[i]) > v72)
              {
                break;
              }

              v68 = v107[++v71];
            }

            v96 = 0;
            v78 = mdm::zone_mallocator::instance(v59);
            v79 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::_fast_shared_ptr_control>(v78);
            v96 = v79;
            *v79 = 1;
            md::PointLabelFeatureElement::PointLabelFeatureElement((v79 + 1), a1, v91, v72, v68, v70);
            v96 = v79;
            md::PointLabelFeatureElement::updateText((v79 + 1), a1, a3);
            if (v96)
            {
              v80 = (v96 + 1);
            }

            else
            {
              v80 = 0;
            }

            md::PointLabelFeatureElement::updateLabelPlacements(v80, a1);
            std::vector<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,geo::allocator_adapter<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,mdm::zone_mallocator>>::push_back[abi:nn200100](&v98, &v96);
            v59 = geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::~fast_shared_ptr(&v96);
            v69 = (v69 + 1);
          }

          while (v69 != v60);
        }

        std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v107);
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v110);
        v7 = v91;
        v32 = v88;
        v31 = v89;
      }

      if (v98 == *(&v98 + 1))
      {
        v81 = 72;
        if (*(*v7 + 112))
        {
          v81 = 76;
        }

        v82 = *(*v7 + v81);
        v110 = 0;
        v83 = mdm::zone_mallocator::instance(v46);
        v84 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::_fast_shared_ptr_control>(v83);
        v110 = v84;
        *v84 = 1;
        md::PointLabelFeatureElement::PointLabelFeatureElement(v84 + 8, a1, v7, v82, 0, 0);
        v110 = v84;
        md::PointLabelFeatureElement::updateText((v84 + 8), a1, a3);
        if (v110)
        {
          v85 = (v110 + 8);
        }

        else
        {
          v85 = 0;
        }

        md::PointLabelFeatureElement::updateLabelPlacements(v85, a1);
        std::vector<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,geo::allocator_adapter<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,mdm::zone_mallocator>>::push_back[abi:nn200100](&v98, &v110);
        geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>::~fast_shared_ptr(&v110);
      }

      std::__tree<std::__value_type<md::LabelIdentifier,md::PointPosition>,std::__map_value_compare<md::LabelIdentifier,std::__value_type<md::LabelIdentifier,md::PointPosition>,std::less<md::LabelIdentifier>,true>,geo::allocator_adapter<std::__value_type<md::LabelIdentifier,md::PointPosition>,mdm::zone_mallocator>>::__emplace_unique_key_args<md::LabelIdentifier,md::LabelIdentifier,md::PointPosition>((a1 + 432), v92, &v92, &v98);
      v110 = &v98;
      std::vector<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,geo::allocator_adapter<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::allocator>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v110);
      ++v31;
    }

    while (v31 != v32);
    v31 = v93;
  }

  if (v31)
  {
    operator delete(v31);
  }

  return a1;
}

void sub_1B32D50B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  v24 = *(v22 + 704);
  if (v24)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v24);
  }

  geo::small_vector_base<md::PointLabelStyleEntry>::~small_vector_base((v22 + 584));
  a21 = v22 + 552;
  std::vector<md::LabelFeaturePlacementInfo,geo::allocator_adapter<md::LabelFeaturePlacementInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a21);
  a21 = v22 + 520;
  std::vector<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,geo::allocator_adapter<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a21);
  *(v22 + 496) = a10;

  v25 = *(v22 + 488);
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v25);
  }

  std::__tree<std::__value_type<md::LabelIdentifier,md::PointPosition>,std::__map_value_compare<md::LabelIdentifier,std::__value_type<md::LabelIdentifier,md::PointPosition>,std::less<md::LabelIdentifier>,true>,geo::allocator_adapter<std::__value_type<md::LabelIdentifier,md::PointPosition>,mdm::zone_mallocator>>::destroy(*(v22 + 440));
  a21 = v22 + 320;
  std::vector<md::PointLabelFeature::WorkUnit,geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a21);
  std::mutex::~mutex(a9);
  md::LabelFeature::~LabelFeature(v22);
  _Unwind_Resume(a1);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<md::PointLabelFeature::WorkUnit>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 48 * a2, 0x10200405C56A57CuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void **std::__uninitialized_allocator_relocate[abi:nn200100]<geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator>,md::PointLabelFeature::WorkUnit*>(void **result, void **a2, uint64_t a3)
{
  if (result != a2)
  {
    v4 = result;
    v5 = result;
    do
    {
      *a3 = *v5;
      *(a3 + 8) = 0;
      *(a3 + 8) = *(v5 + 1);
      *(a3 + 24) = v5[3];
      v5[2] = 0;
      v5[3] = 0;
      v5[1] = 0;
      *(a3 + 32) = *(v5 + 2);
      v5 += 6;
      a3 += 48;
    }

    while (v5 != a2);
    do
    {
      result = std::__destroy_at[abi:nn200100]<md::PointLabelFeature::WorkUnit,0>(v4);
      v4 += 48;
    }

    while (v4 != a2);
  }

  return result;
}

mdm::zone_mallocator *std::__split_buffer<md::PointLabelFeature::WorkUnit,geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator> &>::~__split_buffer(mdm::zone_mallocator *a1)
{
  v1 = a1;
  v3 = *(a1 + 1);
  for (i = *(a1 + 2); i != v3; i = *(v1 + 2))
  {
    *(v1 + 2) = i - 6;
    a1 = std::__destroy_at[abi:nn200100]<md::PointLabelFeature::WorkUnit,0>((i - 6));
  }

  v4 = *v1;
  if (*v1)
  {
    v5 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::PointLabelFeature::WorkUnit>(v5, v4);
  }

  return v1;
}

uint64_t std::construct_at[abi:nn200100]<md::PointLabelFeature::WorkUnit,std::shared_ptr<geo::codec::VectorTile> &,md::PointLabelFeature::WorkUnit*>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *a1 = 1;
    *(a1 + 8) = 0;
    *(a1 + 16) = a2;
    *(a1 + 24) = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(a1 + 32) = 0;
    *(a1 + 40) = 0;
    std::__shared_weak_count::__release_shared[abi:nn200100](a3);
  }

  else
  {
    *a1 = 1;
    *(a1 + 8) = 0;
    *(a1 + 16) = a2;
    *(a1 + 24) = 0;
    *(a1 + 32) = 0;
    *(a1 + 40) = 0;
  }

  return a1;
}

void md::PointLabelFeature::setPOIUpdateRemoveVersion(md::PointLabelFeature *this, uint64_t a2)
{
  std::mutex::lock((this + 248));
  v5 = *(this + 41);
  v6 = *(this + 42);
  if (v5 >= v6)
  {
    v8 = *(this + 40);
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 4);
    v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v11 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v8) >> 4);
    if (2 * v11 > v10)
    {
      v10 = 2 * v11;
    }

    if (v11 >= 0x2AAAAAAAAAAAAAALL)
    {
      v12 = 0x555555555555555;
    }

    else
    {
      v12 = v10;
    }

    v24 = this + 344;
    if (v12)
    {
      v13 = mdm::zone_mallocator::instance(v4);
      v14 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<md::PointLabelFeature::WorkUnit>(v13, v12);
    }

    else
    {
      v14 = 0;
    }

    v15 = &v14[48 * v9];
    *(&v23 + 1) = &v14[48 * v12];
    *v15 = 2;
    *(v15 + 2) = 0;
    *(v15 + 3) = 0;
    *(v15 + 1) = 0;
    v15[32] = 0;
    *(v15 + 5) = a2;
    *&v23 = v15 + 48;
    v16 = *(this + 40);
    v17 = *(this + 41);
    v18 = &v15[v16 - v17];
    std::__uninitialized_allocator_relocate[abi:nn200100]<geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator>,md::PointLabelFeature::WorkUnit*>(v16, v17, v18);
    v19 = *(this + 40);
    *(this + 40) = v18;
    v20 = *(this + 42);
    v21 = v23;
    *(this + 328) = v23;
    *&v23 = v19;
    *(&v23 + 1) = v20;
    v22[0] = v19;
    v22[1] = v19;
    std::__split_buffer<md::PointLabelFeature::WorkUnit,geo::allocator_adapter<md::PointLabelFeature::WorkUnit,mdm::zone_mallocator> &>::~__split_buffer(v22);
    v7 = v21;
  }

  else
  {
    *v5 = 2;
    *(v5 + 16) = 0;
    *(v5 + 24) = 0;
    *(v5 + 8) = 0;
    *(v5 + 32) = 0;
    v7 = v5 + 48;
    *(v5 + 40) = a2;
  }

  *(this + 41) = v7;
  atomic_store(1u, this + 312);
  std::mutex::unlock((this + 248));
}

void sub_1B32D56DC(_Unwind_Exception *a1)
{
  if (*(v2 - 49) < 0)
  {
    operator delete(*(v2 - 72));
  }

  _Unwind_Resume(a1);
}

double md::GeocentricFrame::_updateMatrix(float64x2_t *this)
{
  v2 = 0;
  v3 = *this;
  v86 = vsubq_f64(this[1], *this);
  v87 = 0;
  v4 = 0.0;
  do
  {
    v4 = v4 + v86.f64[v2] * v86.f64[v2];
    ++v2;
  }

  while (v2 != 3);
  v5 = 0;
  v6 = 1.0 / sqrt(v4);
  do
  {
    *(v111 + v5 * 8) = v86.f64[v5] * v6;
    ++v5;
  }

  while (v5 != 3);
  v7 = 0;
  v8 = v111[0];
  v9 = *&v111[1];
  v83 = v3;
  v84 = 0;
  do
  {
    *(v111 + v7 * 8) = -v83.f64[v7];
    ++v7;
  }

  while (v7 != 3);
  v10 = 0;
  v11 = *&v111[1];
  v12 = v111[0];
  memset(&v111[2] + 8, 0, 40);
  memset(v111 + 8, 0, 32);
  *&v111[0] = 0x3FF0000000000000;
  *(&v111[2] + 1) = 0x3FF0000000000000;
  v112 = 0x3FF0000000000000uLL;
  v114.f64[1] = 1.0;
  v113 = v12;
  v114.f64[0] = v11;
  v104 = 0u;
  v106 = 0;
  v109 = 0u;
  v108 = 0u;
  v105 = 0u;
  v103 = 0u;
  v102 = 0u;
  v110 = 0x3FF0000000000000;
  v101 = v6;
  *&v104 = v6;
  v107 = v6;
  v89 = v8;
  v92 = -*(&v8 + 1);
  v93 = *&v8;
  v90 = v9;
  v94 = v9;
  v97 = xmmword_1B33B0740;
  v91 = 0;
  v95 = 0;
  v96 = 0.0;
  v98 = 0u;
  v100 = 0x3FF0000000000000;
  v13 = v85;
  v14 = &v89;
  v99 = 0u;
  do
  {
    v15 = 0;
    v16 = v14;
    do
    {
      v17 = *v16;
      v16 += 4;
      *&v13[v15++] = v17;
    }

    while (v15 != 4);
    ++v10;
    v13 += 4;
    v14 = (v14 + 8);
  }

  while (v10 != 4);
  v18 = 0;
  v19 = &v101;
  do
  {
    v20 = 0;
    v21 = v85;
    do
    {
      v22 = 0;
      v23 = 0.0;
      v24 = v19;
      do
      {
        v25 = *v24;
        v24 += 4;
        v23 = v23 + v21[v22++] * v25;
      }

      while (v22 != 4);
      v88[4 * v20++ + v18] = v23;
      v21 += 4;
    }

    while (v20 != 4);
    ++v18;
    ++v19;
  }

  while (v18 != 4);
  v26 = 0;
  v27 = v88;
  do
  {
    v28 = 0;
    v29 = v111;
    do
    {
      v30 = 0;
      v31 = 0.0;
      v32 = v27;
      do
      {
        v33 = *v32;
        v32 += 4;
        v31 = v31 + *(v29 + v30) * v33;
        v30 += 8;
      }

      while (v30 != 32);
      *&v82[4 * v28++ + v26] = v31;
      v29 += 2;
    }

    while (v28 != 4);
    ++v26;
    ++v27;
  }

  while (v26 != 4);
  v34 = gm::Matrix<double,3,1>::normalized<int,void>(&this[2]);
  for (i = 0; i != 3; ++i)
  {
    *(v111 + i * 8) = this[3].f64[i + 1] - this[2].f64[i];
  }

  v38 = 0;
  v86 = v111[0];
  v87 = *&v111[1];
  v39 = 0.0;
  do
  {
    v39 = v39 + v86.f64[v38] * v86.f64[v38];
    ++v38;
  }

  while (v38 != 3);
  v40 = 0;
  v41 = sqrt(v39);
  v42 = this[2].f64[0];
  v43 = this[2].f64[1];
  v44 = this[3].f64[0];
  do
  {
    *(v111 + v40 * 8) = v86.f64[v40] * (1.0 / v41);
    ++v40;
  }

  while (v40 != 3);
  v45 = v111[0];
  v46 = *&v111[1];
  v47 = -(*(v111 + 1) * v36 - *&v111[1] * v35);
  v48 = -(*&v111[1] * v34 - *v111 * v36);
  v49 = -(*v111 * v35 - *(v111 + 1) * v34);
  *v111 = v47;
  *(v111 + 1) = v48;
  *&v111[1] = v49;
  v50 = gm::Matrix<double,3,1>::normalized<int,void>(v111);
  v51 = 0;
  memset(&v111[2] + 8, 0, 40);
  memset(v111 + 8, 0, 32);
  *&v111[0] = 0x3FF0000000000000;
  *(&v111[2] + 1) = 0x3FF0000000000000;
  v112 = 0x3FF0000000000000uLL;
  v114.f64[1] = 1.0;
  v113.f64[0] = v42;
  v113.f64[1] = v43;
  v114.f64[0] = v44;
  v104 = 0u;
  v106 = 0;
  v109 = 0u;
  v108 = 0u;
  v105 = 0u;
  v103 = 0u;
  v102 = 0u;
  v110 = 0x3FF0000000000000;
  v101 = v41;
  *&v104 = v41;
  v107 = v41;
  v89 = v45;
  v92 = v50;
  v93 = v53;
  v96 = -(v53 * v46 - v52 * *(&v45 + 1));
  *&v97 = -(v52 * *&v45 - v50 * v46);
  v90 = v46;
  v94 = v52;
  *(&v97 + 1) = -(v50 * *(&v45 + 1) - v53 * *&v45);
  v91 = 0;
  v98 = 0u;
  v99 = 0u;
  v100 = 0x3FF0000000000000;
  v54 = v111;
  v95 = 0;
  do
  {
    v55 = 0;
    v56 = &v89;
    do
    {
      v57 = 0;
      v58 = 0.0;
      v59 = v54;
      do
      {
        v60 = *v59;
        v59 += 4;
        v58 = v58 + *(v56 + v57) * v60;
        v57 += 8;
      }

      while (v57 != 32);
      v88[4 * v55++ + v51] = v58;
      v56 += 2;
    }

    while (v55 != 4);
    ++v51;
    v54 = (v54 + 8);
  }

  while (v51 != 4);
  v61 = 0;
  v62 = v88;
  do
  {
    v63 = 0;
    v64 = &v101;
    do
    {
      v65 = 0;
      v66 = 0.0;
      v67 = v62;
      do
      {
        v68 = *v67;
        v67 += 4;
        v66 = v66 + v64[v65++] * v68;
      }

      while (v65 != 4);
      v85[4 * v63++ + v61] = v66;
      v64 += 4;
    }

    while (v63 != 4);
    ++v61;
    ++v62;
  }

  while (v61 != 4);
  v69 = 0;
  v70 = v85;
  do
  {
    v71 = 0;
    v72 = v82;
    do
    {
      v73 = 0;
      v74 = 0.0;
      v75 = v70;
      do
      {
        v76 = *v75;
        v75 += 4;
        v74 = v74 + *&v72[v73++] * v76;
      }

      while (v73 != 4);
      *(&v111[2 * v71++] + v69) = v74;
      v72 += 4;
    }

    while (v71 != 4);
    ++v69;
    ++v70;
  }

  while (v69 != 4);
  v77 = v112;
  this[9] = v111[4];
  this[10] = v77;
  v78 = v114;
  this[11] = v113;
  this[12] = v78;
  v79 = v111[1];
  this[5] = v111[0];
  this[6] = v79;
  result = *&v111[2];
  v81 = v111[3];
  this[7] = v111[2];
  this[8] = v81;
  LOBYTE(this[13].f64[0]) = 1;
  return result;
}

void *md::FlyoverLabelMapTile::assignWorldPointToLabel(md::FlyoverLabelMapTile *this, md::Label *a2)
{
  v4 = (*(this + 8) - *(this + 6)) * 0.200000003;
  v5 = (*(**(a2 + 1) + 112))(*(a2 + 1), a2 + 48);
  v37 = *md::LabelPoint::mercatorPoint(v5);
  v31[0] = (*(*this + 16))(this, &v37);
  v31[1] = v6;
  v31[2] = v7;
  v28 = 0.0;
  v29 = 0uLL;
  geo::Geocentric<double>::toCoordinate3D<geo::Radians,double>(v31, &v28);
  v8 = v29;
  v9 = tan(v28 * 0.5 + 0.785398163);
  v10 = log(v9);
  memset(v32, 0, sizeof(v32));
  *&v11.f64[0] = v8;
  v11.f64[1] = v10;
  __asm { FMOV            V1.2D, #0.5 }

  v33 = vmlaq_f64(_Q1, vdupq_n_s64(0x3FC45F306DC9C883uLL), v11);
  v17 = *(&v8 + 1);
  if (*(&v8 + 1) == 1.79769313e308)
  {
    v17 = 3.4028e38;
  }

  v34 = v17;
  v35 = 256;
  v36 = 1;
  md::LabelPoint::geocentricPoint(v32);
  v28 = md::LabelPoint::geocentricNormal(v32);
  *&v29 = v18;
  *(&v29 + 1) = v19;
  v20 = v34;
  if (v34 == 3.4028e38)
  {
    v20 = 0.0;
  }

  md::Label::setWorldPoint(a2, v32, &v28, LODWORD(v20) | ((v34 != 3.4028e38) << 32));
  result = (*(**(a2 + 1) + 128))(&v28, v4);
  if (v30 == 1)
  {
    v22 = md::LabelPoint::mercatorPoint(&v28);
    v23 = *v22;
    v24 = exp(v22[1] * 6.28318531 + -3.14159265);
    v25 = atan(v24) * 2.0 + -1.57079633;
    v26 = fmod(v23 * 6.28318531, 6.28318531);
    v27 = fmod(v26 + 6.28318531, 6.28318531) + -3.14159265;
    __sincos_stret(v25);
    __sincos_stret(v27);
    operator new();
  }

  return result;
}

double md::FlyoverLabelMapTile::worldPointFromMercatorPoint(uint64_t a1, __int128 *a2)
{
  v16 = 0uLL;
  v17 = 0;
  v18 = *a2;
  v19 = 2139095039;
  v20 = 256;
  v21 = 1;
  md::LabelPoint::geocentricPoint(&v16);
  v22 = v16;
  v23 = v17;
  v4 = *(a1 + 560);
  if (v4)
  {
    if ((*(*v4 + 64))(v4))
    {
      v14 = *a2;
      v15 = 0;
      v5 = (*(**(a1 + 560) + 56))(*(a1 + 560), &v14, 1);
      if ((v5 & 0x100000000) != 0)
      {
        v6 = *&v5;
        v7 = md::LabelPoint::geocentricNormal(&v16);
        v8 = 0;
        *v13 = v7;
        v13[1] = v9;
        v13[2] = v10;
        do
        {
          *&v24[v8 * 8] = *&v13[v8] * v6;
          ++v8;
        }

        while (v8 != 3);
        for (i = 0; i != 24; i += 8)
        {
          *(&v22 + i) = *(&v22 + i) + *&v24[i];
        }
      }
    }
  }

  return *&v22;
}

void md::FlyoverLabelMapTile::~FlyoverLabelMapTile(md::FlyoverLabelMapTile *this)
{
  md::StandardLabelMapTile::~StandardLabelMapTile(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::PolygonFill::CompressedMeshPipelineSetup::~CompressedMeshPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void *ggl::PolygonFill::CompressedMeshPipelineSetup::CompressedMeshPipelineSetup(void *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(a1, a2, a3);
    std::__shared_weak_count::__release_shared[abi:nn200100](a3);
  }

  else
  {
    ggl::PipelineSetup::PipelineSetup(a1, a2, 0);
  }

  *a1 = &unk_1F2A56888;
  return a1;
}

uint64_t md::TrafficLayerDataSource::resourceKeyForType@<X0>(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v13 = *MEMORY[0x1E69E9840];
  v6 = *(a1 + 592);
  if ((a5 & 0x100000000) != 0)
  {
    v7 = a5;
  }

  else
  {
    v7 = 2147483646;
  }

  v10 = vrev64_s32(*(a3 + 4));
  v8 = *a3;
  v11 = a3[1];
  v12 = v8;
  return gdc::ResourceKey::ResourceKey(a6, a2, v6, &v10, 4, a4, v7);
}

uint64_t md::TrafficLayerDataSource::updateRequest(uint64_t a1, char **a2, uint64_t a3, unsigned __int16 **a4)
{
  v60 = *MEMORY[0x1E69E9840];
  if (*(a1 + 760) != 1)
  {
    return 0;
  }

  gdc::Tiled::tileFromLayerDataKey(v53, *(*a2 + 2));
  if (v53[1] < 7u)
  {
    return 0;
  }

  gdc::LayerDataSource::getResourceFromMap<md::GEOVectorTileResource>(&v51, 9, *a4, a4[1]);
  gdc::LayerDataSource::getResourceFromMap<md::TrafficSkeletonTileResource>(&v49, *a4, a4[1]);
  v10 = *a4;
  v9 = a4[1];
  while (v10 != v9)
  {
    if (*v10 == 16)
    {
      goto LABEL_10;
    }

    v10 += 24;
  }

  v10 = a4[1];
LABEL_10:
  if (v49)
  {
    v11 = v10 == v9;
  }

  else
  {
    v11 = 1;
  }

  if (v11)
  {
    v12 = (*(*a1 + 152))(a1);
    v13 = *a2;
    if (v12 && (v13[210] & 1) == 0)
    {
      v14 = gdc::LayerDataRequest::optionalRequestedResources(v13);
      v15 = 1;
    }

    else
    {
      v14 = gdc::LayerDataRequest::requiredRequestedResources(v13);
      v15 = 0;
    }

    v16 = *v14;
    v17 = v14[1];
    if (*v14 == v17)
    {
      goto LABEL_39;
    }

    v18 = *v14;
    while (*v18 != 17)
    {
      v18 += 24;
      if (v18 == v17)
      {
        goto LABEL_39;
      }
    }

    if (v18 == v17)
    {
      goto LABEL_39;
    }

    v19 = *v14;
    while (*v19 != 17)
    {
      v19 += 24;
      if (v19 == v17)
      {
        v19 = v14[1];
        break;
      }
    }

    if (!*(v19 + 4))
    {
      goto LABEL_39;
    }

    v20 = *v14;
    while (*v20 != 16)
    {
      v20 += 24;
      if (v20 == v17)
      {
        goto LABEL_39;
      }
    }

    if (v20 == v17)
    {
      goto LABEL_39;
    }

    while (*v16 != 16)
    {
      v16 += 24;
      if (v16 == v17)
      {
        v16 = v14[1];
        break;
      }
    }

    if (!*(v16 + 4))
    {
LABEL_39:
      v21 = *(a1 + 24);
      if (v21)
      {
        v22 = (*(*v21 + 24))(v21, 16);
        if (v23)
        {
          v24 = v22;
          md::GEOVectorTileResource::QuadTileFromResourceKey(&v46, *(v51 + 8));
          v25 = *a2;
          v26 = **a2;
          v27 = *(*a2 + 14);
          v54 = vrev64_s32(v48);
          v28 = v47;
          LODWORD(v55) = v47;
          HIDWORD(v55) = v46;
          gdc::ResourceKey::ResourceKey(&v43, v26, 17, &v54, 4, v27, 2147483646);
          gdc::LayerDataRequest::request(v25, &v43, v15);
          if (v44 != v45)
          {
            free(v44);
          }

          v29 = (*(**(a1 + 24) + 32))(*(a1 + 24), 17);
          v30 = v29;
          if ((v29 & 0x100000000) == 0 || (v54 = 0, v55 = 0, v56 = 0, v31 = (*(**(a1 + 24) + 32))(*(a1 + 24), 16), (v31 & 0x100000000) == 0))
          {
            v42 = std::__throw_bad_optional_access[abi:nn200100]();
            if (v54)
            {
              v55 = v54;
              operator delete(v54);
            }

            if (v50)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v50);
            }

            if (v52)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v52);
            }

            _Unwind_Resume(v42);
          }

          v32 = v31;
          v33 = v30;
          if (v30)
          {
            v34 = v31 == 0;
          }

          else
          {
            v34 = 1;
          }

          if (v34)
          {
            v35 = 0;
          }

          else
          {
            if (v30 >= v31)
            {
              v35 = 0;
            }

            else
            {
              v35 = 0;
              do
              {
                ++v35;
                v33 *= 2;
              }

              while (v33 < v31);
            }

            if (v33 > v31)
            {
              do
              {
                --v35;
                v36 = v33 > 2 * v32;
                v32 *= 2;
              }

              while (v36);
            }
          }

          if (v35 + v28 >= v24)
          {
            v37 = -v35;
          }

          else
          {
            v37 = v28 - v24;
          }

          md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(v37, 16, *(a1 + 24), &v46, 0, &v54);
          v38 = v54;
          v39 = v55;
          if (v54 != v55)
          {
            do
            {
              v40 = *a2;
              v41 = *(*a2 + 14);
              v57 = vrev64_s32(*(v38 + 4));
              v58 = v38[1];
              v59 = *v38;
              gdc::ResourceKey::ResourceKey(&v43, v26, 16, &v57, 4, v41, 2147483646);
              gdc::LayerDataRequest::request(v40, &v43, v15);
              if (v44 != v45)
              {
                free(v44);
              }

              v38 += 32;
            }

            while (v38 != v39);
            v38 = v54;
          }

          if (v38)
          {
            v55 = v38;
            operator delete(v38);
          }

          v7 = 1;
          goto LABEL_52;
        }
      }
    }
  }

  v7 = 0;
LABEL_52:
  if (v50)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v50);
  }

  if (v52)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v52);
  }

  return v7;
}

uint64_t md::mun::MetadataResourceDecoder::decode(uint64_t a1)
{
  MEMORY[0x1EEE9AC00](a1);
  v2 = v1;
  v4 = v3;
  v17 = *MEMORY[0x1E69E9840];
  (*(**v1 + 32))();
  (*(**v2 + 24))();
  v5 = GEOMuninMetadataTileCreate();
  if (v5)
  {
    memset(__p, 0, 24);
    {
    }

    {
    }

    {
    }

    v13 = 0uLL;
    v14 = 0;
    std::vector<md::mun::CollectionPoint>::reserve(&v13, v5[3]);
    if (v5[7])
    {
      __asm { FMOV            V0.2D, #0.5 }

      std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(1uLL);
    }

    if (__p[0])
    {
      operator delete(__p[0]);
    }

    memset(buf, 0, sizeof(buf));
    v11 = v5[9];
    if (v11)
    {
      if (v11 < 0x186186186186187)
      {
        __p[7] = buf;
        std::__allocate_at_least[abi:nn200100]<std::allocator<md::mun::StorefrontBundle>>(v11);
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    operator new();
  }

  result = GEOMuninMetadataTileDestroy();
  *v4 = 0;
  v4[1] = 0;
  return result;
}

void sub_1B32D7BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *__p)
{
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void geo::linear_map<md::mun::RigType,BOOL,std::equal_to<md::mun::RigType>,std::allocator<std::pair<md::mun::RigType,BOOL>>,std::vector<std::pair<md::mun::RigType,BOOL>>>::emplace<md::mun::RigType,BOOL>(char **a1, unsigned __int8 a2, __int16 a3)
{
  v5 = *a1;
  v6 = a1[1];
  if (*a1 == v6)
  {
    goto LABEL_7;
  }

  v7 = *a1;
  while (*v7 != a2)
  {
    v7 += 2;
    if (v7 == v6)
    {
      goto LABEL_7;
    }
  }

  if (v7 == v6)
  {
LABEL_7:
    v8 = a1[2];
    if (v6 >= v8)
    {
      v10 = v6 - v5;
      v11 = (v6 - v5) >> 1;
      if (v11 <= -2)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v12 = v8 - v5;
      if (v12 <= v11 + 1)
      {
        v13 = v11 + 1;
      }

      else
      {
        v13 = v12;
      }

      if (v12 >= 0x7FFFFFFFFFFFFFFELL)
      {
        v14 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v14 = v13;
      }

      if (v14)
      {
        if ((v14 & 0x8000000000000000) == 0)
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v15 = v11;
      v16 = (2 * v11);
      v17 = a2 | (a3 << 8);
      v18 = &v16[-v15];
      *v16 = v17;
      v9 = (v16 + 1);
      memcpy(v18, v5, v10);
      *a1 = v18;
      a1[1] = v9;
      a1[2] = 0;
      if (v5)
      {
        operator delete(v5);
      }
    }

    else
    {
      *v6 = a2 | (a3 << 8);
      v9 = (v6 + 2);
    }

    a1[1] = v9;
  }
}

void std::__shared_ptr_emplace<md::mun::MetadataResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A56998;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::ARWalkingPerpendicularManeuverLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, __int32 *a4)
{
  md::ARWalkingPerpendicularManeuverLabelPart::updateLocalState(a1, a1 + 1224, a2 + 432, *(a1 + 16) + 408, *(a1 + 16) + 1040, (*(a1 + 16) + 944), *(a1 + 1256), *(a1 + 1264), *(*(a1 + 32) + 72), *(*(a1 + 32) + 68));
  v19 = 0;
  v8 = md::CompositeLabelPart::layoutForDisplay(a1, a2, a3, a4, &v19);
  if (v8 == 37)
  {
    v9 = *(*(a1 + 32) + 68);
    *(a1 + 416) = v9;
    *(a1 + 352) = *a4;
    *(a1 + 356) = a4[1];
    *(a1 + 510) = fabsf(v9 + -1.0) > 0.000001;
    v10 = *(a2 + 896);
    *(a1 + 536) = v10;
    v11 = *(a2 + 900);
    *(a1 + 540) = v11;
    v12 = *(a1 + 528);
    v13 = v12 * v11;
    v14 = *(a1 + 532);
    v15 = -((v14 * v11) - (v12 * v10));
    *(a1 + 328) = v15;
    *(a1 + 332) = v13 + (v14 * v10);
    *(a1 + 508) = fabsf(v15 + -1.0) > 0.000001;
    *(a1 + 424) = a1 + 1272;
    v16 = *(***(**(a1 + 576) + 576) + 832);
    if (*(*(a1 + 16) + 788) >= 0.0)
    {
      v16();
      (*(**(*(**(a1 + 576) + 576) + 8) + 832))();
      if (*(a1 + 1816) == 1)
      {
        v17 = *(**(*(a1 + 576) + 16) + 832);
        goto LABEL_7;
      }
    }

    else
    {
      v16();
      (*(**(*(**(a1 + 576) + 576) + 8) + 832))();
      if (*(a1 + 1816) == 1)
      {
        v17 = *(**(*(a1 + 576) + 16) + 832);
LABEL_7:
        v17();
      }
    }
  }

  return v8;
}

double md::ARWalkingPerpendicularManeuverLabelPart::updateLocalState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double *a6, double a7, double a8, double a9, double a10)
{
  v10 = *(a1 + 16);
  if (*(v10 + 164) == 1)
  {
    v18 = 0;
    v19 = a10 * a9 * *(a3 + 320);
    v20 = v10 + 152;
    do
    {
      *(&v171 + v18) = *(v20 + 4 * v18);
      ++v18;
    }

    while (v18 != 3);
    v169 = *a6;
    v170 = a6[2];
    v122 = v173;
    v21 = v171;
    v22 = v172;
    v23 = -(v171 * *(&v169 + 1) - *&v169 * v172);
    *&v167 = -(v172 * v170 - v173 * *(&v169 + 1));
    *(&v167 + 1) = -(*&v169 * v173 - v171 * v170);
    v168 = v23;
    v166[0] = -(v23 * *(&v169 + 1) - *(&v167 + 1) * v170);
    v166[1] = -(*&v167 * v170 - v23 * *&v169);
    v166[2] = -(*(&v167 + 1) * *&v169 - *&v167 * *(&v169 + 1));
    gm::quaternionFromAngleAxis<double>(v165, &v167, *(a2 + 8) * -0.0174532925);
    v24 = gm::Quaternion<double>::operator*(v165, &v169);
    v26 = v25;
    v28 = v27;
    v161[0] = gm::Quaternion<double>::operator*(v165, v166);
    v161[1] = v29;
    v162 = v167;
    v161[2] = v30;
    v163 = v23;
    *v164 = v24;
    v164[1] = v26;
    v164[2] = v28;
    v159 = 0uLL;
    v160 = 0.0;
    v31 = a8 * 0.5;
    if (*(a2 + 28) == 6)
    {
      for (i = 0; i != 3; ++i)
      {
        *(&v149 + i * 8) = v31 * v166[i];
      }

      v33 = 0;
      v35 = a7;
      v34 = v122;
      do
      {
        *(&v159 + v33) = *(&v159 + v33) + *(&v149 + v33);
        v33 += 8;
      }

      while (v33 != 24);
      v36 = 0;
      v37 = *(a2 + 4);
      do
      {
        *(&v149 + v36 * 8) = *&v161[v36] * v37;
        ++v36;
      }

      while (v36 != 3);
      for (j = 0; j != 24; j += 8)
      {
        *(&v159 + j) = *(&v159 + j) + *(&v149 + j);
      }
    }

    else
    {
      for (k = 0; k != 3; ++k)
      {
        *(&v149 + k * 8) = v31 * v166[k];
      }

      v40 = 0;
      v35 = a7;
      v34 = v122;
      do
      {
        *(&v159 + v40) = *(&v159 + v40) - *(&v149 + v40);
        v40 += 8;
      }

      while (v40 != 24);
      v41 = 0;
      v42 = *(a2 + 4);
      do
      {
        *(&v149 + v41 * 8) = *&v161[v41] * v42;
        ++v41;
      }

      while (v41 != 3);
      for (m = 0; m != 24; m += 8)
      {
        *(&v159 + m) = *(&v159 + m) - *(&v149 + m);
      }
    }

    v44 = 0;
    v45 = 0.0;
    do
    {
      v45 = v45 + v166[v44] * *(&v159 + v44 * 8);
      ++v44;
    }

    while (v44 != 3);
    v46 = 0;
    v160 = v35 * -0.5 + *(a1 + 1240) * v45 - *(a2 + 24) + v160;
    v157 = v159;
    v158 = v160;
    v47 = *a2;
    do
    {
      *(&v149 + v46 * 8) = *&v164[v46] * v47;
      ++v46;
    }

    while (v46 != 3);
    for (n = 0; n != 24; n += 8)
    {
      *(&v157 + n) = *(&v157 + n) + *(&v149 + n);
    }

    for (ii = 0; ii != 24; ii += 8)
    {
      *(&v149 + ii) = *(&v157 + ii) * v19;
    }

    v50 = 0;
    v138 = v149;
    v139 = *&v150;
    do
    {
      *(&v149 + v50) = *(&v138 + v50) + *(a4 + v50);
      v50 += 8;
    }

    while (v50 != 24);
    v51 = 0;
    v52 = v149;
    v53 = v150;
    do
    {
      *(&v149 + v51) = *(&v159 + v51) * v19;
      v51 += 8;
    }

    while (v51 != 24);
    v54 = 0;
    v138 = v149;
    v139 = *&v150;
    do
    {
      *(&v149 + v54) = *(&v138 + v54) + *(a4 + v54);
      v54 += 8;
    }

    while (v54 != 24);
    v55 = 0;
    v56 = v149;
    v57 = v150;
    v58 = &v138;
    v59 = v161;
    do
    {
      v60 = 0;
      v61 = v58;
      do
      {
        *v61 = v59[v60];
        v61 += 2;
        v60 += 3;
      }

      while (v60 != 9);
      ++v55;
      v58 = (v58 + 8);
      ++v59;
    }

    while (v55 != 3);
    v62 = 0;
    v140 = 0.0;
    *(&v143 + 1) = 0;
    v145 = 0;
    v146 = v52;
    v147 = v53;
    v148 = 0x3FF0000000000000;
    v131 = 0u;
    v133 = 0;
    v136 = 0u;
    v135 = 0u;
    v132 = 0u;
    v130 = 0u;
    *&v129[8] = 0u;
    v137 = 0x3FF0000000000000;
    *v129 = v19;
    v63 = &v138;
    *&v131 = v19;
    v134 = v19;
    do
    {
      v64 = 0;
      v65 = v129;
      do
      {
        v66 = 0;
        v67 = 0.0;
        v68 = v63;
        do
        {
          v69 = *v68;
          v68 += 4;
          v67 = v67 + *&v65[v66] * v69;
          v66 += 8;
        }

        while (v66 != 32);
        *(&v149 + 4 * v64++ + v62) = v67;
        v65 += 32;
      }

      while (v64 != 4);
      ++v62;
      v63 = (v63 + 8);
    }

    while (v62 != 4);
    v70 = 0;
    v71 = v154;
    *(a2 + 240) = v153;
    *(a2 + 256) = v71;
    v72 = v156;
    *(a2 + 272) = v155;
    *(a2 + 288) = v72;
    v73 = v150;
    *(a2 + 176) = v149;
    *(a2 + 192) = v73;
    v74 = v152;
    v75 = &v138;
    v76 = v161;
    *(a2 + 208) = v151;
    *(a2 + 224) = v74;
    do
    {
      v77 = 0;
      v78 = v75;
      do
      {
        *v78 = v76[v77];
        v78 += 2;
        v77 += 3;
      }

      while (v77 != 9);
      ++v70;
      v75 = (v75 + 8);
      ++v76;
    }

    while (v70 != 3);
    v79 = 0;
    v140 = 0.0;
    *(&v143 + 1) = 0;
    v145 = 0;
    v146 = v56;
    v147 = v57;
    v148 = 0x3FF0000000000000;
    v131 = 0u;
    v133 = 0;
    v136 = 0u;
    v135 = 0u;
    v132 = 0u;
    v130 = 0u;
    *&v129[8] = 0u;
    v137 = 0x3FF0000000000000;
    *v129 = v19;
    v80 = &v138;
    *&v131 = v19;
    v134 = v19;
    do
    {
      v81 = 0;
      v82 = v129;
      do
      {
        v83 = 0;
        v84 = 0.0;
        v85 = v80;
        do
        {
          v86 = *v85;
          v85 += 4;
          v84 = v84 + *&v82[v83] * v86;
          v83 += 8;
        }

        while (v83 != 32);
        *(&v149 + 4 * v81++ + v79) = v84;
        v82 += 32;
      }

      while (v81 != 4);
      ++v79;
      v80 = (v80 + 8);
    }

    while (v79 != 4);
    v87 = v154;
    *(a2 + 368) = v153;
    *(a2 + 384) = v87;
    v88 = v156;
    *(a2 + 400) = v155;
    *(a2 + 416) = v88;
    v89 = v150;
    *(a2 + 304) = v149;
    *(a2 + 320) = v89;
    v90 = v152;
    *(a2 + 336) = v151;
    *(a2 + 352) = v90;
    v127 = *a6;
    v128 = a6[2];
    *&v90 = -(v22 * v128 - v34 * *(&v127 + 1));
    v91 = -(*&v127 * v34 - v21 * v128);
    v92 = -(v21 * *(&v127 + 1) - *&v127 * v22);
    *&v138 = v90;
    *(&v138 + 1) = v91;
    v139 = v92;
    v140 = -(v91 * v128 - v92 * *(&v127 + 1));
    v141 = -(v92 * *&v127 - *&v90 * v128);
    v142 = -(*&v90 * *(&v127 + 1) - v91 * *&v127);
    v143 = v127;
    v144 = v128;
    gm::quaternionFromRotationMatrix<double>(v129, &v138);
    if (*(a1 + 1816) == 1)
    {
      md::LabelPart::generateModelMatrixForMeshPositioningMode(&v149, v20, a3, a4, 6, 1, *(a1 + 1817), a9, a10);
      v93 = v154;
      *(a2 + 112) = v153;
      *(a2 + 128) = v93;
      v94 = v156;
      *(a2 + 144) = v155;
      *(a2 + 160) = v94;
      v95 = v150;
      *(a2 + 48) = v149;
      *(a2 + 64) = v95;
      v96 = v152;
      *(a2 + 80) = v151;
      *(a2 + 96) = v96;
      v123 = *a4;
      v124 = *(a4 + 16);
      v149 = 0uLL;
      *&v96 = fabs(*a6);
      *&v150 = 0x3FF0000000000000;
      if (*&v96 >= 0.0001)
      {
LABEL_64:
        for (jj = 0; jj != 24; jj += 8)
        {
          *(&v149 + jj) = *(&v123 + jj) - *(a5 + jj);
        }

        v105 = 0;
        v125 = v149;
        v126 = v150;
        v106 = 0.0;
        do
        {
          v106 = v106 + *(&v125 + v105 * 8) * a6[v105];
          ++v105;
        }

        while (v105 != 3);
        for (kk = 0; kk != 3; ++kk)
        {
          *(&v149 + kk * 8) = a6[kk] * v106;
        }

        for (mm = 0; mm != 24; mm += 8)
        {
          *(&v123 + mm) = *(&v123 + mm) - *(&v149 + mm);
        }
      }

      else
      {
        v97 = 1;
        while (v97 != 3)
        {
          v98 = v97;
          v99 = vabdd_f64(a6[v97], *(&v149 + v97));
          ++v97;
          if (v99 >= 0.0001)
          {
            if ((v98 - 1) < 2)
            {
              goto LABEL_64;
            }

            break;
          }
        }

        v124 = *(a5 + 16);
      }

      *(a2 + 552) = *&v129[16];
      *(a2 + 536) = *v129;
      *(a2 + 560) = v130;
      *(a2 + 512) = v123;
      *(a2 + 528) = v124;
      *(a2 + 568) = v19;
      *(a2 + 576) = v19;
      *(a2 + 584) = v19;
    }

    else
    {
      v100 = *(a2 + 256);
      *(a2 + 112) = *(a2 + 240);
      *(a2 + 128) = v100;
      v101 = *(a2 + 288);
      *(a2 + 144) = *(a2 + 272);
      *(a2 + 160) = v101;
      v102 = *(a2 + 192);
      *(a2 + 48) = *(a2 + 176);
      *(a2 + 64) = v102;
      v103 = *(a2 + 224);
      *(a2 + 80) = *(a2 + 208);
      *(a2 + 96) = v103;
    }

    v125 = v52;
    v126 = v53;
    v149 = 0uLL;
    *&v150 = 0x3FF0000000000000;
    if (fabs(*a6) >= 0.0001)
    {
LABEL_79:
      for (nn = 0; nn != 24; nn += 8)
      {
        *(&v149 + nn) = *(&v125 + nn) - *(a5 + nn);
      }

      v113 = 0;
      v123 = v149;
      v124 = v150;
      v114 = 0.0;
      do
      {
        v114 = v114 + *(&v123 + v113 * 8) * a6[v113];
        ++v113;
      }

      while (v113 != 3);
      for (i1 = 0; i1 != 3; ++i1)
      {
        *(&v149 + i1 * 8) = a6[i1] * v114;
      }

      for (i2 = 0; i2 != 24; i2 += 8)
      {
        *(&v125 + i2) = *(&v125 + i2) - *(&v149 + i2);
      }
    }

    else
    {
      v109 = 1;
      while (v109 != 3)
      {
        v110 = v109;
        v111 = vabdd_f64(a6[v109], *(&v149 + v109));
        ++v109;
        if (v111 >= 0.0001)
        {
          if ((v110 - 1) < 2)
          {
            goto LABEL_79;
          }

          break;
        }
      }

      v126 = *(a5 + 16);
    }

    gm::quaternionFromAngleAxis<double>(&v123, &v127, 1.57079633);
    gm::Quaternion<double>::operator*(&v149, v129, &v123);
    *(a2 + 456) = v149;
    *(a2 + 472) = v150;
    result = *(&v150 + 1);
    *(a2 + 432) = v125;
    *(a2 + 448) = v126;
    *(a2 + 480) = result;
    *(a2 + 488) = v19;
    *(a2 + 496) = v19;
    *(a2 + 504) = v19;
  }

  else
  {
    v118 = std::__throw_bad_optional_access[abi:nn200100]();
    return md::ARWalkingPerpendicularManeuverLabelPart::updateForDisplay(v118);
  }

  return result;
}

double md::ARWalkingPerpendicularManeuverLabelPart::updateForDisplay(md::ARWalkingPerpendicularManeuverLabelPart *this)
{
  v2 = *(this + 72);
  v3 = *(this + 73);
  if (v2 != v3)
  {
    do
    {
      v4 = *v2++;
      (*(*v4 + 112))(v4);
    }

    while (v2 != v3);
    v2 = *(this + 72);
  }

  *(this + 153) = *(this + 79);
  *(this + 154) = *(this + 80);
  *(this + 312) = *(this + 164);
  v5 = 0.0;
  if (*(this + 1816) == 1)
  {
    v6 = 0;
    v7 = 0;
    v8 = *(v2[2] + 24);
    do
    {
      v9 = *(v8 + 80 + 4 * v7);
      v10 = *(v8 + 72 + 4 * v7);
      if (v6)
      {
        break;
      }

      v6 = 1;
      v7 = 1;
    }

    while (v9 >= v10);
    if (v9 >= v10)
    {
      v5 = (*(v8 + 84) - *(v8 + 76));
    }
  }

  *(this + 157) = v5;
  *(this + 1252) = *(this + 660);
  v11 = *(**(*v2 + 576) + 24);
  *(this + 158) = (*(v11 + 80) - *(v11 + 72));
  result = *(this + 81);
  *(this + 155) = result;
  return result;
}

uint64_t md::ARWalkingPerpendicularManeuverLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*(a1 + 1816) != 1 || (v6 = *(*(a1 + 576) + 16), v31 = 0, result = (*(*v6 + 80))(v6, a2, a3, &v31), result == 37) && (v8 = *(a1 + 576), v9 = *(v8 + 24), v10 = *(*(v8 + 16) + 24), v9[164] = v10[18], v9[165] = v10[19], v9[166] = v10[20], v9[167] = v10[21], v31 = 0, result = (*(*v9 + 80))(v9, a2, a3, &v31), result == 37))
  {
    v11 = **(a1 + 576);
    v31 = 0;
    result = (*(*v11 + 80))(v11, a2, a3, &v31);
    if (result == 37)
    {
      v12 = *(a1 + 576);
      v13 = v12[1];
      v14 = *(**(*v12 + 576) + 24);
      v13[164] = v14[18];
      v13[165] = v14[19];
      v13[166] = v14[20];
      v13[167] = v14[21];
      v31 = 0;
      result = (*(*v13 + 80))(v13, a2, a3, &v31);
      if (result == 37)
      {
        v15 = *(*(a1 + 32) + 20);
        *(a1 + 176) = v15;
        *(a1 + 112) = *a3;
        *(a1 + 116) = a3[1];
        *(a1 + 270) = fabsf(v15 + -1.0) > 0.000001;
        v16 = *(a2 + 424);
        v17 = *(v16 + 464);
        *(a1 + 296) = v17;
        v18 = *(v16 + 468);
        *(a1 + 300) = v18;
        v19 = *(a1 + 288);
        v20 = v19 * v18;
        v21 = *(a1 + 292);
        v22 = -((v21 * v18) - (v19 * v17));
        *(a1 + 88) = v22;
        *(a1 + 92) = v20 + (v21 * v17);
        *(a1 + 268) = fabsf(v22 + -1.0) > 0.000001;
        md::CompositeLabelPart::updateCompositeStagingState(a1);
        if (*(a1 + 566) == 1)
        {
          v23 = *(a1 + 576);
          v24 = 0.0;
          if (*(a1 + 1816) == 1)
          {
            v25 = 0;
            v26 = 0;
            v27 = *(v23[2] + 24);
            do
            {
              v28 = *(v27 + 80 + 4 * v26);
              v29 = *(v27 + 72 + 4 * v26);
              if (v25)
              {
                break;
              }

              v25 = 1;
              v26 = 1;
            }

            while (v28 >= v29);
            if (v28 >= v29)
            {
              v24 = (*(v27 + 84) - *(v27 + 76));
            }
          }

          v30 = *(**(*v23 + 576) + 24);
          md::ARWalkingPerpendicularManeuverLabelPart::updateLocalState(a1, a1 + 632, *(a2 + 424), *(a1 + 16) + 616, *(a1 + 16) + 640, (*(a1 + 16) + 544), v24, (*(v30 + 80) - *(v30 + 72)), *(*(a1 + 32) + 24), *(*(a1 + 32) + 20));
          *(a1 + 184) = a1 + 680;
        }

        return 37;
      }
    }
  }

  return result;
}

uint64_t *md::ARWalkingPerpendicularManeuverLabelPart::updateWithStyle(md::ARWalkingPerpendicularManeuverLabelPart *this, md::LabelManager *a2)
{
  md::CompositeLabelPart::updateWithStyle(this, a2);
  v3 = *(this + 4);
  *(this + 158) = *(*md::LabelStyle::prepareStyleGroup<md::LabelComponentStyleGroup>(*v3) + 8);
  *(this + 159) = *(*md::LabelStyle::prepareStyleGroup<md::LabelComponentStyleGroup>(*v3) + 12);
  v4 = *(*md::LabelStyle::prepareStyleGroup<md::LabelComponentStyleGroup>(*v3) + 16);
  *(this + 80) = v4;
  v5 = *v3;
  v6 = *(*v3 + 272);
  if (!v6)
  {
    v7 = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>(*v3);
    v6 = *v7;
    *(v5 + 272) = *v7;
    v4 = *(this + 80);
    v5 = *v3;
  }

  *(this + 164) = *(v6 + 32);
  *(this + 81) = tan(v4 * 0.0174532925);
  result = md::LabelStyle::prepareStyleGroup<md::LabelComponentStyleGroup>(v5);
  *(this + 660) = *(*result + 20);
  return result;
}

void md::ARWalkingPerpendicularManeuverLabelPart::~ARWalkingPerpendicularManeuverLabelPart(md::ARWalkingPerpendicularManeuverLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  v3 = mdm::zone_mallocator::instance(v2);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, this);
}

uint64_t md::JunctionLayoutContext::JunctionLayoutContext(uint64_t a1, uint64_t a2)
{
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = a2;
  *(a1 + 28) = 1065353216;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  v3 = *(a2 + 8);
  v4 = md::LayoutContext::get<md::CameraContext>(v3);
  v5 = gdc::Context::get<md::GeometryContext>(v3);
  v7 = *v5;
  v6 = v5[1];
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
    v8 = *(a1 + 16);
    *(a1 + 8) = v7;
    *(a1 + 16) = v6;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v8);
    }
  }

  else
  {
    *(a1 + 8) = v7;
    *(a1 + 16) = 0;
  }

  *(a1 + 24) = fmaxf(*(v4 + 3080) + *(v4 + 3076), 1.0);
  return a1;
}

void std::__shared_ptr_emplace<ggl::CircleMultiStroke::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A56E00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t std::shared_ptr<ggl::PipelineSetup>::operator=[abi:nn200100]<ggl::CircleMultiStroke::FillPipelineSetup,std::default_delete<ggl::CircleMultiStroke::FillPipelineSetup>,0>(uint64_t a1, void *a2)
{
  if (*a2)
  {
    operator new();
  }

  *a2 = 0;
  v3 = *(a1 + 8);
  *a1 = 0u;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  return a1;
}

uint64_t std::__shared_ptr_pointer<ggl::CircleMultiStroke::FillPipelineSetup  *>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<ggl::CircleMultiStroke::FillPipelineSetup  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::CircleMultiStroke::Style>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::CircleMultiStroke::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A56E90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::CircleMultiStroke::CirclePositionAndScale>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::CircleMultiStroke::CirclePositionAndScale>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A56E38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::ArrowLabelPart::prepareCollisionObject(uint64_t a1, int a2, int a3, void **this)
{
  v5 = 904;
  if (!a2)
  {
    v5 = 832;
  }

  v6 = fmaxf(*(a1 + v5 + 48), *(a1 + v5 + 52));
  v10 = 0;
  v11 = v6;
  md::CollisionObject::resetWithCircles(this, 1u);
  v7 = this[21];
  v8 = *(this + 44);
  *(this + 44) = v8 + 1;
  v9 = &v7[12 * v8];
  *v9 = 0;
  v9[2] = v6;
  gm::Box<float,2>::enclose(this, &v10);
}

uint64_t md::ArrowLabelPart::styleLayer(md::ArrowLabelPart *this, const md::LabelStyle *a2)
{
  if (*(this + 980) == 1)
  {
    v5 = *(a2 + 33);
    if (!v5)
    {
      v6 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(a2);
      v5 = *v6;
      *(a2 + 33) = *v6;
    }

    v3 = (v5 + 63);
  }

  else
  {
    v3 = a2 + 240;
  }

  return *v3;
}

void md::ArrowLabelPart::populateDebugNode(md::ArrowLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::IconLabelPart::populateDebugNode(this, a2);
  std::string::basic_string[abi:nn200100]<0>(&v8, "ArrowLabelPart");
  v4 = gdc::DebugTreeNode::createChildNode(a2, &v8);
  if (v9 < 0)
  {
    operator delete(v8);
  }

  std::string::basic_string[abi:nn200100]<0>(&v8, "HalfWidth");
  gdc::DebugTreeValue::DebugTreeValue(v5, *(this + 238));
  gdc::DebugTreeNode::addProperty(v4, &v8, v5);
  if (v7 < 0)
  {
    operator delete(__p);
  }

  if (v9 < 0)
  {
    operator delete(v8);
  }
}

uint64_t md::ArrowLabelPart::debugString@<X0>(md::ArrowLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v12);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v12, "Arrow\n ", 7);
  md::IconLabelPart::debugString(this, __p);
  if ((v11 & 0x80u) == 0)
  {
    v4 = __p;
  }

  else
  {
    v4 = __p[0];
  }

  if ((v11 & 0x80u) == 0)
  {
    v5 = v11;
  }

  else
  {
    v5 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v12, v4, v5);
  if (v11 < 0)
  {
    operator delete(__p[0]);
  }

  if ((v19 & 0x10) != 0)
  {
    v7 = v18;
    if (v18 < v15)
    {
      v18 = v15;
      v7 = v15;
    }

    locale = v14[4].__locale_;
  }

  else
  {
    if ((v19 & 8) == 0)
    {
      v6 = 0;
      a2[23] = 0;
      goto LABEL_22;
    }

    locale = v14[1].__locale_;
    v7 = v14[3].__locale_;
  }

  v6 = v7 - locale;
  if ((v7 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v6 >= 0x17)
  {
    operator new();
  }

  a2[23] = v6;
  if (v6)
  {
    memmove(a2, locale, v6);
  }

LABEL_22:
  a2[v6] = 0;
  v12 = *MEMORY[0x1E69E54E8];
  *(&v12 + *(v12 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v13 = MEMORY[0x1E69E5548] + 16;
  if (v17 < 0)
  {
    operator delete(v16);
  }

  v13 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v14);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v20);
}

void sub_1B32D9D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  a15 = *MEMORY[0x1E69E54E8];
  *(&a15 + *(a15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a16 = MEMORY[0x1E69E5548] + 16;
  if (a29 < 0)
  {
    operator delete(a24);
  }

  a16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a17);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a32);
  _Unwind_Resume(a1);
}

void md::ArrowLabelPart::setPosition(uint64_t a1, int a2, uint64_t *a3)
{
  v3 = 904;
  if (!a2)
  {
    v3 = 832;
  }

  v4 = (a1 + v3);
  v6 = *a3;
  v5 = a3[1];
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  v7 = v4[1];
  *v4 = v6;
  v4[1] = v5;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }
}

uint64_t md::ArrowLabelPart::setUseExternalLayoutOptions(uint64_t result, int a2, char a3)
{
  v3 = 904;
  if (!a2)
  {
    v3 = 832;
  }

  *(result + v3 + 68) = a3;
  return result;
}

uint64_t md::ArrowLabelPart::setLayoutInReverse(uint64_t result, int a2, char a3)
{
  v3 = 904;
  if (!a2)
  {
    v3 = 832;
  }

  *(result + v3 + 67) = a3;
  return result;
}

uint64_t md::ArrowLabelPart::setLayoutStartOffset(uint64_t result, int a2, float a3)
{
  v3 = 904;
  if (!a2)
  {
    v3 = 832;
  }

  *(result + v3 + 60) = a3;
  return result;
}

uint64_t md::ArrowLabelPart::setAlignment(uint64_t result, int a2, char a3)
{
  v3 = 904;
  if (!a2)
  {
    v3 = 832;
  }

  *(result + v3 + 66) = a3;
  return result;
}

float md::ArrowLabelPart::hikerWidth(uint64_t a1, int a2)
{
  v2 = 0;
  v3 = 0;
  v4 = 312;
  if (!a2)
  {
    v4 = 72;
  }

  v5 = (a1 + v4);
  v6 = v5 + 2;
  do
  {
    v7 = v6[v3];
    v8 = v5[v3];
    if (v2)
    {
      break;
    }

    v2 = 1;
    v3 = 1;
  }

  while (v7 >= v8);
  v9 = 0.0;
  if (v7 >= v8)
  {
    v9 = v5[2] - *v5;
  }

  v10 = 0;
  v11 = 0;
  do
  {
    v12 = v6[v11];
    v13 = v5[v11];
    if (v10)
    {
      break;
    }

    v10 = 1;
    v11 = 1;
  }

  while (v12 >= v13);
  v14 = 0.0;
  if (v12 >= v13)
  {
    v14 = v5[3] - v5[1];
  }

  return fmaxf(v9, v14);
}

float md::ArrowLabelPart::localBoundsOffset(uint64_t a1, int a2)
{
  v2 = 904;
  if (!a2)
  {
    v2 = 832;
  }

  return *(a1 + v2 + 40);
}

uint64_t md::ArrowLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4)
{
  if (*(a1 + 960) == *(a2 + 1608))
  {
    v6 = *(a1 + 968);
  }

  else
  {
    (*(**(a1 + 904) + 32))(&v25);
    if (v25 && v26 != 1)
    {
      if (*(a1 + 968) == 37)
      {
        v6 = 37;
      }

      else
      {
        v6 = 31;
      }
    }

    else
    {
      *(a1 + 960) = *(a2 + 1608);
      v6 = md::ArrowLabelPart::layoutAlongPath(a1, 1, a2 + 432, a4->f32[0], a4->f32[1]);
      *(a1 + 968) = v6;
      if (v6 == 37)
      {
        *(a1 + 969) = 1;
      }
    }

    if (v26 == 1)
    {
      std::mutex::unlock(v25);
    }
  }

  if (*(a1 + 972) == 1)
  {
    v7 = vadd_f32(*(a1 + 944), *a4);
  }

  else
  {
    v24 = *a4;
    v10 = *(a1 + 904);
    v11 = (*(*v10 + 80))(v10);
    v7 = v24;
    v12 = v10[45];
    if (v10[45])
    {
      v13 = 1;
    }

    else
    {
      v13 = 2;
    }

    if (v12 == 2)
    {
      v13 = 0;
    }

    if (v11)
    {
      v12 = v13;
    }

    if (v12 != 1)
    {
      v7 = vmla_n_f32(v24, *(a1 + 928), *(a1 + 952));
    }
  }

  *(a1 + 520) = v7;
  v23 = v7;
  *(a1 + 344) = v7;
  md::CollisionObject::setupShapeData(a1 + 312);
  *(a1 + 608) = *(*(a1 + 16) + 1388);
  if (*(a1 + 969) == 1)
  {
    v14.f32[0] = -*(a1 + 924);
    v15 = *(a1 + 952);
    v14.i32[1] = *(a1 + 924);
    v16 = vmul_f32(vrev64_s32(v15), v14);
    v17 = vmul_n_f32(v15, *(a1 + 920));
    *v18.f32 = vadd_f32(v17, v16);
    *v19.f32 = vneg_f32(*v18.f32);
    LODWORD(v20) = vsub_f32(v17, v16).u32[0];
    HIDWORD(v20) = vsub_f32(v16, v17).i32[1];
    v19.i64[1] = v20;
    v21.i64[0] = v23;
    v21.i64[1] = v23;
    v22 = __PAIR64__(v17.u32[1], v16.u32[0]);
    v17.i32[1] = v16.i32[1];
    *&v18.u32[2] = vsub_f32(v22, v17);
    *(a1 + 760) = vaddq_f32(v19, v21);
    *(a1 + 776) = vaddq_f32(v18, v21);
  }

  return v6;
}

void sub_1B32DA20C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12 == 1)
  {
    std::mutex::unlock(a11);
  }

  _Unwind_Resume(exception_object);
}

uint64_t md::ArrowLabelPart::layoutAlongPath(uint64_t a1, int a2, uint64_t a3, float a4, float a5)
{
  v5 = 904;
  if (!a2)
  {
    v5 = 832;
  }

  v6 = (a1 + v5);
  Hiker = md::LabelPart::createHiker(&v33, a1, a2, *(a1 + v5), a3);
  v8 = v33;
  (*(*v33 + 88))(v33, Hiker);
  if ((v8[1].i8[1] & 1) == 0)
  {
    goto LABEL_39;
  }

  if (v6[8].i8[4] == 1)
  {
    v8[1].i8[3] = v6[8].i8[3];
    v8[1].i8[0] = 1;
    (*(*v8 + 56))(v8, v6[7].f32[1]);
    (*(*v8 + 88))(v8);
    if (v8[1].i8[2])
    {
      goto LABEL_39;
    }

    (*(*v8 + 88))(v8);
    if ((v8[1].i8[1] & 1) == 0)
    {
      goto LABEL_39;
    }

    v9 = v6[6].f32[0];
  }

  else
  {
    v10 = *v6;
    v11 = (*(**v6 + 80))(*v6);
    v12 = *(*&v10 + 45);
    if (*(*&v10 + 45))
    {
      v13 = 1;
    }

    else
    {
      v13 = 2;
    }

    if (v12 == 2)
    {
      v13 = 0;
    }

    if (v11)
    {
      LOBYTE(v12) = v13;
    }

    v8[1].i8[3] = v12 == 2;
    v8[1].i8[0] = 1;
    v14 = *v6;
    v15 = (*(**v6 + 80))(*v6);
    v16 = *(*&v14 + 45);
    if (*(*&v14 + 45))
    {
      v17 = 1;
    }

    else
    {
      v17 = 2;
    }

    if (v16 == 2)
    {
      v17 = 0;
    }

    if (v15)
    {
      v16 = v17;
    }

    if (v16 == 1)
    {
      (*(*v8 + 40))(v8, -v6[6].f32[0]);
    }

    (*(*v8 + 88))(v8);
    if (v8[1].i8[1] != 1)
    {
      goto LABEL_39;
    }

    v9 = v6[6].f32[0] + v6[6].f32[0];
  }

  (*(*v8 + 88))(v8);
  v18 = v8 + 2;
  v31 = v8[2];
  v32 = v8[3].i32[0];
  (*(*v8 + 88))(v8);
  v29 = *(&v8[3] + 4);
  v30 = v8[4].i32[1];
  (*(*v8 + 40))(v8, v9);
  (*(*v8 + 88))(v8);
  if ((v8[1].i8[1] & 1) == 0)
  {
    goto LABEL_39;
  }

  (*(*v8 + 88))(v8);
  (*(*v8 + 88))(v8);
  v19 = 0;
  v20 = 0.0;
  do
  {
    v20 = v20 + (v8[3].f32[v19 + 1] * *(&v29 + v19 * 4));
    ++v19;
  }

  while (v19 != 3);
  if (v20 < 0.9)
  {
    v21 = 18;
    goto LABEL_40;
  }

  if (*&v31 == *v18 && v32 == v8[3].u32[0])
  {
LABEL_39:
    v21 = 9;
    goto LABEL_40;
  }

  for (i = 0; i != 3; ++i)
  {
    v34[0].f32[i] = v18->f32[i] - v31.f32[i];
  }

  v6[3] = vmul_n_f32(v34[0], 1.0 / sqrtf(vaddv_f32(vmul_f32(v34[0], v34[0]))));
  v24 = (*(**v6 + 144))();
  if (((v24 != 1) ^ (*(**v6 + 160))()) == v8[1].u8[3])
  {
    v25 = vneg_f32(v6[3]);
  }

  else
  {
    v25 = v6[3];
  }

  v6[2] = v25;
  v6[5] = vsub_f32(*v18, __PAIR64__(LODWORD(a5), LODWORD(a4)));
  v21 = 37;
LABEL_40:
  (*(*v8 + 8))(v8);
  return v21;
}

uint64_t md::ArrowLabelPart::updateForDisplay(md::ArrowLabelPart *this)
{
  *(this + 119) = *(this + 110);
  result = md::IconLabelPart::updateForDisplay(this);
  if (*(this + 981) == 1)
  {
    *(this + 981) = 0;
    v3 = *(**(this + 104) + 24);

    return v3();
  }

  return result;
}

uint64_t md::ArrowLabelPart::prepareForDisplay(uint64_t this, md::LabelManager *a2)
{
  v2 = this;
  *(this + 952) = *(this + 880);
  v3 = *(this + 612);
  if (v3 == *(this + 816))
  {
    v4 = 0;
    v5 = 1;
    while (*(this + 320 + 4 * v4) >= *(this + 312 + 4 * v4))
    {
      v6 = v5;
      v5 = 0;
      v4 = 1;
      if ((v6 & 1) == 0)
      {
        goto LABEL_7;
      }
    }
  }

  *(this + 816) = v3;
  this = (*(*this + 920))(this, 1, this + 640, this + 312);
LABEL_7:
  if (*(v2 + 565) == 1)
  {
    operator new();
  }

  if ((*(v2 + 900) & 1) == 0)
  {
    v7 = *(**(v2 + 832) + 24);

    return v7();
  }

  return this;
}

uint64_t md::ArrowLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float *a3)
{
  v6 = a1 + 640;
  v7 = *(a1 + 640);
  if (v7)
  {
    v8 = atomic_load((v7 + 142));
    if ((v8 & 1) == 0)
    {
      return 15;
    }

    v9 = atomic_load((*v6 + 143));
    if ((v9 & 1) == 0)
    {
      return 16;
    }
  }

  if (*(a1 + 976) == 0.0)
  {
    v10 = (*(*a1 + 928))(a1);
    v14 = (v11 - v10) / (v13 - v12);
    *(a1 + 976) = v14;
    *(a1 + 880) = v14 * *(a1 + 884);
  }

  v15 = *(a2 + 424);
  if ((*(a1 + 900) & 1) == 0 && (*(**(a1 + 832) + 168))(*(a1 + 832), *(*(a1 + 32) + 16)) && (*(**(a1 + 832) + 176))(*(a1 + 832), *(*(a1 + 32) + 16), 1.0))
  {
    *(a1 + 981) = 1;
  }

  v16 = *(v15 + 1176);
  if (*(a1 + 888) != v16)
  {
    *(a1 + 888) = v16;
    *(a1 + 896) = md::ArrowLabelPart::layoutAlongPath(a1, 0, v15, *a3, a3[1]);
  }

  if (!*v6 || (v17 = atomic_load((*v6 + 143)), (v17 & 1) != 0))
  {
    if (*(a1 + 629) == 1)
    {
      *(a1 + 629) = 0;
      v18 = (*(*a1 + 944))(a1, *(a1 + 640));
      *&v18 = 0.5 - (fminf(v21 - v20, v19 - *&v18) * 0.5);
      *(a1 + 168) = vmaxnm_f32(*(a1 + 620), vdup_lane_s32(*&v18, 0));
      *(a1 + 271) = *(a1 + 631);
      *(a1 + 272) = *(a1 + 630);
    }
  }

  if (!*v6)
  {
    goto LABEL_20;
  }

  v22 = atomic_load((*v6 + 143));
  if (v22)
  {
    if (*v6)
    {
      v23 = atomic_load((*v6 + 143));
      if ((v23 & 1) == 0)
      {
LABEL_22:
        if ((*(a1 + 628) & 1) == 0)
        {
          v28 = 0;
          v29 = 1;
          while (*(a1 + 80 + 4 * v28) >= *(a1 + 72 + 4 * v28))
          {
            v30 = v29;
            v29 = 0;
            v28 = 1;
            if ((v30 & 1) == 0)
            {
              goto LABEL_29;
            }
          }
        }

        *(a1 + 628) = 0;
        (*(*a1 + 920))(a1, 0, v6, a1 + 72);
        goto LABEL_29;
      }
    }

LABEL_20:
    if (*(a1 + 629) == 1)
    {
      *(a1 + 629) = 0;
      v24 = (*(*a1 + 944))(a1, *(a1 + 640));
      *&v24 = 0.5 - (fminf(v27 - v26, v25 - *&v24) * 0.5);
      *(a1 + 168) = vmaxnm_f32(*(a1 + 620), vdup_lane_s32(*&v24, 0));
      *(a1 + 271) = *(a1 + 631);
      *(a1 + 272) = *(a1 + 630);
    }

    goto LABEL_22;
  }

LABEL_29:
  v32 = *a3;
  if (*(a1 + 900) == 1)
  {
    v32 = vadd_f32(v32, *(a1 + 872));
  }

  else
  {
    v33 = *(a1 + 832);
    v34 = (*(*v33 + 80))(v33);
    v35 = v33[45];
    if (v33[45])
    {
      v36 = 1;
    }

    else
    {
      v36 = 2;
    }

    if (v35 == 2)
    {
      v36 = 0;
    }

    if (v34)
    {
      v35 = v36;
    }

    if (v35 != 1)
    {
      v32 = vmla_n_f32(v32, *(a1 + 856), *(a1 + 880));
    }
  }

  *(a1 + 280) = v32;
  *(a1 + 104) = v32;
  md::CollisionObject::setupShapeData(a1 + 72);
  return *(a1 + 896);
}

float md::ArrowLabelPart::updateWithStyle(uint64_t **this, md::LabelManager *a2)
{
  md::ImageLabelPart::updateWithStyle(this, a2);
  v3 = *this[4];
  v4 = *(v3 + 264);
  if (!v4)
  {
    v5 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(*this[4]);
    v4 = *v5;
    *(v3 + 264) = *v5;
  }

  v6 = *(this + 147) * *(v4 + 48);
  *(this + 221) = v6;
  result = *(this + 244) * v6;
  *(this + 220) = result;
  return result;
}

void md::ArrowLabelPart::~ArrowLabelPart(md::ArrowLabelPart *this)
{
  *this = &unk_1F2A56F20;
  v2 = *(this + 114);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 105);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  md::IconLabelPart::~IconLabelPart(this);
  v5 = mdm::zone_mallocator::instance(v4);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v5, this);
}

{
  *this = &unk_1F2A56F20;
  v2 = *(this + 114);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 105);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  md::IconLabelPart::~IconLabelPart(this);
}

float gm::Box<float,2>::enclosed(__int128 *a1, uint64_t a2)
{
  v2 = 0;
  v3 = &v7;
  v7 = *a1;
  v4 = 1;
  do
  {
    v5 = v4;
    *v3 = fminf(*(a2 + 4 * v2), *v3);
    *(&v7 + v2 + 2) = fmaxf(*(&v7 + v2 + 2), *(a2 + 8 + 4 * v2));
    v3 = &v7 + 1;
    v2 = 1;
    v4 = 0;
  }

  while ((v5 & 1) != 0);
  return *&v7;
}

float gm::Box<float,2>::intersection(uint64_t a1, uint64_t a2)
{
  v2 = 0;
  v3 = a1 + 8;
  v4 = a2 + 8;
  v5 = 1;
  do
  {
    if (*(v3 + 4 * v2) <= *(a2 + 4 * v2) || *(a1 + 4 * v2) >= *(v4 + 4 * v2))
    {
      return 3.4028e38;
    }

    v6 = v5;
    v5 = 0;
    v2 = 1;
  }

  while ((v6 & 1) != 0);
  v7 = 0;
  v8 = &v12;
  v9 = 1;
  do
  {
    v10 = v9;
    *v8 = fmaxf(*(a1 + 4 * v7), *(a2 + 4 * v7));
    *&v13[v7 + 1] = fminf(*(v4 + 4 * v7), *(v3 + 4 * v7));
    v8 = v13;
    v7 = 1;
    v9 = 0;
  }

  while ((v10 & 1) != 0);
  return v12;
}

float gm::Box<float,2>::boxEnclosingPoints(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    return 3.4028e38;
  }

  v2 = a1 + 8 * a2;
  do
  {
    v3 = 0;
    v4 = &v9;
    v5 = 1;
    do
    {
      v6 = *(a1 + 4 * v3);
      v7 = v5;
      *v4 = fminf(v6, *v4);
      *&v10[4 * v3 + 4] = fmaxf(*&v10[4 * v3 + 4], v6);
      v4 = v10;
      v3 = 1;
      v5 = 0;
    }

    while ((v7 & 1) != 0);
    a1 += 8;
  }

  while (a1 != v2);
  return v9;
}

double gm::Box<double,2>::enclosed(uint64_t a1, uint64_t a2)
{
  v2 = 0;
  v3 = &v8;
  v4 = 1;
  do
  {
    v5 = *(a2 + 8 * v2);
    v6 = v4;
    *v3 = fmin(v5, *v3);
    *&v9[8 * v2 + 8] = fmax(*&v9[8 * v2 + 8], v5);
    v3 = v9;
    v2 = 1;
    v4 = 0;
  }

  while ((v6 & 1) != 0);
  return v8;
}

double gm::Box<double,2>::invLerped(uint64_t a1, uint64_t a2)
{
  v4 = 0;
  v5 = 0;
  v6 = a1 + 16;
  do
  {
    v7 = *(v6 + 8 * v5);
    v8 = *(a1 + 8 * v5);
    if (v4)
    {
      break;
    }

    v4 = 1;
    v5 = 1;
  }

  while (v7 >= v8);
  v16[1] = v2;
  v16[2] = v3;
  if (v7 >= v8)
  {
    v9 = 0;
    v10 = &v15;
    v11 = 1;
    do
    {
      v12 = v11;
      v13 = (*(a2 + 8 * v9) - *(a1 + 8 * v9)) / (*(v6 + 8 * v9) - *(a1 + 8 * v9));
      *v10 = v13;
      v10 = v16;
      v9 = 1;
      v11 = 0;
    }

    while ((v12 & 1) != 0);
  }

  else
  {
    memset_pattern16(&v15, &unk_1B33B25A0, 0x10uLL);
  }

  return v15;
}

double gm::Box<double,3>::lerped(double *a1, uint64_t a2)
{
  if (a1[3] >= *a1 && a1[4] >= a1[1] && a1[5] >= a1[2])
  {
    for (i = 0; i != 3; ++i)
    {
      *(&__b + i * 8) = a1[i] + (a1[i + 3] - a1[i]) * *(a2 + i * 8);
    }
  }

  else
  {
    memset_pattern16(&__b, &unk_1B33B25A0, 0x18uLL);
  }

  return __b;
}

double gm::Box<double,3>::operator+=(double *a1, uint64_t a2)
{
  v2 = a1 + 3;
  result = a1[3];
  if (result >= *a1)
  {
    result = a1[4];
    if (result >= a1[1])
    {
      result = a1[5];
      if (result >= a1[2])
      {
        for (i = 0; i != 3; ++i)
        {
          a1[i] = a1[i] + *(a2 + i * 8);
        }

        for (j = 0; j != 3; ++j)
        {
          result = v2[j] + *(a2 + j * 8);
          v2[j] = result;
        }
      }
    }
  }

  return result;
}

double gm::Box<double,3>::operator*(uint64_t a1, uint64_t a2, double a3)
{
  v6 = gm::Box<double,3>::center<double>(a2);
  v7 = 0;
  *v25 = v6;
  v25[1] = v8;
  v25[2] = v9;
  do
  {
    v26.f64[v7] = *(a2 + v7 * 8 + 24) - *(a2 + v7 * 8);
    ++v7;
  }

  while (v7 != 3);
  v10 = 0;
  v23 = vmaxnmq_f64(v26, 0);
  v24 = fmax(v27, 0.0);
  do
  {
    v26.f64[v10] = v23.f64[v10] * 0.5;
    ++v10;
  }

  while (v10 != 3);
  v11 = 0;
  v17 = v26;
  v18 = v27;
  do
  {
    v26.f64[v11] = v17.f64[v11] * a3;
    ++v11;
  }

  while (v11 != 3);
  v12 = 0;
  v19 = v26;
  v20 = v27;
  do
  {
    v26.f64[v12] = *&v25[v12] - v19.f64[v12];
    ++v12;
  }

  while (v12 != 3);
  v13 = 0;
  v21 = v26;
  v22 = v27;
  do
  {
    v26.f64[v13] = v23.f64[v13] * a3;
    ++v13;
  }

  while (v13 != 3);
  v14 = 0;
  v19 = v26;
  v20 = v27;
  do
  {
    v26.f64[v14] = v19.f64[v14] + v21.f64[v14];
    ++v14;
  }

  while (v14 != 3);
  result = v27;
  v16 = v26;
  *a1 = v21;
  *(a1 + 16) = v22;
  *(a1 + 24) = v16;
  *(a1 + 40) = result;
  return result;
}

double gm::Box<double,3>::corners(void *a1, uint64_t a2)
{
  for (i = 0; i != 8; ++i)
  {
    v3 = 0;
    v4 = a1;
    do
    {
      v5 = v4 + 3;
      if ((i >> v3))
      {
        v5 = v4;
      }

      *(&v8 + v3++) = *v5;
      ++v4;
    }

    while (v3 != 3);
    v6 = a2 + 24 * i;
    result = v9;
    *v6 = v8;
    *(v6 + 16) = result;
  }

  return result;
}

float gm::LineSegment<float,2>::distanceSquaredTo(float *a1, float a2, float a3)
{
  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  v7 = ((v5 * (a2 - *a1)) + (v6 * (a3 - v4))) / ((v5 * v5) + (v6 * v6));
  if (v7 >= 0.0)
  {
    if (v7 <= 1.0)
    {
      v3 = v3 + (v7 * v5);
      v4 = v4 + (v7 * v6);
    }

    else
    {
      v3 = v5 + v3;
      v4 = v6 + v4;
    }
  }

  return ((v3 - a2) * (v3 - a2)) + ((v4 - a3) * (v4 - a3));
}

BOOL gm::Ray<float,2>::segmentIntersectsBox(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  v4 = 0;
  v5 = 0;
  *a3 = 0.0;
  *a4 = 1.0;
  v6 = a2 + 8;
  do
  {
    while (1)
    {
      v7 = *(a1 + 8 + 4 * v5);
      if (fabsf(v7) >= 1.0e-10)
      {
        break;
      }

      v8 = *(a1 + 4 * v5);
      if (v8 < *(a2 + 4 * v5))
      {
        return 0;
      }

      v9 = *(v6 + 4 * v5);
      v10 = (v8 > v9) | v4;
      v4 = 1;
      v5 = 1;
      if (v10)
      {
        return v8 <= v9;
      }
    }

    v11 = 1.0 / v7;
    v12 = *(a1 + 4 * v5);
    v13 = (*(a2 + 4 * v5) - v12) * v11;
    v14 = (*(v6 + 4 * v5) - v12) * v11;
    *a3 = fmaxf(*a3, fminf(v13, v14));
    v15 = fminf(fmaxf(v13, v14), *a4);
    *a4 = v15;
    v5 = 1;
    v16 = (*a3 <= v15) & (v4 ^ 1);
    v4 = 1;
  }

  while ((v16 & 1) != 0);
  return *a3 <= v15;
}

BOOL gm::Ray<double,2>::segmentIntersectsBox(uint64_t a1, uint64_t a2, double *a3, double *a4, double a5)
{
  v5 = 0;
  v6 = 0;
  *a3 = 0.0;
  *a4 = 1.0;
  v7 = a2 + 16;
  do
  {
    while (1)
    {
      v8 = *(a1 + 16 + 8 * v6);
      if (fabs(v8) >= a5)
      {
        break;
      }

      v9 = *(a1 + 8 * v6);
      if (v9 < *(a2 + 8 * v6))
      {
        return 0;
      }

      v10 = *(v7 + 8 * v6);
      v11 = (v9 > v10) | v5;
      v5 = 1;
      v6 = 1;
      if (v11)
      {
        return v9 <= v10;
      }
    }

    v12 = 1.0 / v8;
    v13 = *(a1 + 8 * v6);
    v14 = (*(a2 + 8 * v6) - v13) * v12;
    v15 = (*(v7 + 8 * v6) - v13) * v12;
    *a3 = fmax(*a3, fmin(v14, v15));
    v16 = fmin(fmax(v14, v15), *a4);
    *a4 = v16;
    v6 = 1;
    v17 = (*a3 <= v16) & (v5 ^ 1);
    v5 = 1;
  }

  while ((v17 & 1) != 0);
  return *a3 <= v16;
}

float gm::Ray<float,3>::at(uint64_t a1, float a2)
{
  for (i = 0; i != 12; i += 4)
  {
    *(&v7 + i) = *(a1 + 12 + i) * a2;
  }

  v3 = 0;
  v5 = v7;
  v6 = v8;
  do
  {
    *(&v7 + v3) = *(&v5 + v3) + *(a1 + v3);
    v3 += 4;
  }

  while (v3 != 12);
  return *&v7;
}

BOOL gm::Ray<float,3>::segmentIntersectsBox(float *a1, float *a2, float *a3, float *a4)
{
  v4 = 0;
  *a3 = 0.0;
  *a4 = 3.4028e38;
  v5 = -3;
  do
  {
    v6 = a1[3];
    if (fabsf(v6) >= 0.000001)
    {
      v7 = 1.0 / v6;
      v8 = (*a2 - *a1) * v7;
      v9 = (a2[3] - *a1) * v7;
      *a3 = fmaxf(*a3, fminf(v8, v9));
      v10 = fminf(fmaxf(v8, v9), *a4);
      *a4 = v10;
      if (*a3 > v10)
      {
        return v4;
      }

      goto LABEL_7;
    }

    if (*a1 < *a2 || *a1 > a2[3])
    {
      break;
    }

LABEL_7:
    v4 = (v5 + 3) > 1;
    ++a2;
    ++a1;
  }

  while (!__CFADD__(v5++, 1));
  return v4;
}

double gm::LineSegment<double,3>::distanceSquaredTo(uint64_t a1, uint64_t a2)
{
  v4 = gm::Ray<double,3>::closestOffsetTo(a1, a2);
  if (v4 >= 0.0)
  {
    if (v4 <= 1.0)
    {
      v11 = gm::Ray<double,3>::at(a1, v4);
      v12 = 0;
      *&v16 = v11;
      *(&v16 + 1) = v13;
      v17 = v14;
      do
      {
        *(&v18 + v12) = *(&v16 + v12) - *(a2 + v12);
        v12 += 8;
      }

      while (v12 != 24);
      v15 = 0;
      result = 0.0;
      do
      {
        result = result + *(&v18 + v15) * *(&v18 + v15);
        v15 += 8;
      }

      while (v15 != 24);
    }

    else
    {
      for (i = 0; i != 24; i += 8)
      {
        *(&v18 + i) = *(a1 + i + 24) + *(a1 + i);
      }

      v9 = 0;
      v16 = v18;
      v17 = v19;
      do
      {
        *(&v18 + v9) = *(&v16 + v9) - *(a2 + v9);
        v9 += 8;
      }

      while (v9 != 24);
      v10 = 0;
      result = 0.0;
      do
      {
        result = result + *(&v18 + v10) * *(&v18 + v10);
        v10 += 8;
      }

      while (v10 != 24);
    }
  }

  else
  {
    for (j = 0; j != 24; j += 8)
    {
      *(&v18 + j) = *(a1 + j) - *(a2 + j);
    }

    v6 = 0;
    result = 0.0;
    do
    {
      result = result + *(&v18 + v6) * *(&v18 + v6);
      v6 += 8;
    }

    while (v6 != 24);
  }

  return result;
}

double gm::Ray<double,3>::closestOffsetTo(uint64_t a1, uint64_t a2)
{
  for (i = 0; i != 24; i += 8)
  {
    *(&v9 + i) = *(a2 + i) - *(a1 + i);
  }

  v3 = 0;
  v4 = a1 + 24;
  v5 = 0.0;
  do
  {
    v5 = v5 + *(v4 + v3) * *(&v9 + v3);
    v3 += 8;
  }

  while (v3 != 24);
  v6 = 0;
  v7 = 0.0;
  do
  {
    v7 = v7 + *(v4 + v6) * *(v4 + v6);
    v6 += 8;
  }

  while (v6 != 24);
  return v5 / v7;
}

void gm::Matrix<double,3,1>::description(std::string *a1, uint64_t a2)
{
  v13 = *MEMORY[0x1E69E9840];
  std::string::basic_string[abi:nn200100]<0>(a1, "");
  for (i = 0; i != 24; i += 8)
  {
    std::string::basic_string[abi:nn200100]<0>(&__p, "(");
    if ((v12 & 0x80u) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p;
    }

    if ((v12 & 0x80u) == 0)
    {
      v6 = v12;
    }

    else
    {
      v6 = v11;
    }

    std::string::append(a1, p_p, v6);
    if (v12 < 0)
    {
      operator delete(__p);
    }

    snprintf(&__p, 0xAuLL, "%3.6f", *(a2 + i));
    v7 = strlen(&__p);
    std::string::append(a1, &__p, v7);
    std::string::basic_string[abi:nn200100]<0>(&__p, ")\n");
    if ((v12 & 0x80u) == 0)
    {
      v8 = &__p;
    }

    else
    {
      v8 = __p;
    }

    if ((v12 & 0x80u) == 0)
    {
      v9 = v12;
    }

    else
    {
      v9 = v11;
    }

    std::string::append(a1, v8, v9);
    if (v12 < 0)
    {
      operator delete(__p);
    }
  }
}

void gm::Matrix<double,4,4>::description(std::string *a1, uint64_t a2)
{
  v17 = *MEMORY[0x1E69E9840];
  std::string::basic_string[abi:nn200100]<0>(a1, "");
  for (i = 0; i != 4; ++i)
  {
    std::string::basic_string[abi:nn200100]<0>(&__p, "(");
    if ((v15 & 0x80u) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p;
    }

    if ((v15 & 0x80u) == 0)
    {
      v6 = v15;
    }

    else
    {
      v6 = v14;
    }

    std::string::append(a1, p_p, v6);
    if (v15 < 0)
    {
      operator delete(__p);
    }

    for (j = 0; ; j += 32)
    {
      snprintf(__str, 0xAuLL, "%3.6f", *(a2 + j));
      v8 = strlen(__str);
      std::string::append(a1, __str, v8);
      if (j == 96)
      {
        break;
      }

      std::string::basic_string[abi:nn200100]<0>(&__p, ", ");
      if ((v15 & 0x80u) == 0)
      {
        v9 = &__p;
      }

      else
      {
        v9 = __p;
      }

      if ((v15 & 0x80u) == 0)
      {
        v10 = v15;
      }

      else
      {
        v10 = v14;
      }

      std::string::append(a1, v9, v10);
      if (v15 < 0)
      {
        operator delete(__p);
      }
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, ")\n");
    if ((v15 & 0x80u) == 0)
    {
      v11 = &__p;
    }

    else
    {
      v11 = __p;
    }

    if ((v15 & 0x80u) == 0)
    {
      v12 = v15;
    }

    else
    {
      v12 = v14;
    }

    std::string::append(a1, v11, v12);
    if (v15 < 0)
    {
      operator delete(__p);
    }

    a2 += 8;
  }
}

uint64_t gm::Plane3<float>::Plane3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (i = 0; i != 3; ++i)
  {
    v23[i] = *(a3 + i * 4) - *(a2 + i * 4);
  }

  v8 = gm::Matrix<float,3,1>::normalized<int,void>(v23);
  v10 = v9;
  v12 = v11;
  for (j = 0; j != 3; ++j)
  {
    v23[j] = *(a4 + j * 4) - *(a2 + j * 4);
  }

  v14 = gm::Matrix<float,3,1>::normalized<int,void>(v23);
  v23[0] = -((v15 * v12) - (v16 * v10));
  v23[1] = -((v16 * v8) - (v14 * v12));
  v23[2] = -((v14 * v10) - (v15 * v8));
  v17 = gm::Matrix<float,3,1>::normalized<int,void>(v23);
  v18 = 0;
  *a1 = v17;
  *(a1 + 4) = v19;
  *(a1 + 8) = v20;
  v21 = 0.0;
  do
  {
    v21 = v21 + (*(a1 + v18) * *(a2 + v18));
    v18 += 4;
  }

  while (v18 != 12);
  *(a1 + 12) = -v21;
  return a1;
}

BOOL gm::Plane3<float>::intersect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = 0;
  v5 = *(a2 + 4);
  v6 = *(a3 + 4);
  v7.i32[0] = vdup_lane_s32(v6, 1).u32[0];
  v7.i32[1] = *a3;
  v8.i32[0] = vdup_lane_s32(v5, 1).u32[0];
  v8.i32[1] = *a2;
  v9 = -((*a3 * v5.f32[0]) - (*a2 * v6.f32[0]));
  v38 = vmla_f32(vneg_f32(vmul_f32(v8, v6)), v5, v7);
  v39 = v9;
  v10 = 0.0;
  do
  {
    v10 = v10 + (v38.f32[v4] * *(a1 + v4 * 4));
    ++v4;
  }

  while (v4 != 3);
  v11 = fabsf(v10);
  if (v11 >= 0.00000011921)
  {
    v12 = 0;
    v13 = -*(a1 + 12);
    do
    {
      *&v40[v12 * 4] = v38.f32[v12] * v13;
      ++v12;
    }

    while (v12 != 3);
    v14 = 0;
    v34 = *v40;
    v35 = *&v40[8];
    v15 = -*(a3 + 12);
    do
    {
      *&v40[v14] = *(a2 + v14) * v15;
      v14 += 4;
    }

    while (v14 != 12);
    v16 = 0;
    v30 = *v40;
    v31 = *&v40[8];
    v17 = -*(a2 + 12);
    do
    {
      *&v40[v16] = *(a3 + v16) * v17;
      v16 += 4;
    }

    while (v16 != 12);
    v18 = 0;
    v28 = *v40;
    v29 = *&v40[8];
    do
    {
      *&v40[v18] = *(&v30 + v18) - *(&v28 + v18);
      v18 += 4;
    }

    while (v18 != 12);
    v19 = 0;
    v20.i32[0] = vdup_lane_s32(*&v40[4], 1).u32[0];
    v21 = *(a1 + 4);
    v20.i32[1] = *v40;
    v22.i32[0] = vdup_lane_s32(v21, 1).u32[0];
    v22.i32[1] = *a1;
    v23 = -((*v40 * v21.f32[0]) - (*a1 * *&v40[4]));
    v32 = vmla_f32(vneg_f32(vmul_f32(v22, *&v40[4])), v20, v21);
    v33 = v23;
    do
    {
      *&v40[v19 * 4] = v32.f32[v19] + *(&v34 + v19 * 4);
      ++v19;
    }

    while (v19 != 3);
    v24 = 0;
    v36 = *v40;
    v37 = *&v40[8];
    v25 = 1.0 / v10;
    do
    {
      *&v40[v24] = *(&v36 + v24) * v25;
      v24 += 4;
    }

    while (v24 != 12);
    v26 = *&v40[8];
    *a4 = *v40;
    *(a4 + 8) = v26;
  }

  return v11 >= 0.00000011921;
}

uint64_t gm::Plane3<double>::Plane3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (i = 0; i != 3; ++i)
  {
    v23[i] = *(a3 + i * 8) - *(a2 + i * 8);
  }

  v8 = gm::Matrix<double,3,1>::normalized<int,void>(v23);
  v10 = v9;
  v12 = v11;
  for (j = 0; j != 3; ++j)
  {
    v23[j] = *(a4 + j * 8) - *(a2 + j * 8);
  }

  v14 = gm::Matrix<double,3,1>::normalized<int,void>(v23);
  v23[0] = -(v15 * v12 - v16 * v10);
  v23[1] = -(v16 * v8 - v14 * v12);
  v23[2] = -(v14 * v10 - v15 * v8);
  v17 = gm::Matrix<double,3,1>::normalized<int,void>(v23);
  v18 = 0;
  *a1 = v17;
  *(a1 + 8) = v19;
  *(a1 + 16) = v20;
  v21 = 0.0;
  do
  {
    v21 = v21 + *(a1 + v18) * *(a2 + v18);
    v18 += 8;
  }

  while (v18 != 24);
  *(a1 + 24) = -v21;
  return a1;
}

float gm::Quaternion<float>::operator*(uint64_t a1, uint64_t a2)
{
  v2 = 0;
  v3 = *a1;
  v4 = *(a1 + 4);
  v5 = *(a2 + 4);
  v6.i32[0] = vdup_lane_s32(v5, 1).u32[0];
  v6.i32[1] = *a2;
  v7.i32[0] = vdup_lane_s32(v4, 1).u32[0];
  v8.i32[0] = v7.i32[0];
  v8.i32[1] = *a1;
  v9 = -((*a2 * v4.f32[0]) - (*a1 * v5.f32[0]));
  v22 = vmla_f32(vneg_f32(vmul_f32(v8, v5)), v4, v6);
  v23 = v9;
  do
  {
    *&v26[v2 * 4] = v22.f32[v2] + v22.f32[v2];
    ++v2;
  }

  while (v2 != 3);
  v10 = 0;
  v5.i32[0] = *v26;
  v11 = *&v26[4];
  v24 = *v26;
  v25 = *&v26[4];
  v12 = *(a1 + 12);
  do
  {
    *&v26[v10] = *(&v24 + v10) * v12;
    v10 += 4;
  }

  while (v10 != 12);
  v13 = 0;
  v20 = *v26;
  v21 = *&v26[8];
  do
  {
    *&v26[v13] = *(&v20 + v13) + *(a2 + v13);
    v13 += 4;
  }

  while (v13 != 12);
  v14 = 0;
  v22 = *v26;
  v23 = *&v26[8];
  v15 = -((v5.f32[0] * v4.f32[0]) - (v11.f32[0] * v3));
  v16 = vdup_lane_s32(v5, 0);
  v16.i32[0] = v11.i32[1];
  v7.f32[1] = v3;
  v18 = vmla_f32(vneg_f32(vmul_f32(v11, v7)), v4, v16);
  v19 = v15;
  do
  {
    *&v26[v14 * 4] = v18.f32[v14] + v22.f32[v14];
    ++v14;
  }

  while (v14 != 3);
  return *v26;
}

float gm::Quaternion<float>::operator*(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = 0;
  v4 = *(a2 + 12);
  do
  {
    *(&v26 + v3) = *(a3 + v3) * v4;
    v3 += 4;
  }

  while (v3 != 12);
  v5 = 0;
  v22 = v26;
  v23 = v27;
  v6 = *(a3 + 12);
  do
  {
    *(&v26 + v5) = *(a2 + v5) * v6;
    v5 += 4;
  }

  while (v5 != 12);
  v7 = 0;
  v20 = v26;
  v21 = v27;
  do
  {
    *(&v26 + v7) = *(&v20 + v7) + *(&v22 + v7);
    v7 += 4;
  }

  while (v7 != 12);
  v8 = 0;
  v24 = v26;
  v25 = v27;
  v9 = *(a2 + 4);
  v10 = *(a3 + 4);
  v11.i32[0] = vdup_lane_s32(v10, 1).u32[0];
  v11.i32[1] = *a3;
  v12.i32[0] = vdup_lane_s32(v9, 1).u32[0];
  v12.i32[1] = *a2;
  v13 = -((*a3 * v9.f32[0]) - (*a2 * v10.f32[0]));
  v18 = vmla_f32(vneg_f32(vmul_f32(v12, v10)), v9, v11);
  v19 = v13;
  do
  {
    *(&v26 + v8 * 4) = v18.f32[v8] + *(&v24 + v8 * 4);
    ++v8;
  }

  while (v8 != 3);
  v14 = 0;
  v15 = v27;
  v16 = 0.0;
  do
  {
    v16 = v16 + (*(a3 + v14) * *(a2 + v14));
    v14 += 4;
  }

  while (v14 != 12);
  result = -(v16 - (v6 * v4));
  *a1 = v26;
  *(a1 + 8) = v15;
  *(a1 + 12) = result;
  return result;
}

float gm::Quaternion<float>::toMatrix(float *a1, float *a2)
{
  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = v3 + v3;
  v7 = (v3 + v3) * v3;
  v8 = (v4 + v4) * v4;
  v9 = v2 + v2;
  v10 = (v2 + v2) * v3;
  v11 = (v4 + v4) * v5;
  v12 = v10 - v11;
  v13 = v4 * (v2 + v2);
  v14 = v5 * v6;
  v15 = v11 + v10;
  v16 = (v5 * v6) + v13;
  *a1 = 1.0 - (v7 + v8);
  a1[1] = v15;
  v17 = 1.0 - ((v2 + v2) * v2);
  v18 = v6 * v4;
  v19 = v5 * v9;
  a1[6] = v16;
  a1[7] = v18 - v19;
  a1[2] = v13 - v14;
  a1[3] = v12;
  a1[4] = v17 - v8;
  a1[5] = v19 + v18;
  result = v17 - v7;
  a1[8] = result;
  return result;
}

long double gm::Quaternion<double>::angle(uint64_t a1)
{
  v1 = 0;
  v2 = 0.0;
  do
  {
    v2 = v2 + *(a1 + v1) * *(a1 + v1);
    v1 += 8;
  }

  while (v1 != 24);
  v3 = atan2(sqrt(v2), *(a1 + 24));
  return v3 + v3;
}

void gm::Quaternion<double>::slerp(uint64_t a1, uint64_t a2, double a3)
{
  v6 = 0;
  v7 = 0.0;
  do
  {
    v7 = v7 + *(a2 + v6) * *(a1 + v6);
    v6 += 8;
  }

  while (v6 != 24);
  v8 = v7 + *(a2 + 24) * *(a1 + 24);
  v9 = fabs(v8);
  if (v9 >= 1.0)
  {
    for (i = 0; i != 24; i += 8)
    {
      *(a1 + i) = *(a2 + i);
    }

    v13 = *(a2 + 24);
LABEL_17:
    *(a1 + 24) = v13;
    return;
  }

  if (v9 <= 0.95)
  {
    v14 = acos(v9);
    v15 = 1.0 / sin(v14);
    v16 = sin(v14 - a3 * v14);
    v17 = 0;
    v18 = v16 * v15;
    do
    {
      *(a1 + v17) = *(a1 + v17) * v18;
      v17 += 8;
    }

    while (v17 != 24);
    v19 = sin(v14 * a3) * v15;
    *(a1 + 24) = *(a1 + 24) * v18;
    v20 = 0;
    if (v8 <= 0.0)
    {
      do
      {
        *(&v25 + v20) = *(a2 + v20) * v19;
        v20 += 8;
      }

      while (v20 != 24);
      v23 = 0;
      v24 = *(a2 + 24) * v19;
      v26 = v24;
      do
      {
        *(a1 + v23) = *(a1 + v23) - *(&v25 + v23);
        v23 += 8;
      }

      while (v23 != 24);
      v13 = *(a1 + 24) - v24;
    }

    else
    {
      do
      {
        *(&v25 + v20) = *(a2 + v20) * v19;
        v20 += 8;
      }

      while (v20 != 24);
      v21 = 0;
      v22 = *(a2 + 24) * v19;
      v26 = v22;
      do
      {
        *(a1 + v21) = *(a1 + v21) + *(&v25 + v21);
        v21 += 8;
      }

      while (v21 != 24);
      v13 = *(a1 + 24) + v22;
    }

    goto LABEL_17;
  }

  v10 = 0;
  if (v8 <= 0.0)
  {
    do
    {
      *(a1 + v10) = -*(a1 + v10);
      v10 += 8;
    }

    while (v10 != 24);
    v11 = 0;
    *(a1 + 24) = -*(a1 + 24);
    do
    {
      *(a1 + v11) = *(a1 + v11) + (*(a2 + v11) - *(a1 + v11)) * a3;
      v11 += 8;
    }

    while (v11 != 24);
  }

  else
  {
    do
    {
      *(a1 + v10) = *(a1 + v10) + (*(a2 + v10) - *(a1 + v10)) * a3;
      v10 += 8;
    }

    while (v10 != 24);
  }

  *(a1 + 24) = *(a1 + 24) + (*(a2 + 24) - *(a1 + 24)) * a3;

  gm::Quaternion<double>::normalize(a1);
}

void sub_1B32DCD50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a16 < 0)
  {
    operator delete(__p);
  }

  if (a23 < 0)
  {
    operator delete(a18);
  }

  if (a30 < 0)
  {
    operator delete(a25);
  }

  if (*(v30 - 56) == 1)
  {
    (*(**(v30 - 88) + 56))(*(v30 - 88));
  }

  v32 = *(v30 - 64);
  if (v32)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v32);
  }

  v33 = *(v30 - 80);
  if (v33)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v33);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<void ()(gm::Range<unsigned long> const&,gm::Range<unsigned long> const&,ggl::DataWrite<ggl::PolygonCommonStroke::DefaultVbo> &,ggl::DataWrite<unsigned short> &)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void sub_1B32DD6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v12);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B32DD860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(gm::Range<unsigned long> const&,gm::Range<unsigned long> const&,ggl::DataWrite<ggl::PolygonBase::CompressedVbo> &,ggl::DataWrite<unsigned short> &)>::~__value_func[abi:nn200100](va);
  _Unwind_Resume(a1);
}

void sub_1B32DDC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  MEMORY[0x1B8C62190](v17, 0x10F1C40141CD30ALL);
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ggl::PolygonCommonStroke::MeshMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57430;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B32DEB08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a12);
  }

  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v17);
  }

  _Unwind_Resume(exception_object);
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<BOOL,GeoCodecsFeatureStylePair>>>(unint64_t a1)
{
  if (a1 < 0x1555555555555556)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void sub_1B32DF334(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B32DF7B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, std::__shared_weak_count *a31)
{
  if (a31)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a31);
  }

  std::unique_ptr<md::MeshSetStorage>::reset[abi:nn200100](v33 + 20, 0);
  ggl::BufferMemory::~BufferMemory((v33 + 12));
  ggl::BufferMemory::~BufferMemory((v33 + 6));
  *(v34 - 128) = v32;
  std::vector<std::shared_ptr<md::MuninRoadLabel>>::__destroy_vector::operator()[abi:nn200100]((v34 - 128));
  if (__p)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::PolygonCommonStroke::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A573B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B32DFAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  _Unwind_Resume(exception_object);
}

void md::Logic<md::PuckLocationAnimationTracingLogic,md::PuckLocationAnimationTracingContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  v3[12] = 0;
  (*(*a1 + 56))(v3);
  gdc::DebugTreeNode::toString(a2);
}

id GEOGetVectorKitPuckTrackingLog(void)
{
  if (GEOGetVectorKitPuckTrackingLog(void)::onceToken != -1)
  {
    dispatch_once(&GEOGetVectorKitPuckTrackingLog(void)::onceToken, &__block_literal_global_47875);
  }

  v1 = GEOGetVectorKitPuckTrackingLog(void)::log;

  return v1;
}

void md::PuckLocationAnimationTracingLogic::publishEvent(uint64_t a1, uint64_t a2, int a3)
{
  if (md::PuckLocationAnimationTracingLogic::canPublishEvents(*(a1 + 368)))
  {
    v8 = [[VKNavigationPuckLocationTracingEvent alloc] initWithEventType:qword_1B3418328[a3] timestamp:*(a2 + 24) locationUUID:CFAbsoluteTimeGetCurrent()];
    v9 = v8;
    v6 = *(a1 + 368);
    if (!v6)
    {
      v7 = std::__throw_bad_function_call[abi:nn200100]();

      _Unwind_Resume(v7);
    }

    (*(*v6 + 48))(v6, &v9);
  }
}

void std::deque<md::PuckAnimationTraceEvent>::pop_front(uint64_t a1)
{
  v2 = (*(*(a1 + 8) + ((*(a1 + 32) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (*(a1 + 32) & 0x7FLL));

  v3 = vaddq_s64(*(a1 + 32), xmmword_1B33B14D0);
  *(a1 + 32) = v3;
  if (v3.i64[0] >= 0x100uLL)
  {
    operator delete(**(a1 + 8));
    *(a1 + 8) += 8;
    *(a1 + 32) -= 128;
  }
}

id std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::emplace_back<unsigned long const&,md::PuckAnimationTraceEvent const&>(void *a1, void *a2, uint64_t a3)
{
  v6 = a1[1];
  v7 = a1[2];
  if (v7 == v6)
  {
    v8 = 0;
  }

  else
  {
    v8 = 102 * ((v7 - v6) >> 3) - 1;
  }

  v9 = a1[4];
  if (v8 == a1[5] + v9)
  {
    v10 = v9 >= 0x66;
    v11 = v9 - 102;
    if (!v10)
    {
      v12 = a1[3];
      v13 = v12 - *a1;
      if (v7 - v6 < v13)
      {
        operator new();
      }

      v14 = v13 >> 2;
      if (v12 == *a1)
      {
        v15 = 1;
      }

      else
      {
        v15 = v14;
      }

      std::__allocate_at_least[abi:nn200100]<std::allocator<std::unique_ptr<std::array<unsigned short,128ul>>>>(v15);
    }

    a1[4] = v11;
    v19 = *v6;
    a1[1] = v6 + 8;
    std::__split_buffer<gdc::TrianglePair *>::emplace_back<gdc::TrianglePair *&>(a1, &v19);
    v6 = a1[1];
    v7 = a1[2];
  }

  if (v7 == v6)
  {
    v17 = 0;
  }

  else
  {
    v16 = a1[5] + a1[4];
    v17 = (*&v6[8 * (v16 / 0x66)] - 4080 * (v16 / 0x66) + 40 * v16);
  }

  *v17 = *a2;
  v17[1] = *a3;
  v17[2] = *(a3 + 8);
  v17[3] = *(a3 + 16);
  result = *(a3 + 24);
  v17[4] = result;
  ++a1[5];
  return result;
}

void sub_1B32E02BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11)
{
  operator delete(v11);
  if (a11)
  {
    operator delete(a11);
  }

  _Unwind_Resume(a1);
}

void ___ZL30GEOGetVectorKitPuckTrackingLogv_block_invoke()
{
  v0 = os_log_create("com.apple.VectorKit", "PuckTracking");
  v1 = GEOGetVectorKitPuckTrackingLog(void)::log;
  GEOGetVectorKitPuckTrackingLog(void)::log = v0;
}

uint64_t md::Logic<md::PuckLocationAnimationTracingLogic,md::PuckLocationAnimationTracingContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  v10 = *MEMORY[0x1E69E9840];
  if (*(a3 + 8) == 0xA81ACD73F9C92AA1 && (v4 = *(a3 + 32)) != 0)
  {
    v6 = result;
    v8 = md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>::resolveDependencies(**(a2 + 8), *(*(a2 + 8) + 8));
    v9 = v7;
    return (*(*v6 + 160))(v6, a2, &v8, v4);
  }

  else
  {
    a4[23] = 0;
    *a4 = 0;
  }

  return result;
}

uint64_t gdc::ObjectHolder<md::PuckLocationAnimationTracingContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 32);
  *(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::PuckLocationAnimationTracingContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1F2A57760;
  v1 = a1[4];
  if (v1)
  {
    MEMORY[0x1B8C62190](v1, 0xC400A2AC0F1);
  }

  JUMPOUT(0x1B8C62190);
}

void *gdc::ManagedObjectHolder<md::PuckLocationAnimationTracingContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1F2A57760;
  v2 = a1[4];
  if (v2)
  {
    MEMORY[0x1B8C62190](v2, 0xC400A2AC0F1);
  }

  return a1;
}

void md::PuckLocationAnimationTracingLogic::~PuckLocationAnimationTracingLogic(id *this)
{
  md::PuckLocationAnimationTracingLogic::~PuckLocationAnimationTracingLogic(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A574F8;
  md::PuckLocationAnimationTracingLogic::tearDownTracing(this);
  std::__function::__value_func<void ()(VKNavigationPuckLocationTracingEvent *)>::~__value_func[abi:nn200100]((this + 43));

  std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::~deque[abi:nn200100]((this + 36));
  std::deque<md::PuckAnimationTraceEvent>::~deque[abi:nn200100]((this + 30));
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((this + 20));
  *this = off_1F2A578C0;
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(this[13]);
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(this[10]);
}

void sub_1B32E05C8(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(VKNavigationPuckLocationTracingEvent *)>::~__value_func[abi:nn200100](v1 + 344);

  std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::~deque[abi:nn200100](v1 + 288);
  std::deque<md::PuckAnimationTraceEvent>::~deque[abi:nn200100](v1 + 240);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 160);
  *v1 = off_1F2A578C0;
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v1 + 104));
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v1 + 80));
  _Unwind_Resume(a1);
}

void md::PuckLocationAnimationTracingLogic::tearDownTracing(md::PuckLocationAnimationTracingLogic *this)
{
  if (*(this + 136) == 1)
  {
    [*(this + 42) unsubscribeFromLocationUpdates:*(this + 16)];
    if (*(this + 136) == 1)
    {
      *(this + 136) = 0;
    }
  }

  if (*(this + 152) == 1)
  {
    md::MapEngineSignals::ThreadSafeSignal<unsigned long,BOOL>::disconnect(*(this + 15), *(this + 18));
    if (*(this + 152) == 1)
    {
      *(this + 152) = 0;
    }
  }

  while (*(this + 35))
  {
    md::PuckLocationAnimationTracingLogic::publishEvent(this, *(*(this + 31) + ((*(this + 34) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (*(this + 34) & 0x7FLL), 0);
    std::deque<md::PuckAnimationTraceEvent>::pop_front(this + 240);
  }

  while (*(this + 41))
  {
    md::PuckLocationAnimationTracingLogic::publishEvent(this, *(*(this + 37) + 8 * (*(this + 40) / 0x66uLL)) + 40 * (*(this + 40) % 0x66uLL) + 8, 0);
    std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::pop_front(this + 288);
  }
}

uint64_t std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::~deque[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v3 == v2)
  {
    v4 = (a1 + 40);
    v10 = *(a1 + 8);
  }

  else
  {
    v4 = (a1 + 40);
    v5 = *(a1 + 32);
    v6 = &v2[v5 / 0x66];
    v7 = (*v6 + 40 * v5 + -4080 * (v5 / 0x66));
    v8 = v2[(*(a1 + 40) + v5) / 0x66] + 40 * *(a1 + 40) + 40 * v5 + -4080 * ((*(a1 + 40) + v5) / 0x66);
    if (v7 != v8)
    {
      do
      {

        v7 += 5;
        if (v7 - *v6 == 4080)
        {
          v9 = v6[1];
          ++v6;
          v7 = v9;
        }
      }

      while (v7 != v8);
      v2 = *(a1 + 8);
      v3 = *(a1 + 16);
    }

    v10 = v3;
  }

  *v4 = 0;
  v11 = v10 - v2;
  if (v11 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = *(a1 + 16);
      v2 = (*(a1 + 8) + 8);
      *(a1 + 8) = v2;
      v11 = v3 - v2;
    }

    while (v11 > 2);
  }

  if (v11 == 1)
  {
    v12 = 51;
    goto LABEL_15;
  }

  if (v11 == 2)
  {
    v12 = 102;
LABEL_15:
    *(a1 + 32) = v12;
  }

  if (v2 != v3)
  {
    do
    {
      v13 = *v2++;
      operator delete(v13);
    }

    while (v2 != v3);
    v15 = *(a1 + 8);
    v14 = *(a1 + 16);
    if (v14 != v15)
    {
      *(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

uint64_t std::deque<md::PuckAnimationTraceEvent>::~deque[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v3 == v2)
  {
    v4 = (a1 + 40);
    v11 = *(a1 + 8);
  }

  else
  {
    v4 = (a1 + 40);
    v5 = *(a1 + 32);
    v6 = &v2[v5 >> 7];
    v7 = *v6 + 32 * (v5 & 0x7F);
    v8 = *(v2 + (((*(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((*(a1 + 40) + v5) & 0x7F);
    if (v7 != v8)
    {
      do
      {

        v9 = *v7;
        v7 += 32;

        if (v7 - *v6 == 4096)
        {
          v10 = v6[1];
          ++v6;
          v7 = v10;
        }
      }

      while (v7 != v8);
      v2 = *(a1 + 8);
      v3 = *(a1 + 16);
    }

    v11 = v3;
  }

  *v4 = 0;
  v12 = v11 - v2;
  if (v12 >= 3)
  {
    do
    {
      operator delete(*v2);
      v3 = *(a1 + 16);
      v2 = (*(a1 + 8) + 8);
      *(a1 + 8) = v2;
      v12 = v3 - v2;
    }

    while (v12 > 2);
  }

  if (v12 == 1)
  {
    v13 = 64;
    goto LABEL_15;
  }

  if (v12 == 2)
  {
    v13 = 128;
LABEL_15:
    *(a1 + 32) = v13;
  }

  if (v2 != v3)
  {
    do
    {
      v14 = *v2++;
      operator delete(v14);
    }

    while (v2 != v3);
    v16 = *(a1 + 8);
    v15 = *(a1 + 16);
    if (v15 != v16)
    {
      *(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::pop_front(uint64_t a1)
{
  v2 = (*(*(a1 + 8) + 8 * (*(a1 + 32) / 0x66uLL)) - 4080 * (*(a1 + 32) / 0x66uLL) + 40 * *(a1 + 32));

  v3 = vaddq_s64(*(a1 + 32), xmmword_1B33B14D0);
  *(a1 + 32) = v3;
  if (v3.i64[0] >= 0xCCuLL)
  {
    operator delete(**(a1 + 8));
    *(a1 + 8) += 8;
    *(a1 + 32) -= 102;
  }
}

uint64_t md::PuckLocationAnimationTracingLogic::setupTracing(uint64_t this)
{
  v1 = *MEMORY[0x1E69E9840];
  if ((*(this + 136) & 1) == 0 && (*(this + 152) & 1) == 0)
  {
    operator new();
  }

  return this;
}

void sub_1B32E0C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(unsigned long,BOOL)>::~__value_func[abi:nn200100](va);
  _Unwind_Resume(a1);
}

void md::PuckLocationAnimationTracingLogic::didDisplayFrame(md::PuckLocationAnimationTracingLogic *this, unint64_t a2)
{
  v11 = *MEMORY[0x1E69E9840];
  while (*(this + 41))
  {
    v4 = (*(*(this + 37) + 8 * (*(this + 40) / 0x66uLL)) - 4080 * (*(this + 40) / 0x66uLL) + 40 * *(this + 40));
    if (*v4 < a2)
    {
      break;
    }

    if (*(this + 176) == 1)
    {
      v5 = GEOGetVectorKitPuckTrackingLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        v6 = v4[4];
        *buf = 138412546;
        v8 = v6;
        v9 = 2048;
        v10 = a2;
        _os_log_impl(&dword_1B2754000, v5, OS_LOG_TYPE_INFO, "[VK] [%@] Frame Displayed - %lu", buf, 0x16u);
      }
    }

    md::PuckLocationAnimationTracingLogic::publishEvent(this, (v4 + 1), 3);
    std::deque<std::pair<unsigned long,md::PuckAnimationTraceEvent>>::pop_front(this + 288);
  }
}

uint64_t std::__function::__func<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(unsigned long),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(unsigned long),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&>>,void ()(unsigned long,BOOL)>::operator()(void *a1, void *a2)
{
  v2 = a1[2];
  v3 = a1[1];
  v4 = (a1[3] + (v2 >> 1));
  if (v2)
  {
    v3 = *(*v4 + v3);
  }

  return v3(v4, *a2);
}

__n128 std::__function::__func<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(unsigned long),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(unsigned long),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&>>,void ()(unsigned long,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A57718;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void md::PuckLocationAnimationTracingLogic::puckAnimatorDidRecieveLocationUpdate(md::PuckLocationAnimationTracingLogic *this, VKPuckAnimator *a2, CLLocation *a3, GEORouteMatch *a4, NSUUID *a5)
{
  v48 = *MEMORY[0x1E69E9840];
  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  if (v11)
  {
    v13 = [(GEORouteMatch *)v11 route];

    if (v13)
    {
      [(VKPuckAnimator *)v9 lastProjectedPosition];
      v15 = v14;
      [(VKPuckAnimator *)v9 lastProjectedPosition];
      v17 = v16;
      v18 = [(GEORouteMatch *)v11 route];
      v19 = exp(v17 * 6.28318531 + -3.14159265);
      v20 = atan(v19) * 114.591559 + -90.0;
      v21 = fmod(v15 * 6.28318531, 6.28318531);
      v22 = [v18 closestPointOnRoute:{v20, (fmod(v21 + 6.28318531, 6.28318531) * 57.2957795 + -180.0)}];
      v40 = HIDWORD(v22);

      v23 = v10;
      if (*(&v22 + 1) >= 1.0)
      {
        v38 = vcvtms_u32_f32(*(&v22 + 1)) + v22;
        *&v40 = *(&v22 + 1) - floorf(*(&v22 + 1));
      }

      else
      {
        v38 = v22;
      }

      v24 = [(GEORouteMatch *)v11 route];
      v39 = v12;
      v25 = *(this + 32);
      v26 = *(this + 31);
      if (v25 == v26)
      {
        v27 = 0;
      }

      else
      {
        v27 = 16 * (v25 - v26) - 1;
      }

      v28 = *(this + 34);
      v29 = *(this + 35) + v28;
      if (v27 == v29)
      {
        if (v28 < 0x80)
        {
          v30 = *(this + 33);
          v31 = *(this + 30);
          if (v25 - v26 < (v30 - v31))
          {
            if (v30 != v25)
            {
              operator new();
            }

            operator new();
          }

          if (v30 == v31)
          {
            v32 = 1;
          }

          else
          {
            v32 = (v30 - v31) >> 2;
          }

          std::__allocate_at_least[abi:nn200100]<std::allocator<std::unique_ptr<std::array<unsigned short,128ul>>>>(v32);
        }

        *(this + 34) = v28 - 128;
        *buf = *v26;
        *(this + 31) = v26 + 8;
        std::__split_buffer<gdc::TrianglePair *>::emplace_back<gdc::TrianglePair *&>(this + 30, buf);
        v26 = *(this + 31);
        v29 = *(this + 35) + *(this + 34);
      }

      *&v33 = v24;
      *(&v33 + 1) = v39;
      v34 = *&v26[(v29 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v29 & 0x7F);
      *v34 = v23;
      *(v34 + 8) = v38;
      *(v34 + 12) = v40;
      *(v34 + 16) = v33;
      ++*(this + 35);
      if (*(this + 176) == 1)
      {
        v35 = GEOGetVectorKitPuckTrackingLog();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          [(GEORouteMatch *)v11 routeCoordinate];
          v36 = GEOPolylineCoordinateAsFullString();
          v37 = GEOPolylineCoordinateAsFullString();
          *buf = 138413058;
          *&buf[4] = v39;
          v42 = 2048;
          v43 = v11;
          v44 = 2112;
          v45 = v36;
          v46 = 2112;
          v47 = v37;
          _os_log_impl(&dword_1B2754000, v35, OS_LOG_TYPE_INFO, "[VK] [%@] Received Location - routeMatch:%p, routeCoordinate:(%@), projectedRouteCoordinate:(%@)", buf, 0x2Au);
        }
      }

      md::PuckLocationAnimationTracingLogic::publishEvent(this, *(*(this + 31) + ((*(this + 34) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (*(this + 34) & 0x7FLL), 1);
    }
  }
}

void sub_1B32E1690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, __int128 a19, uint64_t a20, void *a21)
{
  operator delete(__p);
  if (a19)
  {
    operator delete(a19);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::placeholders::__ph<4> const&>,std::allocator<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::placeholders::__ph<4> const&>>,void ()(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *)>::operator()(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v5 = a1[2];
  v6 = a1[1];
  v7 = (a1[3] + (v5 >> 1));
  if (v5)
  {
    v6 = *(*v7 + v6);
  }

  return v6(v7, *a2, *a3, *a4, *a5);
}

__n128 std::__function::__func<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::placeholders::__ph<4> const&>,std::allocator<std::__bind<void (md::PuckLocationAnimationTracingLogic::*)(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *),md::PuckLocationAnimationTracingLogic*,std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&,std::placeholders::__ph<4> const&>>,void ()(VKPuckAnimator *,CLLocation *,GEORouteMatch *,NSUUID *)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A576D0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void std::__function::__func<md::PuckLocationAnimationTracingLogic::PuckLocationAnimationTracingLogic(md::MapEngineSignals *,VKPuckAnimator *,NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::PuckLocationAnimationTracingLogic::PuckLocationAnimationTracingLogic(md::MapEngineSignals *,VKPuckAnimator *,NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::operator()(uint64_t a1, _BYTE *a2)
{
  v2 = *(a1 + 8);
  if (*a2 == 1)
  {
    md::PuckLocationAnimationTracingLogic::tearDownTracing(v2);
  }

  else
  {
    md::PuckLocationAnimationTracingLogic::setupTracing(v2);
  }
}

uint64_t md::CaptionedIconLabelPart::evaluateFeatureNormalTextPosition(md::CaptionedIconLabelPart *this, md::Label *a2, const LabelLayoutContext *a3)
{
  if (*(this + 164) != 1)
  {
    return 6;
  }

  v35 = v8;
  v36 = v7;
  v37 = v6;
  v38 = v5;
  v39 = v3;
  v40 = v4;
  v11 = 0;
  v12 = this + 152;
  do
  {
    v32[v11] = *&v12[4 * v11];
    ++v11;
  }

  while (v11 != 3);
  for (i = 0; i != 24; i += 8)
  {
    *(&v33 + i) = *(a2 + i + 112) - *(this + i + 616);
  }

  v30 = v33;
  v31 = v34;
  v14 = gm::Matrix<double,3,1>::normalized<int,void>(&v30);
  v16 = v15;
  v18 = v17;
  *&v33 = v14;
  *(&v33 + 1) = v15;
  v34 = v17;
  if (*(a2 + 8))
  {
    v19 = 0.0;
    v20 = 1.0;
    v21 = 0.0;
  }

  else
  {
    v21 = gm::Matrix<double,3,1>::normalized<int,void>(this + 616);
  }

  v23 = 0;
  *&v30 = -(v20 * v16 - v19 * v18);
  *(&v30 + 1) = -(v21 * v18 - v20 * v14);
  v31 = -(v19 * v14 - v21 * v16);
  do
  {
    v24 = *(&v30 + v23);
    v29[v23++] = v24;
  }

  while (v23 != 3);
  v25 = 0;
  v26 = 0.0;
  do
  {
    v26 = v26 + *(&v33 + v25 * 8) * v32[v25];
    ++v25;
  }

  while (v25 != 3);
  if (v26 > *(this + 52))
  {
    return 6;
  }

  v27 = 0;
  v28 = 0.0;
  do
  {
    v28 = v28 + (*&v12[v27 * 4] * v29[v27]);
    ++v27;
  }

  while (v27 != 3);
  return 4 * (v28 <= 0.0);
}

uint64_t std::function<void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  v4 = a2;
  if (a1)
  {
    return (*(*a1 + 48))(a1, &v4);
  }

  v3 = std::__throw_bad_function_call[abi:nn200100]();
  return md::LabelManager::labelMarkerForCustomFeatureAnnotation(v3);
}

void md::LabelManager::labelMarkerForCustomFeatureAnnotation(void *a1, uint64_t a2, void *a3, void *a4)
{
  v8 = a3;
  v7 = a4;
  if (v8 && v7)
  {
    (*(**(a2 + 240) + 16))(*(a2 + 240));
    if ((*(a2 + 3419) & 1) == 0 && (*(a2 + 3418) & 1) == 0)
    {
      md::LabelManager::flushCommands(a2);
    }

    (*(**(a2 + 240) + 176))(*(a2 + 240), v8, v7);
  }

  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void md::LabelManager::adoptSelectedLabelMarker(uint64_t a1, uint64_t *a2)
{
  v4 = (*(**(a1 + 240) + 192))(*(a1 + 240));
  v6 = *a2;
  v5 = a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit((v5 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 3544) = v6;
  v7 = *(a1 + 3552);
  *(a1 + 3552) = v5;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  v9 = *a2;
  v8 = a2[1];
  if (v8)
  {
    atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 3440) = v9;
  v10 = *(a1 + 3448);
  *(a1 + 3448) = v8;
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v10);
  }

  if ((v4 & 1) == 0)
  {

    md::LabelManager::releaseAdoptedSelectedLabelMarker(a1, 1);
  }
}

void md::LabelManager::releaseAdoptedSelectedLabelMarker(md::LabelManager *this, int a2)
{
  if (*(this + 430))
  {
    if (a2)
    {
      v3 = *(this + 17);
      if (v3)
      {
        v4 = *(v3 + 152);
        if (v4)
        {
          std::function<void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::operator()(v4, this);
        }
      }
    }

    (*(**(this + 30) + 200))(*(this + 30));
    v5 = *(this + 444);
    v6 = 0uLL;
    *(this + 3544) = 0u;
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v5);
      v6 = 0uLL;
    }

    v7 = *(this + 431);
    *(this + 215) = v6;
    if (v7)
    {

      std::__shared_weak_count::__release_shared[abi:nn200100](v7);
    }
  }
}

BOOL md::FlyoverDsmTileData::isValid(md::FlyoverDsmTileData *this)
{
  v1 = *(this + 91);
  if (v1 && *v1 != v1[1])
  {
    return 1;
  }

  v3 = *(this + 93);
  return v3 && *v3 != v3[1];
}

unint64_t md::FlyoverDsmTileData::elevationInMetersAtWorldPoint(uint64_t a1, float64x2_t *a2, int a3)
{
  v8 = *a2;
  v5 = md::ElevationRaster::elevationInMetersAtWorldPoint(*(a1 + 728), a3, *a2);
  v6 = HIDWORD(v5);
  if ((v5 & 0x100000000) == 0 && *(a1 + 744))
  {
    v5 = md::ElevationRaster::elevationInMetersAtWorldPoint(*(a1 + 744), a3, v8);
    v6 = HIDWORD(v5);
  }

  return v5 | (v6 << 32);
}

uint64_t md::FlyoverDsmTileData::containsWorldPoint(uint64_t a1, float64x2_t *a2)
{
  v2 = *(a1 + 728);
  if (v2 || (v2 = *(a1 + 744)) != 0)
  {
    v3 = 1 << *(v2 + 57);
    v4.i64[0] = *(v2 + 64);
    v4.i64[1] = v3 + ~*(v2 + 60);
    v5 = vmulq_n_f64(vmlsq_lane_f64(*a2, vcvtq_f64_s64(v4), 1.0 / v3, 0), v3);
    v6 = vcvt_hight_f32_f64(vcvt_f32_f64(v5), v5);
    v7.i32[0] = vmovn_s32(vcgeq_f32(xmmword_1B33B09C0, v6)).u32[0];
    v7.i32[1] = vmovn_s32(vcgeq_f32(v6, xmmword_1B33B09C0)).i32[1];
    LOBYTE(v2) = vminv_u16(vcltz_s16(vshl_n_s16(v7, 0xFuLL)));
  }

  return v2 & 1;
}

void md::FlyoverDsmTileData::~FlyoverDsmTileData(md::FlyoverDsmTileData *this)
{
  md::FlyoverDsmTileData::~FlyoverDsmTileData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A57788;
  *(this + 80) = &unk_1F2A577F0;
  v2 = *(this + 94);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 92);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  md::MapTileData::~MapTileData(this);
}

unint64_t md::FlyoverDsmTileData::heightBounds(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  v3 = *a3;
  if (*a3)
  {
    v4 = *v3;
    v5 = *(v3 + 32);
    v6 = *(v3 + 40);
    v7 = *(a2 + 1);
    v8 = *(v3 + 57);
    v9 = v7 - v8;
    v10 = *(a2 + 8) - (HIDWORD(*(v3 + 60)) << (v7 - v8));
    v11 = (((-1 << v8) + *(v3 + 60) + 1) << (v7 - v8)) + ~(-1 << v7) - *(a2 + 4);
    v12 = 1 << v9;
    v14 = v12 > v5 || v12 > v6;
    if (*(v3 + 24) == 8)
    {
      if (v14)
      {
        v15 = v5 / v12;
        v16 = fabsf(v15 * v10);
        v17 = v16;
        v18 = (ceilf(v15) + truncf(v16));
        v19 = v6 / v12;
        v20 = fabsf(v19 * v11);
        v21 = v20;
        v22 = (ceilf(v19) + truncf(v20));
      }

      else
      {
        v17 = v10 * v5 / v12;
        v18 = v5 / v12 + v17;
        v21 = v11 * v6 / v12;
        v22 = v6 / v12 + v21;
      }

      v32 = 40075000.0;
      v33 = -40075000.0;
      if (v21 < v22)
      {
        v34 = 0;
        v35 = 0;
        v36 = v17 + (~v21 + v5) * v5;
        v37 = -1;
        do
        {
          v38 = v36;
          v39 = v18 - v17;
          if (v18 > v17)
          {
            do
            {
              v40 = *(v4 + v38);
              v41 = v34;
              if (v40 > v34)
              {
                v41 = *(v4 + v38);
              }

              v42 = v37;
              if (v40 < v37)
              {
                v42 = *(v4 + v38);
              }

              v35 |= v40 == 255;
              if (v40 != 255)
              {
                v34 = v41;
                v37 = v42;
              }

              ++v38;
              --v39;
            }

            while (v39);
          }

          ++v21;
          v36 -= v5;
        }

        while (v21 != v22);
        if (v37 <= v34)
        {
          v43 = *(v3 + 52);
          v44 = *(v3 + 48);
          v32 = v43 + (v44 * v37);
          v45 = v34;
          goto LABEL_42;
        }
      }
    }

    else
    {
      if (v14)
      {
        v24 = v5 / v12;
        v25 = fabsf(v24 * v10);
        v26 = v25;
        v27 = (ceilf(v24) + truncf(v25));
        v28 = v6 / v12;
        v29 = fabsf(v28 * v11);
        v30 = v29;
        v31 = (ceilf(v28) + truncf(v29));
      }

      else
      {
        v26 = v10 * v5 / v12;
        v27 = v5 / v12 + v26;
        v30 = v11 * v6 / v12;
        v31 = v6 / v12 + v30;
      }

      v32 = 40075000.0;
      v33 = -40075000.0;
      if (v30 < v31)
      {
        v46 = 0;
        v35 = 0;
        v47 = v26 + (~v30 + v5) * v5;
        v48 = -1;
        do
        {
          v49 = v47;
          v50 = v27 - v26;
          if (v27 > v26)
          {
            do
            {
              v51 = *(v4 + 2 * v49);
              v52 = v46;
              if (v51 > v46)
              {
                v52 = *(v4 + 2 * v49);
              }

              v53 = v48;
              if (v51 < v48)
              {
                v53 = *(v4 + 2 * v49);
              }

              v35 |= v51 == 0xFFFF;
              if (v51 != 0xFFFF)
              {
                v46 = v52;
                v48 = v53;
              }

              ++v49;
              --v50;
            }

            while (v50);
          }

          ++v30;
          v47 -= v5;
        }

        while (v30 != v31);
        if (v48 <= v46)
        {
          v43 = *(v3 + 52);
          v44 = *(v3 + 48);
          v32 = v43 + (v44 * v48);
          v45 = v46;
LABEL_42:
          v33 = v43 + (v44 * v45);
          if ((v35 & 1) == 0)
          {
            goto LABEL_46;
          }
        }
      }
    }

    if (*(a1 + 744))
    {
      v54 = md::FlyoverDsmTileData::heightBounds();
      if ((v55 & 1) == 0)
      {
        goto LABEL_47;
      }

      v32 = fminf(v32, *&v54);
      v33 = fmaxf(v33, *(&v54 + 1));
    }

LABEL_46:
    if (v32 <= v33)
    {
      v58 = LODWORD(v32) & 0xFFFFFF00;
      v57 = LOBYTE(v32);
      v56 = LODWORD(v33) << 32;
      goto LABEL_49;
    }

LABEL_47:
    v56 = 0;
    v57 = 0;
    v58 = 0;
LABEL_49:
    v3 = v56 | v58 | v57;
    v23 = v3 & 0xFFFFFFFFFFFFFF00;
    return v3 | v23;
  }

  v23 = 0;
  return v3 | v23;
}

void md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  v3[12] = 0;
  (*(*a1 + 56))(v3);
  gdc::DebugTreeNode::toString(a2);
}

uint64_t md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  if (*(a3 + 8) == 0xBC61DE3EFA7960C9 && *(a3 + 32))
  {
    *&v6[2] = v4;
    v7 = v5;
    return (*(*result + 160))(result, a2, v6);
  }

  else
  {
    a4[23] = 0;
    *a4 = 0;
  }

  return result;
}

uint64_t md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(a3 + 8) == 0xBC61DE3EFA7960C9)
  {
    if (*(a3 + 32))
    {
      *&v5[2] = v3;
      v6 = v4;
      return (*(*result + 152))(result, a2, v5);
    }
  }

  return result;
}

uint64_t md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(a3 + 8) == 0xBC61DE3EFA7960C9)
  {
    if (*(a3 + 32))
    {
      *&v5[2] = v3;
      v6 = v4;
      return (*(*result + 144))(result, a2, v5);
    }
  }

  return result;
}

uint64_t md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(a3 + 8) == 0xBC61DE3EFA7960C9)
  {
    if (*(a3 + 32))
    {
      *&v5[2] = v3;
      v6 = v4;
      return (*(*result + 136))(result, a2, v5);
    }
  }

  return result;
}

uint64_t md::Logic<md::ARDataRequestObserverLogic,md::ARDataRequestObserverContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(a3 + 8) == 0xBC61DE3EFA7960C9)
  {
    if (*(a3 + 32))
    {
      *&v5[2] = v3;
      v6 = v4;
      return (*(*result + 128))(result, a2, v5);
    }
  }

  return result;
}

uint64_t gdc::ObjectHolder<md::ARDataRequestObserverContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 32);
  *(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARDataRequestObserverContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1F2A57940;
  v1 = a1[4];
  if (v1)
  {
    MEMORY[0x1B8C62190](v1, 0xC400A2AC0F1);
  }

  JUMPOUT(0x1B8C62190);
}

void *gdc::ManagedObjectHolder<md::ARDataRequestObserverContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1F2A57940;
  v2 = a1[4];
  if (v2)
  {
    MEMORY[0x1B8C62190](v2, 0xC400A2AC0F1);
  }

  return a1;
}

void md::ARDataRequestObserverLogic::~ARDataRequestObserverLogic(md::ARDataRequestObserverLogic *this)
{
  *this = off_1F2A578C0;
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(this + 13));
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(this + 10));

  JUMPOUT(0x1B8C62190);
}

{
  *this = off_1F2A578C0;
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(this + 13));
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(this + 10));
}

uint64_t md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::compare(uint64_t a1, uint64_t *a2, unsigned __int8 a3)
{
  v4 = *(a1 + 88);
  result = v4 - a3;
  if (v4 == a3)
  {
    v6 = *(a1 + 56);
    v7 = v6[5];
    if (!v7)
    {
      v7 = v6[6];
    }

    v8 = a2[5];
    if (!v8)
    {
      v8 = a2[6];
    }

    v9 = v7 >= v8;
    if (v7 == v8 && (v10 = v6[15], v11 = a2[15], v9 = v10 >= v11, v10 == v11) && (v12 = v6[16], v13 = a2[16], v9 = v12 >= v13, v12 == v13) && (v14 = v6[17], v15 = a2[17], v9 = v14 >= v15, v14 == v15) && (v16 = v6[18], v17 = a2[18], v9 = v16 >= v17, v16 == v17))
    {
      if (v7)
      {
        return 0;
      }

      else
      {
        return geo::codec::featureStyleAttributesCompare(v6[3], a2[3]);
      }
    }

    else if (v9)
    {
      return 1;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

void std::__hash_table<std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,std::equal_to<void *>,std::hash<void *>,true>,geo::allocator_adapter<std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,mdm::zone_mallocator>>::erase(void *a1, void *a2)
{
  v2 = a1[1];
  v3 = a2[1];
  v4 = vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *&v2)
    {
      v3 %= *&v2;
    }
  }

  else
  {
    v3 &= *&v2 - 1;
  }

  v5 = *(*a1 + 8 * v3);
  do
  {
    v6 = v5;
    v5 = *v5;
  }

  while (v5 != a2);
  if (v6 == a1 + 3)
  {
    goto LABEL_18;
  }

  v7 = v6[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v7 >= *&v2)
    {
      v7 %= *&v2;
    }
  }

  else
  {
    v7 &= *&v2 - 1;
  }

  if (v7 != v3)
  {
LABEL_18:
    if (!*a2)
    {
      goto LABEL_19;
    }

    v8 = *(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v2)
      {
        v8 %= *&v2;
      }
    }

    else
    {
      v8 &= *&v2 - 1;
    }

    if (v8 != v3)
    {
LABEL_19:
      *(*a1 + 8 * v3) = 0;
    }
  }

  v9 = *a2;
  if (*a2)
  {
    v10 = *(v9 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v10 >= *&v2)
      {
        v10 %= *&v2;
      }
    }

    else
    {
      v10 &= *&v2 - 1;
    }

    if (v10 != v3)
    {
      *(*a1 + 8 * v10) = v6;
      v9 = *a2;
    }
  }

  *v6 = v9;
  *a2 = 0;
  --a1[5];
  std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](1, a2);
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *>>(v3, a2);
}

void **geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>::~fast_shared_ptr(void **a1)
{
  v2 = *a1;
  if (*a1)
  {
    if ((*v2)-- == 1)
    {
      *(v2 + 1) = &unk_1F2A57C88;
      v4 = *(v2 + 10);
      if (v4)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v4);
      }

      v9.__vftable = (v2 + 32);
      std::vector<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>,geo::allocator_adapter<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v9);
      v5 = *(v2 + 3);
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v5);
      }

      v6 = *a1;
      v7 = mdm::zone_mallocator::instance(v5);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>::_fast_shared_ptr_control>(v7, v6);
      *a1 = 0;
    }
  }

  return a1;
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](mdm::zone_mallocator *a1, uint64_t a2)
{
  if (a1)
  {
    md::LabelFeaturePoolTileInfo::~LabelFeaturePoolTileInfo((a2 + 24));
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<void *,md::LabelFeaturePoolTileInfo>,void *>>(v3, a2);
}

void md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::removeTile(void *a1, uint64_t *a2)
{
  v4 = a1[1];
  std::mutex::lock((v4 + 8));
  v6 = *a2;
  v5 = a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    v7 = a1[3];
    v8 = a1[4];
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    v9 = v5;
  }

  else
  {
    v9 = 0;
    v7 = a1[3];
    v8 = a1[4];
  }

  while (1)
  {
    if (v7 == v8)
    {
      v7 = v8;
      goto LABEL_8;
    }

    if (v7[1] == v6)
    {
      break;
    }

    v7 += 3;
  }

  if (v7 != v8)
  {
    for (i = v7 + 3; i != v8; i += 3)
    {
      v14 = i[1];
      if (v14 != v6)
      {
        *v7 = *i;
        v15 = i[2];
        i[1] = 0;
        i[2] = 0;
        v16 = v7[2];
        v7[1] = v14;
        v7[2] = v15;
        if (v16)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v16);
        }

        v7 += 3;
      }
    }
  }

LABEL_8:
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }

  std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::erase(a1 + 3, v7, a1[4]);
  v10 = a1[3];
  v11 = a1[4];
  if (a1[8] != v6)
  {
LABEL_13:
    if (v10 != v11)
    {
      goto LABEL_15;
    }

    goto LABEL_14;
  }

  if (v10 != v11)
  {
    std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>::operator=[abi:nn200100](a1 + 7, v10);
    v10 = a1[3];
    v11 = a1[4];
    goto LABEL_13;
  }

LABEL_14:
  v12 = a1[1];
  *(v12 + 152) = 0;
  atomic_store(1u, (v12 + 146));
LABEL_15:
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::mutex::unlock((v4 + 8));
}

void std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,geo::allocator_adapter<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,mdm::zone_mallocator>>::__erase_unique<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>(void *a1, void *a2)
{
  if (*a2)
  {
    v4 = *a2 + 8;
  }

  else
  {
    v4 = 0;
  }

  v5 = md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::hash(v4);
  v6 = a1[1];
  if (v6)
  {
    v7 = v5;
    v8 = vcnt_s8(v6);
    v8.i16[0] = vaddlv_u8(v8);
    v9 = v8.u32[0];
    if (v8.u32[0] > 1uLL)
    {
      v10 = v5;
      if (v5 >= *&v6)
      {
        v10 = v5 % *&v6;
      }
    }

    else
    {
      v10 = (*&v6 - 1) & v5;
    }

    v11 = *(*a1 + 8 * v10);
    if (v11)
    {
      for (i = *v11; i; i = *i)
      {
        v13 = i[1];
        if (v13 == v7)
        {
          v14 = i[2];
          if (v14)
          {
            v15 = v14 + 8;
          }

          else
          {
            v15 = 0;
          }

          if (!md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::compare(v15, *a2 + 8))
          {
            v16 = a1[1];
            v17 = i[1];
            v18 = vcnt_s8(v16);
            v18.i16[0] = vaddlv_u8(v18);
            if (v18.u32[0] > 1uLL)
            {
              if (v17 >= *&v16)
              {
                v17 %= *&v16;
              }
            }

            else
            {
              v17 &= *&v16 - 1;
            }

            v19 = *(*a1 + 8 * v17);
            do
            {
              v20 = v19;
              v19 = *v19;
            }

            while (v19 != i);
            if (v20 == a1 + 3)
            {
              goto LABEL_41;
            }

            v21 = v20[1];
            if (v18.u32[0] > 1uLL)
            {
              if (v21 >= *&v16)
              {
                v21 %= *&v16;
              }
            }

            else
            {
              v21 &= *&v16 - 1;
            }

            if (v21 != v17)
            {
LABEL_41:
              if (!*i)
              {
                goto LABEL_42;
              }

              v22 = *(*i + 1);
              if (v18.u32[0] > 1uLL)
              {
                if (v22 >= *&v16)
                {
                  v22 %= *&v16;
                }
              }

              else
              {
                v22 &= *&v16 - 1;
              }

              if (v22 != v17)
              {
LABEL_42:
                *(*a1 + 8 * v17) = 0;
              }
            }

            v23 = *i;
            if (*i)
            {
              v24 = v23[1];
              if (v18.u32[0] > 1uLL)
              {
                if (v24 >= *&v16)
                {
                  v24 %= *&v16;
                }
              }

              else
              {
                v24 &= *&v16 - 1;
              }

              if (v24 != v17)
              {
                *(*a1 + 8 * v24) = v20;
                v23 = *i;
              }
            }

            *v20 = v23;
            *i = 0;
            --a1[5];

            std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](1, i);
            return;
          }
        }

        else
        {
          if (v9 > 1)
          {
            if (v13 >= *&v6)
            {
              v13 %= *&v6;
            }
          }

          else
          {
            v13 &= *&v6 - 1;
          }

          if (v13 != v10)
          {
            return;
          }
        }
      }
    }
  }
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void *a1, void *a2)
{
  if (a1)
  {
    a1 = a2[4];
    if (a1 != a2[6])
    {
      free(a1);
    }
  }

  else if (!a2)
  {
    return;
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *>>(v3, a2);
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *>>(v3, a2);
}

void **geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(void **a1)
{
  v2 = *a1;
  if (*a1)
  {
    if ((*v2)-- == 1)
    {
      *(v2 + 1) = &unk_1F2A57AD8;
      v4 = *(v2 + 10);
      if (v4)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v4);
      }

      v9.__vftable = (v2 + 32);
      std::vector<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v9);
      v5 = *(v2 + 3);
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v5);
      }

      v6 = *a1;
      v7 = mdm::zone_mallocator::instance(v5);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(v7, v6);
      *a1 = 0;
    }
  }

  return a1;
}

uint64_t md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>>::operator()(uint64_t a1, uint64_t a2)
{
  v2 = a1 + 8;
  if (!a1)
  {
    v2 = 0;
  }

  if (*(v2 + 88) == *(a2 + 96))
  {
    v3 = *(v2 + 56);
    v4 = *(a2 + 64);
    v5 = v3[4];
    if (v5 == v4[4])
    {
      if (!v5)
      {
        return 1;
      }

      v6 = 0;
      while (1)
      {
        v7 = geo::codec::vectorTransitLineAlongLink(v3, v6);
        v8 = geo::codec::vectorTransitLineAlongLink(v4, v6);
        if (*(v7 + 40) != *(v8 + 40) || *(v7 + 73) != *(v8 + 73))
        {
          break;
        }

        if (v5 == ++v6)
        {
          return 1;
        }
      }
    }
  }

  return 0;
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v3, a2);
}

uint64_t std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::erase(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3 != a2)
  {
    v5 = a1[1];
    if (a3 == v5)
    {
      v13 = a2;
    }

    else
    {
      v6 = -*a1;
      v7 = *a1 + a2;
      v8 = *a1 + a3;
      do
      {
        v9 = v8 + v6;
        v10 = v7 + v6;
        *v10 = *(v8 + v6);
        v11 = *(v8 + v6 + 8);
        *(v9 + 8) = 0;
        *(v9 + 16) = 0;
        v12 = *(v7 + v6 + 16);
        *(v10 + 8) = v11;
        if (v12)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v12);
        }

        v7 += 24;
        v8 += 24;
      }

      while (v8 + v6 != v5);
      v13 = v7 + v6;
      v5 = a1[1];
    }

    while (v5 != v13)
    {
      v14 = *(v5 - 8);
      if (v14)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v14);
      }

      v5 -= 24;
    }

    a1[1] = v13;
  }

  return a2;
}

void *std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>::operator=[abi:nn200100](void *a1, void *a2)
{
  v3 = a2[1];
  *a1 = *a2;
  v4 = a2[2];
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  v5 = a1[2];
  a1[1] = v3;
  a1[2] = v4;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  return a1;
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v3, a2);
}

void **geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(void **a1)
{
  v2 = *a1;
  if (*a1)
  {
    if ((*v2)-- == 1)
    {
      *(v2 + 1) = &unk_1F2A57A70;
      v4 = *(v2 + 10);
      if (v4)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v4);
      }

      v9.__vftable = (v2 + 32);
      std::vector<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v9);
      v5 = *(v2 + 3);
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v5);
      }

      v6 = *a1;
      v7 = mdm::zone_mallocator::instance(v5);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(v7, v6);
      *a1 = 0;
    }
  }

  return a1;
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v3, a2);
}

void std::__hash_node_destructor<geo::allocator_adapter<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>,mdm::zone_mallocator>>::operator()[abi:nn200100](void **a1, void **a2)
{
  if (a1)
  {
    a1 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(a2 + 2);
  }

  v3 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v3, a2);
}

void **md::LabelFeaturePool::addUnnamedLineFeature(mdm::zone_mallocator *a1, uint64_t a2, uint64_t *a3, int **a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  v34 = a5;
  v35 = a3;
  v16 = mdm::zone_mallocator::instance(a1);
  v17 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(v16);
  *v17 = 1;
  md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk((v17 + 8), a3, a8, 0);
  v33 = v17;
  v18 = std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,geo::allocator_adapter<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,mdm::zone_mallocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator> const&>((a2 + 120), &v33, &v33);
  *(a6 + 97) = v19 & 1;
  if (v19)
  {
    std::allocate_shared[abi:nn200100]<md::UniLineLabelFeature,geo::allocator_adapter<md::UniLineLabelFeature,mdm::zone_mallocator>,GeoCodecsRoadFeature const*&,std::vector<unsigned int> &,GeoCodecsTileLabelLine *&,md::LabelFeatureCreationParams &,0>(&v32, &v36, &v35, a4, &v34, a6);
    v20 = v33;
    if (v33)
    {
      v21 = v33 + 8;
    }

    else
    {
      v21 = 0;
    }

    v22 = v32;
    v23 = *(v21 + 2);
    *(v21 + 8) = v32;
    if (v23)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v23);
      v24 = *(v21 + 1);
    }

    else
    {
      v24 = v22;
    }

    *(v24 + 152) = v21;
    v27 = *(a2 + 672) + 1;
    *(a2 + 672) = v27;
    *(v24 + 72) = v27;
    *(v24 + 148) = a8;
  }

  else
  {
    geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::operator=(&v33, v18 + 2);
    if (v33)
    {
      v25 = (v33 + 8);
    }

    else
    {
      v25 = 0;
    }

    md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(v25, a3);
    if (v33)
    {
      v26 = v33 + 8;
    }

    else
    {
      v26 = 0;
    }

    md::LabelLineStore::addRoadFeature(*(*(v26 + 1) + 192), a3, a4, a5, a6, *(v26 + 1) + 440);
    v20 = v33;
  }

  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>>,geo::allocator_adapter<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,mdm::zone_mallocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator> const&>((a7 + 56), v20, &v33);
  if (v33)
  {
    v28 = v33 + 8;
  }

  else
  {
    v28 = 0;
  }

  v30 = *(v28 + 1);
  v29 = *(v28 + 2);
  *a1 = v30;
  *(a1 + 1) = v29;
  if (v29)
  {
    atomic_fetch_add_explicit((v29 + 8), 1uLL, memory_order_relaxed);
  }

  return geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(&v33);
}

void sub_1B32E61DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(va);
  _Unwind_Resume(a1);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 24 * a2, 0x60040CE5A77A8uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::UniLineLabelFeature,geo::allocator_adapter<md::UniLineLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::UniLineLabelFeature,geo::allocator_adapter<md::UniLineLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::UniLineLabelFeature,geo::allocator_adapter<md::UniLineLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::UniLineLabelFeature,geo::allocator_adapter<md::UniLineLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A579D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x68uLL, 0x10E004064425D89uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::PhysicalLabelFeature,geo::allocator_adapter<md::PhysicalLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::PhysicalLabelFeature,geo::allocator_adapter<md::PhysicalLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::PhysicalLabelFeature,geo::allocator_adapter<md::PhysicalLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::PhysicalLabelFeature,geo::allocator_adapter<md::PhysicalLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57A38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::LabelFeaturePool::addContourLineFeatures(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t **a5)
{
  v5 = a4;
  v196[1] = *MEMORY[0x1E69E9840];
  v10 = *a3;
  v9 = a3[1];
  v179 = *a4;
  std::mutex::lock(a1);
  v11 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>((a1 + 456), *a2);
  if (v11)
  {
    v12 = v11;
    std::mutex::unlock(a1);
    v193 = 0;
    v194 = 0;
    v195 = 0;
    std::vector<md::LabelFeatureStylerItem,geo::allocator_adapter<md::LabelFeatureStylerItem,mdm::zone_mallocator>>::reserve(&v193, 0x20uLL);
    v13 = *a3;
    v187 = a1;
    v188 = 1;
    std::mutex::lock(a1);
    if (v9 == v10)
    {
      goto LABEL_280;
    }

    v15 = 0;
    if ((0x6DB6DB6DB6DB6DB7 * ((v9 - v10) >> 3)) <= 1)
    {
      v16 = 1;
    }

    else
    {
      v16 = 0x6DB6DB6DB6DB6DB7 * ((v9 - v10) >> 3);
    }

    v180 = v12 + 27;
    v181 = (a1 + 256);
    v183 = v16;
    v184 = v5;
    while (1)
    {
      if (*(v13 + 28) != 1)
      {
        goto LABEL_231;
      }

      v189[0] = 0;
      v17 = mdm::zone_mallocator::instance(v14);
      v18 = pthread_rwlock_rdlock((v17 + 32));
      if (v18)
      {
        geo::read_write_lock::logFailure(v18, "read lock", v19);
      }

      v20 = malloc_type_zone_malloc(*v17, 0x68uLL, 0x10E004064425D89uLL);
      atomic_fetch_add((v17 + 24), 1u);
      geo::read_write_lock::unlock((v17 + 32));
      v189[0] = v20;
      *v20 = 1;
      v20[1] = &unk_1F2A57A70;
      *(v20 + 2) = 0u;
      v21 = v20 + 4;
      *(v20 + 1) = 0u;
      v20[6] = 0;
      v22 = *(v13 + 8);
      if (v22 && (v22 = std::__shared_weak_count::lock(v22)) != 0)
      {
        v23 = *v13;
      }

      else
      {
        v23 = 0;
      }

      v20[8] = v13;
      v20[9] = v23;
      v20[10] = v22;
      v20[11] = 0;
      *(v20 + 96) = 0;
      v24 = v20[5];
      v25 = v20[6];
      if (v24 >= v25)
      {
        v28 = 0xAAAAAAAAAAAAAAABLL * ((v24 - *v21) >> 3);
        v29 = v28 + 1;
        if (v28 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          goto LABEL_286;
        }

        v30 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *v21) >> 3);
        if (2 * v30 > v29)
        {
          v29 = 2 * v30;
        }

        if (v30 >= 0x555555555555555)
        {
          v31 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v31 = v29;
        }

        v192 = v20 + 7;
        if (v31)
        {
          v32 = mdm::zone_mallocator::instance(v22);
          v33 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(v32, v31);
        }

        else
        {
          v33 = 0;
        }

        v34 = &v33[24 * v28];
        *v34 = *(v20 + 4);
        v35 = v20[10];
        *(v34 + 2) = v35;
        if (v35)
        {
          atomic_fetch_add_explicit((v35 + 8), 1uLL, memory_order_relaxed);
        }

        v36 = &v33[24 * v31];
        v27 = v34 + 24;
        v37 = v20[4];
        v38 = v20[5] - v37;
        v5 = &v34[-v38];
        memcpy(&v34[-v38], v37, v38);
        v39 = v20[4];
        v20[4] = v5;
        v20[5] = v27;
        v40 = v20[6];
        v20[6] = v36;
        v190.__shared_weak_owners_ = v39;
        v191 = v40;
        v190.__vftable = v39;
        v190.__shared_owners_ = v39;
        v22 = std::__split_buffer<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator> &>::~__split_buffer(&v190);
      }

      else
      {
        *v24 = *(v20 + 4);
        v26 = v20[10];
        *(v24 + 16) = v26;
        if (v26)
        {
          atomic_fetch_add_explicit((v26 + 8), 1uLL, memory_order_relaxed);
        }

        v27 = (v24 + 24);
      }

      v20[5] = v27;
      v189[0] = v20;
      v41 = *(v20 + 96);
      v42 = *(v20[8] + 24);
      v43 = (((v41 >> 2) | (v41 << 6)) - 0x61C8864680B583EBLL + v42) ^ v41;
      v44 = *(a1 + 240);
      if (!v44)
      {
        break;
      }

      v45 = vcnt_s8(v44);
      v45.i16[0] = vaddlv_u8(v45);
      if (v45.u32[0] > 1uLL)
      {
        v5 = (((v41 >> 2) | (v41 << 6)) - 0x61C8864680B583EBLL + v42) ^ v41;
        if (v43 >= v44)
        {
          v5 = v43 % v44;
        }
      }

      else
      {
        v5 = v43 & (v44 - 1);
      }

      v46 = *(*(a1 + 232) + 8 * v5);
      if (!v46)
      {
        break;
      }

      v47 = *v46;
      if (!*v46)
      {
        break;
      }

      while (1)
      {
        v48 = v47[1];
        if (v48 == v43)
        {
          break;
        }

        if (v45.u32[0] > 1uLL)
        {
          if (v48 >= v44)
          {
            v48 %= v44;
          }
        }

        else
        {
          v48 &= v44 - 1;
        }

        if (v48 != v5)
        {
          goto LABEL_49;
        }

LABEL_48:
        v47 = *v47;
        if (!v47)
        {
          goto LABEL_49;
        }
      }

      v49 = v47[2];
      v50 = v49 + 1;
      if (!v49)
      {
        v50 = 0;
      }

      if (*(v50 + 88) != v41 || *(v50[7] + 24) != v42)
      {
        goto LABEL_48;
      }

      v184[97] = 0;
      if (v49)
      {
        ++*v49;
      }

      if ((*v20)-- == 1)
      {
        v20[1] = &unk_1F2A57A70;
        v151 = v20[10];
        if (v151)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v151);
        }

        v190.__vftable = (v20 + 4);
        std::vector<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v190);
        v152 = v20[3];
        if (v152)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v152);
        }

        v153 = v189[0];
        v154 = mdm::zone_mallocator::instance(v152);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(v154, v153);
        v49 = v47[2];
      }

      v189[0] = v49;
      if (v49)
      {
        v155 = v49 + 1;
      }

      else
      {
        v155 = 0;
      }

      v156 = v155[1];
      std::mutex::lock((v156 + 8));
      v157 = *(v13 + 8);
      if (v157)
      {
        v157 = std::__shared_weak_count::lock(v157);
        v158 = v157;
        if (v157)
        {
          v159 = *v13;
        }

        else
        {
          v159 = 0;
        }
      }

      else
      {
        v159 = 0;
        v158 = 0;
      }

      *&v160 = v13;
      *(&v160 + 1) = v159;
      v162 = v155[4];
      v161 = v155[5];
      if (v162 < v161)
      {
        *v162 = v160;
        *(v162 + 16) = v158;
        v163 = (v162 + 24);
        goto LABEL_276;
      }

      v164 = v155[3];
      v165 = 0xAAAAAAAAAAAAAAABLL * ((v162 - v164) >> 3);
      v166 = v165 + 1;
      if (v165 + 1 > 0xAAAAAAAAAAAAAAALL)
      {
LABEL_286:
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v167 = 0xAAAAAAAAAAAAAAABLL * ((v161 - v164) >> 3);
      if (2 * v167 > v166)
      {
        v166 = 2 * v167;
      }

      if (v167 >= 0x555555555555555)
      {
        v168 = 0xAAAAAAAAAAAAAAALL;
      }

      else
      {
        v168 = v166;
      }

      v192 = v155 + 6;
      if (v168)
      {
        v186 = v160;
        v169 = mdm::zone_mallocator::instance(v157);
        v170 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(v169, v168);
        v160 = v186;
      }

      else
      {
        v170 = 0;
      }

      v171 = &v170[24 * v165];
      v172 = &v170[24 * v168];
      *v171 = v160;
      *(v171 + 2) = v158;
      v163 = v171 + 24;
      v173 = v155[3];
      v174 = v155[4] - v173;
      v175 = &v171[-v174];
      memcpy(&v171[-v174], v173, v174);
      v176 = v155[3];
      v155[3] = v175;
      v155[4] = v163;
      v177 = v155[5];
      v155[5] = v172;
      v190.__shared_weak_owners_ = v176;
      v191 = v177;
      v190.__vftable = v176;
      v190.__shared_owners_ = v176;
      std::__split_buffer<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator> &>::~__split_buffer(&v190);
LABEL_276:
      v78 = v184;
      v155[4] = v163;
      std::mutex::unlock((v156 + 8));
      if (v189[0])
      {
        v178 = v189[0] + 8;
      }

      else
      {
        v178 = 0;
      }

      md::LabelLineStore::addContourLine(*(*(v178 + 1) + 192), v13, v184, *(v178 + 1) + 440);
      v86 = v189[0];
LABEL_118:
      v92 = v86 + 8;
      if (!v86)
      {
        v92 = 0;
      }

      v5 = *(*(v92 + 1) + 72);
      v93 = v12[25];
      if (!v93)
      {
        goto LABEL_139;
      }

      v94 = vcnt_s8(v93);
      v94.i16[0] = vaddlv_u8(v94);
      if (v94.u32[0] > 1uLL)
      {
        v78 = *(*(v92 + 1) + 72);
        if (v5 >= v93)
        {
          v78 = v5 % v93;
        }
      }

      else
      {
        v78 = (v93 - 1) & v5;
      }

      v95 = *(v12[24] + 8 * v78);
      if (!v95 || (v96 = *v95) == 0)
      {
LABEL_139:
        v100 = mdm::zone_mallocator::instance(v88);
        prime = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v100);
        v102 = prime;
        *prime = 0;
        *(prime + 8) = v5;
        v103 = v189[0];
        *(prime + 16) = v189[0];
        if (v103)
        {
          ++*v103;
        }

        v104 = (v12[29] + 1);
        v105 = *(v12 + 60);
        if (!v93 || (v105 * v93) < v104)
        {
          v106 = (v93 & (v93 - 1)) != 0;
          if (v93 < 3)
          {
            v106 = 1;
          }

          v107 = v106 | (2 * v93);
          v108 = vcvtps_u32_f32(v104 / v105);
          if (v107 <= v108)
          {
            v109 = v108;
          }

          else
          {
            v109 = v107;
          }

          if (*&v109 == 1)
          {
            v109 = 2;
          }

          else if ((*&v109 & (*&v109 - 1)) != 0)
          {
            prime = std::__next_prime(*&v109);
            v109 = prime;
          }

          v93 = v12[25];
          if (*&v109 <= v93)
          {
            if (*&v109 < v93)
            {
              prime = vcvtps_u32_f32(v12[29] / *(v12 + 60));
              if (v93 < 3 || (v116 = vcnt_s8(v93), v116.i16[0] = vaddlv_u8(v116), v116.u32[0] > 1uLL))
              {
                prime = std::__next_prime(prime);
              }

              else
              {
                v117 = 1 << -__clz(prime - 1);
                if (prime >= 2)
                {
                  prime = v117;
                }
              }

              if (*&v109 <= prime)
              {
                v109 = prime;
              }

              if (*&v109 >= v93)
              {
                v93 = v12[25];
              }

              else
              {
                if (v109)
                {
                  goto LABEL_153;
                }

                std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>((v12 + 24), 0);
                v93 = 0;
                v12[25] = 0;
              }
            }
          }

          else
          {
LABEL_153:
            v110 = mdm::zone_mallocator::instance(prime);
            v111 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(v110, *&v109);
            std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>((v12 + 24), v111);
            v112 = 0;
            v12[25] = v109;
            do
            {
              *(v12[24] + 8 * v112++) = 0;
            }

            while (*&v109 != v112);
            v113 = *v180;
            if (*v180)
            {
              v114 = v113[1];
              v115 = vcnt_s8(v109);
              v115.i16[0] = vaddlv_u8(v115);
              if (v115.u32[0] > 1uLL)
              {
                if (v114 >= *&v109)
                {
                  v114 %= *&v109;
                }
              }

              else
              {
                v114 &= *&v109 - 1;
              }

              *(v12[24] + 8 * v114) = v180;
              v118 = *v113;
              if (*v113)
              {
                do
                {
                  v119 = v118[1];
                  if (v115.u32[0] > 1uLL)
                  {
                    if (v119 >= *&v109)
                    {
                      v119 %= *&v109;
                    }
                  }

                  else
                  {
                    v119 &= *&v109 - 1;
                  }

                  if (v119 != v114)
                  {
                    v120 = v12[24];
                    if (!*(v120 + 8 * v119))
                    {
                      *(v120 + 8 * v119) = v113;
                      goto LABEL_175;
                    }

                    *v113 = *v118;
                    *v118 = **(v120 + 8 * v119);
                    **(v120 + 8 * v119) = v118;
                    v118 = v113;
                  }

                  v119 = v114;
LABEL_175:
                  v113 = v118;
                  v118 = *v118;
                  v114 = v119;
                }

                while (v118);
              }
            }

            v93 = v109;
          }

          if ((v93 & (v93 - 1)) != 0)
          {
            if (v5 >= v93)
            {
              v78 = v5 % v93;
            }

            else
            {
              v78 = v5;
            }
          }

          else
          {
            v78 = (v93 - 1) & v5;
          }
        }

        v121 = v12[24];
        v122 = *(v121 + 8 * v78);
        v149 = v184;
        if (v122)
        {
          *v102 = *v122;
          goto LABEL_192;
        }

        *v102 = *v180;
        *v180 = v102;
        *(v121 + 8 * v78) = v180;
        if (*v102)
        {
          v123 = *(*v102 + 8);
          if ((v93 & (v93 - 1)) != 0)
          {
            if (v123 >= v93)
            {
              v123 %= v93;
            }
          }

          else
          {
            v123 &= v93 - 1;
          }

          v122 = (v12[24] + 8 * v123);
LABEL_192:
          *v122 = v102;
        }

        ++v12[29];
        v86 = v189[0];
        goto LABEL_194;
      }

      while (2)
      {
        v97 = v96[1];
        if (v97 != v5)
        {
          if (v94.u32[0] > 1uLL)
          {
            if (v97 >= v93)
            {
              v97 %= v93;
            }
          }

          else
          {
            v97 &= v93 - 1;
          }

          if (v97 != v78)
          {
            goto LABEL_139;
          }

LABEL_138:
          v96 = *v96;
          if (!v96)
          {
            goto LABEL_139;
          }

          continue;
        }

        break;
      }

      v98 = v96[2];
      if (v98)
      {
        v99 = v98 + 8;
      }

      else
      {
        v99 = 0;
      }

      if (*(*(v99 + 8) + 72) != v5)
      {
        goto LABEL_138;
      }

      v149 = v184;
LABEL_194:
      if (v86)
      {
        v124 = v86 + 8;
      }

      else
      {
        v124 = 0;
      }

      v125 = *(v124 + 8);
      v185 = v125;
      v126 = *(v124 + 2);
      if (*(&v125 + 1))
      {
        atomic_fetch_add_explicit((*(&v125 + 1) + 8), 1uLL, memory_order_relaxed);
        v127 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(v189);
        atomic_fetch_add_explicit(&v126->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }

      else
      {
        v127 = geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(v189);
      }

      v128 = (a5 + 1);
      while (1)
      {
        v129 = *v128;
        v130 = v128;
        if (!*v128)
        {
          break;
        }

        while (1)
        {
          v128 = v129;
          v131 = v129[5];
          if (v126 < v131)
          {
            break;
          }

          if (v131 >= v126)
          {
            v136 = *(&v185 + 1);
            goto LABEL_212;
          }

          v129 = v128[1];
          if (!v129)
          {
            v130 = v128 + 1;
            goto LABEL_206;
          }
        }
      }

LABEL_206:
      v132 = mdm::zone_mallocator::instance(v127);
      v133 = pthread_rwlock_rdlock((v132 + 32));
      if (v133)
      {
        geo::read_write_lock::logFailure(v133, "read lock", v134);
      }

      v5 = malloc_type_zone_malloc(*v132, 0x30uLL, 0x10200409B2CA512uLL);
      atomic_fetch_add((v132 + 24), 1u);
      geo::read_write_lock::unlock((v132 + 32));
      *(v5 + 32) = v185;
      *v5 = 0;
      *(v5 + 8) = 0;
      *(v5 + 16) = v128;
      *v130 = v5;
      v135 = **a5;
      if (v135)
      {
        *a5 = v135;
        v5 = *v130;
      }

      std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a5[1], v5);
      a5[3] = (a5[3] + 1);
      v136 = 0;
LABEL_212:
      v14 = v136;
      if (v136)
      {
        std::__shared_weak_count::__release_weak(v136);
      }

      if (v149[97] == 1)
      {
        v137 = v194;
        if (v194 >= v195)
        {
          v139 = 0xAAAAAAAAAAAAAAABLL * ((v194 - v193) >> 3);
          v140 = v139 + 1;
          if (v139 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          if (0x5555555555555556 * ((v195 - v193) >> 3) > v140)
          {
            v140 = 0x5555555555555556 * ((v195 - v193) >> 3);
          }

          if (0xAAAAAAAAAAAAAAABLL * ((v195 - v193) >> 3) >= 0x555555555555555)
          {
            v141 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v141 = v140;
          }

          v192 = v196;
          if (v141)
          {
            v142 = mdm::zone_mallocator::instance(v14);
            v143 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<md::LabelFeatureStylerItem>(v142, v141);
          }

          else
          {
            v143 = 0;
          }

          v144 = &v143[24 * v139];
          v145 = &v143[24 * v141];
          *v144 = v185;
          *(v144 + 2) = 0;
          v138 = v144 + 24;
          v146 = &v144[-(v194 - v193)];
          memcpy(v146, v193, v194 - v193);
          v147 = v193;
          v148 = v195;
          v193 = v146;
          v194 = v138;
          v195 = v145;
          v190.__shared_weak_owners_ = v147;
          v191 = v148;
          v190.__vftable = v147;
          v190.__shared_owners_ = v147;
          v14 = std::__split_buffer<md::LabelFeatureStylerItem,geo::allocator_adapter<md::LabelFeatureStylerItem,mdm::zone_mallocator> &>::~__split_buffer(&v190);
        }

        else
        {
          *v194 = v185;
          v138 = v137 + 24;
          *(v137 + 1) = 0;
          *(v137 + 2) = 0;
        }

        v194 = v138;
        if (0xAAAAAAAAAAAAAAABLL * ((v138 - v193) >> 3) >= 0x20)
        {
          flushStyleFeatureQueue(&v193, v179, &v187);
        }
      }

      if (v126)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v126);
      }

LABEL_231:
      ++v15;
      v13 += 56;
      if (v15 == v183)
      {
LABEL_280:
        flushStyleFeatureQueue(&v193, v179, &v187);
        if (v188 == 1)
        {
          std::mutex::unlock(v187);
        }

        std::vector<md::LabelFeatureStylerItem,geo::allocator_adapter<md::LabelFeatureStylerItem,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v193);
        return;
      }
    }

LABEL_49:
    v51 = mdm::zone_mallocator::instance(v22);
    v52 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(v51);
    v53 = v52;
    *v52 = 0;
    *(v52 + 8) = v43;
    v54 = v189[0];
    *(v52 + 16) = v189[0];
    if (v54)
    {
      ++*v54;
    }

    v55 = (*(a1 + 272) + 1);
    v56 = *(a1 + 280);
    if (!v44 || (v56 * v44) < v55)
    {
      v57 = (v44 & (v44 - 1)) != 0;
      if (v44 < 3)
      {
        v57 = 1;
      }

      v58 = v57 | (2 * v44);
      v59 = vcvtps_u32_f32(v55 / v56);
      if (v58 <= v59)
      {
        v60 = v59;
      }

      else
      {
        v60 = v58;
      }

      if (*&v60 == 1)
      {
        v60 = 2;
      }

      else if ((*&v60 & (*&v60 - 1)) != 0)
      {
        v52 = std::__next_prime(*&v60);
        v60 = v52;
      }

      v44 = *(a1 + 240);
      if (*&v60 <= v44)
      {
        if (*&v60 < v44)
        {
          v52 = vcvtps_u32_f32(*(a1 + 272) / *(a1 + 280));
          if (v44 < 3 || (v67 = vcnt_s8(v44), v67.i16[0] = vaddlv_u8(v67), v67.u32[0] > 1uLL))
          {
            v52 = std::__next_prime(v52);
          }

          else
          {
            v68 = 1 << -__clz(v52 - 1);
            if (v52 >= 2)
            {
              v52 = v68;
            }
          }

          if (*&v60 <= v52)
          {
            v60 = v52;
          }

          if (*&v60 >= v44)
          {
            v44 = *(a1 + 240);
          }

          else
          {
            if (v60)
            {
              goto LABEL_63;
            }

            std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>((a1 + 232), 0);
            v44 = 0;
            *(a1 + 240) = 0;
          }
        }
      }

      else
      {
LABEL_63:
        v61 = mdm::zone_mallocator::instance(v52);
        v62 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(v61, *&v60);
        std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>((a1 + 232), v62);
        v63 = 0;
        *(a1 + 240) = v60;
        do
        {
          *(*(a1 + 232) + 8 * v63++) = 0;
        }

        while (*&v60 != v63);
        v64 = *v181;
        if (*v181)
        {
          v65 = v64[1];
          v66 = vcnt_s8(v60);
          v66.i16[0] = vaddlv_u8(v66);
          if (v66.u32[0] > 1uLL)
          {
            if (v65 >= *&v60)
            {
              v65 %= *&v60;
            }
          }

          else
          {
            v65 &= *&v60 - 1;
          }

          *(*(a1 + 232) + 8 * v65) = v181;
          v69 = *v64;
          if (*v64)
          {
            do
            {
              v70 = v69[1];
              if (v66.u32[0] > 1uLL)
              {
                if (v70 >= *&v60)
                {
                  v70 %= *&v60;
                }
              }

              else
              {
                v70 &= *&v60 - 1;
              }

              if (v70 != v65)
              {
                v71 = *(a1 + 232);
                if (!*(v71 + 8 * v70))
                {
                  *(v71 + 8 * v70) = v64;
                  goto LABEL_85;
                }

                *v64 = *v69;
                *v69 = **(v71 + 8 * v70);
                **(v71 + 8 * v70) = v69;
                v69 = v64;
              }

              v70 = v65;
LABEL_85:
              v64 = v69;
              v69 = *v69;
              v65 = v70;
            }

            while (v69);
          }
        }

        v44 = v60;
      }

      if ((v44 & (v44 - 1)) != 0)
      {
        if (v43 >= v44)
        {
          v5 = v43 % v44;
        }

        else
        {
          v5 = v43;
        }
      }

      else
      {
        v5 = (v44 - 1) & v43;
      }
    }

    v72 = *(a1 + 232);
    v73 = *(v72 + 8 * v5);
    if (v73)
    {
      *v53 = *v73;
    }

    else
    {
      *v53 = *v181;
      *v181 = v53;
      *(v72 + 8 * v5) = v181;
      if (!*v53)
      {
LABEL_103:
        ++*(a1 + 272);
        v184[97] = 1;
        v75 = mdm::zone_mallocator::instance(v52);
        v76 = pthread_rwlock_rdlock((v75 + 32));
        if (v76)
        {
          geo::read_write_lock::logFailure(v76, "read lock", v77);
        }

        v78 = malloc_type_zone_malloc(*v75, 0x1E8uLL, 0x1081040B1190BC6uLL);
        atomic_fetch_add((v75 + 24), 1u);
        geo::read_write_lock::unlock((v75 + 32));
        *(v78 + 8) = 0;
        *(v78 + 16) = 0;
        *v78 = &unk_1F2A57AA0;
        md::LineLabelFeature::LineLabelFeature(v78 + 32, 4, 2);
        *(v78 + 32) = &unk_1F29E9980;
        *(v78 + 472) = &unk_1F29E9C48;
        *(v78 + 480) = -1;
        *(v78 + 484) = *(v13 + 24) * 0.1;
        v80 = *(v13 + 32);
        v79 = *(v13 + 40);
        if (v79)
        {
          atomic_fetch_add_explicit((v79 + 8), 1uLL, memory_order_relaxed);
        }

        v81 = *(v78 + 456);
        *(v78 + 448) = v80;
        *(v78 + 456) = v79;
        if (v81)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v81);
        }

        v82 = *(v78 + 224);
        *(v82 + 154) = 4;
        *(v82 + 159) = v184[8] != 255;
        md::LabelLineStore::addContourLine(v82, v13, v184, v78 + 472);
        v83 = *(v78 + 224);
        v84 = atomic_load(v83 + 155);
        if (v84)
        {
          md::LabelLineStore::consumeWorkUnits(v83);
        }

        (*(*(v78 + 32) + 32))(v78 + 32, v13, v184[96]);
        *&v85 = v78 + 32;
        *(&v85 + 1) = v78;
        v86 = v189[0];
        v87 = v189[0] + 8;
        if (!v189[0])
        {
          v87 = 0;
        }

        v88 = *(v87 + 2);
        *(v87 + 8) = v85;
        if (v88)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v88);
          v86 = v189[0];
        }

        v89 = v86 + 8;
        if (!v86)
        {
          v89 = 0;
        }

        v90 = *(v89 + 1);
        *(v90 + 152) = v89;
        v91 = *(a1 + 672) + 1;
        *(a1 + 672) = v91;
        *(v90 + 72) = v91;
        *(v90 + 148) = 0;
        goto LABEL_118;
      }

      v74 = *(*v53 + 8);
      if ((v44 & (v44 - 1)) != 0)
      {
        if (v74 >= v44)
        {
          v74 %= v44;
        }
      }

      else
      {
        v74 &= v44 - 1;
      }

      v73 = (*(a1 + 232) + 8 * v74);
    }

    *v73 = v53;
    goto LABEL_103;
  }

  std::mutex::unlock(a1);
}

void sub_1B32E7924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::mutex *a20, char a21, int a22, void *a23, uint64_t a24)
{
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v25);
  }

  std::mutex::unlock((v24 + 8));
  geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>::~fast_shared_ptr(&a23);
  if (a21 == 1)
  {
    std::mutex::unlock(a20);
  }

  std::vector<md::LabelFeatureStylerItem,geo::allocator_adapter<md::LabelFeatureStylerItem,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((v26 - 144));
  _Unwind_Resume(a1);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>(mdm::zone_mallocator *a1, uint64_t a2)
{
  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(v3, v2);
  }
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::ContourLineLabelFeature,GeoCodecsContourLinesFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 24 * a2, 0x60040CE5A77A8uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

std::__shared_weak_count *std::__split_buffer<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator> &>::~__split_buffer(std::__shared_weak_count *a1)
{
  v1 = a1;
  shared_owners = a1->__shared_owners_;
  shared_weak_owners = a1->__shared_weak_owners_;
  while (shared_weak_owners != shared_owners)
  {
    v1->__shared_weak_owners_ = shared_weak_owners - 24;
    a1 = *(shared_weak_owners - 8);
    if (a1)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a1);
      shared_weak_owners = v1->__shared_weak_owners_;
    }

    else
    {
      shared_weak_owners -= 24;
    }
  }

  v4 = v1->__vftable;
  if (v1->__vftable)
  {
    v5 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::pair<GeoCodecsContourLinesFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(v5, v4);
  }

  return v1;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::ContourLineLabelFeature,geo::allocator_adapter<md::ContourLineLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::ContourLineLabelFeature,geo::allocator_adapter<md::ContourLineLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::ContourLineLabelFeature,geo::allocator_adapter<md::ContourLineLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::ContourLineLabelFeature,geo::allocator_adapter<md::ContourLineLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57AA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *> *> **,0>(mdm::zone_mallocator *a1, uint64_t a2)
{
  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(v3, v2);
  }
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 24 * a2, 0x60040CE5A77A8uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

std::__shared_weak_count *std::__split_buffer<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator> &>::~__split_buffer(std::__shared_weak_count *a1)
{
  v1 = a1;
  shared_owners = a1->__shared_owners_;
  shared_weak_owners = a1->__shared_weak_owners_;
  while (shared_weak_owners != shared_owners)
  {
    v1->__shared_weak_owners_ = shared_weak_owners - 24;
    a1 = *(shared_weak_owners - 8);
    if (a1)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a1);
      shared_weak_owners = v1->__shared_weak_owners_;
    }

    else
    {
      shared_weak_owners -= 24;
    }
  }

  v4 = v1->__vftable;
  if (v1->__vftable)
  {
    v5 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::pair<GeoCodecsTransitLink const*,std::shared_ptr<geo::codec::VectorTile>>>(v5, v4);
  }

  return v1;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitLineLabelFeature,geo::allocator_adapter<md::TransitLineLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::TransitLineLabelFeature,geo::allocator_adapter<md::TransitLineLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitLineLabelFeature,geo::allocator_adapter<md::TransitLineLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::TransitLineLabelFeature,geo::allocator_adapter<md::TransitLineLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57B08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void **geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::operator=(void **a1, void **a2)
{
  v4 = *a2;
  if (*a2)
  {
    ++*v4;
  }

  v5 = *a1;
  if (*a1)
  {
    if ((*v5)-- == 1)
    {
      *(v5 + 1) = &unk_1F2A57B40;
      v7 = *(v5 + 10);
      if (v7)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v7);
      }

      v12.__vftable = (v5 + 32);
      std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v12);
      v8 = *(v5 + 3);
      if (v8)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v8);
      }

      v9 = *a1;
      v10 = mdm::zone_mallocator::instance(v8);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(v10, v9);
      *a1 = 0;
      v4 = *a2;
    }
  }

  *a1 = v4;
  return a1;
}

void md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(std::__shared_weak_count *a1, uint64_t *a2)
{
  shared_owners = a1->__shared_owners_;
  std::mutex::lock((shared_owners + 8));
  v5 = a2[1];
  if (v5 && (v5 = std::__shared_weak_count::lock(v5)) != 0)
  {
    v6 = *a2;
  }

  else
  {
    v6 = 0;
  }

  v7[0] = a2;
  v7[1] = v6;
  v8 = v5;
  std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::allocator_adapter<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::zone_mallocator>>::push_back[abi:nn200100](a1 + 1, v7);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }

  std::mutex::unlock((shared_owners + 8));
}

void sub_1B32E82E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a12);
  }

  std::mutex::unlock((v12 + 8));
  _Unwind_Resume(a1);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitNodeLabelFeature,geo::allocator_adapter<md::TransitNodeLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::TransitNodeLabelFeature,geo::allocator_adapter<md::TransitNodeLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitNodeLabelFeature,geo::allocator_adapter<md::TransitNodeLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::TransitNodeLabelFeature,geo::allocator_adapter<md::TransitNodeLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57B70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::allocator>::_fast_shared_ptr_control>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x68uLL, 0x10E004064425D89uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitAccessPointLabelFeature,geo::allocator_adapter<md::TransitAccessPointLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::TransitAccessPointLabelFeature,geo::allocator_adapter<md::TransitAccessPointLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TransitAccessPointLabelFeature,geo::allocator_adapter<md::TransitAccessPointLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::TransitAccessPointLabelFeature,geo::allocator_adapter<md::TransitAccessPointLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57BA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::PointLabelFeature,geo::allocator_adapter<md::PointLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::PointLabelFeature,geo::allocator_adapter<md::PointLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::PointLabelFeature,geo::allocator_adapter<md::PointLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::PointLabelFeature,geo::allocator_adapter<md::PointLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57C18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::MuninPointLabelFeature,geo::allocator_adapter<md::MuninPointLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::MuninPointLabelFeature,geo::allocator_adapter<md::MuninPointLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::MuninPointLabelFeature,geo::allocator_adapter<md::MuninPointLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::MuninPointLabelFeature,geo::allocator_adapter<md::MuninPointLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57BE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *> *> **,0>(mdm::zone_mallocator *a1, uint64_t a2)
{
  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long,md::LabelFeaturePool::RemovedVersionInfo>,void *> *> *>(v3, v2);
  }
}

void std::__shared_ptr_emplace<md::MuninStorefrontLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57C50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *> *> *>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void std::unique_ptr<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *> *> *,mdm::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *> *> **,0>(mdm::zone_mallocator *a1, uint64_t a2)
{
  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = mdm::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *> *> *>(v3, v2);
  }
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::allocator>,void *>>(uint64_t a1)
{
  v2 = pthread_rwlock_rdlock((a1 + 32));
  if (v2)
  {
    geo::read_write_lock::logFailure(v2, "read lock", v3);
  }

  v4 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004014030ADEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 24 * a2, 0x60040CE5A77A8uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

std::__shared_weak_count *std::__split_buffer<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>,geo::allocator_adapter<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>,mdm::zone_mallocator> &>::~__split_buffer(std::__shared_weak_count *a1)
{
  v1 = a1;
  shared_owners = a1->__shared_owners_;
  shared_weak_owners = a1->__shared_weak_owners_;
  while (shared_weak_owners != shared_owners)
  {
    v1->__shared_weak_owners_ = shared_weak_owners - 24;
    a1 = *(shared_weak_owners - 8);
    if (a1)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a1);
      shared_weak_owners = v1->__shared_weak_owners_;
    }

    else
    {
      shared_weak_owners -= 24;
    }
  }

  v4 = v1->__vftable;
  if (v1->__vftable)
  {
    v5 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::pair<md::LabelClientTileOverlay const*,std::shared_ptr<md::LabelClientTile>>>(v5, v4);
  }

  return v1;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::OverlayLineLabelFeature,geo::allocator_adapter<md::OverlayLineLabelFeature,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::OverlayLineLabelFeature,geo::allocator_adapter<md::OverlayLineLabelFeature,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::OverlayLineLabelFeature,geo::allocator_adapter<md::OverlayLineLabelFeature,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::OverlayLineLabelFeature,geo::allocator_adapter<md::OverlayLineLabelFeature,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57CB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::operator()(void *a1)
{
  v2 = a1[2];
  if (v2)
  {
    v3 = a1[3];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (a1[1])
      {
        md::LabelFeaturePool::flushRemovedTiles(v3);
      }

      std::__shared_weak_count::__release_shared[abi:nn200100](v5);
    }
  }
}

void std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::__clone(void *result, void *a2)
{
  v3 = result[1];
  v2 = result[2];
  *a2 = &unk_1F2A57CF0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  a2[3] = result[3];
  return result;
}

void std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A57CF0;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelFeaturePool::removeFeaturesForTile(std::shared_ptr<md::LabelSourceTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A57CF0;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  return a1;
}

void std::__shared_ptr_emplace<md::LabelTileCollisionInfo>::__on_zero_shared(uint64_t a1)
{
  std::vector<md::LabelCollisionPath,geo::allocator_adapter<md::LabelCollisionPath,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 216));
  std::vector<geo::Mercator3<double>,geo::allocator_adapter<geo::Mercator3<double>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 184));
  std::vector<float,geo::allocator_adapter<float,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 152));
  std::vector<gm::Matrix<float,2,1>,geo::allocator_adapter<gm::Matrix<float,2,1>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 120));

  std::mutex::~mutex((a1 + 24));
}

void std::__shared_ptr_emplace<md::LabelTileCollisionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A57D38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::ARWalkingLabeler::layoutLabelsForStaging(md::ARWalkingLabeler *this)
{
  v2 = this + 1816;
  v3 = *(this + 228);
  v4 = *(this + 235);
  if (v3 != v4)
  {
    v5 = 0;
    v6 = 0;
    v7 = *(this + 233);
    v8 = (this + 1840);
    v9 = this + 1856;
    do
    {
      if (v5 == v7)
      {
        break;
      }

      v10 = v3[6];
      v11 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(this + 230, v3[2]);
      if (v11)
      {
        v12 = *(this + 1848);
        v13 = *(v11 + 1);
        v14 = vcnt_s8(v12);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          if (v13 >= *&v12)
          {
            v13 %= *&v12;
          }
        }

        else
        {
          v13 &= *&v12 - 1;
        }

        v15 = *(*v8 + 8 * v13);
        do
        {
          v16 = v15;
          v15 = *v15;
        }

        while (v15 != v11);
        if (v16 == v9)
        {
          goto LABEL_22;
        }

        v17 = *(v16 + 1);
        if (v14.u32[0] > 1uLL)
        {
          if (v17 >= *&v12)
          {
            v17 %= *&v12;
          }
        }

        else
        {
          v17 &= *&v12 - 1;
        }

        if (v17 != v13)
        {
LABEL_22:
          if (!*v11)
          {
            goto LABEL_23;
          }

          v18 = *(*v11 + 8);
          if (v14.u32[0] > 1uLL)
          {
            if (v18 >= *&v12)
            {
              v18 %= *&v12;
            }
          }

          else
          {
            v18 &= *&v12 - 1;
          }

          if (v18 != v13)
          {
LABEL_23:
            *(*v8 + 8 * v13) = 0;
          }
        }

        v19 = *v11;
        if (*v11)
        {
          v20 = *(v19 + 8);
          if (v14.u32[0] > 1uLL)
          {
            if (v20 >= *&v12)
            {
              v20 %= *&v12;
            }
          }

          else
          {
            v20 &= *&v12 - 1;
          }

          if (v20 != v13)
          {
            *(*v8 + 8 * v20) = v16;
            v19 = *v11;
          }
        }

        *v16 = v19;
        *v11 = 0;
        --*(this + 233);
        operator delete(v11);
        v4 = *(this + 235);
      }

      v6 += v10;
      v3 = v3[1];
      ++v5;
    }

    while (v3 != v4);
    v21 = *(this + 228);
    if (v21 != v3)
    {
      v22 = *(*v3 + 8);
      v23 = *v21;
      *(v23 + 8) = v22;
      *v22 = v23;
      do
      {
        v24 = v21[1];
        --*(this + 229);
        operator delete(v21);
        v21 = v24;
      }

      while (v24 != v3);
    }

    v25 = *(this + 236);
    v26 = v25 >= v6;
    v27 = v25 - v6;
    if (!v26)
    {
      v27 = 0;
    }

    *(this + 236) = v27;
  }

  *(this + 235) = v2;
  if ((*(this + 400) & 1) == 0)
  {
    std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear(this + 237);
    std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear(this + 242);
    v41 = *(this + 9);
    v42 = *(this + 10);
    while (v41 != v42)
    {
      v43 = *v41;
      v41 += 2;
      md::Label::updateStateMachineForStaging(v43, 2, 29);
    }

    v165 = 0uLL;
    md::ARWalkingLabeler::updateStagingActiveLabel(this, &v165);
    *(this + 1720) = 0;
    return;
  }

  v165 = 0u;
  v166 = 0u;
  LODWORD(v167) = 1065353216;
  v161 = 0u;
  v162 = 0u;
  v163 = 1065353216;
  v28 = *(this + 9);
  for (i = *(this + 10); v28 != i; v28 += 2)
  {
    v30 = *v28;
    if (std::__hash_table<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>>>::find<gdc::Registry *>(this + 237, *v28))
    {
      v153 = v30;
      std::__hash_table<md::Label *,std::hash<md::Label *>,std::equal_to<md::Label *>,std::allocator<md::Label *>>::__emplace_unique_key_args<md::Label *,md::Label *>(&v165, v30);
      v164 = *v28;
      v153 = &v164;
      v31 = std::__hash_table<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::__unordered_map_hasher<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::hash<md::Label *>,std::equal_to<md::Label *>,true>,std::__unordered_map_equal<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::equal_to<md::Label *>,std::hash<md::Label *>,true>,std::allocator<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>>>::__emplace_unique_key_args<md::Label *,std::piecewise_construct_t const&,std::tuple<md::Label *&&>,std::tuple<>>(this + 242, v164);
      v160 = *v28;
      v153 = &v160;
      v32 = std::__hash_table<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::__unordered_map_hasher<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::hash<md::Label *>,std::equal_to<md::Label *>,true>,std::__unordered_map_equal<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::equal_to<md::Label *>,std::hash<md::Label *>,true>,std::allocator<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>>>::__emplace_unique_key_args<md::Label *,std::piecewise_construct_t const&,std::tuple<md::Label *&&>,std::tuple<>>(&v161, v160);
      v33 = *(v31 + 3);
      v34 = *(v31 + 5);
      v32[7] = v31[7];
      *(v32 + 5) = v34;
      *(v32 + 3) = v33;
    }
  }

  v151 = (this + 1896);
  std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear(this + 237);
  v35 = v165;
  *&v165 = 0;
  v36 = *(this + 237);
  *(this + 237) = v35;
  if (v36)
  {
    operator delete(v36);
  }

  v37 = *(&v165 + 1);
  v38 = v166;
  *(this + 238) = *(&v165 + 1);
  *(&v165 + 1) = 0;
  v39 = *(&v166 + 1);
  *(this + 240) = *(&v166 + 1);
  *(this + 482) = LODWORD(v167);
  *(this + 239) = v38;
  if (v39)
  {
    v40 = *(v38 + 8);
    if ((v37 & (v37 - 1)) != 0)
    {
      if (v40 >= v37)
      {
        v40 %= v37;
      }
    }

    else
    {
      v40 &= v37 - 1;
    }

    *(*v151 + 8 * v40) = this + 1912;
    v166 = 0uLL;
  }

  v150 = (this + 1936);
  std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear(this + 242);
  v44 = v161;
  *&v161 = 0;
  v45 = *(this + 242);
  *(this + 242) = v44;
  if (v45)
  {
    operator delete(v45);
  }

  v46 = *(&v161 + 1);
  v47 = v162;
  *(this + 243) = *(&v161 + 1);
  *(&v161 + 1) = 0;
  v48 = *(&v162 + 1);
  *(this + 245) = *(&v162 + 1);
  *(this + 492) = v163;
  *(this + 244) = v47;
  if (v48)
  {
    v49 = *(v47 + 8);
    if ((v46 & (v46 - 1)) != 0)
    {
      if (v49 >= v46)
      {
        v49 %= v46;
      }
    }

    else
    {
      v49 &= v46 - 1;
    }

    *(*v150 + 8 * v49) = this + 1952;
    v162 = 0uLL;
  }

  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v161);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v165);
  v152 = *(this + 1721);
  if (v152)
  {
    v50 = 1;
  }

  else
  {
    v51 = +[VKDebugSettings sharedSettings];
    v50 = [v51 labelDedupingDisabled];
  }

  v159 = 0;
  v158 = 0;
  v52 = *(*(this + 3) + 424) + 136;
  v161 = 0u;
  v162 = 0u;
  v163 = 1065353216;
  v53 = *(this + 9);
  v54 = *(this + 10);
  *&v165 = this;
  *(&v165 + 1) = &v158;
  v148 = v52;
  *&v166 = v52;
  *(&v166 + 1) = &v161;
  if (v53 != v54)
  {
    while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_0::operator()(&v165, v53) & 1) != 0)
    {
LABEL_69:
      v53 += 2;
      if (v53 == v54)
      {
        goto LABEL_75;
      }
    }

    while (1)
    {
      v54 -= 2;
      if (v54 == v53)
      {
        break;
      }

      if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_0::operator()(&v165, v54))
      {
        v55 = *v53;
        *v53 = *v54;
        *v54 = v55;
        v56 = v53[1];
        v53[1] = v54[1];
        v54[1] = v56;
        goto LABEL_69;
      }
    }
  }

  v54 = v53;
LABEL_75:
  for (j = *(this + 9); j != v54; j += 2)
  {
    v58 = *j;
    if ((*(*j + 1378) & 1) == 0)
    {
      v59 = v54 - 2;
      while (v59 != j)
      {
        v54 = v59;
        v61 = *v59;
        v59 -= 2;
        v60 = v61;
        if (*(v61 + 1378) == 1)
        {
          *j = v60;
          v59[2] = v58;
          v62 = j[1];
          j[1] = v59[3];
          v59[3] = v62;
          goto LABEL_78;
        }
      }

      v54 = j;
      break;
    }

LABEL_78:
    ;
  }

  v63 = *(this + 9);
  if ((v50 & 1) == 0)
  {
    md::LabelPool::prepareDedupingGroupsForCollision(*(this + 6), *(this + 3));
    v64 = v63;
    if (v63 != v54)
    {
      v65 = v54;
      v64 = v63;
LABEL_87:
      while (1)
      {
        v66 = *v64;
        if (!*(*v64 + 24))
        {
          break;
        }

        v64 += 2;
        if (v64 == v65)
        {
          v64 = v65;
          goto LABEL_94;
        }
      }

      v67 = v65 - 2;
      while (v67 != v64)
      {
        v65 = v67;
        v69 = *v67;
        v67 -= 2;
        v68 = v69;
        if (*(v69 + 24))
        {
          *v64 = v68;
          v67[2] = v66;
          v70 = v64[1];
          v64[1] = v67[3];
          v67[3] = v70;
          v64 += 2;
          if (v64 != v65)
          {
            goto LABEL_87;
          }

          break;
        }
      }
    }

LABEL_94:
    v71 = 126 - 2 * __clz((v64 - v63) >> 4);
    if (v64 == v63)
    {
      v72 = 0;
    }

    else
    {
      v72 = v71;
    }

    std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,false>(v63, v64, v72, 1);
  }

  v165 = 0u;
  v166 = 0u;
  LODWORD(v167) = 1065353216;
  v73 = v63;
  if (v63 == v54)
  {
    goto LABEL_141;
  }

  v74 = v63;
  do
  {
    v75 = *v74;
    if (*(*v74 + 1378) != 1)
    {
      goto LABEL_130;
    }

    v76 = *(v75 + 3);
    if ((*(**(v75 + 1) + 264))(*(v75 + 1)) == 26 || (*(**(*v74 + 1) + 264))(*(*v74 + 1)) == 24)
    {
      v77 = 1;
      if (!v76)
      {
        goto LABEL_127;
      }
    }

    else
    {
      v77 = isArrivalFeature(*v74 + 1);
      if (!v76)
      {
LABEL_127:
        v79 = 0;
LABEL_128:
        if (md::ARWalkingLabeler::doesStagingLabelIntersectWithWorld(this, *v74, v77, v79))
        {
          goto LABEL_130;
        }

LABEL_129:
        v153 = *v74;
        std::__hash_table<md::Label *,std::hash<md::Label *>,std::equal_to<md::Label *>,std::allocator<md::Label *>>::__emplace_unique_key_args<md::Label *,md::Label *>(&v165, v153);
        goto LABEL_130;
      }
    }

    if (((*(**(*v74 + 1) + 264))(*(*v74 + 1)) == 26 || (*(**(*v74 + 1) + 264))(*(*v74 + 1)) == 24) && (v78 = (*(*v76 + 56))(v76, *v74)) != 0)
    {
      if (*(v78 + 1378))
      {
        v79 = v78;
      }

      else
      {
        v79 = 0;
      }

      if (v50)
      {
        goto LABEL_128;
      }
    }

    else
    {
      v79 = 0;
      if (v50)
      {
        goto LABEL_128;
      }
    }

    v80 = (*(*v76 + 24))(v76, *(*v74 + 36));
    v81 = *v74;
    if (v80)
    {
      *(v81 + 44) = 0;
      if (*(v81 + 3))
      {
        *(v81 + 845) = 21;
      }

      if (*(v81 + 1373) == 1 && *(v81 + 36) == *(v81 + 33))
      {
        *(v81 + 1373) = 0;
        *(v81 + 1338) = 0;
      }

      if (*(v81 + 1379))
      {
        *(v81 + 1379) = 0;
      }

      v82 = *(v81 + 36);
      if (!v82 || ((*(*v82 + 456))(v82, 0), (*(v81 + 1379) & 1) == 0))
      {
        if (*(v81 + 844) == 2 || *(v81 + 845) != 21)
        {
          md::Label::updateStateMachineForStaging(v81, 6, 21);
        }
      }
    }

    else if (!md::ARWalkingLabeler::doesStagingLabelIntersectWithWorld(this, *v74, v77, v79))
    {
      (*(*v76 + 32))(v76, *v74, 0);
      goto LABEL_129;
    }

LABEL_130:
    v74 += 2;
  }

  while (v74 != v54);
  v83 = v54;
  v73 = v63;
LABEL_134:
  while (1)
  {
    v84 = *v73;
    if (!std::__hash_table<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>>>::find<gdc::Registry *>(&v165, *v73))
    {
      break;
    }

    v73 += 2;
    if (v73 == v83)
    {
      v73 = v83;
      goto LABEL_141;
    }
  }

  v85 = v83 - 2;
  while (v85 != v73)
  {
    v83 = v85;
    v87 = *v85;
    v85 -= 2;
    v86 = v87;
    if (std::__hash_table<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>>>::find<gdc::Registry *>(&v165, v87))
    {
      *v73 = v86;
      v85[2] = v84;
      v88 = v73[1];
      v73[1] = v85[3];
      v85[3] = v88;
      v73 += 2;
      if (v73 != v83)
      {
        goto LABEL_134;
      }

      break;
    }
  }

LABEL_141:
  v89 = v73;
  if (v54 != v73)
  {
    v89 = v73;
LABEL_143:
    while (1)
    {
      v90 = *v89;
      if (*(*v89 + 845) == 21)
      {
        break;
      }

      v89 += 2;
      if (v89 == v54)
      {
        v89 = v54;
        goto LABEL_150;
      }
    }

    v91 = (v54 - 2);
    while (v91 != v89)
    {
      v54 = v91;
      v93 = *v91;
      v91 -= 2;
      v92 = v93;
      if (*(v93 + 845) != 21)
      {
        *v89 = v92;
        v91[2] = v90;
        v94 = v89[1];
        v89[1] = v91[3];
        v91[3] = v94;
        v89 += 2;
        if (v89 != v54)
        {
          goto LABEL_143;
        }

        break;
      }
    }
  }

LABEL_150:
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v165);
  v95 = +[VKDebugSettings sharedSettings];
  v96 = [v95 arForceOccludedStyling];

  if (*(this + 1648) != v96)
  {
    *(this + 1648) = v96;
    v97 = *(this + 9);
    for (k = *(this + 10); v97 != k; v97 += 2)
    {
      v99 = v97[1];
      v157[0] = *v97;
      v157[1] = v99;
      if (v99)
      {
        atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      setFallbackOcclusionStyleEnabled(v157, *(this + 1648));
      if (v99)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v99);
      }
    }
  }

  if (v73 - v63 > 15 || v89 - v73 < 16)
  {
    if (!*(this + 210))
    {
      v106 = v73;
      goto LABEL_192;
    }

    v113 = *(this + 211);
    v155[0] = *(this + 210);
    v155[1] = v113;
    if (v113)
    {
      atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    setFallbackOcclusionStyleEnabled(v155, *(this + 1648));
    v106 = v73;
    v73 = v63;
    if (v113)
    {
      goto LABEL_191;
    }
  }

  else
  {
    v100 = v73;
    if (v73 != v89)
    {
      v101 = v73 + 2;
      v100 = v73;
      if (v73 + 2 != v89)
      {
        v100 = v73;
        do
        {
          v102 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(&v161, *v101);
          if (v102 && v102[3] < *(std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(&v161, *v100) + 3))
          {
            v100 = v101;
          }

          v101 += 2;
        }

        while (v101 != v89);
      }
    }

    v103 = *v100;
    v104 = *(*v100 + 24);
    if (v104 && ((*(**(v103 + 8) + 264))(*(v103 + 8)) == 26 || (*(**(v103 + 8) + 264))(*(v103 + 8)) == 24) && !std::__hash_table<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>>>::find<gdc::Registry *>(v104 + 26, v103))
    {
      v105 = (*(*v104 + 56))(v104, v103);
      if (v105)
      {
        v103 = v105;
      }
    }

    v106 = v73;
    if (v73 != v89)
    {
      v106 = v89;
      v107 = v73;
      while (1)
      {
        v108 = *v107;
        if (*v107 != v103)
        {
          break;
        }

LABEL_175:
        v107 += 2;
        if (v107 == v106)
        {
          goto LABEL_188;
        }
      }

      v109 = v106 - 2;
      while (v109 != v107)
      {
        v106 = v109;
        v111 = *v109;
        v109 -= 2;
        v110 = v111;
        if (v111 == v103)
        {
          *v107 = v110;
          v109[2] = v108;
          v112 = v107[1];
          v107[1] = v109[3];
          v109[3] = v112;
          goto LABEL_175;
        }
      }

      v106 = v107;
    }

LABEL_188:
    v113 = v73[1];
    v156[0] = *v73;
    v156[1] = v113;
    if (v113)
    {
      atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    setFallbackOcclusionStyleEnabled(v156, 1);
    v63 = v73;
    if (v113)
    {
LABEL_191:
      std::__shared_weak_count::__release_shared[abi:nn200100](v113);
LABEL_192:
      v73 = v63;
    }
  }

  if (v106 != v89)
  {
    v114 = v106;
    do
    {
      md::Label::updateStateMachineForStaging(*v114, 2, 22);
      v114 += 2;
    }

    while (v114 != v89);
  }

  v115 = 126 - 2 * __clz((v106 - v73) >> 4);
  *&v165 = *(this + 3) + 3600;
  *(&v165 + 1) = &v161;
  if (v106 == v73)
  {
    v116 = 0;
  }

  else
  {
    v116 = v115;
  }

  std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,false>(v73, v106, &v165, v116, 1);
  if (v106 - v73 > 15)
  {
    v117 = v73[1];
    v153 = *v73;
    v154 = v117;
    if (v117)
    {
      v149 = v117;
      atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    else
    {
      v149 = 0;
    }
  }

  else
  {
    v149 = 0;
    v153 = 0;
    v154 = 0;
  }

  md::ARWalkingLabeler::updateStagingActiveLabel(this, &v153);
  v118 = +[VKDebugSettings sharedSettings];
  v119 = [v118 arAlwaysShowOneContinueLabel];

  for (; v73 != v106; v73 += 2)
  {
    v120 = *v73;
    if ((v152 & 1) != 0 || v120 == *(this + 210) || (v119 & 1) != 0 && *(v120 + 1291) == 26)
    {
      v121 = isStagingLabelVisible(*(*(this + 3) + 424), v120);
      v122 = *v73;
      v123 = *(this + 1904);
      if (v123)
      {
        v124 = 0x9DDFEA08EB382D69 * ((8 * (*v73 & 0x1FFFFFFF) + 8) ^ HIDWORD(*v73));
        v125 = 0x9DDFEA08EB382D69 * (HIDWORD(v122) ^ (v124 >> 47) ^ v124);
        v126 = 0x9DDFEA08EB382D69 * (v125 ^ (v125 >> 47));
        v127 = vcnt_s8(v123);
        v127.i16[0] = vaddlv_u8(v127);
        if (v127.u32[0] > 1uLL)
        {
          v128 = v126;
          if (v126 >= *&v123)
          {
            v128 = v126 % *&v123;
          }
        }

        else
        {
          v128 = v126 & (*&v123 - 1);
        }

        v129 = *(*v151 + 8 * v128);
        if (v129)
        {
          for (m = *v129; m; m = *m)
          {
            v131 = m[1];
            if (v131 == v126)
            {
              if (m[2] == v122)
              {
                goto LABEL_249;
              }
            }

            else
            {
              if (v127.u32[0] > 1uLL)
              {
                if (v131 >= *&v123)
                {
                  v131 %= *&v123;
                }
              }

              else
              {
                v131 &= *&v123 - 1;
              }

              if (v131 != v128)
              {
                break;
              }
            }
          }
        }
      }

      if (v121)
      {
        *(v122 + 851) = 16843009;
        *&v165 = v122;
        std::__hash_table<md::Label *,std::hash<md::Label *>,std::equal_to<md::Label *>,std::allocator<md::Label *>>::__emplace_unique_key_args<md::Label *,md::Label *>(v151, v122);
        md::LabelLayoutContext::coordinateEyePos(&v165, *(*(this + 3) + 424));
        v132 = *v73;
        v133 = *(*v73 + 804) / *(*v73 + 224);
        *(&v166 + 1) = *(*v73 + 788);
        v167 = v133;
        v160 = v132;
        v164 = &v160;
        v134 = std::__hash_table<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::__unordered_map_hasher<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::hash<md::Label *>,std::equal_to<md::Label *>,true>,std::__unordered_map_equal<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::equal_to<md::Label *>,std::hash<md::Label *>,true>,std::allocator<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>>>::__emplace_unique_key_args<md::Label *,std::piecewise_construct_t const&,std::tuple<md::Label *&&>,std::tuple<>>(v150, v132);
        *(v134 + 3) = v165;
        *(v134 + 5) = v166;
        *(v134 + 7) = v167;
        if ((*(this + 1344) & 1) == 0 && *(*v73 + 24) && ((*(**(*v73 + 8) + 264))(*(*v73 + 8)) == 24 || (*(**(*v73 + 8) + 264))(*(*v73 + 8)) == 26))
        {
          v135 = *(*v73 + 24);
          v136 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(v135 + 21, *v73);
          if (v136)
          {
            v137 = v136[3];
            v138 = v135[12];
            if (v138)
            {
              v139 = vcnt_s8(v138);
              v139.i16[0] = vaddlv_u8(v139);
              if (v139.u32[0] > 1uLL)
              {
                v140 = v136[3];
                if (v137 >= *&v138)
                {
                  v140 = v137 % *&v138;
                }
              }

              else
              {
                v140 = (*&v138 - 1) & v137;
              }

              v141 = *(v135[11] + 8 * v140);
              if (v141)
              {
                for (n = *v141; n; n = *n)
                {
                  v143 = n[1];
                  if (v143 == v137)
                  {
                    if (n[2] == v137)
                    {
                      goto LABEL_249;
                    }
                  }

                  else
                  {
                    if (v139.u32[0] > 1uLL)
                    {
                      if (v143 >= *&v138)
                      {
                        v143 %= *&v138;
                      }
                    }

                    else
                    {
                      v143 &= *&v138 - 1;
                    }

                    if (v143 != v140)
                    {
                      break;
                    }
                  }
                }
              }
            }

            operator new();
          }
        }
      }

LABEL_249:
      v144 = *v73;
      *(v144 + 352) = 0;
      v145 = *(v144 + 24);
      if (v145)
      {
        (*(*v145 + 32))(v145, v144, 0);
      }

      if (*(v144 + 1373) == 1 && *(v144 + 288) == *(v144 + 264))
      {
        *(v144 + 1373) = 0;
        *(v144 + 1338) = 0;
      }

      if ((*(v144 + 1379) & 1) == 0)
      {
        *(v144 + 1379) = 1;
        if (*(v144 + 1378) == 1)
        {
          md::Label::updateStateMachineForStaging(v144, 4, 37);
        }
      }

      v146 = *(v144 + 288);
      if (v146)
      {
        (*(*v146 + 456))(v146, 1);
      }

      if ((*(v144 + 1379) & 1) == 0 && (*(v144 + 844) == 2 || *(v144 + 845) != 20))
      {
        md::Label::updateStateMachineForStaging(v144, 6, 20);
      }

      v119 &= *(*v73 + 1291) != 26;
    }

    else
    {
      md::Label::updateStateMachineForStaging(*v73, 2, 32);
    }
  }

  for (ii = 0; ii != 24; ii += 8)
  {
    *(this + ii + 1656) = *(v148 + ii);
  }

  *(this + 1720) = 0;
  if (v149)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v149);
  }

  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v161);
}

void sub_1B32EA518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(va);
  _Unwind_Resume(a1);
}

void md::ARWalkingLabeler::updateStagingActiveLabel(uint64_t a1, void *a2)
{
  v47 = *MEMORY[0x1E69E9840];
  std::string::basic_string[abi:nn200100]<0>(&v37, "");
  if (!*a2)
  {
    goto LABEL_10;
  }

  v4 = *(*a2 + 8);
  if ((*(*v4 + 264))(v4) == 24)
  {
    v5 = v4[90];
    md::LabelExternalPointFeature::incident(v5);
    objc_claimAutoreleasedReturnValue();
    goto LABEL_11;
  }

  if ((*(*v4 + 264))(v4) == 26)
  {
    v5 = v4[25];
    md::LabelExternalPointFeature::incident(v5);
    objc_claimAutoreleasedReturnValue();
    goto LABEL_11;
  }

  if ((*(*v4 + 264))(v4) == 25)
  {
    v5 = v4[29];
    md::LabelExternalPointFeature::incident(v5);
    objc_claimAutoreleasedReturnValue();
    goto LABEL_11;
  }

  if ((*(*v4 + 264))(v4) == 27)
  {
    v5 = v4[93];
    md::LabelExternalPointFeature::incident(v5);
    objc_claimAutoreleasedReturnValue();
  }

  else
  {
LABEL_10:
    v5 = 0;
  }

LABEL_11:
  v6 = *a2;
  if (*(a1 + 1680) == *a2)
  {
    goto LABEL_52;
  }

  v7 = GEOGetVectorKitARWalkingLabelerLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = *a2;
    v9 = *(a1 + 1680);
    v10 = *(a1 + 1704);
    v34 = v5;
    v11 = v10;
    if (v9)
    {
      v12 = *(v9 + 48);
      if (v8)
      {
        goto LABEL_15;
      }
    }

    else
    {
      v12 = 0;
      if (v8)
      {
LABEL_15:
        v13 = *(v8 + 48);
        if (v9)
        {
LABEL_16:
          v14 = *(v9 + 845);
          goto LABEL_20;
        }

LABEL_19:
        v14 = 38;
LABEL_20:
        std::ostringstream::basic_ostringstream[abi:nn200100](&v40);
        if (v8)
        {
          v15 = "Active did label change -";
        }

        else
        {
          v15 = "Active label cleared -";
        }

        if (v8)
        {
          v16 = 25;
        }

        else
        {
          v16 = 22;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, v15, v16);
        if (v9)
        {
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, " reason:", 8);
          md::stringFromLabelOutcome(&__p, v14);
          v17 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &__p : __p.__r_.__value_.__r.__words[0];
          v18 = strlen(v17);
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, v17, v18);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }

        if (v8 && ((std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, " current:(", 10), md::LabelIdentifier::to_string(&__p, v13), (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) ? (v19 = &__p) : (v19 = __p.__r_.__value_.__r.__words[0]), v20 = strlen(v19), std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, v19, v20), std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, ", ", 2), [v34 description], v21 = objc_claimAutoreleasedReturnValue(), v22 = v21, v23 = objc_msgSend(v21, "UTF8String"), v24 = strlen(v23), std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, v23, v24), std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, ")", 1), v21, SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0))
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if (v9)
          {
LABEL_38:
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, " previous:(", 11);
            md::LabelIdentifier::to_string(&__p, v12);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              p_p = &__p;
            }

            else
            {
              p_p = __p.__r_.__value_.__r.__words[0];
            }

            v26 = strlen(p_p);
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, p_p, v26);
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, ", ", 2);
            v27 = [v11 description];
            v28 = v27;
            v29 = [v27 UTF8String];
            v30 = strlen(v29);
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, v29, v30);
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v40, ")", 1);

            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
        }

        else if (v9)
        {
          goto LABEL_38;
        }

        std::stringbuf::str[abi:nn200100](v35, &v41);
        v40 = *MEMORY[0x1E69E54E8];
        *(&v40 + *(v40 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
        v41 = MEMORY[0x1E69E5548] + 16;
        if (v43 < 0)
        {
          operator delete(v42[7].__locale_);
        }

        v41 = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(v42);
        std::ostream::~ostream();
        MEMORY[0x1B8C620C0](&v44);

        v31 = v35;
        if (v36 < 0)
        {
          v31 = v35[0];
        }

        *buf = 136315138;
        v46 = v31;
        _os_log_impl(&dword_1B2754000, v7, OS_LOG_TYPE_INFO, "%s", buf, 0xCu);
        if (v36 < 0)
        {
          operator delete(v35[0]);
        }

        goto LABEL_51;
      }
    }

    v13 = 0;
    if (v9)
    {
      goto LABEL_16;
    }

    goto LABEL_19;
  }

LABEL_51:

  v6 = *a2;
LABEL_52:
  v32 = a2[1];
  if (v32)
  {
    atomic_fetch_add_explicit((v32 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 1680) = v6;
  v33 = *(a1 + 1688);
  *(a1 + 1688) = v32;
  if (v33)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v33);
  }

  geo::_retain_ptr<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::reset(a1 + 1696, v5);

  if (v38 < 0)
  {
    operator delete(v37);
  }
}

void sub_1B32EAC30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43)
{
  v45 = *MEMORY[0x1E69E54E8];
  a26 = *MEMORY[0x1E69E54E8];
  *(&a26 + *(v45 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a27 = MEMORY[0x1E69E5548] + 16;
  if (a40 < 0)
  {
    operator delete(a35);
  }

  a27 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a28);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a43);

  if (a19 < 0)
  {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::__hash_table<md::Label *,std::hash<md::Label *>,std::equal_to<md::Label *>,std::allocator<md::Label *>>::__emplace_unique_key_args<md::Label *,md::Label *>(void *result, unint64_t a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (a2 & 0x1FFFFFFF) + 8) ^ HIDWORD(a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = result[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*result + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != a2)
  {
    goto LABEL_17;
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::__unordered_map_hasher<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::hash<md::Label *>,std::equal_to<md::Label *>,true>,std::__unordered_map_equal<md::Label *,std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>,std::equal_to<md::Label *>,std::hash<md::Label *>,true>,std::allocator<std::__hash_value_type<md::Label *,md::ARWalkingBecameVisibleDebugData>>>::__emplace_unique_key_args<md::Label *,std::piecewise_construct_t const&,std::tuple<md::Label *&&>,std::tuple<>>(void *a1, unint64_t a2)
{
  v2 = 0x9DDFEA08EB382D69 * ((8 * (a2 & 0x1FFFFFFF) + 8) ^ HIDWORD(a2));
  v3 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v2 >> 47) ^ v2);
  v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  v5 = a1[1];
  if (!*&v5)
  {
    goto LABEL_18;
  }

  v6 = vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    if (v4 >= *&v5)
    {
      v7 = v4 % *&v5;
    }
  }

  else
  {
    v7 = v4 & (*&v5 - 1);
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v10 = v9[1];
    if (v10 == v4)
    {
      break;
    }

    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= *&v5)
      {
        v10 %= *&v5;
      }
    }

    else
    {
      v10 &= *&v5 - 1;
    }

    if (v10 != v7)
    {
      goto LABEL_18;
    }

LABEL_17:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_18;
    }
  }

  if (v9[2] != a2)
  {
    goto LABEL_17;
  }

  return v9;
}

uint64_t md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_0::operator()(uint64_t *a1, md::Label **a2)
{
  v4 = *a1;
  md::Label::layoutForStaging(*a2, *(*a1 + 24), *(*a1 + 48), a1[1]);
  v5 = *a2;
  if (*(*a2 + 1378) != 1)
  {
    return 0;
  }

  if (!isArrivalFeature(v5 + 1) && (*(**(v5 + 1) + 264))(*(v5 + 1)) != 24 && (*(**(v5 + 1) + 264))(*(v5 + 1)) != 26)
  {
    v18 = 29;
    goto LABEL_35;
  }

  v6 = *a2;
  v7 = gm::Matrix<double,3,1>::distanceSquaredToPoint<int,void>(a1[2], *a2 + 616);
  v8 = a1[3];
  v9 = 0x9DDFEA08EB382D69 * ((8 * (v6 & 0x1FFFFFFF) + 8) ^ (v6 >> 32));
  v10 = 0x9DDFEA08EB382D69 * ((v6 >> 32) ^ (v9 >> 47) ^ v9);
  v11 = 0x9DDFEA08EB382D69 * (v10 ^ (v10 >> 47));
  v12 = v8[1];
  if (!*&v12)
  {
    goto LABEL_22;
  }

  v13 = vcnt_s8(v12);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    v14 = 0x9DDFEA08EB382D69 * (v10 ^ (v10 >> 47));
    if (v11 >= *&v12)
    {
      v14 = v11 % *&v12;
    }
  }

  else
  {
    v14 = v11 & (*&v12 - 1);
  }

  v15 = *(*v8 + 8 * v14);
  if (!v15 || (v16 = *v15) == 0)
  {
LABEL_22:
    operator new();
  }

  while (1)
  {
    v17 = *(v16 + 1);
    if (v17 == v11)
    {
      break;
    }

    if (v13.u32[0] > 1uLL)
    {
      if (v17 >= *&v12)
      {
        v17 %= *&v12;
      }
    }

    else
    {
      v17 &= *&v12 - 1;
    }

    if (v17 != v14)
    {
      goto LABEL_22;
    }

LABEL_21:
    v16 = *v16;
    if (!v16)
    {
      goto LABEL_22;
    }
  }

  if (*(v16 + 2) != v6)
  {
    goto LABEL_21;
  }

  v19 = v7 / (*(v6 + 28) * *(v6 + 28));
  v16[3] = v19;
  v20 = 1.0 / *(v6 + 28);
  v21 = fmax(*(v4 + 784), v20 * *(v6 + 202));
  v22 = fmin(v20 * *(v6 + 203), *(v4 + 864));
  v23 = v22 * v22;
  if (v19 >= v21 * v21 && v19 <= v23)
  {
    return 1;
  }

  v25 = *(v6 + 3);
  if (v25 && ((*(**(v6 + 1) + 264))(*(v6 + 1)) == 26 || (*(**(*a2 + 1) + 264))(*(*a2 + 1)) == 24) && (v26 = (*(*v25 + 56))(v25, *a2)) != 0)
  {
    v18 = 3;
    md::Label::updateStateMachineForStaging(v26, 2, 3);
  }

  else
  {
    v18 = 3;
  }

LABEL_35:
  md::Label::updateStateMachineForStaging(*a2, 2, v18);
  return 0;
}

uint64_t setFallbackOcclusionStyleEnabled(uint64_t *a1, char a2)
{
  v4 = (*(**(*a1 + 8) + 264))(*(*a1 + 8));
  result = *(*a1 + 8);
  if (v4 == 24)
  {
    *(result + 849) = a2;
  }

  else
  {
    result = (*(*result + 264))(result);
    v6 = *a1;
    if (result == 26)
    {
      *(*(v6 + 8) + 418) = a2;
    }

    else
    {
      result = isArrivalFeature((v6 + 8));
      if (result)
      {
        *(*(*a1 + 8) + 760) = a2;
      }
    }
  }

  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,false>(unint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  v9 = a2 - 2;
  v162 = a2 - 1;
  v164 = a2 - 6;
  v165 = a2 - 4;
  v160 = a2 - 5;
  v161 = a2 - 3;
  v10 = a1;
  while (1)
  {
    a1 = v10;
    v11 = (a2 - v10) >> 4;
    v12 = v11 - 2;
    if (v11 > 2)
    {
      break;
    }

    if (v11 < 2)
    {
      return;
    }

    if (v11 == 2)
    {
      if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, v10))
      {
        v94 = *v10;
        *v10 = *v9;
        *v9 = v94;
        v95 = v10[1];
        v96 = a2 - 1;
        v10[1] = *v162;
        goto LABEL_210;
      }

      return;
    }

LABEL_9:
    if (v11 <= 23)
    {
      if (a5)
      {
        if (v10 != a2)
        {
          v101 = v10 + 2;
          if (v10 + 2 != a2)
          {
            v102 = 0;
            v103 = v10;
            do
            {
              v104 = v103;
              v103 = v101;
              if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v101, v104))
              {
                v170 = *v103;
                *v103 = 0;
                v103[1] = 0;
                v105 = v102;
                while (1)
                {
                  v106 = v10 + v105;
                  v107 = *(v10 + v105);
                  *v106 = 0;
                  *(v106 + 1) = 0;
                  v108 = *(v10 + v105 + 24);
                  *(v106 + 1) = v107;
                  if (v108)
                  {
                    std::__shared_weak_count::__release_shared[abi:nn200100](v108);
                  }

                  if (!v105)
                  {
                    break;
                  }

                  v109 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, (v10 + v105 - 16));
                  v105 -= 16;
                  if ((v109 & 1) == 0)
                  {
                    v110 = v10 + v105 + 16;
                    goto LABEL_137;
                  }
                }

                v110 = v10;
LABEL_137:
                v111 = v170;
                v170 = 0uLL;
                v112 = *(v110 + 8);
                *v110 = v111;
                if (v112)
                {
                  std::__shared_weak_count::__release_shared[abi:nn200100](v112);
                }

                if (*(&v170 + 1))
                {
                  std::__shared_weak_count::__release_shared[abi:nn200100](*(&v170 + 1));
                }
              }

              v101 = v103 + 2;
              v102 += 16;
            }

            while (v103 + 2 != a2);
          }
        }
      }

      else if (v10 != a2)
      {
        while (1)
        {
          v151 = a1 + 2;
          if (a1 + 2 == a2)
          {
            break;
          }

          v152 = a1;
          a1 += 2;
          if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v151, v152))
          {
            v170 = *a1;
            *a1 = 0;
            a1[1] = 0;
            v153 = a1;
            do
            {
              v154 = *(v153 - 1);
              *(v153 - 2) = 0;
              *(v153 - 1) = 0;
              v155 = v153[1];
              *v153 = v154;
              if (v155)
              {
                std::__shared_weak_count::__release_shared[abi:nn200100](v155);
              }

              v156 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v153 - 4);
              v153 -= 2;
            }

            while ((v156 & 1) != 0);
            v157 = v170;
            v170 = 0uLL;
            v158 = v153[1];
            *v153 = v157;
            if (v158)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v158);
            }

            if (*(&v170 + 1))
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](*(&v170 + 1));
            }
          }
        }
      }

      return;
    }

    if (!a4)
    {
      if (v10 == a2)
      {
        return;
      }

      v168 = a2;
      v113 = v12 >> 1;
      v114 = v12 >> 1;
      do
      {
        v115 = v114;
        if (v113 >= v114)
        {
          v116 = (2 * v114) | 1;
          v117 = &a1[2 * v116];
          if (2 * v114 + 2 < v11 && md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * v116], v117 + 2))
          {
            v117 += 2;
            v116 = 2 * v115 + 2;
          }

          v118 = &a1[2 * v115];
          if ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v117, v118) & 1) == 0)
          {
            v170 = *v118;
            *v118 = 0;
            v118[1] = 0;
            do
            {
              v119 = v117;
              v120 = *v117;
              *v117 = 0;
              v117[1] = 0;
              v121 = v118[1];
              *v118 = v120;
              if (v121)
              {
                std::__shared_weak_count::__release_shared[abi:nn200100](v121);
              }

              if (v113 < v116)
              {
                break;
              }

              v122 = (2 * v116) | 1;
              v117 = &a1[2 * v122];
              v116 = 2 * v116 + 2;
              if (v116 >= v11)
              {
                v116 = v122;
              }

              else if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * v122], v117 + 2))
              {
                v117 += 2;
              }

              else
              {
                v116 = v122;
              }

              v118 = v119;
            }

            while (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v117, &v170));
            v123 = v170;
            v170 = 0uLL;
            v124 = v119[1];
            *v119 = v123;
            if (v124)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v124);
            }

            if (*(&v170 + 1))
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](*(&v170 + 1));
            }
          }
        }

        v114 = v115 - 1;
      }

      while (v115);
      v125 = v168;
      while (2)
      {
        v126 = 0;
        v127 = v125;
        v166 = *a1;
        v169 = a1[1];
        *a1 = 0;
        a1[1] = 0;
        v128 = a1;
        do
        {
          v129 = &v128[2 * v126];
          v130 = v129 + 2;
          v131 = 2 * v126;
          v126 = (2 * v126) | 1;
          v132 = v131 + 2;
          if (v131 + 2 < v11)
          {
            v133 = v129 + 4;
            if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v129 + 2, v129 + 4))
            {
              v130 = v133;
              v126 = v132;
            }
          }

          v134 = *v130;
          *v130 = 0;
          v130[1] = 0;
          v135 = v128[1];
          *v128 = v134;
          if (v135)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v135);
          }

          v128 = v130;
        }

        while (v126 <= ((v11 - 2) >> 1));
        v125 -= 2;
        if (v130 == v127 - 2)
        {
          v147 = v130[1];
          *v130 = v166;
          v130[1] = v169;
          if (!v147)
          {
            goto LABEL_189;
          }
        }

        else
        {
          v136 = *(v127 - 1);
          *v125 = 0;
          *(v127 - 1) = 0;
          v137 = v130[1];
          *v130 = v136;
          if (v137)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v137);
          }

          v138 = *(v127 - 1);
          *(v127 - 2) = v166;
          *(v127 - 1) = v169;
          if (v138)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v138);
          }

          v139 = ((v130 + 2) - a1) >> 4;
          v140 = v139 < 2;
          v141 = v139 - 2;
          if (v140)
          {
            goto LABEL_189;
          }

          v142 = v141 >> 1;
          v143 = &a1[2 * (v141 >> 1)];
          if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v143, v130))
          {
            goto LABEL_189;
          }

          v170 = *v130;
          *v130 = 0;
          v130[1] = 0;
          do
          {
            v144 = v143;
            v145 = *v143;
            *v143 = 0;
            v143[1] = 0;
            v146 = v130[1];
            *v130 = v145;
            if (v146)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v146);
            }

            if (!v142)
            {
              break;
            }

            v142 = (v142 - 1) >> 1;
            v143 = &a1[2 * v142];
            v130 = v144;
          }

          while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v143, &v170) & 1) != 0);
          v147 = v144[1];
          *v144 = v170;
          if (!v147)
          {
LABEL_189:
            v140 = v11-- <= 2;
            if (v140)
            {
              return;
            }

            continue;
          }
        }

        break;
      }

      std::__shared_weak_count::__release_shared[abi:nn200100](v147);
      goto LABEL_189;
    }

    v13 = v11 >> 1;
    v14 = &v10[2 * (v11 >> 1)];
    if (v11 >= 0x81)
    {
      v15 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * (v11 >> 1)], a1);
      v16 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, &a1[2 * (v11 >> 1)]);
      v163 = a4;
      if (v15)
      {
        v18 = a1 + 1;
        v17 = *a1;
        if (v16)
        {
          *a1 = *v9;
          goto LABEL_26;
        }

        v31 = a1[1];
        *a1 = *v14;
        v14[1] = v31;
        v18 = v14 + 1;
        *v14 = v17;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, &a1[2 * (v11 >> 1)]))
        {
          v17 = *v14;
          *v14 = *v9;
LABEL_26:
          *v9 = v17;
          v25 = a2 - 1;
LABEL_27:
          v32 = *v18;
          *v18 = *v25;
          *v25 = v32;
        }
      }

      else if (v16)
      {
        v23 = *v14;
        *v14 = *v9;
        *v9 = v23;
        v25 = v14 + 1;
        v24 = v14[1];
        v14[1] = *v162;
        *v162 = v24;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * (v11 >> 1)], a1))
        {
          v26 = *a1;
          *a1 = *v14;
          v18 = a1 + 1;
          *v14 = v26;
          goto LABEL_27;
        }
      }

      v33 = v14 - 2;
      v34 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v14 - 2, a1 + 2);
      v35 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v165, v14 - 2);
      if (v34)
      {
        v36 = a1[2];
        v37 = a1 + 3;
        if (v35)
        {
          v38 = a2 - 4;
          a1[2] = *v165;
          goto LABEL_39;
        }

        v44 = *v37;
        *(a1 + 1) = *v33;
        *(v14 - 1) = v44;
        v37 = v14 - 1;
        *v33 = v36;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v165, v14 - 2))
        {
          v36 = *v33;
          v38 = a2 - 4;
          *v33 = *v165;
LABEL_39:
          *v38 = v36;
          v41 = a2 - 3;
LABEL_40:
          v45 = *v37;
          *v37 = *v41;
          *v41 = v45;
        }
      }

      else if (v35)
      {
        v39 = *v33;
        *v33 = *v165;
        *v165 = v39;
        v41 = v14 - 1;
        v40 = *(v14 - 1);
        *(v14 - 1) = *v161;
        *v161 = v40;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v14 - 2, a1 + 2))
        {
          v42 = a1[2];
          a1[2] = *v33;
          *v33 = v42;
          v37 = a1 + 3;
          goto LABEL_40;
        }
      }

      v46 = v13 + 1;
      v47 = &a1[2 * v13 + 2];
      v48 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v47, a1 + 4);
      v49 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v164, v47);
      if (v48)
      {
        v50 = a1[4];
        v51 = a1 + 5;
        if (v49)
        {
          v52 = a2 - 6;
          a1[4] = *v164;
          goto LABEL_49;
        }

        v57 = *v51;
        *(a1 + 2) = *v47;
        v47[1] = v57;
        v51 = v47 + 1;
        *v47 = v50;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v164, &a1[2 * v13 + 2]))
        {
          v50 = *v47;
          v52 = a2 - 6;
          *v47 = *v164;
LABEL_49:
          *v52 = v50;
          v55 = a2 - 5;
LABEL_50:
          v58 = *v51;
          *v51 = *v55;
          *v55 = v58;
        }
      }

      else if (v49)
      {
        v53 = *v47;
        *v47 = *v164;
        *v164 = v53;
        v55 = v47 + 1;
        v54 = v47[1];
        v47[1] = *v160;
        *v160 = v54;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * v13 + 2], a1 + 4))
        {
          v56 = a1[4];
          a1[4] = *v47;
          *v47 = v56;
          v51 = a1 + 5;
          goto LABEL_50;
        }
      }

      v59 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v14, v14 - 2);
      v60 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * v13 + 2], v14);
      if (v59)
      {
        v61 = *v33;
        a4 = v163;
        if (v60)
        {
          *v33 = *v47;
          *v47 = v61;
          v62 = v14 - 1;
          goto LABEL_59;
        }

        v65 = *v14;
        v14[1] = *(v14 - 1);
        *v14 = v61;
        *v33 = v65;
        if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &a1[2 * v13 + 2], v14))
        {
          v66 = *v14;
          *v14 = *v47;
          *v47 = v66;
          v62 = v14 + 1;
LABEL_59:
          v67 = &a1[2 * v46];
          v68 = *v62;
          *v62 = v67[1];
          v67[1] = v68;
        }
      }

      else
      {
        a4 = v163;
        if (v60)
        {
          v63 = *v14;
          *v14 = *v47;
          *v47 = v63;
          if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v14, v14 - 2))
          {
            v64 = *v33;
            *v33 = *v14;
            v62 = v14 - 1;
            *v14 = v64;
            v46 = v13;
            goto LABEL_59;
          }
        }
      }

      v69 = *a1;
      *a1 = *v14;
      v22 = a1 + 1;
      *v14 = v69;
      v30 = v14 + 1;
      v9 = a2 - 2;
      goto LABEL_61;
    }

    v19 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1, &a1[2 * (v11 >> 1)]);
    v20 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, a1);
    if (v19)
    {
      v22 = v14 + 1;
      v21 = *v14;
      if (v20)
      {
        *v14 = *v9;
      }

      else
      {
        v43 = v14[1];
        *v14 = *a1;
        a1[1] = v43;
        v22 = a1 + 1;
        *a1 = v21;
        if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, a1))
        {
          goto LABEL_62;
        }

        v21 = *a1;
        *a1 = *v9;
      }

      *v9 = v21;
      v30 = a2 - 1;
    }

    else
    {
      if (!v20)
      {
        goto LABEL_62;
      }

      v27 = *a1;
      *a1 = *v9;
      *v9 = v27;
      v28 = a1[1];
      a1[1] = *v162;
      *v162 = v28;
      if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1, &a1[2 * (v11 >> 1)]))
      {
        goto LABEL_62;
      }

      v29 = *v14;
      *v14 = *a1;
      *a1 = v29;
      v22 = v14 + 1;
      v30 = a1 + 1;
    }

LABEL_61:
    v70 = *v22;
    *v22 = *v30;
    *v30 = v70;
LABEL_62:
    --a4;
    if (a5 & 1) != 0 || (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 - 2, a1))
    {
      v170 = *a1;
      *a1 = 0;
      a1[1] = 0;
      v71 = a1;
      do
      {
        v71 += 2;
      }

      while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v71, &v170) & 1) != 0);
      v72 = a2;
      if (v71 - 2 == a1)
      {
        v72 = a2;
        do
        {
          if (v71 >= v72)
          {
            break;
          }

          v72 -= 2;
        }

        while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v72, &v170) & 1) == 0);
      }

      else
      {
        do
        {
          v72 -= 2;
        }

        while (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v72, &v170));
      }

      v10 = v71;
      if (v71 < v72)
      {
        v73 = v72;
        do
        {
          v74 = *v10;
          *v10 = *v73;
          *v73 = v74;
          v75 = v10[1];
          v10[1] = v73[1];
          v73[1] = v75;
          do
          {
            v10 += 2;
          }

          while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v10, &v170) & 1) != 0);
          do
          {
            v73 -= 2;
          }

          while (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v73, &v170));
        }

        while (v10 < v73);
      }

      v76 = v10 - 2;
      if (v10 - 2 != a1)
      {
        v77 = *v76;
        *v76 = 0;
        *(v10 - 1) = 0;
        v78 = a1[1];
        *a1 = v77;
        if (v78)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v78);
        }
      }

      v79 = v170;
      v170 = 0uLL;
      v80 = *(v10 - 1);
      *(v10 - 1) = v79;
      if (v80)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v80);
      }

      if (*(&v170 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&v170 + 1));
      }

      if (v71 < v72)
      {
        goto LABEL_88;
      }

      v81 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *>(a1, v10 - 2, a3);
      if (std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *>(v10, a2, a3))
      {
        a2 = v10 - 2;
        if (v81)
        {
          return;
        }

        goto LABEL_1;
      }

      if (!v81)
      {
LABEL_88:
        std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,false>(a1, v10 - 2, a3, a4, a5 & 1);
        goto LABEL_89;
      }
    }

    else
    {
      v82 = a1[1];
      *&v170 = *a1;
      *(&v170 + 1) = v82;
      *a1 = 0;
      a1[1] = 0;
      if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v9))
      {
        v10 = a1;
        do
        {
          v10 += 2;
        }

        while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v10) & 1) == 0);
      }

      else
      {
        v83 = a1 + 2;
        do
        {
          v10 = v83;
          if (v83 >= a2)
          {
            break;
          }

          v84 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v83);
          v83 = v10 + 2;
        }

        while (!v84);
      }

      v85 = a2;
      if (v10 < a2)
      {
        v85 = a2;
        do
        {
          v85 -= 2;
        }

        while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v85) & 1) != 0);
      }

      while (v10 < v85)
      {
        v86 = *v10;
        *v10 = *v85;
        *v85 = v86;
        v87 = v10[1];
        v10[1] = v85[1];
        v85[1] = v87;
        do
        {
          v10 += 2;
        }

        while (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v10));
        do
        {
          v85 -= 2;
        }

        while ((md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v170, v85) & 1) != 0);
      }

      v88 = v10 - 2;
      if (v10 - 2 != a1)
      {
        v89 = *v88;
        *v88 = 0;
        *(v10 - 1) = 0;
        v90 = a1[1];
        *a1 = v89;
        if (v90)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v90);
        }
      }

      v91 = v170;
      v170 = 0uLL;
      v92 = *(v10 - 1);
      *(v10 - 1) = v91;
      if (v92)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v92);
      }

      if (*(&v170 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&v170 + 1));
      }

LABEL_89:
      a5 = 0;
    }
  }

  if (v11 != 3)
  {
    if (v11 == 4)
    {

      std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(v10, v10 + 2, v10 + 4, v9, a3);
      return;
    }

    if (v11 == 5)
    {

      std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(v10, v10 + 2, v10 + 4, v10 + 6, v9, a3);
      return;
    }

    goto LABEL_9;
  }

  v97 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v10 + 2, v10);
  v98 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, v10 + 2);
  if (v97)
  {
    v100 = v10 + 1;
    v99 = *v10;
    if (v98)
    {
      *v10 = *v9;
    }

    else
    {
      v159 = *(v10 + 1);
      v10[3] = v10[1];
      v100 = v10 + 3;
      v10[2] = v99;
      *v10 = v159;
      if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v9, v10 + 2))
      {
        return;
      }

      v99 = v10[2];
      v10[2] = *v9;
    }

    *v9 = v99;
  }

  else
  {
    if (!v98)
    {
      return;
    }

    v148 = v10[2];
    v10[2] = *v9;
    *v9 = v148;
    v149 = v10[3];
    v10[3] = *v162;
    *v162 = v149;
    if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v10 + 2, v10))
    {
      return;
    }

    v150 = *v10;
    *v10 = v10[2];
    v10[2] = v150;
    v100 = v10 + 1;
    v162 = v10 + 3;
  }

  v95 = *v100;
  v96 = v162;
  *v100 = *v162;
LABEL_210:
  *v96 = v95;
}

void sub_1B32ECB80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v18);
  }

  _Unwind_Resume(exception_object);
}

uint64_t isStagingLabelVisible(const LabelLayoutContext *a1, md::Label *a2)
{
  if (!a2)
  {
    return 0;
  }

  v2 = *(a2 + 201);
  if (*(a1 + 34) > v2 || *(a1 + 35) < v2)
  {
    return 0;
  }

  else
  {
    return (*(*a2 + 40))(a2, a1 + 736);
  }
}

uint64_t md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  v6 = *a2;
  v7 = *a3;
  if (!isArrivalFeature((*a2 + 8)) && !isArrivalFeature((v7 + 8)))
  {
    v10 = (*(**(v6 + 8) + 264))(*(v6 + 8));
    v11 = v10 == 24;
    if ((v10 == 24) != ((*(**(v7 + 8) + 264))() == 24))
    {
      return v11;
    }

    v12 = (*(**(v6 + 8) + 208))(*(v6 + 8));
    v13 = [v12 intraFeaturePriority];

    v14 = (*(**(v7 + 8) + 208))(*(v7 + 8));
    v15 = [v14 intraFeaturePriority];

    v8 = v13 >= v15;
    if (v13 == v15)
    {
      v16 = (*(**(v6 + 8) + 304))(*(v6 + 8), *a2 + 48);
      v18 = v17;
      v19 = (*(**(v7 + 8) + 304))();
      if ((v18 & 1) != 0 && (v20 & 1) != 0 && ((v21 = vabds_f32(*(&v16 + 1), *(&v19 + 1)), v16 == v19) ? (v22 = v21 < 0.00000011921) : (v22 = 0), !v22))
      {
        if (v10 != 24 && ((v30 = *a1, v31 = **a1, v31 < v16) || v31 == v16 && *(v30 + 1) <= *(&v16 + 1)) && (v31 < v19 || v31 == v19 && *(v30 + 1) <= *(&v19 + 1)))
        {
          if (v16 >= v19)
          {
            return (v16 == v19) & (*(&v16 + 1) < *(&v19 + 1));
          }

          else
          {
            return 1;
          }
        }

        else if (v16 <= v19)
        {
          return (v16 == v19) & (*(&v16 + 1) > *(&v19 + 1));
        }

        else
        {
          return 1;
        }
      }

      else
      {
        v23 = *(a1 + 8);
        v24 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(v23, *a2);
        if (v24)
        {
          v25 = v24;
          v26 = std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>(v23, *a3);
          v27 = (*(**(v6 + 8) + 264))(*(v6 + 8));
          v28 = v25[3];
          v29 = v26[3];
          if (v27 == 24)
          {
            return v28 > v29;
          }

          else
          {
            return v28 < v29;
          }
        }

        else
        {
          return 0;
        }
      }
    }

    return !v8;
  }

  if (isArrivalFeature((v6 + 8)) && isArrivalFeature((v7 + 8)))
  {
    v8 = *(v6 + 8) >= *(v7 + 8);
    return !v8;
  }

  return isArrivalFeature((v6 + 8));
}

uint64_t std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, uint64_t a5)
{
  v10 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a2, a1);
  v11 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a3, a2);
  if (v10)
  {
    v13 = (a1 + 1);
    v12 = *a1;
    if (v11)
    {
      *a1 = *a3;
LABEL_9:
      *a3 = v12;
      v16 = (a3 + 1);
      goto LABEL_10;
    }

    *a1 = *a2;
    *a2 = v12;
    v13 = (a2 + 1);
    v18 = a1[1];
    a1[1] = a2[1];
    a2[1] = v18;
    if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a3, a2))
    {
      v12 = *a2;
      *a2 = *a3;
      goto LABEL_9;
    }
  }

  else if (v11)
  {
    v14 = *a2;
    *a2 = *a3;
    *a3 = v14;
    v16 = (a2 + 1);
    v15 = a2[1];
    a2[1] = a3[1];
    a3[1] = v15;
    if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a2, a1))
    {
      v17 = *a1;
      *a1 = *a2;
      v13 = (a1 + 1);
      *a2 = v17;
LABEL_10:
      v19 = *v13;
      *v13 = *v16;
      *v16 = v19;
    }
  }

  result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a4, a3);
  if (result)
  {
    v21 = *a3;
    *a3 = *a4;
    *a4 = v21;
    v22 = a3[1];
    a3[1] = a4[1];
    a4[1] = v22;
    result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a3, a2);
    if (result)
    {
      v23 = *a2;
      *a2 = *a3;
      *a3 = v23;
      v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a5, a2, a1);
      if (result)
      {
        v25 = *a1;
        *a1 = *a2;
        *a2 = v25;
        v26 = a1[1];
        a1[1] = a2[1];
        a2[1] = v26;
      }
    }
  }

  return result;
}

uint64_t std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, uint64_t a6)
{
  std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(a1, a2, a3, a4, a6);
  result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a6, a5, a4);
  if (result)
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    v14 = a4[1];
    a4[1] = a5[1];
    a5[1] = v14;
    result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a6, a4, a3);
    if (result)
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a6, a3, a2);
      if (result)
      {
        v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        v18 = a2[1];
        a2[1] = a3[1];
        a3[1] = v18;
        result = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a6, a2, a1);
        if (result)
        {
          v19 = *a1;
          *a1 = *a2;
          *a2 = v19;
          v20 = a1[1];
          a1[1] = a2[1];
          a2[1] = v20;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  v6 = (a2 - a1) >> 4;
  if (v6 > 2)
  {
    switch(v6)
    {
      case 3:
        v9 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 2, a1);
        v10 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a2 - 2, a1 + 2);
        if (v9)
        {
          v12 = a1 + 1;
          v11 = *a1;
          if (v10)
          {
            *a1 = *(a2 - 2);
          }

          else
          {
            v25 = *(a1 + 1);
            a1[3] = a1[1];
            v12 = a1 + 3;
            a1[2] = v11;
            *a1 = v25;
            if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a2 - 2, a1 + 2))
            {
              return 1;
            }

            v11 = a1[2];
            a1[2] = *(a2 - 2);
          }

          *(a2 - 2) = v11;
          v20 = a2 - 1;
        }

        else
        {
          if (!v10)
          {
            return 1;
          }

          v18 = a1[2];
          a1[2] = *(a2 - 2);
          *(a2 - 2) = v18;
          v20 = a1 + 3;
          v19 = a1[3];
          a1[3] = *(a2 - 1);
          *(a2 - 1) = v19;
          if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 2, a1))
          {
            return 1;
          }

          v21 = *a1;
          *a1 = a1[2];
          a1[2] = v21;
          v12 = a1 + 1;
        }

        v26 = *v12;
        *v12 = *v20;
        *v20 = v26;
        return 1;
      case 4:
        std::__sort4[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a1 + 4, a2 - 2, a3);
        break;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
        break;
      default:
        goto LABEL_13;
    }

    return 1;
  }

  if (v6 < 2)
  {
    return 1;
  }

  if (v6 == 2)
  {
    if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a2 - 2, a1))
    {
      v7 = *a1;
      *a1 = *(a2 - 2);
      *(a2 - 2) = v7;
      v8 = a1[1];
      a1[1] = *(a2 - 1);
      *(a2 - 1) = v8;
    }

    return 1;
  }

LABEL_13:
  v13 = a1 + 4;
  v14 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 2, a1);
  v15 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 4, a1 + 2);
  if (v14)
  {
    v17 = (a1 + 1);
    v16 = *a1;
    if (v15)
    {
      *a1 = a1[4];
    }

    else
    {
      v27 = *(a1 + 1);
      a1[3] = a1[1];
      v17 = (a1 + 3);
      a1[2] = v16;
      *a1 = v27;
      if (!md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 4, a1 + 2))
      {
        goto LABEL_31;
      }

      v16 = a1[2];
      a1[2] = a1[4];
    }

    a1[4] = v16;
    v23 = (a1 + 5);
    goto LABEL_30;
  }

  if (v15)
  {
    v22 = *(a1 + 1);
    *(a1 + 1) = *(a1 + 2);
    *(a1 + 2) = v22;
    if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, a1 + 2, a1))
    {
      v23 = (a1 + 3);
      v24 = *a1;
      *a1 = a1[2];
      a1[2] = v24;
      v17 = (a1 + 1);
LABEL_30:
      v28 = *v17;
      *v17 = *v23;
      *v23 = v28;
    }
  }

LABEL_31:
  v29 = a1 + 6;
  if (a1 + 6 == a2)
  {
    return 1;
  }

  v30 = 0;
  v31 = 0;
  while (1)
  {
    if (md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, v29, v13))
    {
      v41 = *v29;
      *v29 = 0;
      v29[1] = 0;
      v32 = v30;
      while (1)
      {
        v33 = a1 + v32;
        v34 = *(a1 + v32 + 32);
        *(v33 + 4) = 0;
        *(v33 + 5) = 0;
        v35 = *(a1 + v32 + 56);
        *(v33 + 3) = v34;
        if (v35)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v35);
        }

        if (v32 == -32)
        {
          break;
        }

        v36 = md::ARWalkingLabeler::layoutLabelsForStaging(void)::$_4::operator()(a3, &v41, (a1 + v32 + 16));
        v32 -= 16;
        if ((v36 & 1) == 0)
        {
          v37 = a1 + v32 + 48;
          goto LABEL_41;
        }
      }

      v37 = a1;
LABEL_41:
      v38 = v41;
      v41 = 0uLL;
      v39 = *(v37 + 8);
      *v37 = v38;
      if (v39)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v39);
      }

      if (*(&v41 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&v41 + 1));
      }

      if (++v31 == 8)
      {
        return v29 + 2 == a2;
      }
    }

    v13 = v29;
    v30 += 16;
    v29 += 2;
    if (v29 == a2)
    {
      return 1;
    }
  }
}

void sub_1B32ED668(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  _Unwind_Resume(exception_object);
}

void std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  v8 = a2 - 2;
  i = a1;
  while (1)
  {
    a1 = i;
    v10 = (a2 - i) >> 4;
    v11 = v10 - 2;
    if (v10 > 2)
    {
      break;
    }

    if (v10 < 2)
    {
      return;
    }

    if (v10 == 2)
    {
      v75 = *v8;
      v76 = *i;
      if (*v8 != *i)
      {
        v77 = *(v75 + 24);
        v78 = *(v76 + 24);
        v79 = v77 >= v78;
        if (v77 == v78)
        {
          v79 = *(v75 + 32) >= *(v76 + 32);
        }

        if (!v79)
        {
          *i = v75;
          *(a2 - 2) = v76;
          v80 = i[1];
          i[1] = *(a2 - 1);
          *(a2 - 1) = v80;
        }
      }

      return;
    }

LABEL_9:
    if (v10 <= 23)
    {
      v99 = i + 2;
      v101 = i == a2 || v99 == a2;
      if (a4)
      {
        if (v101)
        {
          return;
        }

        v102 = 0;
        v103 = i;
        while (2)
        {
          v104 = v103;
          v103 = v99;
          v105 = v104[2];
          v106 = *v104;
          if (v105 != *v104)
          {
            v107 = *(v105 + 24);
            v108 = *(v106 + 24);
            if (v107 == v108)
            {
              if (*(v105 + 32) >= *(v106 + 32))
              {
                goto LABEL_168;
              }
            }

            else if (v107 >= v108)
            {
              goto LABEL_168;
            }

            v109 = v104[3];
            v110 = v102;
            *v103 = 0;
            v103[1] = 0;
            while (1)
            {
              v111 = (i + v110);
              v112 = *(i + v110 + 8);
              *v111 = 0;
              v111[1] = 0;
              v113 = *(i + v110 + 24);
              v111[2] = v106;
              v111[3] = v112;
              if (v113)
              {
                std::__shared_weak_count::__release_shared[abi:nn200100](v113);
              }

              if (!v110)
              {
                break;
              }

              v114 = (i + v110);
              v106 = *(i + v110 - 16);
              if (v105 == v106)
              {
                goto LABEL_166;
              }

              v115 = *(v105 + 24);
              v116 = *(v106 + 24);
              v117 = v115 >= v116;
              if (v115 == v116)
              {
                v117 = *(v105 + 32) >= *(v106 + 32);
              }

              if (v117)
              {
                goto LABEL_166;
              }

              v110 -= 16;
            }

            v114 = i;
LABEL_166:
            v118 = v114[1];
            *v114 = v105;
            v114[1] = v109;
            if (v118)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v118);
            }
          }

LABEL_168:
          v99 = v103 + 2;
          v102 += 16;
          if (v103 + 2 == a2)
          {
            return;
          }

          continue;
        }
      }

      if (v101)
      {
        return;
      }

      while (2)
      {
        v185 = a1;
        a1 = v99;
        v186 = v185[2];
        v187 = *v185;
        if (v186 != *v185)
        {
          v188 = *(v186 + 24);
          v189 = *(v187 + 24);
          if (v188 == v189)
          {
            if (*(v186 + 32) >= *(v187 + 32))
            {
              goto LABEL_261;
            }
          }

          else if (v188 >= v189)
          {
            goto LABEL_261;
          }

          v190 = v185[3];
          *a1 = 0;
          a1[1] = 0;
          while (1)
          {
            v191 = v185;
            v192 = v185[1];
            *v191 = 0;
            v191[1] = 0;
            v193 = v191[3];
            v191[2] = v187;
            v191[3] = v192;
            if (v193)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v193);
            }

            v185 = v191 - 2;
            v187 = *(v191 - 2);
            if (v186 == v187)
            {
              break;
            }

            v194 = *(v186 + 24);
            v195 = *(v187 + 24);
            if (v194 == v195)
            {
              if (*(v186 + 32) >= *(v187 + 32))
              {
                break;
              }
            }

            else if (v194 >= v195)
            {
              break;
            }
          }

          v196 = v191[1];
          *v191 = v186;
          v191[1] = v190;
          if (v196)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v196);
          }
        }

LABEL_261:
        v99 = a1 + 2;
        if (a1 + 2 == a2)
        {
          return;
        }

        continue;
      }
    }

    if (!a3)
    {
      if (i == a2)
      {
        return;
      }

      v119 = v11 >> 1;
      v120 = v11 >> 1;
      while (2)
      {
        v121 = v120;
        if (v119 < v120)
        {
          goto LABEL_202;
        }

        v122 = (2 * v120) | 1;
        v123 = &a1[2 * v122];
        if (2 * v121 + 2 < v10)
        {
          v124 = v123[2];
          v125 = *v123;
          if (*v123 != v124)
          {
            v126 = *(v125 + 24);
            v127 = *(v124 + 24);
            if (v126 == v127)
            {
              if (*(v125 + 32) < *(v124 + 32))
              {
LABEL_177:
                v123 += 2;
                v122 = 2 * v121 + 2;
              }
            }

            else if (v126 < v127)
            {
              goto LABEL_177;
            }
          }
        }

        v128 = &a1[2 * v121];
        v129 = *v123;
        v130 = *v128;
        if (*v123 != *v128)
        {
          v131 = *(v129 + 24);
          v132 = *(v130 + 24);
          if (v131 == v132)
          {
            if (*(v129 + 32) < *(v130 + 32))
            {
              goto LABEL_202;
            }
          }

          else if (v131 < v132)
          {
            goto LABEL_202;
          }
        }

        v133 = v128[1];
        *v128 = 0;
        v128[1] = 0;
        v134 = *v123;
LABEL_184:
        v135 = v123;
        v136 = v123[1];
        *v135 = 0;
        v135[1] = 0;
        v137 = v128[1];
        *v128 = v134;
        v128[1] = v136;
        if (v137)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v137);
        }

        if (v119 < v122)
        {
LABEL_200:
          v147 = v135[1];
          *v135 = v130;
          v135[1] = v133;
          if (v147)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v147);
          }

LABEL_202:
          v120 = v121 - 1;
          if (v121)
          {
            continue;
          }

          while (2)
          {
            v148 = 0;
            v149 = a2;
            v151 = *a1;
            v150 = a1[1];
            *a1 = 0;
            a1[1] = 0;
            v152 = a1;
LABEL_207:
            v153 = &v152[2 * v148];
            v154 = v153 + 2;
            v155 = 2 * v148;
            v148 = (2 * v148) | 1;
            v156 = v155 + 2;
            if (v156 < v10)
            {
              v159 = v153[4];
              v157 = v153 + 4;
              v158 = v159;
              v160 = *(v157 - 2);
              if (v160 != v159)
              {
                v161 = *(v160 + 24);
                v162 = *(v158 + 24);
                if (v161 == v162)
                {
                  if (*(v160 + 32) < *(v158 + 32))
                  {
LABEL_211:
                    v154 = v157;
                    v148 = v156;
                  }
                }

                else if (v161 < v162)
                {
                  goto LABEL_211;
                }
              }
            }

            v163 = *v154;
            *v154 = 0;
            v154[1] = 0;
            v164 = v152[1];
            *v152 = v163;
            if (v164)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v164);
            }

            v152 = v154;
            if (v148 > ((v10 - 2) >> 1))
            {
              a2 -= 2;
              if (v154 == v149 - 2)
              {
                v177 = v154[1];
                *v154 = v151;
                v154[1] = v150;
                if (v177)
                {
                  goto LABEL_241;
                }
              }

              else
              {
                v165 = *(v149 - 1);
                *a2 = 0;
                *(v149 - 1) = 0;
                v166 = v154[1];
                *v154 = v165;
                if (v166)
                {
                  std::__shared_weak_count::__release_shared[abi:nn200100](v166);
                }

                v167 = *(v149 - 1);
                *(v149 - 2) = v151;
                *(v149 - 1) = v150;
                if (v167)
                {
                  std::__shared_weak_count::__release_shared[abi:nn200100](v167);
                }

                v168 = ((v154 + 2) - a1) >> 4;
                v169 = v168 < 2;
                v170 = v168 - 2;
                if (!v169)
                {
                  v171 = v170 >> 1;
                  v172 = &a1[2 * (v170 >> 1)];
                  v173 = *v172;
                  v174 = *v154;
                  if (*v172 != *v154)
                  {
                    v175 = *(v173 + 24);
                    v176 = *(v174 + 24);
                    if (v175 == v176)
                    {
                      if (*(v173 + 32) >= *(v174 + 32))
                      {
                        goto LABEL_242;
                      }
                    }

                    else if (v175 >= v176)
                    {
                      goto LABEL_242;
                    }

                    v178 = v154[1];
                    *v154 = 0;
                    v154[1] = 0;
                    v179 = *v172;
                    while (1)
                    {
                      v180 = v172;
                      v181 = v172[1];
                      *v180 = 0;
                      v180[1] = 0;
                      v182 = v154[1];
                      *v154 = v179;
                      v154[1] = v181;
                      if (v182)
                      {
                        std::__shared_weak_count::__release_shared[abi:nn200100](v182);
                      }

                      if (!v171)
                      {
                        break;
                      }

                      v171 = (v171 - 1) >> 1;
                      v172 = &a1[2 * v171];
                      v179 = *v172;
                      if (*v172 == v174)
                      {
                        break;
                      }

                      v183 = *(v179 + 24);
                      v184 = *(v174 + 24);
                      if (v183 == v184)
                      {
                        v154 = v180;
                        if (*(v179 + 32) >= *(v174 + 32))
                        {
                          break;
                        }
                      }

                      else
                      {
                        v154 = v180;
                        if (v183 >= v184)
                        {
                          break;
                        }
                      }
                    }

                    v177 = v180[1];
                    *v180 = v174;
                    v180[1] = v178;
                    if (v177)
                    {
LABEL_241:
                      std::__shared_weak_count::__release_shared[abi:nn200100](v177);
                    }
                  }
                }
              }

LABEL_242:
              v169 = v10-- <= 2;
              if (v169)
              {
                return;
              }

              continue;
            }

            goto LABEL_207;
          }
        }

        break;
      }

      v138 = 2 * v122;
      v122 = (2 * v122) | 1;
      v123 = &a1[2 * v122];
      v139 = v138 + 2;
      if (v139 < v10)
      {
        v140 = v123[2];
        v141 = *v123;
        if (*v123 != v140)
        {
          v142 = *(v141 + 24);
          v143 = *(v140 + 24);
          if (v142 == v143)
          {
            if (*(v141 + 32) < *(v140 + 32))
            {
LABEL_191:
              v123 += 2;
              v122 = v139;
            }
          }

          else if (v142 < v143)
          {
            goto LABEL_191;
          }
        }
      }

      v134 = *v123;
      v128 = v135;
      if (*v123 != v130)
      {
        v144 = *(v134 + 24);
        v145 = *(v130 + 24);
        v146 = v144 >= v145;
        if (v144 == v145)
        {
          v128 = v135;
          if (*(v134 + 32) < *(v130 + 32))
          {
            goto LABEL_200;
          }
        }

        else
        {
          v128 = v135;
          if (!v146)
          {
            goto LABEL_200;
          }
        }
      }

      goto LABEL_184;
    }

    v12 = v10 >> 1;
    v13 = &i[2 * (v10 >> 1)];
    if (v10 < 0x81)
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(&a1[2 * (v10 >> 1)], a1, v8);
    }

    else
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, &a1[2 * (v10 >> 1)], v8);
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1 + 2, v13 - 2, a2 - 4);
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1 + 4, &a1[2 * v12 + 2], a2 - 6);
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(v13 - 2, &a1[2 * (v10 >> 1)], &a1[2 * v12 + 2]);
      v14 = *a1;
      *a1 = *v13;
      *v13 = v14;
    }

    --a3;
    v15 = *a1;
    if ((a4 & 1) == 0)
    {
      v16 = *(a1 - 2);
      if (v16 == v15)
      {
        goto LABEL_71;
      }

      v17 = *(v16 + 24);
      v18 = *(v15 + 24);
      v19 = v17 >= v18;
      if (v17 == v18)
      {
        v19 = *(v16 + 32) >= *(v15 + 32);
      }

      if (v19)
      {
LABEL_71:
        v47 = a1[1];
        *a1 = 0;
        a1[1] = 0;
        v48 = *v8;
        if (v15 == *v8)
        {
          goto LABEL_82;
        }

        v49 = *(v15 + 24);
        v50 = *(v48 + 24);
        v51 = v49 >= v50;
        if (v49 == v50)
        {
          v51 = *(v15 + 32) >= *(v48 + 32);
        }

        if (v51)
        {
LABEL_82:
          for (i = a1 + 2; i < a2; i += 2)
          {
            v55 = *i;
            if (v15 != *i)
            {
              v56 = *(v15 + 24);
              v57 = *(v55 + 24);
              if (v56 == v57)
              {
                if (*(v15 + 32) < *(v55 + 32))
                {
                  break;
                }
              }

              else if (v56 < v57)
              {
                break;
              }
            }
          }
        }

        else
        {
          for (i = a1 + 2; ; i += 2)
          {
            v52 = *i;
            if (v15 != *i)
            {
              v53 = *(v52 + 24);
              v54 = v49 >= v53;
              if (v49 == v53)
              {
                v54 = *(v15 + 32) >= *(v52 + 32);
              }

              if (!v54)
              {
                break;
              }
            }
          }
        }

        v58 = a2;
        if (i < a2)
        {
          v58 = v8;
          if (v15 != v48)
          {
            v59 = *(v15 + 24);
            v58 = v8;
            do
            {
              v60 = *(v48 + 24);
              v61 = v59 >= v60;
              if (v59 == v60)
              {
                v61 = *(v15 + 32) >= *(v48 + 32);
              }

              if (v61)
              {
                break;
              }

              v62 = *(v58 - 2);
              v58 -= 2;
              v48 = v62;
            }

            while (v15 != v62);
          }
        }

        if (i < v58)
        {
          v63 = *i;
          v64 = *v58;
          do
          {
            *i = v64;
            *v58 = v63;
            v65 = i[1];
            i[1] = v58[1];
            v58[1] = v65;
            do
            {
              while (1)
              {
                do
                {
                  v66 = i[2];
                  i += 2;
                  v63 = v66;
                }

                while (v15 == v66);
                v67 = *(v15 + 24);
                v68 = *(v63 + 24);
                if (v67 == v68)
                {
                  break;
                }

                if (v67 < v68)
                {
                  goto LABEL_107;
                }
              }
            }

            while (*(v15 + 32) >= *(v63 + 32));
LABEL_107:
            while (1)
            {
              v69 = *(v58 - 2);
              v58 -= 2;
              v64 = v69;
              if (v15 == v69)
              {
                break;
              }

              v70 = *(v64 + 24);
              if (v67 == v70)
              {
                if (*(v15 + 32) >= *(v64 + 32))
                {
                  break;
                }
              }

              else if (v67 >= v70)
              {
                break;
              }
            }
          }

          while (i < v58);
        }

        v71 = i - 2;
        if (i - 2 != a1)
        {
          v72 = *v71;
          *v71 = 0;
          *(i - 1) = 0;
          v73 = a1[1];
          *a1 = v72;
          if (v73)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v73);
          }
        }

        a4 = 0;
        v74 = *(i - 1);
        *(i - 2) = v15;
        *(i - 1) = v47;
        if (v74)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v74);
          a4 = 0;
        }

        continue;
      }
    }

    v20 = a1[1];
    *a1 = 0;
    a1[1] = 0;
    v22 = a1 + 2;
    v21 = a1[2];
    if (v21 == v15)
    {
LABEL_28:
      if (v22 < a2)
      {
        while (1)
        {
          v26 = *v8;
          if (*v8 == v15)
          {
            if (v22 >= v8)
            {
              goto LABEL_46;
            }
          }

          else
          {
            v27 = *(v26 + 24);
            v28 = *(v15 + 24);
            if (v27 == v28)
            {
              if (v22 >= v8 || *(v26 + 32) < *(v15 + 32))
              {
                goto LABEL_46;
              }
            }

            else if (v22 >= v8 || v27 < v28)
            {
              goto LABEL_46;
            }
          }

          v8 -= 2;
        }
      }

      v8 = a2;
      goto LABEL_46;
    }

    v23 = *(v15 + 24);
    while (1)
    {
      v24 = *(v21 + 24);
      if (v24 == v23)
      {
        break;
      }

      if (v24 >= v23)
      {
        goto LABEL_27;
      }

LABEL_25:
      v25 = v22[2];
      v22 += 2;
      v21 = v25;
      if (v25 == v15)
      {
        goto LABEL_40;
      }
    }

    if (*(v21 + 32) < *(v15 + 32))
    {
      goto LABEL_25;
    }

LABEL_27:
    if (v22 - 2 == a1)
    {
      goto LABEL_28;
    }

LABEL_40:
    while (1)
    {
      v29 = *v8;
      if (*v8 != v15)
      {
        v30 = *(v29 + 24);
        v31 = v30 >= v23;
        if (v30 == v23)
        {
          v31 = *(v29 + 32) >= *(v15 + 32);
        }

        if (!v31)
        {
          break;
        }
      }

      v8 -= 2;
    }

LABEL_46:
    i = v22;
    if (v22 < v8)
    {
      v32 = *v8;
      i = v22;
      v33 = v8;
      do
      {
        *i = v32;
        *v33 = v21;
        v34 = i[1];
        i[1] = v33[1];
        v33[1] = v34;
        v35 = i[2];
        i += 2;
        v21 = v35;
        if (v35 == v15)
        {
          goto LABEL_57;
        }

        v36 = *(v15 + 24);
        do
        {
          v37 = *(v21 + 24);
          if (v37 == v36)
          {
            if (*(v21 + 32) >= *(v15 + 32))
            {
              goto LABEL_57;
            }
          }

          else if (v37 >= v36)
          {
            goto LABEL_57;
          }

          v38 = i[2];
          i += 2;
          v21 = v38;
        }

        while (v38 != v15);
        do
        {
          while (1)
          {
            do
            {
LABEL_57:
              v39 = *(v33 - 2);
              v33 -= 2;
              v32 = v39;
            }

            while (v39 == v15);
            v40 = *(v32 + 24);
            v41 = *(v15 + 24);
            if (v40 != v41)
            {
              break;
            }

            if (*(v32 + 32) < *(v15 + 32))
            {
              goto LABEL_60;
            }
          }
        }

        while (v40 >= v41);
LABEL_60:
        ;
      }

      while (i < v33);
    }

    v42 = i - 2;
    if (i - 2 != a1)
    {
      v43 = *v42;
      *v42 = 0;
      *(i - 1) = 0;
      v44 = a1[1];
      *a1 = v43;
      if (v44)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v44);
      }
    }

    v45 = *(i - 1);
    *(i - 2) = v15;
    *(i - 1) = v20;
    if (v45)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v45);
    }

    v19 = v22 >= v8;
    v8 = a2 - 2;
    if (v19)
    {
      v46 = std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *>(a1, i - 2);
      if (std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *>(i, a2))
      {
        a2 = i - 2;
        if (v46)
        {
          return;
        }

        goto LABEL_1;
      }

      if (!v46)
      {
        goto LABEL_70;
      }
    }

    else
    {
LABEL_70:
      std::__introsort<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,false>(a1, i - 2, a3, a4 & 1);
      a4 = 0;
    }
  }

  if (v10 != 3)
  {
    if (v10 == 4)
    {
      std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(i, i + 2, i + 4);
      v81 = *v8;
      v82 = i[4];
      if (*v8 != v82)
      {
        v83 = *(v81 + 24);
        v84 = *(v82 + 24);
        v85 = v83 >= v84;
        if (v83 == v84)
        {
          v85 = *(v81 + 32) >= *(v82 + 32);
        }

        if (!v85)
        {
          i[4] = v81;
          *(a2 - 2) = v82;
          v86 = i[5];
          i[5] = *(a2 - 1);
          *(a2 - 1) = v86;
          v87 = i[4];
          v88 = i[2];
          if (v87 != v88)
          {
            v89 = *(v87 + 24);
            v90 = *(v88 + 24);
            v91 = v89 >= v90;
            if (v89 == v90)
            {
              v91 = *(v87 + 32) >= *(v88 + 32);
            }

            if (!v91)
            {
              v92 = i[3];
              v93 = i[5];
              i[2] = v87;
              i[3] = v93;
              i[4] = v88;
              i[5] = v92;
              v94 = *i;
              if (v87 != *i)
              {
                v95 = *(v87 + 24);
                v96 = *(v94 + 24);
                v97 = v95 >= v96;
                if (v95 == v96)
                {
                  v97 = *(v87 + 32) >= *(v94 + 32);
                }

                if (!v97)
                {
                  v98 = i[1];
                  *i = v87;
                  i[1] = v93;
                  i[2] = v94;
                  i[3] = v98;
                }
              }
            }
          }
        }
      }

      return;
    }

    if (v10 == 5)
    {

      std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(i, i + 2, i + 4, i + 6, v8);
      return;
    }

    goto LABEL_9;
  }

  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(i, i + 2, v8);
}

BOOL md::ARWalkingLabeler::doesStagingLabelIntersectWithWorld(md::ARWalkingLabeler *this, md::Label *a2, int a3, md::Label *a4)
{
  v64 = *MEMORY[0x1E69E9840];
  v52 = a4;
  v53 = a2;
  v47 = v51;
  v48 = v51;
  v49 = v51;
  v50 = 2;
  v42 = v46;
  v43 = v46;
  v44 = v46;
  v45 = 2;
  geo::small_vector_base<md::Label *>::push_back(&v42, &v53);
  if (a4)
  {
    geo::small_vector_base<md::Label *>::push_back(&v42, &v52);
  }

  v7 = v42;
  v8 = v43;
  if (v42 == v43)
  {
    v19 = v48;
  }

  else
  {
    v9 = this + 1816;
    do
    {
      v10 = *v7;
      v54 = *(*v7 + 616);
      v55 = *(v10 + 632);
      if (a3)
      {
        v11 = geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::find(v9, v10);
        if (v9 == v11)
        {
          md::ARWalkingLabelWorldIntersector::resolveWorldPoint(this + 1728, &v54);
          *&v54 = v13;
          *(&v54 + 1) = v14;
          v55 = v15;
          *&v61[8] = v54;
          v62 = v15;
          *v61 = a2;
          v63 = 0;
          geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::insert(v9, v61);
        }

        for (i = 0; i != 24; i += 8)
        {
          *(&v54 + i) = *(v11 + 24 + i);
        }
      }

      v16 = v48;
      v17 = 1 - 0x5555555555555555 * ((v48 - v47) >> 3);
      if (v50 < v17)
      {
        geo::small_vector_base<gm::Matrix<double,3,1>>::grow(&v47, v17);
        v16 = v48;
      }

      *v16 = v54;
      *(v16 + 2) = v55;
      v18 = v48 + 24;
      v48 += 24;
      ++v7;
    }

    while (v7 != v8);
    v19 = v18;
  }

  v20 = v47;
  v21 = this;
  if (v47 == v19)
  {
    v38 = 0;
  }

  else
  {
    v22 = (this + 1728);
    v40 = v19;
    do
    {
      if (*v22 && *(this + 218) | *(this + 219) | *(this + 220))
      {
        ++*(v21 + 451);
        if (*(v21 + 1792) == 1)
        {
          v23 = *(v21 + 221);
          v24 = *(v21 + 222);
          v25 = *(v21 + 223);
        }

        else
        {
          md::ARWalkingLabelWorldIntersector::resolveWorldPoint(v22, this + 109);
          v27 = *(v21 + 1792);
          *(v21 + 221) = v23;
          *(v21 + 222) = v24;
          *(v21 + 223) = v25;
          if ((v27 & 1) == 0)
          {
            *(v21 + 1792) = 1;
          }

          v22 = (this + 1728);
        }

        v28 = 0;
        *&v58 = v23;
        *(&v58 + 1) = v24;
        *&v59 = v25;
        do
        {
          *&v61[v28] = *&v20[v28] - *(&v58 + v28);
          v28 += 8;
        }

        while (v28 != 24);
        v54 = v58;
        v55 = v59;
        v56 = *v61;
        v57 = *&v61[16];
        if (*(v21 + 1800))
        {
          goto LABEL_29;
        }

        v29 = *(v21 + 216);
        if (*(v29 + 128))
        {
          v30 = *(v29 + 16);
          if (v30)
          {
            if (!(v30 >> 60))
            {
              std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<md::ARBuildingTileData *,double>>>(v30);
            }

            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          v31 = *v29;
          if (*v29 != v29 + 8)
          {
            do
            {
              v32 = gdc::Context::context<md::components::SharedTransformData>(*(v31[4] + 792));
              *v61 = 0;
              *&v58 = 0;
              if (gm::Ray<double,3>::segmentIntersectsBox(&v54, v32 + 17, v61, &v58, 0.000001, 1.0))
              {
                std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<md::ARBuildingTileData *,double>>>(1uLL);
              }

              v33 = v31[1];
              if (v33)
              {
                do
                {
                  v34 = v33;
                  v33 = *v33;
                }

                while (v33);
              }

              else
              {
                do
                {
                  v34 = v31[2];
                  v35 = *v34 == v31;
                  v31 = v34;
                }

                while (!v35);
              }

              v31 = v34;
            }

            while (v34 != (v29 + 8));
          }

          std::__introsort<std::_ClassicAlgPolicy,md::ARWorldIntersector::intersectBuildings(gm::LineSegment<double,3> const&)::$_0 &,std::pair<md::ARBuildingTileData *,double> *,false>(0, 0, 0, 1);
          v58 = 0u;
          v59 = 0u;
          v60 = 1065353216;
          v21 = this;
          std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v58);
          v22 = (this + 1728);
        }

        if (*(v29 + 129) != 1)
        {
LABEL_29:
          v26 = 2;
        }

        else
        {
          v37 = *(v29 + 104);
          v36 = *(v29 + 112);
          while (1)
          {
            if (v37 == v36)
            {
              v26 = 2;
              goto LABEL_55;
            }

            *v61 = 0;
            *&v58 = 0;
            if (gm::Ray<double,3>::segmentIntersectsBox(&v54, v37, v61, &v58, 0.000001, 1.0))
            {
              break;
            }

            v37 += 6;
          }

          v26 = 1;
LABEL_55:
          v21 = this;
          v22 = (this + 1728);
        }

        v19 = v40;
      }

      else
      {
        v26 = 2;
      }

      if (v26 != 2)
      {
        break;
      }

      v20 += 24;
    }

    while (v20 != v19);
    v38 = v26 < 2;
  }

  if (v42 != v44)
  {
    free(v42);
  }

  if (v47 != v49)
  {
    free(v47);
  }

  return v38;
}

void sub_1B32EEC60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, void *a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, char a61)
{
  if (a17 != a19)
  {
    free(a17);
  }

  if (a23 != a25)
  {
    free(a23);
  }

  _Unwind_Resume(exception_object);
}

void md::ARWalkingLabelWorldIntersector::resolveWorldPoint(uint64_t a1, __int128 *a2)
{
  v21 = *MEMORY[0x1E69E9840];
  v3 = *a1;
  if (*a1)
  {
    ++*(a1 + 80);
    v20 = *(a2 + 2);
    v19 = *a2;
    v4 = v3[2];
    if (v4)
    {
      if (!(v4 >> 61))
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<std::unique_ptr<std::array<unsigned short,128ul>>>>(v4);
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v5 = *v3;
    if (*v3 == v3 + 1)
    {
      v16 = 0u;
      v17 = 0u;
      v18 = 1065353216;
    }

    else
    {
      do
      {
        v6 = gdc::Context::context<md::components::SharedTransformData>(*(v5[4] + 792));
        if (*a2 >= v6[17] && *a2 < v6[20])
        {
          v7 = v6 + 21;
          v8 = -2;
          v9 = a2 + 1;
          do
          {
            if (!v8)
            {
              goto LABEL_14;
            }

            v10 = v8;
            v11 = *v9;
            if (*v9 < *(v7 - 3))
            {
              break;
            }

            v12 = *v7++;
            ++v8;
            ++v9;
          }

          while (v11 < v12);
          if (v10 < 0xFFFFFFFFFFFFFFFELL)
          {
LABEL_14:
            std::__allocate_at_least[abi:nn200100]<std::allocator<std::unique_ptr<std::array<unsigned short,128ul>>>>(1uLL);
          }
        }

        v13 = v5[1];
        if (v13)
        {
          do
          {
            v14 = v13;
            v13 = *v13;
          }

          while (v13);
        }

        else
        {
          do
          {
            v14 = v5[2];
            v15 = *v14 == v5;
            v5 = v14;
          }

          while (!v15);
        }

        v5 = v14;
      }

      while (v14 != v3 + 1);
      v16 = 0u;
      v17 = 0u;
      v18 = 1065353216;
    }

    std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(&v16);
  }
}

void geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::insert(uint64_t a1, unint64_t *a2)
{
  if (std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::zone_mallocator>>::find<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>((a1 + 24), *a2))
  {
    operator new();
  }

  operator new();
}

uint64_t *std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  v3 = *a2;
  v4 = *result;
  if (*a2 != *result)
  {
    v5 = *(v3 + 24);
    v6 = *(v4 + 24);
    if (v5 == v6)
    {
      if (*(v3 + 32) < *(v4 + 32))
      {
        goto LABEL_4;
      }
    }

    else if (v5 < v6)
    {
LABEL_4:
      v7 = *a3;
      if (*a3 != v3)
      {
        v8 = *(v7 + 24);
        if (v8 == v5)
        {
          if (*(v7 + 32) < *(v3 + 32))
          {
            goto LABEL_7;
          }
        }

        else if (v8 < v5)
        {
LABEL_7:
          *result++ = v7;
          *a3 = v4;
          v9 = a3 + 1;
LABEL_25:
          v13 = v9;
          goto LABEL_26;
        }
      }

      *result = v3;
      *a2 = v4;
      v20 = result[1];
      result[1] = a2[1];
      a2[1] = v20;
      v21 = *a3;
      v22 = *a2;
      if (*a3 != *a2)
      {
        v23 = *(v21 + 24);
        v24 = *(v22 + 24);
        v25 = v23 >= v24;
        if (v23 == v24)
        {
          v25 = *(v21 + 32) >= *(v22 + 32);
        }

        if (!v25)
        {
          *a2 = v21;
          *a3 = v22;
          v9 = a3 + 1;
          result = a2 + 1;
          goto LABEL_25;
        }
      }

      return result;
    }
  }

  v10 = *a3;
  if (*a3 == v3)
  {
    return result;
  }

  v11 = *(v10 + 24);
  v12 = *(v3 + 24);
  if (v11 == v12)
  {
    if (*(v10 + 32) >= *(v3 + 32))
    {
      return result;
    }
  }

  else if (v11 >= v12)
  {
    return result;
  }

  *a2 = v10;
  *a3 = v3;
  v13 = a2 + 1;
  v14 = a2[1];
  a2[1] = a3[1];
  a3[1] = v14;
  v15 = *a2;
  v16 = *result;
  if (*a2 != *result)
  {
    v17 = *(v15 + 24);
    v18 = *(v16 + 24);
    v19 = v17 >= v18;
    if (v17 == v18)
    {
      v19 = *(v15 + 32) >= *(v16 + 32);
    }

    if (!v19)
    {
      *result++ = v15;
      *a2 = v16;
LABEL_26:
      v26 = *result;
      *result = *v13;
      *v13 = v26;
    }
  }

  return result;
}

uint64_t *std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  result = std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, a2, a3);
  v11 = *a4;
  v12 = *a3;
  if (*a4 != *a3)
  {
    v13 = *(v11 + 24);
    v14 = *(v12 + 24);
    if (v13 == v14)
    {
      if (*(v11 + 32) >= *(v12 + 32))
      {
        goto LABEL_15;
      }
    }

    else if (v13 >= v14)
    {
      goto LABEL_15;
    }

    *a3 = v11;
    *a4 = v12;
    v15 = a3[1];
    a3[1] = a4[1];
    a4[1] = v15;
    v16 = *a3;
    v17 = *a2;
    if (*a3 != *a2)
    {
      v18 = *(v16 + 24);
      v19 = *(v17 + 24);
      v20 = v18 >= v19;
      if (v18 == v19)
      {
        v20 = *(v16 + 32) >= *(v17 + 32);
      }

      if (!v20)
      {
        *a2 = v16;
        *a3 = v17;
        v21 = a2[1];
        a2[1] = a3[1];
        a3[1] = v21;
        v22 = *a2;
        v23 = *a1;
        if (*a2 != *a1)
        {
          v24 = *(v22 + 24);
          v25 = *(v23 + 24);
          v26 = v24 >= v25;
          if (v24 == v25)
          {
            v26 = *(v22 + 32) >= *(v23 + 32);
          }

          if (!v26)
          {
            *a1 = v22;
            *a2 = v23;
            v27 = a1[1];
            a1[1] = a2[1];
            a2[1] = v27;
          }
        }
      }
    }
  }

LABEL_15:
  v28 = *a5;
  v29 = *a4;
  if (*a5 == *a4)
  {
    return result;
  }

  v30 = *(v28 + 24);
  v31 = *(v29 + 24);
  if (v30 == v31)
  {
    if (*(v28 + 32) >= *(v29 + 32))
    {
      return result;
    }
  }

  else if (v30 >= v31)
  {
    return result;
  }

  *a4 = v28;
  *a5 = v29;
  v32 = a4[1];
  a4[1] = a5[1];
  a5[1] = v32;
  v33 = *a4;
  v34 = *a3;
  if (*a4 != *a3)
  {
    v35 = *(v33 + 24);
    v36 = *(v34 + 24);
    v37 = v35 >= v36;
    if (v35 == v36)
    {
      v37 = *(v33 + 32) >= *(v34 + 32);
    }

    if (!v37)
    {
      *a3 = v33;
      *a4 = v34;
      v38 = a3[1];
      a3[1] = a4[1];
      a4[1] = v38;
      v39 = *a3;
      v40 = *a2;
      if (*a3 != *a2)
      {
        v41 = *(v39 + 24);
        v42 = *(v40 + 24);
        v43 = v41 >= v42;
        if (v41 == v42)
        {
          v43 = *(v39 + 32) >= *(v40 + 32);
        }

        if (!v43)
        {
          *a2 = v39;
          *a3 = v40;
          v44 = a2[1];
          a2[1] = a3[1];
          a3[1] = v44;
          v45 = *a2;
          v46 = *a1;
          if (*a2 != *a1)
          {
            v47 = *(v45 + 24);
            v48 = *(v46 + 24);
            v49 = v47 >= v48;
            if (v47 == v48)
            {
              v49 = *(v45 + 32) >= *(v46 + 32);
            }

            if (!v49)
            {
              *a1 = v45;
              *a2 = v46;
              v50 = a1[1];
              a1[1] = a2[1];
              a2[1] = v50;
            }
          }
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *>(uint64_t *a1, uint64_t *a2)
{
  v4 = (a2 - a1) >> 4;
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a2 - 2);
        break;
      case 4:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a1 + 4);
        v29 = *(a2 - 2);
        v30 = a1[4];
        if (v29 != v30)
        {
          v31 = *(v29 + 24);
          v32 = *(v30 + 24);
          v33 = v31 >= v32;
          if (v31 == v32)
          {
            v33 = *(v29 + 32) >= *(v30 + 32);
          }

          if (!v33)
          {
            a1[4] = v29;
            *(a2 - 2) = v30;
            v34 = a1[5];
            a1[5] = *(a2 - 1);
            *(a2 - 1) = v34;
            v35 = a1[4];
            v36 = a1[2];
            if (v35 != v36)
            {
              v37 = *(v35 + 24);
              v38 = *(v36 + 24);
              v39 = v37 >= v38;
              if (v37 == v38)
              {
                v39 = *(v35 + 32) >= *(v36 + 32);
              }

              if (!v39)
              {
                v40 = a1[3];
                v41 = a1[5];
                a1[2] = v35;
                a1[3] = v41;
                a1[4] = v36;
                a1[5] = v40;
                v42 = *a1;
                if (v35 != *a1)
                {
                  v43 = *(v35 + 24);
                  v44 = *(v42 + 24);
                  v45 = v43 >= v44;
                  if (v43 == v44)
                  {
                    v45 = *(v35 + 32) >= *(v42 + 32);
                  }

                  if (!v45)
                  {
                    v46 = a1[1];
                    *a1 = v35;
                    a1[1] = v41;
                    a1[2] = v42;
                    a1[3] = v46;
                  }
                }
              }
            }
          }
        }

        return 1;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
        break;
      default:
        goto LABEL_14;
    }

    return 1;
  }

  if (v4 < 2)
  {
    return 1;
  }

  if (v4 == 2)
  {
    v5 = *(a2 - 2);
    v6 = *a1;
    if (v5 != *a1)
    {
      v7 = *(v5 + 24);
      v8 = *(v6 + 24);
      v9 = v7 >= v8;
      if (v7 == v8)
      {
        v9 = *(v5 + 32) >= *(v6 + 32);
      }

      if (!v9)
      {
        *a1 = v5;
        *(a2 - 2) = v6;
        v10 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v10;
      }
    }

    return 1;
  }

LABEL_14:
  v11 = a1 + 4;
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,md::ARWalkingLabeler::deduplicateAndIntersectLabels(geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>,BOOL,geo::slice<std::__wrap_iter<std::shared_ptr<md::Label> *>>&)::$_1 &,std::shared_ptr<md::Label> *,0>(a1, a1 + 2, a1 + 4);
  v12 = a1 + 6;
  if (a1 + 6 == a2)
  {
    return 1;
  }

  v13 = 0;
  for (i = 32; ; i += 16)
  {
    v15 = *v12;
    v16 = *v11;
    if (*v12 == *v11)
    {
      goto LABEL_34;
    }

    v17 = *(v15 + 24);
    v18 = *(v16 + 24);
    if (v17 == v18)
    {
      break;
    }

    if (v17 < v18)
    {
      goto LABEL_21;
    }

LABEL_34:
    v11 = v12;
    v12 += 2;
    if (v12 == a2)
    {
      return 1;
    }
  }

  if (*(v15 + 32) >= *(v16 + 32))
  {
    goto LABEL_34;
  }

LABEL_21:
  v19 = v12[1];
  v20 = i;
  *v12 = 0;
  v12[1] = 0;
  while (1)
  {
    v21 = (a1 + v20);
    v22 = *(a1 + v20 + 8);
    *v21 = 0;
    v21[1] = 0;
    v23 = *(a1 + v20 + 24);
    v21[2] = v16;
    v21[3] = v22;
    if (v23)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v23);
    }

    if (!v20)
    {
      break;
    }

    v24 = (a1 + v20);
    v16 = *(a1 + v20 - 16);
    if (v15 == v16)
    {
      goto LABEL_31;
    }

    v25 = *(v15 + 24);
    v26 = *(v16 + 24);
    v27 = v25 >= v26;
    if (v25 == v26)
    {
      v27 = *(v15 + 32) >= *(v16 + 32);
    }

    if (v27)
    {
      goto LABEL_31;
    }

    v20 -= 16;
  }

  v24 = a1;
LABEL_31:
  v28 = v24[1];
  *v24 = v15;
  v24[1] = v19;
  if (v28)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v28);
  }

  if (++v13 != 8)
  {
    goto LABEL_34;
  }

  return v12 + 2 == a2;
}

id GEOGetVectorKitARWalkingLabelerLog(void)
{
  if (GEOGetVectorKitARWalkingLabelerLog(void)::onceToken != -1)
  {
    dispatch_once(&GEOGetVectorKitARWalkingLabelerLog(void)::onceToken, &__block_literal_global_48173);
  }

  v1 = GEOGetVectorKitARWalkingLabelerLog(void)::log;

  return v1;
}

void ___ZL34GEOGetVectorKitARWalkingLabelerLogv_block_invoke()
{
  v0 = os_log_create("com.apple.VectorKit", "ARWalkingLabeler");
  v1 = GEOGetVectorKitARWalkingLabelerLog(void)::log;
  GEOGetVectorKitARWalkingLabelerLog(void)::log = v0;
}

void md::ARWalkingLabeler::debugDraw(md::ARWalkingLabeler *this, NSMutableString *a2, md::DebugConsole *a3)
{
  v240 = *MEMORY[0x1E69E9840];
  v188 = a2;
  md::StandardLabeler::debugDraw(this, v188, a3);
  v194 = this;
  if (*(this + 404) == 1)
  {
    v5 = *(this + 253);
    v6 = *(v194 + 254);
    if (v5 != v6)
    {
      __asm { FMOV            V0.2D, #1.0 }

      v197 = _Q0;
      do
      {
        v12 = *(v5 + 16);
        v13 = *(v5 + 24);
        while (v12 != v13)
        {
          if (*(v12 + 106) != 1)
          {
            goto LABEL_20;
          }

          v14 = *(v12 + 16);
          *(a3 + 24) = -256;
          if (isStagingLabelVisible(*(*(v194 + 3) + 424), v14))
          {
            v15 = *(v14 + 36);
            if (v15)
            {
              (*(*v15 + 784))(v15, *(v194 + 3), a3);
            }

            *(a3 + 24) = -16711936;
LABEL_12:
            if ((*(*v14 + 48))(v14, *(v194 + 3) + 1168))
            {
              v16 = *(v14 + 36);
              if (v16)
              {
                (*(*v16 + 792))(v16, *(v194 + 3), a3);
              }
            }

            goto LABEL_15;
          }

          *(a3 + 24) = -16711936;
          if (v14)
          {
            goto LABEL_12;
          }

LABEL_15:
          v17 = 0;
          *(a3 + 24) = -16776961;
          v18 = *(v194 + 3);
          v19 = (v18 + 1296);
          do
          {
            v20 = 0;
            v21 = 0.0;
            v22 = v19;
            do
            {
              v23 = *v22;
              v22 += 4;
              v21 = v21 + *(v14 + v20 + 408) * v23;
              v20 += 8;
            }

            while (v20 != 24);
            *&v223[0].i64[v17] = *(v18 + 1296 + 8 * v17 + 96) + v21;
            ++v17;
            ++v19;
          }

          while (v17 != 4);
          v24 = *(v18 + 176) * 3.0;
          *(a3 + 1) = vcvt_f32_f64(vmulq_f64(v223[0], vdivq_f64(v197, vdupq_lane_s64(v223[1].i64[1], 0))));
          ggl::DebugConsole::drawCircleWithFill(a3, v24);
LABEL_20:
          v12 += 128;
        }

        v5 += 40;
      }

      while (v5 != v6);
    }
  }

  v25 = v194;
  if (*(v194 + 403) == 1)
  {
    v26 = *(v194 + 3);
    v27 = exp(*(v26 + 576) * 6.28318531 + -3.14159265);
    v28 = atan(v27);
    v29 = geo::WGS84::unitsPerMeterAtLatitude<geo::Degrees,double>(v28 * 114.591559 + -90.0);
    v30 = *(v26 + 1500);
    v31 = *(v26 + 1496);
    v32 = *(v26 + 176);
    k = +[VKDebugSettings sharedSettings];
    [k arDebugMiniMapMapRectSize];
    v35 = v34;
    v198 = v29;
    [k arDebugMiniMapScreenRectXOffset];
    v37 = v36;
    v38 = *(v26 + 1496);
    [k arDebugMiniMapScreenRectYOffset];
    v40 = v39;
    LODWORD(v29) = *(v26 + 1500);
    [k arDebugMiniMapScreenRectSize];
    v41 = (v26 + 568);
    v42 = fminf(v30, v31);
    v43 = v32;
    v45 = v44 * v42;
    v212[0] = v38 * v37;
    v212[1] = *&v29 * v40;
    v212[2] = v45 + (v38 * v37);
    v212[3] = v45 + (*&v29 * v40);
    v223[0] = *(v26 + 568);
    v205[0] = v35;
    v232.f64[0] = v35;
    md::DebugConsoleMapRect::DebugConsoleMapRect(&v207, a3, v212, v223, v205, v232.f64);
    *(a3 + 24) = 0x80000000;
    v46 = v208.f32[0];
    *(a3 + 1) = v208;
    ggl::DebugConsole::drawRectangleWithFill(a3, &v209, v46);
    v206 = -16711681;
    memset(v223, 0, 24);
    if (*(v194 + 259) | *(v194 + 260) | *(v194 + 261))
    {
      v48.n128_u64[0] = *(v194 + 259);
      v49 = 1.5;
      if (vabdd_f64(v41->n128_f64[0], v48.n128_f64[0]) >= v198 * 0.25)
      {
LABEL_30:
        v48.n128_u64[1] = *(v194 + 260);
        v206 = -16711936;
        v53 = *(*(v194 + 3) + 176);
        v223[0].i32[0] = -16711936;
        md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, v53, v223, 1, v48);
        v52 = 0;
      }

      else
      {
        v50 = 0;
        while (v50 != 2)
        {
          v51 = v50++;
          if (vabdd_f64(*(v26 + 576 + 8 * v51), *(v194 + v51 + 260)) >= v198 * 0.25)
          {
            if (v51 <= 1)
            {
              goto LABEL_30;
            }

            break;
          }
        }

        v52 = 1;
      }
    }

    else
    {
      v52 = 1;
      v49 = 1.5;
    }

    v47.f64[0] = v43 * 3.0;
    v186 = v47;
    v54 = v43 + v43;
    v55 = v43 * v49;
    md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, *(*(v194 + 3) + 176), &v206, v52, *v41);
    v56 = 0;
    v57 = &v232;
    v58 = (v26 + 1168);
    do
    {
      v59 = 0;
      v60 = v58;
      do
      {
        v61 = *v60;
        v60 += 4;
        v57->f64[v59++] = v61;
      }

      while (v59 != 4);
      ++v56;
      v57 += 2;
      ++v58;
    }

    while (v56 != 4);
    v62 = 0;
    v225 = vaddq_f64(v232, v238);
    v226 = vaddq_f64(v233, v239);
    v227 = vsubq_f64(v238, v232);
    v228 = vsubq_f64(v239, v233);
    v223[4] = vaddq_f64(v234, v238);
    *v224 = vaddq_f64(v235, v239);
    *&v224[16] = vsubq_f64(v238, v234);
    *&v224[32] = vsubq_f64(v239, v235);
    v223[0] = v236;
    v223[1] = v237;
    v223[2] = vsubq_f64(v238, v236);
    v223[3] = vsubq_f64(v239, v237);
    do
    {
      v63 = 0;
      v64 = &v223[2 * v62];
      v65 = v64[1].i64[0];
      v220 = *v64;
      *&v221 = v65;
      v66 = 0.0;
      do
      {
        v66 = v66 + *&v220.i64[v63] * *&v220.i64[v63];
        ++v63;
      }

      while (v63 != 3);
      v67 = 0;
      v68 = 1.0 / sqrt(v66);
      do
      {
        *(&v201 + v67 * 8) = *&v220.i64[v67] * v68;
        ++v67;
      }

      while (v67 != 3);
      v69 = &v205[4 * v62];
      v70 = v202;
      v71 = *&v64[1].i64[1] * v68;
      *v69 = v201;
      *(v69 + 2) = v70;
      v69[3] = v71;
      ++v62;
    }

    while (v62 != 6);
    geo::Frustum<double>::calculateCorners(v205, (v26 + 1168), 0.0);
    geo::Frustum<double>::edges(v223, v205);
    for (i = 0; i != 36; i += 3)
    {
      v73 = 0;
      v74 = v223[i];
      do
      {
        v232.f64[v73] = *&v223[i + 1].i64[v73 + 1] + *&v223[i].i64[v73];
        ++v73;
      }

      while (v73 != 3);
      v75 = vsubq_f64(v232, v74);
      v232 = v74;
      v233 = v75;
      LODWORD(v201) = -16711936;
      md::DebugConsoleMapRect::drawWorldSegment(&v207, &v232, &v201);
    }

    v76 = *(v194 + 257);
    v199 = k;
    if (v76)
    {
      v77 = [v76 routeInfo];
      v189 = [v77 route];

      v203 = 0u;
      v204 = 0u;
      v201 = 0u;
      v202 = 0u;
      obj = [v189 sections];
      v78 = [obj countByEnumeratingWithState:&v201 objects:&v232 count:16];
      if (v78)
      {
        v79 = *v202;
        v190 = *v202;
        do
        {
          v80 = 0;
          v192 = v78;
          do
          {
            if (*v202 != v79)
            {
              objc_enumerationMutation(obj);
            }

            v81 = *(*(&v201 + 1) + 8 * v80);
            if ([v81 pointCount] >= 2)
            {
              v221 = 0u;
              v222 = 0u;
              v220 = 0u;
              if (v81)
              {
                [v81 bounds];
                v82 = *&v220.i64[1];
                v83 = *v220.i64;
                v84 = *&v222;
                v85 = *(&v221 + 1);
              }

              else
              {
                v85 = 0.0;
                v84 = 0.0;
                v82 = 0.0;
                v83 = 0.0;
              }

              v86 = 0;
              v87 = *(MEMORY[0x1E69A1688] + 16);
              v88 = *(MEMORY[0x1E69A1688] + 24);
              v89 = v83 / v87;
              v90 = (v84 + v82) / v88;
              v91 = v82 / v88;
              v216 = v83 / v87;
              v217 = 1.0 - v90;
              v92 = (v85 + v83) / v87;
              v218 = *&v92;
              v219 = 1.0 - v91;
              v93 = &v216;
              v94 = 1;
              while (v211[0].f64[v86] > *v93 && v210.f64[v86] < *&(&v218)[v86])
              {
                v95 = v94;
                v94 = 0;
                v93 = &v217;
                v86 = 1;
                if ((v95 & 1) == 0)
                {
                  memset(&v223[0].u64[1], 0, 72);
                  *v223[0].i64 = v92 - v89;
                  *&v223[2].i64[1] = v90 - v91;
                  *v224 = COERCE_UNSIGNED_INT64(v92 - v89);
                  *&v224[16] = v83 / v87;
                  *&v224[24] = 1.0 - v90;
                  *&v224[32] = xmmword_1B33B0740;
                  v96 = [v81 points];
                  for (j = 1; j < [v81 pointCount]; ++j)
                  {
                    v229 = vcvtq_f64_f32(*(v96 + 12));
                    v230 = 0.0;
                    v98 = gm::Matrix<double,4,4>::multiplyHomogeneous<int,void>(v223[0].i64, &v229);
                    v100 = v99;
                    v229 = vcvtq_f64_f32(*v96);
                    v230 = 0.0;
                    v101 = gm::Matrix<double,4,4>::multiplyHomogeneous<int,void>(v223[0].i64, &v229);
                    LODWORD(v214[0]) = -1;
                    v229.f64[0] = v101;
                    v229.f64[1] = v102;
                    v230 = v98 - v101;
                    v231 = v100 - v102;
                    md::DebugConsoleMapRect::drawWorldSegment(&v207, &v229, v214);
                    v96 += 12;
                    k = v199;
                  }

                  v79 = v190;
                  v78 = v192;
                  break;
                }
              }
            }

            ++v80;
          }

          while (v80 != v78);
          v78 = [obj countByEnumeratingWithState:&v201 objects:&v232 count:16];
        }

        while (v78);
      }

      v25 = v194;
    }

    v103 = *(v25 + 253);
    __asm { FMOV            V0.2D, #0.5 }

    v187 = _Q0;
    if (v103 != *(v25 + 254))
    {
      v105 = *(v25 + 254);
      _Q0.f64[0] = 0.0;
      v106 = vdupq_lane_s64(*&v186.f64[0], 0);
      v107.i64[1] = v106.i64[1];
      v107.i64[0] = 0;
      v108 = v194 + 2096;
      v109 = vbslq_s8(vdupq_lane_s64(vcgeq_f64(v186, _Q0).i64[0], 0), v106, v107);
      v110 = (v43 * 10.0);
      v111 = vmulq_f64(vbslq_s8(vdupq_lane_s64(vcgtq_f64(_Q0, v186).i64[0], 0), v109.u64[0], v109), v187);
      v191 = vcvt_hight_f32_f64(vcvt_f32_f64(v111), v111);
      *&v111.f64[0] = 4286578816;
      *obja = v111;
      v193 = 4286578816;
      do
      {
        v112 = v103[2];
        v113 = v103[3];
        while (v112 != v113)
        {
          v114 = geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::find(v108, *(v112 + 16));
          *(&v116 + 1) = obja[1];
          *&v116 = obja[0] & 0xFFFFFFFFFFFFFF00;
          if (v108 == v114)
          {
            goto LABEL_77;
          }

          v117 = *(*(v112 + 16) + 224) * 0.2;
          *&v115 = *(v114 + 24);
          *obja = v115;
          if (vabdd_f64(*(v112 + 40), *&v115) < v117)
          {
            v118 = (v114 + 32);
            v119 = 6;
            while (v119 != 8)
            {
              v120 = v119;
              v121 = *v118++;
              v122 = vabdd_f64(*(v112 + 8 * v119++), v121);
              if (v122 >= v117)
              {
                if ((v120 - 6) <= 1)
                {
                  goto LABEL_78;
                }

                break;
              }
            }

LABEL_77:
            v123 = 0;
            *obja = v116;
            goto LABEL_79;
          }

LABEL_78:
          v193 = *(v114 + 32);
          v123 = 1;
LABEL_79:
          v124 = *(v112 + 104);
          if (v124 > 0x1C)
          {
            if (*(v112 + 104) > 0x20u)
            {
              if (v124 == 37)
              {
                v220.i32[0] = -1;
                goto LABEL_96;
              }

              if (v124 != 33)
              {
LABEL_94:
                v125 = -16777216;
                goto LABEL_95;
              }

LABEL_91:
              v125 = -16776961;
              goto LABEL_95;
            }

            if (v124 == 29)
            {
              goto LABEL_91;
            }

            if (v124 != 32)
            {
              goto LABEL_94;
            }

            v125 = -8388480;
          }

          else if (v124 - 22 >= 3)
          {
            if (v124 == 3)
            {
              v125 = -16711681;
            }

            else
            {
              if (v124 != 21)
              {
                goto LABEL_94;
              }

              v125 = -256;
            }
          }

          else
          {
            v125 = -16744193;
          }

LABEL_95:
          v220.i32[0] = v125;
LABEL_96:
          if ((*(**v103 + 264))(*v103) == 26)
          {
            *v126.i64 = md::DebugConsoleMapRect::worldPointToPixel(&v207, *(v112 + 40));
            v126.i32[1] = v127;
            v128 = vdupq_lane_s64(v126.i64[0], 0);
            v126.i64[0] = vsubq_f32(v126, v191).u64[0];
            v129 = vaddq_f32(v128, v191);
            v126.i64[1] = v129.i64[1];
            v223[0] = v126;
            md::DebugConsoleMapRect::drawPixelRect(&v207, v223, &v220, v123 ^ 1, v126, v129);
            if (((v123 ^ 1) & 1) == 0)
            {
              v130.n128_u64[0] = obja[0];
              v130.n128_u64[1] = v193;
              *v131.i64 = md::DebugConsoleMapRect::worldPointToPixel(&v207, v130);
              v131.i32[1] = v132;
              v133 = vdupq_lane_s64(v131.i64[0], 0);
              v131.i64[0] = vsubq_f32(v131, v191).u64[0];
              v134 = vaddq_f32(v133, v191);
              v131.i64[1] = v134.i64[1];
              v223[0] = v131;
              md::DebugConsoleMapRect::drawPixelRect(&v207, v223, &v220, 1, v131, v134);
            }
          }

          else
          {
            v135 = isArrivalFeature(v103);
            v136 = *(v112 + 40);
            if (v135)
            {
              md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, v54, &v220, v123 ^ 1, v136);
              if (!v123)
              {
                goto LABEL_105;
              }

              v137.n128_u64[0] = obja[0];
              v137.n128_u64[1] = v193;
              v138 = v54;
            }

            else
            {
              md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, v55, &v220, v123 ^ 1, v136);
              if (!v123)
              {
                goto LABEL_105;
              }

              v137.n128_u64[0] = obja[0];
              v137.n128_u64[1] = v193;
              v138 = v55;
            }

            md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, v138, &v220, 1, v137);
          }

LABEL_105:
          if (*(v112 + 76) == 1)
          {
            v139 = vcvtq_f64_f32(*(v112 + 64));
            v140 = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v209, v208)), vsubq_f64(v211[0], v210)));
            v223[0] = *(v112 + 40);
            v223[1] = vmulq_n_f64(v139, (v110 / fminf(v140.f32[1], v140.f32[0])) / sqrt(vaddvq_f64(vmulq_f64(v139, v139))));
            md::DebugConsoleMapRect::drawWorldSegment(&v207, v223, &v220);
          }

          k = v199;
          if (fabsf(*(*(v112 + 16) + 832)) > 0.0001 && *(v112 + 92) == 1)
          {
            v141 = *(v112 + 40);
            v142 = vcvtq_f64_f32(*(v112 + 80));
            LODWORD(v229.f64[0]) = -65536;
            v143 = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v209, v208)), vsubq_f64(v211[0], v210)));
            v223[0] = v141;
            v223[1] = vmulq_n_f64(v142, (v110 / fminf(v143.f32[1], v143.f32[0])) / sqrt(vaddvq_f64(vmulq_f64(v142, v142))));
            md::DebugConsoleMapRect::drawWorldSegment(&v207, v223, &v229);
          }

          v112 += 128;
        }

        v103 += 5;
      }

      while (v103 != v105);
    }

    v25 = v194;
    if (GEOConfigGetBOOL())
    {
      v144 = *(v194 + 276);
      if (v144)
      {
        *&v229.f64[0] = &unk_1F2A3C678;
        *&v229.f64[1] = &v207;
        v231 = COERCE_DOUBLE(&v229);
        v216 = COERCE_DOUBLE(&unk_1F2A3C6C0);
        v217 = *&v194;
        v218 = &v207;
        v219 = COERCE_DOUBLE(&v216);
        memset(v223, 0, 32);
        v223[2].i32[0] = 1065353216;
        v145 = *v144;
        if (*v144 != v144 + 1)
        {
          do
          {
            v146 = v145[4];
            v147 = *(v146 + 792);
            v148 = gdc::Context::context<md::components::SharedTransformData>(v147);
            if (v231 != 0.0)
            {
              if ((*(**&v231 + 48))(COERCE_DOUBLE(*&v231), v148 + 17))
              {
                goto LABEL_122;
              }

              v146 = v145[4];
            }

            v149 = v148 + 39;
            v220.i64[0] = &unk_1F2A563A8;
            v220.i64[1] = &v216;
            *&v221 = v149;
            *(&v221 + 1) = &v220;
            md::ARWorldIntersector::visitReferencedAssetOcclusionVolumes(v144, v146, v223, &v220);
            std::__function::__value_func<BOOL ()(md::ARAssetOcclusionMeshData const*,std::vector<arComponents::LocalBounds> const&)>::~__value_func[abi:nn200100](&v220);
            v150 = gdc::Registry::storage<arComponents::LocalBounds>(v147);
            v151 = v150[7];
            v152 = v150[8];
            if (v151 != v152)
            {
              v153 = v150[10];
              while (v219 != 0.0)
              {
                (*(**&v219 + 48))(COERCE_DOUBLE(*&v219), v149, v153);
                v153 += 168;
                v151 += 8;
                if (v151 == v152)
                {
                  goto LABEL_122;
                }
              }

LABEL_171:
              std::__throw_bad_function_call[abi:nn200100]();
            }

LABEL_122:
            v154 = v145[1];
            if (v154)
            {
              do
              {
                v155 = v154;
                v154 = *v154;
              }

              while (v154);
            }

            else
            {
              do
              {
                v155 = v145[2];
                _ZF = *v155 == v145;
                v145 = v155;
              }

              while (!_ZF);
            }

            v145 = v155;
          }

          while (v155 != v144 + 1);
        }

        std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(v223);
        std::__function::__value_func<void ()(gm::Matrix<double,4,4> const&,arComponents::LocalBounds const&)>::~__value_func[abi:nn200100](&v216);
        std::__function::__value_func<BOOL ()(gm::Box<double,3> const&)>::~__value_func[abi:nn200100](&v229);
        v25 = v194;
        v156 = *(v194 + 276);
        v220.i64[0] = &unk_1F2A3C678;
        v220.i64[1] = &v207;
        *(&v221 + 1) = &v220;
        v214[0] = &unk_1F2A3C708;
        v214[1] = v194;
        v214[2] = &v207;
        v215 = v214;
        v157 = *(v156 + 104);
        v158 = *(v156 + 112);
        for (k = v199; v157 != v158; v157 += 48)
        {
          v159 = 0;
          memset(&v224[8], 0, 32);
          memset(&v223[2].u64[1], 0, 40);
          memset(&v223[0].u64[1], 0, 32);
          v223[0].i64[0] = 0x3FF0000000000000;
          v223[2].i64[1] = 0x3FF0000000000000;
          *v224 = 0x3FF0000000000000;
          *&v224[40] = 0x3FF0000000000000;
          do
          {
            v160 = *(v157 + 8 * v159);
            *(v213 + v159++) = v160;
          }

          while (v159 != 3);
          do
          {
            v161 = *(v157 + 8 * v159);
            *(v213 + v159++) = v161;
          }

          while (v159 != 6);
          if (!v215)
          {
            goto LABEL_171;
          }

          (*(*v215 + 48))(v215, v223, v213);
        }

        std::__function::__value_func<void ()(gm::Matrix<double,4,4> const&,gm::Box<float,3> const&)>::~__value_func[abi:nn200100](v214);
        std::__function::__value_func<BOOL ()(gm::Box<double,3> const&)>::~__value_func[abi:nn200100](&v220);
      }
    }

    if (GEOConfigGetBOOL())
    {
      v162 = *(v25 + 6);
      v223[1].i64[0] = 0;
      v223[0].i64[1] = 0;
      v223[0].i64[0] = &v223[0].i64[1];
      *(&v223[1] + 8) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      *(&v223[2] + 8) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
      v163 = *(v162 + 16);
      v164 = *(v162 + 24);
      if (v163 != v164)
      {
        do
        {
          v165 = *v163;
          if ((*v163)->n128_u8[9] < 0x15u)
          {
            LODWORD(v213[0]) = -16776961;
            md::DebugConsoleMapRect::drawWorldRect(&v207, v165 + 3, v213, 0);
          }

          else
          {
            md::MultiRectRegion::addRect(v223, v165[3].n128_f64);
          }

          v163 += 2;
        }

        while (v163 != v164);
        if (v223[1].i64[0])
        {
          LODWORD(v213[0]) = -16711681;
          md::DebugConsoleMapRect::drawWorldRect(&v207, &v223[1].u64[1], v213, 0);
          v166 = v223[0].i64[0];
          if (v223[0].i64[0] != &v223[0].u64[1])
          {
            do
            {
              LODWORD(v213[0]) = -16711681;
              md::DebugConsoleMapRect::drawWorldRect(&v207, v166 + 2, v213, 0);
              v167 = v166->n128_u64[1];
              if (v167)
              {
                do
                {
                  v168 = v167;
                  v167 = v167->i64[0];
                }

                while (v167);
              }

              else
              {
                do
                {
                  v168 = v166[1].n128_u64[0];
                  _ZF = v168->i64[0] == v166;
                  v166 = v168;
                }

                while (!_ZF);
              }

              v166 = v168;
            }

            while (v168 != &v223[0].u64[1]);
          }
        }
      }

      std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v223[0].i64[1]);
    }

    if (GEOConfigGetBOOL())
    {
      v169 = *(v25 + 276);
      v223[0].i64[0] = &unk_1F2A3C750;
      v223[0].i64[1] = &v207;
      v223[1].i64[1] = v223;
      v172 = *v169;
      v170 = v169 + 1;
      v171 = v172;
      if (v172 != v170)
      {
        do
        {
          v173 = v171[4];
          v174 = v173 ? v173 + 168 : 0;
          v213[0] = v174;
          if (!v223[1].i64[1])
          {
            goto LABEL_171;
          }

          (*(*v223[1].i64[1] + 48))(v223[1].i64[1], v213);
          v175 = v171[1];
          if (v175)
          {
            do
            {
              v176 = v175;
              v175 = *v175;
            }

            while (v175);
          }

          else
          {
            do
            {
              v176 = v171[2];
              _ZF = *v176 == v171;
              v171 = v176;
            }

            while (!_ZF);
          }

          v171 = v176;
        }

        while (v176 != v170);
      }

      std::__function::__value_func<void ()(gdc::Tiled const*)>::~__value_func[abi:nn200100](v223);
    }

    v177 = *(v25 + 257);
    if (v177)
    {
      v178 = v177;
      v179 = [v178 routeInfo];
      v180 = [v179 route];

      [v180 pointAtRouteCoordinate:*(*(v25 + 3) + 3600)];
      v200 = v181;
      v183 = tan(v182 * 0.00872664626 + 0.785398163);
      v184 = log(v183);
      v185.f64[0] = v200;
      v185.f64[1] = v184;
      LODWORD(v213[0]) = 127;
      md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius(&v207, v54, v213, 1, vmlaq_f64(v187, xmmword_1B33B0700, v185));
    }
  }

  if (*(v25 + 402) == 1)
  {
    md::ARWalkingLabeler::debugOutputLabelState(v25, v188);
  }
}

uint64_t md::ARWalkingLabeler::needsDebugDraw(md::ARWalkingLabeler *this)
{
  if (md::StandardLabeler::needsDebugDraw(this) || (*(this + 402) & 1) != 0 || (*(this + 403) & 1) != 0)
  {
    v2 = 1;
  }

  else
  {
    v2 = *(this + 404);
  }

  return v2 & 1;
}

void md::ARWalkingLabeler::updateDebugSettings(md::ARWalkingLabeler *this)
{
  v5 = +[VKDebugSettings sharedSettings];
  *(this + 402) = [v5 arLabelingStateOverlay];
  *(this + 403) = [v5 arDebugMiniMap];
  *(this + 404) = [v5 arDebugDrawLabelFeatureBounds];
  v2 = *(this + 108);
  [v5 arManeuverDebugElevationOffset];
  if (v2 != v3)
  {
    [v5 arManeuverDebugElevationOffset];
    *(this + 108) = v4;
    md::ARWalkingSupport::setARWalkingFeatures(*(this + 55), *(*(this + 55) + 448), 1);
  }
}

void md::ARWalkingLabeler::getLabelMarkers(void *a1)
{
  v24 = *MEMORY[0x1E69E9840];
  std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>::shared_ptr[abi:nn200100]<gss::StylesheetManager<gss::PropertyID>,0>(&v10, *(a1[3] + 8), *(a1[3] + 16));
  v2 = a1[272];
  if (v2 != a1[273])
  {
    v3 = (v2 + 8);
    v12 = 0;
    v13 = 0;
    v17 = 0;
    v19 = 0;
    v20 = 0;
    v18 = 0;
    v22 = 0;
    v23 = 0;
    v21 = 0;
    v14 = 0u;
    v15 = 0u;
    v16 = 0;
    md::Label::populateFeatureInfo(*(v2 + 8), &v12, 0);
    v5 = *v3;
    v4 = v3[1];
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v7 = *(v5 + 8);
    v6 = (v5 + 8);
    v8 = (*(*v7 + 264))(v7);
    v9 = *v6;
    if (v8 == 24)
    {
      if (v9[849])
      {
        goto LABEL_12;
      }
    }

    else if ((*(*v9 + 264))(v9) == 26)
    {
      if (*(*v6 + 418))
      {
        goto LABEL_12;
      }
    }

    else if (isArrivalFeature(v6) && (*(*v6 + 760) & 1) != 0)
    {
LABEL_12:
      if (!v4)
      {
LABEL_16:
        operator new();
      }

LABEL_15:
      std::__shared_weak_count::__release_shared[abi:nn200100](v4);
      goto LABEL_16;
    }

    if (!v4)
    {
      goto LABEL_16;
    }

    goto LABEL_15;
  }

  if (v11)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v11);
  }
}

void sub_1B32F14A8(mdm::zone_mallocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a35 < 0)
  {
    v37 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v37, a30);
  }

  if (a28 < 0)
  {
    v38 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v38, a23);
  }

  std::vector<unsigned long long,geo::allocator_adapter<unsigned long long,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((v35 + 32));
  if (a17)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a17);
  }

  if (a13)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a13);
  }

  _Unwind_Resume(a1);
}

void md::ARWalkingLabelMarker::~ARWalkingLabelMarker(md::ARWalkingLabelMarker *this)
{
  md::StandardLabelMarker::~StandardLabelMarker(this);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<md::ARWalkingLabelMarker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58490;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::ARWalkingLabeler::restyleActiveLabels(uint64_t **this)
{
  md::ARWalkingSupport::restyleFeatures(this[55], 0);

  md::StandardLabeler::restyleActiveLabels(this);
}

uint64_t md::ARWalkingLabeler::needsForceLayoutAllLabels(md::ARWalkingLabeler *this)
{
  v1 = *(this + 372);
  if (v1 == 1)
  {
    *(this + 372) = 0;
  }

  else if (*(this + 400) == 1)
  {
    LOBYTE(v1) = *(this + 1720);
  }

  else
  {
    LOBYTE(v1) = 0;
  }

  return v1 & 1;
}

void *md::ARWalkingLabeler::render(md::ARWalkingLabeler *this, const md::LayoutContext *a2, md::LabelRenderModel *a3, __n128 a4)
{
  if (*(this + 370))
  {
    v6 = 0;
  }

  else
  {
    v6 = *(this + 371) ^ 1;
  }

  v7 = *(this + 13);
  v8 = *(this + 14);
  while (v7 != v8)
  {
    v9 = *v7;
    if (*(*v7 + 1152))
    {
      v10 = (*(*v9 + 48))(*v7, *(this + 3) + 1168);
      v9 = *v7;
      if (v10)
      {
        md::Label::pushToRenderModel(*v7, a3, a4);
        if (v6)
        {
          v11 = *v7;
          if (*(*v7 + 1339) != 1)
          {
            goto LABEL_39;
          }

          v12 = *(v11 + 272);
          if (v12 && ((*(*v12 + 616))(v12) & 1) != 0 || (v13 = *(v11 + 296)) != 0 && ((*(*v13 + 696))(v13) & 1) != 0 || *(v11 + 304))
          {
LABEL_40:
            v6 = 0;
            *(this + 371) = 1;
            goto LABEL_41;
          }

          v14 = *(v11 + 1152);
          if (v14 == 1)
          {
            if (*(v11 + 1200) < 1.0)
            {
              goto LABEL_40;
            }
          }

          else if (v14 != 3)
          {
            if (v14 == 2 && *(v11 + 1200) > 0.0)
            {
              goto LABEL_40;
            }

LABEL_37:
            if (*(v11 + 1264))
            {
              goto LABEL_40;
            }

            v11 = *v7;
LABEL_39:
            if (md::Label::isAnimating(v11))
            {
              goto LABEL_40;
            }

            v6 = 1;
LABEL_41:
            ++*(this + 91);
            goto LABEL_42;
          }

          if (*(v11 + 1232) < 1.0)
          {
            goto LABEL_40;
          }

          goto LABEL_37;
        }

        v6 = 0;
        goto LABEL_41;
      }
    }

    if (*(v9 + 1339) != 1)
    {
      goto LABEL_42;
    }

    v15 = *(v9 + 272);
    if (v15 && ((*(*v15 + 616))(v15, a2) & 1) != 0 || (v16 = *(v9 + 296)) != 0 && ((*(*v16 + 696))(v16, a2) & 1) != 0 || *(v9 + 304))
    {
LABEL_34:
      a4.n128_u32[0] = 1148846080;
      md::Label::animate(*v7, a4);
      goto LABEL_42;
    }

    v17 = *(v9 + 1152);
    if (v17 == 1)
    {
      if (*(v9 + 1200) < 1.0)
      {
        goto LABEL_34;
      }
    }

    else if (v17 != 3)
    {
      if (v17 == 2 && *(v9 + 1200) > 0.0)
      {
        goto LABEL_34;
      }

      goto LABEL_33;
    }

    if (*(v9 + 1232) < 1.0)
    {
      goto LABEL_34;
    }

LABEL_33:
    if (*(v9 + 1264))
    {
      goto LABEL_34;
    }

LABEL_42:
    v7 += 2;
  }

  v18 = *(*(*(this + 3) + 168) + 64);
  result = (*(*v18 + 24))(v18, a2);
  v20 = result + 1;
  if (result + 1 != (a3 + 40))
  {
    v21 = result;
    v22 = *(a3 + 5);
    v23 = *(a3 + 6);
    v24 = v23 - v22;
    v25 = result[3];
    v26 = result[1];
    if (v25 - v26 >= (v23 - v22))
    {
      v34 = result[2];
      v35 = v34 - v26;
      if (v34 - v26 >= v24)
      {
        if (v23 != v22)
        {
          result = memmove(result[1], v22, v23 - v22);
        }

        v33 = &v26[v24];
      }

      else
      {
        v36 = &v22[v35];
        if (v34 != v26)
        {
          result = memmove(result[1], v22, v35);
          v34 = v21[2];
        }

        if (v23 != v36)
        {
          result = memmove(v34, v36, v23 - v36);
        }

        v33 = &v34[v23 - v36];
      }
    }

    else
    {
      v27 = v24 >> 3;
      if (v26)
      {
        result[2] = v26;
        v28 = mdm::zone_mallocator::instance(result);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::LabelExternalMesh *>(v28, v26);
        v25 = 0;
        *v20 = 0;
        v20[1] = 0;
        v20[2] = 0;
      }

      if (v27 >> 61)
      {
        goto LABEL_70;
      }

      v29 = v25 >> 2;
      if (v25 >> 2 <= v27)
      {
        v29 = v24 >> 3;
      }

      v30 = v25 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v29;
      if (v30 >> 61)
      {
LABEL_70:
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v31 = mdm::zone_mallocator::instance(result);
      result = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<md::LabelExternalMesh *>(v31, v30);
      v32 = result;
      v21[1] = result;
      v21[2] = result;
      v21[3] = &result[v30];
      if (v23 != v22)
      {
        result = memmove(result, v22, v23 - v22);
      }

      v33 = &v32[v24];
    }

    v21[2] = v33;
  }

  return result;
}

void md::ARWalkingLabeler::layoutForDisplay(md::ARWalkingLabeler *this, const md::LayoutContext *a2)
{
  v63 = *MEMORY[0x1E69E9840];
  v57 = 0;
  v56 = 0;
  v4 = *(this + 13);
  v5 = *(this + 14);
  while (v4 != v5)
  {
    md::Label::layoutForDisplay(*v4, *(this + 3), &v56);
    v4 += 2;
  }

  v6 = *(a2 + 1);
  v7 = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100](v6, 0x8741E659406FCBBuLL);
  if (v7 && (v8 = v7[5], *(v8 + 8) == 0x8741E659406FCBBLL))
  {
    v9 = *(v8 + 32);
    if (v9)
    {
      LOBYTE(v9) = *v9;
    }
  }

  else
  {
    LOBYTE(v9) = 0;
  }

  *(this + 2240) = v9 & 1;
  v10 = gdc::Context::context<md::ARWorldIntersectorContext>(v6);
  if (v10)
  {
    v11 = *(v10 + 8);
    if (!*&v11)
    {
      goto LABEL_24;
    }

    v12 = **v10;
    if (v12)
    {
      v13 = *v12;
      if (v13)
      {
        v14 = vcnt_s8(v11);
        v14.i16[0] = vaddlv_u8(v14);
        do
        {
          v15 = v13[1];
          if (v15)
          {
            if (v14.u32[0] > 1uLL)
            {
              if (v15 < *&v11 || v15 % *&v11)
              {
                break;
              }
            }

            else if ((v15 & (*&v11 - 1)) != 0)
            {
              break;
            }
          }

          else if (!*(v13 + 16))
          {
            v11.i8[0] = 1;
            goto LABEL_24;
          }

          v13 = *v13;
        }

        while (v13);
      }
    }

    v11.i8[0] = 0;
LABEL_24:
    *(this + 2224) |= v11.i8[0];
    v16 = *(v10 + 40);
    v17 = *(v10 + 48);
    if (v17)
    {
      v18 = 0;
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_28;
    }
  }

  else
  {
    v16 = 0;
    v17 = 0;
  }

  v18 = 1;
LABEL_28:
  *(this + 276) = v16;
  v19 = *(this + 277);
  *(this + 277) = v17;
  if (v19)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v19);
  }

  if ((v18 & 1) == 0)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v17);
  }

  v20 = gdc::Context::context<md::ARLogicContext>(*(a2 + 1));
  if (v20)
  {
    v21 = *(v20 + 18);
    *(this + 1100) = *(v20 + 16);
    *(this + 2202) = v21;
    v22 = *(v20 + 64);
  }

  else
  {
    v22 = 0;
    *(this + 1100) = 0;
    *(this + 2202) = 0;
  }

  *(this + 2203) = v22;
  v23 = *(this + 281);
  if (v23)
  {
    v24 = (*(*v23 + 48))(v23, *(this + 3) + 1168);
    if (*(this + 1976) != v24)
    {
      *(this + 1976) = v24;
      *(this + 279) |= 8uLL;
    }

    if ((v24 & 1) == 0)
    {
      md::ARWalkingLabeler::screenHeadingForWorldPoint(buf, *(this + 3) + 432, *(this + 281) + 408, *(this + 84));
      if ((buf[8] & 1) != 0 || vabdd_f64(*buf, *(this + 248)) < *(this + 73))
      {
        if (buf[8] == *(this + 1977))
        {
          goto LABEL_46;
        }

        v25 = *buf;
      }

      else
      {
        v25 = *buf;
      }

      *(this + 1977) = buf[8];
      *(this + 248) = v25;
      *(this + 279) |= 1uLL;
    }
  }

  else
  {
    *(this + 248) = 0;
    *(this + 988) = 0;
    *(this + 504) = 0;
  }

LABEL_46:
  v26 = *(this + 279);
  if ((v26 & 0xF) != 0)
  {
    memset(buf, 0, sizeof(buf));
    v62 = 0.0;
    v27 = *(this + 281);
    if (v27)
    {
      v28 = v27[51] * 6.28318531;
      v29 = v27[53] / v27[29];
      v30 = exp(v27[52] * 6.28318531 + -3.14159265);
      v55 = atan(v30);
      v31 = fmod(v28, 6.28318531);
      v32 = fmod(v31 + 6.28318531, 6.28318531);
      v33.f64[0] = v55;
      v33.f64[1] = v32;
      *buf = vmlaq_f64(xmmword_1B33B0660, xmmword_1B33B0650, v33);
      v62 = v29;
    }

    v59 = &unk_1F2A58470;
    v60 = 0;
    v34 = [VKARWalkingFeatureDidUpdateInfo alloc];
    v35 = *(this + 250);
    v36 = *(this + 504);
    v37 = *(*(this + 55) + 448);
    v38 = *(this + 1976);
    v39 = *(this + 1977);
    v58 = *(this + 248);
    LOBYTE(v54) = v39;
    v40 = [(VKARWalkingFeatureDidUpdateInfo *)v34 initWithFeature:v35 featureLabelIdentifier:v36 featureSet:v37 labelPosition:buf updateTypes:v26 isVisible:v38 isDirectlyBehind:v54 screenHeading:&v58];
    v41 = v40;
    objc_storeStrong(&v60, v40);

    v42 = GEOGetVectorKitARWalkingLabelerLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      if (v60)
      {
        v43 = v60;
        v44 = [v43 description];
        v45 = v44;
        v46 = [v44 UTF8String];
        *buf = 136315138;
        *&buf[4] = v46;
        _os_log_impl(&dword_1B2754000, v42, OS_LOG_TYPE_DEBUG, "arWalkingFeatureDidUpdate %s", buf, 0xCu);
      }

      else
      {
        *buf = 136315138;
        *&buf[4] = "nil";
        _os_log_impl(&dword_1B2754000, v42, OS_LOG_TYPE_DEBUG, "arWalkingFeatureDidUpdate %s", buf, 0xCu);
      }
    }

    v47 = *(this + 3);
    v48 = v60;
    v49 = v48;
    v50 = *(v47 + 136);
    if (v50 && v50[31])
    {
      v51 = v48;
      *buf = v51;
      v52 = v50[31];
      if (!v52)
      {
        v53 = std::__throw_bad_function_call[abi:nn200100]();

        v59 = &unk_1F2A58470;
        _Unwind_Resume(v53);
      }

      (*(*v52 + 48))(v52, buf);
    }

    v59 = &unk_1F2A58470;
    v26 = *(this + 279);
  }

  *(this + 279) = v26 & 0xFFFFFFFFFFFFFFF0;
}

void geo::_retain_ptr<VKARWalkingFeatureDidUpdateInfo * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *a1 = &unk_1F2A58470;

  JUMPOUT(0x1B8C62190);
}

uint64_t geo::_retain_ptr<VKARWalkingFeatureDidUpdateInfo * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *a1 = &unk_1F2A58470;

  return a1;
}

void md::ARWalkingLabeler::screenHeadingForWorldPoint(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  for (i = 0; i != 24; i += 8)
  {
    *(&v25 + i) = *(a3 + i) - *(a2 + 136 + i);
  }

  v23 = v25;
  v24 = v26;
  v9 = gm::Matrix<double,3,1>::normalized<int,void>(&v23);
  v10 = 0;
  *&v25 = v9;
  *(&v25 + 1) = v11;
  v26 = v12;
  v13 = 0.0;
  do
  {
    v13 = v13 + *(&v25 + v10) * *(a2 + 160 + v10);
    v10 += 8;
  }

  while (v10 != 24);
  v14 = gm::Matrix<double,4,4>::multiplyHomogeneous<int,void>((a2 + 736), a3);
  v16 = fabs(v15) > 1.0;
  v17 = v14 / v15;
  v19 = v18 / v15;
  v20 = 1.0 / sqrt(v17 * v17 + v19 * v19);
  v21 = -(v17 * v20);
  v22 = acos(v20 * v19) * 57.2957795;
  if ((v21 > 0.0) & ~v16 | (v21 < 0.0) & v16)
  {
    v22 = 360.0 - v22;
  }

  *a1 = v22;
  *(a1 + 8) = v13 <= a4;
}

uint64_t md::ARWalkingLabeler::synchStagingWithDisplay(md::ARWalkingLabeler *this)
{
  md::StandardLabeler::synchStagingWithDisplay(this);
  v2 = *(this + 210);
  if (*(this + 281) == v2)
  {
    goto LABEL_14;
  }

  v3 = *(this + 211);
  if (v3)
  {
    atomic_fetch_add_explicit((v3 + 8), 1uLL, memory_order_relaxed);
  }

  *(this + 281) = v2;
  v4 = *(this + 282);
  *(this + 282) = v3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  v5 = *(this + 250);
  v6 = *(this + 213);
  v7 = v5;
  v8 = v6;
  v9 = v8;
  if (v7 == v8)
  {

    goto LABEL_10;
  }

  v10 = [v7 isEqual:v8];

  if ((v10 & 1) == 0)
  {
    v11 = *(this + 213);
    v7 = *(this + 250);
    *(this + 250) = v11;
LABEL_10:
  }

  *(this + 279) |= 4uLL;
  v12 = *(this + 281);
  if (v12)
  {
    LODWORD(v12) = *(v12 + 48);
  }

  *(this + 504) = v12;
LABEL_14:
  v13 = (this + 2176);
  std::vector<std::pair<std::bitset<2ul>,std::shared_ptr<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>>>>>::clear[abi:nn200100](this + 272);
  v14 = *(this + 9);
  v15 = *(this + 10);
  if (v14 != v15)
  {
    v16 = *(this + 273);
    do
    {
      v17 = *v14;
      v18 = *(*v14 + 845);
      v19 = *(this + 274);
      if (v16 >= v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * ((v16 - *v13) >> 3);
        v22 = v21 + 1;
        if (v21 + 1 > 0xAAAAAAAAAAAAAAALL)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v23 = 0xAAAAAAAAAAAAAAABLL * ((v19 - *v13) >> 3);
        if (2 * v23 > v22)
        {
          v22 = 2 * v23;
        }

        if (v23 >= 0x555555555555555)
        {
          v24 = 0xAAAAAAAAAAAAAAALL;
        }

        else
        {
          v24 = v22;
        }

        if (v24)
        {
          if (v24 <= 0xAAAAAAAAAAAAAAALL)
          {
            operator new();
          }

LABEL_147:
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v25 = 24 * v21;
        *v25 = v18;
        *(v25 + 8) = v17;
        v26 = v14[1];
        *(v25 + 16) = v26;
        if (v26)
        {
          atomic_fetch_add_explicit((v26 + 8), 1uLL, memory_order_relaxed);
        }

        v16 = v25 + 24;
        v27 = *(this + 272);
        v28 = *(this + 273) - v27;
        v29 = v25 - v28;
        memcpy((v25 - v28), v27, v28);
        *(this + 272) = v29;
        *(this + 273) = v16;
        *(this + 274) = 0;
        if (v27)
        {
          operator delete(v27);
        }
      }

      else
      {
        *v16 = v18;
        *(v16 + 8) = v17;
        v20 = v14[1];
        *(v16 + 16) = v20;
        if (v20)
        {
          atomic_fetch_add_explicit((v20 + 8), 1uLL, memory_order_relaxed);
        }

        v16 += 24;
      }

      *(this + 273) = v16;
      v14 += 2;
    }

    while (v14 != v15);
  }

  v30 = *(this + 13);
  v31 = *(this + 14);
  *__p = 0u;
  v110 = 0u;
  for (i = 1065353216; v30 != v31; v30 += 2)
  {
    v32 = 0x9DDFEA08EB382D69 * ((8 * (*v30 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*v30));
    v33 = 0x9DDFEA08EB382D69 * (HIDWORD(*v30) ^ (v32 >> 47) ^ v32);
    v34 = 0x9DDFEA08EB382D69 * (v33 ^ (v33 >> 47));
    if (!__p[1])
    {
      goto LABEL_51;
    }

    v35 = vcnt_s8(__p[1]);
    v35.i16[0] = vaddlv_u8(v35);
    if (v35.u32[0] > 1uLL)
    {
      v36 = 0x9DDFEA08EB382D69 * (v33 ^ (v33 >> 47));
      if (v34 >= __p[1])
      {
        v36 = v34 % __p[1];
      }
    }

    else
    {
      v36 = v34 & (__p[1] - 1);
    }

    v37 = *(__p[0] + v36);
    if (!v37 || (v38 = *v37) == 0)
    {
LABEL_51:
      operator new();
    }

    while (1)
    {
      v39 = v38[1];
      if (v39 == v34)
      {
        break;
      }

      if (v35.u32[0] > 1uLL)
      {
        if (v39 >= __p[1])
        {
          v39 %= __p[1];
        }
      }

      else
      {
        v39 &= __p[1] - 1;
      }

      if (v39 != v36)
      {
        goto LABEL_51;
      }

LABEL_50:
      v38 = *v38;
      if (!v38)
      {
        goto LABEL_51;
      }
    }

    if (v38[2] != *v30)
    {
      goto LABEL_50;
    }
  }

  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 262);
  std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear(this + 265);
  *(this + 270) = this + 2096;
  *(this + 271) = 0;
  v40 = *(this + 228);
  if (v40 != (this + 1816))
  {
    geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::insert(this + 2096, v40 + 2);
  }

  v41 = 16;
  if (*(this + 1792))
  {
    v41 = 40;
  }

  v42 = this + v41;
  v43 = *(v42 + 218);
  *(this + 2072) = *(v42 + 108);
  *(this + 261) = v43;
  v44 = *(this + 254);
  v45 = *(this + 253);
  while (v44 != v45)
  {
    v44 -= 40;
    std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>,0>(v44);
  }

  *(this + 254) = v45;
  v46 = *(this + 9);
  v47 = *(this + 10);
  if (v46 != v47)
  {
    v108 = *(this + 3);
    do
    {
      v48 = *v46;
      v49 = 0x9DDFEA08EB382D69 * ((8 * (*v46 & 0x1FFFFFFF) + 8) ^ HIDWORD(*v46));
      v50 = 0x9DDFEA08EB382D69 * (HIDWORD(*v46) ^ (v49 >> 47) ^ v49);
      v51 = 0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47));
      v52 = *(this + 1944);
      if (!*&v52)
      {
        goto LABEL_79;
      }

      v53 = vcnt_s8(v52);
      v53.i16[0] = vaddlv_u8(v53);
      if (v53.u32[0] > 1uLL)
      {
        v54 = v51;
        if (v51 >= *&v52)
        {
          v54 = v51 % *&v52;
        }
      }

      else
      {
        v54 = v51 & (*&v52 - 1);
      }

      v55 = *(*(this + 242) + 8 * v54);
      if (v55)
      {
        v56 = *v55;
        if (*v55)
        {
          do
          {
            v57 = v56[1];
            if (v57 == v51)
            {
              if (v56[2] == v48)
              {
                break;
              }
            }

            else
            {
              if (v53.u32[0] > 1uLL)
              {
                if (v57 >= *&v52)
                {
                  v57 %= *&v52;
                }
              }

              else
              {
                v57 &= *&v52 - 1;
              }

              if (v57 != v54)
              {
                goto LABEL_79;
              }
            }

            v56 = *v56;
          }

          while (v56);
        }
      }

      else
      {
LABEL_79:
        v56 = 0;
      }

      v58 = *(this + 253);
      v59 = *(this + 254);
      v60 = *(v48 + 8);
      if (v58 == v59)
      {
        goto LABEL_86;
      }

      v61 = *(this + 253);
      while (v60 != *v61)
      {
        v61 += 5;
        if (v61 == v59)
        {
          goto LABEL_86;
        }
      }

      if (v61 == v59)
      {
LABEL_86:
        v62 = *(v48 + 16);
        v113 = *(v48 + 8);
        v114 = v62;
        if (v62)
        {
          atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
          v58 = *(this + 253);
          v59 = *(this + 254);
        }

        memset(v115, 0, 24);
        memset(v112, 0, sizeof(v112));
        if (v58 == v59)
        {
          goto LABEL_94;
        }

        v61 = v58;
        while (v60 != *v61)
        {
          v61 += 5;
          if (v61 == v59)
          {
            goto LABEL_94;
          }
        }

        if (v61 == v59)
        {
LABEL_94:
          v63 = *(this + 255);
          if (v59 >= v63)
          {
            v65 = 0xCCCCCCCCCCCCCCCDLL * (v59 - v58);
            if (v65 + 1 > 0x666666666666666)
            {
              std::__throw_bad_array_new_length[abi:nn200100]();
            }

            v66 = 0xCCCCCCCCCCCCCCCDLL * ((v63 - v58) >> 3);
            v67 = 2 * v66;
            if (2 * v66 <= v65 + 1)
            {
              v67 = v65 + 1;
            }

            if (v66 >= 0x333333333333333)
            {
              v68 = 0x666666666666666;
            }

            else
            {
              v68 = v67;
            }

            v119 = this + 2024;
            if (v68)
            {
              if (v68 <= 0x666666666666666)
              {
                operator new();
              }

              goto LABEL_147;
            }

            v116 = 0.0;
            v117 = 40 * v65;
            v118 = 40 * v65;
            std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>::pair[abi:nn200100]((40 * v65), &v113);
            v64 = (v118 + 40);
            v69 = *(this + 253);
            v70 = *(this + 254) - v69;
            v71 = v117 - v70;
            memcpy((v117 - v70), v69, v70);
            v72 = *(this + 253);
            *(this + 253) = v71;
            *(this + 254) = v64;
            v73 = *(this + 255);
            *(this + 255) = *(&v118 + 1);
            *&v118 = v72;
            *(&v118 + 1) = v73;
            v116 = *&v72;
            v117 = v72;
            std::__split_buffer<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>>::~__split_buffer(&v116);
          }

          else
          {
            std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>::pair[abi:nn200100](v59, &v113);
            v64 = v59 + 5;
            *(this + 254) = v59 + 5;
          }

          *(this + 254) = v64;
          v61 = v64 - 5;
        }

        v116 = COERCE_DOUBLE(v115);
        std::vector<md::ARWalkingLabelDebugData>::__destroy_vector::operator()[abi:nn200100](&v116);
        if (v114)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v114);
        }

        v116 = COERCE_DOUBLE(v112);
        std::vector<md::ARWalkingLabelDebugData>::__destroy_vector::operator()[abi:nn200100](&v116);
        v48 = *v46;
        v74 = 0x9DDFEA08EB382D69 * ((8 * (*v46 & 0x1FFFFFFF) + 8) ^ HIDWORD(*v46));
        v75 = 0x9DDFEA08EB382D69 * (HIDWORD(*v46) ^ (v74 >> 47) ^ v74);
        v51 = 0x9DDFEA08EB382D69 * (v75 ^ (v75 >> 47));
      }

      v76 = gm::Matrix<double,3,1>::distanceSquaredToPoint<int,void>(v108 + 568, v48 + 616);
      if (__p[1])
      {
        v77 = vcnt_s8(__p[1]);
        v77.i16[0] = vaddlv_u8(v77);
        if (v77.u32[0] > 1uLL)
        {
          v78 = v51;
          if (v51 >= __p[1])
          {
            v78 = v51 % __p[1];
          }
        }

        else
        {
          v78 = v51 & (__p[1] - 1);
        }

        v79 = *(__p[0] + v78);
        if (v79)
        {
          for (j = *v79; j; j = *j)
          {
            v81 = j[1];
            if (v51 == v81)
            {
              if (j[2] == v48)
              {
                v105 = 1;
                goto LABEL_127;
              }
            }

            else
            {
              if (v77.u32[0] > 1uLL)
              {
                if (v81 >= __p[1])
                {
                  v81 %= __p[1];
                }
              }

              else
              {
                v81 &= __p[1] - 1;
              }

              if (v81 != v78)
              {
                break;
              }
            }
          }
        }
      }

      v105 = 0;
LABEL_127:
      v82 = v76 / (*(v48 + 224) * *(v48 + 224));
      v83 = std::__hash_table<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>>>::find<gdc::Registry *>(this + 237, v48);
      v84 = v83;
      if (v56)
      {
        v85 = (v56 + 3);
      }

      else
      {
        v85 = 0;
      }

      v87 = v61[3];
      v86 = v61[4];
      if (v87 >= v86)
      {
        v89 = v61[2];
        v90 = (v87 - v89) >> 7;
        if ((v90 + 1) >> 57)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v91 = v86 - v89;
        v92 = v91 >> 6;
        if (v91 >> 6 <= (v90 + 1))
        {
          v92 = v90 + 1;
        }

        if (v91 >= 0x7FFFFFFFFFFFFF80)
        {
          v93 = 0x1FFFFFFFFFFFFFFLL;
        }

        else
        {
          v93 = v92;
        }

        v119 = (v61 + 2);
        if (v93)
        {
          std::__allocate_at_least[abi:nn200100]<std::allocator<md::ARWalkingLabelDebugData>>(v93);
        }

        v116 = 0.0;
        v117 = v90 << 7;
        v118 = (v90 << 7);
        v113 = v82;
        md::ARWalkingLabelDebugData::ARWalkingLabelDebugData(v90 << 7, v46, &v113, v105, v84 != 0, v85);
        *&v118 = v118 + 128;
        v94 = v61[2];
        v95 = v61[3];
        v96 = v117 + v94 - v95;
        if (v94 != v95)
        {
          v97 = v61[2];
          v98 = v117 + v94 - v95;
          do
          {
            *v98 = *v97;
            *v97 = 0;
            *(v97 + 8) = 0;
            *(v98 + 16) = *(v97 + 16);
            *(v97 + 16) = 0;
            *(v97 + 24) = 0;
            v99 = *(v97 + 32);
            v100 = *(v97 + 48);
            v101 = *(v97 + 64);
            *(v98 + 77) = *(v97 + 77);
            *(v98 + 48) = v100;
            *(v98 + 64) = v101;
            *(v98 + 32) = v99;
            *(v98 + 96) = *(v97 + 96);
            v102 = *(v97 + 104);
            *(v98 + 120) = *(v97 + 120);
            *(v98 + 104) = v102;
            v97 += 128;
            v98 += 128;
          }

          while (v97 != v95);
          do
          {
            std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::ARWalkingManeuverLabelFeature> const,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,0>(v94);
            v94 += 128;
          }

          while (v94 != v95);
        }

        v103 = v61[2];
        v61[2] = v96;
        v104 = v61[4];
        v107 = v118;
        *(v61 + 3) = v118;
        *&v118 = v103;
        *(&v118 + 1) = v104;
        v116 = *&v103;
        v117 = v103;
        std::__split_buffer<md::ARWalkingLabelDebugData>::~__split_buffer(&v116);
        v88 = v107;
      }

      else
      {
        v116 = v82;
        md::ARWalkingLabelDebugData::ARWalkingLabelDebugData(v87, v46, &v116, v105, v83 != 0, v85);
        v88 = v87 + 128;
        v61[3] = v87 + 128;
      }

      v61[3] = v88;
      v46 += 2;
    }

    while (v46 != v47);
  }

  return std::__hash_table<std::shared_ptr<md::ARAssetOcclusionMeshData>,std::hash<std::shared_ptr<md::ARAssetOcclusionMeshData>>,std::equal_to<std::shared_ptr<md::ARAssetOcclusionMeshData>>,std::allocator<std::shared_ptr<md::ARAssetOcclusionMeshData>>>::~__hash_table(__p);
}

void std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>,0>(uint64_t a1)
{
  v3 = (a1 + 16);
  std::vector<md::ARWalkingLabelDebugData>::__destroy_vector::operator()[abi:nn200100](&v3);
  v2 = *(a1 + 8);
  if (v2)
  {

    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }
}

uint64_t md::ARWalkingLabelDebugData::ARWalkingLabelDebugData(uint64_t a1, void *a2, void *a3, char a4, char a5, uint64_t a6)
{
  v12 = *a2;
  v13 = *(*a2 + 16);
  *a1 = *(*a2 + 8);
  *(a1 + 8) = v13;
  if (v13)
  {
    atomic_fetch_add_explicit((v13 + 8), 1uLL, memory_order_relaxed);
    v12 = *a2;
  }

  v14 = a2[1];
  *(a1 + 16) = v12;
  *(a1 + 24) = v14;
  if (v14)
  {
    atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
  }

  v15 = *a2;
  *(a1 + 32) = *(*a2 + 48);
  v16 = *(v15 + 616);
  *(a1 + 56) = *(v15 + 632);
  *(a1 + 40) = v16;
  *(a1 + 64) = *(*a2 + 152);
  *(a1 + 80) = (*(**a1 + 144))();
  *(a1 + 88) = v17;
  *(a1 + 92) = v18;
  *(a1 + 96) = *a3;
  v19 = *a2;
  *(a1 + 104) = *(*a2 + 845);
  *(a1 + 105) = *(v19 + 844);
  *(a1 + 106) = a4;
  *(a1 + 107) = a5;
  *(a1 + 112) = a6;
  *(a1 + 120) = *(v19 + 792);
  return a1;
}

void sub_1B32F316C(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 24);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  v4 = *(v1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  _Unwind_Resume(exception_object);
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<md::ARWalkingLabelDebugData>>(unint64_t a1)
{
  if (!(a1 >> 57))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t std::__split_buffer<md::ARWalkingLabelDebugData>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 128;
    std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::ARWalkingManeuverLabelFeature> const,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,0>(i - 128);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::vector<md::ARWalkingLabelDebugData>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 128;
        std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::ARWalkingManeuverLabelFeature> const,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,0>(v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void *std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>::pair[abi:nn200100](void *result, void *a2)
{
  v2 = a2[1];
  *result = *a2;
  result[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  v3 = a2[2];
  v4 = a2[3];
  v5 = v4 - v3;
  if (v4 != v3)
  {
    if (!((v5 >> 7) >> 57))
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<md::ARWalkingLabelDebugData>>(v5 >> 7);
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  return result;
}

void sub_1B32F3394(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 40;
    std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>,0>(i - 40);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void md::ARWalkingLabeler::synchronizedUpdate(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v154 = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 440);
  v6 = gdc::Context::context<md::ARLogicContext>(*(a2 + 8));
  if (v6)
  {
    v7 = *(v6 + 88);
    v134 = *(v6 + 96);
  }

  else
  {
    LOBYTE(v134) = 0;
    v7 = 0.0;
  }

  v8 = *(*v5 + 424);
  v9 = *(v5 + 776);
  md::LabelLayoutContext::coordinateEyePos(&v146, v8);
  v135 = v8;
  v10 = v8[17];
  v11 = v146;
  *(v9 + 32) = v146;
  v12 = v147;
  *(v9 + 48) = v147;
  *(v9 + 56) = v10;
  if (*v11.i64 == 0.0 && *&v11.i64[1] == 0.0)
  {
    if (!v10)
    {
      goto LABEL_30;
    }

    v13 = GEOGetVectorKitHighPrecisionAltitudeRequestorLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "!_hasLocalizedAltitude";
      *&buf[12] = 2080;
      *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/HighPrecisionAltitudeRequestor.mm";
      *&buf[22] = 1024;
      *&buf[24] = 255;
      _os_log_impl(&dword_1B2754000, v13, OS_LOG_TYPE_ERROR, "We are getting an empty coordinate while localized: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }

  else
  {
    if (v10)
    {
      *buf = v12;
      *&v139 = COERCE_DOUBLE(v143);
      v140 = COERCE_DOUBLE(v143);
      v141 = COERCE_DOUBLE(v143);
      v142 = 2;
      geo::small_vector_base<geo::Unit<geo::MeterUnitDescription,double>>::append<geo::Unit<geo::MeterUnitDescription,double> const*>(&v139, buf, &buf[8]);
      v133 = v146;
      v14 = *(v9 + 64);
      v15 = geo::WGS84::unitsPerMeterAtLatitude<geo::Degrees,double>(*v146.i64);
      v16 = tan(*v133.i64 * 0.00872664626 + 0.785398163);
      v17 = log(v16);
      *&v18.f64[0] = vdupq_laneq_s64(v133, 1).u64[0];
      v18.f64[1] = v17;
      __asm { FMOV            V2.2D, #0.5 }

      v153 = vcvtq_u64_f64(vmulq_n_f64(vmlaq_f64(_Q2, xmmword_1B33B0700, v18), 1.0 / (v14 * v15)));
      v24 = v153.i64[1];
      v25 = v153.i64[0];
      v26 = geo::LRUPolicy<md::SpatialKey,std::shared_ptr<md::HighPrecisionAltitudeRequest>,md::SpatialKeyHash>::get(v9 + 216, (v9 + 176), v153.i64[0], v153.i64[1]);
      if (v9 + 216 == v26)
      {
        operator new();
      }

      v27 = v26;
      if ((*(*(v26 + 32) + 64) & 1) == 0)
      {
        v28 = GEOGetVectorKitHighPrecisionAltitudeRequestorLog();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          *buf = 134219008;
          *&buf[4] = v133.i64[0];
          *&buf[12] = 2048;
          *&buf[14] = v133.i64[1];
          *&buf[22] = 2048;
          *&buf[24] = v12;
          *&buf[32] = 2048;
          *&buf[34] = v25;
          *&buf[42] = 2048;
          *&buf[44] = v24;
          _os_log_impl(&dword_1B2754000, v28, OS_LOG_TYPE_DEBUG, "Adding high precision altitude from device location coordinate:%f,%f,%f key:%llu,%llu", buf, 0x34u);
        }

        v29 = *(v27 + 32);
        if ((*(v29 + 64) & 1) == 0)
        {
          v30 = *(v29 + 8);
          *v29 = 0;
          *(v29 + 8) = 0;
          if (v30)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v30);
          }

          if ((v29 + 16) != &v139)
          {
            v31 = v29 + 48;
            v32 = *(v29 + 16);
            if (v32 != *(v29 + 32))
            {
              free(v32);
            }

            *(v29 + 16) = v31;
            *(v29 + 24) = v31;
            *(v29 + 32) = v31;
            *(v29 + 40) = 2;
            geo::small_vector_base<geo::Unit<geo::MeterUnitDescription,double>>::append<geo::Unit<geo::MeterUnitDescription,double> const*>(v29 + 16, v139, *&v140);
          }

          *(v29 + 64) = 1;
        }
      }

      if (v139 != *&v141)
      {
        free(v139);
      }
    }

    v13 = md::HighPrecisionAltitudeRequestor::vlLocalizer(v9);
    if (v13)
    {
      md::HighPrecisionAltitudeRequestor::clLocationForCoordinate(buf, v9, (v9 + 32));
      if (*&buf[8])
      {
        [v13 prepareWithDeviceLocation:?];
        v33 = *&buf[8];
      }

      else
      {
        v33 = 0;
      }

      *buf = &unk_1F2A2A238;
    }
  }

LABEL_30:
  if (a4)
  {
    *&buf[8] = 0;
    *&buf[16] = 0;
    *buf = &buf[8];
    *&buf[24] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    *&buf[40] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    v34 = v5 + 848;
    std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v5 + 848));
    v35 = *&buf[8];
    *(v5 + 840) = *buf;
    *(v5 + 848) = v35;
    v36 = *&buf[16];
    *(v5 + 856) = *&buf[16];
    if (v36)
    {
      v35[2] = v34;
      *buf = &buf[8];
      *&buf[8] = 0;
      *&buf[16] = 0;
      v35 = 0;
    }

    else
    {
      *(v5 + 840) = v34;
    }

    v37 = *&buf[40];
    *(v5 + 864) = *&buf[24];
    *(v5 + 880) = v37;
    std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v35);
    ++*(v5 + 896);
    for (i = *(a3 + 24); i; i = *i)
    {
      v39 = i[2];
      if (*(v39 + 9) >= *(v5 + 48))
      {
        md::MultiRectRegion::addRect((v5 + 840), (v39 + 48));
      }
    }

    if (v5 + 784 != a3)
    {
      *(v5 + 832) = *(a3 + 48);
      std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::allocator_adapter<std::shared_ptr<md::LabelMapTile>,mdm::zone_mallocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::shared_ptr<md::LabelMapTile>,void *> *>>((v5 + 784), *(a3 + 24));
    }
  }

  if (*(v5 + 896) != *(v5 + 752))
  {
    v40 = GEOGetVectorKitARWalkingSupportLog();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
    {
      v41 = *(v5 + 768);
      v42 = *(v5 + 752);
      v43 = *(v5 + 896);
      *buf = 134218496;
      *&buf[4] = v41;
      *&buf[12] = 2048;
      *&buf[14] = v42;
      *&buf[22] = 2048;
      *&buf[24] = v43;
      _os_log_impl(&dword_1B2754000, v40, OS_LOG_TYPE_INFO, "FeatureSet(version:%llu) has mismatching sceneStamp:%llu expected:%llu", buf, 0x20u);
    }

    *(v5 + 752) = *(v5 + 896);
    v44 = *(v5 + 552);
    for (j = *(v5 + 560); v44 != j; v44 += 2)
    {
      memset(buf, 0, 32);
      *&buf[32] = 1065353216;
      md::ARWalkingSupport::prepareContinueFeaturePlacementsForRegion(v5, v44, v5 + 840, buf);
      if (*&buf[24])
      {
        v139 = v44;
        v46 = std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>,std::hash<std::shared_ptr<md::ARWalkingContinueLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingContinueLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>,std::equal_to<std::shared_ptr<md::ARWalkingContinueLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingContinueLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>>::__emplace_unique_key_args<std::shared_ptr<md::ARWalkingContinueLabelFeature>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<md::ARWalkingContinueLabelFeature> const&>,std::tuple<>>((v5 + 648), *v44);
        std::__hash_table<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<md::LabelIdentifier,std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<md::LabelIdentifier>,std::equal_to<md::LabelIdentifier>,true>,std::__unordered_map_equal<md::LabelIdentifier,std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<md::LabelIdentifier>,std::hash<md::LabelIdentifier>,true>,std::allocator<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::__move_assign((v46 + 4), buf);
      }

      std::__hash_table<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<md::LabelIdentifier,std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<md::LabelIdentifier>,std::equal_to<md::LabelIdentifier>,true>,std::__unordered_map_equal<md::LabelIdentifier,std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<md::LabelIdentifier>,std::hash<md::LabelIdentifier>,true>,std::allocator<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::__deallocate_node(*&buf[16]);
      v47 = *buf;
      *buf = 0;
      if (v47)
      {
        operator delete(v47);
      }
    }
  }

  if (*(v5 + 9) == 1)
  {
    md::LabelLayoutContext::mercatorEyePos(v135);
    v49 = v48 * 6.28318531;
    v51 = exp(v50 * 6.28318531 + -3.14159265);
    v52 = atan(v51) * 2.0 + -1.57079633;
    v53 = fmod(v49, 6.28318531);
    v54 = fmod(v53 + 6.28318531, 6.28318531) + -3.14159265;
    v55 = __sincos_stret(v52);
    v56 = 6378137.0 / sqrt(v55.__sinval * v55.__sinval * -0.00669437999 + 1.0);
    v57 = __sincos_stret(v54);
    *&v139 = v56 * v55.__cosval * v57.__cosval;
    v140 = v56 * v55.__cosval * v57.__sinval;
    v141 = v55.__sinval * 0.99330562 * v56;
    v58 = *(v5 + 520);
    for (k = *(v5 + 528); v58 != k; v58 += 2)
    {
      v60 = *v58;
      if (*(*v58 + 816))
      {
        continue;
      }

      v61 = *(v5 + 696);
      if (v61)
      {
        v62 = 0x9DDFEA08EB382D69 * ((8 * (*v58 & 0x1FFFFFFF) + 8) ^ HIDWORD(*v58));
        v63 = 0x9DDFEA08EB382D69 * (HIDWORD(v60) ^ (v62 >> 47) ^ v62);
        v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
        v65 = vcnt_s8(v61);
        v65.i16[0] = vaddlv_u8(v65);
        if (v65.u32[0] > 1uLL)
        {
          v66 = v64;
          if (v64 >= *&v61)
          {
            v66 = v64 % *&v61;
          }
        }

        else
        {
          v66 = v64 & (*&v61 - 1);
        }

        v67 = *(*(v5 + 688) + 8 * v66);
        if (v67)
        {
          for (m = *v67; m; m = *m)
          {
            v69 = m[1];
            if (v64 == v69)
            {
              if (m[2] == v60)
              {
                goto LABEL_78;
              }
            }

            else
            {
              if (v65.u32[0] > 1uLL)
              {
                if (v69 >= *&v61)
                {
                  v69 %= *&v61;
                }
              }

              else
              {
                v69 &= *&v61 - 1;
              }

              if (v69 != v66)
              {
                break;
              }
            }
          }
        }
      }

      *buf = 1;
      v70 = (*(*v60 + 112))(v60, buf);
      v71 = md::LabelPoint::geocentricPoint(v70);
      v146 = *v71;
      v147 = *(v71 + 2);
      v72 = gm::Matrix<double,3,1>::distanceSquaredToPoint<int,void>(&v139, &v146);
      if (v72 > *(v5 + 24))
      {
        continue;
      }

      v73 = GEOGetVectorKitARWalkingSupportLog();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
      {
        v74 = *(v5 + 24);
        v75 = *(*v58 + 720);
        md::LabelExternalPointFeature::incident(v75);
        objc_claimAutoreleasedReturnValue();
        *buf = 134218498;
        *&buf[4] = v72;
        *&buf[12] = 2048;
        *&buf[14] = v74;
        *&buf[22] = 2112;
        *&buf[24] = v75;
        _os_log_impl(&dword_1B2754000, v73, OS_LOG_TYPE_INFO, "Maneuver feature has entered high precision threshold (d:%f t:%f). Requesting high precision altitude for Maneuver %@", buf, 0x20u);
      }

      v76 = *(v5 + 776);
      md::LabelPoint::coordinate(buf, v70);
      v153 = *buf;
      md::HighPrecisionAltitudeRequestor::requestAltitude(&v144, v76, v153.i64);
      v77 = v144;
      if (v144)
      {
        *buf = v58;
        v78 = std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::__emplace_unique_key_args<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<md::ARWalkingManeuverLabelFeature> const&>,std::tuple<>>((v5 + 688), *v58);
        v79 = v145;
        if (v145)
        {
          atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v80 = v78[5];
        v78[4] = v77;
        v78[5] = v79;
        if (v80)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v80);
        }

        if (!v79)
        {
          continue;
        }
      }

      else
      {
        buf[0] = 0;
        buf[8] = 0;
        md::ARWalkingManeuverLabelFeature::updateWithHighPrecisionAltitude(*v58, buf, 0, 0);
        v81 = GEOGetVectorKitARWalkingSupportLog();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
        {
          v82 = *(*v58 + 720);
          md::LabelExternalPointFeature::incident(v82);
          objc_claimAutoreleasedReturnValue();
          v153.i32[0] = 138412290;
          *(v153.i64 + 4) = v82;
          _os_log_impl(&dword_1B2754000, v81, OS_LOG_TYPE_INFO, "Failed to request high precision altitude for Maneuver %@ - Will continue with fallback altitude", &v153, 0xCu);
        }

        v79 = v145;
        if (!v145)
        {
          continue;
        }
      }

      std::__shared_weak_count::__release_shared[abi:nn200100](v79);
LABEL_78:
      ;
    }
  }

  md::ARWalkingSupport::updateFeatureSet(v5, (v5 + 440));
  if (*(v5 + 88) == 1)
  {
    md::ARWalkingSupport::processSetFeatureRequest(v5, v5 + 56);
    if (*(v5 + 88) == 1)
    {
      *(v5 + 56) = &unk_1F2A3ED40;

      *(v5 + 88) = 0;
    }
  }

  if (*(v5 + 432) == 1)
  {
    md::ARWalkingSupport::updateFeatureSet(v5, (v5 + 96));
    v83 = 0.0;
    if (v134)
    {
      v83 = v135[42] - fmax(v7, *(v5 + 416));
    }

    if (*(v5 + 520) == *(v5 + 528) && *(v5 + 552) == *(v5 + 560) && *(v5 + 584) == *(v5 + 592))
    {
      v84 = 40;
      if (*(v5 + 616) == *(v5 + 624))
      {
        v84 = 32;
      }
    }

    else
    {
      v84 = 40;
    }

    if (!(*(v5 + 328) + *(v5 + 368)) || v83 > *(v5 + v84))
    {
      if ((*(v5 + 432) & 1) == 0 || (geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr(buf, v5 + 440), (*(v5 + 432) & 1) == 0))
      {
        v132 = std::__throw_bad_optional_access[abi:nn200100]();
        if (v139 != *&v141)
        {
          free(v139);
        }

        _Unwind_Resume(v132);
      }

      md::ARWalkingFeatureSet::operator=(v5 + 440, v5 + 96);
      md::ARWalkingSupport::updateFeatureSetState(v5, *&buf[8], 5);
      if (*(v5 + 672) + *(v5 + 712))
      {
        v85 = 3;
      }

      else
      {
        v85 = 4;
      }

      md::ARWalkingSupport::updateFeatureSetState(v5, *(v5 + 448), v85);
      *buf = &unk_1F2A3ED40;

      md::ARWalkingSupport::restyleFeatures(v5, (v5 + 488));
      *(v5 + 496) = *(v5 + 488);
      if (*(v5 + 432) == 1)
      {
        md::ARWalkingFeatureSet::~ARWalkingFeatureSet((v5 + 96));
        *(v5 + 432) = 0;
      }

      v86 = GEOGetVectorKitARWalkingSupportLog();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
      {
        v87 = *(v5 + 768);
        if (*(v5 + 328) + *(v5 + 368))
        {
          v88 = "YES";
        }

        else
        {
          v88 = "NO";
        }

        v89 = 0xAAAAAAAAAAAAAAABLL * ((*(v5 + 472) - *(v5 + 464)) >> 3);
        v90 = (*(v5 + 592) - *(v5 + 584)) >> 4;
        v91 = (*(v5 + 528) - *(v5 + 520)) >> 4;
        v92 = (*(v5 + 560) - *(v5 + 552)) >> 4;
        v93 = *(v5 + 672) + *(v5 + 712);
        *buf = 134219778;
        *&buf[4] = v87;
        *&buf[12] = 2080;
        *&buf[14] = v88;
        *&buf[22] = 2048;
        *&buf[24] = v83;
        *&buf[32] = 2048;
        *&buf[34] = v89;
        *&buf[42] = 2048;
        *&buf[44] = v90;
        *&buf[52] = 2048;
        *&buf[54] = v91;
        v149 = 2048;
        v150 = v92;
        v151 = 2048;
        v152 = v93;
        _os_log_impl(&dword_1B2754000, v86, OS_LOG_TYPE_INFO, "Updating to FeatureSet version:%llu pendingRequests:%s elapsedTimeSinceLocalization:%f - tracking %lu AR Label Features (arrival:%lu maneuver:%lu continue:%lu pendingRequests:%lu)", buf, 0x52u);
      }
    }
  }

  if (*(v5 + 672) + *(v5 + 712))
  {
    v94 = 3;
  }

  else
  {
    v94 = 4;
  }

  md::ARWalkingSupport::updateFeatureSetState(v5, *(v5 + 448), v94);
  for (n = *(v5 + 920); n; n = *n)
  {
    v97 = *v5;
    v98 = n[3];
    v99 = v98;
    v100 = *(v97 + 136);
    if (v100 && *(v100 + 280))
    {
      *buf = v98;
      v101 = *(v100 + 280);
      if (!v101)
      {
        std::__throw_bad_function_call[abi:nn200100]();
      }

      (*(*v101 + 48))(v101, buf);
    }
  }

  if (*(v5 + 928))
  {
    std::__hash_table<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::allocator<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::__deallocate_node(*(v5 + 920));
    *(v5 + 920) = 0;
    v102 = *(v5 + 912);
    if (v102)
    {
      for (ii = 0; ii != v102; ++ii)
      {
        *(*(v5 + 904) + 8 * ii) = 0;
      }
    }

    *(v5 + 928) = 0;
  }

  md::StandardLabeler::synchronizedUpdate(a1, v95, a3, a4);
  v104 = *(a2 + 8);
  v105 = md::LayoutContext::get<md::CameraContext>(v104);
  v106 = gdc::Camera::cameraFrame(v105);
  v107 = *(v106 + 16);
  *(a1 + 408) = vmulq_f64(*v106, vdupq_n_s64(0x404CA5DC1A63C1F8uLL));
  *(a1 + 424) = v107;
  v108 = gdc::Context::context<md::ARLogicContext>(v104);
  v109 = v108 && *(v108 + 64) == 2 && *(v108 + 16) == 3;
  *(a1 + 401) = v109;
  v110 = *(*(a1 + 24) + 3027) & v109 & 1;
  if (*(a1 + 400) != v110)
  {
    *(a1 + 400) = v110;
    v111 = GEOGetVectorKitARWalkingLabelerLog();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
    {
      v112 = "NO";
      if (*(a1 + 400))
      {
        v113 = "YES";
      }

      else
      {
        v113 = "NO";
      }

      if (*(*(a1 + 24) + 3027))
      {
        v114 = "NO";
      }

      else
      {
        v114 = "YES";
      }

      if (*(a1 + 401))
      {
        v112 = "YES";
      }

      *buf = 136315650;
      *&buf[4] = v113;
      *&buf[12] = 2080;
      *&buf[14] = v114;
      *&buf[22] = 2080;
      *&buf[24] = v112;
      _os_log_impl(&dword_1B2754000, v111, OS_LOG_TYPE_INFO, "shouldLayoutLabels:%s (hideRoadLabels:%s, isSessionReady:%s)", buf, 0x20u);
    }

    if (*(a1 + 400) == 1)
    {
      *(a1 + 1720) = 1;
    }
  }

  v115 = *(*(a1 + 24) + 424);
  v116 = +[VKDebugSettings sharedSettings];
  v117 = [v116 labelOcclusionDisabled];

  v118 = gdc::Context::context<md::ARWorldIntersectorContext>(*(a2 + 8));
  if ((v118 == 0) | v117 & 1)
  {
    v119 = 0;
    v120 = 0;
  }

  else
  {
    v120 = *(v118 + 40);
    v119 = *(v118 + 48);
    if (v119)
    {
      atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }

  if (*(a1 + 2224) == 1)
  {
    std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear((a1 + 1816));
    std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::clear((a1 + 1840));
    *(a1 + 1880) = a1 + 1816;
    *(a1 + 1888) = 0;
  }

  v121 = *(*(*(a1 + 24) + 232) + 17);
  if (v119)
  {
    atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  *buf = *(v115 + 136);
  *&buf[16] = *(v115 + 152);
  *(a1 + 1728) = v120;
  v122 = *(a1 + 1736);
  *(a1 + 1736) = v119;
  if (v122)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v122);
  }

  *(a1 + 1744) = *buf;
  *(a1 + 1760) = *&buf[16];
  if (*(a1 + 1792))
  {
    *(a1 + 1792) = 0;
  }

  *(a1 + 1800) = (v121 & 1) == 0;
  *(a1 + 1804) = 0;
  v123 = *(a1 + 400);
  *(a1 + 1721) = *(a1 + 2240);
  if (v123)
  {
    if (*(a1 + 405) == 1)
    {
      md::ARWalkingSupport::setARWalkingFeatures(*(a1 + 440), *(*(a1 + 440) + 448), 1);
      *(a1 + 405) = 0;
    }

    v124 = gm::Matrix<double,3,1>::distanceToPoint<int,void>(v115 + 136, a1 + 1656);
    if (*(v115 + 8) == 1)
    {
      v125 = exp(*(v115 + 144) * 6.28318531 + -3.14159265);
      v126 = atan(v125);
      v124 = v124 / geo::WGS84::unitsPerMeterAtLatitude<geo::Degrees,double>(v126 * 114.591559 + -90.0);
    }

    if ((*(a1 + 406) & 1) != 0 || (*(a1 + 2224) & 1) != 0 || v124 >= *(a1 + 504))
    {
      v127 = GEOGetVectorKitARWalkingLabelerLog();
      if (os_log_type_enabled(v127, OS_LOG_TYPE_INFO))
      {
        v128 = "false";
        v129 = *(v115 + 136);
        v130 = *(v115 + 144);
        if (*(a1 + 2224))
        {
          v128 = "true";
        }

        v131 = *(v115 + 152);
        *buf = 136316162;
        *&buf[4] = v128;
        *&buf[12] = 2048;
        *&buf[14] = v124;
        *&buf[22] = 2048;
        *&buf[24] = v129;
        *&buf[32] = 2048;
        *&buf[34] = v130;
        *&buf[42] = 2048;
        *&buf[44] = v131;
        _os_log_impl(&dword_1B2754000, v127, OS_LOG_TYPE_INFO, "Needs re-evaluation didUpdateIntersector:%s distance:%f currentEyePos:%f,%f,%f", buf, 0x34u);
      }

      *(a1 + 1720) = 1;
    }

    *(a1 + 2224) = 0;
    *(a1 + 406) = 0;
  }

  if (v119)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v119);
  }
}

void md::ARWalkingLabeler::~ARWalkingLabeler(md::ARWalkingLabeler *this)
{
  md::ARWalkingLabeler::~ARWalkingLabeler(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A57D70;
  *(this + 1) = &unk_1F2A57F90;
  *(this + 2) = &unk_1F2A57FD8;
  *(this + 49) = &unk_1F2A58048;
  v2 = gdc::ServiceLocator::resolve<mre::GraphicsResourceStore>(**(*(this + 3) + 112), *(*(*(this + 3) + 112) + 8));
  (*(*v2 + 56))(v2, *(this + 59), *(this + 60));
  *(*(*(this + 3) + 168) + 40) = *(*(*(this + 3) + 168) + 112);
  md::ARWalkingLabeler::{unnamed type#4}::~ARWalkingLabeler(this + 1976);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 1936);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 1896);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 1840);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 227);
  v3 = *(this + 217);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  *(this + 212) = &unk_1F2A580C8;

  v4 = *(this + 211);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 1568);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 1488);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(this + 1408);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(this + 1328);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(this + 1248);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(this + 1168);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(this + 1088);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 1008);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(this + 928);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 848);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 768);
  md::Monitorable<md::Transformable<md::ConfigValue<GEOConfigKeyDouble,double>>>::~Monitorable(this + 648);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 568);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(this + 488);
  v5 = *(this + 58);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::unique_ptr<md::LabelExternalMeshModerator>::~unique_ptr[abi:nn200100](this + 56);
  std::unique_ptr<md::ARWalkingSupport>::~unique_ptr[abi:nn200100](this + 55);

  md::StandardLabeler::~StandardLabeler(this);
}

void sub_1B32F4960(_Unwind_Exception *a1)
{
  md::ARWalkingLabeler::{unnamed type#4}::~ARWalkingLabeler(v1 + 1976);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(v1 + 1936);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(v1 + 1896);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(v1 + 1840);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear((v1 + 1816));
  v3 = *(v1 + 1736);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  *(v1 + 1696) = &unk_1F2A580C8;

  v4 = *(v1 + 1688);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 1568);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 1488);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 1408);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 1328);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(v1 + 1248);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(v1 + 1168);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 1088);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 1008);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 928);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 848);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 768);
  md::Monitorable<md::Transformable<md::ConfigValue<GEOConfigKeyDouble,double>>>::~Monitorable(v1 + 648);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 568);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v1 + 488);
  v5 = *(v1 + 464);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::unique_ptr<md::LabelExternalMeshModerator>::~unique_ptr[abi:nn200100]((v1 + 448));
  std::unique_ptr<md::ARWalkingSupport>::~unique_ptr[abi:nn200100]((v1 + 440));
  md::StandardLabeler::~StandardLabeler(v1);
  _Unwind_Resume(a1);
}

uint64_t md::ARWalkingLabeler::{unnamed type#4}::~ARWalkingLabeler(uint64_t a1)
{
  v2 = *(a1 + 280);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(a1 + 240);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  if (*(a1 + 200))
  {
    std::vector<std::pair<std::bitset<2ul>,std::shared_ptr<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>>>>>::clear[abi:nn200100]((a1 + 200));
    operator delete(*(a1 + 200));
  }

  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(a1 + 144);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear((a1 + 120));
  *(a1 + 72) = &unk_1F2A580E8;

  v5 = (a1 + 48);
  std::vector<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  *(a1 + 16) = &unk_1F2A580C8;

  return a1;
}

uint64_t md::Monitorable<md::Transformable<md::ConfigValue<GEOConfigKeyDouble,double>>>::~Monitorable(uint64_t a1)
{
  if (*(a1 + 64))
  {
    GEOConfigRemoveBlockListener();
    v2 = *(a1 + 64);
    *(a1 + 64) = 0;
  }

  atomic_store(0, *(a1 + 72));
  std::__function::__value_func<void ()(double)>::~__value_func[abi:nn200100](a1 + 88);
  v3 = *(a1 + 80);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  std::__function::__value_func<double ()(double const&)>::~__value_func[abi:nn200100](a1 + 32);
  return a1;
}

void sub_1B32F4BA0(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(double)>::~__value_func[abi:nn200100](v1 + 88);
  v3 = *(v1 + 80);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  std::__function::__value_func<double ()(double const&)>::~__value_func[abi:nn200100](v1 + 32);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<md::ARWalkingSupport>::~unique_ptr[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__hash_table<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::allocator<geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::~__hash_table(v2 + 904);
    std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v2 + 848));
    std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::allocator_adapter<std::shared_ptr<md::LabelMapTile>,mdm::zone_mallocator>>::~__hash_table(v2 + 784);
    v3 = *(v2 + 776);
    *(v2 + 776) = 0;
    if (v3)
    {
      md::HighPrecisionAltitudeRequestor::~HighPrecisionAltitudeRequestor(v3);
      MEMORY[0x1B8C62190]();
    }

    md::ARWalkingFeatureSet::~ARWalkingFeatureSet((v2 + 440));
    if (*(v2 + 432) == 1)
    {
      md::ARWalkingFeatureSet::~ARWalkingFeatureSet((v2 + 96));
    }

    if (*(v2 + 88) == 1)
    {
      *(v2 + 56) = &unk_1F2A3ED40;
    }

    MEMORY[0x1B8C62190](v2, 0x10A2C40356C2218);
  }

  return a1;
}

void std::vector<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 40;
        std::__destroy_at[abi:nn200100]<std::pair<std::shared_ptr<md::LabelFeature>,std::vector<md::ARWalkingLabelDebugData>>,0>(v4);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

uint64_t ARStringForFeature(_BYTE *a1, void *a2)
{
  v30 = *MEMORY[0x1E69E9840];
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v22);
  v4 = (*(**a2 + 264))(*a2);
  if (v4 > 0x1B)
  {
    v5 = "";
  }

  else
  {
    v5 = off_1E7B35C80[v4];
  }

  std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::basic_string[abi:nn200100]<0>(v28, v5);
  if ((v29 & 0x80u) == 0)
  {
    v6 = v28;
  }

  else
  {
    v6 = v28[0];
  }

  if ((v29 & 0x80u) == 0)
  {
    v7 = v29;
  }

  else
  {
    v7 = v28[1];
  }

  v8 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, v6, v7);
  if (v29 < 0)
  {
    v9 = v28[0];
    v10 = mdm::zone_mallocator::instance(v8);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v10, v9);
  }

  v11 = (*(**a2 + 264))(*a2);
  v12 = *a2;
  if (v11 == 24)
  {
    v13 = v12[90];
    md::LabelExternalPointFeature::incident(v13);
    v14 = [objc_claimAutoreleasedReturnValue() displayText];
LABEL_16:
    v15 = v14;

    if (v15)
    {
      v16 = v15;
    }

    else
    {
      v16 = @"<NOTEXT>";
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, ":", 1);
    v17 = v16;
    v18 = [(__CFString *)v16 UTF8String];
    v19 = strlen(v18);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, v18, v19);
    goto LABEL_21;
  }

  if ((*(*v12 + 264))(v12) == 26)
  {
    v13 = *(*a2 + 200);
    md::LabelExternalPointFeature::incident(v13);
    v14 = [objc_claimAutoreleasedReturnValue() displayText];
    goto LABEL_16;
  }

  v16 = 0;
LABEL_21:
  std::stringbuf::str[abi:nn200100](a1, &v24);

  v22[0] = *MEMORY[0x1E69E54D8];
  v20 = *(MEMORY[0x1E69E54D8] + 72);
  *(v22 + *(v22[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v23 = v20;
  v24 = MEMORY[0x1E69E5548] + 16;
  if (v26 < 0)
  {
    operator delete(v25[7].__locale_);
  }

  v24 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v25);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v27);
}

void sub_1B32F5084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28)
{
  a9 = *MEMORY[0x1E69E54D8];
  v30 = *(MEMORY[0x1E69E54D8] + 72);
  *(&a9 + *(a9 - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  a11 = v30;
  a12 = MEMORY[0x1E69E5548] + 16;
  if (a25 < 0)
  {
    operator delete(__p);
  }

  a12 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a13);
  std::iostream::~basic_iostream();
  MEMORY[0x1B8C620C0](&a28);
  _Unwind_Resume(a1);
}

uint64_t geo::MarkedLRUCache<md::Label *,gm::Matrix<double,3,1>,std::hash<md::Label *>,std::equal_to<md::Label *>>::MarkedLRUCache(uint64_t a1)
{
  *a1 = a1;
  *(a1 + 8) = a1;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0;
  *(a1 + 56) = 1065353216;
  *(a1 + 64) = 0;
  *(a1 + 72) = 0;
  std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__rehash<true>(a1 + 24, 0);
  *(a1 + 64) = a1;
  return a1;
}

void sub_1B32F5244(_Unwind_Exception *a1)
{
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table((v1 + 3));
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(v1);
  _Unwind_Resume(a1);
}

void md::Transformable<md::ConfigValue<GEOConfigKeyDouble,double>>::update(uint64_t a1)
{
  if (*a1)
  {
    v2 = *(a1 + 8) == 0;
  }

  else
  {
    v2 = 1;
  }

  if (!v2)
  {
    GEOConfigGetDouble();
    *(a1 + 16) = v3;
  }

  v4 = *(a1 + 56);
  if (v4)
  {
    *(a1 + 24) = (*(*v4 + 48))(v4, a1 + 16);
  }

  else
  {
    v5 = std::__throw_bad_function_call[abi:nn200100]();
    std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_10,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_10>,void ()(double)>::operator()(v5);
  }
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_10,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_10>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58428;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_9,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_9>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A583E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_8,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_8>,void ()(BOOL)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58398;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_7,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_7>,void ()(unsigned int)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58350;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_6,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_6>,void ()(unsigned int)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58308;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_5,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_5>,void ()(BOOL)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A582C0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_4,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_4>,void ()(double)>::operator()(uint64_t a1)
{
  v1 = *(a1 + 8);
  v2 = *(v1 + 440);
  v3 = *(v1 + 1024);
  md::ARWalkingSupport::setHighPrecisionAltitudeDistanceThreshold(v2, &v3);
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_4,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_4>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58278;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_3,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_3>,void ()(BOOL)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A58230;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_2,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_2>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A581E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_1,std::allocator<md::ARWalkingLabeler::initializeEvaluationConstants(void)::$_1>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A581A0;
  a2[1] = v2;
  return result;
}

uint64_t ___ZN2md11MonitorableINS_13TransformableINS_11ConfigValueI18GEOConfigKeyDoubledEEEEE16setCallbackQueueEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFvdEEE_block_invoke(uint64_t result)
{
  v1 = *(result + 40);
  if (v1)
  {
    v2 = *(result + 32);
    if (*v1)
    {
      v3 = *(v2 + 24);
      md::Transformable<md::ConfigValue<GEOConfigKeyDouble,double>>::update(*(result + 32));
      result = *(v2 + 112);
      if (result)
      {

        return std::function<void ()(double)>::operator()(result, v3);
      }
    }
  }

  return result;
}

float md::GlobeClipPlane(double a1, double a2, double a3)
{
  v3 = 0;
  *v14 = a1;
  *&v14[1] = a2;
  *&v14[2] = a3;
  v4 = 0.0;
  do
  {
    v4 = v4 + *&v14[v3] * *&v14[v3];
    ++v3;
  }

  while (v3 != 3);
  v5 = gm::Matrix<double,3,1>::normalized<int,void>(v14);
  v6 = 0;
  *v12 = v5;
  v12[1] = v7;
  v12[2] = v8;
  do
  {
    v9 = *&v12[v6];
    *(&v13 + v6++) = v9;
  }

  while (v6 != 3);
  v10 = asin(194259.118 / sqrt(v4));
  cos(1.3962634 - v10);
  return v13;
}

void md::splitRoadSectionByZ(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, float a6, float a7)
{
  v13 = a5;
  v14.n128_f64[0] = vabds_f32(a7, a6);
  if (v14.n128_f64[0] >= 1.0e-10)
  {
    v26 = v13;
    v14.n128_f32[0] = fminf(a6, a7);
    v15 = fmaxf(a6, a7);
    if (a4)
    {
      v16 = 0;
      v17 = 0;
      v18 = vcvtms_u32_f32(v14.n128_f32[0]);
      v19 = (a3 + 20);
      while (*(v19 - 2) <= v18)
      {
        if (*(v19 + 9) == 1)
        {
          v17 = *v19;
        }

        ++v16;
        v19 += 25;
        if (a4 == v16)
        {
          goto LABEL_20;
        }
      }
    }

    else
    {
      v17 = 0;
      LODWORD(v16) = 0;
    }

    v20 = a4 >= v16;
    v21 = a4 - v16;
    if (v21 != 0 && v20)
    {
      v22 = vcvtps_u32_f32(v15);
      v23 = (a3 + 100 * v16 + 20);
      while (1)
      {
        v24 = *(v23 - 2);
        if (v24 >= v22)
        {
          break;
        }

        if (*(v23 + 9) == 1 && *v23 != v17)
        {
          v25 = v24;
          v13[2](v14, v24);
          v17 = *v23;
          v13 = v26;
        }

        else
        {
          v25 = v14.n128_f32[0];
        }

        v23 += 25;
        v14.n128_f32[0] = v25;
        if (!--v21)
        {
          goto LABEL_21;
        }
      }
    }

LABEL_20:
    v25 = v14.n128_f32[0];
LABEL_21:
    (v13[2])(v13, v17, a1, a2, a6 > a7, v25, v15);
    v13 = v26;
  }
}

std::mutex *md::DaVinciNavigationMapEngineMode::willBecomeInactive(uint64_t a1, uint64_t a2)
{
  md::DaVinciBaseMapEngineMode::willBecomeInactive(a1, a2);
  v3 = *(a2 + 41928);
  v4 = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v3 + 16), 0x2FED70A4459DFCA1uLL);
  if (v4)
  {
    v5 = v4[5];
    if (v5)
    {
      md::StyleLogic::setMapMode(v5, 0, 0.0);
      v3 = *(a2 + 41928);
    }
  }

  v6 = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v3 + 16), 0xDAD5CEE0DC5FF509);
  if (v6)
  {
    v7 = v6[5];
    if (v7)
    {
      *(v7 + 168) = 0;
    }
  }

  result = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v3 + 16), 0x20A1ED17D78F322BuLL);
  if (result)
  {
    v9 = *&result->__m_.__opaque[32];
    if (v9)
    {
      v10 = *(v9 + 160);

      return md::LabelManager::setLabelMode(v10, 1);
    }
  }

  return result;
}

std::mutex *md::DaVinciNavigationMapEngineMode::didBecomeActive(__n128 *a1, md::MapEngine *a2, uint64_t a3, uint64_t *a4)
{
  md::DaVinciBaseMapEngineMode::didBecomeActive(a1, a2, a3, a4);
  v5 = *(a2 + 5241);
  v6 = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v5 + 16), 0x2FED70A4459DFCA1uLL);
  if (v6)
  {
    v7 = v6[5];
    if (v7)
    {
      md::StyleLogic::setMapMode(v7, 3, 0.0);
      v5 = *(a2 + 5241);
    }
  }

  v8 = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v5 + 16), 0xDAD5CEE0DC5FF509);
  if (v8)
  {
    v9 = v8[5];
    if (v9)
    {
      *(v9 + 168) = 1;
    }
  }

  result = std::unordered_map<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>::find[abi:nn200100]((v5 + 16), 0x20A1ED17D78F322BuLL);
  if (result)
  {
    v11 = *&result->__m_.__opaque[32];
    if (v11)
    {
      v12 = *(v11 + 160);

      return md::LabelManager::setLabelMode(v12, 2);
    }
  }

  return result;
}

void md::DaVinciNavigationMapEngineMode::~DaVinciNavigationMapEngineMode(md::DaVinciNavigationMapEngineMode *this)
{
  *this = &unk_1F2A58888;
  v2 = *(this + 82);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  md::MapEngineMode::~MapEngineMode(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A58888;
  v2 = *(this + 82);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  md::MapEngineMode::~MapEngineMode(this);
}

void md::DaVinciNavigationMapEngineMode::DaVinciNavigationMapEngineMode(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  v7[4] = *MEMORY[0x1E69E9840];
  v7[0] = a3;
  v7[1] = a4;
  if (a4)
  {
    atomic_fetch_add_explicit((a4 + 8), 1uLL, memory_order_relaxed);
  }

  IsEnabled_VKMLayout_Navigation = MapsFeature_IsEnabled_VKMLayout_Navigation();
  md::DaVinciBaseMapEngineMode::DaVinciBaseMapEngineMode(a1, 11, a2, v7, IsEnabled_VKMLayout_Navigation);
}

void sub_1B32F6164(_Unwind_Exception *a1)
{
  *v1 = &unk_1F2A58888;
  v3 = *(v1 + 82);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void sub_1B32F61B4()
{
  if (v0)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v0);
  }

  JUMPOUT(0x1B32F61ACLL);
}

void ggl::VSLibrary::~VSLibrary(ggl::VSLibrary *this)
{
  ggl::ShaderLibrary::~ShaderLibrary(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::VSLibraryBundleMTLData::~VSLibraryBundleMTLData(ggl::VSLibraryBundleMTLData *this)
{
  ggl::MTLBundleShaderLibraryData::~MTLBundleShaderLibraryData(this);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::MarkerFeatureHandle::MarkerFeatureHandle(uint64_t a1, unint64_t a2, int a3)
{
  *(a1 + 16) = 255;
  *(a1 + 20) = 0;
  *(a1 + 24) = 0;
  *(a1 + 32) = 0;
  *(a1 + 40) = 1;
  *(a1 + 56) = 0;
  *(a1 + 64) = 0;
  v6 = *(a2 + 8);
  if (v6)
  {
    v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      v8 = *a2;
      goto LABEL_6;
    }
  }

  else
  {
    v7 = 0;
  }

  v8 = 0;
LABEL_6:
  v9 = geo::codec::VectorTile::key(v8);
  v10 = *(v9 + 8);
  v36 = *v9;
  LOWORD(v37) = v10;
  BYTE2(v37) = *(v9 + 10);
  v11 = GEOTileKeyMake();
  *&v35 = v11;
  *(&v35 + 1) = v12;
  v13 = *(&v35 + 6) >> 6;
  *(a1 + 16) = -1;
  *(a1 + 17) = BYTE6(v11) & 0x3F;
  *(a1 + 20) = (v12 >> 16) & 0x3FFFFFF;
  *(a1 + 24) = v13;
  *(a1 + 32) = 0;
  *(a1 + 40) = 1;
  *(a1 + 48) = (v12 >> 42) & 0x3FFF;
  v14 = [MEMORY[0x1E69A2478] modernManager];
  v15 = [v14 activeTileGroup];
  *(a1 + 52) = [v15 versionForTileKey:&v35];

  v17 = *(a2 + 24);
  v16 = *(a2 + 32);
  if (v16)
  {
    atomic_fetch_add_explicit((v16 + 8), 1uLL, memory_order_relaxed);
  }

  v18 = *(a1 + 64);
  *(a1 + 56) = v17;
  *(a1 + 64) = v16;
  if (v18)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v18);
  }

  *a1 = a3;
  *(a1 + 8) = -1;
  if (a3 <= 10)
  {
    if (a3 <= 7)
    {
      if (a3 != 1)
      {
        if (a3 != 2)
        {
          goto LABEL_43;
        }

        goto LABEL_23;
      }

      v27 = *(v8 + 63);
      v28 = geo::codec::VectorTile::poisCount(v27, *(v8 + 64));
      if (v27 > a2 || v27 + 224 * v28 <= a2)
      {
        goto LABEL_40;
      }

      v21 = (a2 - v27) >> 5;
      v22 = 0x6DB6DB6DB6DB6DB7;
LABEL_38:
      v31 = v21 * v22;
LABEL_39:
      *(a1 + 8) = v31;
      goto LABEL_40;
    }

    if (a3 != 8)
    {
      if (a3 != 9)
      {
        goto LABEL_43;
      }

      goto LABEL_29;
    }

LABEL_26:
    v23 = *(v8 + 177);
    v24 = geo::codec::VectorTile::transitNodeCount(v23, *(v8 + 178));
    if (v23 > a2 || v23 + 344 * v24 <= a2)
    {
      goto LABEL_40;
    }

    v21 = (a2 - v23) >> 3;
    v22 = 0x82FA0BE82FA0BE83;
    goto LABEL_38;
  }

  if (a3 <= 12)
  {
    if (a3 == 11)
    {
      v29 = *(v8 + 196);
      v30 = geo::codec::VectorTile::transitAccessPointCount(v29, *(v8 + 197));
      if (v29 > a2 || v29 + 248 * v30 <= a2)
      {
        goto LABEL_40;
      }

      v21 = (a2 - v29) >> 3;
      v22 = 0xEF7BDEF7BDEF7BDFLL;
      goto LABEL_38;
    }

    goto LABEL_26;
  }

  if (a3 == 13)
  {
LABEL_29:
    v25 = *(v8 + 161);
    v26 = geo::codec::VectorTile::coastlinesCount(v25, *(v8 + 162));
    if (v25 > a2 || v25 + 104 * v26 <= a2)
    {
      goto LABEL_40;
    }

    v21 = (a2 - v25) >> 3;
    v22 = 0x4EC4EC4EC4EC4EC5;
    goto LABEL_38;
  }

  if (a3 == 19)
  {
LABEL_23:
    v19 = *(v8 + 4);
    v20 = geo::codec::VectorTile::linesCount(v19, *(v8 + 5));
    if (v19 > a2 || v19 + 168 * v20 <= a2)
    {
      goto LABEL_40;
    }

    v21 = (a2 - v19) >> 3;
    v22 = 0xCF3CF3CF3CF3CF3DLL;
    goto LABEL_38;
  }

LABEL_43:
  v33 = *(v8 + 12);
  v34 = geo::codec::VectorTile::polygonsCount(v33, *(v8 + 13));
  if (v33 <= a2 && v33 + 128 * v34 > a2)
  {
    *a1 = 0;
    v31 = (a2 - v33) >> 7;
    goto LABEL_39;
  }

LABEL_40:
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  return a1;
}

void sub_1B32F65B4(_Unwind_Exception *a1)
{
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v6 = *(v1 + 64);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::RouteLine::DefaultVbo>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::RouteLine::DefaultVbo>,ggl::zone_mallocator>>::__on_zero_shared_weak(ggl::zone_mallocator *a1)
{
  v2 = ggl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v2, a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::RouteLine::DefaultVbo>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::RouteLine::DefaultVbo>,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58AE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::RouteLine::BaseMesh::~BaseMesh(ggl::RouteLine::BaseMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void ggl::RouteLine::BaseMesh::~BaseMesh(ggl::RouteLine::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::MeshTyped<ggl::RouteLine::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::RouteLine::BasePipelineSetup::~BasePipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::RouteLine::PatternedBasePipelineSetup::~PatternedBasePipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::RouteLine::RouteLineMaskPipelineSetup::~RouteLineMaskPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void md::DaVinciMetaLayerDataSource::createLayerData(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  gdc::LayerDataSource::getResourceFromMap(__p, 29, *a3, a3[1]);
  v4 = __p[0];
  v3 = __p[1];
  if (__p[1])
  {
    atomic_fetch_add_explicit(__p[1] + 1, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  if (v4)
  {
    if (*(v4[18] + 2248))
    {
      operator new();
    }
  }

  operator new();
}

void sub_1B32F6F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  v19 = *v17;
  if (*v17)
  {
    v13[34].__vftable = v19;
    operator delete(v19);
  }

  if (*v16)
  {
    operator delete(*v16);
  }

  if (*v15)
  {
    operator delete(*v15);
  }

  md::MapTileData::~MapTileData(v14);
  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v20);
  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v12);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::DaVinciMetaTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58C00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::DaVinciMetaLayerDataSource::~DaVinciMetaLayerDataSource(md::DaVinciMetaLayerDataSource *this)
{
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::RouteLineArrow::BaseMesh::~BaseMesh(ggl::RouteLineArrow::BaseMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void ggl::RouteLineArrow::BaseMesh::~BaseMesh(ggl::RouteLineArrow::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection()
{
  {
    {
      ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::attributesReflection(void)::r = &ggl::RouteLineArrow::defaultVboReflection;
    }

    ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection(void)::r = &ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::attributesReflection(void)::r;
    unk_1EB829600 = 1;
  }
}

void non-virtual thunk toggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::RouteLineArrow::BasePipelineState::~BasePipelineState(ggl::RouteLineArrow::BasePipelineState *this)
{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

void ggl::RouteLineArrow::BasePipelineSetup::typedReflection(ggl::RouteLineArrow::BasePipelineSetup *this)
{
  {
    ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection();
    ggl::RouteLineArrow::BasePipelineSetup::typedReflection(void)::ref = &ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection(void)::r;
    *algn_1EB829C68 = &ggl::RouteLineArrow::pipelineDataBasePipelineDeviceStructs(void)::ref;
    qword_1EB829C70 = 0;
    {
      ggl::RouteLineArrow::pipelineDataBasePipelineConstantStructs(void)::ref = ggl::Tile::View::reflection(void)::reflection;
      unk_1EB829C50 = ggl::Tile::Transform::reflection(void)::reflection;
      qword_1EB829C58 = ggl::RouteLineArrow::Style::reflection(void)::reflection;
    }

    qword_1EB829C78 = &ggl::RouteLineArrow::pipelineDataBasePipelineConstantStructs(void)::ref;
    unk_1EB829C80 = xmmword_1B33B07A0;
  }
}

void ggl::RouteLineArrow::BasePipelineSetup::~BasePipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void md::mun::MuninSelectionContext::~MuninSelectionContext(md::mun::MuninSelectionContext *this)
{
  *this = &unk_1F2A58D50;
  v2 = *(this + 10);
  if (v2)
  {
    *(this + 11) = v2;
    operator delete(v2);
  }

  *this = &unk_1F2A61128;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 16);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A58D50;
  v2 = *(this + 10);
  if (v2)
  {
    *(this + 11) = v2;
    operator delete(v2);
  }

  *this = &unk_1F2A61128;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 16);
}

float geo::fromLinear<float,4,(geo::ColorSpace)5,int,void>::operator()(gm::Matrix<float,4,1> const&)const::{lambda(gm::Matrix<float,4,1> const&)#1}::operator()(uint64_t a1)
{
  v2 = 0;
  v3 = *(a1 + 8);
  *&v35[0] = *a1;
  DWORD2(v35[0]) = v3;
  v4 = 0;
  do
  {
    *v4.i32 = *v4.i32 + (*&dword_1B34184D4[v2] * *(v35 + v2 * 4));
    ++v2;
  }

  while (v2 != 3);
  v5 = 0;
  v6 = 0;
  do
  {
    v6.f32[0] = v6.f32[0] + (*&dword_1B34184D4[v5 + 3] * *(v35 + v5 * 4));
    ++v5;
  }

  while (v5 != 3);
  v7 = 0;
  v8 = 0.0;
  do
  {
    v8 = v8 + (*&dword_1B34184D4[v7 + 6] * *(v35 + v7 * 4));
    ++v7;
  }

  while (v7 != 3);
  v9 = __PAIR64__(v6.u32[0], v4.u32[0]);
  *v4.i32 = (*v4.i32 + (v6.f32[0] * 15.0)) + (v8 * 3.0);
  v10 = vdiv_f32(vmul_f32(v9, 0x4110000040800000), vdup_lane_s32(v4, 0));
  if (v6.f32[0] <= 0.00886)
  {
    v1.f32[0] = v6.f32[0] * 903.29;
  }

  else
  {
    v1.f32[0] = (cbrtf(v6.f32[0]) * 116.0) + -16.0;
  }

  v6.i32[0] = 953267991;
  v11 = vand_s8(vmul_n_f32(vadd_f32(v10, 0xBEEFC7A4BE4A93F3), v1.f32[0] * 13.0), vdup_lane_s32(vmvn_s8(vcgt_f32(v6, v1)), 0));
  v12 = sqrtf(vaddv_f32(vmul_f32(v11, v11)));
  v13 = 0.0;
  if (v12 >= 0.00001)
  {
    v13 = atan2f(v11.f32[1], v11.f32[0]) * 57.296;
  }

  v14 = fmodf(v13, 360.0);
  v15 = fmodf(v14 + 360.0, 360.0);
  if (v1.f32[0] <= 99.999 && v1.f32[0] >= 0.00001)
  {
    v17 = 0;
    memset(v35, 0, sizeof(v35));
    v18 = ((v1.f32[0] + 16.0) * (v1.f32[0] + 16.0)) * (0.00000064066 * (v1.f32[0] + 16.0));
    if (v18 <= 0.00886)
    {
      v18 = v1.f32[0] * 0.0011071;
    }

    do
    {
      v19 = 0;
      v20 = &dword_1B34184F8[3 * v17];
      v22 = v20[1];
      v21 = v20[2];
      v23 = ((v21 * -94839.0) + (*v20 * 284520.0)) * v18;
      v24 = ((v22 * -126450.0) + (v21 * 632260.0)) * v18;
      v25 = ((*v20 * ((v18 * v1.f32[0]) * 731720.0)) + (v21 * ((v18 * v1.f32[0]) * 838420.0))) + (v22 * ((v18 * v1.f32[0]) * 769860.0));
      v26 = 1;
      do
      {
        v27 = v26;
        *v16.i32 = v24 + (126452 * v19);
        v28.f32[0] = v23;
        v28.f32[1] = v25 - ((v1.f32[0] * 769860.0) * v19);
        *(v35 + (v19 | (2 * v17))) = vdiv_f32(v28, vdup_lane_s32(v16, 0));
        v19 = 1;
        v26 = 0;
      }

      while ((v27 & 1) != 0);
      ++v17;
    }

    while (v17 != 3);
    v29 = __sincosf_stret(v15 * 0.017453);
    v30 = 0;
    v31 = 3.4028e38;
    do
    {
      v32 = *(v35 + v30 + 4) / (v29.__sinval - (*(v35 + v30) * v29.__cosval));
      if (v32 >= 0.0 && v32 < v31)
      {
        v31 = *(v35 + v30 + 4) / (v29.__sinval - (*(v35 + v30) * v29.__cosval));
      }

      v30 += 8;
    }

    while (v30 != 48);
  }

  if (v12 >= 0.00001)
  {
    v33 = v15;
  }

  else
  {
    v33 = 0.0;
  }

  return fminf(fmaxf(v33, 0.0), 360.0);
}

float geo::toLinear<float,4,(geo::ColorSpace)5,int,void>::operator()(gm::Matrix<float,4,1> const&)const::{lambda(gm::Matrix<float,4,1> const&)#1}::operator()(float *a1)
{
  v1 = a1[1];
  v2 = a1[2];
  v3 = fmodf(*a1, 360.0);
  v4 = fmodf(v3 + 360.0, 360.0);
  v6 = 0.0;
  v7 = fminf(fmaxf(v1, 0.0), 100.0);
  v8 = fmaxf(v2, 0.0);
  v9 = fminf(v8, 100.0);
  v10 = 0.0;
  if (v9 <= 99.999 && v9 >= 0.00001)
  {
    v11 = 0;
    memset(v41, 0, sizeof(v41));
    v12 = ((v9 + 16.0) * (v9 + 16.0)) * (0.00000064066 * (v9 + 16.0));
    if (v12 <= 0.00886)
    {
      v12 = v9 * 0.0011071;
    }

    do
    {
      v13 = 0;
      v14 = &dword_1B34184F8[3 * v11];
      v16 = v14[1];
      v15 = v14[2];
      v17 = ((v15 * -94839.0) + (*v14 * 284520.0)) * v12;
      v18 = ((v16 * -126450.0) + (v15 * 632260.0)) * v12;
      v19 = ((*v14 * ((v12 * v9) * 731720.0)) + (v15 * ((v12 * v9) * 838420.0))) + (v16 * ((v12 * v9) * 769860.0));
      v20 = 1;
      do
      {
        v21 = v20;
        *v5.i32 = v18 + (126452 * v13);
        v22.f32[0] = v17;
        v22.f32[1] = v19 - ((v9 * 769860.0) * v13);
        *(v41 + (v13 | (2 * v11))) = vdiv_f32(v22, vdup_lane_s32(v5, 0));
        v13 = 1;
        v20 = 0;
      }

      while ((v21 & 1) != 0);
      ++v11;
    }

    while (v11 != 3);
    v23 = __sincosf_stret(v4 * 0.017453);
    v24 = 0;
    v25 = 3.4028e38;
    do
    {
      v26 = v23.__sinval - (*(v41 + v24) * v23.__cosval);
      if ((*(v41 + v24 + 4) / v26) >= 0.0 && (*(v41 + v24 + 4) / v26) < v25)
      {
        v25 = *(v41 + v24 + 4) / v26;
      }

      v24 += 8;
    }

    while (v24 != 48);
    v10 = (v7 * 0.01) * v25;
  }

  v27 = (v2 >= 0.0) & (fabsf(v2) > 0.0001);
  v28 = v8 <= 100.0 && v27 == 0;
  v29 = 0.0;
  v30 = 0.0;
  if (!v28)
  {
    v31 = v4 * 0.017453;
    if (v7 < 0.00001)
    {
      v31 = 0.0;
    }

    v32 = __sincosf_stret(v31);
    v33 = ((v10 * v32.__sinval) / (v9 * 13.0)) + 0.46832;
    if (v9 <= 8.0)
    {
      v29 = v9 * 0.0011071;
    }

    else
    {
      v29 = ((v9 * 0.0086207) + 0.13793) * (((v9 * 0.0086207) + 0.13793) * ((v9 * 0.0086207) + 0.13793));
    }

    v6 = ((v29 * 9.0) * (-0.19783 - ((v10 * v32.__cosval) / (v9 * 13.0)))) / (v33 * -4.0);
    v30 = ((v29 * 9.0) - ((v6 + (v29 * 15.0)) * v33)) / (v33 * 3.0);
  }

  v34 = 0;
  *&v41[0] = __PAIR64__(LODWORD(v29), LODWORD(v6));
  v35 = 0.0;
  *(v41 + 2) = v30;
  do
  {
    v35 = v35 + (*&dword_1B34184F8[v34] * *(v41 + v34 * 4));
    ++v34;
  }

  while (v34 != 3);
  v36 = 0;
  v37 = 0.0;
  do
  {
    v37 = v37 + (*&dword_1B34184F8[v36 + 3] * *(v41 + v36 * 4));
    ++v36;
  }

  while (v36 != 3);
  v38 = 0;
  v39 = 0.0;
  do
  {
    v39 = v39 + (*&dword_1B34184F8[v38 + 6] * *(v41 + v38 * 4));
    ++v38;
  }

  while (v38 != 3);
  return fminf(fmaxf(v35, 0.0), 1.0);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>>>::__erase_unique<unsigned long long>(void *a1, unint64_t a2)
{
  v3 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>(a1, a2);
  if (v3)
  {

    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>>>::erase(a1, v3);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>>>::erase(void *a1, void *a2)
{
  v2 = a1[1];
  v3 = a2[1];
  v4 = vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *&v2)
    {
      v3 %= *&v2;
    }
  }

  else
  {
    v3 &= *&v2 - 1;
  }

  v5 = *(*a1 + 8 * v3);
  do
  {
    v6 = v5;
    v5 = *v5;
  }

  while (v5 != a2);
  if (v6 == a1 + 2)
  {
    goto LABEL_18;
  }

  v7 = v6[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v7 >= *&v2)
    {
      v7 %= *&v2;
    }
  }

  else
  {
    v7 &= *&v2 - 1;
  }

  if (v7 != v3)
  {
LABEL_18:
    if (!*a2)
    {
      goto LABEL_19;
    }

    v8 = *(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *&v2)
      {
        v8 %= *&v2;
      }
    }

    else
    {
      v8 &= *&v2 - 1;
    }

    if (v8 != v3)
    {
LABEL_19:
      *(*a1 + 8 * v3) = 0;
    }
  }

  v9 = *a2;
  if (*a2)
  {
    v10 = *(v9 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v10 >= *&v2)
      {
        v10 %= *&v2;
      }
    }

    else
    {
      v10 &= *&v2 - 1;
    }

    if (v10 != v3)
    {
      *(*a1 + 8 * v10) = v6;
      v9 = *a2;
    }
  }

  *v6 = v9;
  *a2 = 0;
  --a1[3];
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>::operator()[abi:nn200100](1, a2);
}

uint64_t *md::TransitNodeFeaturePool::clearCommandBuffer(md::TransitNodeFeaturePool *this, md::FrameGraph **a2)
{
  v3 = *(*(this + 37) + 8);
  v4 = *(*(md::FrameGraph::renderQueueForPass(a2[1], *(v3 + 220)) + 16) + 8 * *(v3 + 221));
  ggl::CommandBuffer::clearRenderItems(v4);
  *(v4 + 32) = 0;

  return std::unique_ptr<md::TransitNodeTextureAtlas>::reset[abi:nn200100](this + 16, 0);
}

uint64_t *md::TransitNodeFeaturePool::renderIcons(md::TransitNodeFeaturePool *a1, uint64_t **a2, uint64_t a3, md::FrameGraph **a4)
{
  v172 = *MEMORY[0x1E69E9840];
  result = md::TransitNodeFeaturePool::clearCommandBuffer(a1, a4);
  v10 = *a2;
  v9 = a2[1];
  if (*a2 != v9)
  {
    v11 = *(*(a1 + 37) + 8);
    v12 = md::FrameGraph::renderQueueForPass(a4[1], *(v11 + 220));
    if (v12)
    {
      v13 = *(*(v12 + 16) + 8 * *(v11 + 221));
    }

    else
    {
      v13 = 0;
    }

    v14 = md::LayoutContext::get<md::CameraContext>(*(a3 + 8));
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v168 = 0u;
    v169 = 0u;
    v19 = v9 - v10;
    if (v19 <= 1)
    {
      v19 = 1;
    }

    do
    {
      v20 = *v10;
      v21 = *(*v10 + 260);
      if (*(*v10 + 260))
      {
        if (v21 == 1)
        {
          v17 -= 0x3333333333333333 * ((*(v20 + 112) - *(v20 + 104)) >> 2);
        }

        else if (v21 == 2)
        {
          ++v16;
          v15 += *(v20 + 262);
        }
      }

      else
      {
        v18 -= 0x3333333333333333 * ((*(v20 + 112) - *(v20 + 104)) >> 2);
      }

      ++v10;
      --v19;
    }

    while (v19);
    *&v169 = v17;
    *(&v169 + 1) = v18;
    *&v168 = v15;
    *(&v168 + 1) = v16;
    if (v17 <= v18)
    {
      v22 = v18;
    }

    else
    {
      v22 = v17;
    }

    if (v22 | v16)
    {
      [*a3 sizeInPixels];
      v159 = v24;
      v161 = v23;
      v25 = *(a1 + 25);
      ggl::BufferMemory::BufferMemory(v163);
      ggl::ResourceAccessor::accessConstantData(v170, 0, v25, 1);
      ggl::BufferMemory::operator=(v163, v170);
      ggl::BufferMemory::~BufferMemory(v170);
      v26 = v164;
      v27.f64[0] = v161;
      v27.f64[1] = v159;
      __asm { FMOV            V0.2D, #0.5 }

      v164[1] = vcvt_f32_f64(vmulq_f64(v27, _Q0));
      *v26 = vcvt_f32_s32(*(*(a1 + 15) + 40));
      v166 = 0u;
      v167 = 0u;
      v33 = *(a1 + 29);
      if ((*(v33 + 6) - *(v33 + 5)) / *(v33 + 1) < 6 * v22)
      {
        ggl::BufferData::resize(v33, 6 * v22);
        ggl::DataAccess<ggl::DaVinci::TexturedCompressedVbo>::DataAccess(v170, *(a1 + 29), 0, 6 * v22, 1, 0, 0);
        if (v22)
        {
          v34 = 0;
          v35 = 0;
          v36 = v171;
          do
          {
            for (i = 0; i != 6; ++i)
            {
              *v36++ = v35 + PopulateQuadIndexData(std::shared_ptr<ggl::IndexDataTyped<unsigned short>> const&,unsigned long)::vertexOffsets[i];
            }

            ++v34;
            v35 += 4;
          }

          while (v34 != v22);
        }

        ggl::BufferMemory::~BufferMemory(v170);
      }

      v38 = *(a1 + 31);
      if ((*(v38 + 6) - *(v38 + 5)) / *(v38 + 1) < (18 * v16))
      {
        ggl::BufferData::resize(v38, 18 * v16);
        ggl::DataAccess<ggl::DaVinci::TexturedCompressedVbo>::DataAccess(v170, *(a1 + 31), 0, 18 * v16, 1, 0, 0);
        if (v16)
        {
          v39 = 0;
          v40 = 0;
          v41 = v171;
          do
          {
            for (j = 0; j != 18; ++j)
            {
              *v41++ = v40 + PopulatePillIndexData(std::shared_ptr<ggl::IndexDataTyped<unsigned short>> const&,unsigned long)::vertexOffsets[j];
            }

            ++v39;
            v40 += 8;
          }

          while (v39 != v16);
        }

        ggl::BufferMemory::~BufferMemory(v170);
      }

      v158 = v14;
      v155 = a3;
      v156 = a2;
      v43 = 0;
      memset(v165, 0, sizeof(v165));
      v44 = (a1 + 168);
      v160 = a1;
      v162 = (a1 + 136);
      v170[0] = 0x300000002;
      do
      {
        v45 = *(v170 + v43);
        v46 = *(&v168 + v45);
        if (v46)
        {
          v47 = v44[v45];
          v48 = *(a1 + 29);
          v49 = *(a1 + 30);
          if (v49)
          {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v50 = *(v47 + 104);
          *(v47 + 96) = v48;
          *(v47 + 104) = v49;
          if (v50)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v50);
          }

          if (v49)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v49);
          }

          v51 = v162[v45];
          v51[9] = 0;
          v51[10] = 6 * v46;
          v51[11] = 0;
          v51[12] = 1;
          ggl::BufferData::resize(**(v44[v45] + 64), 4 * v46);
          operator new();
        }

        v43 += 4;
      }

      while (v43 != 8);
      v52 = 0;
      v170[0] = 0x100000000;
      do
      {
        v53 = *(v170 + v52);
        v54 = *(&v168 + v53);
        if (v54)
        {
          v55 = v44[v53];
          v56 = *(a1 + 31);
          v57 = *(a1 + 32);
          if (v57)
          {
            atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v58 = *(v55 + 104);
          *(v55 + 96) = v56;
          *(v55 + 104) = v57;
          if (v58)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v58);
          }

          if (v57)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v57);
          }

          v59 = v162[v53];
          v59[9] = 0;
          v59[10] = 18 * v54;
          v59[11] = 0;
          v59[12] = 1;
          ggl::BufferData::resize(**(v44[v53] + 64), 8 * v54);
          operator new();
        }

        v52 += 4;
      }

      while (v52 != 8);
      v60 = *gdc::Camera::heading((v158 + 3800));
      v62 = __sincosf_stret(v60);
      v63 = *a2;
      if (a2[1] != *a2)
      {
        v64 = 0;
        v65 = v166;
        v157 = -v62.__sinval;
        do
        {
          v66 = v63[v64];
          md::LayoutContext::frameState(v155);
          if (*(v66 + 261))
          {
            LOBYTE(v69) = 100;
          }

          else
          {
            v69 = (*(v66 + 12) * 100.0);
          }

          v70 = (*(v66 + 8) * 255.0);
          v67.i32[0] = *(v66 + 16);
          v71 = *(v66 + 260);
          if (v71 == 2)
          {
            v110 = *(v66 + 212);
            v111 = *(v66 + 216);
            v112 = (v62.__sinval * v111) + (v62.__cosval * v110);
            v113 = -((v62.__sinval * v110) - (v111 * v62.__cosval));
            v114 = *(v66 + 24) * *v67.i32;
            v115 = v113 * v114;
            v116 = v112 * v114;
            v117 = (v70 << 24) | 0xFFFFFF;
            v118 = *(&v166 + 1);
            v119 = (v66 + 193);
            v120 = (v66 + 132);
            v121 = 8;
            do
            {
              v122 = *(v120 - 1);
              v123 = (v122 * v115) + (*v120 * v116);
              v124.f32[0] = -((*v120 * v113) - (v122 * v112)) * *v67.i32;
              v124.f32[1] = v123;
              v125 = vadd_f32(v124, *(v66 + 36));
              v126 = *(v119 - 1);
              *v118 = v125;
              v118[1].i32[0] = v117;
              v118[1].i32[1] = v117;
              v118[2].i16[0] = v126;
              v118[2].i8[4] = v69;
              v118[2].i8[5] = 0;
              if (*(v66 + 262) == 1)
              {
                v127 = *(v66 + 208) + *(v119 - 1);
                v128 = *(v66 + 209) + *v119;
                *v65 = vadd_f32(*(v66 + 228), v125);
                v65[1].i32[0] = v117;
                v65[1].i32[1] = v117;
                v65[2].i8[0] = v127;
                v65[2].i8[1] = v128;
                v65[2].i8[4] = v69;
                v65[2].i8[5] = 0;
                v65 += 3;
              }

              v118 += 3;
              v119 += 2;
              v120 += 2;
              --v121;
            }

            while (v121);
            *(&v166 + 1) = v118;
          }

          else
          {
            v72 = *(v61 + 48);
            v68.i32[0] = *(v66 + 20);
            if (v71 == 1)
            {
              v93 = *(v66 + 104);
              v94 = *(v66 + 112);
              if (v93 != v94)
              {
                v95 = (v70 << 24) | 0xFFFFFF;
                v96 = vdup_n_s32(v72);
                v97 = vdup_lane_s32(v67, 0);
                v98 = v66 + 192;
                v99 = vdup_lane_s32(v68, 0);
                v100 = v167;
                v101 = vcltz_s32(vshl_n_s32(v96, 0x1FuLL));
                do
                {
                  v102 = 0;
                  v103 = vmul_n_f32(*v93, v62.__cosval);
                  v104 = vmul_n_f32(vrev64_s32(*v93), v157);
                  v105.i32[0] = vsub_f32(v103, v104).u32[0];
                  v105.i32[1] = vadd_f32(v103, v104).i32[1];
                  v106 = vmla_f32(*(v66 + 36), v97, v105);
                  v107 = vbsl_s8(v101, vrnda_f32(v106), v106);
                  v108 = v100;
                  do
                  {
                    v109 = *(v98 + 2 * v102);
                    *v108 = vmla_f32(v107, v99, *(v98 + 8 * v102 - 64));
                    v100 = v108 + 3;
                    v108[1].i32[0] = v95;
                    v108[1].i32[1] = v95;
                    v108[2].i16[0] = v109;
                    v108[2].i8[4] = v69;
                    v108[2].i8[5] = 0;
                    ++v102;
                    v108 += 3;
                  }

                  while (v102 != 4);
                  v93 = (v93 + 20);
                }

                while (v93 != v94);
                *&v167 = v100;
              }
            }

            else if (!*(v66 + 260))
            {
              v73 = 0;
              v74 = v66 + 192;
              v75 = v70 << 24;
              v76 = vdup_lane_s32(v67, 0);
              v77 = vdup_lane_s32(v68, 0);
              v78 = vcltz_s32(vshl_n_s32(vdup_n_s32(v72), 0x1FuLL));
              do
              {
                v79 = v73;
                v80 = *(v66 + 104);
                v81 = *(v66 + 112);
                if (v80 != v81)
                {
                  v82 = *(&v167 + 1);
                  do
                  {
                    if (v80[2].u8[0] == v73)
                    {
                      if (*(v66 + 66) == 1)
                      {
                        v83 = *(v66 + 28) | (*(v66 + 30) << 16);
                      }

                      else
                      {
                        v83 = v80[1].i32[0] & 0xFFFFFF;
                      }

                      v84 = 0;
                      v85 = vmul_n_f32(*v80, v62.__cosval);
                      v86 = vmul_n_f32(vrev64_s32(*v80), v157);
                      v87.i32[0] = vsub_f32(v85, v86).u32[0];
                      v87.i32[1] = vadd_f32(v85, v86).i32[1];
                      v88 = vmla_f32(*(v66 + 36), v76, v87);
                      v89 = vbsl_s8(v78, vrnda_f32(v88), v88);
                      v90 = v75 | v83;
                      do
                      {
                        v91 = *(v66 + 32);
                        v92 = *(v74 + 2 * v84);
                        v61 = &v82[3];
                        *v82 = vmla_f32(v89, v77, *(v74 + 8 * v84 - 64));
                        v82[1].i32[0] = v90;
                        v82[1].i32[1] = v91;
                        v82[2].i16[0] = v92;
                        v82[2].i8[4] = v69;
                        v82[2].i8[5] = 0;
                        ++v84;
                        v82 += 3;
                      }

                      while (v84 != 4);
                      v82 = v61;
                    }

                    v80 = (v80 + 20);
                  }

                  while (v80 != v81);
                  *(&v167 + 1) = v82;
                }

                v73 = 1;
              }

              while ((v79 & 1) == 0);
            }
          }

          ++v64;
          v63 = *v156;
        }

        while (v64 < v156[1] - *v156);
        *&v166 = v65;
      }

      for (k = 0; k != 4; ++k)
      {
        if (*(&v168 + k * 8))
        {
          v130 = v162[k];
          v132 = v13[10];
          v131 = v13[11];
          if (v132 >= v131)
          {
            v134 = v13[9];
            v135 = (v132 - v134) >> 3;
            if ((v135 + 1) >> 61)
            {
              std::__throw_bad_array_new_length[abi:nn200100]();
            }

            v136 = v131 - v134;
            v137 = v136 >> 2;
            if (v136 >> 2 <= (v135 + 1))
            {
              v137 = v135 + 1;
            }

            if (v136 >= 0x7FFFFFFFFFFFFFF8)
            {
              v138 = 0x1FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v138 = v137;
            }

            v170[4] = v13 + 12;
            if (v138)
            {
              v139 = ggl::zone_mallocator::instance(v61);
              v140 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::RenderItem *>(v139, v138);
            }

            else
            {
              v140 = 0;
            }

            v142 = &v140[8 * v138];
            v141 = &v140[8 * v135];
            *v141 = v130;
            v133 = v141 + 8;
            v143 = v13[9];
            v144 = v13[10] - v143;
            v145 = &v141[-v144];
            memcpy(&v141[-v144], v143, v144);
            v146 = v13[9];
            v13[9] = v145;
            v13[10] = v133;
            v147 = v13[11];
            v13[11] = v142;
            v170[2] = v146;
            v170[3] = v147;
            v170[0] = v146;
            v170[1] = v146;
            v61 = std::__split_buffer<ggl::RenderItem *,geo::allocator_adapter<ggl::RenderItem *,ggl::zone_mallocator> &>::~__split_buffer(v170);
          }

          else
          {
            *v132 = v130;
            v133 = v132 + 1;
          }

          v13[10] = v133;
        }
      }

      v148 = *(v160 + 27);
      v149 = *(v160 + 15);
      md::TransitNodeTextureAtlas::updateTextureIfNecessary(v149);
      **(v148 + 168) = *(v149 + 56);
      v150 = *(v160 + 28);
      v151 = *(v160 + 15);
      md::TransitNodeTextureAtlas::updateTextureIfNecessary(v151);
      **(v150 + 168) = *(v151 + 56);
      for (m = 24; m != -8; m -= 8)
      {
        std::unique_ptr<ggl::DataWrite<ggl::TransitNode::DefaultVbo>>::reset[abi:nn200100]((v165 + m), 0);
      }

      ggl::BufferMemory::~BufferMemory(v163);
    }

    v153 = v13[9];
    v154 = v13[10];

    return ggl::CommandBuffer::sortRenderItems(v153, v154);
  }

  return result;
}

void sub_1B32F88BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  for (i = 24; i != -8; i -= 8)
  {
    std::unique_ptr<ggl::DataWrite<ggl::TransitNode::DefaultVbo>>::reset[abi:nn200100]((&a25 + i), 0);
  }

  ggl::BufferMemory::~BufferMemory(&a19);
  _Unwind_Resume(a1);
}

ggl::BufferMemory *std::unique_ptr<ggl::DataWrite<ggl::TransitNode::DefaultVbo>>::reset[abi:nn200100](ggl::BufferMemory **a1, ggl::BufferMemory *a2)
{
  result = *a1;
  *a1 = a2;
  if (result)
  {
    ggl::BufferMemory::~BufferMemory(result);

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void sub_1B32F8BC4(_Unwind_Exception *a1)
{
  v4 = *v2;
  if (*v2)
  {
    v1[5].__shared_weak_owners_ = v4;
    operator delete(v4);
  }

  v5 = v1[5].__vftable;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  shared_owners = v1[4].__shared_owners_;
  if (shared_owners)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](shared_owners);
  }

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v7);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::TransitNodeExternalIcon>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58F00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void md::TransitNodeFeaturePool::externalIconForObject(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((a1 + 32), *(*(a3 + 8) + 40)))
  {
    operator new();
  }

  operator new();
}

void sub_1B32F9150(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>::operator()[abi:nn200100](1, v2);
  std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::TransitNodeMissingFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58F38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::VertexDataTyped<ggl::TransitNode::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  ggl::VertexData::~VertexData((a1 - 200));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::VertexData::~VertexData((a1 - 200));
}

void ggl::VertexDataTyped<ggl::TransitNode::DefaultVbo>::~VertexDataTyped(ggl::VertexData *a1)
{
  ggl::VertexData::~VertexData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TransitNode::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58E90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::TransitNodeRGB::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58E58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::TransitNodeColorized::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58E20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::TransitNode::Settings>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TransitNode::Settings>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58DC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::TransitNodeFeature>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(void *a1, unint64_t a2)
{
  v2 = a1[1];
  if (!*&v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*&v2 <= a2)
    {
      v4 = a2 % *&v2;
    }
  }

  else
  {
    v4 = (*&v2 - 1) & a2;
  }

  v5 = *(*a1 + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= *&v2)
      {
        v7 %= *&v2;
      }
    }

    else
    {
      v7 &= *&v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (v6[2] != a2)
  {
    goto LABEL_17;
  }

  return v6;
}

void std::__shared_ptr_emplace<md::TransitNodeFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A58EC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

double md::ElevatedStrokeLayerDataSource::selectedPolygons@<D0>(uint64_t a1@<X8>)
{
  result = 0.0;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 1065353216;
  return result;
}

void std::__shared_ptr_emplace<md::ElevatedStrokeTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A59048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t std::__split_buffer<md::ElevatedStrokeGroup>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 160;
    md::ElevatedStrokeGroup::~ElevatedStrokeGroup((i - 160));
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void md::ElevatedStrokeLayerDataSource::~ElevatedStrokeLayerDataSource(md::ElevatedStrokeLayerDataSource *this)
{
  md::ElevatedStrokeLayerDataSource::~ElevatedStrokeLayerDataSource(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A58F70;
  v2 = *(this + 99);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  *(this + 95) = &unk_1F2A59028;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void md::overlayComponents::VectorOverlay::drapingStyle(md::overlayComponents::VectorOverlay *this, const md::LayoutContext *a2, float a3, float a4, const md::LayoutContext *a5)
{
  *this = 0;
  *(this + 8) = 0;
  *(this + 12) = 0;
  *(this + 20) = 0;
  *(this + 24) = 0;
  v8 = *(a2 + 9);
  if (v8)
  {
    v10 = *(a2 + 10);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(&v32, v8, v10);
    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v10);
    }

    if (v35 == 1)
    {
      v11 = a4 >= 0x17 ? 23 : a4;
      if (gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<BOOL>(v32[3], 91, v11, 2u, 0))
      {
        v12 = gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<unsigned int>(v32[3], 319, v11, 2, 0);
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<float>(v32[3], 97, v11, 2u, 0);
        if (v13 > 0.0)
        {
          if (v12 == 2)
          {
            v14 = 0x3F0000003F000000;
          }

          else if (v12 == 1)
          {
            v14 = 1065353216;
          }

          else
          {
            v14 = 0x3F80000000000000;
          }

          *(this + 8) = 1;
          *this = vmul_n_f32(v14, v13);
        }

        v24 = gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<unsigned int>(v32[3], 408, v11, 2, 0);
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<float>(v32[3], 404, v11, 2u, 0);
        if (v25 > 0.0)
        {
          if (v24 == 2)
          {
            v26 = 0x3F0000003F000000;
          }

          else if (v24 == 1)
          {
            v26 = 1065353216;
          }

          else
          {
            v26 = 0x3F80000000000000;
          }

          *(this + 20) = 1;
          *(this + 12) = vmul_n_f32(v26, v25);
        }

        v27 = gdc::ServiceLocator::resolve<md::AccessibilityHelper>(**(a5 + 2), *(*(a5 + 2) + 8));
        md::AccessibilityHelper::adjustedColorAtZ<(gss::PropertyID)92,(gss::PropertyID)489>(v28, v27, &v32, a4, 2u);
        *(this + 24) = *(v28 + 3) >= 0.0039062;
      }
    }

    if (v35 == 1)
    {
      (*(*v32 + 56))(v32);
    }

    if (v34)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v34);
    }

    v23 = v33;
    if (v33)
    {
      goto LABEL_33;
    }
  }

  else
  {
    md::RibbonLayoutContext::RibbonLayoutContext(&v32, a5);
    v37 = 0;
    v38 = 1065353216;
    v39 = 0;
    v42 = 0;
    v43 = 0;
    v40 = 0;
    v41 = 0;
    v44 = 255;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = 1;
    v36 = a3;
    v28[0] = xmmword_1B33B0B40;
    v28[1] = xmmword_1B33B06F0;
    v29 = 256;
    __asm { FMOV            V0.2S, #-1.0 }

    v30 = -_D0;
    v31 = 0;
    md::PolylineOverlayStyle::updateFromOverlay(*(a2 + 7), &v32, v28);
    v21 = *(v28 + 1) * 0.5;
    *(this + 8) = 1;
    *this = v21;
    *(this + 1) = v21;
    v22 = *(a2 + 5);
    os_unfair_lock_lock((v22 + 24));
    os_unfair_lock_unlock((v22 + 24));
    *(this + 24) = *(v22 + 12) >= 0.0039062;
    v23 = v43;
    if (v43)
    {
LABEL_33:
      std::__shared_weak_count::__release_shared[abi:nn200100](v23);
    }
  }
}

void sub_1B32F9CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a20);
  }

  if (a18)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a18);
  }

  _Unwind_Resume(exception_object);
}

md::ShieldIconLabelPart *md::ShieldIconLabelPart::clone(md::ShieldIconLabelPart *this)
{
  v2 = mdm::zone_mallocator::instance(this);
  v3 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v2, 0x360uLL);
  md::ShieldIconLabelPart::ShieldIconLabelPart(v3, this);
  return v3;
}

void sub_1B32F9D30(mdm::zone_mallocator *a1)
{
  v3 = mdm::zone_mallocator::instance(a1);
  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, v1);
  _Unwind_Resume(a1);
}

md::ShieldIconLabelPart *md::ShieldIconLabelPart::ShieldIconLabelPart(md::ShieldIconLabelPart *this, const md::ShieldIconLabelPart *a2)
{
  v4 = this + 596;
  v5 = md::LabelPart::LabelPart(this, a2);
  *v5 = &unk_1F2A4BAF0;
  v6 = *(a2 + 572);
  *(v5 + 588) = *(a2 + 588);
  *(v5 + 572) = v6;
  __asm { FMOV            V0.4S, #1.0 }

  *v4 = _Q0;
  *(v5 + 153) = 1065353216;
  *(v5 + 308) = 256;
  *(v5 + 618) = 0;
  *(v5 + 155) = *(a2 + 155);
  *(v5 + 156) = 0;
  *(v5 + 628) = *(a2 + 628);
  *(v4 + 33) = 16777217;
  *(v5 + 633) = 0;
  *v5 = &unk_1F2A5A040;
  *(v5 + 80) = *(a2 + 80);
  v12 = *(a2 + 81);
  *(v5 + 81) = v12;
  if (v12)
  {
    atomic_fetch_add_explicit((v12 + 8), 1uLL, memory_order_relaxed);
  }

  v13 = (this + 656);
  *(this + 680) = *(a2 + 680);
  if (*(a2 + 679) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::__init_copy_ctor_external(v13, *(a2 + 82), *(a2 + 83));
  }

  else
  {
    v14 = *(a2 + 41);
    *(this + 84) = *(a2 + 84);
    *v13 = v14;
  }

  v15 = *(a2 + 43);
  *(this + 701) = *(a2 + 701);
  *(this + 43) = v15;
  v16 = *(a2 + 712);
  v17 = *(a2 + 744);
  *(this + 728) = *(a2 + 728);
  *(this + 744) = v17;
  *(this + 712) = v16;
  *(this + 792) = 0u;
  *(this + 202) = 1065353216;
  *(this + 824) = 0;
  *(this + 414) = 0;
  *(this + 812) = 0;
  *(this + 820) = 0;
  v18 = *(a2 + 776);
  *(this + 760) = *(a2 + 760);
  *(this + 776) = v18;
  *this = &unk_1F2A59200;
  *(this + 104) = *(a2 + 104);
  v19 = *(a2 + 105);
  *(this + 105) = v19;
  if (v19)
  {
    atomic_fetch_add_explicit((v19 + 8), 1uLL, memory_order_relaxed);
  }

  *(this + 848) = *(a2 + 848);
  *(v4 + 32) = *(a2 + 852);
  return this;
}

void sub_1B32F9F20(_Unwind_Exception *a1)
{
  v3 = *(v1 + 648);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  *v1 = &unk_1F2A5B190;
  md::CollisionObject::~CollisionObject((v1 + 312));
  md::CollisionObject::~CollisionObject((v1 + 72));
  _Unwind_Resume(a1);
}

void md::ShieldIconLabelPart::populateDebugNode(md::ShieldIconLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::IconLabelPart::populateDebugNode(this, a2);
  std::string::basic_string[abi:nn200100]<0>(&v10, "ShieldIconLabelPart");
  v4 = gdc::DebugTreeNode::createChildNode(a2, &v10);
  if (v11 < 0)
  {
    operator delete(v10);
  }

  std::string::basic_string[abi:nn200100]<0>(&v10, "Shield Text");
  v5 = (*(**(this + 80) + 32))(*(this + 80));
  std::string::basic_string[abi:nn200100]<0>(&v6, v5);
  gdc::DebugTreeValue::DebugTreeValue(v7, &v6);
  gdc::DebugTreeNode::addProperty(v4, &v10, v7);
  if (v9 < 0)
  {
    operator delete(__p);
  }

  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v6.__r_.__value_.__l.__data_);
  }

  if (v11 < 0)
  {
    operator delete(v10);
  }
}

void sub_1B32FA058(_Unwind_Exception *exception_object)
{
  if (*(v1 - 17) < 0)
  {
    operator delete(*(v1 - 40));
  }

  _Unwind_Resume(exception_object);
}

uint64_t md::ShieldIconLabelPart::debugString@<X0>(md::ShieldIconLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  v31 = *MEMORY[0x1E69E9840];
  std::ostringstream::basic_ostringstream[abi:nn200100](&v19);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, "Shield(", 7);
  v4 = (*(**(this + 80) + 32))(*(this + 80));
  if (v4)
  {
    v5 = v4;
  }

  else
  {
    v5 = "";
  }

  v6 = strlen(v5);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, v5, v6);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, ")", 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, "\n ", 2);
  md::IconLabelPart::debugString(this, &v28);
  if ((v30 & 0x80u) == 0)
  {
    v7 = &v28;
  }

  else
  {
    v7 = v28;
  }

  if ((v30 & 0x80u) == 0)
  {
    v8 = v30;
  }

  else
  {
    v8 = v29;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, v7, v8);
  if (v30 < 0)
  {
    operator delete(v28);
  }

  v9 = (*(**(this + 104) + 48))(&v28);
  v10 = v30;
  if ((v30 & 0x80u) != 0)
  {
    v10 = v29;
  }

  if (v10)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, "\n ", 2);
    if ((v30 & 0x80u) == 0)
    {
      v11 = &v28;
    }

    else
    {
      v11 = v28;
    }

    if ((v30 & 0x80u) == 0)
    {
      v12 = v30;
    }

    else
    {
      v12 = v29;
    }

    v9 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v19, v11, v12);
  }

  if ((v26 & 0x10) != 0)
  {
    v14 = v25;
    if (v25 < v22)
    {
      v25 = v22;
      v14 = v22;
    }

    locale = v21[4].__locale_;
  }

  else
  {
    if ((v26 & 8) == 0)
    {
      v13 = 0;
      a2[23] = 0;
      goto LABEL_35;
    }

    locale = v21[1].__locale_;
    v14 = v21[3].__locale_;
  }

  v13 = v14 - locale;
  if ((v14 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v13 >= 0x17)
  {
    operator new();
  }

  a2[23] = v13;
  if (v13)
  {
    v9 = memmove(a2, locale, v13);
  }

LABEL_35:
  a2[v13] = 0;
  if (v30 < 0)
  {
    v16 = v28;
    v17 = mdm::zone_mallocator::instance(v9);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v17, v16);
  }

  v19 = *MEMORY[0x1E69E54E8];
  *(&v19 + *(v19 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v20 = MEMORY[0x1E69E5548] + 16;
  if (v24 < 0)
  {
    operator delete(__p);
  }

  v20 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v21);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v27);
}

void sub_1B32FA3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  a9 = *MEMORY[0x1E69E54E8];
  *(&a9 + *(a9 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a10 = MEMORY[0x1E69E5548] + 16;
  if (a23 < 0)
  {
    operator delete(__p);
  }

  a10 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a11);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a26);
  _Unwind_Resume(a1);
}

void md::ShieldIconLabelPart::~ShieldIconLabelPart(md::ShieldIconLabelPart *this)
{
  *this = &unk_1F2A59200;
  v2 = *(this + 105);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  md::IconLabelPart::~IconLabelPart(this);
  v4 = mdm::zone_mallocator::instance(v3);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v4, this);
}

{
  *this = &unk_1F2A59200;
  v2 = *(this + 105);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  md::IconLabelPart::~IconLabelPart(this);
}

uint64_t md::ShieldIconLabelPart::ShieldIconLabelPart(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  v7 = md::IconLabelPart::IconLabelPart(a1, a2, 0, 0);
  *v7 = &unk_1F2A59200;
  v8 = a4[1];
  v7[104] = *a4;
  v7[105] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((v8 + 8), 1uLL, memory_order_relaxed);
  }

  v9 = *(a3 + 296);
  if (!v9)
  {
    v10 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(a3, 0);
    v9 = *v10;
    *(a3 + 296) = *v10;
  }

  *(a1 + 848) = *(v9 + 91);
  *(a1 + 852) = *(v9 + 56);
  *(a1 + 557) = 1;
  *(a1 + 712) = 1;
  return a1;
}

void sub_1B32FA6BC(_Unwind_Exception *a1)
{
  v3 = *(v1 + 105);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  md::IconLabelPart::~IconLabelPart(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TransitNode::DefaultVbo>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TransitNode::DefaultVbo>,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A59650;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::TransitNode::BaseMesh::~BaseMesh(ggl::TransitNode::BaseMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void non-virtual thunk toggl::MeshTyped<ggl::TransitNode::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::TransitNode::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::PointIconLabelPart::debugString@<X0>(md::PointIconLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v15);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, "PointIcon", 9);
  if (*(this + 173))
  {
    if (*(this + 208))
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, ", multiPOI(", 11);
      v4 = MEMORY[0x1B8C61C90](&v15, *(this + 208));
      v5 = ")";
      v6 = 1;
    }

    else
    {
      v5 = ", multiPOI-fallback";
      v4 = &v15;
      v6 = 19;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, v5, v6);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, "\n  ", 3);
  md::IconLabelPart::debugString(this, __p);
  if ((v14 & 0x80u) == 0)
  {
    v7 = __p;
  }

  else
  {
    v7 = __p[0];
  }

  if ((v14 & 0x80u) == 0)
  {
    v8 = v14;
  }

  else
  {
    v8 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, v7, v8);
  if (v14 < 0)
  {
    operator delete(__p[0]);
  }

  if ((v22 & 0x10) != 0)
  {
    v10 = v21;
    if (v21 < v18)
    {
      v21 = v18;
      v10 = v18;
    }

    locale = v17[4].__locale_;
  }

  else
  {
    if ((v22 & 8) == 0)
    {
      v9 = 0;
      a2[23] = 0;
      goto LABEL_27;
    }

    locale = v17[1].__locale_;
    v10 = v17[3].__locale_;
  }

  v9 = v10 - locale;
  if ((v10 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v9 >= 0x17)
  {
    operator new();
  }

  a2[23] = v9;
  if (v9)
  {
    memmove(a2, locale, v9);
  }

LABEL_27:
  a2[v9] = 0;
  v15 = *MEMORY[0x1E69E54E8];
  *(&v15 + *(v15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v16 = MEMORY[0x1E69E5548] + 16;
  if (v20 < 0)
  {
    operator delete(v19);
  }

  v16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v17);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v23);
}

void sub_1B32FAACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  a15 = *MEMORY[0x1E69E54E8];
  *(&a15 + *(a15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a16 = MEMORY[0x1E69E5548] + 16;
  if (a29 < 0)
  {
    operator delete(a24);
  }

  a16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a17);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a32);
  _Unwind_Resume(a1);
}

void ___ZN2md24VenueFloorMeshGeneration19_writeFootprintDataEPN3ggl6DeviceERKNSt3__16vectorINS_14PolygonSectionENS4_9allocatorIS6_EEEERNS5_INS1_11PolygonBase18CompressedMeshMeshENS7_ISD_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  v176[19] = *MEMORY[0x1E69E9840];
  v2 = *(a1 + 40);
  v3 = *v2;
  v138 = v2[1];
  if (*v2 == v138)
  {
    return;
  }

  v4 = 0;
  v146 = 0;
  v147 = 0;
  v136 = *(a1 + 32);
  v133 = *MEMORY[0x1E69E54E8];
  v134 = *(MEMORY[0x1E69E54E8] + 24);
  do
  {
    v5 = *(v3 + 88);
    v6 = v146;
    v7 = (v146 - v4) >> 2;
    if (v5 <= v7)
    {
      if (v5 < v7)
      {
        v6 = (v4 + 4 * v5);
      }

      v146 = v6;
    }

    else
    {
      if (v5 - v7 > -v146 >> 2)
      {
        if (!(v5 >> 62))
        {
          v8 = -v4 >> 1;
          if (v8 <= v5)
          {
            v8 = *(v3 + 88);
          }

          if (-v4 >= 0x7FFFFFFFFFFFFFFCLL)
          {
            v9 = 0x3FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v9 = v8;
          }

          std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(v9);
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v146 += 2 * (v5 - v7);
    }

    ggl::DataAccess<ggl::TrafficBase::DefaultVbo>::DataAccess(v149, **(**(a1 + 32) + 144 * v147 + 64), 0, v5, a2);
    if (v5)
    {
      v10 = (v149[5] + 4);
      v11 = (v4 + 2);
      v12 = (*(v3 + 8) + 4);
      do
      {
        v13 = (*(v12 - 1) * 65535.0);
        v14 = (*v12 * 65535.0);
        *(v10 - 2) = v13;
        *(v10 - 1) = v14;
        *v10 = 0x7FFF;
        v10 += 2;
        *(v11 - 1) = v13;
        *v11 = v14;
        v11 += 2;
        v12 += 2;
        --v5;
      }

      while (v5);
    }

    v15 = v146 - v4;
    v145 = ((v146 - v4) >> 1) + ((v146 - v4) >> 2) - 6;
    ggl::DataAccess<ggl::DaVinci::TexturedCompressedVbo>::DataAccess(v161, *(*v136 + 144 * v147 + 96), 0, v145, 1, 1, a2);
    v151[0] = 0;
    v151[1] = 0;
    v150 = v151;
    v152 = xmmword_1B33B22C0;
    v153 = 0;
    v154 = 0;
    v155 = 0;
    v157 = 4;
    v156 = 0;
    v159 = 0;
    v160 = 0;
    v158 = 0;
    v148 = (v146 - v4) >> 2;
    if (v148 < 3)
    {
      goto LABEL_150;
    }

    LOWORD(v16) = 0;
    LOWORD(v17) = 0;
    v18 = (v4 + 2);
    LOWORD(v19) = -1;
    v20 = (v4 + 2);
    v21 = (v146 - v4) >> 2;
    LOWORD(v22) = -1;
    do
    {
      v23 = *(v20 - 1);
      v25 = *v20;
      v20 += 2;
      v24 = v25;
      if (v23 >= v22)
      {
        v22 = v22;
      }

      else
      {
        v22 = v23;
      }

      if (v24 >= v19)
      {
        v19 = v19;
      }

      else
      {
        v19 = v24;
      }

      if (v23 <= v17)
      {
        v17 = v17;
      }

      else
      {
        v17 = v23;
      }

      if (v24 <= v16)
      {
        v16 = v16;
      }

      else
      {
        v16 = v24;
      }

      --v21;
    }

    while (v21);
    v139 = v3;
    v26 = v22 | (v19 << 16);
    v154 = (v17 << 32) | (v16 << 48) | v26;
    v155 = fmax((v17 - v26), (v16 - WORD1(v26)));
    v135 = v146 - v4;
    v27 = *(v146 - 2);
    v28 = *(v146 - 1);
    v29 = 0.0;
    v30 = (v146 - v4) >> 2;
    do
    {
      v31 = *(v18 - 1);
      v32 = *v18;
      v18 += 2;
      v29 = v29 + ((v28 + v32) * (v27 - v31));
      v28 = v32;
      v27 = v31;
      --v30;
    }

    while (v30);
    v33 = 0;
    v34 = 0;
    v35 = 0;
    do
    {
      v36 = v153;
      if (!v153)
      {
        v37 = malloc_type_malloc(48 * v152, 0x1022040F1C12834uLL);
        v167.__r_.__value_.__r.__words[0] = v37;
        std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::__emplace_unique_key_args<geo::Pool<gdc::FallbackNode>::Element *,geo::Pool<gdc::FallbackNode>::Element * const&>(&v150, v37);
        v36 = v153;
        v38 = &v37[6 * v152 - 6];
        if (v38 >= v37)
        {
          do
          {
            v39 = v38;
            *v38 = v36;
            v38 -= 6;
            v36 = v39;
          }

          while (v38 >= v37);
          v36 = (v38 + 6);
        }

        v153 = v36;
      }

      v40 = (v4 + 4 * v34);
      v153 = *v36;
      *v36 = v33;
      *(v36 + 2) = *v40;
      *(v36 + 8) = 0u;
      *(v36 + 24) = 0u;
      *(v36 + 37) = 0;
      if (v35)
      {
        v41 = (v35 + 16);
        v42 = *(v35 + 16);
        *(v36 + 8) = v35;
        *(v36 + 16) = v42;
        *(v42 + 8) = v36;
      }

      else
      {
        *(v36 + 8) = v36;
        v41 = (v36 + 16);
      }

      *v41 = v36;
      *(v36 + 44) = 0;
      if (v155)
      {
        *(v36 + 40) = geo::Triangulator<unsigned short,unsigned short>::GeometricHasher::mortonEncode(&v154, *v40, v40[1]);
      }

      v33 = ++v156;
      ++v34;
      v35 = v36;
    }

    while (v34 != v148);
    if (*(v36 + 2) == *(*(v36 + 16) + 2))
    {
      v43 = *(v36 + 8);
      geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v36);
      v36 = v43;
    }

    v3 = v139;
    v15 = v146 - v4;
    if (v29 < 0.0)
    {
      v44 = v36;
      do
      {
        v46 = *(v44 + 8);
        v45 = *(v44 + 16);
        *(v44 + 8) = v45;
        *(v44 + 16) = v46;
        v44 = v45;
      }

      while (v45 != v36);
    }

    if (!v36)
    {
      goto LABEL_150;
    }

    v47 = *(v36 + 16);
    if (!v155)
    {
      goto LABEL_82;
    }

    v48 = *(v36 + 16);
    if (!v47)
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "Called linkListInHashSpace with a NULL head.", 44);
      std::ios_base::getloc((MEMORY[0x1E69E5300] + *(*MEMORY[0x1E69E5300] - 24)));
      v98 = std::locale::use_facet(&v167, MEMORY[0x1E69E5318]);
      (v98->__vftable[2].~facet_0)(v98, 10);
      std::locale::~locale(&v167);
      std::ostream::put();
      std::ostream::flush();
LABEL_149:
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "Called earclipPolygon with a NULL head. Probably wrong to do so.", 64);
      std::ios_base::getloc((MEMORY[0x1E69E5300] + *(*MEMORY[0x1E69E5300] - 24)));
      v99 = std::locale::use_facet(&v167, MEMORY[0x1E69E5318]);
      (v99->__vftable[2].~facet_0)(v99, 10);
      std::locale::~locale(&v167);
      std::ostream::put();
      std::ostream::flush();
      goto LABEL_150;
    }

    do
    {
      v49 = v48;
      v50 = *(v48 + 1);
      v48 = *(v48 + 2);
      *(v49 + 3) = v50;
      *(v49 + 4) = v48;
    }

    while (v48 != v47);
    *(*(v48 + 3) + 32) = 0;
    *(v48 + 3) = 0;
    v51 = 1;
    do
    {
      v52 = 0;
      v53 = 0;
      v54 = v48;
      do
      {
        v55 = 0;
        v56 = v54;
        if (v51)
        {
          while (1)
          {
            ++v55;
            v56 = *(v56 + 4);
            if (!v56)
            {
              break;
            }

            if (v51 == v55)
            {
              v55 = v51;
              break;
            }
          }
        }

        ++v52;
        v57 = v51;
        while (1)
        {
          v58 = !v57 || v56 == 0;
          v59 = !v58;
          if (!v55)
          {
            break;
          }

          if (!v59 || *(v54 + 10) <= *(v56 + 10))
          {
            v60 = *(v54 + 4);
            --v55;
            v61 = v56;
            v62 = v54;
            goto LABEL_77;
          }

LABEL_76:
          v61 = *(v56 + 4);
          --v57;
          v60 = v54;
          v62 = v56;
LABEL_77:
          v63 = v62;
          if (v53)
          {
            *(v53 + 4) = v62;
            v63 = v48;
          }

          *(v62 + 3) = v53;
          v48 = v63;
          v54 = v60;
          v56 = v61;
          v53 = v62;
        }

        if (v59)
        {
          v55 = 0;
          goto LABEL_76;
        }

        v54 = v56;
      }

      while (v56);
      *(v53 + 4) = 0;
      v51 *= 2;
    }

    while (v52 > 1);
LABEL_82:
    if (!v47)
    {
      goto LABEL_149;
    }

    v64 = *(v47 + 1);
    v65 = *(v47 + 2);
    if (v64 != v65)
    {
      v144 = v47;
      v132 = v4;
LABEL_85:
      v140 = v155;
      v66 = v144[2];
      v67 = v144;
      v68 = v144[1];
      while (1)
      {
        v69 = v64;
        v70 = v65;
        v71 = v64[2];
        v72 = v65[1];
        v73 = v64[1];
        v74 = v65[2];
        if (((v72 - v68) * (v66 - v71) + (v66 - v74) * (v68 - v73)) <= 0)
        {
          v141 = v64[1];
          v142 = v64[2];
          if (v140)
          {
            v75 = v68;
            v76 = v66;
            if (v71 >= v66)
            {
              v77 = v66;
            }

            else
            {
              v77 = v71;
            }

            if (v71 > v66)
            {
              v76 = v71;
            }

            if (v73 >= v68)
            {
              v78 = v68;
            }

            else
            {
              v78 = v73;
            }

            if (v73 > v68)
            {
              v75 = v73;
            }

            if (v78 >= v72)
            {
              v79 = v72;
            }

            else
            {
              v79 = v78;
            }

            if (v77 >= v74)
            {
              v80 = v74;
            }

            else
            {
              v80 = v77;
            }

            if (v75 <= v72)
            {
              v81 = v72;
            }

            else
            {
              v81 = v75;
            }

            if (v76 <= v74)
            {
              v82 = v74;
            }

            else
            {
              v82 = v76;
            }

            v83 = geo::Triangulator<unsigned short,unsigned short>::GeometricHasher::mortonEncode(&v154, v79, v80);
            v84 = geo::Triangulator<unsigned short,unsigned short>::GeometricHasher::mortonEncode(&v154, v81, v82);
            v85 = *(v67 + 4);
            if (v85)
            {
              v86 = v84;
              while (*(v85 + 10) <= v86)
              {
                if (v85 != v69 && v85 != v70)
                {
                  v87 = *v85;
                  if (*v69 != v87 && *v67 != v87 && *v70 != v87)
                  {
                    v88 = v85[2];
                    v89 = v85[1];
                    if ((((*(*(v85 + 2) + 2) - v89) * (v88 - *(*(v85 + 1) + 4)) + (v88 - *(*(v85 + 2) + 4)) * (v89 - *(*(v85 + 1) + 2))) & 0x80000000) == 0 && geo::Triangulator<unsigned short,unsigned short>::vertexLiesWithinTriangle(v89, v88, v141, v142, v68, v66, v72, v74))
                    {
                      goto LABEL_87;
                    }
                  }
                }

                v85 = *(v85 + 4);
                if (!v85)
                {
                  break;
                }
              }
            }

            v90 = *(v67 + 3);
            if (v90)
            {
              while (*(v90 + 10) >= v83)
              {
                if (v90 != v69 && v90 != v70)
                {
                  v91 = *v90;
                  if (*v69 != v91 && *v67 != v91 && *v70 != v91)
                  {
                    v92 = v90[2];
                    v93 = v90[1];
                    if ((((*(*(v90 + 2) + 2) - v93) * (v92 - *(*(v90 + 1) + 4)) + (v92 - *(*(v90 + 2) + 4)) * (v93 - *(*(v90 + 1) + 2))) & 0x80000000) == 0 && geo::Triangulator<unsigned short,unsigned short>::vertexLiesWithinTriangle(v93, v92, v141, v142, v68, v66, v72, v74))
                    {
                      goto LABEL_87;
                    }
                  }
                }

                v90 = *(v90 + 3);
                if (!v90)
                {
                  break;
                }
              }
            }

LABEL_143:
            std::vector<unsigned short>::push_back[abi:nn200100](&v158, v69);
            std::vector<unsigned short>::push_back[abi:nn200100](&v158, v67);
            std::vector<unsigned short>::push_back[abi:nn200100](&v158, v70);
            geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v67);
            v144 = *(v70 + 2);
            if (v144)
            {
              v64 = *(v144 + 1);
              v65 = *(v144 + 2);
              if (v64 != v65)
              {
                goto LABEL_85;
              }
            }

LABEL_145:
            if (v69)
            {
              geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v69);
            }

            geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v70);
            v4 = v132;
            v3 = v139;
            goto LABEL_178;
          }

          v94 = *(v65 + 2);
          if (v94 == v64)
          {
            goto LABEL_143;
          }

          v95 = *v64;
          while (1)
          {
            v96 = *v94;
            if (v95 != v96 && *v67 != v96 && *v70 != v96)
            {
              v97 = *(v94 + 1);
              if ((((*(*(v94 + 2) + 2) - v97) * (HIWORD(v97) - *(*(v94 + 1) + 4)) + (HIWORD(v97) - *(*(v94 + 2) + 4)) * (v97 - *(*(v94 + 1) + 2))) & 0x80000000) == 0 && geo::Triangulator<unsigned short,unsigned short>::vertexLiesWithinTriangle(v97, HIWORD(v97), v141, v142, v68, v66, v72, v74))
              {
                break;
              }
            }

            v94 = *(v94 + 2);
            if (v94 == v69)
            {
              goto LABEL_143;
            }
          }
        }

LABEL_87:
        if (v70 == v144)
        {
          break;
        }

        v64 = *(v70 + 1);
        v65 = *(v70 + 2);
        v68 = v72;
        v66 = v74;
        v67 = v70;
        if (v64 == v65)
        {
          goto LABEL_145;
        }
      }

      v4 = v132;
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5300], "Wrapped around the polygon without finishing... :-(", 51);
      v3 = v139;
      v15 = v135;
      std::ios_base::getloc((MEMORY[0x1E69E5300] + *(*MEMORY[0x1E69E5300] - 24)));
      v118 = std::locale::use_facet(&v167, MEMORY[0x1E69E5318]);
      (v118->__vftable[2].~facet_0)(v118, 10);
      std::locale::~locale(&v167);
      std::ostream::put();
      std::ostream::flush();
      v119 = 0;
      v120 = v70;
      do
      {
        ++v119;
        v120 = *(v120 + 2);
      }

      while (v120 != v144 && v120 != 0);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5310], "List has ", 9);
      std::to_string(&v167, v119);
      if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v122 = &v167;
      }

      else
      {
        v122 = v167.__r_.__value_.__r.__words[0];
      }

      if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v167.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v167.__r_.__value_.__l.__size_;
      }

      v124 = MEMORY[0x1E69E5310];
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(MEMORY[0x1E69E5310], v122, size);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v124, " nodes:", 7);
      std::ios_base::getloc((v124 + *(*v124 - 24)));
      v125 = std::locale::use_facet(&__dst, MEMORY[0x1E69E5318]);
      (v125->__vftable[2].~facet_0)(v125, 10);
      std::locale::~locale(&__dst);
      std::ostream::put();
      std::ostream::flush();
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v124, "\t", 1);
      if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v167.__r_.__value_.__l.__data_);
      }

      v126 = v70;
      do
      {
        std::to_string(&v167, *v126);
        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v127 = &v167;
        }

        else
        {
          v127 = v167.__r_.__value_.__r.__words[0];
        }

        if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v128 = HIBYTE(v167.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v128 = v167.__r_.__value_.__l.__size_;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v124, v127, v128);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v124, " ", 1);
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v167.__r_.__value_.__l.__data_);
        }

        v126 = *(v126 + 2);
      }

      while (v126 != v144 && v126);
      std::ios_base::getloc((v124 + *(*v124 - 24)));
      v129 = std::locale::use_facet(&v167, MEMORY[0x1E69E5318]);
      (v129->__vftable[2].~facet_0)(v129, 10);
      std::locale::~locale(&v167);
      std::ostream::put();
      std::ostream::flush();
      v130 = *(v70 + 1);
      if (v130)
      {
        do
        {
          v131 = v70;
          v70 = *(v70 + 2);
          geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v131);
        }

        while (v70 != v130);
        geo::Triangulator<unsigned short,unsigned short>::removeNode(&v150, v70);
      }

LABEL_150:
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1)
      {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_15525);
      }

      v100 = GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
      {
        if (v146 == v4)
        {
          v164 = 0;
          LOBYTE(__dst.__locale_) = 0;
          p_dst = &__dst;
        }

        else
        {
          std::ostringstream::basic_ostringstream[abi:nn200100](&v167);
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v167, "(", 1);
          v101 = MEMORY[0x1B8C61CD0](&v167, *v4);
          v102 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v101, ", ", 2);
          v103 = MEMORY[0x1B8C61CD0](v102, *(v4 + 2));
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v103, ")", 1);
          if (v15 != 4)
          {
            v104 = v148 - 1;
            v105 = (v4 + 6);
            do
            {
              std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v167, ", (", 3);
              v106 = MEMORY[0x1B8C61CD0](&v167, *(v105 - 1));
              v107 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v106, ", ", 2);
              v108 = MEMORY[0x1B8C61CD0](v107, *v105);
              std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v108, ")", 1);
              v105 += 2;
              --v104;
            }

            while (v104);
          }

          if ((v175 & 0x10) != 0)
          {
            v111 = v174;
            if (v174 < v171)
            {
              v174 = v171;
              v111 = v171;
            }

            v112 = __src;
          }

          else
          {
            if ((v175 & 8) == 0)
            {
              v109 = 0;
              v164 = 0;
              goto LABEL_171;
            }

            v112 = v168;
            v111 = v169;
          }

          v109 = v111 - v112;
          if (v111 - v112 >= 0x7FFFFFFFFFFFFFF8)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          if (v109 >= 0x17)
          {
            operator new();
          }

          v164 = v111 - v112;
          if (v109)
          {
            memmove(&__dst, v112, v109);
          }

LABEL_171:
          *(&__dst.__locale_ + v109) = 0;
          v167.__r_.__value_.__r.__words[0] = v133;
          *(v167.__r_.__value_.__r.__words + *(v133 - 24)) = v134;
          v167.__r_.__value_.__l.__size_ = MEMORY[0x1E69E5548] + 16;
          if (v173 < 0)
          {
            operator delete(__p);
          }

          v167.__r_.__value_.__l.__size_ = MEMORY[0x1E69E5538] + 16;
          std::locale::~locale(&v167.__r_.__value_.__r.__words[2]);
          std::ostream::~ostream();
          MEMORY[0x1B8C620C0](v176);
          p_dst = &__dst;
          if (v164 < 0)
          {
            p_dst = __dst.__locale_;
          }
        }

        *buf = 136315138;
        v166 = p_dst;
        _os_log_impl(&dword_1B2754000, v100, OS_LOG_TYPE_ERROR, "Triangulator failed to fully triangulate polygon: %s", buf, 0xCu);
        if (v164 < 0)
        {
          operator delete(__dst.__locale_);
        }
      }
    }

LABEL_178:
    v113 = v158;
    if (v145 == (v159 - v158) >> 1)
    {
      if (v159 != v158)
      {
        v114 = v162;
        v115 = v145;
        if (v145 <= 1)
        {
          v115 = 1;
        }

        do
        {
          v116 = *v113++;
          *v114++ = v116;
          --v115;
        }

        while (v115);
      }
    }

    else
    {
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1)
      {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_15525);
      }

      v117 = GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v167.__r_.__value_.__l.__data_) = 134218240;
        *(v167.__r_.__value_.__r.__words + 4) = v145;
        WORD2(v167.__r_.__value_.__r.__words[1]) = 2048;
        *(&v167.__r_.__value_.__r.__words[1] + 6) = (v159 - v158) >> 1;
        _os_log_impl(&dword_1B2754000, v117, OS_LOG_TYPE_ERROR, "Mismatching number of indices, indexCount: %zu, triangulatedIndexCount: %zu", &v167, 0x16u);
      }

      if (v145)
      {
        bzero(v162, 6 * v148 - 12);
      }
    }

    if (v158)
    {
      v159 = v158;
      operator delete(v158);
    }

    geo::Pool<geo::Triangulator<unsigned short,unsigned short>::Node>::~Pool(&v150);
    ggl::BufferMemory::~BufferMemory(v161);
    ++v147;
    ggl::BufferMemory::~BufferMemory(v149);
    v3 += 144;
  }

  while (v3 != v138);
}

void sub_1B32FBE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, void *a51, uint64_t a52, uint64_t a53, char a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, std::locale a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  std::locale::~locale(&a60);
  if (a70 < 0)
  {
    operator delete(__p);
  }

  if (a51)
  {
    a52 = a51;
    operator delete(a51);
  }

  geo::Pool<geo::Triangulator<unsigned short,unsigned short>::Node>::~Pool(&a41);
  ggl::BufferMemory::~BufferMemory(&a54);
  ggl::BufferMemory::~BufferMemory(&a35);
  if (a10)
  {
    operator delete(a10);
  }

  _Unwind_Resume(a1);
}

uint64_t geo::Pool<geo::Triangulator<unsigned short,unsigned short>::Node>::~Pool(uint64_t a1)
{
  v25 = 0;
  v26 = 0;
  v24 = &v25;
  v3 = (a1 + 40);
  v2 = *(a1 + 40);
  if (v2)
  {
    do
    {
      std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::__emplace_unique_key_args<geo::Pool<gdc::FallbackNode>::Element *,geo::Pool<gdc::FallbackNode>::Element * const&>(&v24, v2);
      v2 = **v3;
      *v3 = v2;
    }

    while (v2);
    v4 = v26;
  }

  else
  {
    v4 = 0;
  }

  v5 = *(a1 + 24);
  v6 = *a1;
  v7 = (a1 + 8);
  v8 = v4 == *(a1 + 16) * v5 || v6 == v7;
  if (!v8)
  {
    v9 = v25;
    v10 = *a1;
    do
    {
      if (v5)
      {
        v11 = 0;
        v12 = v10[4];
        do
        {
          v13 = v12 + 48 * v11;
          if (!v9)
          {
            goto LABEL_21;
          }

          v14 = &v25;
          v15 = v9;
          do
          {
            v16 = v15;
            v17 = v14;
            v18 = v15[4];
            if (v18 >= v13)
            {
              v14 = v15;
            }

            v15 = v15[v18 < v13];
          }

          while (v15);
          if (v14 == &v25)
          {
            goto LABEL_21;
          }

          if (v18 < v13)
          {
            v16 = v17;
          }

          if (v13 < v16[4])
          {
LABEL_21:
            *(v13 + 44) = -1;
          }

          ++v11;
        }

        while (v11 != v5);
      }

      v19 = v10[1];
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = *v19;
        }

        while (v19);
      }

      else
      {
        do
        {
          v20 = v10[2];
          v8 = *v20 == v10;
          v10 = v20;
        }

        while (!v8);
      }

      v10 = v20;
    }

    while (v20 != v7);
  }

  if (v6 != v7)
  {
    do
    {
      free(v6[4]);
      v21 = v6[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = *v21;
        }

        while (v21);
      }

      else
      {
        do
        {
          v22 = v6[2];
          v8 = *v22 == v6;
          v6 = v22;
        }

        while (!v8);
      }

      v6 = v22;
    }

    while (v22 != v7);
  }

  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(a1 + 8));
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = v7;
  *(a1 + 40) = 0;
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v25);
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(a1 + 8));
  return a1;
}

void sub_1B32FC1FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(a11);
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v11 + 8));
  _Unwind_Resume(a1);
}

uint64_t geo::Triangulator<unsigned short,unsigned short>::removeNode(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    v3 = *(a2 + 8);
    v2 = *(a2 + 16);
    if (v2)
    {
      *(v2 + 8) = v3;
    }

    if (v3)
    {
      *(v3 + 16) = v2;
    }

    v4 = *(a2 + 24);
    v5 = *(a2 + 32);
    if (v4)
    {
      *(v4 + 32) = v5;
    }

    if (v5)
    {
      *(v5 + 24) = v4;
    }

    if (*(result + 16))
    {
      *(a2 + 44) = -1;
      *a2 = *(result + 40);
      *(result + 40) = a2;
    }
  }

  return result;
}

uint64_t geo::Triangulator<unsigned short,unsigned short>::GeometricHasher::mortonEncode(unsigned __int16 *a1, int a2, int a3)
{
  v3 = a1[4];
  v4 = 0xFFFF * (a2 - *a1) / v3;
  v5 = (v4 | (v4 << 8)) & 0xF000F | (16 * ((v4 | (v4 << 8)) & 0xFF00FF)) & 0xF0F0F0F;
  v6 = ((0xFFFF * (a3 - a1[1]) / v3) | ((0xFFFF * (a3 - a1[1]) / v3) << 8)) & 0xFF00FF;
  v7 = (v6 | (16 * v6)) & 0x3030303 | (4 * ((v6 | (16 * v6)) & 0xF0F0F0F)) & 0x33333333;
  return ((4 * v7) | (2 * v7)) & 0xAAAAAAAA | (v5 | (4 * v5)) & 0x11111111 | (2 * ((v5 | (4 * v5)) & 0x33333333)) & 0x55555555;
}

void *std::construct_at[abi:nn200100]<ggl::PolygonBase::CompressedMeshMesh,char const(&)[21],std::shared_ptr<ggl::VertexDataTyped<ggl::PolygonBase::CompressedVbo>>,std::shared_ptr<ggl::IndexDataTyped<unsigned short>>,ggl::PolygonBase::CompressedMeshMesh*>(void *a1, __int128 *a2, __int128 *a3)
{
  v8 = *a2;
  v6 = *(&v8 + 1);
  *a2 = 0;
  *(a2 + 1) = 0;
  v7 = *a3;
  v5 = *(&v7 + 1);
  *a3 = 0;
  *(a3 + 1) = 0;
  ggl::PolygonBase::CompressedMeshMesh::CompressedMeshMesh(a1, "Venue footprint mesh", &v8, &v7);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }

  return a1;
}

uint64_t std::__split_buffer<ggl::PolygonBase::CompressedMeshMesh>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    v4 = *(i - 144);
    *(a1 + 16) = i - 144;
    (*v4)();
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void sub_1B32FC90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  *a17 = off_1F2A59C08;

  _Unwind_Resume(a1);
}

void artworkAndKeyForEtaLabel(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t *a7)
{
  v91 = *MEMORY[0x1E69E9840];
  v12 = a2;
  md::RoadSignColoring::RoadSignColoring(&v58);
  v52[0] = 0;
  __asm { FMOV            V0.2D, #1.0 }

  *&v52[8] = _Q0;
  *&v52[24] = xmmword_1B33B1570;
  *&v52[40] = 0;
  *v53 = 0;
  *&v53[8] = *MEMORY[0x1E695F060];
  v54 = 0uLL;
  *&v53[24] = 0x4034000000000000;
  v55 = xmmword_1B33B1580;
  v56 = 0uLL;
  *v57 = 0x401A000000000000;
  *&v57[8] = *&v53[8];
  *&v57[24] = 0;
  __asm { FMOV            V1.2D, #6.0 }

  *&v66._orientation = _Q0;
  *&v66._contentScale = _Q1;
  *&v66._arrowLength = xmmword_1B33B1E60;
  v66._arrowJoinCornerRadius = 17.0;
  memset(&v66._shadowOffset, 0, 24);
  memset(&v66._innerStrokeWeight, 0, 24);
  v66._cornerRadius = 0.0;
  v66._verticalMargin = 0.0;
  LOWORD(v66._glyphSize.width) = 1;
  v19 = [v12 routeEtaType];
  v52[0] = a6;
  v20 = *(a3 + 8);
  v21 = *(v20 + 176);
  *&v52[8] = *(*(v20 + 336) + 172);
  *&v52[16] = v21;
  *&v66._orientation = *&v52[8];
  v66._scale = v21;
  if (v19 == 1)
  {
    v22 = 1;
  }

  else
  {
    v22 = 3;
  }

  LOBYTE(v66._glyphSize.width) = v22;
  RoadSignMetadataForStyleQuery = GetRoadSignMetadataForStyleQuery(a3, *a4, *(a4 + 8), (a4 + 32), &v58, v52, &v66);
  if (RoadSignMetadataForStyleQuery)
  {
    v49 = a1;
    memset(&v64, 0, sizeof(v64));
    v65[3] = 0;
    v24 = [v12 imageProvider];
    v25 = v24 == 0;

    if (!v25)
    {
      v26 = [v12 imageProvider];
      v27 = [v12 customImageKey];
      v28 = v27;
      std::string::__assign_external(&v64, [v27 UTF8String]);
      *&v81 = &unk_1F2A59C28;
      *(&v81 + 1) = v26;
      *&v82 = v27;
      *(&v82 + 1) = &v81;
      std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::swap[abi:nn200100](&v81, v65);
      std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](&v81);
    }

    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v62, v64.__r_.__value_.__l.__data_, v64.__r_.__value_.__l.__size_);
    }

    else
    {
      v62 = v64;
    }

    std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn200100](v63, v65);
    v29 = *(a4 + 16);
    if (v29)
    {
      v30 = *(a4 + 24);
      if (v30)
      {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(&__len_1, v29, v30);
      if (v30)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v30);
      }

      if (v71)
      {
        _ZNSt3__115allocate_sharedB8nn200100IN2md13LabelImageKeyENS_9allocatorIS2_EEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_();
      }

      v50 = 0;
      v51 = 0;
      if (*(&v70 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&v70 + 1));
      }

      if (*(&__len_1 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&__len_1 + 1));
      }
    }

    else
    {
      v50 = 0;
      v51 = 0;
    }

    std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](v63);
    if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v62.__r_.__value_.__l.__data_);
    }

    v31 = [v12 etaText];
    v67 = &unk_1F2A43ED8;
    __p = 0;
    v32 = v31;
    RoadSignKey = VKLabelNavArtworkCache::getRoadSignKey(v32, 0, v52, &v66, &v58, v33);

    v61 = RoadSignKey;
    v35 = geo::LRUPolicy<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>>::get(*a7 + 48, (*a7 + 8), RoadSignKey);
    if (*a7 + 48 == v35)
    {
      v66._glyphVerticalOffset = 0.0;
      v66._glyphSize.height = 0.0;
      v36 = a7[2];
      v87 = v55;
      v88 = v56;
      v89 = *v57;
      v90 = *&v57[16];
      v83 = *&v52[32];
      v84 = *v53;
      v85 = *&v53[16];
      v86 = v54;
      v81 = *v52;
      v82 = *&v52[16];
      __len_1 = *&v66._orientation;
      v70 = *&v66._contentScale;
      v71 = *&v66._arrowLength;
      arrowJoinCornerRadius = v66._arrowJoinCornerRadius;
      strokeWeight_low = LOBYTE(v66._strokeWeight);
      if (SHIBYTE(v66._shadowRadius) < 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::__init_copy_ctor_external(&shadowOffset, *&v66._shadowOffset.width, *&v66._shadowOffset.height);
      }

      else
      {
        shadowOffset = v66._shadowOffset;
        shadowRadius = v66._shadowRadius;
      }

      horizontalMargin_low = LOBYTE(v66._horizontalMargin);
      if (SHIBYTE(v66._signMargin) < 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::__init_copy_ctor_external(&v76, *&v66._innerStrokeWeight, *&v66._signHeight);
      }

      else
      {
        v76 = *&v66._innerStrokeWeight;
        signMargin = v66._signMargin;
      }

      v79 = *&v66._verticalMargin;
      width_low = LOWORD(v66._glyphSize.width);
      v37 = a7[6];
      v59 = a7[5];
      v60 = v37;
      if (v37)
      {
        atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }

      v38 = md::RoadSignArtworkGenerator::generateRoadSignArtwork(v36, v32, &v81, &__len_1, &v58, &v66._glyphSize.height, &v59);
      v39 = v60;
      if (v60)
      {
        std::__shared_weak_count::__release_weak(v60);
      }

      if (SHIBYTE(signMargin) < 0)
      {
        v40 = v76;
        v41 = mdm::zone_mallocator::instance(v39);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v41, v40);
      }

      if (SHIBYTE(shadowRadius) < 0)
      {
        width = shadowOffset.width;
        v43 = mdm::zone_mallocator::instance(v39);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v43, *&width);
      }

      geo::_retain_ptr<LabelNavRouteContextObserverProxy * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::reset(&v67, v38);
      v44 = *a7;
      geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr(&v81, &v67);
      geo::Cache<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>,geo::LRUPolicy>::insert(v44, &v61, &v81);
    }

    geo::_retain_ptr<VKARWalkingFeatureSet * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator=(&v67, *(v35 + 32));
    *v49 = __p;
    v49[1] = RoadSignKey;
    v67 = &unk_1F2A43ED8;

    RoadSignMetadataForStyleQuery = std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](v65);
    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v64.__r_.__value_.__l.__data_);
    }
  }

  else
  {
    *a1 = 0;
    a1[1] = 0;
  }

  if (SHIBYTE(v66._signMargin) < 0)
  {
    innerStrokeWeight = v66._innerStrokeWeight;
    v46 = mdm::zone_mallocator::instance(RoadSignMetadataForStyleQuery);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v46, *&innerStrokeWeight);
  }

  if (SHIBYTE(v66._shadowRadius) < 0)
  {
    v47 = v66._shadowOffset.width;
    v48 = mdm::zone_mallocator::instance(RoadSignMetadataForStyleQuery);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v48, *&v47);
  }
}

void sub_1B32FDA0C(mdm::zone_mallocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, mdm::zone_mallocator *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  if (SLOBYTE(STACK[0x33F]) < 0)
  {
    operator delete(STACK[0x328]);
  }

  if (SLOBYTE(STACK[0x3E7]) < 0)
  {
    v74 = STACK[0x3D0];
    v75 = mdm::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v75, v74);
  }

  if (a71)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a71);
  }

  if (LOBYTE(STACK[0x360]) == 1)
  {
    (*(*STACK[0x340] + 56))();
  }

  if (STACK[0x358])
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](STACK[0x358]);
  }

  if (STACK[0x348])
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](STACK[0x348]);
  }

  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](v72 + 24);
  if (SLOBYTE(STACK[0x217]) < 0)
  {
    operator delete(STACK[0x200]);
  }

  v76 = std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](&STACK[0x250]);
  if (SLOBYTE(STACK[0x24F]) < 0)
  {
    operator delete(STACK[0x238]);
  }

  if (SLOBYTE(STACK[0x2DF]) < 0)
  {
    v77 = STACK[0x2C8];
    v78 = mdm::zone_mallocator::instance(v76);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v78, v77);
  }

  if (SLOBYTE(STACK[0x2BF]) < 0)
  {
    v79 = STACK[0x2A8];
    v80 = mdm::zone_mallocator::instance(v76);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v80, v79);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0,std::allocator<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0>,CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::operator()(uint64_t a1, _DWORD *a2, _DWORD *a3, double a4, double a5, double a6)
{
  LODWORD(a6) = *a3;
  LODWORD(a4) = *a2;
  LODWORD(a5) = a2[1];
  return [*(a1 + 8) imageForCustomImageKey:*(a1 + 16) suggestedSize:*&a4 contentScale:{*&a5, a6}];
}

void std::__function::__func<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0,std::allocator<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0>,CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void std::__function::__func<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0,std::allocator<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0>,CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::destroy(uint64_t a1)
{
  v2 = *(a1 + 8);
}

id std::__function::__func<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0,std::allocator<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0>,CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2A59C28;
  a2[1] = *(a1 + 8);
  result = *(a1 + 16);
  a2[2] = result;
  return result;
}

void std::__function::__func<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0,std::allocator<artworkAndKeyForEtaLabel(VKRouteEtaDescription *,md::NavContext const*,md::RoadSignStyleGroup const&,geo::Mercator2<double> const&,md::RoadSignOrientation,BOOL,VKLabelNavArtworkCache *)::$_0>,CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__func(uint64_t a1)
{

  JUMPOUT(0x1B8C62190);
}

void sub_1B32FE0E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v14)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v14);
  }

  _Unwind_Resume(exception_object);
}

void sub_1B32FE67C(mdm::zone_mallocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, std::__shared_weak_count *a24, uint64_t a25, std::__shared_weak_count *a26, uint64_t a27, std::__shared_weak_count *a28)
{
  v35 = mdm::zone_mallocator::instance(a1);
  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v35, v29);
  if (v28)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v28);
  }

  md::NavLabel::~NavLabel(v31);

  if (v32)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v32);
  }

  MEMORY[0x1B8C62190](v31, 0x10B3C40B01559D4);
  if (a28)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a28);
  }

  if (a26)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a26);
  }

  if (a24)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a24);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<md::NavRouteEta *,std::shared_ptr<md::NavLabel>::__shared_ptr_default_delete<md::NavLabel,md::NavRouteEta>,std::allocator<md::NavRouteEta>>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<md::NavRouteEta *,std::shared_ptr<md::NavLabel>::__shared_ptr_default_delete<md::NavLabel,md::NavRouteEta>,std::allocator<md::NavRouteEta>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B32FE904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  v10 = v9;
  a9.receiver = v10;
  a9.super_class = VKLabelNavRouteEta;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B32FEF38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::vector<GeoCodecsFeatureStylePair,geo::allocator_adapter<GeoCodecsFeatureStylePair,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](va);

  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v12);
  }

  _Unwind_Resume(a1);
}

void md::NavContext::styleQueryForFeatureAttributes(md::NavContext *this, GEOFeatureStyleAttributes *a2, void *a3)
{
  v5 = a3;
  v6 = *(a2 + 1);
  v9 = v5;
  v7 = [v5 featureStyleAttributesPtr];
  v8 = v7[1];
  v10[0] = *v7;
  v10[1] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  md::LabelStyleCache::styleQueryForFeatureAttributes(this, (*(v6 + 336) + 184), v10, 0);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }
}

void sub_1B32FF050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v10);
  }

  _Unwind_Resume(a1);
}

void sub_1B32FF7F8(_Unwind_Exception *a1)
{
  std::vector<GeoCodecsFeatureStylePair,geo::allocator_adapter<GeoCodecsFeatureStylePair,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v2);

  _Unwind_Resume(a1);
}

uint64_t md::TrafficIncidentIconLabelPart::debugString@<X0>(md::TrafficIncidentIconLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v12);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v12, "TrafficIncident", 15);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v12, "\n  ", 3);
  md::IconLabelPart::debugString(this, __p);
  if ((v11 & 0x80u) == 0)
  {
    v4 = __p;
  }

  else
  {
    v4 = __p[0];
  }

  if ((v11 & 0x80u) == 0)
  {
    v5 = v11;
  }

  else
  {
    v5 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v12, v4, v5);
  if (v11 < 0)
  {
    operator delete(__p[0]);
  }

  if ((v19 & 0x10) != 0)
  {
    v7 = v18;
    if (v18 < v15)
    {
      v18 = v15;
      v7 = v15;
    }

    locale = v14[4].__locale_;
  }

  else
  {
    if ((v19 & 8) == 0)
    {
      v6 = 0;
      a2[23] = 0;
      goto LABEL_22;
    }

    locale = v14[1].__locale_;
    v7 = v14[3].__locale_;
  }

  v6 = v7 - locale;
  if ((v7 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v6 >= 0x17)
  {
    operator new();
  }

  a2[23] = v6;
  if (v6)
  {
    memmove(a2, locale, v6);
  }

LABEL_22:
  a2[v6] = 0;
  v12 = *MEMORY[0x1E69E54E8];
  *(&v12 + *(v12 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v13 = MEMORY[0x1E69E5548] + 16;
  if (v17 < 0)
  {
    operator delete(v16);
  }

  v13 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v14);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v20);
}

void sub_1B32FFAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  a15 = *MEMORY[0x1E69E54E8];
  *(&a15 + *(a15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a16 = MEMORY[0x1E69E5548] + 16;
  if (a29 < 0)
  {
    operator delete(a24);
  }

  a16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a17);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a32);
  _Unwind_Resume(a1);
}

void md::TrafficIncidentIconLabelPart::~TrafficIncidentIconLabelPart(md::TrafficIncidentIconLabelPart *this)
{
  md::IconLabelPart::~IconLabelPart(this);
  v3 = mdm::zone_mallocator::instance(v2);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, this);
}

void std::__shared_ptr_emplace<ggl::Glow::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A940;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::GlowAlpha::MeshPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A908;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::Glow::Style>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Glow::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A868;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B33003D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a12);
  }

  MEMORY[0x1B8C62190](v12, v13);
  _Unwind_Resume(a1);
}

void ggl::ConstantDataTyped<ggl::GlowAlpha::Glow>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlowAlpha::Glow>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A780;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::PolygonShadowedStroke::ShadowPath>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PolygonShadowedStroke::ShadowPath>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::PolygonShadowedStroke::ShadowPathPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5A480;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::MultipleIconLabelPart::debugCompositeClassName@<X0>(md::MultipleIconLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v15);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, "MultipleIcons, ", 15);
  md::StackLabelPart::debugCompositeClassName(this, __p);
  if ((v14 & 0x80u) == 0)
  {
    v4 = __p;
  }

  else
  {
    v4 = __p[0];
  }

  if ((v14 & 0x80u) == 0)
  {
    v5 = v14;
  }

  else
  {
    v5 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, v4, v5);
  if (v14 < 0)
  {
    operator delete(__p[0]);
  }

  if (*(this + 183))
  {
    if (*(this + 188))
    {
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v15, ", multiPOI(", 11);
      v6 = MEMORY[0x1B8C61C90](&v15, *(this + 188));
      v7 = ")";
      v8 = 1;
    }

    else
    {
      v7 = ", multiPOI-fallback";
      v6 = &v15;
      v8 = 19;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v6, v7, v8);
  }

  if ((v22 & 0x10) != 0)
  {
    v10 = v21;
    if (v21 < v18)
    {
      v21 = v18;
      v10 = v18;
    }

    locale = v17[4].__locale_;
  }

  else
  {
    if ((v22 & 8) == 0)
    {
      v9 = 0;
      a2[23] = 0;
      goto LABEL_27;
    }

    locale = v17[1].__locale_;
    v10 = v17[3].__locale_;
  }

  v9 = v10 - locale;
  if ((v10 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v9 >= 0x17)
  {
    operator new();
  }

  a2[23] = v9;
  if (v9)
  {
    memmove(a2, locale, v9);
  }

LABEL_27:
  a2[v9] = 0;
  v15 = *MEMORY[0x1E69E54E8];
  *(&v15 + *(v15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v16 = MEMORY[0x1E69E5548] + 16;
  if (v20 < 0)
  {
    operator delete(v19);
  }

  v16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v17);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v23);
}

void sub_1B3300C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  if (a14 < 0)
  {
    operator delete(__p);
  }

  a15 = *MEMORY[0x1E69E54E8];
  *(&a15 + *(a15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a16 = MEMORY[0x1E69E5548] + 16;
  if (a29 < 0)
  {
    operator delete(a24);
  }

  a16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a17);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a32);
  _Unwind_Resume(a1);
}

uint64_t md::MultipleIconLabelPart::needsCrossfade(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  if (!a3)
  {
    return 0;
  }

  if (!*(a1 + 747))
  {
    return 0;
  }

  if (md::LabelIconStyleMonitor::needsCrossfade(a1 + 696, **(a1 + 32), a4))
  {
    return 1;
  }

  v8 = *(a1 + 576);
  v9 = *(a1 + 584);
  if (v8 == v9)
  {
    return 0;
  }

  v10 = v8 + 8;
  do
  {
    result = (*(**(v10 - 8) + 768))(*(v10 - 8), a2, 1, a4);
    if (result)
    {
      break;
    }

    v11 = v10 == v9;
    v10 += 8;
  }

  while (!v11);
  return result;
}

uint64_t md::MultipleIconLabelPart::layoutForStaging(float32x2_t *a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4)
{
  v36 = *MEMORY[0x1E69E9840];
  if (a1[94].i8[4] == 1)
  {
    v26 = a2;
    v27 = a3;
    v28 = a4;
    v35 = 0;
    v33 = v34;
    v34[0] = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v5 = a1[72];
    v6 = a1[73];
    if (v5 == v6)
    {
      a1[94].i8[4] = 0;
    }

    else
    {
      do
      {
        v7 = *v5;
        v29 = v7;
        v8 = atomic_load((*(v7 + 640) + 142));
        if ((v8 & 1) == 0)
        {
          std::vector<md::LabelPart *,geo::allocator_adapter<md::LabelPart *,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v30);
          std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(v34[0]);
          return 15;
        }

        v9 = atomic_load((*(v7 + 640) + 143));
        if (v9)
        {
          v10 = md::LabelIcon::image(*(v7 + 640));
          v11 = v10;
          v12 = v34[0];
          v13 = v34;
          v14 = v34;
          if (!v34[0])
          {
            goto LABEL_16;
          }

          v13 = v34;
          while (1)
          {
            while (1)
            {
              v14 = v12;
              v10 = [v11 compareTo:v12[4]];
              if ((v10 & 0x80000000) == 0)
              {
                break;
              }

              v12 = *v14;
              v13 = v14;
              if (!*v14)
              {
                goto LABEL_16;
              }
            }

            v10 = [v14[4] compareTo:v11];
            if ((v10 & 0x80000000) == 0)
            {
              break;
            }

            v13 = v14 + 1;
            v12 = v14[1];
            if (!v12)
            {
              goto LABEL_16;
            }
          }

          if (*v13)
          {

            std::vector<md::LabelPart *,geo::allocator_adapter<md::LabelPart *,mdm::zone_mallocator>>::push_back[abi:nn200100](&v30, &v29);
          }

          else
          {
LABEL_16:
            v15 = mdm::zone_mallocator::instance(v10);
            v16 = pthread_rwlock_rdlock((v15 + 32));
            if (v16)
            {
              geo::read_write_lock::logFailure(v16, "read lock", v17);
            }

            v18 = malloc_type_zone_malloc(*v15, 0x28uLL, 0x10A0040AE65CA53uLL);
            atomic_fetch_add((v15 + 24), 1u);
            geo::read_write_lock::unlock((v15 + 32));
            v18[4] = v11;
            *v18 = 0;
            v18[1] = 0;
            v18[2] = v14;
            *v13 = v18;
            if (*v33)
            {
              v33 = *v33;
              v18 = *v13;
            }

            std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v34[0], v18);
            ++v35;
          }
        }

        else
        {
          std::vector<md::LabelPart *,geo::allocator_adapter<md::LabelPart *,mdm::zone_mallocator>>::push_back[abi:nn200100](&v30, &v29);
        }

        ++v5;
      }

      while (v5 != v6);
      v19 = v30;
      v20 = v31;
      a1[94].i8[4] = 0;
      while (v19 != v20)
      {
        v21 = *v19;
        v22 = a1[72];
        v23 = a1[73];
        if (v22 != v23)
        {
          while (*v22 != v21)
          {
            if (++v22 == v23)
            {
              goto LABEL_36;
            }
          }

          if (v22 != v23)
          {
            v24 = v22 + 1;
            if (v22 + 1 != v23)
            {
              do
              {
                if (*v24 != v21)
                {
                  *v22++ = *v24;
                }

                ++v24;
              }

              while (v24 != v23);
              v23 = a1[73];
            }
          }
        }

        if (v22 != v23)
        {
          a1[73] = v22;
        }

LABEL_36:
        if (v21)
        {
          (*(*v21 + 8))(v21);
        }

        ++v19;
      }
    }

    std::vector<md::LabelPart *,geo::allocator_adapter<md::LabelPart *,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v30);
    std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(v34[0]);
    a3 = v27;
    a4 = v28;
    a2 = v26;
  }

  if (*&a1[72] == *&a1[73])
  {
    return 16;
  }

  else
  {
    return md::StackLabelPart::layoutForStaging(a1, a2, a3, a4);
  }
}

void sub_1B330117C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  std::vector<md::LabelPart *,geo::allocator_adapter<md::LabelPart *,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a14);
  std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(a19);
  _Unwind_Resume(a1);
}

void std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(*a1);
    std::__tree<VKImage * {__strong},md::VKImageLessPredicate,geo::allocator_adapter<VKImage * {__strong},mdm::zone_mallocator>>::destroy(a1[1]);

    v3 = mdm::zone_mallocator::instance(v2);
    v4 = pthread_rwlock_rdlock((v3 + 32));
    if (v4)
    {
      geo::read_write_lock::logFailure(v4, "read lock", v5);
    }

    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void md::MultipleIconLabelPart::~MultipleIconLabelPart(md::MultipleIconLabelPart *this)
{
  *this = &unk_1F2A5AA50;
  if (*(this + 719) < 0)
  {
    v2 = *(this + 87);
    v3 = mdm::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v3, v2);
  }

  md::CompositeLabelPart::~CompositeLabelPart(this);
  v5 = mdm::zone_mallocator::instance(v4);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v5, this);
}

{
  *this = &unk_1F2A5AA50;
  if (*(this + 719) < 0)
  {
    v2 = *(this + 87);
    v3 = mdm::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v3, v2);
  }

  md::CompositeLabelPart::~CompositeLabelPart(this);
}

uint64_t md::MultipleIconLabelPart::MultipleIconLabelPart(uint64_t a1, md::LabelStyle *a2, int a3)
{
  md::StackLabelPart::StackLabelPart(a1, 1, 0, 0, 0);
  *v6 = &unk_1F2A5AA50;
  md::LabelIconStyleMonitor::LabelIconStyleMonitor((v6 + 87), 1, a2);
  *(a1 + 752) = a3;
  *(a1 + 756) = 1;
  return a1;
}

uint64_t md::CompositeLabelPart::partIntersectsDisplayFrustum(uint64_t a1, double *a2)
{
  v4 = md::LabelPart::partIntersectsDisplayFrustum(a1, a2);
  v5 = v4;
  v6 = *(a1 + 630);
  if ((v6 & 1) != 0 || !v4)
  {
    goto LABEL_8;
  }

  v7 = *(a1 + 576);
  v8 = *(a1 + 584);
  if (v7 == v8)
  {
    v6 = 0;
LABEL_8:
    v9 = v6 & v5;
    return v9 & 1;
  }

  while (((*(**v7 + 496))(*v7, a2) & 1) == 0)
  {
    if (++v7 == v8)
    {
      v6 = *(a1 + 630);
      goto LABEL_8;
    }
  }

  v9 = 1;
  return v9 & 1;
}

uint64_t md::CompositeLabelPart::partIntersectsStagingFrustum(uint64_t a1, double *a2)
{
  v4 = md::LabelPart::partIntersectsStagingFrustum(a1, a2);
  v5 = v4;
  v6 = *(a1 + 630);
  if ((v6 & 1) != 0 || !v4)
  {
    goto LABEL_8;
  }

  v7 = *(a1 + 576);
  v8 = *(a1 + 584);
  if (v7 == v8)
  {
    v6 = 0;
LABEL_8:
    v9 = v6 & v5;
    return v9 & 1;
  }

  while (((*(**v7 + 488))(*v7, a2) & 1) == 0)
  {
    if (++v7 == v8)
    {
      v6 = *(a1 + 630);
      goto LABEL_8;
    }
  }

  v9 = 1;
  return v9 & 1;
}

uint64_t md::CompositeLabelPart::partCollidesWithDisplayObject(md::CompositeLabelPart *this, const md::CollisionObject *a2)
{
  v4 = md::LabelPart::partCollidesWithDisplayObject(this, a2);
  v5 = v4;
  v6 = *(this + 630);
  if ((v6 & 1) != 0 || !v4)
  {
    goto LABEL_8;
  }

  v7 = *(this + 72);
  v8 = *(this + 73);
  if (v7 == v8)
  {
    v6 = 0;
LABEL_8:
    v9 = v6 & v5;
    return v9 & 1;
  }

  while (((*(**v7 + 480))(*v7, a2) & 1) == 0)
  {
    if (++v7 == v8)
    {
      v6 = *(this + 630);
      goto LABEL_8;
    }
  }

  v9 = 1;
  return v9 & 1;
}

uint64_t md::CompositeLabelPart::partCollidesWithObject(md::CompositeLabelPart *this, const md::CollisionObject *a2)
{
  v4 = md::LabelPart::partCollidesWithObject(this, a2);
  v5 = v4;
  v6 = *(this + 630);
  if ((v6 & 1) != 0 || !v4)
  {
    goto LABEL_8;
  }

  v7 = *(this + 72);
  v8 = *(this + 73);
  if (v7 == v8)
  {
    v6 = 0;
LABEL_8:
    v9 = v6 & v5;
    return v9 & 1;
  }

  while (((*(**v7 + 472))(*v7, a2) & 1) == 0)
  {
    if (++v7 == v8)
    {
      v6 = *(this + 630);
      goto LABEL_8;
    }
  }

  v9 = 1;
  return v9 & 1;
}

uint64_t md::CompositeLabelPart::setRenderOrder(uint64_t this, uint64_t a2)
{
  v2 = *(this + 576);
  for (i = *(this + 584); v2 != i; this = (*(*v5 + 832))(v5, a2))
  {
    v5 = *v2++;
  }

  return this;
}

uint64_t md::CompositeLabelPart::populateDebugNode(uint64_t this, DebugTreeNode *a2)
{
  v2 = *(this + 576);
  for (i = *(this + 584); v2 != i; this = (*(*v5 + 808))(v5, a2))
  {
    v5 = *v2++;
  }

  return this;
}

uint64_t md::CompositeLabelPart::debugString@<X0>(uint64_t **this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v20);
  ((*this)[113])(&__p, this);
  if ((v19 & 0x80u) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p;
  }

  if ((v19 & 0x80u) == 0)
  {
    v7 = v19;
  }

  else
  {
    v7 = v18;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v20, p_p, v7);
  if (v19 < 0)
  {
    operator delete(__p);
  }

  v8 = this[72];
  for (i = this[73]; v8 != i; ++v8)
  {
    v10 = *v8;
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v20, "\n ", 2);
    (*(*v10 + 800))(&__p, v10, a2);
    if ((v19 & 0x80u) == 0)
    {
      v11 = &__p;
    }

    else
    {
      v11 = __p;
    }

    if ((v19 & 0x80u) == 0)
    {
      v12 = v19;
    }

    else
    {
      v12 = v18;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v20, v11, v12);
    if (v19 < 0)
    {
      operator delete(__p);
    }
  }

  if ((v27 & 0x10) != 0)
  {
    v14 = v26;
    if (v26 < v23)
    {
      v26 = v23;
      v14 = v23;
    }

    locale = v22[4].__locale_;
  }

  else
  {
    if ((v27 & 8) == 0)
    {
      v13 = 0;
      a3[23] = 0;
      goto LABEL_32;
    }

    locale = v22[1].__locale_;
    v14 = v22[3].__locale_;
  }

  v13 = v14 - locale;
  if ((v14 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v13 >= 0x17)
  {
    operator new();
  }

  a3[23] = v13;
  if (v13)
  {
    memmove(a3, locale, v13);
  }

LABEL_32:
  a3[v13] = 0;
  v20 = *MEMORY[0x1E69E54E8];
  *(&v20 + *(v20 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v21 = MEMORY[0x1E69E5548] + 16;
  if (v25 < 0)
  {
    operator delete(v24);
  }

  v21 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v22);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v28);
}

void sub_1B3301AB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  a15 = *MEMORY[0x1E69E54E8];
  *(&a15 + *(a15 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a16 = MEMORY[0x1E69E5548] + 16;
  if (a29 < 0)
  {
    operator delete(__p);
  }

  a16 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a17);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a32);
  _Unwind_Resume(a1);
}

void md::CompositeLabelPart::debugDrawWorldForWorld(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, float32x4_t a6)
{
  if (*(a1 + 630))
  {
    v8 = (a1 + 312);
    v9 = a2 + 432;

    md::CollisionObject::worldDrawDebugHighlightWithContext(v8, v9, a3, a4, a5, a6);
  }

  else
  {
    v10 = *(a1 + 576);
    v11 = *(a1 + 584);
    while (v10 != v11)
    {
      v12 = *v10++;
      (*(*v12 + 792))(v12, a2, a3);
    }
  }
}

void md::CompositeLabelPart::debugDrawWorldForStaging(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, float32x4_t a6)
{
  if (*(a1 + 630))
  {
    v8 = *(a2 + 424);
    v9 = (a1 + 72);

    md::CollisionObject::worldDrawDebugHighlightWithContext(v9, v8, a3, a4, a5, a6);
  }

  else
  {
    v10 = *(a1 + 576);
    v11 = *(a1 + 584);
    while (v10 != v11)
    {
      v12 = *v10++;
      (*(*v12 + 784))(v12, a2, a3);
    }
  }
}

void md::CompositeLabelPart::debugDraw(uint64_t a1, ggl::DebugConsole *a2, double a3)
{
  md::LabelPart::debugDraw(a1, a2, a3);
  if ((*(a1 + 630) & 1) == 0)
  {
    v5 = *(a1 + 576);
    v6 = *(a1 + 584);
    while (v5 != v6)
    {
      v7 = *v5++;
      (*(*v7 + 776))(v7, a2);
    }
  }
}

uint64_t md::CompositeLabelPart::isTextVisible(md::CompositeLabelPart *this)
{
  v1 = *(this + 72);
  v2 = *(this + 73);
  if (v1 == v2)
  {
    return 0;
  }

  v3 = v1 + 8;
  do
  {
    result = (*(**(v3 - 8) + 752))(*(v3 - 8));
    if (result)
    {
      break;
    }

    v5 = v3 == v2;
    v3 += 8;
  }

  while (!v5);
  return result;
}

uint64_t md::CompositeLabelPart::populateImageInfos(uint64_t result, uint64_t a2)
{
  v2 = *(result + 576);
  for (i = *(result + 584); v2 != i; result = (*(*v5 + 736))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

uint64_t md::CompositeLabelPart::hasSelectableParts(md::CompositeLabelPart *this)
{
  v1 = *(this + 72);
  v2 = *(this + 73);
  while (1)
  {
    if (v1 == v2)
    {
      return 0;
    }

    v3 = *v1;
    if (((*(**v1 + 656))(*v1) & 1) != 0 || (*(*v3 + 648))(v3))
    {
      break;
    }

    ++v1;
  }

  return 1;
}

uint64_t md::CompositeLabelPart::populateHoverBounds(uint64_t result, uint64_t a2)
{
  v2 = *(result + 576);
  for (i = *(result + 584); v2 != i; result = (*(*v5 + 528))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

uint64_t md::CompositeLabelPart::intersectsDisplayFrustum(uint64_t a1, double *a2)
{
  if (*(a1 + 630) == 1)
  {
    if (*(a1 + 565) == 1)
    {
      v3 = a1 + 312;

      return md::CollisionObject::intersectsWorldFrustum(v3, a2);
    }

    return 0;
  }

  v5 = *(a1 + 576);
  v6 = *(a1 + 584);
  if (v5 == v6)
  {
    return 0;
  }

  v7 = v5 + 8;
  do
  {
    result = (*(**(v7 - 8) + 872))(*(v7 - 8), a2);
    if (result)
    {
      break;
    }

    v8 = v7 == v6;
    v7 += 8;
  }

  while (!v8);
  return result;
}

uint64_t md::CompositeLabelPart::intersectsStagingFrustum(uint64_t a1, double *a2)
{
  if (*(a1 + 630) == 1)
  {
    if (*(a1 + 565) == 1 && *(a1 + 566) == 1)
    {
      v3 = a1 + 312;

      return md::CollisionObject::intersectsWorldFrustum(v3, a2);
    }

    return 0;
  }

  v5 = *(a1 + 576);
  v6 = *(a1 + 584);
  if (v5 == v6)
  {
    return 0;
  }

  v7 = v5 + 8;
  do
  {
    result = (*(**(v7 - 8) + 864))(*(v7 - 8), a2);
    if (result)
    {
      break;
    }

    v8 = v7 == v6;
    v7 += 8;
  }

  while (!v8);
  return result;
}

uint64_t md::CompositeLabelPart::collidesWithDisplayObject(md::CompositeLabelPart *this, const md::CollisionObject *a2)
{
  if (*(this + 630) == 1)
  {

    return md::LabelPart::collidesWithDisplayObject(this, a2);
  }

  else
  {
    v4 = *(this + 72);
    v5 = *(this + 73);
    if (v4 == v5)
    {
      return 0;
    }

    else
    {
      v6 = v4 + 8;
      do
      {
        result = (*(**(v6 - 8) + 856))(*(v6 - 8), a2);
        if (result)
        {
          break;
        }

        v7 = v6 == v5;
        v6 += 8;
      }

      while (!v7);
    }
  }

  return result;
}

uint64_t md::CompositeLabelPart::collidesWithObject(md::CompositeLabelPart *this, const md::CollisionObject *a2)
{
  v2 = a2;
  if (*(this + 630) != 1)
  {
    v6 = *(this + 72);
    v7 = *(this + 73);
    if (v6 != v7)
    {
      v8 = v6 + 8;
      do
      {
        result = (*(**(v8 - 8) + 848))(*(v8 - 8), v2);
        if (result)
        {
          break;
        }

        v9 = v8 == v7;
        v8 += 8;
      }

      while (!v9);
      return result;
    }

    return 0;
  }

  if (*(this + 232) == 0 || (*(a2 + 200) & *(this + 272)) != 0)
  {
    return 0;
  }

  v3 = *(a2 + 21);
  if (*(this + 30))
  {
    v4 = (this + 72);
    if (v3)
    {

      return md::CollisionObject::circlesCollideWithCircles(v4, a2);
    }

    goto LABEL_19;
  }

  if (v3)
  {
    a2 = (this + 72);
    v4 = v2;
LABEL_19:

    return md::CollisionObject::circlesCollideWithRects(v4, a2);
  }

  if ((*(this + 268) & 1) != 0 || *(a2 + 196) == 1)
  {
    v10 = (this + 72);

    return md::CollisionObject::rectsCollideWithRectsOBB(v10, a2);
  }

  else
  {
    v11 = (this + 72);

    return md::CollisionObject::rectsCollideWithRects(v11, a2);
  }
}

uint64_t md::CompositeLabelPart::collidesWithItem(md::CompositeLabelPart *this, float32x2_t *a2, uint64_t a3)
{
  if (*(this + 630) == 1)
  {
    v4 = *(*a2 + 16);

    return v4(a2, this + 72);
  }

  else
  {
    v6 = *(this + 72);
    v7 = *(this + 73);
    if (v6 == v7)
    {
      return 0;
    }

    else
    {
      v9 = v6 + 8;
      do
      {
        result = md::LabelPart::partCollidesWithItem(*(v9 - 8), a2, a3);
        if (result)
        {
          break;
        }

        v10 = v9 == v7;
        v9 += 8;
      }

      while (!v10);
    }
  }

  return result;
}

uint64_t md::CompositeLabelPart::setPartRotation(uint64_t result, float *a2)
{
  v2 = *a2;
  *(result + 288) = *a2;
  v3 = a2[1];
  *(result + 292) = v3;
  v4 = *(result + 296);
  v5 = *(result + 300);
  v6 = v4 * v3;
  v7 = -((v5 * v3) - (v4 * v2));
  *(result + 88) = v7;
  *(result + 92) = v6 + (v5 * v2);
  *(result + 268) = fabsf(v7 + -1.0) > 0.000001;
  v8 = *a2;
  *(result + 528) = *a2;
  v9 = a2[1];
  *(result + 532) = v9;
  v10 = *(result + 536);
  v11 = *(result + 540);
  v12 = v10 * v9;
  v13 = -((v11 * v9) - (v10 * v8));
  *(result + 328) = v13;
  *(result + 332) = v12 + (v11 * v8);
  *(result + 508) = fabsf(v13 + -1.0) > 0.000001;
  v14 = *(result + 576);
  for (i = *(result + 584); v14 != i; result = (*(*v17 + 384))(v17, a2))
  {
    v17 = *v14++;
  }

  return result;
}

uint64_t md::CompositeLabelPart::setRadialPosition(uint64_t result, uint64_t a2, uint64_t a3)
{
  v3 = *(result + 576);
  for (i = *(result + 584); v3 != i; result = (*(*v7 + 376))(v7, a2, a3))
  {
    v7 = *v3++;
  }

  return result;
}

uint64_t md::CompositeLabelPart::isVisuallySimilar(md::CompositeLabelPart *this, const md::LabelPart *a2, const md::LabelPart *a3)
{
  v3 = *(this + 73);
  v4 = *(this + 72);
  if (v3 - v4 != *(a2 + 73) - *(a2 + 72))
  {
    return 0;
  }

  if (v3 == v4)
  {
    return 1;
  }

  v7 = 0;
  do
  {
    result = md::LabelPart::ArePartsVisuallySimilar(*(v4 + 8 * v7), *(*(a2 + 72) + 8 * v7), a3);
    if ((result & 1) == 0)
    {
      break;
    }

    ++v7;
    v4 = *(this + 72);
  }

  while (v7 < (*(this + 73) - v4) >> 3);
  return result;
}

uint64_t md::CompositeLabelPart::clearLabelAnimationIDs(uint64_t this)
{
  *(this + 564) = -1;
  v1 = *(this + 576);
  v2 = *(this + 584);
  while (v1 != v2)
  {
    v3 = *v1++;
    this = (*(*v3 + 192))(v3);
  }

  return this;
}

uint64_t md::CompositeLabelPart::markActive(uint64_t this)
{
  v1 = *(this + 576);
  v2 = *(this + 584);
  while (v1 != v2)
  {
    v3 = *v1++;
    this = (*(*v3 + 152))(v3);
  }

  return this;
}

uint64_t md::CompositeLabelPart::setInWorldSpace(uint64_t this, uint64_t a2, uint64_t a3)
{
  *(this + 565) = a2;
  *(this + 566) = a3;
  v3 = *(this + 576);
  for (i = *(this + 584); v3 != i; this = (*(*v7 + 64))(v7, a2, a3))
  {
    v7 = *v3++;
  }

  return this;
}

void *md::CompositeLabelPart::setPreviousModelChainTransform(void *result, uint64_t a2)
{
  result[8] = a2;
  v2 = result[72];
  for (i = result[73]; v2 != i; result = (*(*v5 + 56))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

void *md::CompositeLabelPart::setPreviousStagingModelChainTransform(void *result, uint64_t a2)
{
  result[7] = a2;
  v2 = result[72];
  for (i = result[73]; v2 != i; result = (*(*v5 + 48))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

void *md::CompositeLabelPart::setPreviousModelChainMatrix(void *result, uint64_t a2)
{
  result[6] = a2;
  v2 = result[72];
  for (i = result[73]; v2 != i; result = (*(*v5 + 40))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

void *md::CompositeLabelPart::setPreviousStagingModelChainMatrix(void *result, uint64_t a2)
{
  result[5] = a2;
  v2 = result[72];
  for (i = result[73]; v2 != i; result = (*(*v5 + 32))(v5, a2))
  {
    v5 = *v2++;
  }

  return result;
}

unint64_t md::characteristicPointSectionRange(uint64_t a1, unint64_t a2, int a3)
{
  if (a2)
  {
    v3 = 0;
    v4 = 0;
    while (*(a1 + 100 * v3 + 8) != a3)
    {
      v3 = v4 + 1;
      v4 = v3;
      v5 = v3;
      if (v3 >= a2)
      {
        goto LABEL_8;
      }
    }

    v5 = v4;
  }

  else
  {
    v5 = 0;
    v3 = 0;
  }

LABEL_8:
  if (v3 == a2)
  {
    return 0;
  }

  v7 = v5 + 1;
  do
  {
    v8 = v7;
    if (v7 >= a2)
    {
      break;
    }

    ++v7;
  }

  while (*(a1 + 100 * v8 + 8) == a3);
  return v5 | (v8 << 32);
}

void md::trafficStyleAttributes(uint64_t **this, const md::GEOVectorTileResource *a2)
{
  v33 = *MEMORY[0x1E69E9840];
  v3 = *grl::IconMetricsRenderResult::getFillRect(a2);
  if (!v3 || (v4 = *(v3 + 33), !*(v3 + 33)))
  {
LABEL_11:
    *this = 0;
    this[1] = 0;
    this[2] = 0;
    md::TrafficStyleAttributes(&v28, 0);
    if (&v28 != this)
    {
      std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__assign_with_size[abi:nn200100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(this, v28, v29, v29 - v28);
    }

    v13 = &v28;
    goto LABEL_25;
  }

  v5 = *v3;
  if (*v5 != 27)
  {
    v6 = 0;
    v11 = v5 + 2;
    while (v4 - 1 != v6)
    {
      v12 = *v11;
      v11 += 2;
      ++v6;
      if (v12 == 27)
      {
        if (v6 < v4)
        {
          goto LABEL_5;
        }

        goto LABEL_11;
      }
    }

    goto LABEL_11;
  }

  v6 = 0;
LABEL_5:
  v7 = LOWORD(v5[2 * v6 + 1]);
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  md::TrafficStyleAttributes(&v28, 0);
  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::vector[abi:nn200100](&v24, &v28);
  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v28);
  v9 = v25;
  if (v25 >= v26)
  {
    v14 = (v25 - v24) >> 3;
    if ((v14 + 1) >> 61)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v15 = (v26 - v24) >> 2;
    if (v15 <= v14 + 1)
    {
      v15 = v14 + 1;
    }

    if (v26 - v24 >= 0x7FFFFFFFFFFFFFF8)
    {
      v16 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v16 = v15;
    }

    v32 = &v27;
    if (v16)
    {
      v17 = gss::zone_mallocator::instance(v8);
      v18 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<gss::StyleAttribute,unsigned short>>(v17, v16);
    }

    else
    {
      v18 = 0;
    }

    v20 = &v18[8 * v16];
    v19 = &v18[8 * v14];
    *v19 = (v7 << 32) | 0x1B;
    v10 = v19 + 1;
    v21 = v19 - (v25 - v24);
    memcpy(v21, v24, v25 - v24);
    v22 = v24;
    v23 = v26;
    v24 = v21;
    v25 = v10;
    v26 = v20;
    v30 = v22;
    v31 = v23;
    v28 = v22;
    v29 = v22;
    std::__split_buffer<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator> &>::~__split_buffer(&v28);
  }

  else
  {
    *v25 = (v7 << 32) | 0x1B;
    v10 = v9 + 1;
  }

  v25 = v10;
  gss::FeatureAttributeSet::operator=(this, &v24);
  v13 = &v24;
LABEL_25:
  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v13);
}

void sub_1B3302C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&a9);
  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v9);
  _Unwind_Resume(a1);
}

uint64_t *md::Ribbons::RibbonWriter<md::TransitDisplayConnectionRibbonDescriptor>::writeVertex(uint64_t *result, uint64_t a2)
{
  v2 = 0;
  v3 = (fminf(fmaxf(*(a2 + 8), 0.0), 1.0) * 65535.0);
  v4 = (fminf(fmaxf(*(a2 + 12), 0.0), 1.0) * 65535.0);
  v5 = *result;
  v6 = 1;
  do
  {
    v7 = v6;
    *v5 = v3;
    *(v5 + 2) = v4;
    v8.i64[0] = *(a2 + 16 + 8 * v2);
    v8.i64[1] = *(a2 + 40 + 8 * v2);
    v9.i64[0] = 0xBF000000BF000000;
    v9.i64[1] = 0xBF000000BF000000;
    *(v5 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v9, xmmword_1B33B0C70, v8)));
    v5 += 16;
    v2 = 1;
    v6 = 0;
  }

  while ((v7 & 1) != 0);
  *result = v5;
  return result;
}

uint64_t (****std::unique_ptr<md::TransitDisplayConnectionRibbon,mdm::TypeDeleter<md::TransitDisplayConnectionRibbon>>::~unique_ptr[abi:nn200100](uint64_t (****a1)(void)))(void)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = (**v2)(v2);
    v4 = mdm::zone_mallocator::instance(v3);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<md::TransitDisplayConnectionRibbon>(v4, v2);
  }

  return a1;
}

void md::TransitDisplayConnectionRibbon::~TransitDisplayConnectionRibbon(md::TransitDisplayConnectionRibbon *this)
{
  md::Ribbons::StandardModeRibbonUsingPositionType<gm::Matrix<float,2,1>>::~StandardModeRibbonUsingPositionType(this);

  JUMPOUT(0x1B8C62190);
}

uint64_t *std::unique_ptr<md::Ribbons::RibbonSection<md::TransitDisplayConnectionRibbonDescriptor>>::~unique_ptr[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v4 = v2 + 56;
    std::vector<std::unique_ptr<md::TransitDisplayConnectionRibbon,mdm::TypeDeleter<md::TransitDisplayConnectionRibbon>>,geo::allocator_adapter<std::unique_ptr<md::TransitDisplayConnectionRibbon,mdm::TypeDeleter<md::TransitDisplayConnectionRibbon>>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v4);
    MEMORY[0x1B8C62190](v2, 0x1020C40DC9CC32ALL);
  }

  return a1;
}

void std::vector<std::unique_ptr<md::Ribbons::RibbonSection<md::TransitDisplayConnectionRibbonDescriptor>>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
      {
        v4 = std::unique_ptr<md::Ribbons::RibbonSection<md::TransitDisplayConnectionRibbonDescriptor>>::~unique_ptr[abi:nn200100](v4 - 1);
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void md::Ribbons::RibbonBatch<md::TransitDisplayConnectionRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::TransitDisplayConnectionRibbonDescriptor>::~RibbonBatch(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::Ribbons::RibbonBatch<md::TransitDisplayConnectionRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *a1 = &unk_1F2A5B528;
  v6 = (a1 + 376);
  std::vector<std::unique_ptr<md::Ribbons::RibbonSection<md::TransitDisplayConnectionRibbonDescriptor>>>::__destroy_vector::operator()[abi:nn200100](&v6);
  md::FrameAllocator<ggl::RenderItem>::reset(a1 + 352);
  free(*(a1 + 352));
  v2 = *(a1 + 328);
  if (v2)
  {
    *(a1 + 336) = v2;
    operator delete(v2);
  }

  v6 = (a1 + 296);
  std::vector<gm::MultiRange<unsigned long>,geo::allocator_adapter<gm::MultiRange<unsigned long>,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v6);
  v3 = *(a1 + 272);
  if (v3)
  {
    *(a1 + 280) = v3;
    operator delete(v3);
  }

  for (i = 144; i != -112; i -= 128)
  {
    ggl::RenderItem::~RenderItem((a1 + i));
  }

  return a1;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::shared_ptr<md::TextDataString>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 16 * a2, 0x20040A4A59CD2uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v6;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TextDataStringInfo,geo::allocator_adapter<md::TextDataStringInfo,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::TextDataStringInfo,geo::allocator_adapter<md::TextDataStringInfo,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TextDataStringInfo,geo::allocator_adapter<md::TextDataStringInfo,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::TextDataStringInfo,geo::allocator_adapter<md::TextDataStringInfo,mdm::zone_mallocator>>::__on_zero_shared(uint64_t a1)
{
  std::vector<md::TextDataStringInfo::TextFragment,geo::allocator_adapter<md::TextDataStringInfo::TextFragment,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 128));
  if (*(a1 + 119) < 0)
  {
    v3 = *(a1 + 96);
    v4 = mdm::zone_mallocator::instance(v2);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char16_t>(v4, v3);
  }

  if (*(a1 + 87) < 0)
  {
    v5 = *(a1 + 64);
    v6 = mdm::zone_mallocator::instance(v2);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v6, v5);
  }

  if (*(a1 + 55) < 0)
  {
    v7 = *(a1 + 32);
    v8 = mdm::zone_mallocator::instance(v2);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v8, v7);
  }
}

void std::__shared_ptr_emplace<md::TextDataStringInfo,geo::allocator_adapter<md::TextDataStringInfo,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5B7F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TextDataString,geo::allocator_adapter<md::TextDataString,mdm::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<md::TextDataString,geo::allocator_adapter<md::TextDataString,mdm::zone_mallocator>>::__on_zero_shared_weak(mdm::zone_mallocator *a1)
{
  v2 = mdm::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<md::TextDataString,geo::allocator_adapter<md::TextDataString,mdm::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<md::TextDataString,geo::allocator_adapter<md::TextDataString,mdm::zone_mallocator>>::__on_zero_shared(void *a1)
{
  atomic_fetch_add(&md::TextDataString::_totalLabelTextData, 0xFFFFFFFF);
  std::vector<gm::Matrix<double,2,1>,geo::allocator_adapter<gm::Matrix<double,2,1>,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 15));
  v5 = a1 + 11;
  std::vector<md::FontGlyphInfo,geo::allocator_adapter<md::FontGlyphInfo,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v5);
  a1[8] = &unk_1F2A5F810;
  v2 = a1[9];
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = a1[7];
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  v4 = a1[5];
  if (v4)
  {

    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }
}

void std::__shared_ptr_emplace<md::TextDataString,geo::allocator_adapter<md::TextDataString,mdm::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5B830;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t md::CaptionedIconLabelPart::debugCompositeClassName@<X0>(md::CaptionedIconLabelPart *this@<X0>, _BYTE *a2@<X8>)
{
  v95[19] = *MEMORY[0x1E69E9840];
  std::ostringstream::basic_ostringstream[abi:nn200100](&v76);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "CaptionedIcon", 13);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  textDisplayClass: ", 21);
  v4 = *(this + 947);
  v5 = "";
  if (v4 <= 3)
  {
    v5 = off_1E7B35C48[v4];
  }

  std::string::basic_string[abi:nn200100]<0>(&v86, v5);
  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v6 = &v86;
  }

  else
  {
    v6 = v86.__r_.__value_.__r.__words[0];
  }

  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v86.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v86.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v6, size);
  if (*(this + 732))
  {
    v8 = " (optional text is hidden)";
  }

  else
  {
    v8 = "";
  }

  if (*(this + 732))
  {
    v9 = 26;
  }

  else
  {
    v9 = 0;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v8, v9);
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v86.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, " altStyleCount=", 15);
  MEMORY[0x1B8C61C80](&v76, *(this + 945));
  v10 = v76;
  *(&v76 + *(v76 - 24) + 8) = *(&v76 + *(v76 - 24) + 8) & 0xFFFFFEFB | 4;
  *(&v78[0].__locale_ + *(v10 - 24)) = 2;
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  text collision alpha: ", 25);
  std::ostream::operator<<();
  if (*(this + 954) == 1)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, " (persisted opt text collided)", 30);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  layout style:", 16);
  v11 = *(this + 922);
  if (v11 > 0x13)
  {
    v12 = "";
  }

  else
  {
    v12 = off_1E7B3E7A8[v11];
  }

  std::string::basic_string[abi:nn200100]<0>(&v86, v12);
  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v13 = &v86;
  }

  else
  {
    v13 = v86.__r_.__value_.__r.__words[0];
  }

  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v14 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v14 = v86.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v13, v14);
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v86.__r_.__value_.__l.__data_);
  }

  if (*(this + 925) == 1)
  {
    *(&v78[0].__locale_ + *(v76 - 24)) = 1;
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  icon margins[L:", 18);
    v15 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v15, " R:", 3);
    v16 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v16, " T:", 3);
    v17 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v17, " B:", 3);
    v18 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v18, " DiagV:", 7);
    v19 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v19, " DiagH:", 7);
    v20 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v20, "]", 1);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  padding:", 11);
  *(&v78[0].__locale_ + *(v76 - 24)) = 1;
  std::ostream::operator<<();
  if (*(this + 926) == 1)
  {
    if (*(this + 927) != 1)
    {
LABEL_101:
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  [style] placement:(", 22);
      LabelPlacementToShortString(&v86, this + 842);
      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v42 = &v86;
      }

      else
      {
        v42 = v86.__r_.__value_.__r.__words[0];
      }

      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v43 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v43 = v86.__r_.__value_.__l.__size_;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v42, v43);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, ")", 1);
      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v86.__r_.__value_.__l.__data_);
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, " alternates:[", 13);
      gss::to_string(&v86, *(this + 425));
      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v44 = &v86;
      }

      else
      {
        v44 = v86.__r_.__value_.__r.__words[0];
      }

      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v45 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v45 = v86.__r_.__value_.__l.__size_;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v44, v45);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "]", 1);
      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v86.__r_.__value_.__l.__data_);
      }

      if (*(this + 958) == 1)
      {
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "(data placement disabled)", 25);
      }

      v46 = *(this + 847);
      v47 = *(this + 848);
      v71[0] = *(this + 832);
      v71[1] = v47;
      v71[2] = 0;
      v72 = v46;
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  [placement] resolved:", 24);
      LabelPlacementToShortString(&v86, v71);
      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v48 = &v86;
      }

      else
      {
        v48 = v86.__r_.__value_.__r.__words[0];
      }

      if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v49 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v49 = v86.__r_.__value_.__l.__size_;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v48, v49);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, " default:", 9);
      LabelPlacementToShortString(&v85, this + 837);
      if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v50 = &v85;
      }

      else
      {
        v50 = v85.__r_.__value_.__r.__words[0];
      }

      if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v51 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v51 = v85.__r_.__value_.__l.__size_;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v50, v51);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, " snapToDef(can:", 15);
      v52 = MEMORY[0x1B8C61C50](&v76, *(this + 956));
      v53 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v52, " should:", 8);
      v54 = MEMORY[0x1B8C61C50](v53, *(this + 957));
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v54, ")\n", 2);
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v85.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v86.__r_.__value_.__l.__data_);
      }

      LOWORD(__dst) = 256;
      v74 = 0;
      if ((*(*this + 544))(this, 1, &__dst))
      {
        memset(&v86, 0, sizeof(v86));
        v55 = *(this + 100);
        v56 = *(this + 101);
        if (v55 != v56)
        {
          v57 = 1;
          do
          {
            if ((v57 & 1) == 0)
            {
              std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::append(&v86.__r_.__value_.__l.__data_, " ", 1uLL);
            }

            LabelPlacementToShortString(&v85, v55);
            if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v58 = &v85;
            }

            else
            {
              v58 = v85.__r_.__value_.__r.__words[0];
            }

            if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v59 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
            }

            else
            {
              v59 = v85.__r_.__value_.__l.__size_;
            }

            v60 = std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,mdm::zone_mallocator>>::append(&v86.__r_.__value_.__l.__data_, v58, v59);
            if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v85.__r_.__value_.__l.__data_);
            }

            v57 = 0;
            v55 += 5;
          }

          while (v55 != v56);
          v61 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
          v62 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
          if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          {
            v62 = v86.__r_.__value_.__l.__size_;
          }

          if (v62)
          {
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "    alternates:<", 16);
            if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v63 = &v86;
            }

            else
            {
              v63 = v86.__r_.__value_.__r.__words[0];
            }

            if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v64 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
            }

            else
            {
              v64 = v86.__r_.__value_.__l.__size_;
            }

            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, v63, v64);
            v60 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, ">\n", 2);
            v61 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
          }

          if (v61 < 0)
          {
            v65 = v86.__r_.__value_.__r.__words[0];
            v66 = mdm::zone_mallocator::instance(v60);
            geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v66, v65);
          }
        }
      }

      goto LABEL_161;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, "\n  annotation:", 14);
    std::ostringstream::basic_ostringstream[abi:nn200100](&v86);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, "Layout1:", 8);
    v21 = *(this + 933);
    if (v21 > 6)
    {
      v22 = "";
    }

    else
    {
      v22 = off_1E7B38270[v21];
    }

    std::string::basic_string[abi:nn200100]<0>(&v85, v22);
    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v23 = &v85;
    }

    else
    {
      v23 = v85.__r_.__value_.__r.__words[0];
    }

    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v24 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v24 = v85.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, v23, v24);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v85.__r_.__value_.__l.__data_);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, " ImgSrc=", 8);
    v25 = *(this + 935);
    if (v25 > 7)
    {
      v26 = "";
    }

    else
    {
      v26 = off_1E7B382A8[v25];
    }

    std::string::basic_string[abi:nn200100]<0>(&v85, v26);
    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v27 = &v85;
    }

    else
    {
      v27 = v85.__r_.__value_.__r.__words[0];
    }

    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v28 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v28 = v85.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, v27, v28);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v85.__r_.__value_.__l.__data_);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, " Layout2:", 9);
    v29 = *(this + 938);
    if (v29 > 6)
    {
      v30 = "";
    }

    else
    {
      v30 = off_1E7B38270[v29];
    }

    std::string::basic_string[abi:nn200100]<0>(&v85, v30);
    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v31 = &v85;
    }

    else
    {
      v31 = v85.__r_.__value_.__r.__words[0];
    }

    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v32 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v32 = v85.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, v31, v32);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v85.__r_.__value_.__l.__data_);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, " ImgSrc=", 8);
    v33 = *(this + 940);
    if (v33 > 7)
    {
      v34 = "";
    }

    else
    {
      v34 = off_1E7B382A8[v33];
    }

    std::string::basic_string[abi:nn200100]<0>(&v85, v34);
    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v35 = &v85;
    }

    else
    {
      v35 = v85.__r_.__value_.__r.__words[0];
    }

    if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v36 = HIBYTE(v85.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v36 = v85.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v86, v35, v36);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v85.__r_.__value_.__l.__data_);
    }

    if ((v94 & 0x10) != 0)
    {
      v38 = v93;
      if (v93 < v90)
      {
        v93 = v90;
        v38 = v90;
      }

      v39 = v89;
    }

    else
    {
      if ((v94 & 8) == 0)
      {
        v37 = 0;
        v75 = 0;
LABEL_91:
        *(&__dst + v37) = 0;
        v86.__r_.__value_.__r.__words[0] = *MEMORY[0x1E69E54E8];
        *(v86.__r_.__value_.__r.__words + *(v86.__r_.__value_.__r.__words[0] - 24)) = *(MEMORY[0x1E69E54E8] + 24);
        v86.__r_.__value_.__l.__size_ = MEMORY[0x1E69E5548] + 16;
        if (v92 < 0)
        {
          operator delete(v91);
        }

        v86.__r_.__value_.__l.__size_ = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(&v86.__r_.__value_.__r.__words[2]);
        std::ostream::~ostream();
        MEMORY[0x1B8C620C0](v95);
        if ((v75 & 0x80u) == 0)
        {
          p_dst = &__dst;
        }

        else
        {
          p_dst = __dst;
        }

        if ((v75 & 0x80u) == 0)
        {
          v41 = v75;
        }

        else
        {
          v41 = v74;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v76, p_dst, v41);
        if (v75 < 0)
        {
          operator delete(__dst);
        }

        goto LABEL_101;
      }

      v39 = v87;
      v38 = v88;
    }

    v37 = v38 - v39;
    if (v38 - v39 > 0x7FFFFFFFFFFFFFF7)
    {
      goto LABEL_177;
    }

    if (v37 >= 0x17)
    {
      operator new();
    }

    v75 = v38 - v39;
    if (v37)
    {
      memmove(&__dst, v39, v37);
    }

    goto LABEL_91;
  }

LABEL_161:
  if ((v83 & 0x10) != 0)
  {
    v68 = v82;
    if (v82 < v79)
    {
      v82 = v79;
      v68 = v79;
    }

    locale = v78[4].__locale_;
  }

  else
  {
    if ((v83 & 8) == 0)
    {
      v67 = 0;
      a2[23] = 0;
      goto LABEL_174;
    }

    locale = v78[1].__locale_;
    v68 = v78[3].__locale_;
  }

  v67 = v68 - locale;
  if ((v68 - locale) > 0x7FFFFFFFFFFFFFF7)
  {
LABEL_177:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v67 >= 0x17)
  {
    operator new();
  }

  a2[23] = v67;
  if (v67)
  {
    memmove(a2, locale, v67);
  }

LABEL_174:
  a2[v67] = 0;
  v76 = *MEMORY[0x1E69E54E8];
  *(&v76 + *(v76 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v77 = MEMORY[0x1E69E5548] + 16;
  if (v81 < 0)
  {
    operator delete(__p);
  }

  v77 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v78);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v84);
}

void sub_1B3303FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33)
{
  if (a15 < 0)
  {
    operator delete(__p);
  }

  a16 = *MEMORY[0x1E69E54E8];
  *(&a16 + *(a16 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  a17 = MEMORY[0x1E69E5548] + 16;
  if (a30 < 0)
  {
    operator delete(a25);
  }

  a17 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a18);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a33);
  _Unwind_Resume(a1);
}

void gss::to_string(uint64_t a1, int a2)
{
  if (a2 == 0x8000)
  {
    v3 = "default";
    goto LABEL_5;
  }

  if (!a2)
  {
    v3 = "none";
LABEL_5:

    std::string::basic_string[abi:nn200100]<0>(a1, v3);
    return;
  }

  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  v4 = a2 & 0x1FF;
  if ((a2 & 0x1FF) != 0)
  {
    v5 = 0;
    do
    {
      if (v4)
      {
        v6 = *(a1 + 23);
        if ((v6 & 0x80u) != 0)
        {
          v6 = *(a1 + 8);
        }

        if (v6)
        {
          std::string::append(a1, ",", 1uLL);
        }

        v7 = "";
        if (v5 <= 0xA)
        {
          v7 = off_1E7B3E750[v5];
        }

        std::string::basic_string[abi:nn200100]<0>(__p, v7);
        if ((v12 & 0x80u) == 0)
        {
          v8 = __p;
        }

        else
        {
          v8 = __p[0];
        }

        if ((v12 & 0x80u) == 0)
        {
          v9 = v12;
        }

        else
        {
          v9 = __p[1];
        }

        std::string::append(a1, v8, v9);
        if (v12 < 0)
        {
          operator delete(__p[0]);
        }
      }

      ++v5;
      v10 = v4 >= 2;
      v4 >>= 1;
    }

    while (v10);
  }
}

void sub_1B3304418(_Unwind_Exception *exception_object)
{
  if (*(v1 + 23) < 0)
  {
    operator delete(*v1);
  }

  _Unwind_Resume(exception_object);
}

void md::CaptionedIconLabelPart::populateDebugNode(md::CaptionedIconLabelPart *this, gdc::DebugTreeNode *a2)
{
  std::string::basic_string[abi:nn200100]<0>(&v69, "CaptionedIconLabelPart");
  v4 = gdc::DebugTreeNode::createChildNode(a2, &v69);
  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Text Display Mode");
  v5 = *(this + 947);
  if (v5 > 3)
  {
    v6 = "";
  }

  else
  {
    v6 = off_1E7B35C48[v5];
  }

  std::string::basic_string[abi:nn200100]<0>(&v65, v6);
  gdc::DebugTreeValue::DebugTreeValue(v66, &v65);
  gdc::DebugTreeNode::addProperty(v4, &v69, v66);
  if (v68 < 0)
  {
    operator delete(v67);
  }

  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v65.__r_.__value_.__l.__data_);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Feature Text Display Mode");
  v7 = *(this + 946);
  if (v7 > 3)
  {
    v8 = "";
  }

  else
  {
    v8 = off_1E7B35C48[v7];
  }

  std::string::basic_string[abi:nn200100]<0>(&v65, v8);
  gdc::DebugTreeValue::DebugTreeValue(v62, &v65);
  gdc::DebugTreeNode::addProperty(v4, &v69, v62);
  if (v64 < 0)
  {
    operator delete(v63);
  }

  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v65.__r_.__value_.__l.__data_);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Hide Text Part");
  gdc::DebugTreeValue::DebugTreeValue(v59, *(this + 732));
  gdc::DebugTreeNode::addProperty(v4, &v69, v59);
  if (v61 < 0)
  {
    operator delete(__p);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Text Collision Alpha");
  gdc::DebugTreeValue::DebugTreeValue(v56, *(this + 237));
  gdc::DebugTreeNode::addProperty(v4, &v69, v56);
  if (v58 < 0)
  {
    operator delete(v57);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Layout Style");
  v9 = *(this + 922);
  if (v9 > 0x13)
  {
    v10 = "";
  }

  else
  {
    v10 = off_1E7B3E7A8[v9];
  }

  std::string::basic_string[abi:nn200100]<0>(&v65, v10);
  gdc::DebugTreeValue::DebugTreeValue(v53, &v65);
  gdc::DebugTreeNode::addProperty(v4, &v69, v53);
  if (v55 < 0)
  {
    operator delete(v54);
  }

  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v65.__r_.__value_.__l.__data_);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  std::string::basic_string[abi:nn200100]<0>(&v69, "Padding");
  gdc::DebugTreeValue::DebugTreeValue(v50, *(this + 42));
  gdc::DebugTreeNode::addProperty(v4, &v69, v50);
  if (v52 < 0)
  {
    operator delete(v51);
  }

  if (v70 < 0)
  {
    operator delete(v69);
  }

  if (*(this + 925) == 1)
  {
    std::string::basic_string[abi:nn200100]<0>(&v69, "IconPart");
    v11 = gdc::DebugTreeNode::createChildNode(v4, &v69);
    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Left");
    gdc::DebugTreeValue::DebugTreeValue(v47, *(this + 171));
    gdc::DebugTreeNode::addProperty(v11, &v69, v47);
    if (v49 < 0)
    {
      operator delete(v48);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Right");
    gdc::DebugTreeValue::DebugTreeValue(v44, *(this + 172));
    gdc::DebugTreeNode::addProperty(v11, &v69, v44);
    if (v46 < 0)
    {
      operator delete(v45);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Top");
    gdc::DebugTreeValue::DebugTreeValue(v41, *(this + 173));
    gdc::DebugTreeNode::addProperty(v11, &v69, v41);
    if (v43 < 0)
    {
      operator delete(v42);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Bottom");
    gdc::DebugTreeValue::DebugTreeValue(v38, *(this + 174));
    gdc::DebugTreeNode::addProperty(v11, &v69, v38);
    if (v40 < 0)
    {
      operator delete(v39);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Diagonal Vertical");
    gdc::DebugTreeValue::DebugTreeValue(v35, *(this + 175));
    gdc::DebugTreeNode::addProperty(v11, &v69, v35);
    if (v37 < 0)
    {
      operator delete(v36);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Margin Diagonal Horizontal");
    gdc::DebugTreeValue::DebugTreeValue(v32, *(this + 176));
    gdc::DebugTreeNode::addProperty(v11, &v69, v32);
    if (v34 < 0)
    {
      operator delete(v33);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }
  }

  if (*(this + 926) == 1)
  {
    std::string::basic_string[abi:nn200100]<0>(&v69, "TextPart");
    v12 = gdc::DebugTreeNode::createChildNode(v4, &v69);
    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Label Placement");
    LabelPlacementToShortString(&v65, this + 842);
    gdc::DebugTreeValue::DebugTreeValue(v29, &v65);
    gdc::DebugTreeNode::addProperty(v12, &v69, v29);
    if (v31 < 0)
    {
      operator delete(v30);
    }

    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v65.__r_.__value_.__l.__data_);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Alternate Position");
    gss::to_string(&v65, *(this + 425));
    gdc::DebugTreeValue::DebugTreeValue(v26, &v65);
    gdc::DebugTreeNode::addProperty(v12, &v69, v26);
    if (v28 < 0)
    {
      operator delete(v27);
    }

    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v65.__r_.__value_.__l.__data_);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    v13 = *(this + 847);
    v14 = *(this + 848);
    v24[0] = *(this + 832);
    v24[1] = v14;
    v24[2] = 0;
    v25 = v13;
    std::string::basic_string[abi:nn200100]<0>(&v69, "Resolved Placement");
    LabelPlacementToShortString(&v65, v24);
    gdc::DebugTreeValue::DebugTreeValue(v21, &v65);
    gdc::DebugTreeNode::addProperty(v12, &v69, v21);
    if (v23 < 0)
    {
      operator delete(v22);
    }

    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v65.__r_.__value_.__l.__data_);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }

    std::string::basic_string[abi:nn200100]<0>(&v69, "Default Placement");
    LabelPlacementToShortString(&v65, this + 837);
    gdc::DebugTreeValue::DebugTreeValue(v18, &v65);
    gdc::DebugTreeNode::addProperty(v12, &v69, v18);
    if (v20 < 0)
    {
      operator delete(v19);
    }

    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v65.__r_.__value_.__l.__data_);
    }

    if (v70 < 0)
    {
      operator delete(v69);
    }
  }

  v15 = *(this + 72);
  v16 = *(this + 73);
  while (v15 != v16)
  {
    v17 = *v15++;
    (*(*v17 + 808))(v17, a2);
  }
}

void sub_1B3304B80(_Unwind_Exception *exception_object)
{
  if (*(v1 - 49) < 0)
  {
    operator delete(*(v1 - 72));
  }

  _Unwind_Resume(exception_object);
}

void md::CaptionedIconLabelPart::debugDraw(uint64_t a1, ggl::DebugConsole *a2, double a3)
{
  md::LabelPart::debugDraw(a1, a2, a3);
  if (*(a1 + 925) == 1)
  {
    (*(***(a1 + 576) + 776))(**(a1 + 576), a2);
  }

  if (*(a1 + 926) == 1 && *(a1 + 947) != 3)
  {
    v5 = *(**(*(a1 + 576) + 8 * *(a1 + 925)) + 776);

    v5();
  }
}

uint64_t md::CaptionedIconLabelPart::isTextVisible(md::CaptionedIconLabelPart *this)
{
  if (*(this + 926) == 1)
  {
    return (*(**(*(this + 72) + 8 * *(this + 925)) + 752))();
  }

  else
  {
    return 0;
  }
}

uint64_t md::CaptionedIconLabelPart::populateIconImageInfos(uint64_t result)
{
  if (*(result + 925) == 1)
  {
    return (*(***(result + 576) + 736))();
  }

  return result;
}

uint64_t md::CaptionedIconLabelPart::transferResource@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (*(this + 925) == 1)
  {
    return (*(***(this + 576) + 608))();
  }

  *a2 = 0;
  return this;
}

uint64_t md::MultiCollisionObjectPlacementCandidate::collidesWithObject(md::MultiCollisionObjectPlacementCandidate *this, const md::CollisionObject *a2)
{
  v2 = *(this + 1);
  v3 = *(this + 2);
  if (v2 != v3)
  {
    v5 = *(a2 + 20);
    while (1)
    {
      if (!v5 && !*(a2 + 21) || (*(v2 + 200) & *(a2 + 200)) != 0)
      {
        goto LABEL_13;
      }

      v6 = *(v2 + 168);
      if (*(a2 + 21))
      {
        break;
      }

      if (v6)
      {
        v7 = v2;
        v8 = a2;
LABEL_12:
        if (md::CollisionObject::circlesCollideWithRects(v7, v8))
        {
          return 1;
        }

        goto LABEL_13;
      }

      if ((*(a2 + 196) & 1) != 0 || *(v2 + 196) == 1)
      {
        if (md::CollisionObject::rectsCollideWithRectsOBB(a2, v2))
        {
          return 1;
        }
      }

      else if (md::CollisionObject::rectsCollideWithRects(a2, v2))
      {
        return 1;
      }

LABEL_13:
      v2 += 208;
      if (v2 == v3)
      {
        return 0;
      }
    }

    v7 = a2;
    v8 = v2;
    if (v6)
    {
      if (md::CollisionObject::circlesCollideWithCircles(a2, v2))
      {
        return 1;
      }

      goto LABEL_13;
    }

    goto LABEL_12;
  }

  return 0;
}

void md::MultiCollisionObjectPlacementCandidate::~MultiCollisionObjectPlacementCandidate(md::MultiCollisionObjectPlacementCandidate *this)
{
  *this = &unk_1F2A5BC40;
  v1 = (this + 8);
  std::vector<md::CollisionObject,geo::allocator_adapter<md::CollisionObject,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v1);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5BC40;
  v1 = (this + 8);
  std::vector<md::CollisionObject,geo::allocator_adapter<md::CollisionObject,mdm::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v1);
}

uint64_t md::CaptionedIconLabelPart::snapToDefaultPlacement(unsigned __int8 *a1, const md::LabelManager *a2, md::LabelCollider *a3, md::LabelCollidableItem *a4, uint64_t a5)
{
  if (md::CaptionedIconLabelPart::collideIconPart(a1, a2, a3, a4))
  {
    return 0;
  }

  v11 = a1[959];

  return md::CaptionedIconLabelPart::tryAlternatePlacements(a1, 0, v11 ^ 1u, v11, a2, a3, a4, a5);
}

uint64_t md::CaptionedIconLabelPart::populateHoverBounds(uint64_t result, uint64_t a2)
{
  v2 = result;
  if (*(result + 925) == 1)
  {
    result = (*(***(result + 576) + 528))(**(result + 576), a2);
  }

  if (*(v2 + 926) == 1 && (*(v2 + 732) & 1) == 0)
  {
    v3 = *(**(*(v2 + 576) + 8 * *(v2 + 925)) + 528);

    return v3();
  }

  return result;
}

uint64_t md::CaptionedIconLabelPart::reserveSpaceLabelPart(md::CaptionedIconLabelPart *this, BOOL *a2)
{
  if (*(this + 925) != 1)
  {
    return 0;
  }

  *a2 = *(this + 926) ^ 1;
  return **(this + 72);
}

uint64_t md::CaptionedIconLabelPart::optionalTextHidden(md::CaptionedIconLabelPart *this)
{
  if (*(this + 926) == 1)
  {
    v1 = *(this + 953);
  }

  else
  {
    v1 = 1;
  }

  return v1 & 1;
}

float md::CaptionedIconLabelPart::setOptionalTextHidden(md::CaptionedIconLabelPart *this, int a2)
{
  *(this + 680) = a2;
  *(this + 953) = a2;
  result = (a2 ^ 1u);
  *(this + 237) = result;
  return result;
}

uint64_t md::CaptionedIconLabelPart::isVisuallySimilar(md::CaptionedIconLabelPart *this, const md::LabelPart *a2, const md::LabelPart *a3)
{
  result = md::CompositeLabelPart::isVisuallySimilar(this, a2, a3);
  if (result)
  {
    return *(this + 926) != 1 || *(this + 847) == *(a2 + 847) && *(this + 848) == *(a2 + 848);
  }

  return result;
}

void md::CaptionedIconLabelPart::evaluateAnimation(uint64_t a1, uint64_t *a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5)
{
  v5 = *(a1 + 16);
  if (*(v5 + 1184) == 1)
  {
    v6 = atomic_load((v5 + 1328));
    if ((v6 & 1) == 0)
    {
      v8 = *a2;
      v9 = a2[1];
      if (v8 != v9)
      {
        v13 = v8;
        while (*(v13 + 16) != 1)
        {
          v13 += 24;
          if (v13 == v9)
          {
            return;
          }
        }

        v14 = md::LabelAnimation::property(v8, v9, 1);
        if (v14 != 0.0)
        {
          v49 = v14;
          memset(v55, 0, sizeof(v55));
          *v56 = 2139095039;
          *&v56[4] = 0;
          v56[6] = 0;
          v15 = (*(**(*(a1 + 16) + 8) + 72))(*(*(a1 + 16) + 8));
          if (v15)
          {
            v16 = v15;
            md::ClusterNodeContext::LockedPtr::LockedPtr(&v57, (v15 + 288));
            v17 = 0.0;
            if (v58 == 0.0 || (v18 = *(*&v58 + 72)) == 0)
            {
              v20 = 0;
            }

            else
            {
              for (i = 0; i != 24; i += 8)
              {
                *&v55[i] = *(v18 + 16 + i);
              }

              *&v55[24] = *(v18 + 40);
              *v56 = *(v18 + 56);
              *&v56[3] = *(v18 + 59);
              if (*(v18 + 68))
              {
                v17 = *(v18 + 64);
              }

              else
              {
                v17 = 0.0;
              }

              v20 = 1;
            }

            if (*&v57.f64[1])
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](*&v57.f64[1]);
            }

            if (v20)
            {
              v21 = *(a1 + 16);
              v22 = *(a3 + 232);
              v23 = *(v22 + 64);
              v24 = *(v21 + 1064) / v23;
              if ((*(v16 + 237) & 1) != 0 || *(v16 + 248))
              {
                v25 = v24 * *(a3 + 484);
                v26 = *(a3 + 1616) * *(v21 + 1136);
              }

              else
              {
                if (*(v22 + 30) == 1)
                {
                  v25 = v24 * *(a3 + 484);
                }

                else
                {
                  v48 = v24;
                  if (*v56 != 3.4028e38)
                  {
                    v48 = *v56;
                  }

                  v25 = (v48 * *(a3 + 484));
                }

                v26 = v17 * *(a3 + 1616);
              }

              v27 = v25 + v26;
              if (*(a3 + 440))
              {
                v28 = v27 * v23;
                v29 = *md::LabelPoint::mercatorPoint(v55);
                v30 = *(md::LabelPoint::mercatorPoint(v55) + 8);
                v53.f64[0] = v29;
                v53.f64[1] = v30;
                v54 = v28;
              }

              else
              {
                md::LabelPoint::geocentricPoint(v55);
                md::LabelPoint::geocentricPoint(v55);
                for (j = 0; j != 3; ++j)
                {
                  v57.f64[j] = *&md::GeocentricNormal(geo::Geocentric<double> const&)::oneOverRadiiSquared[j] * *&v55[j * 8];
                }

                v32 = gm::Matrix<double,3,1>::normalized<int,void>(&v57);
                v33 = 0;
                *v50 = v32;
                v50[1] = v34;
                v50[2] = v35;
                do
                {
                  v57.f64[v33] = *&v50[v33] * v27;
                  ++v33;
                }

                while (v33 != 3);
                v36 = 0;
                v51 = v57;
                v52 = v58;
                do
                {
                  v57.f64[v36] = v51.f64[v36] + *&v55[v36 * 8];
                  ++v36;
                }

                while (v36 != 3);
                v53 = v57;
                v54 = v58;
              }

              v37 = 0;
              v38 = (a3 + 1296);
              do
              {
                v39 = 0;
                v40 = 0.0;
                v41 = v38;
                do
                {
                  v42 = *v41;
                  v41 += 4;
                  v40 = v40 + v53.f64[v39++] * v42;
                }

                while (v39 != 3);
                v57.f64[v37] = *(a3 + 1296 + 8 * v37 + 96) + v40;
                ++v37;
                ++v38;
              }

              while (v37 != 4);
              __asm { FMOV            V1.2D, #1.0 }

              *a5 = vmla_n_f32(*a5, vsub_f32(vcvt_f32_f64(vmulq_f64(v57, vdivq_f64(_Q1, vdupq_lane_s64(v59, 0)))), *a4), v49);
            }
          }
        }
      }
    }
  }
}

void md::CaptionedIconLabelPart::generateModelMatrix(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4, uint64_t a5, double a6, double a7)
{
  v14 = *(a1 + 16);
  v15 = *(a1 + 847);
  md::LabelPart::generateModelMatrixForMeshPositioningMode(&v24, v14 + 152, a4, a5, v15, 1, *(a1 + 858), a6, a7);
  v16 = v29;
  a2[4] = v28;
  a2[5] = v16;
  v17 = v31;
  a2[6] = v30;
  a2[7] = v17;
  v18 = v25;
  *a2 = v24;
  a2[1] = v18;
  v19 = v27;
  a2[2] = v26;
  a2[3] = v19;
  if (a3)
  {
    md::LabelPart::generateModelMatrixForMeshPositioningMode(&v24, v14 + 152, a4, a5, v15, 1, *(a1 + 859), a6, a7);
    v20 = v29;
    a3[4] = v28;
    a3[5] = v20;
    v21 = v31;
    a3[6] = v30;
    a3[7] = v21;
    v22 = v25;
    *a3 = v24;
    a3[1] = v22;
    v23 = v27;
    a3[2] = v26;
    a3[3] = v23;
  }
}

uint64_t md::CaptionedIconLabelPart::setInWorldSpace(md::CaptionedIconLabelPart *this, BOOL a2, uint64_t a3)
{
  v4 = *(this + 858) != 0;
  *(this + 565) = v4;
  result = md::CompositeLabelPart::setInWorldSpace(this, v4, a3);
  if (*(this + 565) == 1 && *(this + 566) == 1)
  {
    operator new();
  }

  return result;
}

void ggl::PolygonAnimatableFill::CompressedMeshPipelineSetup::~CompressedMeshPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::Circle::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5BCD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::Circle::View>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Circle::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5BD80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::Circle::Style>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Circle::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5BDD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B33061D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a14);
  }

  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<md::VenueBuildingFeatureMarker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5BF00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::function<void ()(NSError *)>>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 32 * a2, 0x1020040A5B76CDFuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::Buffer *>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::function<void ()(ggl::WillSubmitFrameInfo const*)>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::function<void ()(void)>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::function<void ()(NSError *)>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::Texture *>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 8 * a2, 0x2004093837F09uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

ggl::zone_mallocator *std::__split_buffer<std::function<void ()(ggl::WillSubmitFrameInfo const*)>,geo::allocator_adapter<std::function<void ()(ggl::WillSubmitFrameInfo const*)>,ggl::zone_mallocator> &>::~__split_buffer(ggl::zone_mallocator *a1)
{
  v1 = a1;
  v3 = *(a1 + 1);
  for (i = *(a1 + 2); i != v3; i = *(v1 + 2))
  {
    *(v1 + 2) = i - 32;
    a1 = std::__function::__value_func<void ()(ggl::WillSubmitFrameInfo const*)>::~__value_func[abi:nn200100](i - 32);
  }

  v4 = *v1;
  if (*v1)
  {
    v5 = ggl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::function<void ()(ggl::WillSubmitFrameInfo const*)>>(v5, v4);
  }

  return v1;
}

void std::__function::__func<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,std::allocator<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0>,void ()(NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5BFA8;
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100]((a1 + 1));

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,std::allocator<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0>,void ()(NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5BFA8;
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100]((a1 + 1));
  return a1;
}

uint64_t *std::unique_ptr<ggl::Performance::HUD>::reset[abi:nn200100](uint64_t *result, uint64_t a2)
{
  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = *(v2 + 8);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v3);
    }

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void ggl::MetalRenderer::readPixels(ggl::Texture *a1@<X1>, void *a2@<X8>)
{
  v17 = *MEMORY[0x1E69E9840];
  v5 = *(a1 + 20);
  v13 = *(a1 + 21);
  v14 = v5;
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v15 = &unk_1F29E1230;
  cf = DeviceRGB;
  *a2 = 0;
  a2[1] = 0;
  v7 = *(a1 + 17);
  if ((v7 - 14) < 2)
  {
    v11 = 32;
    v12 = 8;
    v10 = 4 * v5;
    v9 = DeviceRGB;
    v8 = 16385;
    std::allocate_shared[abi:nn200100]<ggl::BitmapData,std::allocator<ggl::BitmapData>,unsigned int &,unsigned int &,int,int,unsigned int,CGColorSpace *,unsigned int,0>();
  }

  if (v7 == 5)
  {
    v11 = 32;
    v12 = 32;
    v10 = 4 * v5;
    v9 = DeviceRGB;
    v8 = 16641;
    std::allocate_shared[abi:nn200100]<ggl::BitmapData,std::allocator<ggl::BitmapData>,unsigned int &,unsigned int &,int,int,unsigned int,CGColorSpace *,unsigned int,0>();
  }

  v15 = &unk_1F29E1230;
  if (DeviceRGB)
  {
    CFRelease(DeviceRGB);
  }
}

void sub_1B3306A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, CFTypeRef cf)
{
  if (cf)
  {
    CFRelease(cf);
  }

  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<ggl::BitmapData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C070;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::MetalRenderer::~MetalRenderer(ggl::MetalRenderer *this)
{
  ggl::MetalRenderer::~MetalRenderer(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5BF38;
  v2 = *(this + 54);
  *(this + 54) = 0;
  if (v2)
  {
    (*(*v2 + 8))(v2);
    v3 = *(this + 54);
    *(this + 54) = 0;
    if (v3)
    {
      (*(*v3 + 8))(v3);
    }
  }

  std::unique_ptr<ggl::Performance::HUD>::reset[abi:nn200100](this + 18, 0);

  ggl::Renderer::~Renderer(this);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ClearCache::PipelineStateEntry>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ClearCache::RenderStateEntry>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

uint64_t ggl::DataProviderReleaseInfoCallback(uint64_t this, void *a2)
{
  if (this)
  {
    v2 = *(this + 8);
    if (v2)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v2);
    }

    JUMPOUT(0x1B8C62190);
  }

  return this;
}

uint64_t ggl::DataProviderGetBytesAtPositionCallback(ggl *this, char *a2, int64_t a3, unint64_t a4)
{
  if (4 * *(this + 3) * *(this + 2) - a3 >= a4)
  {
    v4 = a4;
  }

  else
  {
    v4 = 4 * *(this + 3) * *(this + 2) - a3;
  }

  if (v4)
  {
    v5 = a3;
    v8 = v4;
    do
    {
      if ((v5 & 0x8000000000000000) != 0 || (v9 = *(this + 3), v10 = 4 * *(this + 2), v8 + v5 > v10 * v9))
      {
        v11 = 0;
      }

      else
      {
        v12 = v9 + ~(v5 / v10);
        if (v10 - v5 % v10 >= v8)
        {
          v11 = v8;
        }

        else
        {
          v11 = v10 - v5 % v10;
        }

        v13 = v5 % v10 + v12 * v10;
        if ((v13 & 0x8000000000000000) == 0 && v13 + v11 <= *(*this + 56) * *(*this + 32))
        {
          v14 = (*(**this + 16))(*this);
          memcpy(a2, (v14 + v13), v11);
        }
      }

      v5 += v11;
      a2 += v11;
      v8 -= v11;
    }

    while (v8);
  }

  return v4;
}

void ggl::BitmapData::~BitmapData(ggl::BitmapData *this)
{
  ggl::BitmapData::~BitmapData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5C100;
  v2 = *(this + 10);
  *(this + 10) = 0;
  if (v2)
  {
    MEMORY[0x1B8C62190](v2, 0x1000C4077774924);
  }

  ggl::BitmapDataBase::~BitmapDataBase(this);
}

void ggl::BitmapDataBase::~BitmapDataBase(CGColorSpaceRef *this)
{
  *this = &unk_1F2A5C0A8;
  CGColorSpaceRelease(this[8]);
  v2 = this[2];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void *ggl::IOSurfaceBitmapData::data(IOSurfaceRef *this)
{
  if ((this[12] & 1) == 0)
  {
    IOSurfaceLock(this[10], 1u, 0);
    *(this + 96) = 1;
  }

  v2 = this[10];

  return IOSurfaceGetBaseAddress(v2);
}

void ggl::IOSurfaceBitmapData::~IOSurfaceBitmapData(IOSurfaceRef *this)
{
  ggl::IOSurfaceBitmapData::~IOSurfaceBitmapData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5C130;
  IOSurfaceUnlock(this[10], 1u, 0);
  v2 = this[10];
  if (v2)
  {
    CFRelease(v2);
    this[10] = 0;
  }

  ggl::BitmapDataBase::~BitmapDataBase(this);
}

ggl::IOSurfaceBitmapData *ggl::IOSurfaceBitmapData::IOSurfaceBitmapData(ggl::IOSurfaceBitmapData *this, IOSurfaceRef buffer, CGColorSpace *a3, int a4)
{
  Width = IOSurfaceGetWidth(buffer);
  Height = IOSurfaceGetHeight(buffer);
  v10 = 8 * IOSurfaceGetBytesPerElement(buffer);
  BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
  *(this + 1) = 0;
  *(this + 2) = 0;
  *this = &unk_1F2A5C0A8;
  *(this + 3) = Width;
  *(this + 4) = Height;
  *(this + 5) = 8;
  *(this + 6) = v10;
  *(this + 7) = BytesPerRow;
  *(this + 8) = CGColorSpaceRetain(a3);
  *(this + 18) = a4;
  *this = &unk_1F2A5C130;
  *(this + 10) = buffer;
  *(this + 11) = IOSurfaceGetAllocSize(buffer);
  *(this + 96) = 0;
  if (buffer)
  {
    CFRetain(buffer);
  }

  return this;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::pair<unsigned int,std::shared_ptr<ggl::QueryItem>>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__move_impl<std::_ClassicAlgPolicy>::operator()[abi:nn200100]<ggl::PendingQuery *,std::__deque_iterator<ggl::PendingQuery,ggl::PendingQuery *,ggl::PendingQuery&,ggl::PendingQuery **,long,128l>,0>(void *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  v6 = a4;
  v7 = a2;
  if (a2 == a3)
  {
    v13 = a2;
    goto LABEL_17;
  }

  v10 = *a4;
  while (1)
  {
    v11 = v10 - a5 + 4096;
    v12 = (a3 - v7) >> 5 >= v11 >> 5 ? v11 >> 5 : (a3 - v7) >> 5;
    if (v12)
    {
      break;
    }

LABEL_13:
    v16 = v6[1];
    ++v6;
    v10 = v16;
    a5 = v16;
  }

  v13 = v7 + 32 * v12;
  do
  {
    *a5 = *v7;
    v14 = *(v7 + 16);
    *(v7 + 16) = 0;
    *(v7 + 24) = 0;
    v15 = *(a5 + 24);
    *(a5 + 16) = v14;
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v15);
    }

    v7 += 32;
    a5 += 32;
  }

  while (v7 != v13);
  if (v13 != a3)
  {
    v7 = v13;
    goto LABEL_13;
  }

  if (*v6 + 4096 == a5)
  {
    v17 = v6[1];
    ++v6;
    a5 = v17;
  }

LABEL_17:
  *a1 = v13;
  a1[1] = v6;
  a1[2] = a5;
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,ggl::Batcher::commit(unsigned int)::$_0 &,gm::Range<unsigned long> *>(uint64_t a1, __n128 *a2, __n128 a3)
{
  v3 = (a2 - a1) >> 4;
  if (v3 > 2)
  {
    if (v3 == 3)
    {
      v6 = (a1 + 16);
      v7 = *(a1 + 16);
      v9 = a2[-1].n128_u64[0];
      v4 = a2 - 1;
      v8 = v9;
      if (v7 < *a1)
      {
        if (v8 >= v7)
        {
          v28 = *a1;
          *a1 = *v6;
          *v6 = v28;
          if (v4->n128_u64[0] >= *(a1 + 16))
          {
            return 1;
          }

          v10 = *v6;
          *v6 = *v4;
          goto LABEL_13;
        }

LABEL_12:
        v10 = *a1;
        *a1 = *v4;
LABEL_13:
        *v4 = v10;
        return 1;
      }

      if (v8 >= v7)
      {
        return 1;
      }

      v23 = *v6;
      *v6 = *v4;
      *v4 = v23;
LABEL_50:
      if (*(a1 + 16) < *a1)
      {
        v41 = *a1;
        *a1 = *v6;
        *v6 = v41;
      }

      return 1;
    }

    if (v3 != 4)
    {
      if (v3 != 5)
      {
        goto LABEL_14;
      }

      std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,ggl::Batcher::commit::$_0 &,gm::Range<unsigned long> *,0>(a1, (a1 + 16), (a1 + 32), (a1 + 48), a2[-1].n128_u64, a3);
      return 1;
    }

    v6 = (a1 + 16);
    v17 = *(a1 + 16);
    v18 = (a1 + 32);
    v19 = *(a1 + 32);
    v20 = a2 - 1;
    v21 = *a1;
    if (v17 >= *a1)
    {
      if (v19 < v17)
      {
        v26 = *v6;
        *v6 = *v18;
        *v18 = v26;
        if (v6->n128_u64[0] < v21)
        {
          v27 = *a1;
          *a1 = *v6;
          *v6 = v27;
        }
      }

      goto LABEL_47;
    }

    if (v19 >= v17)
    {
      v38 = *a1;
      *a1 = *v6;
      *v6 = v38;
      if (v19 >= *(a1 + 16))
      {
        goto LABEL_47;
      }

      v22 = *v6;
      *v6 = *v18;
    }

    else
    {
      v22 = *a1;
      *a1 = *v18;
    }

    *v18 = v22;
LABEL_47:
    if (v20->n128_u64[0] >= v18->n128_u64[0])
    {
      return 1;
    }

    v39 = *v18;
    *v18 = *v20;
    *v20 = v39;
    if (v18->n128_u64[0] >= v6->n128_u64[0])
    {
      return 1;
    }

    v40 = *v6;
    *v6 = *v18;
    *v18 = v40;
    goto LABEL_50;
  }

  if (v3 < 2)
  {
    return 1;
  }

  if (v3 == 2)
  {
    v5 = a2[-1].n128_u64[0];
    v4 = a2 - 1;
    if (v5 >= *a1)
    {
      return 1;
    }

    goto LABEL_12;
  }

LABEL_14:
  v11 = (a1 + 32);
  v12 = *(a1 + 32);
  v13 = (a1 + 16);
  v14 = *(a1 + 16);
  v15 = *a1;
  if (v14 >= *a1)
  {
    if (v12 < v14)
    {
      v24 = *v13;
      *v13 = *v11;
      *v11 = v24;
      if (v13->n128_u64[0] < v15)
      {
        v25 = *a1;
        *a1 = *v13;
        *v13 = v25;
      }
    }
  }

  else
  {
    if (v12 >= v14)
    {
      v29 = *a1;
      *a1 = *v13;
      *v13 = v29;
      if (v12 >= *(a1 + 16))
      {
        goto LABEL_33;
      }

      v16 = *v13;
      *v13 = *v11;
    }

    else
    {
      v16 = *a1;
      *a1 = *v11;
    }

    *v11 = v16;
  }

LABEL_33:
  v30 = (a1 + 48);
  if ((a1 + 48) == a2)
  {
    return 1;
  }

  v31 = 0;
  v32 = 0;
  while (1)
  {
    v33 = v30->n128_u64[0];
    if (v30->n128_u64[0] < v11->n128_u64[0])
    {
      v34 = v30->n128_i64[1];
      v35 = v31;
      while (1)
      {
        *(a1 + v35 + 48) = *(a1 + v35 + 32);
        if (v35 == -32)
        {
          break;
        }

        v36 = *(a1 + v35 + 16);
        v35 -= 16;
        if (v33 >= v36)
        {
          v37 = (a1 + v35 + 48);
          goto LABEL_41;
        }
      }

      v37 = a1;
LABEL_41:
      *v37 = v33;
      v37[1] = v34;
      if (++v32 == 8)
      {
        return &v30[1] == a2;
      }
    }

    v11 = v30;
    v31 += 16;
    if (++v30 == a2)
    {
      return 1;
    }
  }
}

void ggl::MetalSurface::~MetalSurface(id *this)
{

  JUMPOUT(0x1B8C62190);
}

{
}

uint64_t ___ZN3ggl7MPSBlur6encodeEPNS_11MetalDeviceEPU27objcproto16MTLCommandBuffer11objc_object_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  v6 = a3;
  v7 = a4;
  v8 = [MEMORY[0x1E69741C0] texture2DDescriptorWithPixelFormat:*(a1 + 32) width:objc_msgSend(v7 height:"width") mipmapped:objc_msgSend(v7, "height"), 0];
  v9 = [v6 device];
  v10 = [v9 newTextureWithDescriptor:v8];

  return v10;
}

Class initMPSImageTent(void)
{
  if (LoadMetalPerformanceShaders(void)::loadPredicate != -1)
  {
    dispatch_once(&LoadMetalPerformanceShaders(void)::loadPredicate, &__block_literal_global_50114);
  }

  result = objc_getClass("MPSImageTent");
  classMPSImageTent = result;
  getMPSImageTentClass = MPSImageTentFunction;
  return result;
}

void ___ZL27LoadMetalPerformanceShadersv_block_invoke()
{
  LoadMetalPerformanceShaders(void)::frameworkLibrary = dlopen("/System/Library/Frameworks/MetalPerformanceShaders.framework/MetalPerformanceShaders", 2);
  if (!LoadMetalPerformanceShaders(void)::frameworkLibrary)
  {
    NSLog(@"### Failed to Soft Linked: /System/Library/Frameworks/MetalPerformanceShaders.framework/MetalPerformanceShaders");
  }
}

Class initMPSImageGaussianBlur(void)
{
  if (LoadMetalPerformanceShaders(void)::loadPredicate != -1)
  {
    dispatch_once(&LoadMetalPerformanceShaders(void)::loadPredicate, &__block_literal_global_50114);
  }

  result = objc_getClass("MPSImageGaussianBlur");
  classMPSImageGaussianBlur = result;
  getMPSImageGaussianBlurClass = MPSImageGaussianBlurFunction;
  return result;
}

ggl::zone_mallocator *std::__split_buffer<ggl::Texture *,geo::allocator_adapter<ggl::Texture *,ggl::zone_mallocator> &>::~__split_buffer(ggl::zone_mallocator *a1)
{
  v3 = *(a1 + 1);
  v2 = *(a1 + 2);
  if (v2 != v3)
  {
    *(a1 + 2) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  v4 = *a1;
  if (*a1)
  {
    v5 = ggl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::Texture *>(v5, v4);
  }

  return a1;
}

id GEOGetGeoGLMetalSwapchainLog(void)
{
  if (GEOGetGeoGLMetalSwapchainLog(void)::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoGLMetalSwapchainLog(void)::onceToken, &__block_literal_global_50130);
  }

  v1 = GEOGetGeoGLMetalSwapchainLog(void)::log;

  return v1;
}

void std::__shared_ptr_pointer<ggl::MetalSurfaceDrawable *,std::shared_ptr<ggl::MetalSurfaceDrawable>::__shared_ptr_default_delete<ggl::MetalSurfaceDrawable,ggl::MetalSurfaceDrawable>,std::allocator<ggl::MetalSurfaceDrawable>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ___ZL28GEOGetGeoGLMetalSwapchainLogv_block_invoke()
{
  v0 = os_log_create("com.apple.VectorKit.GeoGL", "MetalSwapchain");
  v1 = GEOGetGeoGLMetalSwapchainLog(void)::log;
  GEOGetGeoGLMetalSwapchainLog(void)::log = v0;
}

void ggl::resetAllocator(ggl *this)
{
  v1 = ggl::zone_mallocator::instance(this);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::reset(v1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void non-virtual thunk toggl::VertexDataTyped<ggl::TextureRect::TextureVBO>::~VertexDataTyped(uint64_t a1)
{
  ggl::BufferData::~BufferData((a1 - 200));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::BufferData::~BufferData((a1 - 200));
}

void ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>::~VertexDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>::__on_zero_shared_weak(ggl::zone_mallocator *a1)
{
  v2 = ggl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C3A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::TextureRect::TextureMesh::~TextureMesh(ggl::TextureRect::TextureMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void ggl::TextureRect::TextureMesh::~TextureMesh(ggl::TextureRect::TextureMesh *this)
{
  ggl::Mesh::~Mesh(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::MeshTyped<ggl::TextureRect::TextureVBO>::typedReflection()
{
  {
    {
      ggl::MeshTyped<ggl::TextureRect::TextureVBO>::attributesReflection(void)::r = &ggl::TextureRect::textureVBOReflection;
    }

    ggl::MeshTyped<ggl::TextureRect::TextureVBO>::typedReflection(void)::r = &ggl::MeshTyped<ggl::TextureRect::TextureVBO>::attributesReflection(void)::r;
    qword_1EB82DEA8 = 1;
  }
}

void non-virtual thunk toggl::MeshTyped<ggl::TextureRect::TextureVBO>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::TextureRect::TextureVBO>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::TextureRect::TextureRectPipelineState::~TextureRectPipelineState(ggl::TextureRect::TextureRectPipelineState *this)
{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

void ggl::TextureRect::TextureRectPipelineSetup::typedReflection(ggl::TextureRect::TextureRectPipelineSetup *this)
{
  {
    ggl::MeshTyped<ggl::TextureRect::TextureVBO>::typedReflection();
    ggl::TextureRect::TextureRectPipelineSetup::typedReflection(void)::ref = &ggl::MeshTyped<ggl::TextureRect::TextureVBO>::typedReflection(void)::r;
    unk_1EB82E300 = &ggl::TextureRect::pipelineDataTextureRectPipelineDeviceStructs(void)::ref;
    qword_1EB82E308 = 0;
    {
      ggl::TextureRect::pipelineDataTextureRectPipelineConstantStructs(void)::ref = ggl::TextureRect::View::reflection(void)::reflection;
    }

    qword_1EB82E310 = &ggl::TextureRect::pipelineDataTextureRectPipelineConstantStructs(void)::ref;
    unk_1EB82E318 = vdupq_n_s64(1uLL);
  }
}

void ggl::TextureRect::TextureRectPipelineSetup::~TextureRectPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

uint64_t ggl::MetalResourceAccessor::commit(uint64_t result, void *a2)
{
  if (!a2[3])
  {
    ggl::MetalResourceManager::newRasterizationRateMap(*(*(result + 8) + 80), a2);
  }

  return result;
}

void *ggl::MetalResourceAccessor::commit(void *this, const ggl::PipelineState *a2)
{
  if (!*(a2 + 3))
  {
    return ggl::MetalResourceManager::newPipelineState(*(this[1] + 80), a2);
  }

  return this;
}

void *ggl::MetalResourceAccessor::commit(void *this, const ggl::ShaderLibrary *a2)
{
  if (!*(a2 + 3))
  {
    return ggl::MetalResourceManager::newLibrary(*(this[1] + 80), a2);
  }

  return this;
}

uint64_t ggl::CullingGrid::intersectedCellsForRibbon(unint64_t a1, float32x2_t *a2, int a3)
{
  v4 = 0;
  result = 0;
  v6 = a1 - (a3 ^ 1u);
  v7 = 1;
  do
  {
    v8 = v7;
    if (v6)
    {
      v9 = 0;
      v10 = v4 ^ 1;
      while (1)
      {
        v11 = &a2[v9++];
        v12 = &a2[v9 % a1];
        v13 = v12->f32[v4];
        v14 = v11->f32[v4];
        v15 = v13 - v14;
        if ((v13 - v14) != 0.0)
        {
          v16 = v13 * 4.0;
          v17 = vcvtps_s32_f32(fminf(v16, v14 * 4.0));
          v18 = vcvtms_s32_f32(fmaxf(v14 * 4.0, v16));
          if (v18 >= 3)
          {
            v18 = 3;
          }

          if (v18 >= v17)
          {
            break;
          }
        }

LABEL_17:
        if (v9 == v6)
        {
          goto LABEL_18;
        }
      }

      v19 = v11->f32[v10];
      v20 = v12->f32[v10] - v19;
      v21 = 1.0 / v15;
      while (1)
      {
        v22 = vcvtms_s32_f32((v19 + (-((v14 + (v17 * -0.25)) * v20) * v21)) * 4.0);
        if (v22 <= 3)
        {
          if (v8)
          {
            result = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v17 & 1 | (2 * (v22 & 1))] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v22 & 2 | (v17 >> 1) & 1]))) | result;
            if (v17)
            {
              v23 = 2 * (v22 & 1);
              v24 = v22 & 2 | ((v17 - 1) >> 1) & 1;
              v25 = v23 | (v17 - 1) & 1;
LABEL_15:
              result = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v25] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v24]))) | result;
            }
          }

          else
          {
            v26 = v22 & 1;
            result = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v26 | (2 * (v17 & 1))] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v17 & 2 | ((v22 & 0xFE) >> 1)]))) | result;
            if (v17)
            {
              v24 = (v22 >> 1) | (v17 - 1) & 2;
              v25 = v26 & 0xFFFFFFFD | (2 * ((v17 - 1) & 1));
              goto LABEL_15;
            }
          }
        }

        v71 = v18 > v17++;
        if (!v71)
        {
          goto LABEL_17;
        }
      }
    }

LABEL_18:
    v7 = 0;
    v4 = 1;
  }

  while ((v8 & 1) != 0);
  if (a1)
  {
    __asm { FMOV            V0.2S, #4.0 }

    v32 = a2;
    v33 = a1;
    do
    {
      v34 = *v32++;
      v35 = vmin_s32(vmax_s32(vcvt_s32_f32(vrndm_f32(vmul_f32(v34, _D0))), 0), 0x300000003);
      result = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v35.i8[0] & 1 | (2 * (v35.i8[4] & 1))] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v35.i8[4] & 2 | (v35.i32[0] >> 1)]))) | result;
      --v33;
    }

    while (v33);
    if (a3)
    {
      v74 = 0x8000000080000000;
      v36 = 0x8000000080000000;
      v37 = 0x8000000080000000;
      v38 = a2;
      v39 = a1;
      do
      {
        v40 = *v38++;
        v41 = vcvt_n_s32_f32(v40, 2uLL);
        v37 = vmin_s32(v41, v37);
        v36 = vmax_s32(v36, v41);
        --v39;
      }

      while (v39);
      HIDWORD(v74) = v36.i32[1];
      v42 = v36.i32[0];
      goto LABEL_28;
    }
  }

  else if (a3)
  {
    v74 = 0x8000000080000000;
    v37 = 0x8000000080000000;
    v42 = 0x80000000;
LABEL_28:
    v43 = 0;
    v44 = &v73;
    LODWORD(v74) = v42;
    v73 = v37;
    v72 = xmmword_1B33B22D0;
    v45 = &v72;
    v46 = 1;
    do
    {
      v47 = v46;
      if (*(&v72 + v43 + 2) <= v44->i32[0] || *v45 >= *(&v74 + v43))
      {
        v57 = 0x7FFFFFFF7FFFFFFFLL;
        v58 = 0x8000000080000000;
        goto LABEL_40;
      }

      v46 = 0;
      v45 = (&v72 + 4);
      v44 = (&v73 + 4);
      v43 = 1;
    }

    while ((v47 & 1) != 0);
    v48 = 0;
    v49 = &v75;
    v50 = &v73;
    v51 = &v72;
    v52 = 1;
    do
    {
      v53 = v52;
      v54 = *v51;
      v55 = v50->i32[0];
      if (v54 > v55)
      {
        v55 = v54;
      }

      v56 = *(&v74 + v48);
      if (v56 >= *(&v72 + v48 + 2))
      {
        v56 = *(&v72 + v48 + 2);
      }

      *(&v76 + v48) = v56;
      *v49 = v55;
      v49 = (&v75 + 4);
      v51 = (&v72 + 4);
      v50 = (&v73 + 4);
      v48 = 1;
      v52 = 0;
    }

    while ((v53 & 1) != 0);
    v57 = v75;
    v58 = v76;
LABEL_40:
    LODWORD(v74) = v58;
    if (v57 < v58)
    {
      v59 = HIDWORD(v57);
      do
      {
        if (SHIDWORD(v58) > v59)
        {
          v60 = (v57 * 0.25) + 0.125;
          v61 = v59;
          do
          {
            v62 = 1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v57 & 1 | (2 * (v61 & 1u))] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v61 & 2 | (v57 >> 1) & 1]));
            if ((v62 & result) == 0)
            {
              if (a1)
              {
                v63 = 0;
                v64 = 0;
                v65 = a2 + 1;
                v66 = 1;
                do
                {
                  if (v66 == a1)
                  {
                    v67 = 0;
                  }

                  else
                  {
                    v67 = v66;
                  }

                  v68 = &a2[v67];
                  v69 = *(v65 - 1);
                  v70 = fmaxf(v69, *v68);
                  v71 = v60 >= fminf(*v68, v69) && v60 < v70;
                  if (v71)
                  {
                    if (((v68[1] - ((v61 * 0.25) + 0.125)) * (v69 - v60)) > ((*v65 - ((v61 * 0.25) + 0.125)) * (*v68 - v60)))
                    {
                      ++v64;
                    }

                    else
                    {
                      --v64;
                    }

                    v63 = 1;
                  }

                  ++v66;
                  v65 += 2;
                }

                while (v66 - a1 != 1);
                if ((v63 & (v64 != 0)) == 0)
                {
                  v62 = 0;
                }
              }

              else
              {
                v62 = 0;
              }

              result = v62 | result;
            }

            ++v61;
          }

          while (v61 != HIDWORD(v58));
        }

        LODWORD(v57) = v57 + 1;
      }

      while (v57 != v58);
    }
  }

  return result;
}

void ggl::ShaderLibrary::~ShaderLibrary(ggl::ShaderLibrary *this)
{
  ggl::ShaderLibrary::~ShaderLibrary(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5C4C0;
  v2 = *(this + 27);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 22);
  if (v3)
  {
    v4 = *(this + 23);
    v5 = *(this + 22);
    if (v4 != v3)
    {
      do
      {
        v2 = *(v4 - 8);
        if (v2)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v2);
        }

        v4 -= 16;
      }

      while (v4 != v3);
      v5 = *(this + 22);
    }

    *(this + 23) = v3;
    v6 = ggl::zone_mallocator::instance(v2);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v6, v5);
  }

  std::vector<ggl::ShaderLibrary::ComputeShaderEntry,geo::allocator_adapter<ggl::ShaderLibrary::ComputeShaderEntry,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 144));
  std::vector<ggl::ShaderLibrary::ComputeShaderEntry,geo::allocator_adapter<ggl::ShaderLibrary::ComputeShaderEntry,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 112));
  v8 = *(this + 10);
  if (v8)
  {
    v9 = *(this + 11);
    v10 = *(this + 10);
    if (v9 != v8)
    {
      do
      {
        v7 = *(v9 - 8);
        if (v7)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v7);
        }

        v9 -= 24;
      }

      while (v9 != v8);
      v10 = *(this + 10);
    }

    *(this + 11) = v8;
    v11 = ggl::zone_mallocator::instance(v7);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v11, v10);
  }

  v12 = *(this + 6);
  if (v12)
  {
    v13 = *(this + 7);
    v14 = *(this + 6);
    if (v13 != v12)
    {
      do
      {
        v7 = *(v13 - 8);
        *(v13 - 8) = 0;
        if (v7)
        {
          v7 = (v7->~__shared_weak_count_0)(v7);
        }

        v13 -= 16;
      }

      while (v13 != v12);
      v14 = *(this + 6);
    }

    *(this + 7) = v12;
    v15 = ggl::zone_mallocator::instance(v7);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v15, v14);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

void std::vector<ggl::ShaderLibrary::ComputeShaderEntry,geo::allocator_adapter<ggl::ShaderLibrary::ComputeShaderEntry,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](ggl::zone_mallocator *a1)
{
  v1 = *a1;
  if (*a1)
  {
    *(a1 + 1) = v1;
    v2 = ggl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v2, v1);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

uint64_t std::__shared_ptr_pointer<ggl::Shader *,std::shared_ptr<ggl::Shader>::__shared_ptr_default_delete<ggl::Shader,ggl::Shader>,std::allocator<ggl::Shader>>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<ggl::Shader *,std::shared_ptr<ggl::Shader>::__shared_ptr_default_delete<ggl::Shader,ggl::Shader>,std::allocator<ggl::Shader>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t ggl::NullDevice::unvendLoader(uint64_t a1, uint64_t *a2)
{
  result = *a2;
  *a2 = 0;
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void ggl::NullDevice::~NullDevice(ggl::NullDevice *this)
{
  *this = &unk_1F2A5D838;
  v1 = *(this + 11);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5D838;
  v1 = *(this + 11);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }
}

double ggl::NullDevice::NullDevice(ggl::NullDevice *this)
{
  *(this + 8) = 0;
  *(this + 1) = 0u;
  *(this + 36) = xmmword_1B33B09D0;
  *(this + 7) = 0xF0000000ELL;
  *(this + 8) = 0;
  *(this + 72) = 0;
  *(this + 10) = 0;
  *(this + 11) = 0;
  *&result = 1;
  *(this + 12) = 1;
  *this = &unk_1F2A5C518;
  return result;
}

void std::vector<ggl::DeviceDataElement,geo::allocator_adapter<ggl::DeviceDataElement,ggl::zone_mallocator>>::resize(ggl::zone_mallocator *a1, unint64_t a2, _OWORD *a3)
{
  v6 = *a1;
  v5 = *(a1 + 1);
  v7 = v5 - *a1;
  v8 = v7 >> 4;
  if (a2 <= v7 >> 4)
  {
    if (a2 >= v8)
    {
      return;
    }

    v25 = &v6[16 * a2];
    goto LABEL_19;
  }

  v10 = *(a1 + 2);
  if (a2 - v8 <= (v10 - v5) >> 4)
  {
    v25 = &v5[a2 - v8];
    v26 = 16 * a2 - 16 * v8;
    do
    {
      *v5++ = *a3;
      v26 -= 16;
    }

    while (v26);
LABEL_19:
    *(a1 + 1) = v25;
    return;
  }

  if (a2 >> 60)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v11 = v10 - v6;
  v12 = v11 >> 3;
  if (v11 >> 3 <= a2)
  {
    v12 = a2;
  }

  if (v11 >= 0x7FFFFFFFFFFFFFF0)
  {
    v13 = 0xFFFFFFFFFFFFFFFLL;
  }

  else
  {
    v13 = v12;
  }

  v14 = ggl::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v14 + 32));
  v15 = malloc_type_zone_malloc(*v14, 16 * v13, 0x1020040EDED9539uLL);
  atomic_fetch_add((v14 + 24), 1u);
  geo::read_write_lock::unlock((v14 + 32));
  v16 = &v15[v7];
  v17 = &v15[16 * a2];
  v18 = &v6[16 * a2] - v5;
  v19 = &v15[v7];
  do
  {
    *v19 = *a3;
    v19 += 16;
    v18 -= 16;
  }

  while (v18);
  v20 = *(a1 + 1) - *a1;
  v21 = &v16[-v20];
  v22 = memcpy(&v16[-v20], *a1, v20);
  v23 = *a1;
  *a1 = v21;
  *(a1 + 1) = v17;
  *(a1 + 2) = &v15[16 * v13];
  if (v23)
  {
    v24 = ggl::zone_mallocator::instance(v22);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v24, v23);
  }
}

void std::vector<std::shared_ptr<ggl::ConstantData>,geo::allocator_adapter<std::shared_ptr<ggl::ConstantData>,ggl::zone_mallocator>>::resize(ggl::zone_mallocator *a1, unint64_t a2, void *a3)
{
  v5 = *a1;
  v6 = *(a1 + 1);
  v7 = &v6[-*a1];
  v8 = v7 >> 4;
  if (a2 <= v7 >> 4)
  {
    if (a2 < v8)
    {
      v26 = &v5[16 * a2];
      while (v6 != v26)
      {
        v27 = *(v6 - 1);
        if (v27)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v27);
        }

        v6 -= 16;
      }

      *(a1 + 1) = v26;
    }
  }

  else
  {
    v10 = a2 - v8;
    v11 = *(a1 + 2);
    if (v10 <= (v11 - v6) >> 4)
    {
      v28 = &v6[16 * v10];
      do
      {
        v29 = a3[1];
        *v6 = *a3;
        *(v6 + 1) = v29;
        if (v29)
        {
          atomic_fetch_add_explicit((v29 + 8), 1uLL, memory_order_relaxed);
        }

        v6 += 16;
      }

      while (v6 != v28);
      *(a1 + 1) = v28;
    }

    else
    {
      if (a2 >> 60)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v12 = v11 - v5;
      v13 = v12 >> 3;
      if (v12 >> 3 <= a2)
      {
        v13 = a2;
      }

      if (v12 >= 0x7FFFFFFFFFFFFFF0)
      {
        v14 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v14 = v13;
      }

      v15 = ggl::zone_mallocator::instance(a1);
      geo::read_write_lock::read_lock((v15 + 32));
      v16 = malloc_type_zone_malloc(*v15, 16 * v14, 0x20040A4A59CD2uLL);
      atomic_fetch_add((v15 + 24), 1u);
      geo::read_write_lock::unlock((v15 + 32));
      v17 = &v16[v7];
      v18 = &v16[16 * a2];
      v19 = &v16[v7];
      do
      {
        v20 = a3[1];
        *v19 = *a3;
        *(v19 + 1) = v20;
        if (v20)
        {
          atomic_fetch_add_explicit((v20 + 8), 1uLL, memory_order_relaxed);
        }

        v19 += 16;
      }

      while (v19 != v18);
      v21 = *(a1 + 1) - *a1;
      v22 = &v17[-v21];
      v23 = memcpy(&v17[-v21], *a1, v21);
      v24 = *a1;
      *a1 = v22;
      *(a1 + 1) = v18;
      *(a1 + 2) = &v16[16 * v14];
      if (v24)
      {
        v25 = ggl::zone_mallocator::instance(v23);

        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v25, v24);
      }
    }
  }
}

void ggl::PipelineSetup::useResetFlags(ggl::PipelineSetup *this)
{
  std::vector<BOOL>::resize(this + 80, (*(this + 22) - *(this + 21)) >> 3, 1);
  std::vector<BOOL>::resize(this + 32, (*(this + 14) - *(this + 13)) >> 4, 0);
  v2 = (*(this + 18) - *(this + 17)) >> 4;

  std::vector<BOOL>::resize(this + 56, v2, 1);
}

BOOL ggl::PipelineSetup::canSetDeviceF(ggl::PipelineSetup *this, uint64_t a2, int *a3)
{
  if (this && (v3 = *(*(*(this + 6) + 72) + 24), (v4 = *(v3 + 56)) != 0))
  {
    v5 = *(v3 + 48);
    while (v5[1] != a2)
    {
      v5 += 2;
      if (!--v4)
      {
        goto LABEL_6;
      }
    }

    v6 = *v5;
  }

  else
  {
LABEL_6:
    v6 = -1;
  }

  *a3 = v6;
  return v6 >= 0;
}

uint64_t ggl::PipelineSetup::setTextureData(uint64_t this, uint64_t a2, ggl::Texture *a3)
{
  v3 = *(this + 16);
  if (v3)
  {
    v4 = *(*(v3 + 48) + 72);
    v5 = *(v4 + 8);
    v6 = *(v5 + 72);
    if (v6)
    {
      i = *(v5 + 64);
      while (i[1] != a2)
      {
        i += 2;
        if (!--v6)
        {
          goto LABEL_6;
        }
      }

      goto LABEL_11;
    }

LABEL_6:
    v8 = *(v4 + 24);
    v9 = *(v8 + 72);
    if (v9)
    {
      for (i = *(v8 + 64); i[1] != a2; i += 2)
      {
        if (!--v9)
        {
          return this;
        }
      }

LABEL_11:
      *(*(this + 168) + 8 * *i) = a3;
    }
  }

  return this;
}

void ggl::PipelineSetup::setDeviceDataWithoutCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4 = (a1 + 16 * a3);
  *v4 = a4;
  v4[1] = 0;
  v5 = (a2 + 16 * a3);
  v6 = v5[1];
  *v5 = 0;
  v5[1] = 0;
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }
}

void non-virtual thunk toggl::VertexDataTyped<ggl::ColoredText::My>::~VertexDataTyped(uint64_t a1)
{
  ggl::BufferData::~BufferData((a1 - 200));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::BufferData::~BufferData((a1 - 200));
}

void ggl::VertexDataTyped<ggl::ColoredText::My>::~VertexDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::ColoredText::My>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::ColoredText::My>,ggl::zone_mallocator>>::__on_zero_shared_weak(ggl::zone_mallocator *a1)
{
  v2 = ggl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::ColoredText::My>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::ColoredText::My>,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C670;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::ColoredText::MyMesh::~MyMesh(ggl::ColoredText::MyMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void ggl::ColoredText::MyMesh::~MyMesh(ggl::ColoredText::MyMesh *this)
{
  ggl::Mesh::~Mesh(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::MeshTyped<ggl::ColoredText::My>::typedReflection()
{
  {
    {
      ggl::MeshTyped<ggl::ColoredText::My>::attributesReflection(void)::r = &ggl::ColoredText::myReflection;
    }

    ggl::MeshTyped<ggl::ColoredText::My>::typedReflection(void)::r = &ggl::MeshTyped<ggl::ColoredText::My>::attributesReflection(void)::r;
    qword_1EB82DEC0 = 1;
  }
}

void non-virtual thunk toggl::MeshTyped<ggl::ColoredText::My>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::ColoredText::My>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ColoredText::MyPipelineState::~MyPipelineState(ggl::ColoredText::MyPipelineState *this)
{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

void ggl::ColoredText::MyPipelineSetup::typedReflection(ggl::ColoredText::MyPipelineSetup *this)
{
  {
    ggl::MeshTyped<ggl::ColoredText::My>::typedReflection();
    ggl::ColoredText::MyPipelineSetup::typedReflection(void)::ref = &ggl::MeshTyped<ggl::ColoredText::My>::typedReflection(void)::r;
    *algn_1EB82E338 = &ggl::ColoredText::pipelineDataMyPipelineDeviceStructs(void)::ref;
    qword_1EB82E340 = 0;
    {
      ggl::ColoredText::pipelineDataMyPipelineConstantStructs(void)::ref = ggl::ColoredText::View::reflection(void)::reflection;
    }

    qword_1EB82E348 = &ggl::ColoredText::pipelineDataMyPipelineConstantStructs(void)::ref;
    *algn_1EB82E350 = vdupq_n_s64(1uLL);
  }
}

void ggl::ColoredText::MyPipelineSetup::~MyPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

char *std::vector<ggl::Texture2DLoadItem,geo::allocator_adapter<ggl::Texture2DLoadItem,ggl::zone_mallocator>>::__emplace_back_slow_path<ggl::Texture2DLoadItem>(uint64_t *a1, __int128 *a2)
{
  v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v3)
  {
    v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }

  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999)
  {
    v6 = 0x333333333333333;
  }

  else
  {
    v6 = v3;
  }

  v18[4] = a1 + 3;
  if (v6)
  {
    v7 = ggl::zone_mallocator::instance(a1);
    v8 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::Texture2DLoadItem>(v7, v6);
  }

  else
  {
    v8 = 0;
  }

  v9 = &v8[80 * v2];
  v10 = *a2;
  v11 = a2[1];
  *(v9 + 28) = *(a2 + 28);
  v12 = &v8[80 * v6];
  *v9 = v10;
  *(v9 + 1) = v11;
  std::__function::__value_func<void ()(ggl::Texture2DLoadItem const&)>::__value_func[abi:nn200100]((v9 + 48), (a2 + 3));
  v13 = a1[1];
  v14 = &v9[*a1 - v13];
  std::__uninitialized_allocator_relocate[abi:nn200100]<geo::allocator_adapter<ggl::Texture2DLoadItem,ggl::zone_mallocator>,ggl::Texture2DLoadItem*>(*a1, v13, v14);
  v15 = *a1;
  *a1 = v14;
  a1[1] = (v9 + 80);
  v16 = a1[2];
  a1[2] = v12;
  v18[2] = v15;
  v18[3] = v16;
  v18[0] = v15;
  v18[1] = v15;
  std::__split_buffer<ggl::Texture2DLoadItem,geo::allocator_adapter<ggl::Texture2DLoadItem,ggl::zone_mallocator> &>::~__split_buffer(v18);
  return v9 + 80;
}

BOOL ggl::DebugConsole::flush(ggl::DebugConsole *this, ggl::CommandBuffer *a2, const RenderTargetFormat *a3)
{
  v6 = *(this + 7);
  v7 = *(v6 + 88);
  v8 = (v6 + 72);
  if (v7)
  {
    v8 = v7;
  }

  v11 = v8;
  v9 = *v8;
  v10 = v11[1];
  v12 = v10 != v9;
  if (v10 != v9)
  {
    ggl::DebugConsole::setRenderTargetFormat(this, a3);
    ggl::CommandBuffer::pushRenderItem(a2, *(this + 7));
  }

  v13 = *(this + 8);
  v14 = *(v13 + 88);
  v15 = (v13 + 72);
  if (v14)
  {
    v15 = v14;
  }

  if (v15[1] != *v15)
  {
    ggl::DebugConsole::setRenderTargetFormat(this, a3);
    ggl::CommandBuffer::pushRenderItem(a2, *(this + 8));
    return 1;
  }

  return v12;
}

uint64_t ggl::DebugConsole::setRenderTargetFormat(uint64_t this, const RenderTargetFormat *a2)
{
  v12 = *MEMORY[0x1E69E9840];
  colorFormatsCount = a2->colorFormatsCount;
  if (colorFormatsCount != *(this + 136) || a2->samples != *(this + 144) || a2->depthStencilFormat != *(this + 148))
  {
    goto LABEL_9;
  }

  if (colorFormatsCount)
  {
    v3 = a2;
    v4 = (this + 120);
    while (1)
    {
      v6 = v3->colorFormats[0];
      v3 = (v3 + 4);
      v5 = v6;
      v7 = *v4++;
      if (v5 != v7)
      {
        break;
      }

      if (!--colorFormatsCount)
      {
        return this;
      }
    }

LABEL_9:
    v8 = *&a2->colorFormatsCount;
    *(this + 120) = *a2->colorFormats;
    *(this + 136) = v8;
    v9 = *(*(*(this + 112) + 80) + 136);
    if (v9)
    {
      atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
    }

    v10 = 0uLL;
    v11 = 0;
    operator new();
  }

  return this;
}

void std::__shared_ptr_emplace<ggl::TextureRect::TextureRectPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C7E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ColoredText::MyPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C7A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::DebugConsole::~DebugConsole(ggl::DebugConsole *this)
{
  ggl::DebugConsole::~DebugConsole(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5C6E8;
  v2 = *(*(this + 7) + 32);
  v3 = *v2[21];
  if (!v3 || ((*(*v3 + 8))(*v2[21]), v4 = *(this + 7), (v2 = v4[4]) != 0))
  {
    ((*v2)[1])(v2);
    v4 = *(this + 7);
  }

  v5 = v4[3];
  if (v5)
  {
    (*(*v5 + 8))(v5);
    v4 = *(this + 7);
  }

  v6 = v4[8];
  if (v6)
  {
    (*(*v6 + 8))(v6);
  }

  v7 = *(this + 8);
  v8 = v7[4];
  if (v8)
  {
    (*(*v8 + 8))(v8);
    v7 = *(this + 8);
  }

  v9 = v7[3];
  if (v9)
  {
    (*(*v9 + 8))(v9);
    v7 = *(this + 8);
  }

  v10 = v7[8];
  if (v10)
  {
    (*(*v10 + 8))(v10);
  }

  v11 = *(this + 11);
  if (v11)
  {
    MEMORY[0x1B8C62170](v11, 0x1000C8000313F17);
  }

  std::unique_ptr<ggl::DataWrite<ggl::TransitNode::DefaultVbo>>::reset[abi:nn200100](this + 9, 0);
  v12 = *(this + 8);
  *(this + 8) = 0;
  if (v12)
  {
    (*(*v12 + 8))(v12);
  }

  v13 = *(this + 7);
  *(this + 7) = 0;
  if (v13)
  {
    (*(*v13 + 8))(v13);
  }
}

void ggl::DebugConsole::DebugConsole(ggl::DebugConsole *this, const ggl::CommonLibrary *a2)
{
  *this = &unk_1F2A5C6E8;
  *(this + 8) = xmmword_1B33B22E0;
  *(this + 24) = xmmword_1B33B22F0;
  *(this + 5) = 0;
  *(this + 6) = 108000;
  *(this + 56) = 0u;
  *(this + 72) = 0u;
  *(this + 11) = 0;
  *(this + 12) = 0xFFFFFFFFLL;
  *(this + 26) = 1056964608;
  *(this + 108) = 0;
  *(this + 14) = a2;
  *(this + 120) = 0u;
  *(this + 136) = 0u;
  operator new();
}

void ggl::ConstantDataTyped<ggl::TextureRect::View>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TextureRect::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C870;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::ConstantDataTyped<ggl::ColoredText::View>::~ConstantDataTyped(std::mutex *a1)
{
  ggl::BufferData::~BufferData(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ColoredText::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

ggl::BufferMemory *ggl::DebugConsole::end(ggl::BufferMemory **this)
{
  result = std::unique_ptr<ggl::DataWrite<ggl::TransitNode::DefaultVbo>>::reset[abi:nn200100](this + 9, 0);
  v3 = this[7];
  v4 = this[10];
  *(v3 + 9) = 0;
  *(v3 + 10) = v4;
  *(v3 + 11) = 0;
  *(v3 + 12) = 1;
  return result;
}

uint64_t ggl::DebugConsole::setProjection(uint64_t a1, uint64_t a2)
{
  v4 = **(*(*(a1 + 56) + 32) + 136);
  v21 = 0;
  v22 = 0;
  v15 = 0;
  v16 = 0;
  v5 = *(v4 + 8);
  v23 = v4;
  v24 = 0;
  v25 = v5;
  v26 = 1;
  if (v5)
  {
    v6 = *(v4 + 72);
  }

  else
  {
    v6 = 0;
  }

  v27 = v6;
  ggl::BufferMemory::operator=(&v15, &v22);
  if (v27)
  {
    ggl::ResourceAccessor::_endAccess(v27, v22, v23, v24, v25, v26, HIBYTE(v26));
  }

  v7 = 0;
  v8 = v21;
  do
  {
    *(v8 + v7) = *(a2 + v7);
    v7 += 4;
  }

  while (v7 != 64);
  ggl::ResourceAccessor::_endAccess(v8, v15, v16, v17, v18, v19, v20);
  v9 = **(*(*(a1 + 64) + 32) + 136);
  v21 = 0;
  v22 = 0;
  v15 = 0;
  v16 = 0;
  v10 = *(v9 + 8);
  v23 = v9;
  v24 = 0;
  v25 = v10;
  v26 = 1;
  if (v10)
  {
    v11 = *(v9 + 72);
  }

  else
  {
    v11 = 0;
  }

  v27 = v11;
  ggl::BufferMemory::operator=(&v15, &v22);
  if (v27)
  {
    ggl::ResourceAccessor::_endAccess(v27, v22, v23, v24, v25, v26, HIBYTE(v26));
  }

  v12 = 0;
  v13 = v21;
  do
  {
    *(v13 + v12) = *(a2 + v12);
    v12 += 4;
  }

  while (v12 != 64);
  return ggl::ResourceAccessor::_endAccess(v13, v15, v16, v17, v18, v19, v20);
}

uint64_t ggl::DebugConsole::_measureLine(uint64_t this, const char *a2, uint64_t a3)
{
  for (i = 0.0; a3; --a3)
  {
    v5 = *a2++;
    v4 = v5;
    if (v5 > 0x21 || v4 == 32)
    {
      i = *(this + 24) + i;
    }

    else if (v4 == 9)
    {
      i = i + (*(this + 24) * 4.0);
    }

    else if (v4 == 10)
    {
      return this;
    }
  }

  return this;
}

uint64_t ggl::DebugConsole::drawString(uint64_t this, const char *a2, uint64_t a3)
{
  if (a2)
  {
    v3 = a3;
    v5 = this;
    v7 = *(this + 8);
    v6 = *(this + 12);
    this = ggl::DebugConsole::_measureLine(this, a2, a3);
    if (v3)
    {
      v9 = a2;
      v10 = v3;
      v11 = *(v5 + 28);
      do
      {
        v12 = *v9++;
        if (v12 == 10)
        {
          v11 = v11 + *(v5 + 28);
        }

        --v10;
      }

      while (v10);
    }

    else
    {
      v11 = *(v5 + 28);
    }

    v13 = v7 - v8;
    v14 = *(v5 + 40);
    v15 = *(v5 + 44);
    v16 = v7 + (v8 * -0.5);
    if (v14 != 1)
    {
      v16 = v7;
    }

    if (v14 == 2)
    {
      v17 = v13;
    }

    else
    {
      v17 = v16;
    }

    v18 = v6 - v11;
    v19 = v6 + (v11 * -0.5);
    if (v15 != 1)
    {
      v19 = v6;
    }

    if (v15 == 2)
    {
      v20 = v18;
    }

    else
    {
      v20 = v19;
    }

    if ((108000 - *(v5 + 80)) / 6uLL < v3)
    {
      v3 = (108000 - *(v5 + 80)) / 6uLL;
    }

    if (v3)
    {
      v21 = 0;
      v22 = v5 + 96;
      v23 = v5 + 100;
      do
      {
        v24 = a2[v21];
        if (v24 < 0x22)
        {
          if (v24 != 32)
          {
            if (v24 == 10)
            {
              this = ggl::DebugConsole::_measureLine(v5, &a2[v21 + 1], v3 + ~v21);
              v20 = *(v5 + 28) + v20;
              v70 = *(v5 + 40);
              switch(v70)
              {
                case 2:
                  v17 = *(v5 + 8) - v69;
                  break;
                case 1:
                  v17 = *(v5 + 8) + (v69 * -0.5);
                  break;
                case 0:
                  v17 = *(v5 + 8);
                  break;
              }
            }

            else if (v24 == 9)
            {
              v17 = v17 + (*(v5 + 24) * 4.0);
            }

            goto LABEL_55;
          }
        }

        else
        {
          v25 = 0;
          v27 = *(v5 + 16);
          v26 = *(v5 + 20);
          v28 = (v24 - 33) * 0.0097656;
          v29 = *(v5 + 72);
          v30 = *(v5 + 80);
          *(v5 + 80) = v30 + 1;
          v31 = *(v5 + 108);
          if (*(v5 + 108))
          {
            v32 = v28 + 0.0097656;
          }

          else
          {
            v32 = v28;
          }

          v33 = *(v29 + 40) + 24 * v30;
          *v33 = v17;
          *(v33 + 4) = v20;
          *(v33 + 8) = 0;
          *(v33 + 12) = v32;
          do
          {
            *(v33 + 16 + v25) = *(v22 + v25);
            ++v25;
          }

          while (v25 != 4);
          v34 = 0;
          v35 = v33 + 20;
          do
          {
            *(v35 + v34) = *(v23 + v34);
            ++v34;
          }

          while (v34 != 4);
          v36 = 0;
          v37 = v31 == 0;
          v38 = *(v5 + 72);
          v39 = *(v5 + 80);
          *(v5 + 80) = v39 + 1;
          if (v37)
          {
            v28 = v28 + 0.0097656;
          }

          v40 = v20 + v26;
          v41 = *(v38 + 40) + 24 * v39;
          *v41 = v17;
          *(v41 + 4) = v40;
          *(v41 + 8) = 0;
          *(v41 + 12) = v28;
          do
          {
            *(v41 + 16 + v36) = *(v22 + v36);
            ++v36;
          }

          while (v36 != 4);
          v42 = 0;
          v43 = v41 + 20;
          do
          {
            *(v43 + v42) = *(v23 + v42);
            ++v42;
          }

          while (v42 != 4);
          v44 = 0;
          v45 = v17 + v27;
          v46 = *(v5 + 72);
          v47 = *(v5 + 80);
          *(v5 + 80) = v47 + 1;
          v48 = *(v46 + 40) + 24 * v47;
          *v48 = v45;
          *(v48 + 4) = v20;
          *(v48 + 8) = 1065353216;
          *(v48 + 12) = v32;
          do
          {
            *(v48 + 16 + v44) = *(v22 + v44);
            ++v44;
          }

          while (v44 != 4);
          v49 = 0;
          v50 = v48 + 20;
          do
          {
            *(v50 + v49) = *(v23 + v49);
            ++v49;
          }

          while (v49 != 4);
          v51 = 0;
          v52 = *(v5 + 72);
          v53 = *(v5 + 80);
          *(v5 + 80) = v53 + 1;
          v54 = *(v52 + 40) + 24 * v53;
          *v54 = v45;
          *(v54 + 4) = v20;
          *(v54 + 8) = 1065353216;
          *(v54 + 12) = v32;
          do
          {
            *(v54 + 16 + v51) = *(v22 + v51);
            ++v51;
          }

          while (v51 != 4);
          v55 = 0;
          v56 = v54 + 20;
          do
          {
            *(v56 + v55) = *(v23 + v55);
            ++v55;
          }

          while (v55 != 4);
          v57 = 0;
          v58 = *(v5 + 72);
          v59 = *(v5 + 80);
          *(v5 + 80) = v59 + 1;
          v60 = *(v58 + 40) + 24 * v59;
          *v60 = v17;
          *(v60 + 4) = v40;
          *(v60 + 8) = 0;
          *(v60 + 12) = v28;
          do
          {
            *(v60 + 16 + v57) = *(v22 + v57);
            ++v57;
          }

          while (v57 != 4);
          v61 = 0;
          v62 = v60 + 20;
          do
          {
            *(v62 + v61) = *(v23 + v61);
            ++v61;
          }

          while (v61 != 4);
          v63 = 0;
          v64 = *(v5 + 72);
          v65 = *(v5 + 80);
          *(v5 + 80) = v65 + 1;
          v66 = *(v64 + 40) + 24 * v65;
          *v66 = v45;
          *(v66 + 4) = v40;
          *(v66 + 8) = 1065353216;
          *(v66 + 12) = v28;
          do
          {
            *(v66 + 16 + v63) = *(v22 + v63);
            ++v63;
          }

          while (v63 != 4);
          v67 = 0;
          v68 = v66 + 20;
          do
          {
            *(v68 + v67) = *(v23 + v67);
            ++v67;
          }

          while (v67 != 4);
        }

        v17 = v17 + *(v5 + 24);
LABEL_55:
        ++v21;
      }

      while (v21 != v3);
    }

    *(v5 + 8) = v17;
    *(v5 + 12) = v20;
  }

  return this;
}

float32_t ggl::DebugConsole::drawBar(float32x2_t *this, float32_t result)
{
  v2 = this[10];
  if ((*&v2 + 6) <= *&this[6])
  {
    v3 = 0;
    v4 = this[2].f32[1];
    v5 = this[13].u8[4];
    v6 = 0.92773;
    v7 = 0.9375;
    if (!this[13].i8[4])
    {
      v7 = 0.92773;
    }

    v8 = this[9];
    this[10] = (*&v2 + 1);
    v9 = *(*&v8 + 40) + 24 * *&v2;
    *v9 = this[1].i32[0];
    *(v9 + 4) = this[1].i32[1];
    *(v9 + 8) = 0;
    *(v9 + 12) = v7;
    v10 = this + 12;
    do
    {
      *(v9 + 16 + v3) = v10->i8[v3];
      ++v3;
    }

    while (v3 != 4);
    v11 = 0;
    v12 = &this[12] + 4;
    v13 = v9 + 20;
    do
    {
      *(v13 + v11) = v12[v11];
      ++v11;
    }

    while (v11 != 4);
    v14 = 0;
    v15 = v5 == 0;
    v16 = this[10];
    v17 = *(*&this[9] + 40) + 24 * *&v16;
    if (v15)
    {
      v6 = 0.9375;
    }

    v18 = this[1].i32[0];
    v19 = this[1].f32[1] + v4;
    this[10] = (*&v16 + 1);
    *v17 = v18;
    *(v17 + 4) = v19;
    *(v17 + 8) = 0;
    *(v17 + 12) = v6;
    do
    {
      *(v17 + 16 + v14) = v10->i8[v14];
      ++v14;
    }

    while (v14 != 4);
    v20 = 0;
    v21 = v17 + 20;
    do
    {
      *(v21 + v20) = v12[v20];
      ++v20;
    }

    while (v20 != 4);
    v22 = 0;
    v23 = this[10];
    v24 = *(*&this[9] + 40) + 24 * *&v23;
    v25 = this[1].i32[1];
    v26 = this[1].f32[0] + result;
    this[10] = (*&v23 + 1);
    *v24 = v26;
    *(v24 + 4) = v25;
    *(v24 + 8) = 1065353216;
    *(v24 + 12) = v7;
    do
    {
      *(v24 + 16 + v22) = v10->i8[v22];
      ++v22;
    }

    while (v22 != 4);
    v27 = 0;
    v28 = v24 + 20;
    do
    {
      *(v28 + v27) = v12[v27];
      ++v27;
    }

    while (v27 != 4);
    v29 = 0;
    v30 = this[10];
    v31 = *(*&this[9] + 40) + 24 * *&v30;
    v32 = this[1].i32[1];
    v33 = this[1].f32[0] + result;
    this[10] = (*&v30 + 1);
    *v31 = v33;
    *(v31 + 4) = v32;
    *(v31 + 8) = 1065353216;
    *(v31 + 12) = v7;
    do
    {
      *(v31 + 16 + v29) = v10->i8[v29];
      ++v29;
    }

    while (v29 != 4);
    v34 = 0;
    v35 = v31 + 20;
    do
    {
      *(v35 + v34) = v12[v34];
      ++v34;
    }

    while (v34 != 4);
    v36 = 0;
    v37 = this[10];
    v38 = *(*&this[9] + 40) + 24 * *&v37;
    v39 = this[1].i32[0];
    v40 = this[1].f32[1] + v4;
    this[10] = (*&v37 + 1);
    *v38 = v39;
    *(v38 + 4) = v40;
    *(v38 + 8) = 0;
    *(v38 + 12) = v6;
    do
    {
      *(v38 + 16 + v36) = v10->i8[v36];
      ++v36;
    }

    while (v36 != 4);
    v41 = 0;
    v42 = v38 + 20;
    do
    {
      *(v42 + v41) = v12[v41];
      ++v41;
    }

    while (v41 != 4);
    v43 = 0;
    v44 = this[10];
    v45 = (*(*&this[9] + 40) + 24 * *&v44);
    this[10] = (*&v44 + 1);
    *v45 = vadd_f32(this[1], __PAIR64__(LODWORD(v4), LODWORD(result)));
    v45[1].i32[0] = 1065353216;
    v45[1].f32[1] = v6;
    do
    {
      v45[2].i8[v43] = v10->i8[v43];
      ++v43;
    }

    while (v43 != 4);
    for (i = 0; i != 4; ++i)
    {
      v45[2].i8[i + 4] = v12[i];
    }

    result = this[1].f32[0] + result;
    this[1].f32[0] = result;
  }

  return result;
}

float32x2_t *ggl::DebugConsole::drawSymbol(float32x2_t *result, char a2)
{
  v2 = result[10];
  if ((*&v2 + 6) <= *&result[6])
  {
    v3 = 0;
    v4 = ((a2 - 127) - 33) * 0.0097656;
    v5 = result[13].u8[4];
    v6 = result[9];
    result[10] = (*&v2 + 1);
    v7 = *(*&v6 + 40) + 24 * *&v2;
    v8 = result[4];
    v9 = vmla_f32(result[1], 0xBF000000BF000000, v8);
    *v7 = v9;
    if (v5)
    {
      v10 = v4 + 0.0097656;
    }

    else
    {
      v10 = ((a2 - 127) - 33) * 0.0097656;
    }

    *(v7 + 8) = 0;
    *(v7 + 12) = v10;
    v11 = result + 12;
    do
    {
      *(v7 + 16 + v3) = v11->i8[v3];
      ++v3;
    }

    while (v3 != 4);
    v12 = 0;
    v13 = &result[12] + 4;
    v14 = v7 + 20;
    do
    {
      *(v14 + v12) = v13[v12];
      ++v12;
    }

    while (v12 != 4);
    v15 = 0;
    v16 = v5 == 0;
    v17 = result[10];
    v18 = *(*&result[9] + 40) + 24 * *&v17;
    if (v16)
    {
      v4 = v4 + 0.0097656;
    }

    v19 = vadd_f32(v9, v8);
    result[10] = (*&v17 + 1);
    *v18 = __PAIR64__(v19.u32[1], v9.u32[0]);
    *(v18 + 8) = 0;
    *(v18 + 12) = v4;
    do
    {
      *(v18 + 16 + v15) = v11->i8[v15];
      ++v15;
    }

    while (v15 != 4);
    v20 = 0;
    v21 = v18 + 20;
    do
    {
      *(v21 + v20) = v13[v20];
      ++v20;
    }

    while (v20 != 4);
    v22 = 0;
    v23 = result[10];
    v24 = *(*&result[9] + 40) + 24 * *&v23;
    result[10] = (*&v23 + 1);
    *v24 = __PAIR64__(v9.u32[1], v19.u32[0]);
    *(v24 + 8) = 1065353216;
    *(v24 + 12) = v10;
    do
    {
      *(v24 + 16 + v22) = v11->i8[v22];
      ++v22;
    }

    while (v22 != 4);
    v25 = 0;
    v26 = v24 + 20;
    do
    {
      *(v26 + v25) = v13[v25];
      ++v25;
    }

    while (v25 != 4);
    v27 = 0;
    v28 = result[9];
    v29 = result[10];
    result[10] = (*&v29 + 1);
    v30 = *(*&v28 + 40) + 24 * *&v29;
    *v30 = v19.i32[0];
    *(v30 + 4) = v9.i32[1];
    *(v30 + 8) = 1065353216;
    *(v30 + 12) = v10;
    do
    {
      *(v30 + 16 + v27) = v11->i8[v27];
      ++v27;
    }

    while (v27 != 4);
    v31 = 0;
    v32 = v30 + 20;
    do
    {
      *(v32 + v31) = v13[v31];
      ++v31;
    }

    while (v31 != 4);
    v33 = 0;
    v34 = result[9];
    v35 = result[10];
    result[10] = (*&v35 + 1);
    v36 = *(*&v34 + 40) + 24 * *&v35;
    *v36 = __PAIR64__(v19.u32[1], v9.u32[0]);
    *(v36 + 8) = 0;
    *(v36 + 12) = v4;
    do
    {
      *(v36 + 16 + v33) = v11->i8[v33];
      ++v33;
    }

    while (v33 != 4);
    v37 = 0;
    v38 = v36 + 20;
    do
    {
      *(v38 + v37) = v13[v37];
      ++v37;
    }

    while (v37 != 4);
    v39 = 0;
    v40 = result[9];
    v41 = result[10];
    result[10] = (*&v41 + 1);
    v42 = *(*&v40 + 40) + 24 * *&v41;
    *v42 = v19;
    *(v42 + 8) = 1065353216;
    *(v42 + 12) = v4;
    do
    {
      *(v42 + 16 + v39) = v11->i8[v39];
      ++v39;
    }

    while (v39 != 4);
    for (i = 0; i != 4; ++i)
    {
      *(v42 + 20 + i) = v13[i];
    }
  }

  return result;
}

float ggl::DebugConsole::drawLine(uint64_t a1, float *a2, float result)
{
  v3 = *(a1 + 80);
  if ((v3 + 6) <= *(a1 + 48))
  {
    v4 = 0;
    v5 = *(a1 + 8);
    v6 = *(a1 + 12);
    v7 = a2[1] - v6;
    v8 = v5 - *a2;
    v9 = *(a1 + 104) / sqrtf((v8 * v8) + (v7 * v7));
    v10 = v9 * v7;
    v11 = v9 * v8;
    v12 = *(a1 + 72);
    *(a1 + 80) = v3 + 1;
    v13 = *(v12 + 40) + 24 * v3;
    *v13 = v5 - v10;
    *(v13 + 4) = v6 - v11;
    *(v13 + 8) = 0x3F6D800000000000;
    v14 = a1 + 96;
    do
    {
      *(v13 + 16 + v4) = *(v14 + v4);
      ++v4;
    }

    while (v4 != 4);
    v15 = 0;
    v16 = a1 + 100;
    v17 = v13 + 20;
    do
    {
      *(v17 + v15) = *(v16 + v15);
      ++v15;
    }

    while (v15 != 4);
    v18 = 0;
    v19 = *(a1 + 80);
    v20 = *(*(a1 + 72) + 40) + 24 * v19;
    v21 = *a2 + v10;
    v22 = a2[1] + v11;
    *(a1 + 80) = v19 + 1;
    *v20 = v21;
    *(v20 + 4) = v22;
    *(v20 + 8) = 0x3F7000003F800000;
    do
    {
      *(v20 + 16 + v18) = *(v14 + v18);
      ++v18;
    }

    while (v18 != 4);
    v23 = 0;
    v24 = v20 + 20;
    do
    {
      *(v24 + v23) = *(v16 + v23);
      ++v23;
    }

    while (v23 != 4);
    v25 = 0;
    v26 = *(a1 + 80);
    v27 = *(*(a1 + 72) + 40) + 24 * v26;
    v28 = *(a1 + 8) + v10;
    v29 = *(a1 + 12) + v11;
    *(a1 + 80) = v26 + 1;
    *v27 = v28;
    *(v27 + 4) = v29;
    *(v27 + 8) = 0x3F70000000000000;
    do
    {
      *(v27 + 16 + v25) = *(v14 + v25);
      ++v25;
    }

    while (v25 != 4);
    v30 = 0;
    v31 = v27 + 20;
    do
    {
      *(v31 + v30) = *(v16 + v30);
      ++v30;
    }

    while (v30 != 4);
    v32 = 0;
    v33 = *(a1 + 80);
    v34 = *(*(a1 + 72) + 40) + 24 * v33;
    v35 = *(a1 + 8) - v10;
    v36 = *(a1 + 12) - v11;
    *(a1 + 80) = v33 + 1;
    *v34 = v35;
    *(v34 + 4) = v36;
    *(v34 + 8) = 0x3F6D800000000000;
    do
    {
      *(v34 + 16 + v32) = *(v14 + v32);
      ++v32;
    }

    while (v32 != 4);
    v37 = 0;
    v38 = v34 + 20;
    do
    {
      *(v38 + v37) = *(v16 + v37);
      ++v37;
    }

    while (v37 != 4);
    v39 = 0;
    v40 = *(a1 + 80);
    v41 = *(*(a1 + 72) + 40) + 24 * v40;
    v42 = *a2 - v10;
    v43 = a2[1] - v11;
    *(a1 + 80) = v40 + 1;
    *v41 = v42;
    *(v41 + 4) = v43;
    *(v41 + 8) = 0x3F6D80003F800000;
    do
    {
      *(v41 + 16 + v39) = *(v14 + v39);
      ++v39;
    }

    while (v39 != 4);
    v44 = 0;
    v45 = v41 + 20;
    do
    {
      *(v45 + v44) = *(v16 + v44);
      ++v44;
    }

    while (v44 != 4);
    v46 = 0;
    v47 = *a2 + v10;
    v48 = *(a1 + 80);
    v49 = *(*(a1 + 72) + 40) + 24 * v48;
    v50 = a2[1] + v11;
    *(a1 + 80) = v48 + 1;
    *v49 = v47;
    *(v49 + 4) = v50;
    *(v49 + 8) = 0x3F7000003F800000;
    do
    {
      *(v49 + 16 + v46) = *(v14 + v46);
      ++v46;
    }

    while (v46 != 4);
    for (i = 0; i != 4; ++i)
    {
      *(v49 + 20 + i) = *(v16 + i);
    }

    *(a1 + 8) = *a2;
    result = a2[1];
    *(a1 + 12) = result;
  }

  return result;
}

void ggl::DebugConsole::drawLineStrip(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      *(a1 + 8) = *a2;
      v4 = *(a2 + 4);
      *(a1 + 12) = v4;
      if (a3 >= 2)
      {
        v5 = a3 - 1;
        v6 = (a2 + 8);
        do
        {
          v4 = ggl::DebugConsole::drawLine(a1, v6, v4);
          v6 += 2;
          --v5;
        }

        while (v5);
      }
    }
  }
}

float ggl::DebugConsole::drawRectangle(uint64_t a1, float *a2)
{
  v11 = *(a1 + 8);
  v4 = v11;
  *(a1 + 8) = *a2;
  v5 = a2[1];
  *(a1 + 12) = v5;
  v9 = *&v4;
  v10 = v5;
  v6 = ggl::DebugConsole::drawLine(a1, &v9, v5);
  ggl::DebugConsole::drawLine(a1, &v11, v6);
  v9 = *a2;
  v10 = *(&v4 + 1);
  v7 = ggl::DebugConsole::drawLine(a1, &v9, v9);

  return ggl::DebugConsole::drawLine(a1, a2, v7);
}

float ggl::DebugConsole::drawRectangleWithFill(float32x2_t *a1, float *a2, float result)
{
  v3 = a1[10];
  if ((*&v3 + 6) <= *&a1[6])
  {
    v4 = 0;
    v6 = *a2;
    v5 = a2[1];
    v8 = a1[1].f32[0];
    v7 = a1[1].f32[1];
    v9 = a1[13].u8[4];
    v10 = 0.99609;
    if (!a1[13].i8[4])
    {
      v10 = 0.98633;
    }

    v11 = a1[9];
    a1[10] = (*&v3 + 1);
    v12 = *(*&v11 + 40) + 24 * *&v3;
    *v12 = v8;
    *(v12 + 4) = a1[1].i32[1];
    *(v12 + 8) = 0;
    *(v12 + 12) = v10;
    v13 = a1 + 12;
    do
    {
      *(v12 + 16 + v4) = v13->i8[v4];
      ++v4;
    }

    while (v4 != 4);
    v14 = 0;
    v15 = &a1[12] + 4;
    v16 = v12 + 20;
    do
    {
      *(v16 + v14) = v15[v14];
      ++v14;
    }

    while (v14 != 4);
    v17 = 0;
    v18 = v9 == 0;
    v19 = a1[10];
    v20 = *(*&a1[9] + 40) + 24 * *&v19;
    v21 = v5 - v7;
    if (v18)
    {
      v22 = 0.99609;
    }

    else
    {
      v22 = 0.98633;
    }

    v23 = a1[1].i32[0];
    v24 = a1[1].f32[1] + v21;
    a1[10] = (*&v19 + 1);
    *v20 = v23;
    *(v20 + 4) = v24;
    *(v20 + 8) = 0;
    *(v20 + 12) = v22;
    do
    {
      *(v20 + 16 + v17) = v13->i8[v17];
      ++v17;
    }

    while (v17 != 4);
    v25 = 0;
    v26 = v20 + 20;
    do
    {
      *(v26 + v25) = v15[v25];
      ++v25;
    }

    while (v25 != 4);
    v27 = 0;
    v28 = a1[10];
    v29 = *(*&a1[9] + 40) + 24 * *&v28;
    v30.f32[0] = v6 - v8;
    v31 = a1[1].i32[1];
    v32 = a1[1].f32[0] + v30.f32[0];
    a1[10] = (*&v28 + 1);
    *v29 = v32;
    *(v29 + 4) = v31;
    *(v29 + 8) = 1065353216;
    *(v29 + 12) = v10;
    do
    {
      *(v29 + 16 + v27) = v13->i8[v27];
      ++v27;
    }

    while (v27 != 4);
    v33 = 0;
    v34 = v29 + 20;
    do
    {
      *(v34 + v33) = v15[v33];
      ++v33;
    }

    while (v33 != 4);
    v35 = 0;
    v36 = a1[10];
    v37 = *(*&a1[9] + 40) + 24 * *&v36;
    v38 = a1[1].i32[1];
    v39 = a1[1].f32[0] + v30.f32[0];
    a1[10] = (*&v36 + 1);
    *v37 = v39;
    *(v37 + 4) = v38;
    *(v37 + 8) = 1065353216;
    *(v37 + 12) = v10;
    do
    {
      *(v37 + 16 + v35) = v13->i8[v35];
      ++v35;
    }

    while (v35 != 4);
    v40 = 0;
    v41 = v37 + 20;
    do
    {
      *(v41 + v40) = v15[v40];
      ++v40;
    }

    while (v40 != 4);
    v42 = 0;
    v43 = a1[10];
    v44 = *(*&a1[9] + 40) + 24 * *&v43;
    v45 = a1[1].i32[0];
    v46 = a1[1].f32[1] + v21;
    a1[10] = (*&v43 + 1);
    *v44 = v45;
    *(v44 + 4) = v46;
    *(v44 + 8) = 0;
    *(v44 + 12) = v22;
    do
    {
      *(v44 + 16 + v42) = v13->i8[v42];
      ++v42;
    }

    while (v42 != 4);
    v47 = 0;
    v48 = v44 + 20;
    do
    {
      *(v48 + v47) = v15[v47];
      ++v47;
    }

    while (v47 != 4);
    v49 = 0;
    v50 = a1[10];
    v51 = (*(*&a1[9] + 40) + 24 * *&v50);
    a1[10] = (*&v50 + 1);
    v30.f32[1] = v21;
    *v51 = vadd_f32(a1[1], v30);
    v51[1].i32[0] = 1065353216;
    v51[1].f32[1] = v22;
    do
    {
      v51[2].i8[v49] = v13->i8[v49];
      ++v49;
    }

    while (v49 != 4);
    for (i = 0; i != 4; ++i)
    {
      v51[2].i8[i + 4] = v15[i];
    }

    a1[1].f32[0] = *a2;
    result = a2[1];
    a1[1].f32[1] = result;
  }

  return result;
}

uint64_t ggl::DebugConsole::drawRectangleWithTexture(uint64_t result, uint64_t a2, void *a3)
{
  v5 = *(result + 64);
  v6 = v5[11];
  if (!v6)
  {
    v6 = v5 + 9;
  }

  if (a2 && v6[1] == *v6)
  {
    v36 = v3;
    v37 = v4;
    v8 = result;
    **(v5[4] + 168) = a2;
    v9 = **(*(*(result + 64) + 64) + 64);
    v29 = 0;
    v30 = 0;
    v23 = 0;
    v24 = 0;
    v10 = 4 * *(v9 + 8);
    v31 = v9;
    v32 = 0;
    v33 = v10;
    v34 = 1;
    if (v10)
    {
      v11 = *(v9 + 72);
    }

    else
    {
      v11 = 0;
    }

    v35 = v11;
    ggl::BufferMemory::operator=(&v23, &v30);
    if (v35)
    {
      ggl::ResourceAccessor::_endAccess(v35, v30, v31, v32, v33, v34, HIBYTE(v34));
    }

    *&v12 = *a3;
    *&v13 = a3[1];
    *&v14 = *a3;
    *(&v14 + 1) = 0x3F80000000000000;
    __asm { FMOV            V2.2S, #1.0 }

    LODWORD(v20) = v13;
    *(&v20 + 1) = _D2;
    DWORD1(v20) = HIDWORD(*a3);
    DWORD1(v12) = DWORD1(v13);
    *(&v13 + 1) = 1065353216;
    v21 = v29;
    v29[2] = v13;
    v21[3] = v12;
    *v21 = v14;
    v21[1] = v20;
    v22 = *(v8 + 64);
    *(v22 + 72) = xmmword_1B33B1B60;
    *(v22 + 88) = 0;
    *(v22 + 96) = 1;
    return ggl::ResourceAccessor::_endAccess(v21, v23, v24, v25, v26, v27, v28);
  }

  return result;
}

void ggl::DebugConsole::drawCircle(ggl::DebugConsole *this, double a2)
{
  v3 = *(this + 8);
  v4 = vdup_lane_s32(*&a2, 0);
  *(this + 1) = vmla_n_f32(v3, **(this + 11), *&a2);
  for (i = 8; i != 256; i += 8)
  {
    v6 = *(*(this + 11) + i);
    v8 = vmla_f32(v3, v4, v6);
    ggl::DebugConsole::drawLine(this, &v8, v6.f32[0]);
  }

  v7 = **(this + 11);
  v8 = vmla_f32(v3, v4, v7);
  ggl::DebugConsole::drawLine(this, &v8, v7.f32[0]);
  *(this + 1) = v3;
}

uint64_t ggl::DebugConsole::drawCircleWithFill(uint64_t this, float a2)
{
  if ((*(this + 80) + 96) <= *(this + 48))
  {
    v2 = vmla_n_f32(*(this + 8), **(this + 88), a2);
    v3 = this + 96;
    v4 = this + 100;
    v5 = 1;
    v6 = v2;
    do
    {
      v7 = 0;
      v8 = *(this + 80);
      v9 = (*(this + 88) + 8 * v5);
      v11 = *v9;
      v10 = v9[1];
      v12 = *(this + 72);
      *(this + 80) = v8 + 1;
      v13 = *(this + 8);
      v14 = *(this + 12);
      v15 = *(v12 + 40) + 24 * v8;
      *v15 = v13;
      *(v15 + 4) = *(this + 12);
      *(v15 + 8) = 0x3F7C800000000000;
      do
      {
        *(v15 + 16 + v7) = *(v3 + v7);
        ++v7;
      }

      while (v7 != 4);
      v16 = 0;
      v17 = v11 * a2;
      v18 = v15 + 20;
      do
      {
        *(v18 + v16) = *(v4 + v16);
        ++v16;
      }

      while (v16 != 4);
      v19 = 0;
      v20 = v13 + v17;
      v21 = *(this + 72);
      v22 = *(this + 80);
      *(this + 80) = v22 + 1;
      v23 = (*(v21 + 40) + 24 * v22);
      *v23 = v6;
      v23[1] = 0x3F7C80003F800000;
      do
      {
        *(v23 + v19 + 16) = *(v3 + v19);
        ++v19;
      }

      while (v19 != 4);
      v24 = 0;
      v25 = v23 + 20;
      do
      {
        v25[v24] = *(v4 + v24);
        ++v24;
      }

      while (v24 != 4);
      v26 = 0;
      v27 = v14 + (v10 * a2);
      v28 = *(this + 72);
      v29 = *(this + 80);
      *(this + 80) = v29 + 1;
      v30 = *(v28 + 40) + 24 * v29;
      *v30 = v20;
      *(v30 + 4) = v27;
      *(v30 + 8) = 0x3F7F00003F800000;
      do
      {
        *(v30 + 16 + v26) = *(v3 + v26);
        ++v26;
      }

      while (v26 != 4);
      v31 = 0;
      v32 = v30 + 20;
      do
      {
        *(v32 + v31) = *(v4 + v31);
        ++v31;
      }

      while (v31 != 4);
      ++v5;
      v6 = __PAIR64__(LODWORD(v27), LODWORD(v20));
    }

    while (v5 != 32);
    v33 = 0;
    v34 = *(this + 72);
    v35 = *(this + 80);
    *(this + 80) = v35 + 1;
    v36 = *(v34 + 40) + 24 * v35;
    *v36 = *(this + 8);
    *(v36 + 4) = *(this + 12);
    *(v36 + 8) = 0x3F7C800000000000;
    do
    {
      *(v36 + 16 + v33) = *(v3 + v33);
      ++v33;
    }

    while (v33 != 4);
    v37 = 0;
    v38 = v36 + 20;
    do
    {
      *(v38 + v37) = *(v4 + v37);
      ++v37;
    }

    while (v37 != 4);
    v39 = 0;
    v40 = *(this + 72);
    v41 = *(this + 80);
    *(this + 80) = v41 + 1;
    v42 = *(v40 + 40) + 24 * v41;
    *v42 = v20;
    *(v42 + 4) = v27;
    *(v42 + 8) = 0x3F7C80003F800000;
    do
    {
      *(v42 + 16 + v39) = *(v3 + v39);
      ++v39;
    }

    while (v39 != 4);
    v43 = 0;
    v44 = v42 + 20;
    do
    {
      *(v44 + v43) = *(v4 + v43);
      ++v43;
    }

    while (v43 != 4);
    v45 = 0;
    v46 = *(this + 72);
    v47 = *(this + 80);
    *(this + 80) = v47 + 1;
    v48 = (*(v46 + 40) + 24 * v47);
    *v48 = v2;
    v48[1] = 0x3F7F00003F800000;
    do
    {
      v48[2].i8[v45] = *(v3 + v45);
      ++v45;
    }

    while (v45 != 4);
    for (i = 0; i != 4; ++i)
    {
      v48[2].i8[i + 4] = *(v4 + i);
    }
  }

  return this;
}

void ggl::MetalDeviceContext::optimizeForGPUAccess(ggl::MetalDeviceContext *this, const ggl::Texture *a2)
{
  v2 = *(this + 5);
  if (v2)
  {
    v3 = *(a2 + 3);
    v6 = ggl::MetalDeviceContextFrame::blitCommandEncoder(v2, 0, 1);
    v5 = ggl::MetalTextureResource::texture(v3, v4);
    [v6 optimizeContentsForGPUAccess:v5];
  }
}

void ggl::MetalDeviceContext::optimizeForCPUAccess(ggl::MetalDeviceContext *this, const ggl::Texture *a2)
{
  v2 = *(this + 5);
  if (v2)
  {
    v3 = *(a2 + 3);
    v6 = ggl::MetalDeviceContextFrame::blitCommandEncoder(v2, 0, 1);
    v5 = ggl::MetalTextureResource::texture(v3, v4);
    [v6 optimizeContentsForCPUAccess:v5];
  }
}

id GEOGetGeoGLMetalDeviceContextLog(void)
{
  if (GEOGetGeoGLMetalDeviceContextLog(void)::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoGLMetalDeviceContextLog(void)::onceToken, &__block_literal_global_50356);
  }

  v1 = GEOGetGeoGLMetalDeviceContextLog(void)::log;

  return v1;
}

__n128 __Block_byref_object_copy__50337(__n128 *a1, __n128 *a2)
{
  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__50338(uint64_t a1)
{
  v1 = *(a1 + 56);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }
}

void ___ZN3ggl18MetalDeviceContext8endFrameERKNS_14EndFrameParamsE_block_invoke(uint64_t a1, void *a2)
{
  v4 = a2;
  [v4 GPUStartTime];
  atomic_store(v3, *(*(*(a1 + 32) + 8) + 48));
}

void std::__shared_ptr_emplace<std::vector<std::function<void ()(NSError *)>,geo::allocator_adapter<std::function<void ()(NSError *)>,ggl::zone_mallocator>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C9B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<std::atomic<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5C978;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ___ZL32GEOGetGeoGLMetalDeviceContextLogv_block_invoke()
{
  v0 = os_log_create("com.apple.VectorKit.GeoGL", "MetalDeviceContext");
  v1 = GEOGetGeoGLMetalDeviceContextLog(void)::log;
  GEOGetGeoGLMetalDeviceContextLog(void)::log = v0;
}

void ggl::MetalDeviceContext::~MetalDeviceContext(ggl::MetalDeviceContext *this)
{
  ggl::MetalDeviceContext::~MetalDeviceContext(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5C8C8;
  v2 = 3;
  do
  {
    dispatch_semaphore_wait(*(this + 8), 0xFFFFFFFFFFFFFFFFLL);
    --v2;
  }

  while (v2);
  v3 = 3;
  do
  {
    dispatch_semaphore_signal(*(this + 8));
    --v3;
  }

  while (v3);
  v4 = *(this + 9);
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }

  v5 = *(this + 23);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::unique_ptr<ggl::ClearCache>::reset[abi:nn200100]((this + 168), 0);
  v6 = *(this + 20);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }

  v7 = *(this + 18);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  v10 = (this + 112);
  std::vector<std::vector<geo::handle<md::CommandBufferResource>>>::__destroy_vector::operator()[abi:nn200100](&v10);
  v8 = *(this + 11);
  if (v8)
  {
    *(this + 12) = v8;
    operator delete(v8);
  }

  std::unique_ptr<ggl::MetalDeviceContextPass>::reset[abi:nn200100](this + 6, 0);
  std::unique_ptr<ggl::MetalDeviceContextFrame>::reset[abi:nn200100](this + 5, 0);
  v9 = *(this + 4);
  *(this + 4) = 0;
  if (v9)
  {
    std::default_delete<ggl::RenderResourceFences>::operator()[abi:nn200100](v9);
  }

  std::unique_ptr<ggl::MetalBindingManager>::reset[abi:nn200100](this + 1, 0);
}

void std::default_delete<ggl::RenderResourceFences>::operator()[abi:nn200100](uint64_t a1)
{
  v2 = 48;
  while (1)
  {
    v3 = *(a1 + v2);
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v3);
    }

    v2 -= 16;
    if (!v2)
    {

      JUMPOUT(0x1B8C62190);
    }
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::shared_ptr<ggl::ConstantDataTyped<ggl::Clear::ClearConstants>>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::unique_ptr<ggl::Clear::ClearPipelineSetup>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void *ggl::CullingGridWithHeight::CullingGridWithHeight(void *this)
{
  v1 = 0;
  *this = 0;
  v2 = vdupq_n_s64(0xFuLL);
  do
  {
    v3 = vorrq_s8(vdupq_n_s64(v1), xmmword_1B33B0560);
    v4 = &this[v1];
    if (vmovn_s64(vcgtq_u64(v2, v3)).u8[0])
    {
      v4[1] = 0;
    }

    if (vmovn_s64(vcgtq_u64(vdupq_n_s64(0xFuLL), v3)).i32[1])
    {
      v4[2] = 0;
    }

    v1 += 2;
  }

  while (v1 != 16);
  return this;
}

uint64_t ggl::CullingGridWithHeight::increaseMaxHeightInCells(ggl::CullingGridWithHeight *this, int a2, float a3)
{
  v3 = 0;
  v4 = (this + 4);
  do
  {
    v5 = 0;
    v6 = 0;
    v7 = v4;
    do
    {
      result = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v5 & 2 | (v3 & 1)]);
      if (((result << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v6 & 2 | (v3 >> 1)]))) & a2) != 0)
      {
        *v7 = fmaxf(*v7, a3);
      }

      ++v6;
      v7 += 8;
      v5 += 2;
    }

    while (v6 != 4);
    ++v3;
    v4 += 2;
  }

  while (v3 != 4);
  return result;
}

uint64_t ggl::CullingGridWithHeight::intersectedCellsForView(uint64_t a1, uint64_t a2)
{
  v3 = 0;
  v4 = 0;
  v5 = (a1 + 4);
  do
  {
    v6 = 0;
    v7 = vcvts_n_f32_u32(v3, 2uLL);
    v49 = v3 >> 1;
    v8 = v3 & 1;
    v47 = v3 + 1;
    v48 = v5;
    v9 = vcvts_n_f32_u32((v3 + 1), 2uLL);
    v10 = 1;
    do
    {
      v12 = *(v5 - 1);
      v11 = *v5;
      v13 = vcvts_n_f32_u32((v10 - 1), 2uLL);
      *v64 = v7;
      *&v64[1] = v13;
      v64[2] = v12;
      v64[3] = 1065353216;
      v65[0] = gm::operator*<float,4,4,1>(a2, v64);
      v65[1] = v14;
      v65[2] = v15;
      v65[3] = v16;
      v17 = ggl::CullingGrid::clipFlagsForClipPoint(v65);
      *v62 = v9;
      *&v62[1] = v13;
      v62[2] = v12;
      v62[3] = 1065353216;
      v63[0] = gm::operator*<float,4,4,1>(a2, v62);
      v63[1] = v18;
      v63[2] = v19;
      v63[3] = v20;
      v21 = vcvts_n_f32_u32(v10, 2uLL);
      v22 = ggl::CullingGrid::clipFlagsForClipPoint(v63) & v17;
      *v60 = v9;
      *&v60[1] = v21;
      v60[2] = v12;
      v60[3] = 1065353216;
      v61[0] = gm::operator*<float,4,4,1>(a2, v60);
      v61[1] = v23;
      v61[2] = v24;
      v61[3] = v25;
      v26 = ggl::CullingGrid::clipFlagsForClipPoint(v61);
      *v58 = v7;
      *&v58[1] = v21;
      v58[2] = v12;
      v58[3] = 1065353216;
      v59[0] = gm::operator*<float,4,4,1>(a2, v58);
      v59[1] = v27;
      v59[2] = v28;
      v59[3] = v29;
      v30 = v22 & v26 & ggl::CullingGrid::clipFlagsForClipPoint(v59);
      *v56 = v7;
      *&v56[1] = v13;
      v56[2] = v11;
      v56[3] = 1065353216;
      v57[0] = gm::operator*<float,4,4,1>(a2, v56);
      v57[1] = v31;
      v57[2] = v32;
      v57[3] = v33;
      v34 = ggl::CullingGrid::clipFlagsForClipPoint(v57);
      *v54 = v9;
      *&v54[1] = v13;
      v54[2] = v11;
      v54[3] = 1065353216;
      v55[0] = gm::operator*<float,4,4,1>(a2, v54);
      v55[1] = v35;
      v55[2] = v36;
      v55[3] = v37;
      v38 = v34 & ggl::CullingGrid::clipFlagsForClipPoint(v55);
      *v52 = v9;
      *&v52[1] = v21;
      v52[2] = v11;
      v52[3] = 1065353216;
      v53[0] = gm::operator*<float,4,4,1>(a2, v52);
      v53[1] = v39;
      v53[2] = v40;
      v53[3] = v41;
      v42 = v30 & v38 & ggl::CullingGrid::clipFlagsForClipPoint(v53);
      *v50 = v7;
      *&v50[1] = v21;
      v50[2] = v11;
      v50[3] = 1065353216;
      v51[0] = gm::operator*<float,4,4,1>(a2, v50);
      v51[1] = v43;
      v51[2] = v44;
      v51[3] = v45;
      if ((v42 & ggl::CullingGrid::clipFlagsForClipPoint(v51)) == 0)
      {
        v4 = (1 << ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[v6 & 2 | v8] << (4 * LOBYTE(ggl::CullingGrid::bitForCell(unsigned char,unsigned char)::clockwiseOrder[(v10 - 1) & 2 | v49]))) | v4;
      }

      v6 += 2;
      ++v10;
      v5 += 8;
    }

    while (v6 != 8);
    v3 = v47;
    v5 = v48 + 2;
  }

  while (v47 != 4);
  return v4;
}

os_log_t __GEOGetGeoGLPerformanceLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoGL", "Performance");
  GEOGetGeoGLPerformanceLog_log = result;
  return result;
}

ggl::zone_mallocator *ggl::Data::operator=(ggl::zone_mallocator *a1, uint64_t a2)
{
  v4 = *(a1 + 1);
  if (v4)
  {
    v5 = ggl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v5, v4);
    *(a1 + 1) = 0;
  }

  if (*(a2 + 8))
  {
    v6 = *(a2 + 16);
    v7 = ggl::zone_mallocator::instance(a1);
    v8 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v7, v6);
    *(a1 + 1) = v8;
    v9 = *(a2 + 8);
    v10 = *(a2 + 16);
    *(a1 + 2) = v10;
    memcpy(v8, v9, v10);
  }

  return a1;
}

uint64_t std::__function::__func<ggl::AlphaAtlas::AlphaAtlas(unsigned int,BOOL,float,float,ggl::Device *)::$_0,std::allocator<ggl::AlphaAtlas::AlphaAtlas(unsigned int,BOOL,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5CAB8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ggl::IsoAlphaAtlas::IsoAlphaAtlas(unsigned int,float,float,ggl::Device *)::$_0,std::allocator<ggl::IsoAlphaAtlas::IsoAlphaAtlas(unsigned int,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5CB00;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5CB48;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void non-virtual thunk toggl::Texture::~Texture(ggl::Texture *this)
{
  ggl::RenderDataHolder::~RenderDataHolder((this - 40));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::RenderDataHolder::~RenderDataHolder((this - 40));
}

void ggl::Texture::~Texture(ggl::Texture *this)
{
  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::Clear::ClearPipelineState::~ClearPipelineState(ggl::Clear::ClearPipelineState *this)
{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF68;
  v2 = *(this + 7);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

void ggl::Clear::ClearPipelineSetup::~ClearPipelineSetup(std::__shared_weak_count *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);

  JUMPOUT(0x1B8C62190);
}

void *ggl::Clear::ClearPipelineSetup::ClearPipelineSetup(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(a1, a2, a3);
    std::__shared_weak_count::__release_shared[abi:nn200100](a3);
  }

  else
  {
    ggl::PipelineSetup::PipelineSetup(a1, a2, 0);
  }

  *a1 = &unk_1F2A5CBF0;
  v7 = a1[17];
  v8 = *a4;
  v9 = a4[1];
  *v7 = *a4;
  v7[1] = 0;
  v10 = a1[29];
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
  }

  v11 = v10[1];
  *v10 = v8;
  v10[1] = v9;
  if (v11)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v11);
  }

  return a1;
}

void ggl::CommonLibrary::~CommonLibrary(ggl::CommonLibrary *this)
{
  ggl::ShaderLibrary::~ShaderLibrary(this);

  JUMPOUT(0x1B8C62190);
}

void *ggl::CommonLibrary::clearShader(void *this, uint64_t a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  if (a3)
  {
    atomic_fetch_add_explicit((a3 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

void ggl::CommonLibraryMTLData::~CommonLibraryMTLData(ggl::CommonLibraryMTLData *this)
{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);
  ggl::ShaderLibraryData::~ShaderLibraryData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);

  ggl::ShaderLibraryData::~ShaderLibraryData(this);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::MetalResource *>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::vector<NSObject  {objcproto10MTLTexture}* {__strong},geo::allocator_adapter<NSObject  {objcproto10MTLTexture}* {__strong},ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](ggl::zone_mallocator *a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v3 = v1[1];
    v4 = **a1;
    if (v3 != v2)
    {
      do
      {
        v6 = *(v3 - 1);
        v3 -= 8;
      }

      while (v3 != v2);
      v4 = **a1;
    }

    v1[1] = v2;
    v7 = ggl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<NSObject  {objcproto10MTLTexture}* {__strong}>(v7, v4);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<NSObject  {objcproto10MTLTexture}* {__strong}>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void ggl::MetalResourceManager::~MetalResourceManager(dispatch_queue_t *this)
{
  ggl::MetalResourceManager::~MetalResourceManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CCB8;
  dispatch_barrier_sync(this[34], &__block_literal_global_50480);
  v2 = this[34];
  this[34] = 0;

  v4 = this[35];
  if (v4 != this[36])
  {
    do
    {
      ggl::MetalResourceManager::deleteResource(this, *v4);
      v5 = this[36];
      v6 = v5 - (v4 + 1);
      if (v5 != v4 + 1)
      {
        v3 = memmove(v4, v4 + 1, v5 - (v4 + 1));
      }

      this[36] = (v4 + v6);
    }

    while (v4 != (v4 + v6));
    v4 = this[35];
  }

  if (v4)
  {
    this[36] = v4;
    v7 = ggl::zone_mallocator::instance(v3);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::MetalResource *>(v7, v4);
  }

  ggl::ResourceManager::~ResourceManager(this);
}

void ggl::MetalResourceManager::newRasterizationRateMap(uint64_t a1, void *a2)
{
  v50 = a1;
  v54 = *MEMORY[0x1E69E9840];
  v3 = objc_alloc_init(MEMORY[0x1E6974120]);
  v4 = *(a2 + 36);
  *&v5 = v4;
  *(&v5 + 1) = HIDWORD(v4);
  *v52 = v5;
  v53 = 0;
  v51 = v3;
  [v3 setScreenSize:v52];
  v6 = a2[6];
  if (a2[7] != v6)
  {
    v7 = 0;
    do
    {
      v8 = (v6 + (v7 << 6));
      v10 = v8[4];
      v9 = v8[5];
      v12 = *v8;
      v11 = v8[1];
      v13 = objc_alloc(MEMORY[0x1E6974118]);
      v14 = (v9 - v10) >> 2;
      v15 = (v11 - v12) >> 2;
      v52[0] = v14;
      v52[1] = v15;
      v53 = 1;
      v16 = [v13 initWithSampleCount:v52];
      if (v11 != v12)
      {
        v17 = 0;
        if (v15 <= 1)
        {
          v18 = 1;
        }

        else
        {
          v18 = v15;
        }

        do
        {
          v19 = *(*v8 + 4 * v17);
          *([v16 verticalSampleStorage] + 4 * v17++) = v19;
        }

        while (v18 != v17);
      }

      if (v9 != v10)
      {
        v20 = 0;
        if (v14 <= 1)
        {
          v14 = 1;
        }

        do
        {
          v21 = *(v8[4] + 4 * v20);
          *([v16 horizontalSampleStorage] + 4 * v20++) = v21;
        }

        while (v14 != v20);
      }

      [v51 setLayer:v16 atIndex:{v7, v50}];

      ++v7;
      v6 = a2[6];
    }

    while (v7 < (a2[7] - v6) >> 6);
  }

  v22 = [*(*(v50 + 256) + 104) newRasterizationRateMapWithDescriptor:{v51, v50}];
  v23 = ggl::zone_mallocator::instance(v22);
  v24 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v23, 0x28uLL);
  *v24 = 0;
  v24[4] = 2305;
  *(v24 + 3) = 0;
  *(v24 + 4) = 0;
  *(v24 + 2) = 0;
  v25 = [(ggl::zone_mallocator *)v22 layerCount];
  v52[0] = 0;
  v52[1] = 0;
  v53 = 0;
  if (v25)
  {
    std::vector<gm::Size2<unsigned int>,geo::allocator_adapter<gm::Size2<unsigned int>,ggl::zone_mallocator>>::__vallocate[abi:nn200100](v52, v25);
    v26 = v52[1];
    bzero(v52[1], 8 * v25);
    v28 = &v26[8 * v25];
    v52[1] = v28;
    v29 = v52[0];
    v30 = v28 - v52[0];
    if (v28 != v52[0])
    {
      v31 = 0;
      v32 = v52[0];
      v33 = v52[1];
      do
      {
        if (v22)
        {
          v27 = [(ggl::zone_mallocator *)v22 physicalSizeForLayer:v31];
          v34 = vmovn_s64(0);
          v29 = v32;
          v28 = v33;
        }

        else
        {
          v34 = 0;
        }

        *&v29[8 * v31++] = v34;
        v30 = v28 - v29;
      }

      while (v31 < (v28 - v29) >> 3);
    }

    v35 = v30 >> 3;
    v36 = a2[10];
    v37 = a2[12];
    if (v35 > (v37 - v36) >> 3)
    {
      if (v36)
      {
        a2[11] = v36;
        v38 = ggl::zone_mallocator::instance(v27);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Size2<unsigned int>>(v38, v36);
        v37 = 0;
        a2[10] = 0;
        a2[11] = 0;
        a2[12] = 0;
      }

      if (v35 >> 61)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v39 = v37 >> 2;
      if (v37 >> 2 <= v35)
      {
        v39 = v35;
      }

      if (v37 >= 0x7FFFFFFFFFFFFFF8)
      {
        v40 = 0x1FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v40 = v39;
      }

      std::vector<gm::Size2<unsigned int>,geo::allocator_adapter<gm::Size2<unsigned int>,ggl::zone_mallocator>>::__vallocate[abi:nn200100]((a2 + 10), v40);
      v41 = a2[11];
      while (v29 != v28)
      {
        v42 = *v29;
        v29 += 8;
        *v41++ = v42;
      }

      a2[11] = v41;
      goto LABEL_44;
    }

    v43 = (a2 + 11);
    v44 = a2[11];
    v45 = v44 - v36;
    if (v35 > (v44 - v36) >> 3)
    {
      v46 = &v29[v45];
      if (v44 != v36)
      {
        do
        {
          v47 = *v29;
          v29 += 8;
          *v36 = v47;
          v36 += 8;
          v45 -= 8;
        }

        while (v45);
      }

      while (v46 != v28)
      {
        v49 = *v46;
        v46 += 8;
        *v44 = v49;
        v44 += 8;
      }

      *v43 = v44;
LABEL_44:
      [(ggl::zone_mallocator *)v22 parameterBufferSizeAndAlign];
      operator new();
    }

    while (v29 != v28)
    {
      v48 = *v29;
      v29 += 8;
      *v36 = v48;
      v36 += 8;
    }
  }

  else
  {
    v36 = a2[10];
    v43 = (a2 + 11);
  }

  *v43 = v36;
  goto LABEL_44;
}

void sub_1B330E2CC(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::vector<gm::Size2<unsigned int>,geo::allocator_adapter<gm::Size2<unsigned int>,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](va);

  _Unwind_Resume(a1);
}

void std::vector<gm::Size2<unsigned int>,geo::allocator_adapter<gm::Size2<unsigned int>,ggl::zone_mallocator>>::__vallocate[abi:nn200100](ggl::zone_mallocator *a1, unint64_t a2)
{
  if (a2 >> 61)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v4 = ggl::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v4 + 32));
  v5 = malloc_type_zone_malloc(*v4, 8 * a2, 0x100004000313F17uLL);
  atomic_fetch_add((v4 + 24), 1u);
  geo::read_write_lock::unlock((v4 + 32));
  *a1 = v5;
  *(a1 + 1) = v5;
  *(a1 + 2) = &v5[8 * a2];
}

void std::vector<gm::Size2<unsigned int>,geo::allocator_adapter<gm::Size2<unsigned int>,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](ggl::zone_mallocator *a1)
{
  v1 = *a1;
  if (*a1)
  {
    *(a1 + 1) = v1;
    v2 = ggl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Size2<unsigned int>>(v2, v1);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Size2<unsigned int>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void ggl::ResourceManager::onRenderDataReleased(uint64_t a1, uint64_t a2)
{
  std::mutex::lock((a1 + 88));
  v6 = *(a1 + 32);
  v5 = *(a1 + 40);
  if (v6 >= v5)
  {
    v8 = *(a1 + 24);
    v9 = (v6 - v8) >> 3;
    if ((v9 + 1) >> 61)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (v9 + 1))
    {
      v11 = v9 + 1;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFF8)
    {
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v11;
    }

    if (v12)
    {
      v13 = ggl::zone_mallocator::instance(v4);
      geo::read_write_lock::read_lock((v13 + 32));
      v14 = malloc_type_zone_malloc(*v13, 8 * v12, 0x2004093837F09uLL);
      atomic_fetch_add((v13 + 24), 1u);
      geo::read_write_lock::unlock((v13 + 32));
    }

    else
    {
      v14 = 0;
    }

    v15 = &v14[8 * v9];
    v16 = &v14[8 * v12];
    *v15 = a2;
    v7 = v15 + 8;
    v17 = *(a1 + 24);
    v18 = *(a1 + 32) - v17;
    v19 = &v15[-v18];
    v20 = memcpy(&v15[-v18], v17, v18);
    v21 = *(a1 + 24);
    *(a1 + 24) = v19;
    *(a1 + 32) = v7;
    *(a1 + 40) = v16;
    if (v21)
    {
      v22 = ggl::zone_mallocator::instance(v20);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v22, v21);
    }
  }

  else
  {
    *v6 = a2;
    v7 = v6 + 1;
  }

  *(a1 + 32) = v7;

  std::mutex::unlock((a1 + 88));
}

void ggl::ResourceManager::~ResourceManager(ggl::ResourceManager *this)
{
  ggl::ResourceManager::~ResourceManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CD38;
  std::mutex::~mutex(this + 3);
  v2 = *(this + 21);
  if (v2)
  {
    do
    {
      v3 = *v2;
      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }

  v4 = *(this + 19);
  *(this + 19) = 0;
  if (v4)
  {
    operator delete(v4);
  }

  std::mutex::~mutex((this + 88));
  std::vector<ggl::ShaderLibrary::ComputeShaderEntry,geo::allocator_adapter<ggl::ShaderLibrary::ComputeShaderEntry,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 56));
  std::vector<ggl::ShaderLibrary::ComputeShaderEntry,geo::allocator_adapter<ggl::ShaderLibrary::ComputeShaderEntry,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 24));
  v5 = *(this + 2);
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void non-virtual thunk toggl::Clear::ClearMesh::~ClearMesh(ggl::Clear::ClearMesh *this)
{
  ggl::Mesh::~Mesh((this - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((this - 16));
}

void ggl::Clear::ClearMesh::~ClearMesh(ggl::Clear::ClearMesh *this)
{
  ggl::Mesh::~Mesh(this);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::MeshTyped<ggl::Clear::ClearData>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((a1 - 16));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::Mesh::~Mesh((a1 - 16));
}

void ggl::MeshTyped<ggl::Clear::ClearData>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);

  JUMPOUT(0x1B8C62190);
}

void sub_1B330E86C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::__shared_weak_count::__release_shared[abi:nn200100](v10);

  _Unwind_Resume(a1);
}

void ggl::DisplayLink::~DisplayLink(id *this)
{
  ggl::DisplayLink::~DisplayLink(this);

  JUMPOUT(0x1B8C62190);
}

{

  v2 = this[8];
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }

  ggl::RunLoop::~RunLoop(this);
}

void ggl::RunLoop::~RunLoop(ggl::RunLoop *this)
{
  *this = &unk_1F2A5CDE0;
  v2 = *(this + 6);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  std::__function::__value_func<void ()(double)>::~__value_func[abi:nn200100](this + 8);
}

uint64_t ggl::SnapshotRunLoop::onTimerFired(uint64_t this, double a2)
{
  *(this + 64) = 1;
  if (*(this + 65) == 1)
  {
    return std::function<void ()(double)>::operator()(*(this + 32), a2);
  }

  return this;
}

void ggl::SnapshotRunLoop::setPaused(ggl::SnapshotRunLoop *this, char a2)
{
  *(this + 64) = a2;
  if ((a2 & 1) == 0)
  {
    v4 = *(this + 5);
    v3 = *(this + 6);
    if (v3)
    {
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }

    v5 = *(this + 66);
    *(this + 66) = 1;
    if (v5)
    {
      v6 = 10000000;
    }

    else
    {
      v6 = 0;
    }

    v7 = dispatch_time(0, v6);
    v8 = *(this + 7);
    v9[0] = MEMORY[0x1E69E9820];
    v9[1] = 3321888768;
    v9[2] = ___ZN3ggl15SnapshotRunLoop9setPausedEb_block_invoke;
    v9[3] = &__block_descriptor_48_ea8_32c57_ZTSNSt3__18weak_ptrIN3ggl7RunLoop18_RunLoopCallbackerEEE_e5_v8__0l;
    v9[4] = v4;
    v10 = v3;
    if (v3)
    {
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }

    dispatch_after(v7, v8, v9);
    if (v10)
    {
      std::__shared_weak_count::__release_weak(v10);
    }

    if (v3)
    {
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ___ZN3ggl15SnapshotRunLoop9setPausedEb_block_invoke(uint64_t a1)
{
  v2 = *(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(a1 + 32);
      if (v5)
      {
        v6 = CACurrentMediaTime();
        (*(**v5 + 40))(v6);
        (*(**v5 + 24))();
      }

      std::__shared_weak_count::__release_shared[abi:nn200100](v4);
    }
  }
}

void __destroy_helper_block_ea8_32c57_ZTSNSt3__18weak_ptrIN3ggl7RunLoop18_RunLoopCallbackerEEE(uint64_t a1)
{
  v1 = *(a1 + 40);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c57_ZTSNSt3__18weak_ptrIN3ggl7RunLoop18_RunLoopCallbackerEEE(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 40);
  *(result + 32) = *(a2 + 32);
  *(result + 40) = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 16), 1uLL, memory_order_relaxed);
  }

  return result;
}

void ggl::SnapshotRunLoop::~SnapshotRunLoop(ggl::SnapshotRunLoop *this)
{
  *this = &unk_1F2A5CE60;
  *(this + 32) = 1;

  ggl::RunLoop::~RunLoop(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CE60;
  *(this + 32) = 1;

  ggl::RunLoop::~RunLoop(this);
}

void std::__shared_ptr_emplace<ggl::RunLoop::_RunLoopCallbacker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5CED0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::SnapshotRunLoop::SnapshotRunLoop(void *a1, uint64_t a2, void *a3)
{
  v7 = *MEMORY[0x1E69E9840];
  v5 = a3;
  std::__function::__value_func<void ()(double)>::__value_func[abi:nn200100](v6, a2);
  ggl::RunLoop::RunLoop(a1, v6);
}

void sub_1B330EE14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(double)>::~__value_func[abi:nn200100](va);

  _Unwind_Resume(a1);
}

void ggl::MTLShaderLibraryData::~MTLShaderLibraryData(ggl::MTLShaderLibraryData *this)
{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);
  ggl::ShaderLibraryData::~ShaderLibraryData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);

  ggl::ShaderLibraryData::~ShaderLibraryData(this);
}

void std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](ggl::zone_mallocator *a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v3 = v1[1];
    v4 = **a1;
    if (v3 != v2)
    {
      do
      {
        v6 = *(v3 - 1);
        v3 -= 3;
        if (v6 < 0)
        {
          operator delete(*v3);
        }
      }

      while (v3 != v2);
      v4 = **a1;
    }

    v1[1] = v2;
    v7 = ggl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::string>(v7, v4);
  }
}

void ggl::ShaderLibraryData::~ShaderLibraryData(ggl::ShaderLibraryData *this)
{
  *this = &unk_1F2A5CF08;
  v2 = *(this + 3);
  if (v2)
  {
    *(this + 4) = v2;
    v3 = ggl::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v3, v2);
  }

  v4 = *(this + 2);
  *(this + 2) = 0;
  if (v4)
  {
    (*(*v4 + 8))(v4);
  }
}

{
  ggl::ShaderLibraryData::~ShaderLibraryData(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::MTLBundleShaderLibraryData::~MTLBundleShaderLibraryData(ggl::MTLBundleShaderLibraryData *this)
{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);
  ggl::ShaderLibraryData::~ShaderLibraryData(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);

  ggl::ShaderLibraryData::~ShaderLibraryData(this);
}

{
  *this = &unk_1F2A5CF28;
  v2 = this + 56;
  std::vector<std::string,geo::allocator_adapter<std::string,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v2);

  ggl::ShaderLibraryData::~ShaderLibraryData(this);
}

void ggl::DeviceData::~DeviceData(std::mutex *this)
{
  ggl::BufferData::~BufferData(this);

  JUMPOUT(0x1B8C62190);
}

void *ggl::DeviceData::DeviceData(void *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, uint64_t a6, int a7)
{
  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::BufferData::BufferData(a1, a2, v10, a5, a6, a7);
    std::__shared_weak_count::__release_shared[abi:nn200100](a4);
  }

  else
  {
    ggl::BufferData::BufferData(a1, a2, v10, a5, a6, a7);
  }

  *a1 = &unk_1F2A5CF88;
  return a1;
}

void ggl::MetalSwapchain::~MetalSwapchain(ggl::MetalSwapchain *this)
{
  ggl::MetalSwapchain::~MetalSwapchain(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5CFA8;
  v4 = (this + 40);
  std::vector<std::shared_ptr<md::MuninRoadLabel>>::__destroy_vector::operator()[abi:nn200100](&v4);
  v2 = *(this + 4);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 2);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }
}

void ___ZL28GEOGetGeoGLMetalSwapchainLogv_block_invoke_50723()
{
  v0 = os_log_create("com.apple.VectorKit.GeoGL", "MetalSwapchain");
  v1 = GEOGetGeoGLMetalSwapchainLog(void)::log;
  GEOGetGeoGLMetalSwapchainLog(void)::log = v0;
}

void std::__shared_ptr_emplace<ggl::MetalSwapchainDrawableRef>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D040;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<ggl::MetalSwapchainDrawable>::__on_zero_shared(uint64_t a1)
{
  v2 = *(a1 + 144);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(a1 + 128);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  v4 = *(a1 + 112);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  v5 = *(a1 + 96);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  std::mutex::~mutex((a1 + 24));
}

void std::__shared_ptr_emplace<ggl::MetalSwapchainDrawable>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D008;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::vector<std::shared_ptr<ggl::MetalSwapchainDrawable>>::resize(uint64_t *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      v11 = v3 + 16 * a2;
      while (v4 != v11)
      {
        v12 = *(v4 - 8);
        if (v12)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v12);
        }

        v4 -= 16;
      }

      a1[1] = v11;
    }
  }

  else
  {
    v6 = a2 - v5;
    v7 = a1[2];
    if (v6 > (v7 - v4) >> 4)
    {
      if (!(a2 >> 60))
      {
        v8 = v7 - v3;
        v9 = v8 >> 3;
        if (v8 >> 3 <= a2)
        {
          v9 = a2;
        }

        if (v8 >= 0x7FFFFFFFFFFFFFF0)
        {
          v10 = 0xFFFFFFFFFFFFFFFLL;
        }

        else
        {
          v10 = v9;
        }

        if (!(v10 >> 60))
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    bzero(a1[1], 16 * v6);
    a1[1] = v4 + 16 * v6;
  }
}

uint64_t ggl::MetalSwapchain::format(ggl::MetalSwapchain *this, uint64_t a2)
{
  if (a2)
  {
    return 0;
  }

  else
  {
    return *(this + 16);
  }
}

uint64_t std::__function::__func<std::__bind<void (ggl::Texture2DArray::*)(ggl::Texture2DLoadItem const&),ggl::Texture2DArray*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2DArray::*)(ggl::Texture2DLoadItem const&),ggl::Texture2DArray*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::operator()(void *a1)
{
  v1 = a1[2];
  v2 = a1[1];
  v3 = (a1[3] + (v1 >> 1));
  if (v1)
  {
    return (*(*v3 + v2))();
  }

  else
  {
    return v2(v3);
  }
}

__n128 std::__function::__func<std::__bind<void (ggl::Texture2DArray::*)(ggl::Texture2DLoadItem const&),ggl::Texture2DArray*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2DArray::*)(ggl::Texture2DLoadItem const&),ggl::Texture2DArray*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5D078;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void ggl::Texture2DArray::onImplicitLoadComplete(uint64_t a1, uint64_t a2)
{
  if (*(a2 + 24))
  {
    v3 = *(a2 + 20);
    *(a1 + 129) = 0;
    v4 = (*(a1 + 96) + 16 * v3);
    v5 = v4[1];
    *v4 = 0;
    v4[1] = 0;
    if (v5)
    {

      std::__shared_weak_count::__release_shared[abi:nn200100](v5);
    }
  }

  else
  {
    v6 = std::__throw_bad_optional_access[abi:nn200100]();
    std::__shared_ptr_emplace<ggl::RenderFence>::~__shared_ptr_emplace(v6);
  }
}

void std::__shared_ptr_emplace<ggl::RenderFence>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D0C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::CommandBuffer::~CommandBuffer(ggl::CommandBuffer *this)
{
  ggl::CommandBuffer::~CommandBuffer(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5D138;
  v2 = *(this + 3);
  if (v2)
  {
    v4 = *(v2 + 104);
    v3 = *(v2 + 112);
    if (v3 != v4)
    {
      v5 = 0;
      do
      {
        if (*(v4 + 8 * v5) == this)
        {
          *(v4 + 8 * v5) = 0;
          v4 = *(v2 + 104);
          v3 = *(v2 + 112);
        }

        ++v5;
      }

      while (v5 < (v3 - v4) >> 3);
    }
  }

  v6 = *(this + 40);
  v7 = *(this + 41);
  if (v7 != v6)
  {
    v8 = *(this + 43);
    v9 = &v6[v8 >> 7];
    v10 = *v9;
    v11 = *v9 + 32 * (v8 & 0x7F);
    v12 = *(v6 + (((*(this + 44) + v8) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((*(this + 44) + v8) & 0x7F);
    if (v11 != v12)
    {
      do
      {
        v13 = *(v11 + 16);
        if (v13)
        {
          *(v13 + 136) = 2;
          v14 = *(v13 + 120);
          if (v14)
          {
            v15 = *(v14 + 24);
            *(v14 + 16) = 0;
            *(v14 + 24) = 0;
            if (v15)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v15);
            }

            *(v13 + 120) = 0;
            v10 = *v9;
          }
        }

        v11 += 32;
        if (v11 - v10 == 4096)
        {
          v16 = v9[1];
          ++v9;
          v10 = v16;
          v11 = v16;
        }
      }

      while (v11 != v12);
      v6 = *(this + 40);
      v7 = *(this + 41);
    }
  }

  if (v7 == v6)
  {
    v21 = (this + 352);
  }

  else
  {
    v17 = *(this + 43);
    v18 = &v6[v17 >> 7];
    v19 = *v18;
    v20 = *v18 + 32 * (v17 & 0x7F);
    v21 = (this + 352);
    v22 = *(v6 + (((*(this + 44) + v17) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((*(this + 44) + v17) & 0x7F);
    if (v20 != v22)
    {
      do
      {
        v23 = *(v20 + 24);
        if (v23)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v23);
          v19 = *v18;
        }

        v20 += 32;
        if (v20 - v19 == 4096)
        {
          v24 = v18[1];
          ++v18;
          v19 = v24;
          v20 = v24;
        }
      }

      while (v20 != v22);
      v6 = *(this + 40);
      v7 = *(this + 41);
    }
  }

  *v21 = 0;
  v25 = v7 - v6;
  if (v25 >= 3)
  {
    do
    {
      operator delete(*v6);
      v7 = *(this + 41);
      v6 = (*(this + 40) + 8);
      *(this + 40) = v6;
      v25 = v7 - v6;
    }

    while (v25 > 2);
  }

  if (v25 == 1)
  {
    v26 = 64;
    goto LABEL_33;
  }

  if (v25 == 2)
  {
    v26 = 128;
LABEL_33:
    *(this + 43) = v26;
  }

  if (v6 != v7)
  {
    do
    {
      v27 = *v6++;
      operator delete(v27);
    }

    while (v6 != v7);
    v29 = *(this + 40);
    v28 = *(this + 41);
    if (v28 != v29)
    {
      *(this + 41) = v28 + ((v29 - v28 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }

  v30 = *(this + 39);
  if (v30)
  {
    operator delete(v30);
  }

  v32 = *(this + 34);
  v31 = *(this + 35);
  if (v31 == v32)
  {
    v37 = (this + 304);
    v41 = *(this + 34);
  }

  else
  {
    v33 = *(this + 37);
    v34 = &v32[v33 >> 8];
    v35 = *v34;
    v36 = *v34 + 16 * v33;
    v37 = (this + 304);
    v38 = *(v32 + (((*(this + 38) + v33) >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * (*(this + 304) + v33);
    if (v36 != v38)
    {
      do
      {
        v39 = *(v36 + 8);
        if (v39)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v39);
          v35 = *v34;
        }

        v36 += 16;
        if (v36 - v35 == 4096)
        {
          v40 = v34[1];
          ++v34;
          v35 = v40;
          v36 = v40;
        }
      }

      while (v36 != v38);
      v32 = *(this + 34);
      v31 = *(this + 35);
    }

    v41 = v31;
  }

  *v37 = 0;
  v42 = v41 - v32;
  if (v42 >= 3)
  {
    do
    {
      operator delete(*v32);
      v31 = *(this + 35);
      v32 = (*(this + 34) + 8);
      *(this + 34) = v32;
      v42 = v31 - v32;
    }

    while (v42 > 2);
    v41 = v31;
  }

  if (v42 == 1)
  {
    v43 = 128;
  }

  else
  {
    if (v42 != 2)
    {
      goto LABEL_58;
    }

    v43 = 256;
  }

  *(this + 37) = v43;
LABEL_58:
  if (v32 != v41)
  {
    do
    {
      v44 = *v32++;
      operator delete(v44);
    }

    while (v32 != v41);
    v41 = *(this + 34);
    v31 = *(this + 35);
  }

  if (v31 != v41)
  {
    *(this + 35) = v31 + ((v41 - v31 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  v45 = *(this + 33);
  if (v45)
  {
    operator delete(v45);
  }

  v56 = this + 232;
  std::vector<ggl::BufferLoadItem,geo::allocator_adapter<ggl::BufferLoadItem,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v56);
  v56 = this + 200;
  std::vector<ggl::Texture2DLoadItem,geo::allocator_adapter<ggl::Texture2DLoadItem,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v56);
  v47 = *(this + 21);
  if (v47)
  {
    *(this + 22) = v47;
    v48 = ggl::zone_mallocator::instance(v46);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::CopyItem>(v48, v47);
  }

  v49 = *(this + 17);
  if (v49)
  {
    *(this + 18) = v49;
    v50 = ggl::zone_mallocator::instance(v46);
    geo::read_write_lock::read_lock((v50 + 32));
    atomic_fetch_add((v50 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v50, v49);
    geo::read_write_lock::unlock((v50 + 32));
  }

  v51 = *(this + 13);
  if (v51)
  {
    *(this + 14) = v51;
    v52 = ggl::zone_mallocator::instance(v46);
    geo::read_write_lock::read_lock((v52 + 32));
    atomic_fetch_add((v52 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v52, v51);
    geo::read_write_lock::unlock((v52 + 32));
  }

  std::vector<ggl::RenderItem *,geo::allocator_adapter<ggl::RenderItem *,ggl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 72));
  v54 = *(this + 5);
  if (v54)
  {
    *(this + 6) = v54;
    v55 = ggl::zone_mallocator::instance(v53);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::MPSItem *>(v55, v54);
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **>(uint64_t *a1, uint64_t *a2)
{
  v2 = a2 - a1;
  if (v2 > 2)
  {
    if (v2 == 3)
    {
      v5 = *a1;
      v6 = a1[1];
      v7 = *(v6 + 48);
      v8 = *(*a1 + 48);
      v9 = *(a2 - 1);
      v10 = *(v9 + 48);
      if (v7 >= v8)
      {
        if (v10 < v7)
        {
          a1[1] = v9;
          *(a2 - 1) = v6;
          v32 = *a1;
          v31 = a1[1];
          if (*(v31 + 48) < *(*a1 + 48))
          {
            *a1 = v31;
            a1[1] = v32;
          }
        }

        return 1;
      }

      if (v10 >= v7)
      {
        *a1 = v6;
        a1[1] = v5;
        v47 = *(a2 - 1);
        if (*(v47 + 48) >= v8)
        {
          return 1;
        }

        a1[1] = v47;
      }

      else
      {
        *a1 = v9;
      }

      *(a2 - 1) = v5;
      return 1;
    }

    if (v2 != 4)
    {
      if (v2 != 5)
      {
        goto LABEL_13;
      }

      std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    }

    v20 = a1 + 1;
    v21 = a1[1];
    v22 = a1 + 2;
    v23 = a1[2];
    v24 = *a1;
    v25 = *(v21 + 48);
    v26 = *(*a1 + 48);
    v27 = *(v23 + 48);
    if (v25 >= v26)
    {
      if (v27 >= v25)
      {
LABEL_41:
        v21 = v23;
        goto LABEL_42;
      }

      *v20 = v23;
      *v22 = v21;
      v28 = a1;
      v29 = a1 + 1;
      v30 = v21;
      if (v27 >= v26)
      {
LABEL_42:
        v42 = *(a2 - 1);
        if (*(v42 + 48) < *(v21 + 48))
        {
          *v22 = v42;
          *(a2 - 1) = v21;
          v43 = *v22;
          v44 = *v20;
          v45 = *(v43 + 48);
          if (v45 < *(v44 + 48))
          {
            a1[1] = v43;
            a1[2] = v44;
            v46 = *a1;
            if (v45 < *(*a1 + 48))
            {
              *a1 = v43;
              a1[1] = v46;
            }
          }
        }

        return 1;
      }
    }

    else
    {
      v28 = a1;
      v29 = a1 + 2;
      v30 = *a1;
      if (v27 >= v25)
      {
        *a1 = v21;
        a1[1] = v24;
        v28 = a1 + 1;
        v29 = a1 + 2;
        v30 = v24;
        if (v27 >= v26)
        {
          goto LABEL_41;
        }
      }
    }

    *v28 = v23;
    *v29 = v24;
    v21 = v30;
    goto LABEL_42;
  }

  if (v2 < 2)
  {
    return 1;
  }

  if (v2 == 2)
  {
    v3 = *(a2 - 1);
    v4 = *a1;
    if (*(v3 + 48) < *(*a1 + 48))
    {
      *a1 = v3;
      *(a2 - 1) = v4;
    }

    return 1;
  }

LABEL_13:
  v12 = a1 + 2;
  v11 = a1[2];
  v13 = a1[1];
  v14 = *a1;
  v15 = *(v13 + 48);
  v16 = *(*a1 + 48);
  v17 = *(v11 + 48);
  if (v15 >= v16)
  {
    if (v17 >= v15)
    {
      goto LABEL_27;
    }

    a1[1] = v11;
    *v12 = v13;
    v18 = a1;
    v19 = a1 + 1;
LABEL_25:
    if (v17 >= v16)
    {
      goto LABEL_27;
    }

    goto LABEL_26;
  }

  v18 = a1;
  v19 = a1 + 2;
  if (v17 >= v15)
  {
    *a1 = v13;
    a1[1] = v14;
    v18 = a1 + 1;
    v19 = a1 + 2;
    goto LABEL_25;
  }

LABEL_26:
  *v18 = v11;
  *v19 = v14;
LABEL_27:
  v33 = a1 + 3;
  if (a1 + 3 == a2)
  {
    return 1;
  }

  v34 = 0;
  for (i = 24; ; i += 8)
  {
    v36 = *v33;
    v37 = *v12;
    v38 = *(*v33 + 48);
    if (v38 < *(v37 + 48))
    {
      v39 = i;
      while (1)
      {
        *(a1 + v39) = v37;
        v40 = v39 - 8;
        if (v39 == 8)
        {
          break;
        }

        v37 = *(a1 + v39 - 16);
        v39 -= 8;
        if (v38 >= *(v37 + 48))
        {
          v41 = (a1 + v40);
          goto LABEL_35;
        }
      }

      v41 = a1;
LABEL_35:
      *v41 = v36;
      if (++v34 == 8)
      {
        break;
      }
    }

    v12 = v33++;
    if (v33 == a2)
    {
      return 1;
    }
  }

  return v33 + 1 == a2;
}

void ggl::CommandBuffer::stableSortRenderItems(ggl::CommandBuffer *this, char *a2)
{
  v4 = (a2 - this) >> 3;
  if (v4 < 129)
  {
    v8 = 0;
LABEL_7:

    std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(this, a2, v4, 0, v8);
  }

  else
  {
    v5 = MEMORY[0x1E69E5398];
    v6 = (a2 - this) >> 3;
    while (1)
    {
      v7 = operator new(8 * v6, v5);
      if (v7)
      {
        break;
      }

      v8 = v6 >> 1;
      v9 = v6 > 1;
      v6 >>= 1;
      if (!v9)
      {
        goto LABEL_7;
      }
    }

    v10 = v7;
    std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(this, a2, v4, v7, v6);

    operator delete(v10);
  }
}

char *std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    v6 = result;
    if (a3 == 2)
    {
      v7 = *(a2 - 1);
      v8 = *result;
      if (*(v7 + 48) < *(*result + 48))
      {
        *result = v7;
        *(a2 - 1) = v8;
      }
    }

    else if (a3 > 128)
    {
      v19 = a4;
      v20 = a3 >> 1;
      v21 = &result[8 * (a3 >> 1)];
      v22 = a3 >> 1;
      if (a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(result, v21, v22, a4);
        v23 = &v19[8 * v20];
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        v24 = &v19[8 * a3];
        v25 = v23;
        while (v25 != v24)
        {
          v26 = *v25;
          v27 = *(*v25 + 48) < *(*v19 + 48);
          if (*(*v25 + 48) >= *(*v19 + 48))
          {
            v26 = *v19;
          }

          v19 += 8 * (*(*v25 + 48) >= *(*v19 + 48));
          v25 += v27;
          *v6 = v26;
          v6 += 8;
          if (v19 == v23)
          {
            while (v25 != v24)
            {
              v29 = *v25++;
              *v6 = v29;
              v6 += 8;
            }

            return result;
          }
        }

        while (v19 != v23)
        {
          v28 = *v19;
          v19 += 8;
          *v6 = v28;
          v6 += 8;
        }
      }

      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(result, v21, v22, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);

        return std::__inplace_merge<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }

    else if (result != a2)
    {
      v10 = result + 8;
      if (result + 8 != a2)
      {
        v11 = 0;
        v12 = result;
        do
        {
          v13 = *v12;
          v12 = v10;
          v14 = *v10;
          v15 = *(v14 + 48);
          if (v15 < *(v13 + 48))
          {
            v16 = v11;
            while (1)
            {
              *&result[v16 + 8] = v13;
              if (!v16)
              {
                break;
              }

              v13 = *&result[v16 - 8];
              v16 -= 8;
              if (v15 >= *(v13 + 48))
              {
                v17 = &result[v16 + 8];
                goto LABEL_16;
              }
            }

            v17 = result;
LABEL_16:
            *v17 = v14;
          }

          v10 = v12 + 8;
          v11 += 8;
        }

        while (v12 + 8 != a2);
      }
    }
  }

  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *v4 = *v6;
      return result;
    }

    if (a3 == 2)
    {
      v8 = *(a2 - 8);
      v9 = *(v8 + 48);
      v10 = *(*result + 48);
      if (v9 >= v10)
      {
        v8 = *result;
      }

      *a4 = v8;
      v4 = a4 + 1;
      if (v9 >= v10)
      {
        v6 = a2 - 8;
      }

      goto LABEL_8;
    }

    if (a3 > 8)
    {
      v20 = result + 8 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(result, v20, a3 >> 1, a4, a3 >> 1);
      result = std::__stable_sort<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v21 = v6 + 8 * (a3 >> 1);
      while (v21 != a2)
      {
        v22 = *v21;
        v23 = *(*v21 + 48) >= *(*v6 + 48);
        if (*(*v21 + 48) >= *(*v6 + 48))
        {
          v22 = *v6;
        }

        v21 += 8 * (*(*v21 + 48) < *(*v6 + 48));
        v6 += 8 * v23;
        *v4++ = v22;
        if (v6 == v20)
        {
          while (v21 != a2)
          {
            v25 = *v21;
            v21 += 8;
            *v4++ = v25;
          }

          return result;
        }
      }

      while (v6 != v20)
      {
        v24 = *v6;
        v6 += 8;
        *v4++ = v24;
      }
    }

    else if (result != a2)
    {
      v11 = result + 8;
      *a4 = *result;
      if (result + 8 != a2)
      {
        v12 = 0;
        v13 = a4;
        v14 = a4;
        do
        {
          v16 = *v14++;
          v15 = v16;
          if (*(*v11 + 48) >= *(v16 + 48))
          {
            *v14 = *v11;
          }

          else
          {
            v13[1] = v15;
            v17 = a4;
            if (v13 != a4)
            {
              v18 = v12;
              while (1)
              {
                v17 = (a4 + v18);
                v19 = *(a4 + v18 - 8);
                if (*(*v11 + 48) >= *(v19 + 48))
                {
                  break;
                }

                *v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  v17 = a4;
                  break;
                }
              }
            }

            *v17 = *v11;
          }

          v11 += 8;
          v12 += 8;
          v13 = v14;
        }

        while (v11 != a2);
      }
    }
  }

  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    v8 = a5;
    v11 = result;
    while (v8 > a7 && a4 > a7)
    {
      if (!a4)
      {
        return result;
      }

      while (1)
      {
        v12 = *v11;
        if (*(*a2 + 48) < *(*v11 + 48))
        {
          break;
        }

        v11 += 8;
        if (!--a4)
        {
          return result;
        }
      }

      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *v11 = *a2;
          *a2 = v12;
          return result;
        }

        v21 = a4 / 2;
        v15 = &v11[8 * (a4 / 2)];
        v14 = a2;
        if (a2 != a3)
        {
          v22 = (a3 - a2) >> 3;
          v14 = a2;
          do
          {
            v23 = v22 >> 1;
            v24 = &v14[8 * (v22 >> 1)];
            v26 = *v24;
            v25 = v24 + 8;
            v22 += ~(v22 >> 1);
            if (*(v26 + 48) < *(*v15 + 48))
            {
              v14 = v25;
            }

            else
            {
              v22 = v23;
            }
          }

          while (v22);
        }

        v13 = (v14 - a2) >> 3;
      }

      else
      {
        v13 = v8 / 2;
        v14 = &a2[8 * (v8 / 2)];
        v15 = a2;
        if (a2 != v11)
        {
          v16 = (a2 - v11) >> 3;
          v15 = v11;
          do
          {
            v17 = v16 >> 1;
            v18 = &v15[8 * (v16 >> 1)];
            v20 = *v18;
            v19 = v18 + 8;
            v16 += ~(v16 >> 1);
            if (*(*v14 + 48) < *(v20 + 48))
            {
              v16 = v17;
            }

            else
            {
              v15 = v19;
            }
          }

          while (v16);
        }

        v21 = (v15 - v11) >> 3;
      }

      v27 = v14;
      v28 = a2 - v15;
      if (a2 != v15)
      {
        v27 = v15;
        v29 = v14 - a2;
        if (v14 != a2)
        {
          if (v15 + 8 == a2)
          {
            v70 = *v15;
            v72 = v21;
            v74 = a6;
            v30 = a3;
            v31 = v13;
            memmove(v15, a2, v14 - a2);
            v13 = v31;
            v21 = v72;
            a6 = v74;
            a3 = v30;
            v27 = &v15[v29];
            *&v15[v29] = v70;
          }

          else if (a2 + 8 == v14)
          {
            v32 = *(v14 - 1);
            v27 = v15 + 8;
            if (v14 - 8 != v15)
            {
              v73 = v21;
              v75 = a6;
              v33 = a3;
              v34 = v13;
              v71 = *(v14 - 1);
              memmove(v15 + 8, v15, v14 - 8 - v15);
              v32 = v71;
              v21 = v73;
              v13 = v34;
              a3 = v33;
              a6 = v75;
            }

            *v15 = v32;
          }

          else
          {
            v35 = v28 >> 3;
            if (v28 >> 3 == v29 >> 3)
            {
              v36 = v15 + 8;
              v37 = a2 + 8;
              do
              {
                v38 = *(v36 - 1);
                *(v36 - 1) = *(v37 - 1);
                *(v37 - 1) = v38;
                if (v36 == a2)
                {
                  break;
                }

                v36 += 8;
                v39 = v37 == v14;
                v37 += 8;
              }

              while (!v39);
              v27 = a2;
            }

            else
            {
              v40 = v29 >> 3;
              v41 = v28 >> 3;
              do
              {
                v42 = v41;
                v41 = v40;
                v40 = v42 % v40;
              }

              while (v40);
              v43 = &v15[8 * v41];
              do
              {
                v45 = *(v43 - 1);
                v43 -= 8;
                v44 = v45;
                v46 = &v43[v28];
                v47 = v43;
                do
                {
                  v48 = v46;
                  *v47 = *v46;
                  v49 = &v46[8 * v35];
                  v50 = __OFSUB__(v35, (v14 - v46) >> 3);
                  v52 = v35 - ((v14 - v46) >> 3);
                  v51 = (v52 < 0) ^ v50;
                  v46 = &v15[8 * v52];
                  if (v51)
                  {
                    v46 = v49;
                  }

                  v47 = v48;
                }

                while (v46 != v43);
                *v48 = v44;
              }

              while (v43 != v15);
              v27 = &v15[v29];
            }
          }
        }
      }

      a4 -= v21;
      v8 -= v13;
      if (v21 + v13 >= a4 + v8)
      {
        v56 = v21;
        v57 = a4;
        v58 = v13;
        v54 = a6;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(v27, v14, a3, v57, v8);
        v14 = v15;
        v8 = v58;
        a4 = v56;
        a3 = v27;
      }

      else
      {
        v53 = v11;
        v54 = a6;
        v55 = a3;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,ggl::CommandBuffer::stableSortRenderItems(BOOL)::$_0 &,std::__wrap_iter<ggl::RenderItem **>>(v53, v15, v27, v21, v13);
        a3 = v55;
        v11 = v27;
      }

      a2 = v14;
      a6 = v54;
      if (!v8)
      {
        return result;
      }
    }

    if (a4 <= v8)
    {
      if (a2 != v11)
      {
        v65 = a6;
        v66 = v11;
        do
        {
          v67 = *v66;
          v66 += 8;
          *v65 = v67;
          v65 += 8;
        }

        while (v66 != a2);
        while (a2 != a3)
        {
          v68 = *a2;
          v69 = *(*a2 + 48) >= *(*a6 + 48);
          if (*(*a2 + 48) >= *(*a6 + 48))
          {
            v68 = *a6;
          }

          a2 += 8 * (*(*a2 + 48) < *(*a6 + 48));
          a6 += 8 * v69;
          *v11 = v68;
          v11 += 8;
          if (a6 == v65)
          {
            return result;
          }
        }

        return memmove(v11, a6, v65 - a6);
      }
    }

    else if (a2 != a3)
    {
      v59 = a6;
      v60 = a2;
      do
      {
        v61 = *v60;
        v60 += 8;
        *v59 = v61;
        v59 += 8;
      }

      while (v60 != a3);
      while (a2 != v11)
      {
        v62 = *(v59 - 1);
        if (*(v62 + 48) >= *(*(a2 - 1) + 48))
        {
          v59 -= 8;
        }

        else
        {
          v62 = *(a2 - 1);
          a2 -= 8;
        }

        *(a3 - 1) = v62;
        a3 -= 8;
        if (v59 == a6)
        {
          return result;
        }
      }

      if (v59 != a6)
      {
        v63 = -8;
        do
        {
          v64 = *(v59 - 1);
          v59 -= 8;
          *&a3[v63] = v64;
          v63 -= 8;
        }

        while (v59 != a6);
      }
    }
  }

  return result;
}

void std::__shared_ptr_pointer<ggl::RenderTransaction *,std::shared_ptr<ggl::RenderTransaction>::__shared_ptr_default_delete<ggl::RenderTransaction,ggl::RenderTransaction>,std::allocator<ggl::RenderTransaction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::RenderQueue::Pass>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 24 * a2, 0x1020040A95220FAuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void ggl::RenderQueue::attachPass(ggl::RenderQueue *this, ggl::RenderTarget *a2, ggl::RenderQueue *a3)
{
  v7 = *(this + 17);
  v6 = *(this + 18);
  if (v6)
  {
    atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
  }

  v8 = *(a3 + 18);
  *(a3 + 17) = v7;
  *(a3 + 18) = v6;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }

  v10 = *(this + 10);
  v9 = *(this + 11);
  if (v10 >= v9)
  {
    v12 = *(this + 9);
    v13 = v10 - v12;
    v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v12) >> 3);
    v15 = v14 + 1;
    if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v16 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v12) >> 3);
    if (2 * v16 > v15)
    {
      v15 = 2 * v16;
    }

    if (v16 >= 0x555555555555555)
    {
      v17 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v17 = v15;
    }

    v25[4] = this + 96;
    if (v17)
    {
      v18 = ggl::zone_mallocator::instance(v8);
      v19 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::RenderQueue::Pass>(v18, v17);
      v12 = *(this + 9);
      v13 = *(this + 10) - v12;
    }

    else
    {
      v19 = 0;
    }

    v20 = &v19[24 * v14];
    v21 = &v19[24 * v17];
    *v20 = a2;
    *(v20 + 1) = a3;
    v20[16] = 0;
    v11 = v20 + 24;
    v22 = &v20[-v13];
    memcpy(&v20[-v13], v12, v13);
    v23 = *(this + 9);
    *(this + 9) = v22;
    *(this + 10) = v11;
    v24 = *(this + 11);
    *(this + 11) = v21;
    v25[2] = v23;
    v25[3] = v24;
    v25[0] = v23;
    v25[1] = v23;
    std::__split_buffer<ggl::RenderQueue::Pass,geo::allocator_adapter<ggl::RenderQueue::Pass,ggl::zone_mallocator> &>::~__split_buffer(v25);
  }

  else
  {
    *v10 = a2;
    *(v10 + 8) = a3;
    v11 = (v10 + 24);
    *(v10 + 16) = 0;
  }

  *(this + 10) = v11;
}

ggl::zone_mallocator *ggl::RenderQueue::addTextureToSynchronize(ggl::zone_mallocator *this, ggl::Texture *a2)
{
  v3 = this;
  v5 = *(this + 24);
  v4 = *(this + 25);
  if (v5 >= v4)
  {
    v7 = *(this + 23);
    v8 = (v5 - v7) >> 3;
    if ((v8 + 1) >> 61)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (v8 + 1))
    {
      v10 = v8 + 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFF8)
    {
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v10;
    }

    v21[4] = this + 208;
    if (v11)
    {
      v12 = ggl::zone_mallocator::instance(this);
      v13 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<ggl::Texture *>(v12, v11);
    }

    else
    {
      v13 = 0;
    }

    v14 = &v13[8 * v8];
    v15 = &v13[8 * v11];
    *v14 = a2;
    v6 = v14 + 8;
    v16 = *(v3 + 23);
    v17 = *(v3 + 24) - v16;
    v18 = &v14[-v17];
    memcpy(&v14[-v17], v16, v17);
    v19 = *(v3 + 23);
    *(v3 + 23) = v18;
    *(v3 + 24) = v6;
    v20 = *(v3 + 25);
    *(v3 + 25) = v15;
    v21[2] = v19;
    v21[3] = v20;
    v21[0] = v19;
    v21[1] = v19;
    this = std::__split_buffer<ggl::Texture *,geo::allocator_adapter<ggl::Texture *,ggl::zone_mallocator> &>::~__split_buffer(v21);
  }

  else
  {
    *v5 = a2;
    v6 = v5 + 1;
  }

  *(v3 + 24) = v6;
  return this;
}

uint64_t std::__function::__func<ggl::DistanceAtlas::DistanceAtlas(unsigned int,float,float,ggl::Device *)::$_0,std::allocator<ggl::DistanceAtlas::DistanceAtlas(unsigned int,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5D190;
  a2[1] = v2;
  return result;
}

void ggl::RenderDataHolder::resetRenderResource(ggl::RenderDataHolder *this)
{
  *(this + 3) = 0;
  v2 = *(this + 2);
  *(this + 1) = 0;
  *(this + 2) = 0;
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  ++*(this + 8);
}

void ggl::RenderDataHolder::replaceRenderResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a1 + 8);
  if (!v6 || ((v7 = *(a1 + 24)) != 0 ? (v8 = v7 == 3735927469) : (v8 = 1), v8))
  {
    if (!a2)
    {
LABEL_10:
      v9 = 0uLL;
      goto LABEL_11;
    }
  }

  else
  {
    (*(*v6 + 16))(v6);
    if (!a2)
    {
      goto LABEL_10;
    }
  }

  std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>::shared_ptr[abi:nn200100]<gss::StylesheetManager<gss::PropertyID>,0>(&v11, *(a2 + 8), *(a2 + 16));
  v9 = v11;
LABEL_11:
  v11 = 0uLL;
  v10 = *(a1 + 16);
  *(a1 + 8) = v9;
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v10);
    if (*(&v11 + 1))
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](*(&v11 + 1));
    }
  }

  *(a1 + 24) = a3;
  ++*(a1 + 32);
}

uint64_t ggl::Performance::Counters::setGroupMask(uint64_t this, int a2)
{
  *(this + 48) = a2;
  *(this + 52) = 1;
  return this;
}

uint64_t ggl::Performance::HUD::debugConsole(ggl::Performance::HUD *this, uint64_t *a2)
{
  result = *a2;
  if (!*a2)
  {
    operator new();
  }

  v4 = a2[1];
  *this = result;
  *(this + 1) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((v4 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__shared_ptr_emplace<ggl::DebugConsole>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D218;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

__n128 std::__function::__func<ggl::MetalClearItemProcessor::createClearMesh(ggl::ProcessClearItemContext &)::$_0,std::allocator<ggl::MetalClearItemProcessor::createClearMesh(ggl::ProcessClearItemContext &)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5D300;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ggl::MetalClearItemProcessor::process(ggl::ProcessClearItemContext &,ggl::ClearItem *)::$_0,std::allocator<ggl::MetalClearItemProcessor::process(ggl::ProcessClearItemContext &,ggl::ClearItem *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5D3D8;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__shared_ptr_pointer<ggl::Clear::ClearMesh *,std::shared_ptr<ggl::Clear::ClearMesh>::__shared_ptr_default_delete<ggl::Clear::ClearMesh,ggl::Clear::ClearMesh>,std::allocator<ggl::Clear::ClearMesh>>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<ggl::Clear::ClearMesh *,std::shared_ptr<ggl::Clear::ClearMesh>::__shared_ptr_default_delete<ggl::Clear::ClearMesh,ggl::Clear::ClearMesh>,std::allocator<ggl::Clear::ClearMesh>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void ggl::Buffer::~Buffer(ggl::Buffer *this)
{
  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

uint64_t ggl::BufferData::BufferData(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  *a1 = &unk_1F2A5D5A0;
  *(a1 + 8) = a2;
  *(a1 + 16) = a6;
  *(a1 + 19) = 0;
  v7 = a3[1];
  *(a1 + 24) = *a3;
  *(a1 + 32) = v7;
  if (v7)
  {
    atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 40) = a4;
  *(a1 + 48) = a5;
  *(a1 + 104) = 0;
  *(a1 + 56) = 0u;
  *(a1 + 72) = 0u;
  *(a1 + 88) = 0;
  *(a1 + 112) = 1;
  *(a1 + 136) = 0u;
  *(a1 + 152) = 0u;
  *(a1 + 168) = 0u;
  *(a1 + 184) = 0;
  *(a1 + 192) = -1;
  v8 = *a3;
  *(a1 + 17) = *(*a3 + 37);
  *(a1 + 18) = *(v8 + 38);
  *(a1 + 120) = a5 - a4;
  *(a1 + 128) = 850045863;
  if ((a6 & ((~a6 & 6) != 0)) == 0 && a5 != a4)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,ggl::zone_mallocator>>::__append(a1 + 72, a5 - a4);
  }

  return a1;
}

void std::__shared_ptr_emplace<ggl::Buffer,geo::allocator_adapter<ggl::Buffer,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D440;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t ggl::Performance::setExpandedMode(ggl::Performance *this)
{
  v1 = 0;
  v2 = 32;
  if (!this)
  {
    v2 = 28;
  }

  v3 = ggl::Performance::Counters::instance(void)::onceToken[0];
  do
  {
    v5 = *&v4[v1];
    if (v3 != -1)
    {
      dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_50855);
    }

    v7 = ggl::Performance::Counters::instance(void)::counters;
    result = *(ggl::Performance::Counters::instance(void)::counters + 16) + 72 * v6;
    if (*(result + 60))
    {
      result = ggl::Performance::CounterInfo::setDisplayMode(result, v5);
      *(v7 + 52) = 1;
      v3 = ggl::Performance::Counters::instance(void)::onceToken[0];
    }

    else
    {
      v3 = -1;
    }

    v1 += 40;
  }

  while (v1 != 1000);
  return result;
}

void non-virtual thunk toggl::VertexData::~VertexData(ggl::VertexData *this)
{
  ggl::BufferData::~BufferData((this - 200));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::BufferData::~BufferData((this - 200));
}

void ggl::VertexData::~VertexData(std::mutex *this)
{
  ggl::BufferData::~BufferData(this);

  JUMPOUT(0x1B8C62190);
}

void *ggl::VertexData::VertexData(void *a1, uint64_t a2, uint64_t a3, void *a4, int a5)
{
  v8 = *(**(a3 + 216) + 24);
  v9 = *(a3 + 32);
  v12[0] = *(a3 + 24);
  v12[1] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    v10 = *(**(a3 + 216) + 24);
    ggl::BufferData::BufferData(a1, v8, v12, *a4 * v10, a4[1] * v10, a5);
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }

  else
  {
    ggl::BufferData::BufferData(a1, v8, v12, *a4 * v8, a4[1] * v8, a5);
  }

  *a1 = &unk_1F2A5D478;
  a1[25] = &unk_1F2A5D498;
  a1[26] = a2;
  a1[27] = *(a3 + 216);
  return a1;
}

void *ggl::VertexData::VertexData(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t *a6, int a7)
{
  v11 = *(*a3 + 24);
  v13[0] = a4;
  v13[1] = a5;
  if (a5)
  {
    atomic_fetch_add_explicit(&a5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  ggl::BufferData::BufferData(a1, v11, v13, *a6, a6[1], a7);
  if (a5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a5);
  }

  *a1 = &unk_1F2A5D478;
  a1[25] = &unk_1F2A5D498;
  a1[26] = a2;
  a1[27] = a3;
  return a1;
}

void non-virtual thunk toggl::TextureCube::~TextureCube(ggl::TextureCube *this)
{
  v2 = (this - 40);
  *(this - 5) = &unk_1F2A5D4B8;
  *this = &unk_1F2A5D4D8;
  v3 = *(this + 22);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  v4 = 144;
  while (1)
  {
    v5 = *(this + v4);
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v5);
    }

    v4 -= 16;
    if (v4 == 48)
    {
      ggl::RenderDataHolder::~RenderDataHolder(v2);

      JUMPOUT(0x1B8C62190);
    }
  }
}

{
  v2 = (this - 40);
  *(this - 5) = &unk_1F2A5D4B8;
  *this = &unk_1F2A5D4D8;
  v3 = *(this + 22);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  for (i = 144; i != 48; i -= 16)
  {
    v5 = *(this + i);
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v5);
    }
  }

  ggl::RenderDataHolder::~RenderDataHolder(v2);
}

void ggl::TextureCube::~TextureCube(ggl::TextureCube *this)
{
  *this = &unk_1F2A5D4B8;
  *(this + 5) = &unk_1F2A5D4D8;
  v2 = *(this + 27);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = 184;
  while (1)
  {
    v4 = *(this + v3);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v4);
    }

    v3 -= 16;
    if (v3 == 88)
    {
      ggl::RenderDataHolder::~RenderDataHolder(this);

      JUMPOUT(0x1B8C62190);
    }
  }
}

{
  *this = &unk_1F2A5D4B8;
  *(this + 5) = &unk_1F2A5D4D8;
  v2 = *(this + 27);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  for (i = 184; i != 88; i -= 16)
  {
    v4 = *(this + i);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v4);
    }
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

uint64_t ggl::TextureCube::TextureCube(uint64_t result, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, int a9)
{
  *(result + 32) = 0;
  *(result + 24) = 0;
  *(result + 8) = 0u;
  *(result + 56) = 3;
  *(result + 60) = a9;
  *(result + 64) = a8;
  *(result + 68) = a4;
  *(result + 72) = a6;
  *(result + 76) = a7;
  *(result + 80) = 0;
  *result = &unk_1F2A5D4B8;
  *(result + 40) = &unk_1F2A5D4D8;
  *(result + 48) = "";
  *(result + 88) = a3;
  *(result + 96) = 0u;
  *(result + 112) = 0u;
  *(result + 128) = 0u;
  *(result + 144) = 0u;
  *(result + 160) = 0u;
  *(result + 176) = 0u;
  *(result + 192) = 0;
  *(result + 196) = a2;
  *(result + 200) = 1;
  v9 = a5[1];
  *(result + 208) = *a5;
  *(result + 216) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

__n128 std::__function::__func<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5D4F8;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void non-virtual thunk toggl::IndexData::~IndexData(ggl::IndexData *this)
{
  ggl::BufferData::~BufferData((this - 200));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::BufferData::~BufferData((this - 200));
}

void ggl::IndexData::~IndexData(std::mutex *this)
{
  ggl::BufferData::~BufferData(this);

  JUMPOUT(0x1B8C62190);
}

uint64_t ggl::IndexData::IndexData(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  v7 = 4;
  if (a3 != 1)
  {
    v7 = 1;
  }

  if (a3)
  {
    v8 = v7;
  }

  else
  {
    v8 = 2;
  }

  result = ggl::BufferData::BufferData(a1, v8, 1, 0, a5, a4);
  *result = &unk_1F2A5D540;
  *(result + 8) = v8;
  *(result + 200) = &unk_1F2A5D560;
  *(result + 208) = a2;
  *(result + 216) = a3;
  return result;
}

uint64_t ggl::IndexData::IndexData(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5)
{
  v8 = a3[1];
  v9 = a3[4];
  v11[0] = a3[3];
  v11[1] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::BufferData::BufferData(a1, v8, v11, *a4 * a3[1], a4[1] * a3[1], a5);
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }

  else
  {
    ggl::BufferData::BufferData(a1, v8, v11, *a4 * v8, a4[1] * v8, a5);
  }

  *a1 = &unk_1F2A5D540;
  *(a1 + 200) = &unk_1F2A5D560;
  *(a1 + 208) = a2;
  *(a1 + 216) = 0;
  *(a1 + 8) = a3[1];
  return a1;
}

void ggl::ConstantData::~ConstantData(std::mutex *this)
{
  ggl::BufferData::~BufferData(this);

  JUMPOUT(0x1B8C62190);
}

void ggl::Renderer::~Renderer(ggl::Renderer *this)
{
  *this = &unk_1F2A5D5C0;
  v2 = *(this + 15);
  if (v2)
  {
    (*(*v2 + 8))(v2);
  }

  v3 = *(this + 16);
  *(this + 16) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  v4 = *(this + 14);
  *(this + 14) = 0;
  if (v4)
  {
    std::default_delete<ggl::RenderResourceFences>::operator()[abi:nn200100](v4);
  }

  v5 = *(this + 13);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  v6 = std::unique_ptr<ggl::RenderQueue>::reset[abi:nn200100](this + 11, 0);
  v7 = *(this + 7);
  if (v7)
  {
    v8 = *(this + 8);
    v9 = *(this + 7);
    if (v8 != v7)
    {
      do
      {
        v6 = *(v8 - 8);
        if (v6)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v6);
        }

        v8 -= 16;
      }

      while (v8 != v7);
      v9 = *(this + 7);
    }

    *(this + 8) = v7;
    v10 = ggl::zone_mallocator::instance(v6);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v10, v9);
  }
}

void ggl::Renderer::addDebugRenderer(ggl::zone_mallocator *a1, __int128 *a2)
{
  v4 = *(a1 + 8);
  v5 = *(a1 + 9);
  if (v4 >= v5)
  {
    v8 = *(a1 + 7);
    v9 = (v4 - v8) >> 4;
    v10 = v9 + 1;
    if ((v9 + 1) >> 60)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v11 = v5 - v8;
    if (v11 >> 3 > v10)
    {
      v10 = v11 >> 3;
    }

    if (v11 >= 0x7FFFFFFFFFFFFFF0)
    {
      v12 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v10;
    }

    if (v12)
    {
      v13 = ggl::zone_mallocator::instance(a1);
      geo::read_write_lock::read_lock((v13 + 32));
      v14 = malloc_type_zone_malloc(*v13, 16 * v12, 0x20040A4A59CD2uLL);
      atomic_fetch_add((v13 + 24), 1u);
      geo::read_write_lock::unlock((v13 + 32));
    }

    else
    {
      v14 = 0;
    }

    v15 = &v14[16 * v9];
    v16 = *a2;
    *v15 = *a2;
    if (*(&v16 + 1))
    {
      atomic_fetch_add_explicit((*(&v16 + 1) + 8), 1uLL, memory_order_relaxed);
    }

    v17 = &v14[16 * v12];
    v7 = v15 + 16;
    v18 = *(a1 + 7);
    v19 = *(a1 + 8) - v18;
    v20 = &v15[-v19];
    v21 = memcpy(&v15[-v19], v18, v19);
    v22 = *(a1 + 7);
    *(a1 + 7) = v20;
    *(a1 + 8) = v7;
    *(a1 + 9) = v17;
    if (v22)
    {
      v23 = ggl::zone_mallocator::instance(v21);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v23, v22);
    }
  }

  else
  {
    v6 = *(a2 + 1);
    *v4 = *a2;
    v4[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
    }

    v7 = v4 + 2;
  }

  *(a1 + 8) = v7;
}

void ggl::Renderer::removeDebugRenderer(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 56);
  v3 = *(a1 + 64);
  if (v4 != v3)
  {
    while (*v4 != a2)
    {
      v4 += 16;
      if (v4 == v3)
      {
        v4 = *(a1 + 64);
        break;
      }
    }
  }

  if (v3 != v4)
  {
    if (v4 + 16 == v3)
    {
      v7 = v4;
    }

    else
    {
      do
      {
        v5 = *(v4 + 16);
        *(v4 + 16) = 0;
        *(v4 + 24) = 0;
        v6 = *(v4 + 8);
        *v4 = v5;
        if (v6)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v6);
        }

        v7 = v4 + 16;
        v8 = v4 + 32;
        v4 += 16;
      }

      while (v8 != v3);
      v3 = *(a1 + 64);
    }

    while (v3 != v7)
    {
      v9 = *(v3 - 8);
      if (v9)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v9);
      }

      v3 -= 16;
    }

    *(a1 + 64) = v7;
  }
}

void sub_1B3312424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v14 = mach_absolute_time() - a10;
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1)
  {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_50855);
  }

  atomic_fetch_add(*(ggl::Performance::Counters::instance(void)::counters + 32), v14);

  _Unwind_Resume(a1);
}

void non-virtual thunk toggl::IOSurfaceTexture::~IOSurfaceTexture(ggl::IOSurfaceTexture *this)
{
  ggl::IOSurfaceTexture::~IOSurfaceTexture((this - 40));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::IOSurfaceTexture::~IOSurfaceTexture((this - 40));
}

void ggl::IOSurfaceTexture::~IOSurfaceTexture(ggl::IOSurfaceTexture *this)
{
  *this = &unk_1F2A5D778;
  *(this + 5) = &unk_1F2A5D798;
  v2 = *(this + 20);
  if (v2)
  {
    CFRelease(v2);
  }

  v3 = *(this + 21);
  if (v3)
  {
    CFRelease(v3);
  }

  *this = &unk_1F2A5D9F0;
  *(this + 5) = &unk_1F2A5DA10;
  v4 = *(this + 18);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  v5 = *(this + 15);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  *this = &unk_1F2A5DA30;
  *(this + 5) = &unk_1F2A5DA50;
  v6 = *(this + 12);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }

  ggl::RenderDataHolder::~RenderDataHolder(this);
}

{
  ggl::IOSurfaceTexture::~IOSurfaceTexture(this);

  JUMPOUT(0x1B8C62190);
}

void sub_1B3312D28(_Unwind_Exception *a1)
{
  *v1 = &unk_1F2A5D9F0;
  *(v1 + 5) = &unk_1F2A5DA10;
  v3 = *(v1 + 18);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  v4 = *(v1 + 15);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  *v1 = &unk_1F2A5DA30;
  *(v1 + 5) = &unk_1F2A5DA50;
  v5 = *(v1 + 12);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  ggl::RenderDataHolder::~RenderDataHolder(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::IOSurfaceTexture::IOSurfaceTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5, int a6)
{
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *(a1 + 32) = 0;
  *(a1 + 24) = 0;
  *(a1 + 56) = 1;
  *(a1 + 60) = a6;
  *(a1 + 64) = 0;
  *(a1 + 68) = a4;
  *(a1 + 72) = 1;
  *(a1 + 76) = 0;
  *(a1 + 92) = 0;
  *(a1 + 84) = 0;
  *(a1 + 100) = 0x100000000;
  *a1 = &unk_1F2A5D9F0;
  *(a1 + 40) = &unk_1F2A5DA10;
  *(a1 + 48) = "";
  *(a1 + 128) = 0;
  *(a1 + 112) = 0;
  *(a1 + 120) = 0;
  *(a1 + 130) = 1;
  v9 = a5[1];
  *(a1 + 136) = *a5;
  *(a1 + 144) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((v9 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 80) = a2;
  *(a1 + 84) = a3;
  *a1 = &unk_1F2A5D778;
  *(a1 + 40) = &unk_1F2A5D798;
  *(a1 + 168) = 0;
  v10 = 4 * vcvtd_n_u64_f64(ceil(vcvtd_n_f64_u32(a2, 4uLL)), 4uLL);
  *(a1 + 152) = v10;
  *(a1 + 156) = v10 * vcvtd_n_u64_f64(ceil(vcvtd_n_f64_u32(a3, 4uLL)), 4uLL);
  if (a4 > 41)
  {
    if (a4 == 42)
    {
      v11 = 875704422;
      goto LABEL_11;
    }

    if (a4 == 43)
    {
      v11 = 875704438;
      goto LABEL_11;
    }
  }

  else if ((a4 - 12) < 2)
  {
    v11 = 1380401729;
    goto LABEL_11;
  }

  v11 = 1111970369;
LABEL_11:
  v12 = objc_alloc(MEMORY[0x1E695DF20]);
  v13 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:a2];
  v14 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:a3];
  v15 = [MEMORY[0x1E696AD98] numberWithInt:v11];
  v16 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:*(a1 + 152)];
  v17 = [MEMORY[0x1E696AD98] numberWithUnsignedInt:*(a1 + 156)];
  v18 = [v12 initWithObjectsAndKeys:{v13, *MEMORY[0x1E696D130], v14, *MEMORY[0x1E696CF58], v15, *MEMORY[0x1E696CFC0], &unk_1F2A88560, *MEMORY[0x1E696CE50], MEMORY[0x1E695E118], *MEMORY[0x1E696CFA0], v16, *MEMORY[0x1E696CE58], v17, *MEMORY[0x1E696CE30], &unk_1F2A88578, *MEMORY[0x1E696CE60], 0}];

  v19 = IOSurfaceCreate(v18);
  *(a1 + 160) = v19;
  *(a1 + 56) = 4;
  return a1;
}

void sub_1B3313118(_Unwind_Exception *a1)
{
  v5 = v4;

  *v1 = v2;
  *(v1 + 5) = v3;
  v7 = *(v1 + 18);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  v8 = *(v1 + 15);
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }

  *v1 = &unk_1F2A5DA30;
  *(v1 + 5) = &unk_1F2A5DA50;
  v9 = *(v1 + 12);
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }

  ggl::RenderDataHolder::~RenderDataHolder(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::IOSurfaceFormatToMatchingPixelFormat(ggl *this, uint64_t a2, int a3)
{
  if (this <= 1111970368)
  {
    if (this == 875704422)
    {
      if (a2 == 1)
      {
        return 42;
      }
    }

    else if (this == 875704438 && a2 == 1)
    {
      return 43;
    }

    return 0;
  }

  if (this != 1380401729)
  {
    if (this == 1111970369 && a2 == 4)
    {
      v4 = a3 == 0;
      v5 = 14;
      goto LABEL_14;
    }

    return 0;
  }

  if (a2 != 4)
  {
    return 0;
  }

  v4 = a3 == 0;
  v5 = 12;
LABEL_14:
  if (v4)
  {
    return v5;
  }

  else
  {
    return v5 + 1;
  }
}

uint64_t ggl::IOSurfaceTexture::IOSurfaceTexture(uint64_t a1, IOSurfaceRef buffer, void *a3)
{
  Width = IOSurfaceGetWidth(buffer);
  Height = IOSurfaceGetHeight(buffer);
  PixelFormat = IOSurfaceGetPixelFormat(buffer);
  BytesPerElement = IOSurfaceGetBytesPerElement(buffer);
  v10 = ggl::IOSurfaceFormatToMatchingPixelFormat(PixelFormat, BytesPerElement, 0);
  *(a1 + 8) = 0;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 0;
  *(a1 + 56) = 0x200000001;
  *(a1 + 64) = 0;
  *(a1 + 68) = v10;
  *(a1 + 72) = 1;
  *(a1 + 76) = 0;
  *(a1 + 92) = 0;
  *(a1 + 84) = 0;
  *(a1 + 100) = 0x100000000;
  *a1 = &unk_1F2A5D9F0;
  *(a1 + 40) = &unk_1F2A5DA10;
  *(a1 + 48) = "";
  *(a1 + 112) = 0;
  *(a1 + 120) = 0;
  *(a1 + 128) = 0;
  *(a1 + 130) = 1;
  v11 = a3[1];
  *(a1 + 136) = *a3;
  *(a1 + 144) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 80) = Width;
  *(a1 + 84) = Height;
  *a1 = &unk_1F2A5D778;
  *(a1 + 40) = &unk_1F2A5D798;
  *(a1 + 168) = 0;
  CFRetain(buffer);
  *(a1 + 160) = buffer;
  *(a1 + 56) = 4;
  return a1;
}

void sub_1B33133FC(_Unwind_Exception *a1)
{
  *v1 = v2;
  *(v1 + 5) = v3;
  v5 = *(v1 + 18);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }

  v6 = *(v1 + 15);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v6);
  }

  *v1 = &unk_1F2A5DA30;
  *(v1 + 5) = &unk_1F2A5DA50;
  v7 = *(v1 + 12);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  ggl::RenderDataHolder::~RenderDataHolder(v1);
  _Unwind_Resume(a1);
}

IOSurfaceRef ggl::IOSurfaceTexture::createTextureFromPixelBuffer(void *a1, CVPixelBufferRef pixelBuffer)
{
  result = CVPixelBufferGetIOSurface(pixelBuffer);
  if (result)
  {
    operator new();
  }

  *a1 = 0;
  a1[1] = 0;
  return result;
}

void sub_1B331369C(_Unwind_Exception *a1)
{
  v1[1].__vftable = v4;
  v1[2].__shared_weak_owners_ = v5;
  v7 = v1[7].__vftable;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }

  v8 = v1[6].__vftable;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }

  v1[1].__vftable = &unk_1F2A5DA30;
  v1[2].__shared_weak_owners_ = &unk_1F2A5DA50;
  v9 = v1[5].__vftable;
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }

  ggl::RenderDataHolder::~RenderDataHolder(v3);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v10);
  _Unwind_Resume(a1);
}

void ggl::MetalDevice::~MetalDevice(ggl::MetalDevice *this)
{
  ggl::MetalDevice::~MetalDevice(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5D7F0;
  v2 = *(this + 10);
  if (v2)
  {
    *(v2 + 256) = 0;
  }

  std::mutex::~mutex((this + 144));
  v3 = *(this + 17);
  *(this + 17) = 0;
  if (v3)
  {
    (*(*v3 + 8))(v3);
  }

  *this = &unk_1F2A5D838;
  v4 = *(this + 11);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::MetalResourceManager,geo::allocator_adapter<ggl::MetalResourceManager,ggl::zone_mallocator>>>(uint64_t a1, void *a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);

  geo::read_write_lock::unlock((a1 + 32));
}

void std::__shared_ptr_emplace<ggl::MetalResourceManager,geo::allocator_adapter<ggl::MetalResourceManager,ggl::zone_mallocator>>::__on_zero_shared_weak(ggl::zone_mallocator *a1)
{
  v2 = ggl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::MetalResourceManager,geo::allocator_adapter<ggl::MetalResourceManager,ggl::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<ggl::MetalResourceManager,geo::allocator_adapter<ggl::MetalResourceManager,ggl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5D880;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *ggl::RenderItem::assertValid(ggl::RenderItem *this)
{
  result = *(this + 4);
  if (result[18] != result[17])
  {
    v3 = 0;
    do
    {
      (*(*result + 16))(result, v3++);
      result = *(this + 4);
    }

    while (v3 < (result[18] - result[17]) >> 4);
  }

  if (result[22] != result[21])
  {
    v4 = 0;
    do
    {
      (*(*result + 24))(result, v4++);
      result = *(this + 4);
    }

    while (v4 < (result[22] - result[21]) >> 3);
  }

  return result;
}

void ggl::NullRenderer::~NullRenderer(ggl::NullRenderer *this)
{
  ggl::Renderer::~Renderer(this);

  JUMPOUT(0x1B8C62190);
}

void non-virtual thunk toggl::RenderTarget::~RenderTarget(ggl::RenderTarget *this)
{
  ggl::RenderDataHolder::~RenderDataHolder((this - 40));

  JUMPOUT(0x1B8C62190);
}

{
  ggl::RenderDataHolder::~RenderDataHolder((this - 40));
}

void ggl::RenderTarget::~RenderTarget(ggl::RenderTarget *this)
{
  ggl::RenderDataHolder::~RenderDataHolder(this);

  JUMPOUT(0x1B8C62190);
}

void *loadASTCTexture(void *result, uint64_t a2, unint64_t a3)
{
  v6[1] = *MEMORY[0x1E69E9840];
  if (a3 >= 0x10 && *a2 == 1554098963)
  {
    v3 = *(a2 + 4);
    v4 = *(a2 + 5);
    if ((16 * (((*(a2 + 9) << 16) | (*(a2 + 8) << 8) | *(a2 + 7)) + v3 - 1) / v3 * ((((*(a2 + 12) << 16) | (*(a2 + 11) << 8) | *(a2 + 10)) + v4 - 1) / v4) * ((((*(a2 + 15) << 16) | (*(a2 + 14) << 8) | *(a2 + 13)) + *(a2 + 6) - 1) / *(a2 + 6))) + 16 <= a3)
    {
      if (*(a2 + 4) > 7u)
      {
        if (v3 == 8)
        {
          if (v4 != 8 && v4 != 6 && v4 != 5)
          {
            goto LABEL_4;
          }
        }

        else if (v3 == 10)
        {
          if (*(a2 + 5) > 7u)
          {
            if (v4 != 8 && v4 != 10)
            {
              goto LABEL_4;
            }
          }

          else if (v4 != 5 && v4 != 6)
          {
            goto LABEL_4;
          }
        }

        else if (v3 != 12 || v4 != 12 && v4 != 10)
        {
          goto LABEL_4;
        }
      }

      else if (v3 == 4)
      {
        if (v4 != 4)
        {
          goto LABEL_4;
        }
      }

      else if (v3 == 5)
      {
        if (v4 != 5 && v4 != 4)
        {
          goto LABEL_4;
        }
      }

      else if (v3 != 6 || v4 != 6 && v4 != 5)
      {
        goto LABEL_4;
      }

      v6[0] = 16 * (((*(a2 + 9) << 16) | (*(a2 + 8) << 8) | *(a2 + 7)) + v3 - 1) / v3 * ((((*(a2 + 12) << 16) | (*(a2 + 11) << 8) | *(a2 + 10)) + v4 - 1) / v4) * ((((*(a2 + 15) << 16) | (*(a2 + 14) << 8) | *(a2 + 13)) + *(a2 + 6) - 1) / *(a2 + 6));
      std::vector<unsigned long>::vector[abi:nn200100](&__p, v6, 1uLL);
      operator new();
    }
  }

LABEL_4:
  *result = 0;
  result[1] = 0;
  return result;
}

unint64_t astcTextureSize(int a1, unint64_t a2, unint64_t a3)
{
  result = 0;
  switch(a1)
  {
    case 28:
    case 44:
      v5 = vcvtd_n_f64_u64(a2, 2uLL);
      goto LABEL_14;
    case 29:
    case 45:
      v11 = a2;
      v12 = 0.2;
      goto LABEL_13;
    case 30:
    case 46:
      v10 = a2;
      v8 = 0.2;
      goto LABEL_16;
    case 31:
    case 47:
      v11 = a2;
      v12 = 0.166666667;
LABEL_13:
      v5 = v11 * v12;
LABEL_14:
      v6 = vcvtpd_u64_f64(v5);
      v14 = vcvtd_n_f64_u64(a3, 2uLL);
      goto LABEL_20;
    case 32:
    case 48:
      v10 = a2;
      v8 = 0.166666667;
      goto LABEL_16;
    case 33:
    case 49:
      v9 = vcvtd_n_f64_u64(a2, 3uLL);
      goto LABEL_11;
    case 34:
    case 50:
      v13 = vcvtd_n_f64_u64(a2, 3uLL);
      goto LABEL_18;
    case 35:
    case 51:
      v15 = vcvtd_n_f64_u64(a2, 3uLL);
      goto LABEL_23;
    case 36:
    case 52:
      v9 = a2 * 0.1;
LABEL_11:
      v6 = vcvtpd_u64_f64(v9);
      v7 = a3;
      v8 = 0.2;
      goto LABEL_19;
    case 37:
    case 53:
      v13 = a2 * 0.1;
LABEL_18:
      v6 = vcvtpd_u64_f64(v13);
      v7 = a3;
      v8 = 0.166666667;
      goto LABEL_19;
    case 38:
    case 54:
      v15 = a2 * 0.1;
LABEL_23:
      v6 = vcvtpd_u64_f64(v15);
      v14 = vcvtd_n_f64_u64(a3, 3uLL);
      goto LABEL_20;
    case 39:
    case 55:
      v10 = a2;
      v8 = 0.1;
      goto LABEL_16;
    case 40:
    case 56:
      v6 = vcvtpd_u64_f64(a2 * 0.0833333333);
      v7 = a3;
      v8 = 0.1;
      goto LABEL_19;
    case 41:
    case 57:
      v10 = a2;
      v8 = 0.0833333333;
LABEL_16:
      v6 = vcvtpd_u64_f64(v10 * v8);
      v7 = a3;
LABEL_19:
      v14 = v7 * v8;
LABEL_20:
      result = 16 * v6 * vcvtpd_u64_f64(v14);
      break;
    default:
      return result;
  }

  return result;
}

void textureWithData(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (v6)
  {
    std::allocate_shared[abi:nn200100]<ggl::Texture2D,std::allocator<ggl::Texture2D>,std::shared_ptr<ggl::TextureData2D> &,std::shared_ptr<ggl::SamplerState> const&,0>();
  }

  *a1 = 0;
  a1[1] = 0;
  v5 = v7;
  if (v7)
  {

    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  }
}

void sub_1B3314298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  _Unwind_Resume(exception_object);
}

void loadTexture(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  v16 = a2;
  v9 = a3;
  v10 = a4;
  v11 = objc_alloc(MEMORY[0x1E695DEF0]);
  v12 = [v16 pathForResource:v9 ofType:v10];
  v13 = [v11 initWithContentsOfFile:v12];

  v14 = *a5;
  v15 = a5[1];
  v17[0] = v14;
  v17[1] = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  textureWithData(a1, v13, v17, 2, 0, 0);
  if (v15)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v15);
  }
}

void sub_1B33143A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v13);
  }

  _Unwind_Resume(a1);
}

void textureWithData(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  if (v8)
  {
    std::allocate_shared[abi:nn200100]<ggl::Texture2D,std::allocator<ggl::Texture2D>,std::shared_ptr<ggl::TextureData2D> &,std::shared_ptr<ggl::SamplerState> const&,0>();
  }

  *a1 = 0;
  a1[1] = 0;
  v7 = v9;
  if (v9)
  {

    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }
}

void sub_1B331446C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](a10);
  }

  _Unwind_Resume(exception_object);
}

__n128 ggl::BufferMemory::BufferMemory(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  result = *(a2 + 16);
  *(a1 + 16) = result;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a2 + 40) = 0;
  *a2 = 0;
  *(a2 + 8) = 0;
  return result;
}

void std::__call_once_proxy[abi:nn200100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>()
{
  if (GEOGetGeoGLPerformanceLog_onceToken != -1)
  {
    dispatch_once(&GEOGetGeoGLPerformanceLog_onceToken, &__block_literal_global_5_50383);
  }

  v0 = GEOGetGeoGLPerformanceLog_log;
  if (os_log_type_enabled(GEOGetGeoGLPerformanceLog_log, OS_LOG_TYPE_DEBUG))
  {
    *v1 = 0;
    _os_log_impl(&dword_1B2754000, v0, OS_LOG_TYPE_DEBUG, "Reading buffers without 'readable' usage may come with performance penalty.  NB This message is only logged once.", v1, 2u);
  }
}

void non-virtual thunk toggl::Shader::~Shader(ggl::Shader *this)
{
  v1 = this - 16;
  ggl::RenderDataHolder::~RenderDataHolder(this);
  v3 = ggl::zone_mallocator::instance(v2);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, v1);
}

void ggl::Shader::~Shader(ggl::Shader *this)
{
  ggl::RenderDataHolder::~RenderDataHolder((this + 16));
  v3 = ggl::zone_mallocator::instance(v2);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, this);
}

{
  ggl::RenderDataHolder::~RenderDataHolder((this + 16));
}

void ggl::ShaderFunction::~ShaderFunction(ggl::ShaderFunction *this)
{
  ggl::RenderDataHolder::~RenderDataHolder(this);
  v3 = ggl::zone_mallocator::instance(v2);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, this);
}

os_log_t __GEOGetGeoCSSStyleSheetLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoCSS", "StyleSheet");
  GEOGetGeoCSSStyleSheetLog_log = result;
  return result;
}

uint64_t GEOGetGeoCSSMaterialSystemLog()
{
  if (GEOGetGeoCSSMaterialSystemLog_onceToken != -1)
  {
    dispatch_once(&GEOGetGeoCSSMaterialSystemLog_onceToken, &__block_literal_global_5_51265);
  }

  return GEOGetGeoCSSMaterialSystemLog_log;
}

os_log_t __GEOGetGeoCSSMaterialSystemLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoCSS", "MaterialSystem");
  GEOGetGeoCSSMaterialSystemLog_log = result;
  return result;
}

void std::allocator_traits<geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::deallocate[abi:ne200100](gss::zone_mallocator *a1)
{
  v2 = gss::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v2, a1);
}

void *std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1B8C61C10](v20, a1);
  if (v20[0] == 1)
  {
    v6 = a1 + *(*a1 - 24);
    v7 = *(v6 + 5);
    v8 = *(v6 + 2);
    v9 = *(v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((a1 + *(*a1 - 24)));
      v10 = std::locale::use_facet(&__b, MEMORY[0x1E69E5318]);
      v9 = (v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *(v6 + 36) = v9;
    }

    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
    {
      v12 = a2 + a3;
    }

    else
    {
      v12 = a2;
    }

    if (!v7)
    {
      goto LABEL_27;
    }

    v13 = *(v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1 && (*(*v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_27;
    }

    if (v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
      {
        std::string::__throw_length_error[abi:ne200100]();
      }

      if (v16 >= 0x17)
      {
        operator new();
      }

      v22 = v16;
      memset(&__b, v9, v16);
      *(&__b.__locale_ + v16) = 0;
      if (v22 >= 0)
      {
        p_b = &__b;
      }

      else
      {
        p_b = __b.__locale_;
      }

      v18 = (*(*v7 + 96))(v7, p_b, v16);
      if (v22 < 0)
      {
        operator delete(__b.__locale_);
      }

      if (v18 != v16)
      {
        goto LABEL_27;
      }
    }

    if (v11 - v12 < 1 || (*(*v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *(v6 + 3) = 0;
    }

    else
    {
LABEL_27:
      std::ios_base::clear((a1 + *(*a1 - 24)), *(a1 + *(*a1 - 24) + 32) | 5);
    }
  }

  MEMORY[0x1B8C61C20](v20);
  return a1;
}

void sub_1B33149E0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
  }

  MEMORY[0x1B8C61C20](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((v17 + *(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1B33149B4);
}

void std::allocator_traits<geo::allocator_adapter<std::pair<gss::StylePropertyIndex,gss::PropertyID>,gss::zone_mallocator>>::deallocate[abi:ne200100](gss::zone_mallocator *a1)
{
  v2 = gss::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v2 + 32));
  atomic_fetch_add((v2 + 24), 0xFFFFFFFF);
  malloc_zone_free(*v2, a1);
  geo::read_write_lock::unlock((v2 + 32));
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gss::DashPattern>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 40 * a2, 0x108004014D1C949uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void std::allocator_traits<geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>::deallocate[abi:ne200100](gss::zone_mallocator *a1)
{
  v2 = gss::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v2 + 32));
  if (a1)
  {
    atomic_fetch_add((v2 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*v2, a1);
  geo::read_write_lock::unlock((v2 + 32));
}

void std::__shared_ptr_emplace<std::vector<gss::DashPattern,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>::__on_zero_shared_weak(gss::zone_mallocator *a1)
{
  v2 = gss::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v2 + 32));
  if (a1)
  {
    atomic_fetch_add((v2 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*v2, a1);
  geo::read_write_lock::unlock((v2 + 32));
}

void std::__shared_ptr_emplace<std::vector<gss::DashPattern,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>::__on_zero_shared(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1)
  {
    v3 = *(a1 + 40);
    v4 = *(a1 + 32);
    if (v3 != v1)
    {
      v5 = v3;
      do
      {
        v7 = *(v5 - 40);
        v5 -= 40;
        v6 = v7;
        if (v7)
        {
          *(v3 - 32) = v6;
          std::allocator_traits<geo::allocator_adapter<float,gss::zone_mallocator>>::deallocate[abi:ne200100](v6);
        }

        v3 = v5;
      }

      while (v5 != v1);
      v4 = *(a1 + 32);
    }

    *(a1 + 40) = v1;

    std::allocator_traits<geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>::deallocate[abi:ne200100](v4);
  }
}

void std::__shared_ptr_emplace<std::vector<gss::DashPattern,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>,geo::allocator_adapter<gss::DashPattern,gss::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5DB30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<std::vector<std::string,geo::allocator_adapter<std::string,gss::zone_mallocator>>,geo::allocator_adapter<std::string,gss::zone_mallocator>>::__on_zero_shared_weak(gss::zone_mallocator *a1)
{
  v2 = gss::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v2 + 32));
  if (a1)
  {
    atomic_fetch_add((v2 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*v2, a1);
  geo::read_write_lock::unlock((v2 + 32));
}

void std::__shared_ptr_emplace<std::vector<std::string,geo::allocator_adapter<std::string,gss::zone_mallocator>>,geo::allocator_adapter<std::string,gss::zone_mallocator>>::__on_zero_shared(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1)
  {
    v3 = *(a1 + 40);
    v4 = *(a1 + 32);
    if (v3 != v1)
    {
      do
      {
        v5 = *(v3 - 1);
        v3 -= 3;
        if (v5 < 0)
        {
          operator delete(*v3);
        }
      }

      while (v3 != v1);
      v4 = *(a1 + 32);
    }

    *(a1 + 40) = v1;

    std::allocator_traits<geo::allocator_adapter<std::string,gss::zone_mallocator>>::deallocate[abi:ne200100](v4);
  }
}

void std::__shared_ptr_emplace<std::vector<std::string,geo::allocator_adapter<std::string,gss::zone_mallocator>>,geo::allocator_adapter<std::string,gss::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5DB80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

const char *gss::to_string(int a1)
{
  result = "None";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "LineType";
      break;
    case 2:
      result = "BorderType";
      break;
    case 3:
      result = "AoiType";
      break;
    case 4:
      result = "Country";
      break;
    case 5:
      result = "FeatureType";
      break;
    case 6:
      result = "PoiType";
      break;
    case 7:
      result = "LandcoverType";
      break;
    case 8:
      result = "MinzoomRank";
      break;
    case 9:
    case 13:
    case 15:
    case 48:
    case 96:
    case 97:
    case 98:
    case 99:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 152:
LABEL_151:
      result = "Unknown";
      break;
    case 10:
      result = "Significance";
      break;
    case 11:
      result = "FerryType";
      break;
    case 12:
      result = "RailwayType";
      break;
    case 14:
      result = "BrunnelType";
      break;
    case 16:
      result = "PoiIconType";
      break;
    case 17:
      result = "DetailedLandcoverType";
      break;
    case 18:
      result = "NetworkClass";
      break;
    case 19:
      result = "RoofType";
      break;
    case 20:
      result = "LabelType";
      break;
    case 21:
      result = "RampType";
      break;
    case 22:
      result = "DisputedType";
      break;
    case 23:
      result = "RuralUrbanType";
      break;
    case 24:
      result = "DrivingSide";
      break;
    case 25:
      result = "WalkableType";
      break;
    case 26:
      result = "DrivableType";
      break;
    case 27:
      result = "DataSource";
      break;
    case 28:
      result = "BackgroundType";
      break;
    case 29:
      result = "PoiCompany";
      break;
    case 30:
      result = "TransitAgency";
      break;
    case 31:
      result = "RoadHierarchyClass";
      break;
    case 32:
      result = "TollType";
      break;
    case 33:
      result = "RampDirection";
      break;
    case 34:
      result = "ParentChildRelationship";
      break;
    case 35:
      result = "StrokeType";
      break;
    case 36:
      result = "RoadSurface";
      break;
    case 37:
      result = "TransitType";
      break;
    case 38:
      result = "VenueCategory";
      break;
    case 39:
      result = "VenueCategoryDetailed";
      break;
    case 40:
      result = "DebugShape";
      break;
    case 41:
      result = "LocalNorthRegion";
      break;
    case 42:
      result = "TransitNodeType";
      break;
    case 43:
      result = "Status";
      break;
    case 44:
      result = "RouteSignificance";
      break;
    case 45:
      result = "AccessPointType";
      break;
    case 46:
      result = "Polity";
      break;
    case 47:
      result = "PoiLandmark";
      break;
    case 49:
      result = "TransitSystemType";
      break;
    case 50:
      result = "TransitLineType";
      break;
    case 51:
      result = "TransitNodeId";
      break;
    case 52:
      result = "BrowseCategory";
      break;
    case 53:
      result = "TransitDisplayGroup";
      break;
    case 54:
      result = "TransitSystemSignificance";
      break;
    case 55:
      result = "CategoryType";
      break;
    case 56:
      result = "PolygonEdgeType";
      break;
    case 57:
      result = "TransitLineLabelConstraint";
      break;
    case 58:
      result = "TransitNodeLabelAnnotationConstraint";
      break;
    case 59:
      result = "TransitTransferStation";
      break;
    case 60:
      result = "AoiZoomRange";
      break;
    case 61:
      result = "RoadAccessType";
      break;
    case 62:
      result = "TransitAccessPointAccessType";
      break;
    case 63:
      result = "TransitAccessPointHasCuratedName";
      break;
    case 64:
      result = "VenueNodeType";
      break;
    case 65:
      result = "VenueType";
      break;
    case 66:
      result = "DisplaySection";
      break;
    case 67:
      result = "VenueGoInside";
      break;
    case 68:
      result = "LineInTransitData";
      break;
    case 69:
      result = "VenueLevelType";
      break;
    case 70:
      result = "CulDeSac";
      break;
    case 71:
      result = "Landcover";
      break;
    case 72:
      result = "AoiBoundary";
      break;
    case 73:
      result = "SbsmOverride";
      break;
    case 74:
      result = "MuninCoverage";
      break;
    case 75:
      result = "RoadSegmentRoadwayIsPedestrianNavigable";
      break;
    case 76:
      result = "RoadSegmentSideSidewalk";
      break;
    case 77:
      result = "RoadSegmentSideWalkable";
      break;
    case 78:
      result = "HasAssociation";
      break;
    case 79:
      result = "PointFeatureType";
      break;
    case 80:
      result = "TransportPolygonType";
      break;
    case 81:
      result = "CartographicMarkingType";
      break;
    case 82:
      result = "PoiClass";
      break;
    case 83:
      result = "SummaryType";
      break;
    case 84:
      result = "PoiContent";
      break;
    case 85:
      result = "LabelMinZoom";
      break;
    case 86:
      result = "RoadSegmentSideBikeable";
      break;
    case 87:
      result = "HasBikeLane";
      break;
    case 88:
      result = "TollProhibitedAreaPersistence";
      break;
    case 89:
      result = "Relevance";
      break;
    case 90:
      result = "RouteAnnotationType";
      break;
    case 91:
      result = "SpecialRoadSegmentType";
      break;
    case 92:
      result = "PhysicalFeature";
      break;
    case 93:
      result = "Currency";
      break;
    case 94:
      result = "Seasonality";
      break;
    case 95:
      result = "TransitSystemEnabled";
      break;
    case 100:
      result = "MeshType";
      break;
    case 101:
      result = "MarkingColor";
      break;
    case 102:
      result = "LaneMarkingType";
      break;
    case 103:
      result = "LaneMarkingStyle";
      break;
    case 104:
      result = "SurfaceMarkingType";
      break;
    case 105:
      result = "VegetationType";
      break;
    case 106:
      result = "VegetationTreePart";
      break;
    case 107:
      result = "RoadSurfaceClass";
      break;
    case 108:
      result = "TrafficSignType";
      break;
    case 109:
      result = "TrafficDevicePart";
      break;
    case 110:
      result = "PavementPatternStyle";
      break;
    case 150:
      result = "DebugOnly";
      break;
    case 151:
      result = "IsLuxoRegion";
      break;
    case 153:
      result = "ClimateTemperature";
      break;
    case 154:
      result = "ClimatePrecipitation";
      break;
    case 155:
      result = "FeatureRank";
      break;
    case 156:
      result = "HasDisplayElevationAnnotation";
      break;
    case 157:
      result = "LabelAnnotationType";
      break;
    case 158:
      result = "BuiltUpAreaType";
      break;
    case 159:
      result = "RelationshipToStructure";
      break;
    case 160:
      result = "ConsolidationType";
      break;
    case 161:
      result = "GeographicLineType";
      break;
    case 162:
      result = "ZoomPromotion";
      break;
    case 163:
      result = "TransitLineSignificance";
      break;
    case 164:
      result = "InMiniPoiMarket";
      break;
    case 165:
      result = "IslandType";
      break;
    case 166:
      result = "LabelModifier";
      break;
    case 167:
      result = "WaterDisplayType";
      break;
    case 168:
      result = "SubterraneanWater";
      break;
    case 169:
      result = "TransitNodeStationLmz";
      break;
    case 170:
      result = "SuppressInSpr";
      break;
    case 171:
      result = "IndoorVisibility";
      break;
    case 172:
      result = "IndigenousLandType";
      break;
    case 173:
      result = "IndigenousLandRecognition";
      break;
    case 174:
      result = "TerminalTransitNode";
      break;
    case 175:
      result = "HillShading";
      break;
    case 176:
      result = "TintBand";
      break;
    case 177:
      result = "ContourLine";
      break;
    case 178:
      result = "FormOfWay";
      break;
    case 179:
      result = "HillShadingGradual";
      break;
    case 180:
      result = "InHikingRegion";
      break;
    case 181:
      result = "MaskingType";
      break;
    case 182:
      result = "FeatureMinZoom";
      break;
    case 183:
      result = "FeatureMaxZoom";
      break;
    case 184:
      result = "InKittyhawkRegion";
      break;
    case 185:
      result = "HikingConveyance";
      break;
    case 186:
      result = "SuppressInHiking";
      break;
    case 187:
      result = "MasksFeatureType";
      break;
    case 188:
      result = "DisplayClass";
      break;
    case 189:
      result = "HasSupplementalData";
      break;
    case 190:
      result = "ContourLineType";
      break;
    case 191:
      result = "TravelDirectionType";
      break;
    case 192:
      result = "TemporalEvent";
      break;
    case 193:
      result = "PoiTierType";
      break;
    case 194:
      result = "ConstructionStatus";
      break;
    case 195:
      result = "PhysicalFeatureName";
      break;
    default:
      switch(a1)
      {
        case 65536:
          result = "MapMode";
          break;
        case 65537:
          result = "TimePeriod";
          break;
        case 65538:
          result = "SelectionState";
          break;
        case 65539:
          result = "AnnotationType";
          break;
        case 65540:
          result = "IconTappable";
          break;
        case 65541:
          result = "TargetDisplay";
          break;
        case 65542:
          result = "LanguageLocale";
          break;
        case 65543:
          result = "RouteProximity";
          break;
        case 65544:
          result = "TrafficIncidentType";
          break;
        case 65545:
          result = "When";
          break;
        case 65549:
          result = "OverlayType";
          break;
        case 65550:
          result = "ApplicationState";
          break;
        case 65552:
          result = "TransportType";
          break;
        case 65553:
          result = "FlyoverPlace";
          break;
        case 65554:
          result = "TransitOperationalState";
          break;
        case 65555:
          result = "TransitRoutesMerged";
          break;
        case 65556:
          result = "RouteSegmentWhen";
          break;
        case 65557:
          result = "TransitLineMergeType";
          break;
        case 65558:
          result = "TransitNodeImageType";
          break;
        case 65559:
          result = "ViewProximity";
          break;
        case 65560:
          result = "ViewportMinSize";
          break;
        case 65561:
          result = "VehicleIsParked";
          break;
        case 65562:
          result = "TransitLinkVisibleLineCount";
          break;
        case 65563:
          result = "TransitLineMultipleSystems";
          break;
        case 65564:
          result = "TransitLineMultipleLines";
          break;
        case 65565:
          result = "NavigationState";
          break;
        case 65566:
          result = "DistanceToCurrentManeuver";
          break;
        case 65567:
          result = "CustomFeatureType";
          break;
        case 65568:
          result = "Favorite";
          break;
        case 65569:
          result = "Event";
          break;
        case 65570:
          result = "SearchResult";
          break;
        case 65571:
          result = "RouteFeatureType";
          break;
        case 65572:
          result = "CustomFeature";
          break;
        case 65573:
          result = "PickingState";
          break;
        case 65574:
          result = "CurrentManeuverType";
          break;
        case 65575:
          result = "NextStepLength";
          break;
        case 65576:
          result = "CurrentIncidentType";
          break;
        case 65577:
          result = "CurrentManeuverComplexity";
          break;
        case 65578:
          result = "CurrentGroupedManeuverCount";
          break;
        case 65579:
          result = "TransitNodeVisibleLineCount";
          break;
        case 65580:
          result = "EventType";
          break;
        case 65581:
          result = "Cluster";
          break;
        case 65582:
          result = "ClusterHasMultipleCategories";
          break;
        case 65583:
          result = "ClusterIsOpen";
          break;
        case 65584:
          result = "OpenClusterElement";
          break;
        case 65585:
          result = "SearchAlongTheRoute";
          break;
        case 65586:
          result = "VehicleSpeed";
          break;
        case 65587:
          result = "SearchResultsType";
          break;
        case 65588:
          result = "CameraMode";
          break;
        case 65589:
          result = "NavLabelType";
          break;
        case 65590:
          result = "MapZoomLevel";
          break;
        case 65591:
          result = "TransitLinkMultipleSystems";
          break;
        case 65592:
          result = "NavCameraDetached";
          break;
        case 65593:
          result = "RoadSpeed";
          break;
        case 65594:
          result = "Occluded";
          break;
        case 65595:
          result = "NextManeuverRampType";
          break;
        case 65596:
          result = "MapHasLabels";
          break;
        case 65597:
          result = "ApplicationUILayout";
          break;
        case 65598:
          result = "CurrentStepLength";
          break;
        case 65599:
          result = "CategoryIconPresentation";
          break;
        case 65600:
          result = "NavigationDestination";
          break;
        case 65601:
          result = "VenueFeature";
          break;
        case 65602:
          result = "TrafficCameraType";
          break;
        case 65603:
          result = "DraggingState";
          break;
        case 65604:
          result = "VenueFeatureState";
          break;
        case 65605:
          result = "Emphasis";
          break;
        case 65606:
          result = "JetpackMode";
          break;
        case 65607:
          result = "EtaComparison";
          break;
        case 65608:
          result = "VenuesEnabled";
          break;
        case 65609:
          result = "VenuesFloorSwitcherActive";
          break;
        case 65610:
          result = "TransitNodeImageTypeDark";
          break;
        case 65611:
          result = "SettingsCategory";
          break;
        case 65612:
          result = "LabelComponent";
          break;
        case 65613:
          result = "FocusState";
          break;
        case 65614:
          result = "TrafficSignalType";
          break;
        case 65615:
          result = "RoadSignType";
          break;
        case 65616:
          result = "CollectionsType";
          break;
        case 65617:
          result = "GroundMode";
          break;
        case 65618:
          result = "EtaAdvisoryType";
          break;
        case 65619:
          result = "RouteTransportType";
          break;
        case 65620:
          result = "RouteLegWhen";
          break;
        case 65621:
          result = "RoadComplexity";
          break;
        case 65622:
          result = "PreviouslySelected";
          break;
        case 65623:
          result = "AlternateStyle";
          break;
        case 65624:
          result = "FlexPoint";
          break;
        case 65625:
          result = "FlexSelectionZone";
          break;
        case 65626:
          result = "Tier";
          break;
        case 65627:
          result = "IncidentDataSource";
          break;
        case 65628:
          result = "ClusterSize";
          break;
        case 65629:
          result = "DistanceToCurrentTrafficSection";
          break;
        case 65630:
          result = "CurrentTrafficState";
          break;
        case 65631:
          result = "Draped";
          break;
        case 65632:
          result = "ArLabelType";
          break;
        case 65633:
          result = "NextRoadComplexity";
          break;
        case 65634:
          result = "TransitCurrentManeuverType";
          break;
        case 65635:
          result = "RouteSinuosity";
          break;
        case 65636:
          result = "WindshieldMode";
          break;
        case 65637:
          result = "BifurcationType";
          break;
        case 65638:
          result = "Bridge";
          break;
        case 65639:
          result = "Tunnel";
          break;
        case 65640:
          result = "UrbanCanyon";
          break;
        case 65641:
          result = "ComplexOverpass";
          break;
        case 65642:
          result = "ComplexIntersection";
          break;
        case 65643:
          result = "LaneCount";
          break;
        case 65644:
          result = "TrafficCameraMode";
          break;
        case 65645:
          result = "ArLabelLayoutType";
          break;
        case 65646:
          result = "ArArrivalType";
          break;
        case 65647:
          result = "IsCovered";
          break;
        case 65648:
          result = "CameraPitch";
          break;
        case 65649:
          result = "Usage";
          break;
        case 65650:
          result = "MapkitUsage";
          break;
        case 65651:
          result = "PoiFiltering";
          break;
        case 65652:
          result = "NavCameraTransitionComplete";
          break;
        case 65653:
          result = "MapkitIconUsage";
          break;
        case 65654:
          result = "ClientSymbol";
          break;
        case 65655:
          result = "CarDisplayType";
          break;
        case 65656:
          result = "CarDisplayConfig";
          break;
        case 65657:
          result = "ScreenFeatureType";
          break;
        case 65659:
          result = "HikingEnabled";
          break;
        case 65660:
          result = "HikingFeatureState";
          break;
        case 65661:
          result = "RtEvChargingAnnotationType";
          break;
        case 65662:
          result = "MapkitClientMode";
          break;
        case 65663:
          result = "PlatterFocus";
          break;
        case 65664:
          result = "OfflineRegionSelector";
          break;
        case 65666:
          result = "MapPurpose";
          break;
        case 65667:
          result = "OfflineMode";
          break;
        case 65668:
          result = "ApplicationSubState";
          break;
        case 65669:
          result = "RouteSource";
          break;
        case 65670:
          result = "RoutePointManeuverType";
          break;
        case 65671:
          result = "IncreaseContrast";
          break;
        case 65672:
          result = "LevelOfDetail";
          break;
        case 65673:
          result = "DodgeballType";
          break;
        case 65674:
          result = "NewInterfaceEnabled";
          break;
        default:
          goto LABEL_151;
      }

      break;
  }

  return result;
}

{
  v1 = "Unknown";
  if (a1 == 1)
  {
    v1 = "FacePerpendicular";
  }

  if (a1)
  {
    return v1;
  }

  else
  {
    return "FaceAligned";
  }
}

{
  v1 = "Unknown";
  if (a1 == 1)
  {
    v1 = "Wind";
  }

  if (a1)
  {
    return v1;
  }

  else
  {
    return "Standard";
  }
}

{
  v1 = "Unknown";
  if (a1 == 1)
  {
    v1 = "True";
  }

  if (a1)
  {
    return v1;
  }

  else
  {
    return "False";
  }
}

const char *gss::to_string(int a1, int a2)
{
  result = "";
  switch(a1)
  {
    case 1:
      if ((a2 - 1) > 0x1Fu)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B41AD8;
      return v5[v4];
    case 2:
      if (a2 > 0xAu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B3F610;
      return v5[v4];
    case 3:
      if (a2 > 0x76u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x7F;
      v5 = off_1E7B3F210;
      return v5[v4];
    case 4:
      if (a2 > 0x102)
      {
        return "Unknown";
      }

      v13 = off_1E7B3F8A0;
      return v13[a2];
    case 5:
      if ((a2 - 1) > 0x17u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B40FB0;
      return v5[v4];
    case 6:
      if (a2 > 0x1EF)
      {
        return "Unknown";
      }

      v13 = off_1E7B44458;
      return v13[a2];
    case 7:
      if (a2 > 0x27u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x3F;
      v5 = off_1E7B41460;
      return v5[v4];
    case 8:
    case 9:
    case 13:
    case 15:
    case 18:
    case 48:
    case 96:
    case 97:
    case 98:
    case 99:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 152:
      return result;
    case 10:
      if (a2 > 0x10u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B45EA0;
      return v5[v4];
    case 11:
      v6 = "Unknown";
      v8 = "Ferry";
      goto LABEL_252;
    case 12:
      v14 = a2 ^ 0x80;
      v15 = off_1E7B453D8;
      return v15[v14];
    case 14:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57588;
      return v5[v4];
    case 16:
      v10 = a2;
      v11 = "Unknown";
      v12 = "Custom";
      goto LABEL_242;
    case 17:
      if (a2 > 0x20u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x3F;
      v5 = off_1E7B40B80;
      return v5[v4];
    case 19:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B575A8;
      return v5[v4];
    case 20:
      v6 = "Unknown";
      v8 = "Polygon";
      goto LABEL_252;
    case 21:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57AF0;
      return v5[v4];
    case 22:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Disputed";
      }

      v7 = a2 == 0;
      v8 = "NonDisputed";
      goto LABEL_8;
    case 23:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Urban";
      }

      v7 = a2 == 0;
      v8 = "Rural";
      goto LABEL_8;
    case 24:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Left";
      }

      v7 = a2 == 0;
      v8 = "Right";
      goto LABEL_8;
    case 25:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Walkable";
      }

      v7 = a2 == 0;
      v8 = "NonWalkable";
      goto LABEL_8;
    case 26:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Drivable";
      }

      v7 = a2 == 0;
      v8 = "NonDrivable";
      goto LABEL_8;
    case 27:
      if ((a2 & 0xF8) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B40AE0;
      return v5[v4];
    case 28:
      v10 = a2;
      v11 = "Unknown";
      v12 = "Water";
      goto LABEL_242;
    case 29:
      v14 = a2 ^ 0x80;
      v15 = off_1E7B421A0;
      return v15[v14];
    case 30:
      if ((a2 - 1) > 0x4Du)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B46350;
      return v5[v4];
    case 31:
      if ((a2 - 1) >= 5u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B575C0;
      return v5[v4];
    case 32:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Toll";
      }

      v7 = a2 == 0;
      v8 = "NonToll";
      goto LABEL_8;
    case 33:
      if ((a2 - 1) >= 3u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B575E8;
      return v5[v4];
    case 34:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57600;
      return v5[v4];
    case 35:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Normal";
      }

      v7 = a2 == 0;
      v8 = "None";
      goto LABEL_8;
    case 36:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Unpaved";
      }

      v7 = a2 == 0;
      v8 = "Paved";
      goto LABEL_8;
    case 37:
      if (a2 > 902)
      {
        if (a2 <= 1199)
        {
          if (a2 > 905)
          {
            switch(a2)
            {
              case 1000:
                result = "WaterTransportService";
                break;
              case 1001:
                result = "InternationalCarFerryService";
                break;
              case 1002:
                result = "NationalCarFerryService";
                break;
              case 1003:
                result = "RegionalCarFerryService";
                break;
              case 1004:
                result = "LocalCarFerryService";
                break;
              case 1005:
                result = "InternationalPassengerFerryService";
                break;
              case 1006:
                result = "NationalPassengerFerryService";
                break;
              case 1007:
                result = "RegionalPassengerFerryService";
                break;
              case 1008:
                result = "LocalPassengerFerryService";
                break;
              case 1009:
                result = "PostBoatService";
                break;
              case 1010:
                result = "TrainFerryService";
                break;
              case 1011:
                result = "RoadLinkFerryService";
                break;
              case 1012:
                result = "AirportLinkFerryService";
                break;
              case 1013:
                result = "CarHighSpeedFerryService";
                break;
              case 1014:
                result = "PassengerHighSpeedFerryService";
                break;
              case 1015:
                result = "SightseeingBoatService";
                break;
              case 1016:
                result = "SchoolBoat";
                break;
              case 1017:
                result = "CableDrawnBoatService";
                break;
              case 1018:
                result = "RiverBusService";
                break;
              case 1019:
                result = "ScheduledFerryService";
                break;
              case 1020:
                result = "ShuttleFerryService";
                break;
              case 1021:
                result = "AllWaterTransportServices";
                break;
              default:
                switch(a2)
                {
                  case 1100:
                    result = "AirService";
                    break;
                  case 1101:
                    result = "InternationalAirService";
                    break;
                  case 1102:
                    result = "DomesticAirService";
                    break;
                  case 1103:
                    result = "IntercontinentalAirService";
                    break;
                  case 1104:
                    result = "DomesticScheduledAirService";
                    break;
                  case 1105:
                    result = "ShuttleAirService";
                    break;
                  case 1106:
                    result = "IntercontinentalCharterAirService";
                    break;
                  case 1107:
                    result = "InternationalCharterAirService";
                    break;
                  case 1108:
                    result = "RoundTripCharterAirService";
                    break;
                  case 1109:
                    result = "SightseeingAirService";
                    break;
                  case 1110:
                    result = "HelicopterAirService";
                    break;
                  case 1111:
                    result = "DomesticCharterAirService";
                    break;
                  case 1112:
                    result = "SchengenAreaAirService";
                    break;
                  case 1113:
                    result = "AirshipService";
                    break;
                  case 1114:
                    result = "AllAirServices";
                    break;
                  default:
                    if (a2 != 906)
                    {
                      return "Unknown";
                    }

                    result = "AllTramServices";
                    break;
                }

                break;
            }
          }

          else if (a2 == 903)
          {
            return "RegionalTramService";
          }

          else if (a2 == 904)
          {
            return "SightseeingTramService";
          }

          else
          {
            return "ShuttleTramService";
          }

          return result;
        }

        if (a2 > 1501)
        {
          if (a2 > 1600)
          {
            if (a2 <= 1603)
            {
              if (a2 == 1601)
              {
                return "HireCar";
              }

              if (a2 == 1602)
              {
                return "HireVan";
              }

              return "HireMotorbike";
            }

            if (a2 > 1700)
            {
              if (a2 == 1701)
              {
                return "HorseDrawnCarriage";
              }

              if (a2 == 1800)
              {
                return "BRTService";
              }
            }

            else
            {
              if (a2 == 1604)
              {
                return "HireCycle";
              }

              if (a2 == 1700)
              {
                return "MiscellaneousService";
              }
            }
          }

          else
          {
            if (a2 <= 1504)
            {
              if (a2 == 1502)
              {
                return "WaterTaxiService";
              }

              if (a2 == 1503)
              {
                return "RailTaxiService";
              }

              return "BikeTaxiService";
            }

            if (a2 <= 1506)
            {
              if (a2 == 1505)
              {
                return "LicensedTaxiService";
              }

              else
              {
                return "PrivateHireServiceVehicle";
              }
            }

            if (a2 == 1507)
            {
              return "AllTaxiServices";
            }

            if (a2 == 1600)
            {
              return "SelfDrive";
            }
          }
        }

        else if (a2 > 1305)
        {
          if (a2 <= 1400)
          {
            switch(a2)
            {
              case 1306:
                return "SmallTelecabinService";
              case 1307:
                return "AllTelecabinServices";
              case 1400:
                return "FunicularService";
            }
          }

          else
          {
            if (a2 > 1499)
            {
              if (a2 == 1500)
              {
                return "TaxiService";
              }

              else
              {
                return "CommunalTaxiService";
              }
            }

            if (a2 == 1401)
            {
              return "FunicularServiceMinor";
            }

            if (a2 == 1402)
            {
              return "AllFunicularService";
            }
          }
        }

        else
        {
          if (a2 > 1301)
          {
            if (a2 > 1303)
            {
              if (a2 == 1304)
              {
                return "ChairLiftService";
              }

              else
              {
                return "DragLiftService";
              }
            }

            else if (a2 == 1302)
            {
              return "CableCarService";
            }

            else
            {
              return "ElevatorService";
            }
          }

          switch(a2)
          {
            case 1200:
              return "FerryService";
            case 1300:
              return "TelecabinService";
            case 1301:
              return "TelecabinServiceMinor";
          }
        }

        return "Unknown";
      }

      if (a2 > 205)
      {
        if (a2 <= 699)
        {
          if (a2 <= 400)
          {
            if (a2 <= 208)
            {
              if (a2 == 206)
              {
                return "SightseeingCoachService";
              }

              if (a2 == 207)
              {
                return "TouristCoachService";
              }

              return "CommuterCoachService";
            }

            switch(a2)
            {
              case 209:
                return "AllCoachServices";
              case 300:
                return "SuburbanRailwayService";
              case 400:
                return "UrbanRailwayService";
            }
          }

          else
          {
            if (a2 <= 403)
            {
              if (a2 == 401)
              {
                return "MetroService";
              }

              if (a2 == 402)
              {
                return "UndergroundService";
              }

              return "UrbanRailwayServiceMinor";
            }

            if (a2 > 499)
            {
              if (a2 == 500)
              {
                return "MetroServiceMajor";
              }

              if (a2 == 600)
              {
                return "UndergroundServiceMajor";
              }
            }

            else
            {
              if (a2 == 404)
              {
                return "AllUrbanRailwayServices";
              }

              if (a2 == 405)
              {
                return "MonorailService";
              }
            }
          }

          return "Unknown";
        }

        if (a2 > 799)
        {
          if (a2 > 900)
          {
            if (a2 == 901)
            {
              return "CityTramService";
            }

            else
            {
              return "LocalTramService";
            }
          }

          if (a2 == 800)
          {
            return "TrolleybusService";
          }

          if (a2 == 900)
          {
            return "TramService";
          }

          return "Unknown";
        }

        switch(a2)
        {
          case 700:
            result = "BusService";
            break;
          case 701:
            result = "RegionalBusService";
            break;
          case 702:
            result = "ExpressBusService";
            break;
          case 703:
            result = "StoppingBusService";
            break;
          case 704:
            result = "LocalBusService";
            break;
          case 705:
            result = "NightBusService";
            break;
          case 706:
            result = "PostBusService";
            break;
          case 707:
            result = "SpecialNeedsBus";
            break;
          case 708:
            result = "MobilityBusService";
            break;
          case 709:
            result = "MobilityBusForRegisteredDisabled";
            break;
          case 710:
            result = "SightseeingBus";
            break;
          case 711:
            result = "ShuttleBus";
            break;
          case 712:
            result = "SchoolBus";
            break;
          case 713:
            result = "SchoolAndPublicServiceBus";
            break;
          case 714:
            result = "RailReplacementBusService";
            break;
          case 715:
            result = "DemandAndResponseBusService";
            break;
          case 716:
            result = "AllBusServices";
            break;
          default:
            return "Unknown";
        }
      }

      else
      {
        if (a2 <= 99)
        {
          if (a2 > 4)
          {
            if (a2 <= 6)
            {
              if (a2 == 5)
              {
                return "CableCar";
              }

              else
              {
                return "AerialTramway";
              }
            }

            switch(a2)
            {
              case 7:
                return "Funicular";
              case 8:
                return "HighSpeedRail";
              case 12:
                return "Monorail";
            }
          }

          else
          {
            if (a2 > 1)
            {
              if (a2 == 2)
              {
                return "Rail";
              }

              if (a2 == 3)
              {
                return "Bus";
              }

              return "Ferry";
            }

            if (!a2)
            {
              return "LightRail";
            }

            if (a2 == 1)
            {
              return "Subway";
            }
          }

          return "Unknown";
        }

        if (a2 > 199)
        {
          if (a2 > 202)
          {
            if (a2 == 203)
            {
              return "ShuttleCoachService";
            }

            else if (a2 == 204)
            {
              return "RegionalCoachService";
            }

            else
            {
              return "SpecialCoachService";
            }
          }

          else if (a2 == 200)
          {
            return "CoachService";
          }

          else if (a2 == 201)
          {
            return "InternationalCoachService";
          }

          else
          {
            return "NationalCoachService";
          }
        }

        else
        {
          switch(a2)
          {
            case 'd':
              result = "RailwayService";
              break;
            case 'e':
              result = "HighSpeedRailService";
              break;
            case 'f':
              result = "LongDistanceTrains";
              break;
            case 'g':
              result = "InterRegionalRailService";
              break;
            case 'h':
              result = "CarTransportRailService";
              break;
            case 'i':
              result = "SleeperRailService";
              break;
            case 'j':
              result = "RegionalRailService";
              break;
            case 'k':
              result = "TouristRailwayService";
              break;
            case 'l':
              result = "RailShuttleWithinComplex";
              break;
            case 'm':
              result = "SuburbanRailway";
              break;
            case 'n':
              result = "ReplacementRailService";
              break;
            case 'o':
              result = "SpecialRailService";
              break;
            case 'p':
              result = "LorryTransportRailService";
              break;
            case 'q':
              result = "AllRailServices";
              break;
            case 'r':
              result = "CrossCountryRailService";
              break;
            case 's':
              result = "VehicleTransportRailService";
              break;
            case 't':
              result = "RackAndPinionRailway";
              break;
            case 'u':
              result = "AdditionalRailService";
              break;
            default:
              return "Unknown";
          }
        }
      }

      return result;
    case 38:
      if (a2 > 0xAu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B57390;
      return v5[v4];
    case 39:
      if (a2 > 0x11u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B573E8;
      return v5[v4];
    case 40:
      if (a2 > 0xBu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B40B20;
      return v5[v4];
    case 41:
      if (a2 > 0x12u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B41BD8;
      return v5[v4];
    case 42:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57618;
      return v5[v4];
    case 43:
      if (a2 > 9u)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B45F28;
      return v5[v4];
    case 44:
      if (a2 > 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B45E08;
      return v5[v4];
    case 45:
      if (a2 > 0xBu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B3F1B0;
      return v5[v4];
    case 46:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57638;
      return v5[v4];
    case 47:
      if (a2 > 0x356)
      {
        return "Unknown";
      }

      v13 = off_1E7B429A0;
      return v13[a2];
    case 49:
      if ((a2 - 1) > 0xEA4)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B4FD48;
      return v5[v4];
    case 50:
      if (((a2 - 5) >> 1) > 0x8A2u)
      {
        return "Unknown";
      }

      v4 = (a2 - 5);
      v5 = off_1E7B46A40;
      return v5[v4];
    case 51:
      v14 = a2 ^ 0x80;
      v15 = off_1E7B4F470;
      return v15[v14];
    case 52:
      if (a2 > 0x15u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B3F668;
      return v5[v4];
    case 53:
      if (a2 > 0x7Du)
      {
        return "Unknown";
      }

      v4 = a2 & 0x7F;
      v5 = off_1E7B46618;
      return v5[v4];
    case 54:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B57658;
      return v5[v4];
    case 55:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B57680;
      return v5[v4];
    case 56:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B576A8;
      return v5[v4];
    case 57:
      if ((a2 - 1) >= 4u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B576D0;
      return v5[v4];
    case 58:
      if ((a2 - 1) >= 3u)
      {
        return "Unknown";
      }

      return off_1E7B576F0[(a2 - 1)];
    case 59:
    case 63:
    case 66:
    case 67:
    case 68:
    case 70:
    case 72:
    case 73:
    case 75:
    case 95:
    case 150:
    case 151:
    case 156:
    case 164:
    case 168:
    case 170:
    case 174:
    case 176:
    case 180:
    case 184:
    case 186:
    case 189:
LABEL_5:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "True";
      }

      v7 = a2 == 0;
      v8 = "False";
      goto LABEL_8;
    case 60:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57708;
      return v5[v4];
    case 61:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "AuthorizedVehicles";
      }

      v7 = a2 == 0;
      v8 = "NoRestrictions";
      goto LABEL_8;
    case 62:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "ToUndergroundLevel";
      }

      v7 = a2 == 0;
      v8 = "ToGroundLevel";
      goto LABEL_8;
    case 64:
      if ((a2 & 0xF8) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B57478;
      return v5[v4];
    case 65:
      if (a2 > 0x12u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B574B8;
      return v5[v4];
    case 69:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Outdoor";
      }

      v7 = a2 == 0;
      v8 = "Indoor";
      goto LABEL_8;
    case 71:
      if (a2 > 0x27u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x3F;
      v5 = off_1E7B41320;
      return v5[v4];
    case 74:
      v6 = "Unknown";
      v8 = "Available";
      goto LABEL_252;
    case 76:
    case 77:
    case 86:
    case 87:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57740;
      return v5[v4];
    case 78:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "VenueAmenity";
      }

      v7 = a2 == 0;
      v8 = "TransitAccessPoint";
      goto LABEL_8;
    case 79:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57720;
      return v5[v4];
    case 80:
      if (a2 > 0x14u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B57270;
      return v5[v4];
    case 81:
      if (a2 > 0xCu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B3F718;
      return v5[v4];
    case 82:
      if (a2 > 0xEu)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B42128;
      return v5[v4];
    case 83:
      if (a2 > 8u)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B45F78;
      return v5[v4];
    case 84:
      v6 = "Unknown";
      v9 = "Summary";
      goto LABEL_412;
    case 85:
    case 169:
    case 182:
    case 183:
      if (a2 > 0x14u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B4FC70;
      return v5[v4];
    case 88:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57760;
      return v5[v4];
    case 89:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B45BD8;
      return v5[v4];
    case 90:
      if (a2 > 0x15u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B45D20;
      return v5[v4];
    case 91:
      v6 = "Unknown";
      v9 = "IntersectionInternal";
      goto LABEL_412;
    case 92:
      if (a2 > 0x38u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x3F;
      v5 = off_1E7B41EC0;
      return v5[v4];
    case 93:
      if (a2 > 0x12E)
      {
        return "Unknown";
      }

      v13 = off_1E7B400B8;
      return v13[a2];
    case 94:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "PeriodicOrIrregular";
      }

      v7 = a2 == 0;
      v8 = "Perennial";
      goto LABEL_8;
    case 100:
      if (a2 > 0x1Bu)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B41CB0;
      return v5[v4];
    case 101:
      if ((a2 - 1) >= 5u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B57778;
      return v5[v4];
    case 102:
      if ((a2 - 1) > 9u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B41690;
      return v5[v4];
    case 103:
      if ((a2 - 1) >= 3u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B577A0;
      return v5[v4];
    case 104:
      if ((a2 - 1) > 0x41u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B45FC0;
      return v5[v4];
    case 105:
      if ((a2 - 1) >= 4u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B577B8;
      return v5[v4];
    case 106:
      v10 = a2;
      v11 = "Unknown";
      if (a2 == 2)
      {
        v11 = "Trunk";
      }

      v12 = "Leaves";
      goto LABEL_242;
    case 107:
      if ((a2 - 1) > 6u)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B45CE8;
      return v5[v4];
    case 108:
      v10 = a2;
      v11 = "Unknown";
      if (a2 == 2)
      {
        v11 = "Yield";
      }

      v12 = "Stop";
      goto LABEL_242;
    case 109:
      v10 = a2;
      v11 = "Unknown";
      if (a2 == 2)
      {
        v11 = "Support";
      }

      v12 = "Main";
LABEL_242:
      if (v10 == 1)
      {
        return v12;
      }

      else
      {
        return v11;
      }

    case 110:
      if ((a2 - 1) > 0xCu)
      {
        return "Unknown";
      }

      v4 = (a2 - 1);
      v5 = off_1E7B41E58;
      return v5[v4];
    case 153:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B3F7B0;
      return v5[v4];
    case 154:
      if (a2 > 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B3F780;
      return v5[v4];
    case 155:
      if (a2 > 0x16u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B40EF8;
      return v5[v4];
    case 157:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B577D8;
      return v5[v4];
    case 158:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57800;
      return v5[v4];
    case 159:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57818;
      return v5[v4];
    case 160:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57830;
      return v5[v4];
    case 161:
      if (a2 > 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B41208;
      return v5[v4];
    case 162:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B57550;
      return v5[v4];
    case 163:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B46A08;
      return v5[v4];
    case 165:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57848;
      return v5[v4];
    case 166:
      v6 = "Unknown";
      v9 = "HideLabel";
LABEL_412:
      if (a2 == 1)
      {
        v6 = v9;
      }

      v7 = a2 == 0;
      v8 = "None";
      goto LABEL_8;
    case 167:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Oceanic";
      }

      v7 = a2 == 0;
      v8 = "Inland";
      goto LABEL_8;
    case 171:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B57868;
      return v5[v4];
    case 172:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B41280;
      return v5[v4];
    case 173:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57890;
      return v5[v4];
    case 175:
      if (a2 >= 3u)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B578A8;
      return v5[v4];
    case 177:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "Major";
      }

      v7 = a2 == 0;
      v8 = "Minor";
      goto LABEL_8;
    case 178:
      if (a2 > 0x32u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x3F;
      v5 = off_1E7B41070;
      return v5[v4];
    case 179:
      if (a2 > 8u)
      {
        return "Unknown";
      }

      v4 = a2 & 0xF;
      v5 = off_1E7B41238;
      return v5[v4];
    case 181:
      v6 = "Unknown";
      v8 = "Offline";
      goto LABEL_252;
    case 185:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B578C0;
      return v5[v4];
    case 187:
      v6 = "Unknown";
      v8 = "Hillshading";
      goto LABEL_252;
    case 188:
      if (a2 > 0x10u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B40C88;
      return v5[v4];
    case 190:
      if (a2 >= 5u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B578E0;
      return v5[v4];
    case 191:
      v6 = "Unknown";
      if (a2 == 1)
      {
        v6 = "TwoWay";
      }

      v7 = a2 == 0;
      v8 = "OneWay";
      goto LABEL_8;
    case 192:
      v6 = "Unknown";
      v8 = "Olympics";
LABEL_252:
      v7 = a2 == 0;
LABEL_8:
      if (v7)
      {
        return v8;
      }

      else
      {
        return v6;
      }

    case 193:
      if ((a2 & 0xFC) != 0)
      {
        return "Unknown";
      }

      v4 = a2 & 3;
      v5 = off_1E7B57908;
      return v5[v4];
    case 194:
      if (a2 > 6u)
      {
        return "Unknown";
      }

      v4 = a2 & 7;
      v5 = off_1E7B3F868;
      return v5[v4];
    case 195:
      if (a2 > 0x13u)
      {
        return "Unknown";
      }

      v4 = a2 & 0x1F;
      v5 = off_1E7B42088;
      return v5[v4];
    default:
      switch(a1)
      {
        case 65536:
          if ((a2 & 0xF8) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B41C70;
          return v5[v4];
        case 65537:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Night";
          }

          v7 = a2 == 0;
          v8 = "Day";
          goto LABEL_8;
        case 65538:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57928;
          return v5[v4];
        case 65539:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "LocationGem";
          }

          v7 = a2 == 0;
          v8 = "Pin";
          goto LABEL_8;
        case 65540:
        case 65624:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "False";
          }

          v7 = a2 == 0;
          v8 = "True";
          goto LABEL_8;
        case 65541:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57948;
          return v5[v4];
        case 65542:
          if (a2 > 0x7Eu)
          {
            return "Unknown";
          }

          v4 = a2 & 0x7F;
          v5 = off_1E7B416E0;
          return v5[v4];
        case 65543:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57960;
          return v5[v4];
        case 65544:
          if ((a2 - 1) > 0x28u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B46208;
          return v5[v4];
        case 65545:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B57978;
          return v5[v4];
        case 65549:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B579A0;
          return v5[v4];
        case 65550:
          if (a2 > 8u)
          {
            return "Unknown";
          }

          v4 = a2 & 0xF;
          v5 = off_1E7B3F5C8;
          return v5[v4];
        case 65552:
        case 65619:
          if (a2 > 5u)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B57318;
          return v5[v4];
        case 65553:
        case 65555:
        case 65561:
        case 65563:
        case 65564:
        case 65568:
        case 65569:
        case 65570:
        case 65572:
        case 65581:
        case 65582:
        case 65583:
        case 65584:
        case 65585:
        case 65591:
        case 65592:
        case 65594:
        case 65596:
        case 65601:
        case 65606:
        case 65608:
        case 65609:
        case 65622:
        case 65631:
        case 65636:
        case 65638:
        case 65639:
        case 65640:
        case 65641:
        case 65642:
        case 65644:
        case 65647:
        case 65651:
        case 65652:
        case 65659:
        case 65663:
        case 65664:
        case 65667:
        case 65671:
          goto LABEL_5;
        case 65554:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Closed";
          }

          v7 = a2 == 0;
          v8 = "Open";
          goto LABEL_8;
        case 65556:
        case 65620:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57BA8;
          return v5[v4];
        case 65557:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B579B8;
          return v20[v19];
        case 65558:
        case 65610:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57B70;
          return v5[v4];
        case 65559:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B579D8;
          return v5[v4];
        case 65560:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B579F0;
          return v20[v19];
        case 65562:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57A10;
          return v20[v19];
        case 65565:
          if ((a2 & 0xF8) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B41DD8;
          return v20[v19];
        case 65566:
        case 65575:
        case 65598:
        case 65629:
          if ((a2 - 1) > 7u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B41E18;
          return v5[v4];
        case 65567:
          if ((a2 - 1) >= 3u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B57A30;
          return v5[v4];
        case 65571:
          if ((a2 - 1) > 6u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B45DD0;
          return v5[v4];
        case 65573:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57A48;
          return v20[v19];
        case 65574:
          if ((a2 & 0xF0) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 0xF;
          v5 = off_1E7B40A60;
          return v5[v4];
        case 65576:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B57A60;
          return v20[v19];
        case 65577:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Complex";
          }

          v7 = a2 == 0;
          v8 = "Simple";
          goto LABEL_8;
        case 65578:
          if (a2 > 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B40A30;
          return v20[v19];
        case 65579:
          if (a2 > 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B4FD18;
          return v20[v19];
        case 65580:
          if ((a2 - 1) >= 4u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B57A88;
          return v5[v4];
        case 65586:
          if ((a2 - 1) > 8u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B57348;
          return v5[v4];
        case 65587:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B57AA8;
          return v20[v19];
        case 65588:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57AD0;
          return v5[v4];
        case 65589:
          if (a2 > 8u)
          {
            return "Unknown";
          }

          v4 = a2 & 0xF;
          v5 = off_1E7B41D90;
          return v5[v4];
        case 65590:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "HighZoom";
          }

          v7 = a2 == 0;
          v8 = "LowZoom";
          goto LABEL_8;
        case 65593:
          if (a2 > 0x10u)
          {
            return "Unknown";
          }

          v4 = a2 & 0x1F;
          v5 = off_1E7B45C60;
          return v5[v4];
        case 65595:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57AF0;
          return v5[v4];
        case 65597:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57B08;
          return v5[v4];
        case 65599:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57B20;
          return v5[v4];
        case 65600:
          v16 = a2;
          v17 = "Unknown";
          if (a2 == 1)
          {
            v17 = "Confirmed";
          }

          v18 = "Unconfirmed";
          goto LABEL_442;
        case 65602:
          if ((a2 - 1) > 6u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B461D0;
          return v5[v4];
        case 65603:
          v6 = "Unknown";
          v9 = "Dragging";
          goto LABEL_412;
        case 65604:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "PlaceholderForMissingFloor";
          }

          v7 = a2 == 0;
          v8 = "OnCorrectFloor";
          goto LABEL_8;
        case 65605:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57B38;
          return v5[v4];
        case 65607:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57B50;
          return v5[v4];
        case 65611:
          if (a2 > 0xCu)
          {
            return "Unknown";
          }

          v4 = a2 & 0xF;
          v5 = off_1E7B45E38;
          return v5[v4];
        case 65612:
          if (a2 > 0xCu)
          {
            return "Unknown";
          }

          v19 = a2 & 0xF;
          v20 = off_1E7B412B8;
          return v20[v19];
        case 65613:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Focused";
          }

          v7 = a2 == 0;
          v8 = "Unfocused";
          goto LABEL_8;
        case 65614:
          v16 = a2;
          v17 = "Unknown";
          if (a2 == 1)
          {
            v17 = "StopSign";
          }

          v18 = "StopLight";
LABEL_442:
          if (v16 == 2)
          {
            return v18;
          }

          else
          {
            return v17;
          }

        case 65615:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57B90;
          return v20[v19];
        case 65616:
          if ((a2 & 0xF8) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B3F828;
          return v5[v4];
        case 65617:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Elevated";
          }

          v7 = a2 == 0;
          v8 = "Flat";
          goto LABEL_8;
        case 65618:
          if ((a2 - 1) > 0x35u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B40D48;
          return v5[v4];
        case 65621:
        case 65633:
          if (a2 > 9u)
          {
            return "Unknown";
          }

          v4 = a2 & 0xF;
          v5 = off_1E7B45C10;
          return v5[v4];
        case 65623:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57BC0;
          return v5[v4];
        case 65625:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57BD8;
          return v20[v19];
        case 65626:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B57BF8;
          return v20[v19];
        case 65627:
          if ((a2 - 1) >= 3u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B57C20;
          return v5[v4];
        case 65628:
          if ((a2 & 0xF8) != 0)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B3F7E8;
          return v5[v4];
        case 65630:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B57C38;
          return v5[v4];
        case 65632:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57C60;
          return v20[v19];
        case 65634:
          if (a2 > 0xAu)
          {
            return "Unknown";
          }

          v19 = a2 & 0xF;
          v20 = off_1E7B465C0;
          return v20[v19];
        case 65635:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v19 = a2 & 7;
          v20 = off_1E7B57C78;
          return v20[v19];
        case 65637:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57CA0;
          return v20[v19];
        case 65643:
          if (a2 > 0x1Du)
          {
            return "Unknown";
          }

          v4 = a2 & 0x1F;
          v5 = off_1E7B415A0;
          return v5[v4];
        case 65645:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "FacePerpendicular";
          }

          v7 = a2 == 0;
          v8 = "FaceAligned";
          goto LABEL_8;
        case 65646:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Address";
          }

          v7 = a2 == 0;
          v8 = "Storefront";
          goto LABEL_8;
        case 65648:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "TopDown";
          }

          v7 = a2 == 0;
          v8 = "Pitched";
          goto LABEL_8;
        case 65649:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "MapKit";
          }

          v7 = a2 == 0;
          v8 = "Maps";
          goto LABEL_8;
        case 65650:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57CB8;
          return v20[v19];
        case 65653:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57CD0;
          return v20[v19];
        case 65654:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57CE8;
          return v5[v4];
        case 65655:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57D00;
          return v20[v19];
        case 65656:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57D18;
          return v5[v4];
        case 65657:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57D30;
          return v5[v4];
        case 65660:
          if (a2 >= 5u)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B57D48;
          return v5[v4];
        case 65661:
          if ((a2 & 0xFC) != 0)
          {
            return "Unknown";
          }

          v19 = a2 & 3;
          v20 = off_1E7B57D70;
          return v20[v19];
        case 65662:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "Wind";
          }

          v7 = a2 == 0;
          v8 = "Standard";
          goto LABEL_8;
        case 65666:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "NonInteractive";
          }

          v7 = a2 == 0;
          v8 = "Interactive";
          goto LABEL_8;
        case 65668:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "RouteCreation";
          }

          v7 = a2 == 0;
          v8 = "Default";
          goto LABEL_8;
        case 65669:
          if ((a2 - 1) >= 4u)
          {
            return "Unknown";
          }

          v4 = (a2 - 1);
          v5 = off_1E7B57D90;
          return v5[v4];
        case 65670:
          v6 = "Unknown";
          v9 = "TurnAround";
          goto LABEL_412;
        case 65672:
          if (a2 >= 3u)
          {
            return "Unknown";
          }

          v4 = a2 & 3;
          v5 = off_1E7B57DB0;
          return v5[v4];
        case 65673:
          if (a2 > 6u)
          {
            return "Unknown";
          }

          v4 = a2 & 7;
          v5 = off_1E7B40D10;
          return v5[v4];
        case 65674:
          v6 = "Unknown";
          if (a2 == 1)
          {
            v6 = "True";
          }

          v7 = a2 == 0;
          v8 = "False";
          goto LABEL_8;
        default:
          return result;
      }
  }
}

void *gss::defaultValueForKey<gss::ScenePropertyID,float>(int a1)
{
  if ((a1 - 57) > 4)
  {
    return &gss::defaultValueForKey<gss::ScenePropertyID,float>(gss::ScenePropertyID)::_defaultValue;
  }

  else
  {
    return *(&off_1E7B57DC8 + (a1 - 57));
  }
}

void *gss::defaultValueForKey<gss::ScenePropertyID,int>(int a1)
{
  v1 = &kGenericShieldType;
  if (a1 == 66)
  {
    v1 = &gss::defaultValueForKey<gss::ScenePropertyID,int>(gss::ScenePropertyID)::kDefaultCurrentRoadSignOffset;
  }

  if (a1 == 10)
  {
    return &gss::defaultValueForKey<gss::ScenePropertyID,int>(gss::ScenePropertyID)::kDefaultSecondaryLightAngleAltitude;
  }

  else
  {
    return v1;
  }
}

void *gss::defaultValueForKey<gss::ScenePropertyID,unsigned int>(unsigned int a1)
{
  if (a1 > 8)
  {
    return &gss::defaultValueForKey<gss::ScenePropertyID,unsigned int>(gss::ScenePropertyID)::_defaultValue;
  }

  else
  {
    return *(&off_1E7B57DF0 + a1);
  }
}

void gss::defaultValueForKey<gss::ScenePropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>()
{
  {
    geo::_wordColor<float,4,(geo::ColorSpace)0>(&v0, xmmword_1B33B0710);
    gss::defaultValueForKey<gss::ScenePropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>(gss::ScenePropertyID)::_defaultValue = v0;
  }
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,gss::ResolveMultiAttributeVectorToMap(std::vector<std::pair<gss::StyleAttribute,unsigned short>> &)::$_1 &,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short>*>>(uint64_t result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    v7 = a5;
    v9 = result;
    while (v7 > a7 && a4 > a7)
    {
      if (!a4)
      {
        return result;
      }

      v10 = *a2;
      while (1)
      {
        v11 = *v9;
        if (v10 < *v9)
        {
          break;
        }

        v9 += 8;
        if (!--a4)
        {
          return result;
        }
      }

      if (a4 >= v7)
      {
        if (a4 == 1)
        {
          *v9 = v10;
          *a2 = v11;
          v61 = *(v9 + 4);
          *(v9 + 4) = *(a2 + 2);
          *(a2 + 2) = v61;
          return result;
        }

        v20 = a4 / 2;
        v14 = (v9 + 8 * (a4 / 2));
        v13 = a2;
        if (a2 != a3)
        {
          v21 = (a3 - a2) >> 3;
          v13 = a2;
          do
          {
            v22 = v21 >> 1;
            v23 = &v13[8 * (v21 >> 1)];
            v25 = *v23;
            v24 = v23 + 8;
            v21 += ~(v21 >> 1);
            if (v25 < *v14)
            {
              v13 = v24;
            }

            else
            {
              v21 = v22;
            }
          }

          while (v21);
        }

        v12 = (v13 - a2) >> 3;
      }

      else
      {
        v12 = v7 / 2;
        v13 = &a2[8 * (v7 / 2)];
        v14 = a2;
        if (a2 != v9)
        {
          v15 = &a2[-v9] >> 3;
          v14 = v9;
          do
          {
            v16 = v15 >> 1;
            v17 = &v14[8 * (v15 >> 1)];
            v19 = *v17;
            v18 = (v17 + 2);
            v15 += ~(v15 >> 1);
            if (*v13 < v19)
            {
              v15 = v16;
            }

            else
            {
              v14 = v18;
            }
          }

          while (v15);
        }

        v20 = &v14[-v9] >> 3;
      }

      v26 = v13;
      if (v14 != a2)
      {
        v26 = v14;
        if (a2 != v13)
        {
          v27 = *v14;
          *v14 = v10;
          *a2 = v27;
          v28 = *(v14 + 2);
          *(v14 + 2) = *(a2 + 2);
          *(a2 + 2) = v28;
          v26 = v14 + 8;
          for (i = a2 + 8; i != v13; i += 8)
          {
            if (v26 == a2)
            {
              a2 = i;
            }

            v30 = *v26;
            *v26 = *i;
            *i = v30;
            LOWORD(v30) = *(v26 + 2);
            *(v26 + 2) = *(i + 2);
            *(i + 2) = v30;
            v26 += 8;
          }

          if (v26 != a2)
          {
            v31 = v26;
            v32 = a2;
            do
            {
              while (1)
              {
                v33 = *v31;
                *v31 = *v32;
                *v32 = v33;
                LOWORD(v33) = *(v31 + 2);
                *(v31 + 2) = *(v32 + 2);
                *(v32 + 2) = v33;
                v31 += 8;
                v32 += 8;
                if (v32 == v13)
                {
                  break;
                }

                if (v31 == a2)
                {
                  a2 = v32;
                }
              }

              v32 = a2;
            }

            while (v31 != a2);
          }
        }
      }

      a4 -= v20;
      v7 -= v12;
      if (v20 + v12 >= a4 + v7)
      {
        v38 = a4;
        v39 = v12;
        v36 = a6;
        v37 = a7;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,gss::ResolveMultiAttributeVectorToMap(std::vector<std::pair<gss::StyleAttribute,unsigned short>> &)::$_1 &,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short>*>>(v26, v13, a3, v38, v7);
        v13 = v14;
        v7 = v39;
        a4 = v20;
        a3 = v26;
      }

      else
      {
        v34 = v9;
        v35 = a3;
        v36 = a6;
        v37 = a7;
        result = std::__inplace_merge<std::_ClassicAlgPolicy,gss::ResolveMultiAttributeVectorToMap(std::vector<std::pair<gss::StyleAttribute,unsigned short>> &)::$_1 &,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short>*>>(v34, v14, v26, v20, v12);
        a3 = v35;
        v9 = v26;
      }

      a2 = v13;
      a6 = v36;
      a7 = v37;
      if (!v7)
      {
        return result;
      }
    }

    if (a4 <= v7)
    {
      if (a2 != v9)
      {
        v50 = a6;
        v51 = v9;
        do
        {
          v52 = v50;
          v53 = *v51;
          v51 += 8;
          *v50 = v53;
          v50 += 8;
        }

        while (v51 != a2);
        while (a2 != a3)
        {
          v54 = *a2;
          v55 = *a2 >= *a6;
          if (*a2 < *a6)
          {
            v56 = a2;
          }

          else
          {
            v54 = *a6;
            v56 = a6;
          }

          if (*a2 < *a6)
          {
            a2 += 8;
          }

          v57 = *(v56 + 2);
          if (v55)
          {
            a6 += 8;
          }

          *v9 = v54;
          *(v9 + 4) = v57;
          v9 += 8;
          if (a6 == v50)
          {
            return result;
          }
        }

        v58 = 0;
        do
        {
          v59 = v9 + v58;
          v60 = &a6[v58];
          *v59 = *&a6[v58];
          *(v59 + 4) = *&a6[v58 + 4];
          v58 += 8;
        }

        while (v60 != v52);
      }
    }

    else if (a2 != a3)
    {
      v40 = a6;
      v41 = a2;
      do
      {
        v42 = *v41;
        v41 += 8;
        *v40 = v42;
        v40 += 8;
      }

      while (v41 != a3);
      v43 = a3 - 4;
      while (a2 != v9)
      {
        v44 = *(a2 - 2);
        v45 = *(v40 - 2);
        v46 = v45 >= v44;
        if (v45 < v44)
        {
          v47 = a2;
        }

        else
        {
          v44 = *(v40 - 2);
          v47 = v40;
        }

        if (!v46)
        {
          a2 -= 8;
        }

        v48 = *(v47 - 2);
        if (v46)
        {
          v40 -= 8;
        }

        *(v43 - 1) = v44;
        *v43 = v48;
        v43 -= 8;
        if (v40 == a6)
        {
          return result;
        }
      }

      while (v40 != a6)
      {
        v49 = *(v40 - 2);
        v40 -= 8;
        *(v43 - 1) = v49;
        *v43 = *(v40 + 2);
        v43 -= 8;
      }
    }
  }

  return result;
}

uint64_t gss::attributesToString(_BYTE *a1, int **a2, int a3, char *a4, unint64_t a5)
{
  std::ostringstream::basic_ostringstream[abi:ne200100](&v46);
  std::ostringstream::basic_ostringstream[abi:ne200100](&v40);
  v38[0] = 0;
  v38[1] = 0;
  v39 = 0;
  if (a4)
  {
    v9 = a4;
  }

  else
  {
    v9 = "";
  }

  std::string::basic_string[abi:ne200100]<0>(&v35, v9);
  v11 = *a2;
  v10 = a2[1];
  v12 = v10 - *a2;
  if (v10 != *a2)
  {
    v13 = 0;
    v14 = (v12 >> 3) - 1;
    while (1)
    {
      std::string::basic_string[abi:ne200100]<0>(__dst, "");
      if (SHIBYTE(v44) < 0)
      {
        operator delete(__p);
      }

      __p = *__dst;
      v44 = v34;
      HIBYTE(v34) = 0;
      LOBYTE(__dst[0]) = 0;
      std::stringbuf::__init_buf_ptrs[abi:nn200100](&v41);
      if (SHIBYTE(v34) < 0)
      {
        operator delete(__dst[0]);
      }

      v15 = MEMORY[0x1B8C61C80](&v40, *v11);
      v16 = std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(v15, "=", 1);
      MEMORY[0x1B8C61C80](v16, *(v11 + 2));
      if (a3)
      {
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, " (", 2);
        v17 = gss::to_string(*v11);
        v18 = strlen(v17);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, v17, v18);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, "=", 1);
        v19 = gss::to_string(*v11, *(v11 + 2));
        v20 = strlen(v19);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, v19, v20);
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ")", 1);
      }

      v22 = v14-- != 0;
      if (a5 && v22)
      {
        std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v40, ",", 1);
      }

      std::ostringstream::str[abi:ne200100](__dst, &v40);
      if (SHIBYTE(v39) < 0)
      {
        operator delete(v38[0]);
      }

      v39 = v34;
      *v38 = *__dst;
      v23 = HIBYTE(v34);
      if ((v34 & 0x8000000000000000) != 0)
      {
        v23 = __dst[1];
      }

      if (v23 + v13 >= a5)
      {
        break;
      }

      if (!v13)
      {
        goto LABEL_26;
      }

LABEL_36:
      if (v39 >= 0)
      {
        v26 = v38;
      }

      else
      {
        v26 = v38[0];
      }

      if (v39 >= 0)
      {
        v27 = HIBYTE(v39);
      }

      else
      {
        v27 = v38[1];
      }

      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v46, v26, v27);
      v28 = HIBYTE(v39);
      if (v39 < 0)
      {
        v28 = v38[1];
      }

      v13 += v28;
      v11 += 2;
      if (v11 == v10)
      {
        goto LABEL_45;
      }
    }

    std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v46, "\n", 1);
LABEL_26:
    if ((v37 & 0x80u) == 0)
    {
      v24 = v37;
    }

    else
    {
      v24 = v36;
    }

    if (v24)
    {
      if ((v37 & 0x80u) == 0)
      {
        v25 = &v35;
      }

      else
      {
        v25 = v35;
      }

      std::__put_character_sequence[abi:ne200100]<char,std::char_traits<char>>(&v46, v25, v24);
      v13 = v37;
      if ((v37 & 0x8000000000000000) != 0)
      {
        v13 = v36;
      }
    }

    else
    {
      v13 = 0;
    }

    goto LABEL_36;
  }

LABEL_45:
  std::ostringstream::str[abi:ne200100](a1, &v46);
  if (v37 < 0)
  {
    operator delete(v35);
  }

  if (SHIBYTE(v39) < 0)
  {
    operator delete(v38[0]);
  }

  v40 = *MEMORY[0x1E69E54E8];
  v29 = v40;
  v30 = *(MEMORY[0x1E69E54E8] + 24);
  *(&v40 + *(v40 - 24)) = v30;
  v41 = MEMORY[0x1E69E5548] + 16;
  if (SHIBYTE(v44) < 0)
  {
    operator delete(__p);
  }

  v41 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&v42);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&v45);
  v46 = v29;
  *(&v46 + *(v29 - 24)) = v30;
  v47 = MEMORY[0x1E69E5548] + 16;
  if (v49 < 0)
  {
    operator delete(v48[7].__locale_);
  }

  v47 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v48);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v50);
}

void sub_1B3318A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, std::locale a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56, uint64_t a57, uint64_t a58, uint64_t a59, uint64_t a60, uint64_t a61, uint64_t a62, uint64_t a63)
{
  if (a19 < 0)
  {
    operator delete(__p);
  }

  if (a25 < 0)
  {
    operator delete(a20);
  }

  v74 = *MEMORY[0x1E69E54E8];
  a26 = *MEMORY[0x1E69E54E8];
  v75 = *(MEMORY[0x1E69E54E8] + 24);
  *(&a26 + *(a26 - 24)) = v75;
  a27 = MEMORY[0x1E69E5548] + 16;
  if (a40 < 0)
  {
    operator delete(a35);
  }

  a27 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a28);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a43);
  a62 = v74;
  *(&a62 + *(v74 - 24)) = v75;
  a63 = MEMORY[0x1E69E5548] + 16;
  if (a72 < 0)
  {
    operator delete(a71);
  }

  a63 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(&a64);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&a73);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne200100](uint64_t a1)
{
  *(a1 + 160) = 0;
  v2 = MEMORY[0x1E69E5570] + 64;
  *(a1 + 112) = MEMORY[0x1E69E5570] + 64;
  v3 = a1 + 8;
  v4 = *(MEMORY[0x1E69E54E8] + 16);
  v5 = *(MEMORY[0x1E69E54E8] + 8);
  *a1 = v5;
  *(a1 + *(v5 - 24)) = v4;
  v6 = (a1 + *(*a1 - 24));
  std::ios_base::init(v6, (a1 + 8));
  v7 = MEMORY[0x1E69E5570] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  *(a1 + 112) = v2;
  *(a1 + 8) = MEMORY[0x1E69E5538] + 16;
  MEMORY[0x1B8C61F50](a1 + 16);
  *(a1 + 72) = 0u;
  *(a1 + 40) = 0u;
  *(a1 + 56) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 8) = MEMORY[0x1E69E5548] + 16;
  *(a1 + 88) = 0u;
  *(a1 + 104) = 16;
  std::stringbuf::__init_buf_ptrs[abi:nn200100](v3);
  return a1;
}

void sub_1B3318E30(_Unwind_Exception *a1)
{
  if (*(v2 + 95) < 0)
  {
    operator delete(*v4);
  }

  *(v2 + 8) = v3;
  std::locale::~locale((v2 + 16));
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](v1);
  _Unwind_Resume(a1);
}

_BYTE *std::ostringstream::str[abi:ne200100](_BYTE *__dst, uint64_t a2)
{
  v2 = __dst;
  v3 = *(a2 + 104);
  if ((v3 & 0x10) != 0)
  {
    v5 = *(a2 + 96);
    v6 = *(a2 + 56);
    if (v5 < v6)
    {
      *(a2 + 96) = v6;
      v5 = v6;
    }

    v7 = (a2 + 48);
  }

  else
  {
    if ((v3 & 8) == 0)
    {
      v4 = 0;
      __dst[23] = 0;
      goto LABEL_14;
    }

    v7 = (a2 + 24);
    v5 = *(a2 + 40);
  }

  v8 = *v7;
  v4 = v5 - *v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
  {
    std::string::__throw_length_error[abi:ne200100]();
  }

  if (v4 >= 0x17)
  {
    operator new();
  }

  __dst[23] = v4;
  if (v4)
  {
    __dst = memmove(__dst, v8, v4);
  }

LABEL_14:
  v2[v4] = 0;
  return __dst;
}

void gss::attributesToString(_BYTE *a1, uint64_t *a2, uint64_t *a3, int a4, char *a5, unint64_t a6)
{
  v18 = *MEMORY[0x1E69E9840];
  v15 = 0;
  v16 = 0;
  v17 = 0;
  if (a3 != a2)
  {
    v11 = a2;
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__vallocate[abi:ne200100](&v15, a3 - a2);
    v12 = v16;
    do
    {
      v13 = *v11++;
      *v12++ = v13;
    }

    while (v11 != a3);
    v16 = v12;
  }

  gss::attributesToString(a1, &v15, a4, a5, a6);
  v14 = v15;
  if (v15)
  {

    std::allocator_traits<geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::deallocate[abi:ne200100](v14);
  }
}

void sub_1B3319060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, gss::zone_mallocator *a10)
{
  if (a10)
  {
    std::allocator_traits<geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::deallocate[abi:ne200100](a10);
  }

  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__vallocate[abi:ne200100](gss::zone_mallocator *a1, unint64_t a2)
{
  if (a2 >> 61)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v4 = gss::zone_mallocator::instance(a1);
  result = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<gss::StyleAttribute,unsigned short>>(v4, a2);
  *a1 = result;
  *(a1 + 1) = result;
  *(a1 + 2) = &result[8 * a2];
  return result;
}

void gss::attributesToString(_BYTE *a1, uint64_t *a2, int a3, unint64_t a4)
{
  v23 = *MEMORY[0x1E69E9840];
  v7 = *(a2 + 6);
  v21 = 0;
  v22 = 0;
  v20 = 0;
  if (v7)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      ++v9;
      v11 = v10 + 1;
      if (v10 + 1 < v7)
      {
        ++v10;
      }

      else
      {
        v10 = v7;
      }
    }

    while (v11 < v7);
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::__vallocate[abi:ne200100](&v20, v9);
    v13 = v21;
    v14 = 0;
    v15 = 0;
    v16 = *(a2 + 6);
    v17 = *a2;
    v18 = *a2 + *(a2 + 2);
    do
    {
      if (v14 < v16)
      {
        v15 = (v17 + 4 * v14);
        v12 = (v18 + 2 * v14);
      }

      *v13 = *v15;
      *(v13 + 4) = *v12;
      if (v14 + 1 < v16)
      {
        ++v14;
      }

      else
      {
        v14 = v16;
      }

      v13 += 8;
    }

    while (v14 != v7);
    v21 = v13;
  }

  gss::attributesToString(a1, &v20, a3, 0, a4);
  v19 = v20;
  if (v20)
  {

    std::allocator_traits<geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::deallocate[abi:ne200100](v19);
  }
}

void sub_1B3319228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, gss::zone_mallocator *a10)
{
  if (a10)
  {
    std::allocator_traits<geo::allocator_adapter<std::pair<gss::StyleAttribute,unsigned short>,gss::zone_mallocator>>::deallocate[abi:ne200100](a10);
  }

  _Unwind_Resume(exception_object);
}

void *gss::defaultValueForKey<gss::PropertyID,unsigned char>(int a1)
{
  v1 = &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::_defaultValue;
  if (a1 == 474)
  {
    v1 = &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::kDefaultLabelClusterElementCount;
  }

  if (a1 == 469)
  {
    return &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::kDefaultLabelCollisionGroup;
  }

  else
  {
    return v1;
  }
}

uint64_t gss::MaskToLabelPosition(int a1)
{
  v1 = 0;
  while (word_1B352389C[v1] != a1)
  {
    if (++v1 == 10)
    {
      LOBYTE(v1) = 9;
      return v1;
    }
  }

  return v1;
}

uint64_t std::__function::__func<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &),std::allocator<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>,BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "PFbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_10PropertyIDEEEyNS2_18StylePropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne200100](uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    return 1;
  }

  if ((a2 & a1) < 0 != __OFSUB__(a1, a2))
  {
    return strcmp((a1 & 0x7FFFFFFFFFFFFFFFLL), (a2 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }

  return 0;
}

uint64_t std::__function::__func<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &),std::allocator<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>,BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5DBD0;
  a2[1] = v2;
  return result;
}

BOOL gss::FeatureAttributeSet::isSuperset(gss::FeatureAttributeSet *this, const gss::FeatureAttributeSet *a2, unsigned int *a3, int *a4)
{
  if (a2 - this >= (a4 - a3))
  {
    if (a3 == a4)
    {
      return 1;
    }

    v6 = 0;
LABEL_6:
    v7 = *a3;
    for (i = v6; ; i = v6)
    {
      v9 = *(this + 2 * i);
      if (v9 > v7)
      {
        break;
      }

      if (v9 == v7)
      {
        v10 = *(a3 + 2) == *(this + 4 * i + 2);
        v4 = v10;
        ++v6;
        a3 += 2;
        v10 = !v10 || a3 == a4;
        if (v10)
        {
          return v4;
        }

        goto LABEL_6;
      }

      ++v6;
    }
  }

  return 0;
}

uint64_t gss::FeatureAttributeSet::eraseKeyValuePair(uint64_t result)
{
  v2 = *result;
  v1 = *(result + 8);
  while (v2 != v1)
  {
    if (*v2 == 100)
    {
      v3 = v2 + 2;
      if (v2 + 2 != v1)
      {
        do
        {
          *(v3 - 2) = *v3;
          *(v3 - 2) = *(v3 + 2);
          v3 += 2;
        }

        while (v3 != v1);
        v2 = v3 - 2;
      }

      *(result + 8) = v2;
      return result;
    }

    v2 += 2;
  }

  return result;
}

uint64_t std::__function::__func<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &),std::allocator<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &)>,BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne200100](*(a2 + 8), "PFbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_15ScenePropertyIDEEEyNS2_24SceneConfigPropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE"))
  {
    return a1 + 8;
  }

  else
  {
    return 0;
  }
}

uint64_t std::__function::__func<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &),std::allocator<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &)>,BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::ScenePropertyID> &,unsigned long long,gss::SceneConfigPropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5EBD0;
  a2[1] = v2;
  return result;
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,int>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,int>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,int>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,int>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 28);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x28uLL, 0x10200408542BB31uLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    v10[14] = *a3;
    *(v10 + 8) = *(a3 + 4);
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v11 = **v4;
    if (v11)
    {
      *v4 = v11;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 26);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x20uLL, 0x10200409252476EuLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    v10[13] = *a3;
    *(v10 + 7) = *(a3 + 2);
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v11 = **v4;
    if (v11)
    {
      *v4 = v11;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,float>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,float>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,float>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,float>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 28);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x28uLL, 0x10200408542BB31uLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    v10[14] = *a3;
    *(v10 + 8) = *(a3 + 4);
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v11 = **v4;
    if (v11)
    {
      *v4 = v11;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,BOOL>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,BOOL>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,BOOL>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,BOOL>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 26);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x20uLL, 0x102004037C47D07uLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    v10[13] = *a3;
    *(v10 + 28) = *(a3 + 2);
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v11 = **v4;
    if (v11)
    {
      *v4 = v11;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

void std::__tree<std::__value_type<grl::PropertyID,std::string>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,std::string>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,std::string>,grl::zone_mallocator>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<grl::PropertyID,std::string>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,std::string>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,std::string>,grl::zone_mallocator>>::destroy(*a1);
    v2 = std::__tree<std::__value_type<grl::PropertyID,std::string>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,std::string>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,std::string>,grl::zone_mallocator>>::destroy(*(a1 + 1));
    if (a1[63] < 0)
    {
      operator delete(*(a1 + 5));
    }

    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,gm::Matrix<float,2,1>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,gm::Matrix<float,2,1>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,gm::Matrix<float,2,1>>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,gm::Matrix<float,2,1>>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 28);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x28uLL, 0x1020040A08860DFuLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    v10[14] = *a3;
    *(v10 + 4) = *(a3 + 4);
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v11 = **v4;
    if (v11)
    {
      *v4 = v11;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

double grl::codec::PathLayerData::PathLayerData(grl::codec::PathLayerData *this)
{
  v3 = 515;
  v4 = 1;
  v1 = std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::vector[abi:nn200100](this, &v3, 3uLL);
  *(v1 + 16) = 0;
  *(v1 + 34) = -1;
  *(v1 + 10) = 0;
  *(v1 + 43) = 0;
  *(v1 + 47) = 255;
  *(v1 + 52) = 0;
  *(v1 + 60) = 0;
  *(v1 + 16) = 1119092736;
  result = -5.48612928e303;
  *(v1 + 17) = -16777216;
  *(v1 + 18) = 1065353216;
  *(v1 + 76) = 4278190080;
  *(v1 + 21) = 1;
  *(v1 + 88) = -1;
  *(v1 + 23) = 0;
  *(v1 + 96) = 0;
  *(v1 + 25) = 1065353216;
  *(v1 + 26) = -16777216;
  *(v1 + 31) = 0;
  *(v1 + 113) = 0;
  *(v1 + 108) = 0;
  *(v1 + 128) = 1;
  return result;
}

grl::codec::TextLayerData *grl::codec::TextLayerData::TextLayerData(grl::codec::TextLayerData *this)
{
  v4 = 515;
  v5 = 1;
  v2 = std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::vector[abi:nn200100](this, &v4, 3uLL);
  *(v2 + 8) = -16777216;
  *(v2 + 36) = 0;
  std::string::basic_string[abi:nn200100]<0>(v2 + 40, "");
  *(this + 67) = 0;
  *(this + 16) = 0;
  *(this + 71) = -1;
  *(this + 9) = 0;
  *(this + 79) = 0;
  *(this + 87) = -1;
  std::string::basic_string[abi:nn200100]<0>(this + 88, "");
  *(this + 115) = 0;
  *(this + 28) = 0;
  *(this + 119) = -1;
  *(this + 30) = 0;
  *(this + 123) = 0;
  *(this + 127) = -1;
  *(this + 16) = 0;
  *(this + 34) = 0;
  std::string::basic_string[abi:nn200100]<0>(this + 144, "");
  *(this + 21) = 0;
  *(this + 88) = 1;
  return this;
}

grl::codec::TextLayerData *grl::codec::TextLayerData::TextLayerData(grl::codec::TextLayerData *this, const grl::codec::TextLayerData *a2, unsigned int a3, const grl::IconModifiers *a4)
{
  v23 = 515;
  v24 = 1;
  v7 = std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::vector[abi:nn200100](this, &v23, 3uLL);
  *(v7 + 8) = -16777216;
  v8 = (v7 + 32);
  *(v7 + 36) = 0;
  std::string::basic_string[abi:nn200100]<0>(v7 + 40, "");
  *(this + 16) = 0;
  *(this + 67) = 0;
  *(this + 71) = -1;
  *(this + 9) = 0;
  *(this + 79) = 0;
  *(this + 87) = -1;
  std::string::basic_string[abi:nn200100]<0>(this + 88, "");
  *(this + 28) = 0;
  v9 = (this + 84);
  *(this + 115) = 0;
  *(this + 30) = 0;
  *(this + 119) = -1;
  *(this + 123) = 0;
  *(this + 127) = -1;
  *(this + 16) = 0;
  *(this + 34) = 0;
  std::string::basic_string[abi:nn200100]<0>(this + 144, "");
  *(this + 21) = 0;
  *(this + 88) = 1;
  if (a2)
  {
    for (i = 0; i != 4; ++i)
    {
      *(v8 + i) = *(a2 + i + 32);
    }

    *(this + 36) = *(a2 + 36);
    std::string::operator=((this + 40), (a2 + 40));
    v11 = 0;
    *(this + 16) = *(a2 + 16);
    do
    {
      *(this + v11 + 68) = *(a2 + v11 + 68);
      ++v11;
    }

    while (v11 != 4);
    v12 = 0;
    *(this + 18) = *(a2 + 18);
    *(this + 19) = *(a2 + 19);
    *(this + 20) = *(a2 + 20);
    do
    {
      *(v9 + v12) = *(a2 + v12 + 84);
      ++v12;
    }

    while (v12 != 4);
    std::string::operator=((this + 88), (a2 + 88));
    v13 = 0;
    *(this + 28) = *(a2 + 28);
    do
    {
      *(this + v13 + 116) = *(a2 + v13 + 116);
      ++v13;
    }

    while (v13 != 4);
    v14 = 0;
    *(this + 30) = *(a2 + 30);
    do
    {
      *(this + v14 + 124) = *(a2 + v14 + 124);
      ++v14;
    }

    while (v14 != 4);
    *(this + 32) = *(a2 + 32);
    *(this + 33) = *(a2 + 33);
    *(this + 34) = *(a2 + 34);
    std::string::operator=(this + 6, a2 + 6);
    *(this + 42) = *(a2 + 42);
    *(this + 43) = *(a2 + 43);
    *(this + 88) = *(a2 + 88);
  }

  if (*(this + 36) == 1 && *(a4 + 25) == 1)
  {
    v15 = *(a4 + 26);
    *v8 = v15;
    *v9 = v15;
  }

  v16 = *(a4 + 14);
  if (v16)
  {
    v17 = a4 + 112;
    do
    {
      v18 = *(v16 + 16);
      v19 = v18 >= a3;
      v20 = v18 < a3;
      if (v19)
      {
        v17 = v16;
      }

      v16 = *&v16[8 * v20];
    }

    while (v16);
    if (v17 != a4 + 112 && *(v17 + 16) <= a3)
    {
      std::string::operator=(this + 6, (v17 + 40));
    }
  }

  if (*(a4 + 52) == 1)
  {
    *(this + 16) = *(a4 + 14);
  }

  if (*a4 == 1)
  {
    if (*(this + 63) < 0)
    {
      operator delete(*(this + 5));
    }

    strcpy(this + 40, "%$default,heavy");
    *(this + 63) = 15;
  }

  return this;
}

uint64_t *std::__tree<std::__value_type<grl::PropertyID,std::string>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,std::string>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,std::string>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::PropertyID,std::pair<grl::PropertyID,std::string>>(uint64_t *result, unsigned __int16 a2, uint64_t a3)
{
  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 32);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(result);
    geo::read_write_lock::read_lock((v9 + 32));
    v10 = malloc_type_zone_malloc(*v9, 0x40uLL, 0x10320406A6885EAuLL);
    atomic_fetch_add((v9 + 24), 1u);
    geo::read_write_lock::unlock((v9 + 32));
    *(v10 + 16) = *a3;
    v11 = *(a3 + 8);
    *(v10 + 7) = *(a3 + 24);
    *(v10 + 40) = v11;
    *(a3 + 16) = 0;
    *(a3 + 24) = 0;
    *(a3 + 8) = 0;
    *v10 = 0;
    *(v10 + 1) = 0;
    *(v10 + 2) = v7;
    *v6 = v10;
    v12 = **v4;
    if (v12)
    {
      *v4 = v12;
      v10 = *v6;
    }

    result = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v4[1], v10);
    ++v4[3];
  }

  return result;
}

void grl::createCFDictionary(void *a1, const void **a2, uint64_t a3, const void **values, uint64_t a5)
{
  v13 = *MEMORY[0x1E69E9840];
  if (a3 - a2 == a5 - values)
  {
    v6 = (a3 - a2) >> 3;
    if (v6 >= 0x7FFFFFFFFFFFFFFFLL)
    {
      v6 = 0x7FFFFFFFFFFFFFFFLL;
    }

    v7 = CFDictionaryCreate(0, a2, values, v6, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
    *buf = &unk_1F2A5F698;
    cf = v7;
    if (v7)
    {
      *a1 = &unk_1F2A5F698;
      a1[1] = v7;
    }

    else
    {
      if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
      }

      v9 = GEOGetGeoResourceLibCoreFoundationLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
      {
        *v10 = 0;
        _os_log_impl(&dword_1B2754000, v9, OS_LOG_TYPE_ERROR, "Failed to create CFDictionary.", v10, 2u);
      }

      *a1 = &unk_1F2A5F698;
      a1[1] = 0;
      *buf = &unk_1F2A5F698;
      if (cf)
      {
        CFRelease(cf);
      }
    }
  }

  else
  {
    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
    }

    v8 = GEOGetGeoResourceLibCoreFoundationLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_impl(&dword_1B2754000, v8, OS_LOG_TYPE_ERROR, "Creating CFDictionary with missmatching number of keys and values.", buf, 2u);
    }

    *a1 = &unk_1F2A5F698;
    a1[1] = 0;
  }
}

void geo::_retain_ptr<__CFDictionary const*,geo::_retain_cf<__CFDictionary const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F698;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<__CFDictionary const*,geo::_retain_cf<__CFDictionary const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F698;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void grl::createCFMutableDictionary(grl *this)
{
  v7 = *MEMORY[0x1E69E9840];
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
  v5 = &unk_1F2A5EFA0;
  cf = Mutable;
  if (Mutable)
  {
    *this = &unk_1F2A5EFA0;
    *(this + 1) = Mutable;
  }

  else
  {
    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
    }

    v3 = GEOGetGeoResourceLibCoreFoundationLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
    {
      *v4 = 0;
      _os_log_impl(&dword_1B2754000, v3, OS_LOG_TYPE_ERROR, "Failed to create CFMutableDictionary.", v4, 2u);
    }

    *this = &unk_1F2A5EFA0;
    *(this + 1) = 0;
    v5 = &unk_1F2A5EFA0;
    if (cf)
    {
      CFRelease(cf);
    }
  }
}

void geo::_retain_ptr<__CFDictionary *,geo::_retain_cf<__CFDictionary *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5EFA0;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<__CFDictionary *,geo::_retain_cf<__CFDictionary *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5EFA0;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void grl::createCFNumber(grl *this, unsigned int a2)
{
  v13 = *MEMORY[0x1E69E9840];
  if (a2 >= 0x7FFFFFFF)
  {
    v3 = 0x7FFFFFFF;
  }

  else
  {
    v3 = a2;
  }

  valuePtr = v3;
  v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  *this = &unk_1F2A5F6D8;
  *(this + 1) = v4;
  if (!v4)
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_53812);
    }

    v5 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v8 = "result";
      v9 = 2080;
      v10 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/CoreGraphicsUtilities.cpp";
      v11 = 1024;
      v12 = 20;
      _os_log_impl(&dword_1B2754000, v5, OS_LOG_TYPE_ERROR, "Failed to generate CFNumber for uint32_t.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }
}

void grl::createCFNumber(grl *this, float a2)
{
  v12 = *MEMORY[0x1E69E9840];
  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *this = &unk_1F2A5F6D8;
  *(this + 1) = v3;
  if (!v3)
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_53812);
    }

    v4 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      v7 = "result";
      v8 = 2080;
      v9 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/CoreGraphicsUtilities.cpp";
      v10 = 1024;
      v11 = 28;
      _os_log_impl(&dword_1B2754000, v4, OS_LOG_TYPE_ERROR, "Failed to generate CFNumber for float.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }
}

float grl::getOpticalBounds(grl *this, const __CTLine *a2)
{
  if (this)
  {
    BoundsWithOptions = CTLineGetBoundsWithOptions(this, 0x10uLL);
    x = BoundsWithOptions.origin.x;
    y = BoundsWithOptions.origin.y;
    width = BoundsWithOptions.size.width;
    height = BoundsWithOptions.size.height;
    MinX = CGRectGetMinX(BoundsWithOptions);
    v11.origin.x = x;
    v11.origin.y = y;
    v11.size.width = width;
    v11.size.height = height;
    CGRectGetMinY(v11);
    v12.origin.x = x;
    v12.origin.y = y;
    v12.size.width = width;
    v12.size.height = height;
    CGRectGetMaxX(v12);
    v13.origin.x = x;
    v13.origin.y = y;
    v13.size.width = width;
    v13.size.height = height;
    CGRectGetMaxY(v13);
  }

  else
  {
    if (GEOGetGeoResourceLibCoreGraphicsLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreGraphicsLog::onceToken, &__block_literal_global_37_53830);
    }

    v7 = GEOGetGeoResourceLibCoreGraphicsLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreGraphicsLog::log, OS_LOG_TYPE_ERROR))
    {
      *v9 = 0;
      _os_log_impl(&dword_1B2754000, v7, OS_LOG_TYPE_ERROR, "Input CTLine must be a valid pointer to get font bounds.", v9, 2u);
    }

    return 0.0;
  }

  return MinX;
}

float grl::getTextDescent(grl *this, const __CTLine *a2)
{
  if (this)
  {
    descent = 0.0;
    ascent[0] = 0.0;
    v6 = 0;
    CTLineGetTypographicBounds(this, ascent, &descent, &v6);
    v2 = descent;
    return fabsf(v2);
  }

  else
  {
    if (GEOGetGeoResourceLibCoreGraphicsLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreGraphicsLog::onceToken, &__block_literal_global_37_53830);
    }

    v4 = GEOGetGeoResourceLibCoreGraphicsLog::log;
    v3 = 0.0;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreGraphicsLog::log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(ascent[0]) = 0;
      _os_log_impl(&dword_1B2754000, v4, OS_LOG_TYPE_ERROR, "Input CTLine must be a valid pointer to get text descent.", ascent, 2u);
    }
  }

  return v3;
}

void geo::_retain_ptr<__CFAttributedString const*,geo::_retain_cf<__CFAttributedString const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5EF60;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<__CFAttributedString const*,geo::_retain_cf<__CFAttributedString const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5EF60;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void grl::createCTLine(void *a1, const char *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, float a9, float a10, float a11, float a12)
{
  v78 = *MEMORY[0x1E69E9840];
  v13 = *(a2 + 23);
  if ((v13 & 0x80u) != 0)
  {
    v13 = *(a2 + 1);
  }

  if (v13)
  {
    *buf = 0;
    v76 = 0;
    v77 = 0;
    memset(v74, 0, 24);
    v71 = 0;
    v72 = 0;
    v73 = 0;
    memset(values, 0, 24);
    v68 = &unk_1F2A5F6D8;
    v69 = 0;
    v66 = &unk_1F2A5F6D8;
    cf = 0;
    v25 = MEMORY[0x1E6965658];
    if (a3)
    {
      v64 = *MEMORY[0x1E6965658];
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](buf, &v64);
      v64 = a3;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](v74, &v64);
    }

    if (a4)
    {
      v64 = *v25;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](&v71, &v64);
      v64 = a4;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](values, &v64);
    }

    v26 = MEMORY[0x1E69659D8];
    if (a5)
    {
      v64 = *MEMORY[0x1E69659D8];
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](buf, &v64);
      v64 = a5;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](v74, &v64);
    }

    if (a6)
    {
      v64 = *v26;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](&v71, &v64);
      v64 = a6;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](values, &v64);
    }

    v27 = MEMORY[0x1E6965A58];
    v28 = MEMORY[0x1E6965A60];
    if (a7)
    {
      v64 = *MEMORY[0x1E6965A58];
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](buf, &v64);
      v64 = a7;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](v74, &v64);
      *&valuePtr = (a9 * 100.0) / a11;
      v29 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      v64 = &unk_1F2A5F6D8;
      str = v29;
      if (cf)
      {
        CFRelease(cf);
        v29 = str;
      }

      cf = v29;
      v64 = *v28;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](buf, &v64);
      v64 = cf;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](v74, &v64);
    }

    if (a8)
    {
      v64 = *v27;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](&v71, &v64);
      v64 = a8;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](values, &v64);
      *&valuePtr = (a10 * 100.0) / a12;
      v30 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      v64 = &unk_1F2A5F6D8;
      str = v30;
      if (v69)
      {
        CFRelease(v69);
        v30 = str;
      }

      v69 = v30;
      v64 = *v28;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](&v71, &v64);
      v64 = v69;
      std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](values, &v64);
    }

    v31 = *buf;
    v32 = v76;
    v33 = v71;
    if (((v72 - v71) >> 3) >= 0x7FFFFFFFFFFFFFFFLL)
    {
      v34 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v34 = (v72 - v71) >> 3;
    }

    if (a2[23] >= 0)
    {
      v35 = a2;
    }

    else
    {
      v35 = *a2;
    }

    v36 = CFStringCreateWithCString(0, v35, 0x8000100u);
    v64 = &unk_1F29E1668;
    str = v36;
    if (v36)
    {
      if (((v32 - v31) >> 3) >= 0x7FFFFFFFFFFFFFFFLL)
      {
        v37 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v37 = (v32 - v31) >> 3;
      }

      v38 = CFDictionaryCreate(0, v31, v74[0], v37, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
      *&valuePtr = &unk_1F2A5F698;
      *(&valuePtr + 1) = v38;
      if (v38)
      {
        *&v62 = &unk_1F2A5F698;
        *(&v62 + 1) = CFDictionaryCreate(0, v33, values[0], v34, MEMORY[0x1E695E9D8], MEMORY[0x1E695E9E8]);
        if (*(&v62 + 1))
        {
          v39 = CFAttributedStringCreate(0, str, *(&valuePtr + 1));
          *&v61 = &unk_1F2A5EF60;
          *(&v61 + 1) = v39;
          if (v39)
          {
            *&v60 = &unk_1F2A5EF80;
            *(&v60 + 1) = CFAttributedStringCreateMutableCopy(0, 0, v39);
            if (*(&v60 + 1))
            {
              v40 = 0;
              v41 = MEMORY[0x1E69E9830];
              while (v40 < CFStringGetLength(str))
              {
                CharacterAtIndex = CFStringGetCharacterAtIndex(str, v40);
                if (CharacterAtIndex > 0xFF || (*(v41 + 4 * CharacterAtIndex + 60) & 0x400) == 0)
                {
                  v79.location = v40;
                  v79.length = 1;
                  CFAttributedStringSetAttributes(*(&v60 + 1), v79, *(&v62 + 1), 0);
                }

                ++v40;
              }

              v50 = CTLineCreateWithAttributedString(*(&v60 + 1));
              *&v59 = &unk_1F2A5F268;
              *(&v59 + 1) = v50;
              if (v50)
              {
                *a1 = &unk_1F2A5F268;
                a1[1] = v50;
              }

              else
              {
                if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
                {
                  dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
                }

                v55 = GEOGetGeoResourceLibCoreFoundationLog::log;
                if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
                {
                  if (a2[23] >= 0)
                  {
                    v56 = a2;
                  }

                  else
                  {
                    v56 = *a2;
                  }

                  *v57 = 136315138;
                  v58 = v56;
                  _os_log_impl(&dword_1B2754000, v55, OS_LOG_TYPE_ERROR, "Failed to create a CFMutableAttributedString for a CTLine for string %s", v57, 0xCu);
                }

                *a1 = &unk_1F2A5F268;
                a1[1] = 0;
                *&v59 = &unk_1F2A5F268;
                if (*(&v59 + 1))
                {
                  CFRelease(*(&v59 + 1));
                }
              }
            }

            else
            {
              if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
              {
                dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
              }

              v53 = GEOGetGeoResourceLibCoreFoundationLog::log;
              if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
              {
                if (a2[23] >= 0)
                {
                  v54 = a2;
                }

                else
                {
                  v54 = *a2;
                }

                LODWORD(v59) = 136315138;
                *(&v59 + 4) = v54;
                _os_log_impl(&dword_1B2754000, v53, OS_LOG_TYPE_ERROR, "Failed to create a CFMutableAttributedString for a CTLine for string %s", &v59, 0xCu);
              }

              *a1 = &unk_1F2A5F268;
              a1[1] = 0;
            }

            *&v60 = &unk_1F2A5EF80;
            if (*(&v60 + 1))
            {
              CFRelease(*(&v60 + 1));
            }
          }

          else
          {
            if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
            {
              dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
            }

            v51 = GEOGetGeoResourceLibCoreFoundationLog::log;
            if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
            {
              if (a2[23] >= 0)
              {
                v52 = a2;
              }

              else
              {
                v52 = *a2;
              }

              LODWORD(v60) = 136315138;
              *(&v60 + 4) = v52;
              _os_log_impl(&dword_1B2754000, v51, OS_LOG_TYPE_ERROR, "Failed to create a CFAttributedString for a CTLine for string %s", &v60, 0xCu);
            }

            *a1 = &unk_1F2A5F268;
            a1[1] = 0;
          }

          *&v61 = &unk_1F2A5EF60;
          if (*(&v61 + 1))
          {
            CFRelease(*(&v61 + 1));
          }
        }

        else
        {
          if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
          }

          v48 = GEOGetGeoResourceLibCoreFoundationLog::log;
          if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
          {
            if (a2[23] >= 0)
            {
              v49 = a2;
            }

            else
            {
              v49 = *a2;
            }

            LODWORD(v61) = 136315138;
            *(&v61 + 4) = v49;
            _os_log_impl(&dword_1B2754000, v48, OS_LOG_TYPE_ERROR, "Failed to create a CFDictionary for a CTLine for string %s", &v61, 0xCu);
          }

          *a1 = &unk_1F2A5F268;
          a1[1] = 0;
        }

        *&v62 = &unk_1F2A5F698;
        if (*(&v62 + 1))
        {
          CFRelease(*(&v62 + 1));
        }
      }

      else
      {
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
        }

        v46 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          if (a2[23] >= 0)
          {
            v47 = a2;
          }

          else
          {
            v47 = *a2;
          }

          LODWORD(v62) = 136315138;
          *(&v62 + 4) = v47;
          _os_log_impl(&dword_1B2754000, v46, OS_LOG_TYPE_ERROR, "Failed to create a CFDictionary to create a CTLine for string %s", &v62, 0xCu);
        }

        *a1 = &unk_1F2A5F268;
        a1[1] = 0;
      }

      *&valuePtr = &unk_1F2A5F698;
      if (*(&valuePtr + 1))
      {
        CFRelease(*(&valuePtr + 1));
      }
    }

    else
    {
      if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
      }

      v44 = GEOGetGeoResourceLibCoreFoundationLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
      {
        if (a2[23] >= 0)
        {
          v45 = a2;
        }

        else
        {
          v45 = *a2;
        }

        LODWORD(valuePtr) = 136315138;
        *(&valuePtr + 4) = v45;
        _os_log_impl(&dword_1B2754000, v44, OS_LOG_TYPE_ERROR, "Failed to create CFString from %s.", &valuePtr, 0xCu);
      }

      *a1 = &unk_1F2A5F268;
      a1[1] = 0;
    }

    v64 = &unk_1F29E1668;
    if (str)
    {
      CFRelease(str);
    }

    v66 = &unk_1F2A5F6D8;
    if (cf)
    {
      CFRelease(cf);
    }

    v68 = &unk_1F2A5F6D8;
    if (v69)
    {
      CFRelease(v69);
    }

    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](values);
    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v71);
    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v74);
    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](buf);
  }

  else
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v43 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_impl(&dword_1B2754000, v43, OS_LOG_TYPE_ERROR, "Input text must be non-empty to create a CTLine.", buf, 2u);
    }

    *a1 = &unk_1F2A5F268;
    a1[1] = 0;
  }
}

void std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::push_back[abi:nn200100](grl::zone_mallocator *a1, void *a2)
{
  v5 = *(a1 + 1);
  v4 = *(a1 + 2);
  if (v5 >= v4)
  {
    v7 = (v5 - *a1) >> 3;
    if ((v7 + 1) >> 61)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = v4 - *a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (v7 + 1))
    {
      v9 = v7 + 1;
    }

    if (v8 >= 0x7FFFFFFFFFFFFFF8)
    {
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v9;
    }

    if (v10)
    {
      v11 = grl::zone_mallocator::instance(a1);
      v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<void const*>(v11, v10);
    }

    else
    {
      v12 = 0;
    }

    v14 = &v12[8 * v10];
    v13 = &v12[8 * v7];
    *v13 = *a2;
    v6 = v13 + 8;
    v15 = *(a1 + 1) - *a1;
    v16 = &v13[-v15];
    v17 = memcpy(&v13[-v15], *a1, v15);
    v18 = *a1;
    *a1 = v16;
    *(a1 + 1) = v6;
    *(a1 + 2) = v14;
    if (v18)
    {
      v19 = grl::zone_mallocator::instance(v17);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v19, v18);
    }
  }

  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }

  *(a1 + 1) = v6;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<void const*>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 8 * a2, 0xC0040B8AA526DuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

void grl::createCGColor(void *a1, __int32 *a2)
{
  v17 = *MEMORY[0x1E69E9840];
  v4 = CGColorSpaceCreateWithName(*MEMORY[0x1E695F1C0]);
  v15 = &unk_1F29E1230;
  v16 = v4;
  if (v4)
  {
    v5.i32[0] = *a2;
    v6 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*&vmovl_u8(v5))), vdupq_n_s32(0x3B808081u));
    *components = vcvtq_f64_f32(*v6.f32);
    v12 = vcvt_hight_f64_f32(v6);
    v7 = CGColorCreate(v4, components);
    v13 = &unk_1F29E1130;
    cf = v7;
    if (v7)
    {
      *a1 = &unk_1F29E1130;
      a1[1] = v7;
    }

    else
    {
      if (GEOGetGeoResourceLibCoreGraphicsLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibCoreGraphicsLog::onceToken, &__block_literal_global_37_53830);
      }

      v9 = GEOGetGeoResourceLibCoreGraphicsLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibCoreGraphicsLog::log, OS_LOG_TYPE_ERROR))
      {
        *v10 = 0;
        _os_log_impl(&dword_1B2754000, v9, OS_LOG_TYPE_ERROR, "Failed to create a CGColor.", v10, 2u);
      }

      *a1 = &unk_1F29E1130;
      a1[1] = 0;
      v13 = &unk_1F29E1130;
      if (cf)
      {
        CFRelease(cf);
      }
    }
  }

  else
  {
    if (GEOGetGeoResourceLibCoreGraphicsLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreGraphicsLog::onceToken, &__block_literal_global_37_53830);
    }

    v8 = GEOGetGeoResourceLibCoreGraphicsLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreGraphicsLog::log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(components[0]) = 0;
      _os_log_impl(&dword_1B2754000, v8, OS_LOG_TYPE_ERROR, "Nullptr color space being used to generate a CGColor.", components, 2u);
    }

    *a1 = &unk_1F29E1130;
    a1[1] = 0;
  }

  v15 = &unk_1F29E1230;
  if (v16)
  {
    CFRelease(v16);
  }
}

uint64_t std::__shared_ptr_pointer<esl::QuartzImage *,std::shared_ptr<esl::QuartzImage>::__shared_ptr_default_delete<esl::QuartzImage,esl::QuartzImage>,std::allocator<esl::QuartzImage>>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    return (*(*result + 8))();
  }

  return result;
}

void std::__shared_ptr_pointer<esl::QuartzImage *,std::shared_ptr<esl::QuartzImage>::__shared_ptr_default_delete<esl::QuartzImage,esl::QuartzImage>,std::allocator<esl::QuartzImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::getSize(float *a1, void *a2)
{
  if (*a2 && ((*(**a2 + 40))(*a2) & 1) != 0)
  {
    v4 = (*(**a2 + 24))();
    v5 = (*(**a2 + 32))();
  }

  else
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v6 = GEOGetGeoResourceLibEaselLog::log;
    v4 = 0.0;
    if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      *v7 = 0;
      _os_log_impl(&dword_1B2754000, v6, OS_LOG_TYPE_ERROR, "Input image must be a non-nullptr to get a size.", v7, 2u);
    }

    v5 = 0.0;
  }

  *a1 = v4;
  a1[1] = v5;
}

void grl::drawLinearGradientToContext(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v19[5] = *MEMORY[0x1E69E9840];
  v5 = *a1;
  if (!v5 || ((*(*v5 + 24))(v5) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v13 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    buf[0] = 136315650;
    *&buf[1] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    v15 = 2080;
    v16 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    v17 = 1024;
    v18 = 471;
    v10 = "A non-nullptr context is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    v11 = v13;
    v12 = 28;
    goto LABEL_19;
  }

  if (!*a2 || ((*(**a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v13 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    buf[0] = 136315650;
    *&buf[1] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    v15 = 2080;
    v16 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    v17 = 1024;
    v18 = 474;
    v10 = "A non-nullptr path is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }

  if (!(*(**a2 + 24))())
  {
    esl::QuartzColor::QuartzColor(buf, a3);
    esl::QuartzColor::QuartzColor(v19, a5);
    operator new();
  }

  if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
  }

  v9 = GEOGetGeoResourceLibRendererLog::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0]) = 0;
    v10 = "Receieved empty path for drawLinearGradientToContext().";
    v11 = v9;
    v12 = 2;
LABEL_19:
    _os_log_impl(&dword_1B2754000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
  }
}

void std::vector<esl::QuartzColor>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 32;
      v7 = v4 - 32;
      v8 = v4 - 32;
      do
      {
        v9 = *v8;
        v8 -= 32;
        (*v9)(v7);
        v6 -= 32;
        v10 = v7 == v2;
        v7 = v8;
      }

      while (!v10);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void grl::drawRadialGradientToContext(void *a1, void *a2, uint64_t a3, float a4, float a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v27 = *MEMORY[0x1E69E9840];
  v9 = *a1;
  if (!v9 || ((*(*v9 + 24))(v9) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v20 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v26 = 496;
    v17 = "A non-nullptr context is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    v18 = v20;
    v19 = 28;
    goto LABEL_19;
  }

  if (!*a2 || ((*(**a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v20 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v26 = 499;
    v17 = "A non-nullptr path is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }

  if ((*(**a2 + 24))())
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v16 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      v17 = "Receieved empty path for drawRadialGradientToContext().";
      v18 = v16;
      v19 = 2;
LABEL_19:
      _os_log_impl(&dword_1B2754000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    }
  }

  else
  {
    esl::QuartzColor::QuartzColor(buf, a3);
    esl::QuartzColor::QuartzColor(v23, a7);
    if (esl::QuartzColor::isValid(buf) && esl::QuartzColor::isValid(v23))
    {
      (*(**a1 + 408))(*a1);
      (*(**a1 + 288))(*a1, a2);
      (*(**a1 + 264))();
      (*(**a1 + 224))(*a1, a8);
      (*(**a1 + 368))(a4, a5);
      (*(**a1 + 400))();
    }

    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
      }

      v21 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        *v22 = 0;
        _os_log_impl(&dword_1B2754000, v21, OS_LOG_TYPE_ERROR, "Failed to create the gradient colors for a path.", v22, 2u);
      }
    }

    v23[0] = &unk_1F29E15F0;
    v23[1] = &unk_1F29E1130;
    if (cf)
    {
      CFRelease(cf);
    }

    *buf = &unk_1F29E15F0;
    *&buf[8] = &unk_1F29E1130;
    if (*&buf[16])
    {
      CFRelease(*&buf[16]);
    }
  }
}

void grl::drawReflectedGradientToContext(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v37 = *MEMORY[0x1E69E9840];
  v5 = *a1;
  if (!v5 || ((*(*v5 + 24))(v5) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v16 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v23 = 525;
    v13 = "A non-nullptr context is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    v14 = v16;
    v15 = 28;
    goto LABEL_19;
  }

  if (!*a2 || ((*(**a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v16 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v23 = 528;
    v13 = "A non-nullptr path is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }

  if ((*(**a2 + 24))(*a2, v9, v10, v11))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v12 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      v13 = "Receieved empty path for drawReflectedGradientToContext().";
      v14 = v12;
      v15 = 2;
LABEL_19:
      _os_log_impl(&dword_1B2754000, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
    }
  }

  else
  {
    esl::QuartzColor::QuartzColor(v35, a3);
    esl::QuartzColor::QuartzColor(v33, a5);
    if (esl::QuartzColor::isValid(v35) && esl::QuartzColor::isValid(v33))
    {
      *buf = &unk_1F29E15F0;
      *&buf[8] = &unk_1F29E1130;
      v17 = v36;
      if (v36)
      {
        CFRetain(v36);
      }

      *&buf[16] = v17;
      v24 = &unk_1F29E15F0;
      v25 = &unk_1F29E1130;
      v18 = v34;
      if (v34)
      {
        CFRetain(v34);
        v19 = v34;
      }

      else
      {
        v19 = 0;
      }

      v26 = v18;
      v27 = &unk_1F29E15F0;
      v28 = &unk_1F29E1130;
      if (v19)
      {
        CFRetain(v19);
      }

      v29 = v19;
      v30 = &unk_1F29E15F0;
      v31 = &unk_1F29E1130;
      v21 = v36;
      if (v36)
      {
        CFRetain(v36);
      }

      v32 = v21;
      operator new();
    }

    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v20 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_impl(&dword_1B2754000, v20, OS_LOG_TYPE_ERROR, "Failed to create the gradient colors for a path.", buf, 2u);
    }

    v33[0] = &unk_1F29E15F0;
    v33[1] = &unk_1F29E1130;
    if (v34)
    {
      CFRelease(v34);
    }

    v35[0] = &unk_1F29E15F0;
    v35[1] = &unk_1F29E1130;
    if (v36)
    {
      CFRelease(v36);
    }
  }
}

void grl::drawShadowToContext(void *a1, void *a2, uint64_t a3, float *a4, float a5)
{
  v38 = *MEMORY[0x1E69E9840];
  v6 = *a1;
  if (!v6 || ((*(*v6 + 24))(v6) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v15 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    v33 = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    v34 = 2080;
    v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    v36 = 1024;
    v37 = 557;
    v12 = "A non-nullptr context is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    v13 = v15;
    v14 = 28;
    goto LABEL_19;
  }

  if (!*a2 || ((*(**a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v15 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    v33 = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    v34 = 2080;
    v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    v36 = 1024;
    v37 = 560;
    v12 = "A non-nullptr path is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }

  if ((*(**a2 + 24))())
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v11 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      v12 = "Receieved empty path for drawShadowToContext().";
      v13 = v11;
      v14 = 2;
LABEL_19:
      _os_log_impl(&dword_1B2754000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    }
  }

  else
  {
    v16 = (*(**a1 + 120))();
    Translation = esl::AffineTransformMakeTranslation(0.0, -v16, buf);
    (*(**a2 + 120))(v30, Translation);
    v18 = *&v30[8];
    v26 = *v30;
    v27 = *&v30[8];
    if (*v30 && ((*(**v30 + 16))(*v30) & 1) != 0)
    {
      esl::QuartzColor::QuartzColor(v30, a3);
      esl::QuartzColor::QuartzColor(v28, 0.0, 0.0, 0.0, 1.0);
      if (esl::QuartzColor::isValid(v30) && esl::QuartzColor::isValid(v28))
      {
        (*(**a1 + 408))(*a1);
        v19 = *a1;
        v20 = *a4;
        v21 = a4[1];
        v22 = (*(**a1 + 120))(*a1);
        *v25 = v20;
        *&v25[1] = v21 + v22;
        (*(*v19 + 344))(v19, v25, v30, a2, a5);
        (*(**a1 + 232))(*a1, v28);
        (*(**a1 + 296))(*a1);
        (*(**a1 + 288))(*a1);
        (*(**a1 + 312))(*a1);
        (*(**a1 + 400))(*a1);
      }

      else
      {
        if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
        }

        v24 = GEOGetGeoResourceLibEaselLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v25[0]) = 0;
          _os_log_impl(&dword_1B2754000, v24, OS_LOG_TYPE_ERROR, "Failed to create the shadow color for a path.", v25, 2u);
        }
      }

      v28[0] = &unk_1F29E15F0;
      v28[1] = &unk_1F29E1130;
      if (cf)
      {
        CFRelease(cf);
      }

      *v30 = &unk_1F29E15F0;
      *&v30[8] = &unk_1F29E1130;
      if (*&v30[16])
      {
        CFRelease(*&v30[16]);
      }

      v18 = v27;
    }

    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
      }

      v23 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        *v30 = 136315650;
        *&v30[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
        *&v30[12] = 2080;
        *&v30[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
        *&v30[22] = 1024;
        v31 = 569;
        _os_log_impl(&dword_1B2754000, v23, OS_LOG_TYPE_ERROR, "Failed to create a path for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i", v30, 0x1Cu);
      }
    }

    if (v18)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v18);
    }
  }
}

void grl::drawDebugSquareToContext(void *a1, uint64_t a2, float *a3, float *a4)
{
  v22 = *MEMORY[0x1E69E9840];
  v5 = *a1;
  if (!v5 || ((*(*v5 + 24))(v5) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v12 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v21 = 664;
    v13 = "A non-nullptr context is required for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_11:
    _os_log_impl(&dword_1B2754000, v12, OS_LOG_TYPE_ERROR, v13, buf, 0x1Cu);
    return;
  }

  if (!*(a2 + 3))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v12 = GEOGetGeoResourceLibRendererLog::log;
    if (!os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      return;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v21 = 667;
    v13 = "A non-zero alpha color is required to draw for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_11;
  }

  v9 = a4[1];
  if ((v9 * *a4) > 0.0)
  {
    v10 = a3[1];
    v11 = *a4 + *a3;
    v16 = *a3;
    v17 = v10;
    v18 = v11;
    v19 = v9 + v10;
    esl::QuartzColor::QuartzColor(buf, a2);
    if (esl::QuartzColor::isValid(buf))
    {
      (*(**a1 + 408))(*a1);
      (*(**a1 + 232))(*a1, buf);
      (*(**a1 + 256))();
      (*(**a1 + 400))();
    }

    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
      }

      v14 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        *v15 = 0;
        _os_log_impl(&dword_1B2754000, v14, OS_LOG_TYPE_ERROR, "Failed to create the fill color for a debug square.", v15, 2u);
      }
    }

    *buf = &unk_1F29E15F0;
    *&buf[8] = &unk_1F29E1130;
    if (*&buf[16])
    {
      CFRelease(*&buf[16]);
    }

    return;
  }

  if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
  }

  v12 = GEOGetGeoResourceLibRendererLog::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
  {
    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/EaselUtilities.cpp";
    *&buf[22] = 1024;
    v21 = 670;
    v13 = "A positive size is required for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_11;
  }
}

void grl::drawDebugLine(void *a1, uint64_t a2, float32x2_t *a3, float a4)
{
  v5 = *a1;
  if (v5 && ((*(*v5 + 24))(v5) & 1) != 0)
  {
    if ((*(*a2 + 48))(a2))
    {
      if (a4 >= 0.0)
      {
        __asm { FMOV            V2.2S, #1.0 }

        _D2.i32[0] = fmaxf(a4, 1.0);
        v16[0] = vrnda_f32(*a3);
        v16[1] = vadd_f32(v16[0], _D2);
        (*(**a1 + 408))(*a1);
        (*(**a1 + 232))(*a1, a2);
        (*(**a1 + 256))();
        (*(**a1 + 400))();
        return;
      }

      if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
      }

      v9 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        v16[0].i16[0] = 0;
        v10 = "A positive width is required.";
LABEL_13:
        _os_log_impl(&dword_1B2754000, v9, OS_LOG_TYPE_ERROR, v10, v16, 2u);
      }
    }

    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
      }

      v9 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        v16[0].i16[0] = 0;
        v10 = "A non-nullptr color is required.";
        goto LABEL_13;
      }
    }
  }

  else
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29_53818);
    }

    v9 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      v16[0].i16[0] = 0;
      v10 = "A non-nullptr context is required.";
      goto LABEL_13;
    }
  }
}

void grl::FontKey::~FontKey(grl::FontKey *this)
{
  esl::FontKey::~FontKey(this);

  JUMPOUT(0x1B8C62190);
}

grl::zone_mallocator *std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::vector[abi:nn200100](grl::zone_mallocator *a1, uint64_t *a2, unint64_t a3)
{
  *a1 = 0;
  *(a1 + 1) = 0;
  *(a1 + 2) = 0;
  if (a3)
  {
    if (a3 >> 61)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v6 = grl::zone_mallocator::instance(a1);
    v7 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<void const*>(v6, a3);
    *a1 = v7;
    *(a1 + 1) = v7;
    v8 = 8 * a3;
    *(a1 + 2) = &v7[a3];
    do
    {
      v9 = *a2++;
      *v7++ = v9;
      v8 -= 8;
    }

    while (v8);
    *(a1 + 1) = v7;
  }

  return a1;
}

void grl::FontKey::createDescriptor(void)const::$_0::operator()(uint64_t a1, unsigned int a2, unsigned int a3)
{
  v12 = *MEMORY[0x1E69E9840];
  grl::createCFMutableDictionary(&v10);
  grl::createCFNumber(&v8, a2);
  CFDictionarySetValue(theDict, *MEMORY[0x1E69657B0], value);
  grl::createCFNumber(&v6, a3);
  CFDictionarySetValue(theDict, *MEMORY[0x1E69657A0], cf);
  CFArrayAppendValue(*(*a1 + 8), theDict);
  v6 = &unk_1F2A5F6D8;
  if (cf)
  {
    CFRelease(cf);
  }

  v8 = &unk_1F2A5F6D8;
  if (value)
  {
    CFRelease(value);
  }

  v10 = &unk_1F2A5EFA0;
  if (theDict)
  {
    CFRelease(theDict);
  }
}

void geo::_retain_ptr<__CFArray const*,geo::_retain_cf<__CFArray const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F6B8;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<__CFArray const*,geo::_retain_cf<__CFArray const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F6B8;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned short,grl::ImageProvider>,void *>>(uint64_t a1)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v2 = malloc_type_zone_malloc(*a1, 0x50uLL, 0x1020040656BD866uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v2;
}

uint64_t grl::IconRenderer::description(grl::IconRenderer *this, uint64_t a2)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v84);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", size: (", 9);
  v4 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, ", ", 2);
  v5 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v5, ")", 1);
  v6 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", isStretched: ", 15);
  MEMORY[0x1B8C61C50](v6, *(a2 + 297));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", contentScale: ", 16);
  std::ostream::operator<<();
  v7 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", layer count: ", 15);
  MEMORY[0x1B8C61CB0](v7, *(a2 + 56));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", layers: [", 11);
  v8 = *(a2 + 32);
  if (v8 != (a2 + 40))
  {
    do
    {
      v9 = v8[5];
      if (v9)
      {
        (*(*v9 + 32))(__p);
        v10 = v96 >= 0 ? __p : __p[0];
        v11 = v96 >= 0 ? HIBYTE(v96) : __p[1];
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, v10, v11);
        if (SHIBYTE(v96) < 0)
        {
          operator delete(__p[0]);
        }
      }

      v12 = v8[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = *v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          v13 = v8[2];
          v14 = *v13 == v8;
          v8 = v13;
        }

        while (!v14);
      }

      v8 = v13;
    }

    while (v13 != (a2 + 40));
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, "]", 1);
  v15 = MEMORY[0x1E69E54D8];
  if (*(a2 + 72))
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, ", infoLayerData: [", 18);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](__p);
    v16 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, "{ ", 2);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v16, "alternateImageFamily: ", 22);
    std::to_string(&__dst, *(a2 + 76));
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_dst = &__dst;
    }

    else
    {
      p_dst = __dst.__r_.__value_.__r.__words[0];
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = __dst.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, p_dst, size);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, ", alternateImageTextLimit: ", 27);
    std::to_string(&__dst, *(a2 + 80));
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v19 = &__dst;
    }

    else
    {
      v19 = __dst.__r_.__value_.__r.__words[0];
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v20 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v20 = __dst.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, v19, v20);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    v21 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, ", calloutFillColor: ", 20);
    v22 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v21, "(", 1);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 84);
    v23 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v22, &__dst, 1);
    v24 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 85);
    v25 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v24, &__dst, 1);
    v26 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v25, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 86);
    v27 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v26, &__dst, 1);
    v28 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v27, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 87);
    v29 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v28, &__dst, 1);
    v30 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v29, ", calloutHaloColor: ", 20);
    v31 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, "(", 1);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 88);
    v32 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v31, &__dst, 1);
    v33 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v32, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 89);
    v34 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v33, &__dst, 1);
    v35 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v34, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 90);
    v36 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v35, &__dst, 1);
    v37 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v36, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 91);
    v38 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v37, &__dst, 1);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v38, ", calloutShape: ", 16);
    v39 = "";
    if (*(a2 + 92) == 1)
    {
      v39 = "Square";
    }

    if (*(a2 + 92))
    {
      v40 = v39;
    }

    else
    {
      v40 = "Circle";
    }

    std::string::basic_string[abi:nn200100]<0>(&__dst, v40);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v41 = &__dst;
    }

    else
    {
      v41 = __dst.__r_.__value_.__r.__words[0];
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v42 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v42 = __dst.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, v41, v42);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    v43 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, ", calloutTextColor: ", 20);
    v44 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v43, "(", 1);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 93);
    v45 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v44, &__dst, 1);
    v46 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v45, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 94);
    v47 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v46, &__dst, 1);
    v48 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v47, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 95);
    v49 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v48, &__dst, 1);
    v50 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v49, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 96);
    v51 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v50, &__dst, 1);
    v52 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v51, ", labelAnnotationIconColor: ", 28);
    v53 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v52, "(", 1);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 97);
    v54 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v53, &__dst, 1);
    v55 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v54, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 98);
    v56 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v55, &__dst, 1);
    v57 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v56, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 99);
    v58 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v57, &__dst, 1);
    v59 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v58, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 100);
    v60 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v59, &__dst, 1);
    v61 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v60, ", labelTextColor: ", 18);
    v62 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v61, "(", 1);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 101);
    v63 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v62, &__dst, 1);
    v64 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v63, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 102);
    v65 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v64, &__dst, 1);
    v66 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v65, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 103);
    v67 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v66, &__dst, 1);
    v68 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v67, ", ", 2);
    __dst.__r_.__value_.__s.__data_[0] = *(a2 + 104);
    v69 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v68, &__dst, 1);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v69, ", scale: ", 9);
    std::to_string(&__dst, *(a2 + 108));
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v70 = &__dst;
    }

    else
    {
      v70 = __dst.__r_.__value_.__r.__words[0];
    }

    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v71 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v71 = __dst.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, v70, v71);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v96, " }", 2);
    if ((v103 & 0x10) != 0)
    {
      v73 = v102;
      if (v102 < v99)
      {
        v102 = v99;
        v73 = v99;
      }

      locale = v98[4].__locale_;
    }

    else
    {
      if ((v103 & 8) == 0)
      {
        v72 = 0;
        *(&__dst.__r_.__value_.__s + 23) = 0;
LABEL_68:
        __dst.__r_.__value_.__s.__data_[v72] = 0;
        __p[0] = *v15;
        v75 = *(v15 + 72);
        *(__p + *(__p[0] - 3)) = *(v15 + 64);
        v96 = v75;
        v97 = MEMORY[0x1E69E5548] + 16;
        if (v101 < 0)
        {
          operator delete(v100);
        }

        v97 = MEMORY[0x1E69E5538] + 16;
        std::locale::~locale(v98);
        std::iostream::~basic_iostream();
        MEMORY[0x1B8C620C0](&v104);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v76 = &__dst;
        }

        else
        {
          v76 = __dst.__r_.__value_.__r.__words[0];
        }

        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          v77 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }

        else
        {
          v77 = __dst.__r_.__value_.__l.__size_;
        }

        v78 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v85, v76, v77);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v78, "]", 1);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        goto LABEL_78;
      }

      locale = v98[1].__locale_;
      v73 = v98[3].__locale_;
    }

    v72 = v73 - locale;
    if ((v73 - locale) > 0x7FFFFFFFFFFFFFF7)
    {
      goto LABEL_94;
    }

    if (v72 >= 0x17)
    {
      operator new();
    }

    *(&__dst.__r_.__value_.__s + 23) = v73 - locale;
    if (v72)
    {
      memmove(&__dst, locale, v72);
    }

    goto LABEL_68;
  }

LABEL_78:
  if ((v92 & 0x10) != 0)
  {
    v80 = v91;
    if (v91 < v88)
    {
      v91 = v88;
      v80 = v88;
    }

    v81 = v87[4].__locale_;
  }

  else
  {
    if ((v92 & 8) == 0)
    {
      v79 = 0;
      *(this + 23) = 0;
      goto LABEL_91;
    }

    v81 = v87[1].__locale_;
    v80 = v87[3].__locale_;
  }

  v79 = v80 - v81;
  if ((v80 - v81) > 0x7FFFFFFFFFFFFFF7)
  {
LABEL_94:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v79 >= 0x17)
  {
    operator new();
  }

  *(this + 23) = v79;
  if (v79)
  {
    memmove(this, v81, v79);
  }

LABEL_91:
  *(this + v79) = 0;
  v84[0] = *v15;
  v82 = *(v15 + 72);
  *(v84 + *(v84[0] - 24)) = *(v15 + 64);
  v85 = v82;
  v86 = MEMORY[0x1E69E5548] + 16;
  if (v90 < 0)
  {
    operator delete(v89);
  }

  v86 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v87);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v93);
}

__n128 std::__function::__func<grl::IconRenderer::setupTextLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::less<std::string>,geo::allocator_adapter<std::pair<std::string const,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::zone_mallocator>> const&,grl::IconMetricsRenderInput &)::$_0,std::allocator<grl::IconRenderer::setupTextLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::less<std::string>,geo::allocator_adapter<std::pair<std::string const,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::zone_mallocator>> const&,grl::IconMetricsRenderInput &)::$_0>,void ()(unsigned short,grl::codec::TextLayerData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5F118;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

esl::QuartzImage *std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::operator()@<X0>(uint64_t a1@<X0>, esl::QuartzImage **a2@<X8>)
{
  v10 = *(a1 + 40) | (*(a1 + 44) << 32);
  v9 = 1065353216;
  v3 = *(a1 + 32);
  if (v3)
  {
    v4 = (*(*v3 + 48))(v3, &v10, &v9);
    v5 = grl::zone_mallocator::instance(v4);
    geo::read_write_lock::read_lock((v5 + 32));
    v6 = malloc_type_zone_malloc(*v5, 0x48uLL, 0x108104076DFA842uLL);
    atomic_fetch_add((v5 + 24), 1u);
    geo::read_write_lock::unlock((v5 + 32));
    v6[1] = 0;
    v6[2] = 0;
    *v6 = &unk_1F2A5F0E0;
    result = esl::QuartzImage::QuartzImage((v6 + 4), v4);
    *a2 = result;
    a2[1] = v6;
  }

  else
  {
    v8 = std::__throw_bad_function_call[abi:nn200100]();
    return std::__shared_ptr_emplace<esl::QuartzImage,geo::allocator_adapter<esl::QuartzImage,grl::zone_mallocator>>::__on_zero_shared_weak(v8);
  }

  return result;
}

void std::__shared_ptr_emplace<esl::QuartzImage,geo::allocator_adapter<esl::QuartzImage,grl::zone_mallocator>>::__on_zero_shared_weak(grl::zone_mallocator *a1)
{
  v2 = grl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<esl::QuartzImage,geo::allocator_adapter<esl::QuartzImage,grl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F0E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn200100](a1 + 48);
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](a1 + 8);

  operator delete(a1);
}

uint64_t std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy(uint64_t a1)
{
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn200100](a1 + 48);

  return std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100](a1 + 8);
}

uint64_t std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2A5F098;
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn200100]((a2 + 1), a1 + 8);
  a2[5] = *(a1 + 40);

  return std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn200100]((a2 + 6), a1 + 48);
}

void std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F098;
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn200100]((a1 + 6));
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100]((a1 + 1));

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#2}>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F098;
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn200100]((a1 + 6));
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~__value_func[abi:nn200100]((a1 + 1));
  return a1;
}

uint64_t std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::operator()@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 16);
  *a2 = *(result + 8);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy_deallocate(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }
}

uint64_t std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::__clone(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = &unk_1F2A5F050;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F050;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1},std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0::operator() const(unsigned short,grl::codec::ImageLayerData)::{lambda(void)#1}>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F050;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  return a1;
}

__n128 std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0,std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageProvider,std::less<unsigned short>,geo::allocator_adapter<std::pair<unsigned short const,grl::ImageProvider>,grl::zone_mallocator>> const&)::$_0>,void ()(unsigned short,grl::codec::ImageLayerData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5F008;
  result = *(a1 + 8);
  v3 = *(a1 + 24);
  *(a2 + 40) = *(a1 + 40);
  *(a2 + 24) = v3;
  *(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<grl::IconRenderer::setupPathLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&)::$_0,std::allocator<grl::IconRenderer::setupPathLayerRenderer(grl::codec::IconRenderItem const&,grl::IconModifiers const&)::$_0>,void ()(unsigned short,grl::codec::PathLayerData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5EFC0;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t grl::LayerMetrics::LayerMetrics(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a1 = &unk_1F2A5F240;
  *(a1 + 8) = 0;
  *(a1 + 28) = 0u;
  *(a1 + 44) = 0u;
  *(a1 + 60) = 0u;
  *(a1 + 76) = 0u;
  *(a1 + 12) = 0u;
  v5 = (a1 + 12);
  *(a1 + 44) = *a3;
  *(a1 + 48) = a3[1];
  *(a1 + 12) = 0;
  *(a1 + 16) = 0;
  *(a1 + 20) = *a3;
  *(a1 + 24) = a3[1];
  *(a1 + 28) = 0;
  *(a1 + 36) = 0;
  GradientStartPoint = grl::LayerMetrics::findGradientStartPoint(2u, (a1 + 12), *(a2 + 40));
  *(a1 + 76) = LODWORD(GradientStartPoint);
  *(a1 + 80) = v7;
  v8 = fmodf(*(a2 + 40), 6.2832);
  v9 = fmodf(v8 + 6.2832, 6.2832);
  v10 = grl::LayerMetrics::findGradientStartPoint(2u, v5, v9 + -3.1416);
  *(a1 + 84) = LODWORD(v10);
  *(a1 + 88) = v11;
  return a1;
}

uint64_t grl::ShapeLayerRenderer::description@<X0>(grl::ShapeLayerRenderer *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v111);
  v4 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, "{ ", 2);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, "blendMode: ", 11);
  v5 = *(this + 48);
  v6 = "";
  if (v5 <= 0x1B)
  {
    v6 = off_1E7B582A8[v5];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v6);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", changeHaloAndShadowOrder: ", 28);
  std::to_string(&__p, *(this + 49));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v9 = &__p;
  }

  else
  {
    v9 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v10 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v9, v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", clusterElementHaloColor: ", 27);
  v12 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v11, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 50);
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, &__p, 1);
  v14 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 51);
  v15 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v14, &__p, 1);
  v16 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v15, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 52);
  v17 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v16, &__p, 1);
  v18 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v17, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 53);
  v19 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v18, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v19, ", cornerRadius: ", 16);
  std::to_string(&__p, *(this + 14));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v20 = &__p;
  }

  else
  {
    v20 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v21 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v21 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v20, v21);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v22 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", fillColor: ", 13);
  v23 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v22, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 60);
  v24 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, &__p, 1);
  v25 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v24, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 61);
  v26 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v25, &__p, 1);
  v27 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v26, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 62);
  v28 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v27, &__p, 1);
  v29 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v28, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 63);
  v30 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v29, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, ", fillColorSource: ", 19);
  v31 = "TransitLine";
  if (*(this + 64) != 1)
  {
    v31 = "";
  }

  if (*(this + 64))
  {
    v32 = v31;
  }

  else
  {
    v32 = "IconPack";
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v32);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v33 = &__p;
  }

  else
  {
    v33 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v34 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v33, v34);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v35 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", fillSize: ", 12);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v35, "(", 1);
  v36 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v36, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", fillType: ", 12);
  v37 = *(this + 76);
  if (v37 > 2)
  {
    v38 = "";
  }

  else
  {
    v38 = off_1E7B581E0[v37];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v38);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v39 = &__p;
  }

  else
  {
    v39 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v40 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v39, v40);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", gradientAngle: ", 17);
  std::to_string(&__p, *(this + 20));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v41 = &__p;
  }

  else
  {
    v41 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v42 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v42 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v41, v42);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v43 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", gradientEndColor: ", 20);
  v44 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v43, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 84);
  v45 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v44, &__p, 1);
  v46 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v45, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 85);
  v47 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v46, &__p, 1);
  v48 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v47, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 86);
  v49 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v48, &__p, 1);
  v50 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v49, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 87);
  v51 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v50, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v51, ", gradientEndLocation: ", 23);
  std::to_string(&__p, *(this + 22));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v52 = &__p;
  }

  else
  {
    v52 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v53 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v53 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v52, v53);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v54 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", gradientStartColor: ", 22);
  v55 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v54, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 92);
  v56 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v55, &__p, 1);
  v57 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v56, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 93);
  v58 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v57, &__p, 1);
  v59 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v58, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 94);
  v60 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v59, &__p, 1);
  v61 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v60, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 95);
  v62 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v61, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v62, ", gradientStartLocation: ", 25);
  std::to_string(&__p, *(this + 24));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v63 = &__p;
  }

  else
  {
    v63 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v64 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v64 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v63, v64);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", gradientType: ", 16);
  v65 = *(this + 100);
  if (v65 > 3)
  {
    v66 = "";
  }

  else
  {
    v66 = off_1E7B581F8[v65];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v66);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v67 = &__p;
  }

  else
  {
    v67 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v68 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v68 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v67, v68);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v69 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", haloColor: ", 13);
  v70 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v69, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 101);
  v71 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v70, &__p, 1);
  v72 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v71, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 102);
  v73 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v72, &__p, 1);
  v74 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v73, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 103);
  v75 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v74, &__p, 1);
  v76 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v75, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 104);
  v77 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v76, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v77, ", haloWeight: ", 14);
  std::to_string(&__p, *(this + 27));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v78 = &__p;
  }

  else
  {
    v78 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v79 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v79 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v78, v79);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", isClipPath: ", 14);
  std::to_string(&__p, *(this + 112));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v80 = &__p;
  }

  else
  {
    v80 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v81 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v81 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v80, v81);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", scale: ", 9);
  std::to_string(&__p, *(this + 29));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v82 = &__p;
  }

  else
  {
    v82 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v83 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v83 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v82, v83);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v84 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", shadowColor: ", 15);
  v85 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v84, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 120);
  v86 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v85, &__p, 1);
  v87 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v86, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 121);
  v88 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v87, &__p, 1);
  v89 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v88, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 122);
  v90 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v89, &__p, 1);
  v91 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v90, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 123);
  v92 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v91, &__p, 1);
  v93 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v92, ", shadowOffset: ", 16);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v93, "(", 1);
  v94 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v94, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", shadowWeight: ", 16);
  std::to_string(&__p, *(this + 33));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v95 = &__p;
  }

  else
  {
    v95 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v96 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v96 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v95, v96);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", shapeType: ", 13);
  v97 = *(this + 136);
  if (v97 > 9)
  {
    v98 = "";
  }

  else
  {
    v98 = off_1E7B58258[v97];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v98);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v99 = &__p;
  }

  else
  {
    v99 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v100 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v100 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v99, v100);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", tailDirection: ", 17);
  std::to_string(&__p, *(this + 35));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v101 = &__p;
  }

  else
  {
    v101 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v102 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v102 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v101, v102);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, ", visible: ", 11);
  std::to_string(&__p, *(this + 144));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v103 = &__p;
  }

  else
  {
    v103 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v104 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v104 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, v103, v104);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v112, " }", 2);
  if ((v119 & 0x10) != 0)
  {
    v106 = v118;
    if (v118 < v115)
    {
      v118 = v115;
      v106 = v115;
    }

    locale = v114[4].__locale_;
  }

  else
  {
    if ((v119 & 8) == 0)
    {
      v105 = 0;
      a2[23] = 0;
      goto LABEL_158;
    }

    locale = v114[1].__locale_;
    v106 = v114[3].__locale_;
  }

  v105 = v106 - locale;
  if ((v106 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v105 >= 0x17)
  {
    operator new();
  }

  a2[23] = v105;
  if (v105)
  {
    memmove(a2, locale, v105);
  }

LABEL_158:
  a2[v105] = 0;
  v111[0] = *MEMORY[0x1E69E54D8];
  v108 = *(MEMORY[0x1E69E54D8] + 72);
  *(v111 + *(v111[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v112 = v108;
  v113 = MEMORY[0x1E69E5548] + 16;
  if (v117 < 0)
  {
    operator delete(v116);
  }

  v113 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v114);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v120);
}

BOOL grl::ShapeLayerRenderer::renderBalloonToContext(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v74 = *MEMORY[0x1E69E9840];
  if ((*(a1 + 152) & 1) == 0)
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v9 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
    v72 = 1024;
    v73 = 208;
    v11 = "Nullptr for LayerMetrics being used to render layer.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_15:
    _os_log_impl(&dword_1B2754000, v9, OS_LOG_TYPE_ERROR, v11, buf, 0x1Cu);
    return 0;
  }

  *buf = 0;
  if (!*(a1 + 204))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v9 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (!result)
    {
      return result;
    }

    *buf = 136315650;
    *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
    *&buf[12] = 2080;
    *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
    v72 = 1024;
    v73 = 211;
    v11 = "Metrics must contain a size to draw into a context.: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_15;
  }

  (*(**a2 + 456))(*a2, 1);
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v6 = *(a1 + 296);
  if (*(a1 + 296))
  {
    if (v6 == 6)
    {
      *buf = 513;
      v7 = &buf[2];
      v8 = 2;
      goto LABEL_18;
    }

    if (v6 != 5)
    {
      buf[0] = *(a1 + 296);
      v7 = &buf[1];
      v8 = 1;
      goto LABEL_18;
    }
  }

  *buf = 513;
  buf[2] = 3;
  v7 = &buf[3];
  v8 = 3;
LABEL_18:
  std::vector<grl::IconComponent>::__assign_with_size[abi:nn200100]<grl::IconComponent const*,grl::IconComponent const*>(&v68, buf, v7, v8);
  if (*(a1 + 16) == *(a1 + 24))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v12 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 136315650;
      *&buf[4] = "_data.hasLayerStyles()";
      *&buf[12] = 2080;
      *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
      v72 = 1024;
      v73 = 266;
      _os_log_impl(&dword_1B2754000, v12, OS_LOG_TYPE_ERROR, "Balloon rendering needs LayerStyles to render.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }

  v13 = *(a1 + 16);
  v40 = *(a1 + 24);
  if (v13 != v40)
  {
    v15 = v68;
    v14 = v69;
    while (1)
    {
      v16 = *v13;
      v17 = v15;
      if (v15 != v14)
      {
        break;
      }

LABEL_99:
      if (*(a4 + 1))
      {
        (*(**a2 + 392))(buf);
        operator new();
      }

      if (++v13 == v40)
      {
        goto LABEL_102;
      }
    }

    while (1)
    {
      grl::ShapeLayerRenderer::renderBalloonToContext(std::shared_ptr<esl::QuartzContext>,std::list<std::shared_ptr<esl::QuartzImage>> &,grl::LayerRenderToContextOptions &)const::$_0::operator()(&v67, (a1 + 160), *v17, *(a1 + 136), v16);
      v18 = v67;
      if (v67 && ((*(*v67 + 24))(v67) & 1) == 0)
      {
        if (v16 > 1)
        {
          if (v16 == 2)
          {
            v24 = 60;
            if (*(a1 + 108) > 0.0)
            {
              v24 = 101;
            }

            *buf = *(a1 + v24);
            if (!*(a1 + 104))
            {
              goto LABEL_28;
            }

            v21 = a2[1];
            v47[0] = *a2;
            v47[1] = v21;
            if (v21)
            {
              atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            v45 = v18;
            v46 = *(&v67 + 1);
            if (*(&v67 + 1))
            {
              atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
            }

            grl::drawFillToContext(v47, &v45, buf, 0);
            v22 = v46;
            if (!v46)
            {
              goto LABEL_65;
            }

            goto LABEL_64;
          }

          if (v16 == 3 && *(a1 + 123) && (*(a1 + 124) || *(a1 + 132) != 0.0))
          {
            v21 = a2[1];
            v44[0] = *a2;
            v44[1] = v21;
            if (v21)
            {
              atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            v42 = v18;
            v43 = *(&v67 + 1);
            if (*(&v67 + 1))
            {
              atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
            }

            v54.i32[0] = *(a1 + 120);
            *buf = *(a1 + 124);
            grl::drawShadowToContext(v44, &v42, &v54, buf, *(a1 + 132));
            v22 = v43;
            if (!v43)
            {
              goto LABEL_65;
            }

LABEL_64:
            std::__shared_weak_count::__release_shared[abi:nn200100](v22);
LABEL_65:
            if (v21)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v21);
            }
          }
        }

        else
        {
          if (!v16)
          {
            if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
            {
              dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
            }

            v23 = GEOGetGeoResourceLibRendererLog::log;
            if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
            {
              *buf = 136315650;
              *&buf[4] = "iconLayer != LayerStyle::None";
              *&buf[12] = 2080;
              *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
              v72 = 1024;
              v73 = 276;
              _os_log_impl(&dword_1B2754000, v23, OS_LOG_TYPE_ERROR, "Invalid LayerStyle enum used in createLayer().: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
            }

            goto LABEL_28;
          }

          v66 = *(a1 + 60);
          v19 = vmaxnm_f32(vsub_f32(*(a1 + 180), *(a1 + 172)), 0);
          if (vmul_lane_f32(v19, v19, 1).f32[0] > 0.0)
          {
            v20 = *(a1 + 76);
            if (v20 < 2)
            {
              v21 = a2[1];
              v65[0] = *a2;
              v65[1] = v21;
              if (v21)
              {
                atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              v63 = v18;
              v64 = *(&v67 + 1);
              if (*(&v67 + 1))
              {
                atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
              }

              grl::drawFillToContext(v65, &v63, &v66, 0);
              v22 = v64;
              if (v64)
              {
                goto LABEL_64;
              }

              goto LABEL_65;
            }

            if (v20 == 2)
            {
              v25 = *(a1 + 100);
              if (v25 > 1)
              {
                if (v25 == 2)
                {
                  v30.f32[0] = gm::Box<float,2>::operator+((a1 + 172), (a1 + 212));
                  v32.i32[1] = v31;
                  v30.i32[1] = v33;
                  v34 = vmla_f32(v30, 0x3F0000003F000000, vsub_f32(v32, v30));
                  *buf = v34;
                  v35 = *(a1 + 244);
                  v36 = *(a1 + 212);
                  v21 = a2[1];
                  v53[0] = *a2;
                  v53[1] = v21;
                  if (v21)
                  {
                    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
                  }

                  v51 = v18;
                  v52 = *(&v67 + 1);
                  if (*(&v67 + 1))
                  {
                    atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
                  }

                  v37 = vsub_f32(vadd_f32(v36, v35), v34);
                  v38 = sqrtf(vaddv_f32(vmul_f32(v37, v37)));
                  v54.i32[0] = *(a1 + 92);
                  v37.f32[0] = *(a1 + 96) * v38;
                  v56 = *(a1 + 84);
                  grl::drawRadialGradientToContext(v53, &v51, &v54, v37.f32[0], *(a1 + 88) * v38, buf, &v56, *(a1 + 48));
                  v22 = v52;
                  if (v52)
                  {
                    goto LABEL_64;
                  }

                  goto LABEL_65;
                }

                if (v25 == 3)
                {
                  v21 = a2[1];
                  v50[0] = *a2;
                  v50[1] = v21;
                  if (v21)
                  {
                    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
                  }

                  v48 = v18;
                  v49 = *(&v67 + 1);
                  if (*(&v67 + 1))
                  {
                    atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
                  }

                  v28 = *(a1 + 92);
                  v29 = *(a1 + 212);
                  *buf = vadd_f32(v29, *(a1 + 236));
                  v55 = *(a1 + 84);
                  v56 = v28;
                  v54 = vadd_f32(v29, *(a1 + 244));
                  grl::drawReflectedGradientToContext(v50, &v48, &v56, buf, &v55);
                  v22 = v49;
                  if (v49)
                  {
                    goto LABEL_64;
                  }

                  goto LABEL_65;
                }
              }

              else
              {
                if (!*(a1 + 100))
                {
                  v21 = a2[1];
                  v62[0] = *a2;
                  v62[1] = v21;
                  if (v21)
                  {
                    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
                  }

                  v60 = v18;
                  v61 = *(&v67 + 1);
                  if (*(&v67 + 1))
                  {
                    atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
                  }

                  grl::drawFillToContext(v62, &v60, &v66, 0);
                  v22 = v61;
                  if (v61)
                  {
                    goto LABEL_64;
                  }

                  goto LABEL_65;
                }

                if (v25 == 1)
                {
                  v21 = a2[1];
                  v59[0] = *a2;
                  v59[1] = v21;
                  if (v21)
                  {
                    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
                  }

                  v57 = v18;
                  v58 = *(&v67 + 1);
                  if (*(&v67 + 1))
                  {
                    atomic_fetch_add_explicit((*(&v67 + 1) + 8), 1uLL, memory_order_relaxed);
                  }

                  v26 = *(a1 + 92);
                  v27 = *(a1 + 212);
                  *buf = vadd_f32(v27, *(a1 + 236));
                  v55 = *(a1 + 84);
                  v56 = v26;
                  v54 = vadd_f32(v27, *(a1 + 244));
                  grl::drawLinearGradientToContext(v59, &v57, &v56, buf, &v55);
                  v22 = v58;
                  if (v58)
                  {
                    goto LABEL_64;
                  }

                  goto LABEL_65;
                }
              }
            }
          }
        }
      }

LABEL_28:
      if (*(&v67 + 1))
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](*(&v67 + 1));
      }

      if (++v17 == v14)
      {
        goto LABEL_99;
      }
    }
  }

LABEL_102:
  if (*(a1 + 112))
  {
    grl::ShapeLayerRenderer::renderBalloonToContext(std::shared_ptr<esl::QuartzContext>,std::list<std::shared_ptr<esl::QuartzImage>> &,grl::LayerRenderToContextOptions &)const::$_0::operator()(buf, (a1 + 160), *(a1 + 296), *(a1 + 136), 1);
    if (!*buf)
    {
      grl::ShapeLayerRenderer::renderBalloonToContext(std::shared_ptr<esl::QuartzContext>,std::list<std::shared_ptr<esl::QuartzImage>> &,grl::LayerRenderToContextOptions &)const::$_0::operator()(&v67, (a1 + 160), *(a1 + 296), *(a1 + 136), 2);
      v39 = *&buf[8];
      *buf = v67;
      if (v39)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v39);
      }
    }

    (*(**a2 + 288))(*a2, buf);
    (*(**a2 + 264))();
    if (*&buf[8])
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](*&buf[8]);
    }
  }

  if (v68)
  {
    operator delete(v68);
  }

  return 1;
}

void *std::vector<grl::IconComponent>::__assign_with_size[abi:nn200100]<grl::IconComponent const*,grl::IconComponent const*>(void *result, char *__src, char *a3, unint64_t a4)
{
  v6 = result;
  v7 = result[2];
  v8 = *result;
  if (v7 - *result < a4)
  {
    if (v8)
    {
      result[1] = v8;
      operator delete(v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }

    v9 = 2 * v7;
    if (2 * v7 <= a4)
    {
      v9 = a4;
    }

    if (v7 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v9;
    }

    if ((v10 & 0x8000000000000000) == 0)
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v11 = result[1];
  v12 = v11 - v8;
  if (v11 - v8 >= a4)
  {
    v17 = a3 - __src;
    if (v17)
    {
      result = memmove(*result, __src, v17);
    }

    v16 = &v8[v17];
  }

  else
  {
    v13 = &__src[v12];
    if (v11 != v8)
    {
      result = memmove(*result, __src, v12);
      v11 = v6[1];
    }

    v14 = v11;
    if (v13 != a3)
    {
      v14 = v11;
      do
      {
        v15 = *v13++;
        *v14++ = v15;
      }

      while (v13 != a3);
    }

    v16 = v14;
  }

  v6[1] = v16;
  return result;
}

void grl::ShapeLayerRenderer::renderBalloonToContext(std::shared_ptr<esl::QuartzContext>,std::list<std::shared_ptr<esl::QuartzImage>> &,grl::LayerRenderToContextOptions &)const::$_0::operator()(uint64_t a1, float *a2, int a3, unsigned int a4, int a5)
{
  v27 = *MEMORY[0x1E69E9840];
  if (a3 <= 2)
  {
    if (a3 >= 2)
    {
      if (a3 == 2)
      {
        if (a5 != 1)
        {
          if (a4 <= 8 && ((1 << a4) & 0x118) != 0)
          {
            transformFromMetrics(buf, a2);
            v8 = &balloonComponentPathDefinitions;
          }

          else
          {
            transformFromMetrics(buf, a2);
            v8 = &unk_1E7B57E78;
          }

LABEL_31:
          pathFromParameters(v25, v8);
          v20 = *(&v25[0] + 1);
          (*(**&v25[0] + 120))(v25);
          *a1 = v25[0];
          if (v20)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v20);
          }

          return;
        }

LABEL_19:
        *a1 = 0;
        *(a1 + 8) = 0;
        return;
      }

      goto LABEL_20;
    }

LABEL_10:
    v9 = 7;
    if (a5 == 1)
    {
      v9 = 3;
    }

    v10 = gm::Box<float,2>::operator+(&a2[v9], a2 + 13);
    v21 = v13;
    v22 = v12;
    v23 = v11;
    v24 = v10;
    if (a4 <= 8 && ((1 << a4) & 0x118) != 0)
    {
      operator new();
    }

    v17 = vsub_f32(__PAIR64__(LODWORD(v13), LODWORD(v12)), __PAIR64__(LODWORD(v11), LODWORD(v10)));
    if ((fmaxf(v17.f32[0], v17.f32[1]) / fminf(v17.f32[1], v17.f32[0])) > 1.5)
    {
      operator new();
    }

    v18 = a2[24];
    esl::QuartzAffineTransform::QuartzAffineTransform(buf);
    esl::QuartzAffineTransform::translate(v19, v24, v23);
    esl::QuartzAffineTransform::scale(buf, v22 - v24, v21 - v23);
    esl::QuartzAffineTransform::translate(buf, 0.5, 0.5);
    esl::QuartzAffineTransform::rotate(buf, v18 + -1.5708);
    v8 = &unk_1E7B57E98;
    goto LABEL_31;
  }

  if (a3 == 3)
  {
    if (a4 <= 9 && ((1 << a4) & 0x350) != 0 && (a5 != 1 || (a4 & 0xFE) == 8))
    {
      if (a4 == 8 || a4 == 4)
      {
        operator new();
      }

      operator new();
    }

    goto LABEL_19;
  }

  if (a3 == 6)
  {
    goto LABEL_10;
  }

LABEL_20:
  _ZNSt3__115allocate_sharedB8nn200100IN3esl10QuartzPathEN3geo17allocator_adapterIS2_N3grl15zone_mallocatorEEEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_(a1, buf);
  v14 = *(**a1 + 32);
  v15.n128_u64[0] = 0;
  v16.n128_u64[0] = 0;

  v14(v15, v16);
}

esl::QuartzPath *_ZNSt3__115allocate_sharedB8nn200100IN3esl10QuartzPathEN3geo17allocator_adapterIS2_N3grl15zone_mallocatorEEEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_(esl::QuartzPath **a1, char *a2)
{
  v4 = grl::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v4 + 32));
  v5 = malloc_type_zone_malloc(*v4, 0x30uLL, 0x1081040ED926357uLL);
  atomic_fetch_add((v4 + 24), 1u);
  geo::read_write_lock::unlock((v4 + 32));
  v6 = *a2;
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &unk_1F2A5F2D0;
  *(v5 + 24) = v6;
  result = esl::QuartzPath::QuartzPath((v5 + 4));
  *a1 = result;
  a1[1] = v5;
  return result;
}

void std::__shared_ptr_emplace<esl::QuartzPath,geo::allocator_adapter<esl::QuartzPath,grl::zone_mallocator>>::__on_zero_shared_weak(grl::zone_mallocator *a1)
{
  v2 = grl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v2, a1);
}

void std::__shared_ptr_emplace<esl::QuartzPath,geo::allocator_adapter<esl::QuartzPath,grl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F2D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t grl::ImageLayerRenderer::description@<X0>(grl::ImageLayerRenderer *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v110);
  v4 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, "{ ", 2);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, "blendMode: ", 11);
  v5 = *(this + 48);
  v6 = "";
  if (v5 <= 0x1B)
  {
    v6 = off_1E7B582A8[v5];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v6);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", changeHaloAndShadowOrder: ", 28);
  std::to_string(&__p, *(this + 49));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v9 = &__p;
  }

  else
  {
    v9 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v10 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v9, v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", fillColor: ", 13);
  v12 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v11, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 50);
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, &__p, 1);
  v14 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 51);
  v15 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v14, &__p, 1);
  v16 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v15, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 52);
  v17 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v16, &__p, 1);
  v18 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v17, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 53);
  v19 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v18, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v19, ", fillColorSource: ", 19);
  v20 = "TransitLine";
  if (*(this + 54) != 1)
  {
    v20 = "";
  }

  if (*(this + 54))
  {
    v21 = v20;
  }

  else
  {
    v21 = "IconPack";
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v21);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v22 = &__p;
  }

  else
  {
    v22 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v23 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v22, v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v24 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", fillSize: ", 12);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v24, "(", 1);
  v25 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v25, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", fillType: ", 12);
  v26 = *(this + 64);
  if (v26 > 2)
  {
    v27 = "";
  }

  else
  {
    v27 = off_1E7B581E0[v26];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v27);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v28 = &__p;
  }

  else
  {
    v28 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v29 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v28, v29);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", gradientAngle: ", 17);
  std::to_string(&__p, *(this + 17));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v30 = &__p;
  }

  else
  {
    v30 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v31 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v30, v31);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v32 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", gradientEndColor: ", 20);
  v33 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v32, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 72);
  v34 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v33, &__p, 1);
  v35 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v34, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 73);
  v36 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v35, &__p, 1);
  v37 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v36, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 74);
  v38 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v37, &__p, 1);
  v39 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v38, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 75);
  v40 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v39, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v40, ", gradientEndLocation: ", 23);
  std::to_string(&__p, *(this + 19));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v41 = &__p;
  }

  else
  {
    v41 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v42 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v42 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v41, v42);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v43 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", gradientStartColor: ", 22);
  v44 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v43, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 80);
  v45 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v44, &__p, 1);
  v46 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v45, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 81);
  v47 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v46, &__p, 1);
  v48 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v47, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 82);
  v49 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v48, &__p, 1);
  v50 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v49, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 83);
  v51 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v50, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v51, ", gradientStartLocation: ", 25);
  std::to_string(&__p, *(this + 21));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v52 = &__p;
  }

  else
  {
    v52 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v53 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v53 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v52, v53);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", gradientType: ", 16);
  v54 = *(this + 88);
  v55 = "";
  if (v54 <= 3)
  {
    v55 = off_1E7B581F8[v54];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v55);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v56 = &__p;
  }

  else
  {
    v56 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v57 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v57 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v56, v57);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v58 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", haloColor: ", 13);
  v59 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v58, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 89);
  v60 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v59, &__p, 1);
  v61 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v60, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 90);
  v62 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v61, &__p, 1);
  v63 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v62, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 91);
  v64 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v63, &__p, 1);
  v65 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v64, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 92);
  v66 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v65, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v66, ", haloWeight: ", 14);
  std::to_string(&__p, *(this + 24));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v67 = &__p;
  }

  else
  {
    v67 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v68 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v68 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v67, v68);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v69 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", horizontalPadding: ", 21);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v69, "(", 1);
  v70 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v70, ", ", 2);
  std::ostream::operator<<();
  v71 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", horizontalStretchPadding: ", 28);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v71, "(", 1);
  v72 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v72, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", imageDataSource: ", 19);
  v73 = "External";
  if (*(this + 116) != 1)
  {
    v73 = "";
  }

  if (*(this + 116))
  {
    v74 = v73;
  }

  else
  {
    v74 = "IconPack";
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v74);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v75 = &__p;
  }

  else
  {
    v75 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v76 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v76 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v75, v76);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v77 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", imageOffset: ", 15);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v77, "(", 1);
  v78 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v78, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", imageStretchType: ", 20);
  v79 = *(this + 128);
  if (v79 > 2)
  {
    v80 = "";
  }

  else
  {
    v80 = off_1E7B58218[v79];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v80);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v81 = &__p;
  }

  else
  {
    v81 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v82 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v82 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v81, v82);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", opacity: ", 11);
  std::to_string(&__p, *(this + 33));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v83 = &__p;
  }

  else
  {
    v83 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v84 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v84 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v83, v84);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v85 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", shadowColor: ", 15);
  v86 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v85, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 136);
  v87 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v86, &__p, 1);
  v88 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v87, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 137);
  v89 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v88, &__p, 1);
  v90 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v89, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 138);
  v91 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v90, &__p, 1);
  v92 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v91, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 139);
  v93 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v92, &__p, 1);
  v94 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v93, ", shadowOffset: ", 16);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v94, "(", 1);
  v95 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v95, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", shadowWeight: ", 16);
  std::to_string(&__p, *(this + 37));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v96 = &__p;
  }

  else
  {
    v96 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v97 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v97 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v96, v97);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", useShapeRect: ", 16);
  std::to_string(&__p, *(this + 152));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v98 = &__p;
  }

  else
  {
    v98 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v99 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v99 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v98, v99);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v100 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", verticalPadding: ", 19);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v100, "(", 1);
  v101 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v101, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, ", visible: ", 11);
  std::to_string(&__p, *(this + 164));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v102 = &__p;
  }

  else
  {
    v102 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v103 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v103 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, v102, v103);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v111, " }", 2);
  if ((v118 & 0x10) != 0)
  {
    v105 = v117;
    if (v117 < v114)
    {
      v117 = v114;
      v105 = v114;
    }

    locale = v113[4].__locale_;
  }

  else
  {
    if ((v118 & 8) == 0)
    {
      v104 = 0;
      a2[23] = 0;
      goto LABEL_154;
    }

    locale = v113[1].__locale_;
    v105 = v113[3].__locale_;
  }

  v104 = v105 - locale;
  if ((v105 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v104 >= 0x17)
  {
    operator new();
  }

  a2[23] = v104;
  if (v104)
  {
    memmove(a2, locale, v104);
  }

LABEL_154:
  a2[v104] = 0;
  v110[0] = *MEMORY[0x1E69E54D8];
  v107 = *(MEMORY[0x1E69E54D8] + 72);
  *(v110 + *(v110[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v111 = v107;
  v112 = MEMORY[0x1E69E5548] + 16;
  if (v116 < 0)
  {
    operator delete(v115);
  }

  v112 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v113);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v119);
}

uint64_t grl::TextLayerRenderer::description@<X0>(grl::TextLayerRenderer *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v102);
  v4 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, "{ ", 2);
  v5 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, "fillColor: ", 11);
  v6 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v5, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 48);
  v7 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v6, &__p, 1);
  v8 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v7, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 49);
  v9 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v8, &__p, 1);
  v10 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 50);
  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v10, &__p, 1);
  v12 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v11, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 51);
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, ", fillColorSource: ", 19);
  v14 = "";
  if (*(this + 52) == 1)
  {
    v14 = "TransitLine";
  }

  if (*(this + 52))
  {
    v15 = v14;
  }

  else
  {
    v15 = "IconPack";
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v15);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v18 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", fontName: ", 12);
  v19 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v18, "", 1);
  v20 = *(this + 79);
  if (v20 >= 0)
  {
    v21 = this + 56;
  }

  else
  {
    v21 = *(this + 7);
  }

  if (v20 >= 0)
  {
    v22 = *(this + 79);
  }

  else
  {
    v22 = *(this + 8);
  }

  v23 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v19, v21, v22);
  v24 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, "", 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v24, ", fontSize: ", 12);
  std::to_string(&__p, *(this + 20));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v25 = &__p;
  }

  else
  {
    v25 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v26 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v25, v26);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v27 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", haloColor: ", 13);
  v28 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v27, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 84);
  v29 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v28, &__p, 1);
  v30 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v29, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 85);
  v31 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, &__p, 1);
  v32 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v31, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 86);
  v33 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v32, &__p, 1);
  v34 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v33, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 87);
  v35 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v34, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v35, ", haloWeight: ", 14);
  std::to_string(&__p, *(this + 22));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v36 = &__p;
  }

  else
  {
    v36 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v37 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v36, v37);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v38 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", horizontalPadding: ", 21);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v38, "(", 1);
  v39 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v39, ", ", 2);
  std::ostream::operator<<();
  v40 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", nonDigitTextColor: ", 21);
  v41 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v40, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 100);
  v42 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v41, &__p, 1);
  v43 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v42, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 101);
  v44 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v43, &__p, 1);
  v45 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v44, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 102);
  v46 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v45, &__p, 1);
  v47 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v46, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 103);
  v48 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v47, &__p, 1);
  v49 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v48, ", nonDigitTextFontName: ", 24);
  v50 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v49, "", 1);
  v51 = *(this + 127);
  if (v51 >= 0)
  {
    v52 = this + 104;
  }

  else
  {
    v52 = *(this + 13);
  }

  if (v51 >= 0)
  {
    v53 = *(this + 127);
  }

  else
  {
    v53 = *(this + 14);
  }

  v54 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v50, v52, v53);
  v55 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v54, "", 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v55, ", nonDigitTextFontSize: ", 24);
  std::to_string(&__p, *(this + 32));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v56 = &__p;
  }

  else
  {
    v56 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v57 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v57 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v56, v57);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v58 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", nonDigitTextHaloColor: ", 25);
  v59 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v58, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 132);
  v60 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v59, &__p, 1);
  v61 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v60, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 133);
  v62 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v61, &__p, 1);
  v63 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v62, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 134);
  v64 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v63, &__p, 1);
  v65 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v64, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 135);
  v66 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v65, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v66, ", nonDigitTextHaloWeight: ", 26);
  std::to_string(&__p, *(this + 34));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v67 = &__p;
  }

  else
  {
    v67 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v68 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v68 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v67, v68);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v69 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", shadowColor: ", 15);
  v70 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v69, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 140);
  v71 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v70, &__p, 1);
  v72 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v71, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 141);
  v73 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v72, &__p, 1);
  v74 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v73, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 142);
  v75 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v74, &__p, 1);
  v76 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v75, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 143);
  v77 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v76, &__p, 1);
  v78 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v77, ", shadowOffset: ", 16);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v78, "(", 1);
  v79 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v79, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", shadowWeight: ", 16);
  std::to_string(&__p, *(this + 38));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v80 = &__p;
  }

  else
  {
    v80 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v81 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v81 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v80, v81);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v82 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", text: ", 8);
  v83 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v82, "", 1);
  v86 = *(this + 20);
  v85 = this + 160;
  v84 = v86;
  v87 = v85[23];
  if (v87 >= 0)
  {
    v88 = v85;
  }

  else
  {
    v88 = v84;
  }

  if (v87 >= 0)
  {
    v89 = v85[23];
  }

  else
  {
    v89 = *(v85 + 1);
  }

  v90 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v83, v88, v89);
  v91 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v90, "", 1);
  v92 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v91, ", textPosition: ", 16);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v92, "(", 1);
  v93 = std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v93, ", ", 2);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, ", visible: ", 11);
  std::to_string(&__p, v85[32]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v94 = &__p;
  }

  else
  {
    v94 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v95 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v95 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, v94, v95);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v103, " }", 2);
  if ((v110 & 0x10) != 0)
  {
    v97 = v109;
    if (v109 < v106)
    {
      v109 = v106;
      v97 = v106;
    }

    locale = v105[4].__locale_;
  }

  else
  {
    if ((v110 & 8) == 0)
    {
      v96 = 0;
      a2[23] = 0;
      goto LABEL_93;
    }

    locale = v105[1].__locale_;
    v97 = v105[3].__locale_;
  }

  v96 = v97 - locale;
  if ((v97 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v96 >= 0x17)
  {
    operator new();
  }

  a2[23] = v96;
  if (v96)
  {
    memmove(a2, locale, v96);
  }

LABEL_93:
  a2[v96] = 0;
  v102[0] = *MEMORY[0x1E69E54D8];
  v99 = *(MEMORY[0x1E69E54D8] + 72);
  *(v102 + *(v102[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v103 = v99;
  v104 = MEMORY[0x1E69E5548] + 16;
  if (v108 < 0)
  {
    operator delete(v107);
  }

  v104 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v105);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v111);
}

__n128 grl::TextLayerRenderer::setLayerMetrics(grl::TextLayerRenderer *this, const grl::LayerMetrics *a2)
{
  if (*(this + 200) == 1)
  {
    (**(this + 26))();
  }

  else
  {
    *(this + 200) = 1;
  }

  *(this + 26) = &unk_1F2A5F240;
  v4 = *(a2 + 8);
  *(this + 232) = *(a2 + 24);
  *(this + 216) = v4;
  result = *(a2 + 40);
  v6 = *(a2 + 56);
  v7 = *(a2 + 72);
  *(this + 74) = *(a2 + 22);
  *(this + 264) = v6;
  *(this + 280) = v7;
  *(this + 248) = result;
  *(this + 26) = &unk_1F2A5F308;
  *(this + 300) = *(a2 + 92);
  return result;
}

BOOL grl::TextLayerRenderer::renderToContext(uint64_t a1, CGContextRef **a2, uint64_t a3, uint64_t a4)
{
  v47 = *MEMORY[0x1E69E9840];
  if (*(a1 + 183) < 0)
  {
    std::string::__init_copy_ctor_external(&v45, *(a1 + 160), *(a1 + 168));
  }

  else
  {
    v45 = *(a1 + 160);
  }

  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
  {
    size = v45.__r_.__value_.__l.__size_;
    operator delete(v45.__r_.__value_.__l.__data_);
    if (!size)
    {
      return 0;
    }
  }

  else if (!*(&v45.__r_.__value_.__s + 23))
  {
    return 0;
  }

  if (*(a1 + 200))
  {
    v45.__r_.__value_.__r.__words[0] = 0;
    if (*(a1 + 252))
    {
      if (*a4 == 1 && *(a4 + 4) == 1)
      {
        v10 = gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
        v12 = v11;
        v13 = v9;
        v45.__r_.__value_.__r.__words[0] = __PAIR64__(LODWORD(v11), LODWORD(v10));
        v45.__r_.__value_.__l.__size_ = __PAIR64__(LODWORD(v9), LODWORD(v8));
        v14 = a2[1];
        v44[0] = *a2;
        v44[1] = v14;
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v43 = 1342177535;
        v36 = __PAIR64__(LODWORD(v9), LODWORD(v10));
        v15 = v8 - v10;
        v16 = fmaxf(v8 - v10, 0.0);
        v17 = fmaxf(*(a4 + 8) - v9, 0.0);
        v41 = LODWORD(v16);
        v42 = v17;
        grl::drawDebugSquareToContext(v44, &v43, &v36, &v41);
        if (v14)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v14);
        }

        v18 = a2[1];
        v40[0] = *a2;
        v40[1] = v18;
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v41 = 1342177535;
        *&v36 = v15;
        *(&v36 + 1) = v13 - v12;
        if (v15 < 0.0)
        {
          LODWORD(v36) = 0;
        }

        if ((v13 - v12) < 0.0)
        {
          HIDWORD(v36) = 0;
        }

        grl::drawDebugSquareToContext(v40, &v41, &v45, &v36);
        if (v18)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v18);
        }

        v19 = a2[1];
        v39[0] = *a2;
        v39[1] = v19;
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        v43 = -1275068161;
        v36 = LODWORD(v10);
        v41 = LODWORD(v16);
        v42 = fmaxf(v12, 0.0);
        grl::drawDebugSquareToContext(v39, &v43, &v36, &v41);
        if (v19)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v19);
        }
      }

      v20 = (COERCE_FLOAT(*(a1 + 260)) + COERCE_FLOAT(*(a1 + 300)));
      gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
      v22 = v21;
      v23 = *a2;
      if (*(a1 + 344))
      {
        CGContextSetTextPosition(v23[1], v20, v21);
        CTLineDraw(*(a1 + 344), (*a2)[1]);
        v23 = *a2;
        if (*(a4 + 1) == 1)
        {
          (*(*v23 + 49))(&v45);
          operator new();
        }
      }

      CGContextSetTextPosition(v23[1], v20, v22);
      CTLineDraw(*(a1 + 320), (*a2)[1]);
      if (*(a4 + 1) == 1)
      {
        (*(**a2 + 49))(&v45);
        operator new();
      }

      if (*(a4 + 2) == 1)
      {
        esl::QuartzColor::QuartzColor(&v45, 1.0, 0.752, 0.796, 1.0);
        v24 = gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
        gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
        v36 = __PAIR64__(v25, LODWORD(v24));
        v26 = gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
        grl::drawDebugLine(a2, &v45, &v36, fmaxf(v27 - v26, 0.0));
        v45.__r_.__value_.__r.__words[0] = &unk_1F29E15F0;
        v45.__r_.__value_.__l.__size_ = &unk_1F29E1130;
        if (v45.__r_.__value_.__r.__words[2])
        {
          CFRelease(v45.__r_.__value_.__r.__words[2]);
        }

        if (*(a4 + 2))
        {
          esl::QuartzColor::QuartzColor(&v45, 1.0, 0.752, 0.796, 1.0);
          LODWORD(v36) = gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
          HIDWORD(v36) = v28;
          v37 = v29;
          v38 = v30;
          v31 = gm::Box<float,2>::operator+((a1 + 220), (a1 + 260));
          grl::drawDebugLine(a2, &v45, &v36, fmaxf(v32 - v31, 0.0));
          v45.__r_.__value_.__r.__words[0] = &unk_1F29E15F0;
          v45.__r_.__value_.__l.__size_ = &unk_1F29E1130;
          if (v45.__r_.__value_.__r.__words[2])
          {
            CFRelease(v45.__r_.__value_.__r.__words[2]);
          }
        }
      }

      return 1;
    }

    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v34 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LODWORD(v45.__r_.__value_.__l.__data_) = 136315650;
      *(v45.__r_.__value_.__r.__words + 4) = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
      WORD2(v45.__r_.__value_.__r.__words[1]) = 2080;
      *(&v45.__r_.__value_.__r.__words[1] + 6) = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
      HIWORD(v45.__r_.__value_.__r.__words[2]) = 1024;
      v46 = 609;
      v35 = "Metrics must contain a size to draw into a context.: Assertion with expression - %s : Failed in file - %s line - %i";
      goto LABEL_48;
    }
  }

  else
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v34 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LODWORD(v45.__r_.__value_.__l.__data_) = 136315650;
      *(v45.__r_.__value_.__r.__words + 4) = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
      WORD2(v45.__r_.__value_.__r.__words[1]) = 2080;
      *(&v45.__r_.__value_.__r.__words[1] + 6) = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
      HIWORD(v45.__r_.__value_.__r.__words[2]) = 1024;
      v46 = 606;
      v35 = "Nullptr for LayerMetrics being used to render layer.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_48:
      _os_log_impl(&dword_1B2754000, v34, OS_LOG_TYPE_ERROR, v35, &v45, 0x1Cu);
      return 0;
    }
  }

  return result;
}

void grl::TextLayerRenderer::~TextLayerRenderer(grl::TextLayerRenderer *this)
{
  grl::TextLayerRenderer::~TextLayerRenderer(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F1D0;
  *(this + 42) = &unk_1F2A5F268;
  v2 = *(this + 43);
  if (v2)
  {
    CFRelease(v2);
  }

  *(this + 39) = &unk_1F2A5F268;
  v3 = *(this + 40);
  if (v3)
  {
    CFRelease(v3);
  }

  if (*(this + 200) == 1)
  {
    (**(this + 26))(this + 208);
    *(this + 200) = 0;
  }

  if (*(this + 183) < 0)
  {
    operator delete(*(this + 20));
  }

  if (*(this + 127) < 0)
  {
    operator delete(*(this + 13));
  }

  if (*(this + 79) < 0)
  {
    operator delete(*(this + 7));
  }

  std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 16));
}

uint64_t grl::ColorLayerRenderer::description@<X0>(grl::ColorLayerRenderer *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v32);
  v4 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, "{ ", 2);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, "blendMode: ", 11);
  v5 = *(this + 48);
  if (v5 > 0x1B)
  {
    v6 = "";
  }

  else
  {
    v6 = off_1E7B582A8[v5];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v6);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v9 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, ", fillColor: ", 13);
  v10 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, "(", 1);
  __p.__r_.__value_.__s.__data_[0] = *(this + 49);
  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v10, &__p, 1);
  v12 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v11, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 50);
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, &__p, 1);
  v14 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 51);
  v15 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v14, &__p, 1);
  v16 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v15, ", ", 2);
  __p.__r_.__value_.__s.__data_[0] = *(this + 52);
  v17 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v16, &__p, 1);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v17, ", gradientAngle: ", 17);
  std::to_string(&__p, *(this + 14));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v18 = &__p;
  }

  else
  {
    v18 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v19 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v19 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, v18, v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, ", gradientType: ", 16);
  v20 = *(this + 60);
  if (v20 > 3)
  {
    v21 = "";
  }

  else
  {
    v21 = off_1E7B581F8[v20];
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, v21);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v22 = &__p;
  }

  else
  {
    v22 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v23 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, v22, v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, ", visible: ", 11);
  std::to_string(&__p, *(this + 61));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v24 = &__p;
  }

  else
  {
    v24 = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v25 = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, v24, v25);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v33, " }", 2);
  if ((v40 & 0x10) != 0)
  {
    v27 = v39;
    if (v39 < v36)
    {
      v39 = v36;
      v27 = v36;
    }

    locale = v35[4].__locale_;
  }

  else
  {
    if ((v40 & 8) == 0)
    {
      v26 = 0;
      a2[23] = 0;
      goto LABEL_52;
    }

    locale = v35[1].__locale_;
    v27 = v35[3].__locale_;
  }

  v26 = v27 - locale;
  if ((v27 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v26 >= 0x17)
  {
    operator new();
  }

  a2[23] = v26;
  if (v26)
  {
    memmove(a2, locale, v26);
  }

LABEL_52:
  a2[v26] = 0;
  v32[0] = *MEMORY[0x1E69E54D8];
  v29 = *(MEMORY[0x1E69E54D8] + 72);
  *(v32 + *(v32[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v33 = v29;
  v34 = MEMORY[0x1E69E5548] + 16;
  if (v38 < 0)
  {
    operator delete(v37);
  }

  v34 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v35);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v41);
}

__n128 grl::ColorLayerRenderer::setLayerMetrics(void (***this)(void), const grl::LayerMetrics *a2)
{
  if (*(this + 64) == 1)
  {
    (*this[9])();
  }

  else
  {
    *(this + 64) = 1;
  }

  this[9] = &unk_1F2A5F240;
  v4 = *(a2 + 24);
  *(this + 5) = *(a2 + 8);
  *(this + 6) = v4;
  result = *(a2 + 40);
  v6 = *(a2 + 56);
  v7 = *(a2 + 72);
  *(this + 40) = *(a2 + 22);
  *(this + 8) = v6;
  *(this + 9) = v7;
  *(this + 7) = result;
  return result;
}

BOOL grl::ColorLayerRenderer::renderToContext(uint64_t a1)
{
  v12 = *MEMORY[0x1E69E9840];
  if (*(a1 + 64))
  {
    *buf = 0;
    if (*(a1 + 116))
    {
      if (*(a1 + 16) == *(a1 + 24))
      {
        if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
        }

        v2 = GEOGetGeoResourceLibRendererLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 136315650;
          *&buf[4] = "_data.hasLayerStyles()";
          *&buf[12] = 2080;
          *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
          v10 = 1024;
          v11 = 732;
          _os_log_impl(&dword_1B2754000, v2, OS_LOG_TYPE_ERROR, "No LayerStyles given for color layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
        }
      }

      v3 = *(a1 + 16);
      for (i = *(a1 + 24); v3 != i; ++v3)
      {
        if (*v3 == 1)
        {
          operator new();
        }

        if (!*v3)
        {
          if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
          }

          v5 = GEOGetGeoResourceLibRendererLog::log;
          if (os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
          {
            *buf = 136315650;
            *&buf[4] = "iconLayer != LayerStyle::None";
            *&buf[12] = 2080;
            *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
            v10 = 1024;
            v11 = 736;
            _os_log_impl(&dword_1B2754000, v5, OS_LOG_TYPE_ERROR, "Invalid LayerStyle enum used.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
          }
        }
      }

      return 1;
    }

    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v6 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *buf = 136315650;
      *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
      *&buf[12] = 2080;
      *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
      v10 = 1024;
      v11 = 727;
      v8 = "Metrics must contain a size to draw into a context.: Assertion with expression - %s : Failed in file - %s line - %i";
      goto LABEL_27;
    }
  }

  else
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_53794);
    }

    v6 = GEOGetGeoResourceLibRendererLog::log;
    result = os_log_type_enabled(GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *buf = 136315650;
      *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
      *&buf[12] = 2080;
      *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/LayerRenderer.cpp";
      v10 = 1024;
      v11 = 724;
      v8 = "Nullptr for LayerMetrics being used to render layer.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_27:
      _os_log_impl(&dword_1B2754000, v6, OS_LOG_TYPE_ERROR, v8, buf, 0x1Cu);
      return 0;
    }
  }

  return result;
}

void grl::ColorLayerRenderer::~ColorLayerRenderer(grl::ColorLayerRenderer *this)
{
  grl::ColorLayerRenderer::~ColorLayerRenderer(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F208;
  if (*(this + 64) == 1)
  {
    (**(this + 9))(this + 72);
    *(this + 64) = 0;
  }

  std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((this + 16));
}

uint64_t geo::_retain_ptr<__CTLine const*,geo::_retain_cf<__CTLine const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::operator=(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
  }

  v4 = *(a1 + 8);
  if (v4)
  {
    CFRelease(v4);
  }

  *(a1 + 8) = cf;
  return a1;
}

void *std::__tree<std::__value_type<unsigned short,gm::Box<float,2>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,gm::Box<float,2>>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,gm::Box<float,2>>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[14];
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = (v7 + 1);
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x30uLL, 0x10200405B834C99uLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 14) = **a3;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

void *std::__tree<std::__value_type<unsigned short,float>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,float>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,float>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[14];
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = (v7 + 1);
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x28uLL, 0x10200408542BB31uLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 14) = **a3;
    *(v7 + 8) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

void pathFromParameters(esl::QuartzPath **a1, uint64_t a2)
{
  v175 = *MEMORY[0x1E69E9840];
  std::string::basic_string[abi:nn200100]<0>(buf, *(a2 + 8));
  grl::parseCommandList(v168, buf);
  if (v174 < 0)
  {
    operator delete(*buf);
  }

  v140 = a2;
  std::string::basic_string[abi:nn200100]<0>(v166, *(a2 + 8));
  grl::parseCommandList(&v171, v166);
  _ZNSt3__115allocate_sharedB8nn200100IN3esl10QuartzPathEN3geo17allocator_adapterIS2_N3grl15zone_mallocatorEEEJELi0EEENS_10shared_ptrIT_EERKT0_DpOT1_(a1, buf);
  v5 = v171;
  v6 = v172;
  if (v171 != v172)
  {
    v7 = 0;
    v4.n128_u64[0] = 0;
    v160 = v4;
    v4.n128_u64[0] = 0;
    v161 = v4;
    v8 = 2.0;
    v4.n128_u64[0] = 0;
    v159 = v4;
    v142 = v172;
    while (1)
    {
      LOBYTE(__p[0]) = *v5;
      std::vector<unsigned int>::vector[abi:nn200100](&__p[1], (v5 + 8));
      v10 = LOBYTE(__p[0]);
      if (LOBYTE(__p[0]) <= 0x59u)
      {
        if (LOBYTE(__p[0]) > 0x50u)
        {
          v11 = v161.n128_u64[0];
          if (LOBYTE(__p[0]) > 0x53u)
          {
            if (LOBYTE(__p[0]) == 84)
            {
              goto LABEL_93;
            }

            if (LOBYTE(__p[0]) == 86)
            {
              goto LABEL_63;
            }
          }

          else
          {
            if (LOBYTE(__p[0]) == 81)
            {
              goto LABEL_103;
            }

            if (LOBYTE(__p[0]) == 83)
            {
LABEL_108:
              v113 = *a1;
              v73 = a1[1];
              if (v73)
              {
                atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              v114 = 0;
              v115 = (((v7 - 67) >> 4) | (16 * (v7 - 67)));
              v116 = v159;
              if (v115 >= 4)
              {
                v116.n128_f32[0] = *&v11;
              }

              v158 = *(&v11 + 1);
              v159 = v116;
              v117 = v160;
              if (v115 >= 4)
              {
                v117.n128_f32[0] = *(&v11 + 1);
              }

              v160 = v117;
              v151.n128_u32[0] = v11;
              while (1)
              {
                v118 = (v170 - __p[1]) >> 2;
                v119 = grl::PathCommand::expectedFloatCount(v10);
                if (v114 >= v118 / v119)
                {
                  break;
                }

                v120 = v119 * v114;
                v121 = -(v159.n128_f32[0] - (v151.n128_f32[0] * v8));
                v122 = -(v160.n128_f32[0] - (v158 * v8));
                v123.n128_u64[0] = grl::pointAtIndex(__p, v119 * v114, v161.n128_u64[0]);
                v159 = v123;
                v160 = v124;
                v125.n128_u32[0] = grl::pointAtIndex(__p, v120 + 2, v161.n128_u64[0]).u32[0];
                v151 = v125;
                v158 = v126;
                (*(*v113 + 48))(v113, 0, v121, v122, v159, v160);
                v127 = v151;
                v127.n128_f32[1] = v158;
                v161 = v127;
                ++v114;
                LOBYTE(v10) = __p[0];
              }

              goto LABEL_117;
            }
          }
        }

        else
        {
          v11 = v161.n128_u64[0];
          if (LOBYTE(__p[0]) > 0x4Bu)
          {
            if (LOBYTE(__p[0]) - 76 < 2)
            {
LABEL_79:
              v74 = *a1;
              v73 = a1[1];
              if (v73)
              {
                atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              for (i = 0; ; ++i)
              {
                v76 = (v170 - __p[1]) >> 2;
                v77 = grl::PathCommand::expectedFloatCount(v10);
                if (i >= v76 / v77)
                {
                  break;
                }

                v78.n128_u64[0] = grl::pointAtIndex(__p, v77 * i, v161.n128_u64[0]);
                v154 = v79;
                v163 = v78;
                if (i || (LOBYTE(__p[0]) | 0x20) != 0x6D)
                {
                  (*(*v74 + 40))(v74, 0);
                }

                else
                {
                  (*(*v74 + 32))(v74, 0);
                }

                v80 = v163;
                v80.n128_u32[1] = v154;
                v161 = v80;
                LOBYTE(v10) = __p[0];
              }

              goto LABEL_117;
            }
          }

          else
          {
            switch(LOBYTE(__p[0]))
            {
              case 'A':
                goto LABEL_24;
              case 'C':
LABEL_88:
                v81 = *a1;
                v73 = a1[1];
                if (v73)
                {
                  atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
                }

                for (j = 0; ; ++j)
                {
                  v83 = (v170 - __p[1]) >> 2;
                  v84 = grl::PathCommand::expectedFloatCount(v10);
                  if (j >= v83 / v84)
                  {
                    break;
                  }

                  v85 = v84 * j;
                  LODWORD(v86) = grl::pointAtIndex(__p, v84 * j, v161.n128_u64[0]).u32[0];
                  v88 = v87;
                  v89.n128_u64[0] = grl::pointAtIndex(__p, v85 + 2, v161.n128_u64[0]);
                  v159 = v89;
                  v160 = v90;
                  v91.n128_u32[0] = grl::pointAtIndex(__p, v85 + 4, v161.n128_u64[0]).u32[0];
                  v164 = v91;
                  v155 = v92;
                  (*(*v81 + 48))(v81, 0, v86, v88, v159, v160);
                  v93 = v164;
                  v93.n128_u32[1] = v155;
                  v161 = v93;
                  LOBYTE(v10) = __p[0];
                }

                goto LABEL_117;
              case 'H':
                goto LABEL_63;
            }
          }
        }

        goto LABEL_131;
      }

      if (LOBYTE(__p[0]) > 0x6Bu)
      {
        v11 = v161.n128_u64[0];
        if (LOBYTE(__p[0]) > 0x72u)
        {
          switch(LOBYTE(__p[0]))
          {
            case 's':
              goto LABEL_108;
            case 't':
LABEL_93:
              v94 = *a1;
              v73 = a1[1];
              if (v73)
              {
                atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
              }

              if (v7 - 81 > 0x23 || ((1 << (v7 - 81)) & 0x900000009) == 0)
              {
                v9.n128_u32[0] = HIDWORD(v11);
                v160 = v9;
                v9.n128_u32[0] = v11;
                v159 = v9;
              }

              v95 = 0;
              v156 = *(&v11 + 1);
              v150.n128_u32[0] = v11;
              while (1)
              {
                v96 = (v170 - __p[1]) >> 2;
                v97 = grl::PathCommand::expectedFloatCount(v10);
                if (v95 >= v96 / v97)
                {
                  break;
                }

                v98 = v159;
                v98.n128_f32[0] = (v150.n128_f32[0] - v159.n128_f32[0]) + v150.n128_f32[0];
                v159 = v98;
                v99 = v160;
                v99.n128_f32[0] = (v156 - v160.n128_f32[0]) + v156;
                v160 = v99;
                v100.n128_u32[0] = grl::pointAtIndex(__p, v97 * v95, v161.n128_u64[0]).u32[0];
                v150 = v100;
                v156 = v101;
                (*(*v94 + 56))(v94, 0, v159, v160);
                v102 = v150;
                v102.n128_f32[1] = v156;
                v161 = v102;
                ++v95;
                LOBYTE(v10) = __p[0];
              }

              goto LABEL_117;
            case 'v':
              goto LABEL_63;
          }
        }

        else
        {
          if (LOBYTE(__p[0]) - 108 < 2)
          {
            goto LABEL_79;
          }

          if (LOBYTE(__p[0]) == 113)
          {
LABEL_103:
            v103 = *a1;
            v73 = a1[1];
            if (v73)
            {
              atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
            }

            for (k = 0; ; ++k)
            {
              v105 = (v170 - __p[1]) >> 2;
              v106 = grl::PathCommand::expectedFloatCount(v10);
              if (k >= v105 / v106)
              {
                break;
              }

              v107 = v106 * k;
              v108.n128_u64[0] = grl::pointAtIndex(__p, v106 * k, v161.n128_u64[0]);
              v159 = v108;
              v160 = v109;
              v110.n128_u64[0] = grl::pointAtIndex(__p, v107 + 2, v161.n128_u64[0]);
              v165 = v110;
              v157 = v111;
              (*(*v103 + 56))(v103, 0);
              v112 = v165;
              v112.n128_u32[1] = v157;
              v161 = v112;
              LOBYTE(v10) = __p[0];
            }

LABEL_117:
            if (v73)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v73);
            }

            goto LABEL_119;
          }
        }

        goto LABEL_131;
      }

      v11 = v161.n128_u64[0];
      if (LOBYTE(__p[0]) > 0x62u)
      {
        break;
      }

      if (LOBYTE(__p[0]) != 90)
      {
        if (LOBYTE(__p[0]) == 97)
        {
LABEL_24:
          v141 = v7;
          v13 = *a1;
          v12 = a1[1];
          if (v12)
          {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v14 = 0;
          v15 = *(&v11 + 1);
          v148 = *&v11;
          while (1)
          {
            v16 = __p[1];
            v17 = (v170 - __p[1]) >> 2;
            v18 = grl::PathCommand::expectedFloatCount(v10);
            if (v14 >= v17 / v18)
            {
              break;
            }

            v19 = &v16[4 * v18 * v14];
            v20 = *v19;
            v21 = v19[1];
            v22 = v19[2];
            v23 = v19[3];
            v24 = v19[4];
            v25.n128_u64[0] = grl::pointAtIndex(__p, v18 * v14 + 5, v161.n128_u64[0]);
            if (v20 == 0.0 || v21 == 0.0)
            {
              (*(*v13 + 40))(v13, 0, v25);
            }

            else
            {
              v145 = v24;
              v27 = v24 > 0.0;
              v149 = v26;
              v152 = v25;
              v28 = fabsf(v21);
              v29 = fabsf(v20);
              v144 = v22 * 0.017453;
              v30 = __sincosf_stret(v22 * 0.017453);
              v146 = v15;
              v31 = (((v152.n128_f32[0] - v148) * v30.__cosval) + ((v149 - v15) * v30.__sinval)) * 0.5;
              v32 = -((((v152.n128_f32[0] - v148) * v30.__sinval) + ((v148 - v149) * v30.__cosval)) * 0.5);
              v33 = v20 * v20;
              v34 = v21 * v21;
              v35 = ((v31 * v31) / (v20 * v20)) + ((v32 * v32) / (v21 * v21));
              v36 = sqrtf(v35);
              if (v35 <= 1.0)
              {
                v37 = 1.0;
              }

              else
              {
                v37 = v36;
              }

              v38 = v37 * v28;
              v39 = v37 * v29;
              v40 = ((v32 * v32) * v33) + ((v31 * v31) * v34);
              v41 = sqrtf(-(v40 - (v34 * v33)) / v40);
              if (v23 <= 0.0 != v27)
              {
                v41 = -v41;
              }

              v42 = ((v39 * v32) * v41) / v38;
              v43 = ((v38 * v31) * v41) / v39;
              v147 = v39;
              v44 = (v31 - v42) / v39;
              v162 = v38;
              v45 = (v32 - v43) / v38;
              v46 = (v44 * v44) + (v45 * v45);
              v47 = v44 / sqrtf(v46);
              v48 = -1.0;
              v49 = -1.0;
              if (v47 >= -1.0)
              {
                v49 = v47;
                if (v47 > 1.0)
                {
                  v49 = 1.0;
                }
              }

              v50 = fabsf(acosf(v49));
              if (v45 < 0.0)
              {
                v50 = -v50;
              }

              v143 = v50;
              v51 = -(v42 + v31) / v147;
              v52 = -(v43 - ((((v152.n128_f32[0] - v148) * v30.__sinval) + ((v148 - v149) * v30.__cosval)) * 0.5)) / v162;
              v53 = ((v51 * v44) + (v52 * v45)) / sqrtf(((v51 * v51) + (v52 * v52)) * v46);
              if (v53 >= -1.0)
              {
                v48 = v53;
                if (v53 > 1.0)
                {
                  v48 = 1.0;
                }
              }

              v54 = fabsf(acosf(v48));
              if ((v52 * v44) < (v51 * v45))
              {
                v54 = -v54;
              }

              if (v145 <= 0.0 || v54 >= 0.0)
              {
                if (v145 > 0.0 || v54 <= 0.0)
                {
                  v55 = v54;
                }

                else
                {
                  v55 = v54 + -6.2832;
                }
              }

              else
              {
                v55 = v54 + 6.2832;
              }

              esl::QuartzAffineTransform::QuartzAffineTransform(buf);
              esl::QuartzAffineTransform::translate(v56, (((v148 + v152.n128_f32[0]) * 0.5) + (v42 * v30.__cosval)) - (v43 * v30.__sinval), (((v146 + v149) * 0.5) + (v43 * v30.__cosval)) + (v42 * v30.__sinval));
              esl::QuartzAffineTransform::rotate(buf, v144);
              esl::QuartzAffineTransform::scale(buf, v147, v162);
              (*(*v13 + 72))(v13, v145 > 0.0, buf, 0.0, 0.0, 1.0, v143, v55 + v143);
              v57 = v152;
              v57.n128_f32[1] = v149;
              v161 = v57;
              v15 = v149;
              v148 = v152.n128_f32[0];
              v8 = 2.0;
            }

            ++v14;
            LOBYTE(v10) = __p[0];
          }

          if (v12)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v12);
          }

          v7 = v141;
          goto LABEL_119;
        }

LABEL_131:
        if (GEOGetGeoResourceLibSVGLog(void)::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibSVGLog(void)::onceToken, &__block_literal_global_53444);
        }

        v135 = GEOGetGeoResourceLibSVGLog(void)::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibSVGLog(void)::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 0;
          _os_log_impl(&dword_1B2754000, v135, OS_LOG_TYPE_ERROR, "Unhandled path command", buf, 2u);
        }

        goto LABEL_119;
      }

      v132 = *a1;
      (*(**a1 + 112))(*a1);
      v133.n128_f64[0] = (*(*v132 + 96))(v132);
      v159 = v133;
      v160 = v134;
      v133.n128_u32[1] = v134.n128_u32[0];
      v161 = v133;
LABEL_119:
      v128 = (v170 - __p[1]) >> 2;
      v129 = SLOBYTE(__p[0]);
      v130 = v128 % grl::PathCommand::expectedFloatCount(SLOBYTE(__p[0]));
      if (v130)
      {
        if (GEOGetGeoResourceLibSVGLog(void)::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibSVGLog(void)::onceToken, &__block_literal_global_53444);
        }

        v131 = GEOGetGeoResourceLibSVGLog(void)::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibSVGLog(void)::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 67109120;
          *&buf[4] = SLOBYTE(__p[0]);
          _os_log_impl(&dword_1B2754000, v131, OS_LOG_TYPE_ERROR, "Incorrect number of arguments for command: %c", buf, 8u);
        }
      }

      else
      {
        v7 = v129;
      }

      if (__p[1])
      {
        v170 = __p[1];
        operator delete(__p[1]);
      }

      if (!v130)
      {
        v5 += 32;
        if (v5 != v6)
        {
          continue;
        }
      }

      goto LABEL_136;
    }

    if (LOBYTE(__p[0]) == 99)
    {
      goto LABEL_88;
    }

    if (LOBYTE(__p[0]) == 104)
    {
LABEL_63:
      v58 = v7;
      v60 = *a1;
      v59 = a1[1];
      if (v59)
      {
        atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v61 = 0;
      v62 = v10 & 0xDF;
      v63 = ((v10 - 97) < 0x16) & (0x2D1885u >> (v10 - 97));
      v9.n128_u32[0] = HIDWORD(v11);
      v153 = v9;
      while (1)
      {
        v64 = __p[1];
        v65 = (v170 - __p[1]) >> 2;
        v66 = grl::PathCommand::expectedFloatCount(v10);
        if (v61 >= v65 / v66)
        {
          break;
        }

        v67 = v64[v66 * v61];
        v68 = v161;
        v69 = v153;
        if (v63)
        {
          v70 = v153.n128_f32[0] + v67;
          v71 = v161.n128_f32[0] + v67;
          if (v62 == 72)
          {
            v68.n128_f32[0] = v71;
          }

          else
          {
            v69.n128_f32[0] = v70;
          }
        }

        else if (v62 == 72)
        {
          v68.n128_f32[0] = v64[v66 * v61];
        }

        else
        {
          v69.n128_f32[0] = v64[v66 * v61];
        }

        v161 = v68;
        v153 = v69;
        (*(*v60 + 40))(v60, 0);
        ++v61;
        LOBYTE(v10) = __p[0];
      }

      v72 = v161;
      v72.n128_u32[1] = v153.n128_u32[0];
      v161 = v72;
      if (v59)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v59);
      }

      v7 = v58;
      v6 = v142;
      goto LABEL_119;
    }

    goto LABEL_131;
  }

LABEL_136:
  *buf = &v171;
  std::vector<geo::c3mm::C3mmEntrySection<unsigned char>>::__destroy_vector::operator()[abi:nn200100](buf);
  if (v167 < 0)
  {
    operator delete(v166[0]);
  }

  esl::QuartzAffineTransform::QuartzAffineTransform(buf);
  esl::QuartzAffineTransform::scale(v136, v140[6], v140[7]);
  v137 = esl::QuartzAffineTransform::translate(buf, v140[4], v140[5]);
  (*(**a1 + 120))(__p, v137);
  v138 = *__p;
  __p[0] = 0;
  __p[1] = 0;
  v139 = a1[1];
  *a1 = v138;
  if (v139)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v139);
    if (__p[1])
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](__p[1]);
    }
  }

  *buf = v168;
  std::vector<geo::c3mm::C3mmEntrySection<unsigned char>>::__destroy_vector::operator()[abi:nn200100](buf);
}

CGFloat transformFromMetrics(const grl::PathLayerMetrics *a1, float *a2)
{
  esl::QuartzAffineTransform::QuartzAffineTransform(a1);
  esl::QuartzAffineTransform::translate(v4, a2[13], a2[14]);
  esl::QuartzAffineTransform::translate(a1, a2[28], a2[29]);
  esl::QuartzAffineTransform::rotate(a1, a2[24] + -1.5708);
  v5 = a2[26];

  return esl::QuartzAffineTransform::scale(a1, v5, v5);
}

uint64_t grl::PathCommand::expectedFloatCount(int a1)
{
  result = 0;
  if (a1 > 96)
  {
    v3 = a1 - 104;
    if ((a1 - 104) <= 0xE)
    {
      if (((1 << v3) & 0x1030) != 0)
      {
        return 2;
      }

      if (((1 << v3) & 0xA00) != 0)
      {
        return 4;
      }

      if (((1 << v3) & 0x4001) != 0)
      {
        return 1;
      }
    }

    if (a1 != 97)
    {
      if (a1 != 99)
      {
        return result;
      }

      return 6;
    }

    return 7;
  }

  if (a1 <= 80)
  {
    if (a1 <= 75)
    {
      if (a1 != 65)
      {
        if (a1 != 67)
        {
          if (a1 != 72)
          {
            return result;
          }

          return 1;
        }

        return 6;
      }

      return 7;
    }

    if ((a1 - 76) >= 2)
    {
      return result;
    }

    return 2;
  }

  if (a1 > 83)
  {
    if (a1 != 84)
    {
      if (a1 != 86)
      {
        return result;
      }

      return 1;
    }

    return 2;
  }

  if (a1 == 81 || a1 == 83)
  {
    return 4;
  }

  return result;
}

void grl::parseCommandList(void *a1, uint64_t a2)
{
  v2 = a1;
  v51 = 0;
  v59 = *MEMORY[0x1E69E9840];
  v3 = *(a2 + 23);
  if (v3 >= 0)
  {
    v4 = a2;
  }

  else
  {
    v4 = *a2;
  }

  if (v3 >= 0)
  {
    v5 = *(a2 + 23);
  }

  else
  {
    v5 = *(a2 + 8);
  }

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v6 = MEMORY[0x1E69E9830];
LABEL_8:
  v7 = &v4[v5];
  v8 = v4 + 1;
  --v5;
  ++v4;
  while (1)
  {
    v9 = *(v4 - 1);
    if (v9 != 44)
    {
      break;
    }

    if (v5 == -1)
    {
      return;
    }

LABEL_19:
    ++v4;
    ++v8;
    --v5;
  }

  if ((v9 & 0x80000000) != 0)
  {
    v10 = __maskrune(v9, 0x4000uLL);
  }

  else
  {
    v10 = *(v6 + 4 * v9 + 60) & 0x4000;
  }

  if (v10)
  {
    v11 = v5 == -1;
  }

  else
  {
    v11 = 1;
  }

  if (!v11)
  {
    goto LABEL_19;
  }

  if (v5 == -1)
  {
    return;
  }

  v12 = *(v4 - 1);
  v13 = v12 - 65;
  if ((v12 - 65) <= 0x39)
  {
    if (((1 << v13) & 0x2D1885002D1885) != 0)
    {
      goto LABEL_23;
    }

    if (((1 << v13) & 0x200000002000000) != 0)
    {
      v12 = 90;
LABEL_23:
      v54 = 0;
      v55 = 0;
      v56 = 0;
      buf[0] = v12;
      if (!grl::PathCommand::expectedFloatCount(v12))
      {
        v27 = 0;
        goto LABEL_56;
      }

      v49 = v12;
      v50 = v2;
      v14 = 0;
      v15 = v4;
      v52 = v7;
      while (2)
      {
        while (1)
        {
          v16 = *v15;
          if (v16 == 44)
          {
            break;
          }

          if ((v16 & 0x80000000) != 0)
          {
            if (__maskrune(v16, 0x4000uLL))
            {
              break;
            }
          }

          else if ((*(v6 + 4 * v16 + 60) & 0x4000) != 0)
          {
            break;
          }

          if (v15 == v7)
          {
            goto LABEL_55;
          }

          v17 = *v15;
          if ((v17 > 0x2E || ((1 << v17) & 0x680000000000) == 0) && ((v17 & 0x80) != 0 || (*(v6 + 4 * v17 + 60) & 0x400) == 0))
          {
            goto LABEL_54;
          }

          __idx = 0;
          std::string::__init_with_size[abi:nn200100]<char *,char *>(&__str, v15, v7, v7 - v15);
          v18 = std::stof(&__str, &__idx);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__str.__r_.__value_.__l.__data_);
          }

          if (!__idx)
          {
            v14 = v55;
LABEL_54:
            v7 = v15;
LABEL_55:
            v2 = v50;
            v4 += v7 - v8;
            v5 -= v7 - v8;
            v27 = v54;
            if (v54 == v14)
            {
              if (GEOGetGeoResourceLibSVGLog(void)::onceToken != -1)
              {
                dispatch_once(&GEOGetGeoResourceLibSVGLog(void)::onceToken, &__block_literal_global_53444);
              }

              v35 = GEOGetGeoResourceLibSVGLog(void)::log;
              if (os_log_type_enabled(GEOGetGeoResourceLibSVGLog(void)::log, OS_LOG_TYPE_ERROR))
              {
                LODWORD(__str.__r_.__value_.__l.__data_) = 67109120;
                HIDWORD(__str.__r_.__value_.__r.__words[0]) = v49;
                _os_log_impl(&dword_1B2754000, v35, OS_LOG_TYPE_ERROR, "Error reading arguments for command: %c", &__str, 8u);
              }

              v36 = 0;
              v51 = 1;
              if (v27)
              {
LABEL_83:
                v55 = v27;
                operator delete(v27);
              }
            }

            else
            {
LABEL_56:
              v28 = v2[1];
              v29 = v2[2];
              if (v28 >= v29)
              {
                v31 = (v28 - *v2) >> 5;
                v32 = v31 + 1;
                if ((v31 + 1) >> 59)
                {
                  std::__throw_bad_array_new_length[abi:nn200100]();
                }

                v33 = v29 - *v2;
                if (v33 >> 4 > v32)
                {
                  v32 = v33 >> 4;
                }

                if (v33 >= 0x7FFFFFFFFFFFFFE0)
                {
                  v34 = 0x7FFFFFFFFFFFFFFLL;
                }

                else
                {
                  v34 = v32;
                }

                if (v34)
                {
                  if (!(v34 >> 59))
                  {
                    operator new();
                  }

                  std::__throw_bad_array_new_length[abi:nn200100]();
                }

                v37 = 32 * v31;
                *v37 = buf[0];
                v30 = 32 * v31 + 32;
                std::vector<unsigned int>::vector[abi:nn200100]((v37 + 8), &v54);
                v38 = v2;
                v39 = v2[1];
                v40 = v38;
                v41 = *v38;
                v42 = *v38 - v39;
                v43 = v37 + v42;
                if (v42)
                {
                  v44 = v41;
                  v45 = v43;
                  do
                  {
                    *v45 = *v44;
                    *(v45 + 16) = 0;
                    *(v45 + 24) = 0;
                    *(v45 + 8) = 0;
                    *(v45 + 8) = *(v44 + 8);
                    *(v45 + 24) = *(v44 + 24);
                    *(v44 + 8) = 0;
                    *(v44 + 16) = 0;
                    *(v44 + 24) = 0;
                    v44 += 32;
                    v45 += 32;
                  }

                  while (v44 != v39);
                  do
                  {
                    v46 = *(v41 + 8);
                    if (v46)
                    {
                      *(v41 + 16) = v46;
                      operator delete(v46);
                    }

                    v41 += 32;
                  }

                  while (v41 != v39);
                }

                v2 = v40;
                v47 = *v40;
                *v40 = v43;
                v40[1] = v30;
                v40[2] = 0;
                if (v47)
                {
                  operator delete(v47);
                }

                v27 = v54;
              }

              else
              {
                *v28 = buf[0];
                v30 = v28 + 32;
                std::vector<unsigned int>::vector[abi:nn200100]((v28 + 8), &v54);
              }

              v2[1] = v30;
              v36 = 1;
              if (v27)
              {
                goto LABEL_83;
              }
            }

            if ((v36 & 1) == 0)
            {
              if ((v51 & 1) == 0)
              {
                *buf = v2;
                std::vector<geo::c3mm::C3mmEntrySection<unsigned char>>::__destroy_vector::operator()[abi:nn200100](buf);
              }

              return;
            }

            goto LABEL_8;
          }

          v19 = v55;
          if (v55 >= v56)
          {
            v20 = v54;
            v21 = v55 - v54;
            v22 = v55 - v54;
            v23 = v22 + 1;
            if ((v22 + 1) >> 62)
            {
              std::__throw_bad_array_new_length[abi:nn200100]();
            }

            v24 = v56 - v54;
            if ((v56 - v54) >> 1 > v23)
            {
              v23 = v24 >> 1;
            }

            if (v24 >= 0x7FFFFFFFFFFFFFFCLL)
            {
              v25 = 0x3FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v25 = v23;
            }

            if (v25)
            {
              std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(v25);
            }

            v26 = (4 * v22);
            *v26 = v18;
            v14 = v26 + 1;
            memcpy(0, v20, v21);
            v54 = 0;
            v56 = 0;
            if (v20)
            {
              operator delete(v20);
            }

            v7 = v52;
          }

          else
          {
            *v55 = v18;
            v14 = v19 + 1;
          }

          v55 = v14;
          v15 += __idx;
        }

        ++v15;
        continue;
      }
    }
  }

  if (GEOGetGeoResourceLibSVGLog(void)::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibSVGLog(void)::onceToken, &__block_literal_global_53444);
  }

  v48 = GEOGetGeoResourceLibSVGLog(void)::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibSVGLog(void)::log, OS_LOG_TYPE_ERROR))
  {
    *buf = 0;
    _os_log_impl(&dword_1B2754000, v48, OS_LOG_TYPE_ERROR, "Unrecognized character while parsing command type", buf, 2u);
  }
}

os_log_t ___ZL26GEOGetGeoResourceLibSVGLogv_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "SVG");
  GEOGetGeoResourceLibSVGLog(void)::log = result;
  return result;
}

float32x2_t grl::pointAtIndex(unsigned __int8 *a1, uint64_t a2, float32x2_t a3)
{
  v18 = *MEMORY[0x1E69E9840];
  v3 = *(a1 + 1);
  if (a2 + 1 >= ((*(a1 + 2) - v3) >> 2))
  {
    if (GEOGetGeoResourceLibSVGLog(void)::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibSVGLog(void)::onceToken, &__block_literal_global_53444);
    }

    v10 = GEOGetGeoResourceLibSVGLog(void)::log;
    v11 = os_log_type_enabled(GEOGetGeoResourceLibSVGLog(void)::log, OS_LOG_TYPE_ERROR);
    *&result = 0.0;
    if (v11)
    {
      v12 = 136315650;
      v13 = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
      v14 = 2080;
      v15 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/SVGParser.cpp";
      v16 = 1024;
      v17 = 208;
      _os_log_impl(&dword_1B2754000, v10, OS_LOG_TYPE_ERROR, "Invalid float index: Assertion with expression - %s : Failed in file - %s line - %i", &v12, 0x1Cu);
      *&result = 0.0;
    }
  }

  else
  {
    v4 = *(v3 + 4 * a2);
    v5 = *a1 - 97;
    v6 = v5 > 0x15;
    v7 = (1 << v5) & 0x2D1885;
    v8 = v6 || v7 == 0;
    result = vadd_f32(*&v4, a3);
    if (v8)
    {
      *&result = v4;
    }
  }

  return result;
}

uint64_t grl::TextLayerMetrics::TextLayerMetrics(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  v16 = *MEMORY[0x1E69E9840];
  *(a1 + 8) = 3;
  *(a1 + 76) = 0u;
  *(a1 + 60) = 0u;
  *(a1 + 44) = 0u;
  *(a1 + 28) = 0u;
  *(a1 + 12) = 0u;
  *a1 = &unk_1F2A5F308;
  *(a1 + 92) = 0;
  v4 = roundf(a3[1].f32[1] - a3->f32[1]);
  v5 = *(a2 + 76);
  v6 = v5 + roundf(a3[1].f32[0] - a3->f32[0]);
  v7 = v6 + *(a2 + 80);
  *(a1 + 12) = v5;
  *(a1 + 16) = 0;
  *(a1 + 20) = v6;
  *(a1 + 24) = v4;
  *(a1 + 28) = v5;
  *(a1 + 32) = 0;
  *(a1 + 36) = v6;
  *(a1 + 40) = v4;
  *(a1 + 44) = v7;
  *(a1 + 48) = v4;
  v8 = vneg_f32(*a3);
  *(a1 + 92) = v8;
  *(a1 + 92) = *(a2 + 76) + v8.f32[0];
  *v11 = 0;
  if (!*(a1 + 44))
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_53812);
    }

    v9 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *v11 = 136315650;
      *&v11[4] = "_size != gm::Vector2f::zero()";
      v12 = 2080;
      v13 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Renderer/TextLayerMetrics.cpp";
      v14 = 1024;
      v15 = 39;
      _os_log_impl(&dword_1B2754000, v9, OS_LOG_TYPE_ERROR, "A TextLayer of size zero has been generated.: Assertion with expression - %s : Failed in file - %s line - %i", v11, 0x1Cu);
    }
  }

  return a1;
}

uint64_t grl::codec::IconConfigPack::packLog@<X0>(grl::codec::IconConfigPack *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v30);
  std::mutex::lock((this + 232));
  v4 = *(this + 16);
  if (v4 == (this + 120))
  {
    v5 = 0;
  }

  else
  {
    v5 = 0;
    do
    {
      v7 = v4[3];
      v6 = v4[4];
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        v8 = *(v7 + 24);
        std::__shared_weak_count::__release_shared[abi:nn200100](v6);
      }

      else
      {
        v8 = *(v7 + 24);
      }

      v5 += v8;
      v4 = v4[1];
    }

    while (v4 != (this + 120));
  }

  std::mutex::unlock((this + 232));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v31, "IconConfigPack: ", 16);
  grl::codec::ResourcePack::fileName(__p, this);
  if ((v29 & 0x80u) == 0)
  {
    v9 = __p;
  }

  else
  {
    v9 = __p[0];
  }

  if ((v29 & 0x80u) == 0)
  {
    v10 = v29;
  }

  else
  {
    v10 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v31, v9, v10);
  std::ios_base::getloc((&v31 + *(v31 - 24)));
  v11 = std::locale::use_facet(&v36, MEMORY[0x1E69E5318]);
  (v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v36);
  std::ostream::put();
  std::ostream::flush();
  if (v29 < 0)
  {
    operator delete(__p[0]);
  }

  v12 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v31, "Number of Icons: ", 17);
  v13 = MEMORY[0x1B8C61CB0](v12, v5);
  std::ios_base::getloc((v13 + *(*v13 - 24)));
  v14 = MEMORY[0x1E69E5318];
  v15 = std::locale::use_facet(__p, MEMORY[0x1E69E5318]);
  (v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(__p);
  std::ostream::put();
  std::ostream::flush();
  v16 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v31, "Cache| hits: ", 13);
  v17 = (this + 144);
  v18 = atomic_load(this + 36);
  v19 = MEMORY[0x1B8C61C90](v16, v18);
  v20 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v19, " misses:", 8);
  v21 = (this + 148);
  v22 = atomic_load(v21);
  v23 = MEMORY[0x1B8C61C90](v20, v22);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, " hitRate: ", 10);
  atomic_load(v17);
  atomic_load(v17);
  atomic_load(v21);
  v24 = std::ostream::operator<<();
  std::ios_base::getloc((v24 + *(*v24 - 24)));
  v25 = std::locale::use_facet(__p, v14);
  (v25->__vftable[2].~facet_0)(v25, 10);
  std::locale::~locale(__p);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str[abi:nn200100](a2, &v32);
  v30[0] = *MEMORY[0x1E69E54D8];
  v26 = *(MEMORY[0x1E69E54D8] + 72);
  *(v30 + *(v30[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v31 = v26;
  v32 = MEMORY[0x1E69E5548] + 16;
  if (v34 < 0)
  {
    operator delete(v33[7].__locale_);
  }

  v32 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v33);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v35);
}

unint64_t grl::codec::IconConfigPack::hash(grl::codec::IconConfigPack *this, unsigned int a2)
{
  v2 = *(this + 19);
  v5 = *v2;
  v3 = v2 + 1;
  v4 = v5;
  if (v5 == v3)
  {
    return 0;
  }

  v6 = 0;
  v7 = a2 - 0x61C8864680B583EBLL;
  do
  {
    v8 = (*(v4[4] + 16))(v4 + 4);
    v9 = v4[1];
    if (v9)
    {
      do
      {
        v10 = v9;
        v9 = *v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        v10 = v4[2];
        v11 = *v10 == v4;
        v4 = v10;
      }

      while (!v11);
    }

    v12 = (v7 + (v6 << 6) + (v6 >> 2)) ^ v6;
    v6 = ((v12 << 6) - 0x61C8864680B583EBLL + (v12 >> 2) + v8) ^ v12;
    v4 = v10;
  }

  while (v10 != v3);
  return v6;
}

uint64_t grl::codec::IconConfigPack::decode(uint64_t a1, void *a2)
{
  v80[3] = *MEMORY[0x1E69E9840];
  memset(__p, 0, sizeof(__p));
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v80[2] = 0;
  v79 = v80;
  v80[0] = 0;
  v4 = a2[1];
  v71[0] = *a2;
  v71[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    v5 = grl::codec::ResourcePack::decodeHeader(v71, __p);
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
    if ((v5 & 1) == 0)
    {
      goto LABEL_86;
    }
  }

  else if ((grl::codec::ResourcePack::decodeHeader(v71, __p) & 1) == 0)
  {
    goto LABEL_86;
  }

  if (*__p[0] != 73 || *(__p[0] + 1) != 67 || *(__p[0] + 2) != 79 || *(__p[0] + 3) != 78 || *(__p[0] + 4) != 67 || *(__p[0] + 5) != 79 || *(__p[0] + 6) != 78 || *(__p[0] + 7) != 70 || *(__p[0] + 8) != 73 || *(__p[0] + 9) != 71 || *(__p[0] + 10) != 80 || *(__p[0] + 11) != 65 || *(__p[0] + 12) != 67 || *(__p[0] + 13) != 75)
  {
LABEL_86:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n");
    goto LABEL_87;
  }

  v6 = v79;
  if (v79 == v80)
  {
    v58 = 1;
    goto LABEL_88;
  }

  v66 = 0;
  v63 = (a1 + 208);
  while (1)
  {
    v67 = v6;
    v7 = *(v6 + 16);
    if (v7 > 0xE)
    {
      if (v7 == 15)
      {
        v73 = v72;
        v16 = a2[1];
        v68[0] = *a2;
        v68[1] = v16;
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          v17 = grl::codec::ResourcePack::decodeChapterData(v68, v6 + 5, &v72);
          std::__shared_weak_count::__release_shared[abi:nn200100](v16);
          if ((v17 & 1) == 0)
          {
            goto LABEL_86;
          }
        }

        else if ((grl::codec::ResourcePack::decodeChapterData(v68, v6 + 5, &v72) & 1) == 0)
        {
          goto LABEL_86;
        }

        v33 = v72;
        v34 = v73 - v72;
        if ((v73 - v72) < 4)
        {
          v55 = 294;
          v56 = "numberOfDataLocations.has_value()";
          v57 = "Number Of Data Locations could not be read";
          goto LABEL_103;
        }

        v35 = *v72;
        v65 = v72 - 4;
        if (*v72)
        {
          v62 = v72 - 2;
          v36 = 4;
          while (1)
          {
            v37 = v36 + 1;
            if (v36 + 1 > v34)
            {
              v55 = 298;
              v56 = "sizeGroupRaw.has_value()";
              v57 = "Size Group could not be read";
              goto LABEL_103;
            }

            v38 = v33[v36];
            v39 = v66;
            if (v38 < 0xA)
            {
              v39 = v33[v36];
            }

            v66 = v39;
            if (*(a1 + 192) < 3u)
            {
              v40 = 0;
            }

            else
            {
              v37 = v36 + 3;
              if (v36 + 3 > v34)
              {
                v55 = 304;
                v56 = "dataVariant.has_value()";
LABEL_102:
                v57 = "Variant could not be read";
LABEL_103:
                printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v57, v56, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", v55);
                goto LABEL_86;
              }

              v40 = *&v62[v37];
            }

            if (v37 + 2 > v34)
            {
              v55 = 308;
              v56 = "variant.has_value()";
              goto LABEL_102;
            }

            v36 = v37 + 6;
            if (v37 + 6 > v34)
            {
              v55 = 311;
              v56 = "bytePosition.has_value()";
              v57 = "Byte Position could not be read";
              goto LABEL_103;
            }

            if (v38 <= 9)
            {
              v41 = *&v33[v37];
              v42 = *&v65[v36];
              LOBYTE(v76) = v66;
              HIWORD(v76) = v40;
              v77 = v41;
              v43 = std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,grl::zone_mallocator>>::__find_equal<grl::codec::IconConfigPack::IconVariation>(a1 + 40, v78, &v76);
              v44 = *v43;
              if (!*v43)
              {
                v45 = v43;
                v46 = grl::zone_mallocator::instance(v43);
                v44 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,void *>>(v46);
                v44[7] = v76;
                *(v44 + 16) = v77;
                v44[9] = 0;
                std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::__insert_node_at((a1 + 40), v78[0], v45, v44);
              }

              v44[9] = v42;
            }

            if (!--v35)
            {
              goto LABEL_77;
            }
          }
        }
      }

      else if (v7 == 16)
      {
        v73 = v72;
        v12 = *a2;
        v11 = a2[1];
        if (v11)
        {
          atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
        }

        v13 = *(a1 + 176);
        *(a1 + 168) = v12;
        *(a1 + 176) = v11;
        if (v13)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v13);
        }

        std::istream::tellg();
        *(a1 + 184) = v78[16];
      }

      goto LABEL_77;
    }

    if (v7 == 1)
    {
      v73 = v72;
      v14 = a2[1];
      v70[0] = *a2;
      v70[1] = v14;
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        v15 = grl::codec::ResourcePack::decodeChapterData(v70, v6 + 5, &v72);
        std::__shared_weak_count::__release_shared[abi:nn200100](v14);
        if ((v15 & 1) == 0)
        {
          goto LABEL_86;
        }
      }

      else if ((grl::codec::ResourcePack::decodeChapterData(v70, v6 + 5, &v72) & 1) == 0)
      {
        goto LABEL_86;
      }

      v32 = v72;
      if ((grl::codec::ResourcePack::decodePackInfo(a1, v72, v73, (a1 + 192)) & 1) == 0)
      {
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Could not decode Pack Info Chapter", "decodePackInfo(chapterData, _packDataContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", 257);
        v58 = 0;
        v59 = v32;
        goto LABEL_89;
      }

      goto LABEL_77;
    }

    if (v7 == 11)
    {
      v73 = v72;
      v8 = a2[1];
      v69[0] = *a2;
      v69[1] = v8;
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        v9 = grl::codec::ResourcePack::decodeChapterData(v69, v6 + 5, &v72);
        std::__shared_weak_count::__release_shared[abi:nn200100](v8);
        if ((v9 & 1) == 0)
        {
          goto LABEL_86;
        }
      }

      else
      {
        v10 = grl::codec::ResourcePack::decodeChapterData(v69, v6 + 5, &v72);
        if ((v10 & 1) == 0)
        {
          goto LABEL_86;
        }
      }

      v64 = v72;
      v18 = v73 - v72;
      if (v73 == v72)
      {
        v52 = 213;
        v53 = "numPropertyTypes.has_value()";
        v54 = "Property Types Count could not be read";
        goto LABEL_97;
      }

      v61 = *v72;
      if (*v72)
      {
        break;
      }
    }

LABEL_77:
    v47 = v67;
    v48 = v67[1];
    if (v48)
    {
      do
      {
        v49 = v48;
        v48 = *v48;
      }

      while (v48);
    }

    else
    {
      do
      {
        v49 = v47[2];
        v50 = *v49 == v47;
        v47 = v49;
      }

      while (!v50);
    }

    v58 = 1;
    v6 = v49;
    if (v49 == v80)
    {
      goto LABEL_88;
    }
  }

  v19 = 0;
  v60 = v72 + 1;
  v20 = 1;
  while (1)
  {
    if (v20 >= v18)
    {
      v52 = 217;
      v53 = "type.has_value()";
      v54 = "Property Type could not be read";
      goto LABEL_97;
    }

    v21 = v20 + 2;
    if (v20 + 2 > v18)
    {
      break;
    }

    v22 = v64[v20];
    v23 = v60[v20];
    v24 = (a1 + 208);
    v25 = (a1 + 208);
    v26 = *v63;
    if (*v63)
    {
      while (1)
      {
        while (1)
        {
          v25 = v26;
          v27 = *(v26 + 7);
          if (v27 <= v22)
          {
            break;
          }

          v26 = *v25;
          v24 = v25;
          if (!*v25)
          {
            goto LABEL_51;
          }
        }

        if (v27 >= v22)
        {
          break;
        }

        v26 = v25[1];
        if (!v26)
        {
          v24 = v25 + 1;
          goto LABEL_51;
        }
      }
    }

    else
    {
LABEL_51:
      v28 = grl::zone_mallocator::instance(v10);
      v29 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned int,unsigned char>,void *>>(v28);
      v29[7] = v22;
      *(v29 + 32) = 0;
      *v29 = 0;
      *(v29 + 1) = 0;
      *(v29 + 2) = v25;
      *v24 = v29;
      v30 = **(a1 + 200);
      v25 = v29;
      v31 = v29;
      if (v30)
      {
        *(a1 + 200) = v30;
        v31 = *v24;
      }

      v10 = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(*(a1 + 208), v31);
      ++*(a1 + 224);
    }

    *(v25 + 32) = v23;
    ++v19;
    v20 = v21;
    if (v19 >= v61)
    {
      goto LABEL_77;
    }
  }

  v52 = 220;
  v53 = "bytes.has_value()";
  v54 = "Bytes could not be read";
LABEL_97:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v54, v53, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Model/PropertySet.cpp", v52);
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Failed to decode property context", "PropertySet::decodePropertyContext(byteData, context.propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", 284);
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n");
LABEL_87:
  v58 = 0;
LABEL_88:
  v59 = v72;
LABEL_89:
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(v80[0]);
  if (v59)
  {
    operator delete(v59);
  }

  if (__p[0])
  {
    operator delete(__p[0]);
  }

  return v58;
}

uint64_t *std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,grl::zone_mallocator>>::__find_equal<grl::codec::IconConfigPack::IconVariation>(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  v5 = *(a1 + 8);
  result = (a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = *(a3 + 2);
    v8 = *(a3 + 1);
    while (1)
    {
      while (1)
      {
        v9 = v4;
        v10 = *(v4 + 28);
        if (v6 == v10)
        {
          break;
        }

        if (v6 >= v10)
        {
          if (v10 >= v6)
          {
            goto LABEL_18;
          }

          goto LABEL_15;
        }

LABEL_12:
        v4 = *v9;
        result = v9;
        if (!*v9)
        {
          goto LABEL_18;
        }
      }

      v11 = *(v9 + 16);
      if (v7 != v11)
      {
        if (v7 >= v11)
        {
          if (v11 >= v7)
          {
            goto LABEL_18;
          }

          goto LABEL_15;
        }

        goto LABEL_12;
      }

      v12 = *(v9 + 15);
      if (v8 < v12)
      {
        goto LABEL_12;
      }

      if (v12 >= v8)
      {
        goto LABEL_18;
      }

LABEL_15:
      result = v9 + 1;
      v4 = v9[1];
      if (!v4)
      {
        goto LABEL_18;
      }
    }
  }

  v9 = result;
LABEL_18:
  *a2 = v9;
  return result;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<grl::codec::IconConfigPack::IconVariation,unsigned int>,void *>>(uint64_t a1)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v2 = malloc_type_zone_malloc(*a1, 0x28uLL, 0x10200402898D7D2uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v2;
}

void grl::codec::IconConfigPack::encode(grl::codec::IconConfigPack *this, __int16 a2)
{
  v12[3] = *MEMORY[0x1E69E9840];
  v7 = 0;
  v6 = 0;
  v9 = 0;
  v8 = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](&v10);
  LOBYTE(v4[0]) = 73;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 79;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 78;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 79;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 78;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 70;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 73;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 71;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 80;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 75;
  geo::obitstream::appendBytes(&v6, v4, 1);
  memset(v5, 0, sizeof(v5));
  if (v7 != v6)
  {
    if (v7 - v6 >= 0)
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  std::vector<unsigned char>::__append(v5, 0x40uLL);
  v12[2] = 0;
  v11 = v12;
  v12[0] = 0;
  grl::codec::ResourcePack::encodePackInfo(v4, this, a2);
  operator new();
}

void *std::ostringstream::basic_ostringstream[abi:nn200100](void *a1, void *a2)
{
  a1[20] = 0;
  v3 = MEMORY[0x1E69E54E8];
  a1[14] = MEMORY[0x1E69E5590] + 16;
  v5 = *(v3 + 8);
  v4 = *(v3 + 16);
  *a1 = v5;
  *(a1 + *(v5 - 24)) = v4;
  v6 = (a1 + *(*a1 - 24));
  v7 = (a2 + *(*a2 - 24));
  std::ios_base::move(v6, v7);
  v6[1].__vftable = v7[1].__vftable;
  v7[1].__vftable = 0;
  v6[1].__fmtflags_ = v7[1].__fmtflags_;
  *a1 = MEMORY[0x1E69E5570] + 24;
  a1[14] = MEMORY[0x1E69E5570] + 64;
  *(a1 + *(*a1 - 24) + 40) = std::stringbuf::basic_stringbuf();
  return a1;
}

void *std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[16];
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = (v7 + 1);
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x38uLL, 0x1020040086A9628uLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 16) = **a3;
    v7[5] = 0;
    v7[6] = 0;
    *(v7 + 48) = 1;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

uint64_t *std::unique_ptr<geo::obitstream>::reset[abi:nn200100](uint64_t *result, uint64_t a2)
{
  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = MEMORY[0x1E69E54E8];
    v4 = *MEMORY[0x1E69E54E8];
    *(v2 + 32) = *MEMORY[0x1E69E54E8];
    *(v2 + 32 + *(v4 - 24)) = *(v3 + 24);
    *(v2 + 40) = MEMORY[0x1E69E5548] + 16;
    if (*(v2 + 127) < 0)
    {
      operator delete(*(v2 + 104));
    }

    *(v2 + 40) = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale((v2 + 48));
    std::ostream::~ostream();
    MEMORY[0x1B8C620C0](v2 + 144);
    v5 = *v2;
    if (*v2)
    {
      *(v2 + 8) = v5;
      operator delete(v5);
    }

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void grl::codec::IconConfigPack::encodeIconRenderItemData(uint64_t a1, uint64_t a2)
{
  v70 = *MEMORY[0x1E69E9840];
  v4 = *(*(a2 + 152) + 24);
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = 0;
  *(a1 + 24) = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100]((a1 + 32));
  std::vector<unsigned char>::reserve(a1, *(a1 + 16) + 72960 * v4 - *a1);
  std::string::basic_string[abi:nn200100]<0>(__p, "icon render item data");
  v44[0] = off_1E7B57F70;
  v5 = geo::obitstream::markDebugLog(a1, __p, v44);
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
  }

  v48[1] = 0;
  v48[0] = 0;
  v47 = v48;
  v69 = 0;
  v68[0] = 0;
  v67 = v68;
  v6 = *(a2 + 152);
  v7 = *v6;
  v43 = v6 + 1;
  if (*v6 == v6 + 1)
  {
    v66 = 0;
    v65[0] = 0;
    v64 = v65;
  }

  else
  {
    do
    {
      v44[37] = &unk_1F2A5F7A0;
      v46 = *(v7 + 56);
      v45 = *(v7 + 5);
      v8 = v46;
      v9 = WORD6(v45);
      v10 = HIWORD(v45);
      v11 = v68[0];
      v12 = v68;
      for (i = v68; v11; v11 = i[1])
      {
        while (1)
        {
          i = v11;
          v14 = *(v11 + 32);
          if (v46 == v14)
          {
            break;
          }

          if (v46 >= v14)
          {
            if (v14 >= v46)
            {
              goto LABEL_21;
            }

            goto LABEL_17;
          }

LABEL_14:
          v11 = *i;
          v12 = i;
          if (!*i)
          {
            goto LABEL_18;
          }
        }

        v15 = *(i + 18);
        if (HIWORD(v45) != v15)
        {
          if (HIWORD(v45) >= v15)
          {
            if (v15 >= HIWORD(v45))
            {
              goto LABEL_21;
            }

            goto LABEL_17;
          }

          goto LABEL_14;
        }

        v16 = *(i + 17);
        if (WORD6(v45) < v16)
        {
          goto LABEL_14;
        }

        if (v16 >= WORD6(v45))
        {
          goto LABEL_21;
        }

LABEL_17:
        v12 = i + 1;
      }

LABEL_18:
      v17 = i;
      v18 = grl::zone_mallocator::instance(v5);
      geo::read_write_lock::read_lock((v18 + 32));
      i = malloc_type_zone_malloc(*v18, 0x40uLL, 0x1020040719120FCuLL);
      atomic_fetch_add((v18 + 24), 1u);
      geo::read_write_lock::unlock((v18 + 32));
      *(i + 32) = v8;
      *(i + 17) = v9;
      *(i + 18) = v10;
      i[6] = 0;
      i[7] = 0;
      i[5] = 0;
      *i = 0;
      i[1] = 0;
      i[2] = v17;
      *v12 = i;
      v19 = i;
      if (*v67)
      {
        v67 = *v67;
        v19 = *v12;
      }

      v5 = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v68[0], v19);
      ++v69;
LABEL_21:
      *&__p[1] = *(v7 + 5);
      LOBYTE(__p[3]) = *(v7 + 56);
      v21 = v7[8];
      v20 = v7[9];
      __p[0] = &unk_1F2A5F7A0;
      *&v50[0] = v21;
      *(&v50[0] + 1) = v20;
      if (v20)
      {
        atomic_fetch_add_explicit((v20 + 8), 1uLL, memory_order_relaxed);
      }

      v22 = i[6];
      v23 = i[7];
      if (v22 >= v23)
      {
        v25 = i[5];
        v26 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v25) >> 4);
        v27 = v26 + 1;
        if (v26 + 1 > 0x555555555555555)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v28 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v25) >> 4);
        if (2 * v28 > v27)
        {
          v27 = 2 * v28;
        }

        if (v28 >= 0x2AAAAAAAAAAAAAALL)
        {
          v29 = 0x555555555555555;
        }

        else
        {
          v29 = v27;
        }

        if (v29)
        {
          if (v29 <= 0x555555555555555)
          {
            operator new();
          }

          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v30 = 48 * v26;
        *(v30 + 8) = *&__p[1];
        *(v30 + 24) = __p[3];
        *(v30 + 32) = v50[0];
        v50[0] = 0uLL;
        v32 = i[5];
        v31 = i[6];
        v33 = 48 * v26 - (v31 - v32);
        *v30 = &unk_1F2A5F7A0;
        if (v31 != v32)
        {
          v34 = 48 * v26 - 16 * ((v31 - v32) >> 4);
          v35 = v32;
          v36 = v30 - (v31 - v32);
          do
          {
            *v36 = &unk_1F2A5F7A0;
            v37 = *(v35 + 1);
            *(v36 + 24) = *(v35 + 24);
            *(v36 + 8) = v37;
            *(v36 + 32) = *(v35 + 2);
            v35[4] = 0;
            v35[5] = 0;
            v35 += 6;
            v36 += 48;
            v34 += 48;
          }

          while (v35 != v31);
          do
          {
            v38 = v32[5];
            if (v38)
            {
              std::__shared_weak_count::__release_shared[abi:nn200100](v38);
            }

            v32 += 6;
          }

          while (v32 != v31);
        }

        v39 = i[5];
        i[5] = v33;
        i[6] = (v30 + 48);
        i[7] = 0;
        if (v39)
        {
          operator delete(v39);
        }

        v5 = *(&v50[0] + 1);
        i[6] = (v30 + 48);
        if (v5)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v5);
        }
      }

      else
      {
        *v22 = &unk_1F2A5F7A0;
        v24 = *&__p[1];
        *(v22 + 24) = __p[3];
        *(v22 + 1) = v24;
        *(v22 + 2) = v50[0];
        i[6] = v22 + 6;
      }

      v40 = v7[1];
      if (v40)
      {
        do
        {
          v41 = v40;
          v40 = *v40;
        }

        while (v40);
      }

      else
      {
        do
        {
          v41 = v7[2];
          v42 = *v41 == v7;
          v7 = v41;
        }

        while (!v42);
      }

      v7 = v41;
    }

    while (v41 != v43);
    v66 = 0;
    v65[0] = 0;
    v64 = v65;
    if (v67 != v68)
    {
      v63 = 0;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      memset(v50, 0, sizeof(v50));
      memset(__p, 0, sizeof(__p));
      std::ostringstream::basic_ostringstream[abi:nn200100](v50);
      operator new();
    }
  }

  std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::zone_mallocator>>::destroy(v65[0]);
  std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,grl::zone_mallocator>>::destroy(v68[0]);
  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v48[0]);
}

void std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::zone_mallocator>>::destroy(a1[1]);
    v2 = std::unique_ptr<geo::obitstream>::reset[abi:nn200100](a1 + 5, 0);
    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

uint64_t geo::obitstream::markDebugLog(uint64_t a1, uint64_t a2, const char ***a3)
{
  if (*a3)
  {
    v6 = **a3;
  }

  else
  {
    v6 = "";
  }

  v7 = strlen(v6);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((a1 + 32), v6, v7);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((a1 + 32), ":", 1);
  if (*a3)
  {
    v8 = *(*a3 + 4);
  }

  else
  {
    v8 = 0;
  }

  v9 = MEMORY[0x1B8C61C90](a1 + 32, v8);
  v10 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, ":", 1);
  if (*a3)
  {
    v11 = *(*a3 + 5);
  }

  else
  {
    v11 = 0;
  }

  v12 = MEMORY[0x1B8C61C90](v10, v11);
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, " - ", 3);
  v14 = *(a2 + 23);
  if (v14 >= 0)
  {
    v15 = a2;
  }

  else
  {
    v15 = *a2;
  }

  if (v14 >= 0)
  {
    v16 = *(a2 + 23);
  }

  else
  {
    v16 = *(a2 + 8);
  }

  v17 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, v15, v16);
  std::ios_base::getloc((v17 + *(*v17 - 24)));
  v18 = std::locale::use_facet(&v20, MEMORY[0x1E69E5318]);
  (v18->__vftable[2].~facet_0)(v18, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  return std::ostream::flush();
}

void geo::obitstream::appendBytes(geo::obitstream *this, const unsigned __int8 *a2, uint64_t a3)
{
  v3 = a3;
  v4 = a2;
  if (*(this + 24))
  {
    if (a3 >= 1)
    {
      v6 = &a2[a3];
      v7 = *(this + 1);
      do
      {
        v8 = *v4;
        *(v7 - 1) |= v8 >> *(this + 24);
        v9 = v8 << (8 - *(this + 24));
        v11 = *(this + 1);
        v10 = *(this + 2);
        if (v11 >= v10)
        {
          v12 = *this;
          v13 = &v11[-*this];
          v14 = (v13 + 1);
          if ((v13 + 1) < 0)
          {
            goto LABEL_35;
          }

          v15 = v10 - v12;
          if (2 * v15 > v14)
          {
            v14 = 2 * v15;
          }

          if (v15 >= 0x3FFFFFFFFFFFFFFFLL)
          {
            v16 = 0x7FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v16 = v14;
          }

          if (v16)
          {
            operator new();
          }

          v17 = &v11[-*this];
          *v13 = v9;
          v7 = v13 + 1;
          memcpy(0, v12, v17);
          *this = 0;
          *(this + 1) = v13 + 1;
          *(this + 2) = 0;
          if (v12)
          {
            operator delete(v12);
          }
        }

        else
        {
          *v11 = v9;
          v7 = v11 + 1;
        }

        *(this + 1) = v7;
        ++v4;
      }

      while (v4 < v6);
    }
  }

  else
  {
    std::vector<unsigned char>::reserve(this, *(this + 1) + a3 - *this);
    if (v3 >= 1)
    {
      v19 = *(this + 1);
      v18 = *(this + 2);
      if (v18 - v19 >= v3)
      {
        do
        {
          v25 = *v4++;
          *v19++ = v25;
          --v3;
        }

        while (v3);
        *(this + 1) = v19;
      }

      else
      {
        v20 = *this;
        v21 = &v19[-*this];
        v22 = &v21[v3];
        if (&v21[v3] < 0)
        {
LABEL_35:
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v23 = v18 - v20;
        if (2 * v23 > v22)
        {
          v22 = 2 * v23;
        }

        if (v23 >= 0x3FFFFFFFFFFFFFFFLL)
        {
          v24 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v24 = v22;
        }

        if (v24)
        {
          operator new();
        }

        v26 = &v19[-*this];
        v27 = *(this + 1);
        memcpy(v21, v4, v3);
        memcpy(&v21[v3], v19, v27 - v19);
        *(this + 1) = v19;
        memcpy(&v21[v20 - v19], v20, v26);
        *this = &v21[v20 - v19];
        *(this + 1) = &v21[v3 + v27 - v19];
        *(this + 2) = 0;
        if (v20)
        {

          operator delete(v20);
        }
      }
    }
  }
}

void *std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::unique_ptr<geo::obitstream>>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,std::unique_ptr<geo::obitstream>>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::unique_ptr<geo::obitstream>>,grl::zone_mallocator>>::__emplace_unique_key_args<grl::codec::IconConfigPack::IconVariation,std::piecewise_construct_t const&,std::tuple<grl::codec::IconConfigPack::IconVariation const&>,std::tuple<>>(void **a1, unsigned __int8 *a2, int **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    v8 = *(a2 + 2);
    v9 = *(a2 + 1);
    while (1)
    {
      while (1)
      {
        v6 = v5;
        v10 = v5[32];
        if (v7 == v10)
        {
          break;
        }

        if (v7 >= v10)
        {
          if (v10 >= v7)
          {
            return v6;
          }

          goto LABEL_15;
        }

LABEL_12:
        v5 = *v6;
        v13 = v6;
        if (!*v6)
        {
          goto LABEL_18;
        }
      }

      v11 = *(v6 + 18);
      if (v8 != v11)
      {
        if (v8 >= v11)
        {
          if (v11 >= v8)
          {
            return v6;
          }

          goto LABEL_15;
        }

        goto LABEL_12;
      }

      v12 = *(v6 + 17);
      if (v9 < v12)
      {
        goto LABEL_12;
      }

      if (v12 >= v9)
      {
        return v6;
      }

LABEL_15:
      v13 = (v6 + 1);
      v5 = v6[1];
      if (!v5)
      {
        goto LABEL_18;
      }
    }
  }

  v13 = a1 + 1;
LABEL_18:
  v14 = v6;
  v15 = grl::zone_mallocator::instance(a1);
  geo::read_write_lock::read_lock((v15 + 32));
  v6 = malloc_type_zone_malloc(*v15, 0x30uLL, 0x1020040A1599B8AuLL);
  atomic_fetch_add((v15 + 24), 1u);
  geo::read_write_lock::unlock((v15 + 32));
  v16 = **a3;
  *(v6 + 18) = *(*a3 + 2);
  *(v6 + 8) = v16;
  v6[5] = 0;
  *v6 = 0;
  v6[1] = 0;
  v6[2] = v14;
  *v13 = v6;
  v17 = **a1;
  v18 = v6;
  if (v17)
  {
    *a1 = v17;
    v18 = *v13;
  }

  std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v18);
  a1[3] = (a1[3] + 1);
  return v6;
}

void std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,grl::zone_mallocator>>::destroy(*a1);
    v2 = std::__tree<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::__map_value_compare<grl::codec::IconConfigPack::IconVariation,std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,std::less<grl::codec::IconConfigPack::IconVariation>,true>,geo::allocator_adapter<std::__value_type<grl::codec::IconConfigPack::IconVariation,std::vector<std::pair<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>>>,grl::zone_mallocator>>::destroy(a1[1]);
    v3 = a1[5];
    if (v3)
    {
      v4 = a1[6];
      v5 = a1[5];
      if (v4 != v3)
      {
        do
        {
          v6 = *(v4 - 8);
          if (v6)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v6);
          }

          v4 -= 48;
        }

        while (v4 != v3);
        v5 = a1[5];
      }

      a1[6] = v3;
      operator delete(v5);
    }

    v7 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v7 + 32));
    atomic_fetch_add((v7 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v7, a1);

    geo::read_write_lock::unlock((v7 + 32));
  }
}

void grl::codec::IconConfigPack::~IconConfigPack(grl::codec::IconConfigPack *this)
{
  grl::codec::IconConfigPack::~IconConfigPack(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F330;
  std::mutex::~mutex((this + 232));
  std::__tree<std::__value_type<unsigned int,unsigned char>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned char>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,unsigned char>,grl::zone_mallocator>>::destroy(*(this + 26));
  v2 = *(this + 22);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  v3 = *(this + 20);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }

  if (*(this + 17))
  {
    v4 = *(this + 16);
    v5 = *(*(this + 15) + 8);
    v6 = *v4;
    *(v6 + 8) = v5;
    *v5 = v6;
    *(this + 17) = 0;
    if (v4 != (this + 120))
    {
      do
      {
        v7 = *(v4 + 1);
        v8 = *(v4 + 4);
        if (v8)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v8);
        }

        operator delete(v4);
        v4 = v7;
      }

      while (v7 != (this + 120));
    }
  }

  v9 = *(this + 12);
  if (v9)
  {
    do
    {
      v10 = *v9;
      operator delete(v9);
      v9 = v10;
    }

    while (v10);
  }

  v11 = *(this + 10);
  *(this + 10) = 0;
  if (v11)
  {
    operator delete(v11);
  }

  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(this + 6));
  *this = &unk_1F2A5F9A0;
  if (*(this + 31) < 0)
  {
    operator delete(*(this + 1));
  }
}

void std::__tree<std::__value_type<unsigned int,unsigned char>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned char>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,unsigned char>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,unsigned char>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned char>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,unsigned char>,grl::zone_mallocator>>::destroy(*a1);
    v2 = std::__tree<std::__value_type<unsigned int,unsigned char>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned char>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,unsigned char>,grl::zone_mallocator>>::destroy(a1[1]);
    v3 = grl::zone_mallocator::instance(v2);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__tree_node<std::__value_type<unsigned int,unsigned char>,void *>>(v3, a1);
  }
}

void std::__shared_ptr_emplace<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>,geo::allocator_adapter<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>,grl::zone_mallocator>>::__on_zero_shared_weak(grl::zone_mallocator *a1)
{
  v2 = grl::zone_mallocator::instance(a1);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,geo::allocator_adapter<ggl::VertexDataTyped<ggl::TextureRect::TextureVBO>,ggl::zone_mallocator>>>(v2, a1);
}

void std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::less<grl::IconKey>,true>,geo::allocator_adapter<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::less<grl::IconKey>,true>,geo::allocator_adapter<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,std::less<grl::IconKey>,true>,geo::allocator_adapter<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>::destroy(a1[1]);
    v2 = a1[9];
    if (v2)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v2);
    }

    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void std::__shared_ptr_emplace<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>,geo::allocator_adapter<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>,grl::zone_mallocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::codec::IconConfigPack::setLocationCacheSize(grl::codec::IconConfigPack *this, uint64_t a2)
{
  std::mutex::lock((this + 232));
  *(this + 9) = a2;
  while (*(this + 17) > *(this + 9))
  {
    geo::Cache<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>,grl::codec::IconConfigPack::IconVariationHash,geo::LRUPolicy>::_pop(this + 9);
  }

  std::mutex::unlock((this + 232));
}

void geo::Cache<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>,grl::codec::IconConfigPack::IconVariationHash,geo::LRUPolicy>::_pop(void *a1)
{
  v2 = a1[6];
  v8 = *(v2 + 4);
  v9 = *(v2 + 10);
  v3 = v2[4];
  v10 = v2[3];
  v11 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    v2 = a1[6];
    v4 = v2[4];
  }

  else
  {
    v4 = 0;
  }

  v6 = *v2;
  v5 = v2[1];
  *(v6 + 8) = v5;
  *v5 = v6;
  --a1[8];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  }

  operator delete(v2);
  v7 = std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconVariation,std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,grl::codec::IconConfigPack::IconVariationHash,std::equal_to<grl::codec::IconConfigPack::IconVariation>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconVariation,std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconVariation>,grl::codec::IconConfigPack::IconVariationHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>>>::find<grl::codec::IconConfigPack::IconVariation>(a1 + 1, &v8);
  if (v7)
  {
    std::__hash_table<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>>>::erase(a1 + 1, v7);
  }

  if (v3)
  {

    std::__shared_weak_count::__release_shared[abi:nn200100](v3);
  }
}

uint64_t geo::Cache<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>,grl::codec::IconConfigPack::IconVariationHash,geo::LRUPolicy>::operator[](uint64_t a1, unsigned __int8 *a2)
{
  v4 = a1 + 48;
  v5 = geo::LRUPolicy<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>,grl::codec::IconConfigPack::IconVariationHash>::get(a1 + 48, (a1 + 8), a2);
  if (v4 == v5)
  {
    v6 = std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconVariation,std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,grl::codec::IconConfigPack::IconVariationHash,std::equal_to<grl::codec::IconConfigPack::IconVariation>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconVariation,std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconVariation>,grl::codec::IconConfigPack::IconVariationHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconVariation,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconVariation,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>>,void *>>>>::find<grl::codec::IconConfigPack::IconVariation>((a1 + 8), a2);
    if (v6)
    {
      v7 = v6;
      v8 = v6[3];
      v10 = *v8;
      v9 = v8[1];
      *(v10 + 8) = v9;
      *v9 = v10;
      --*(a1 + 64);
      v11 = v8[4];
      if (v11)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v11);
      }

      operator delete(v8);
      std::__hash_table<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>>>::erase((a1 + 8), v7);
    }

    operator new();
  }

  return v5 + 24;
}

void std::__shared_ptr_emplace<grl::codec::IconRenderItem>::__on_zero_shared(uint64_t a1)
{
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(a1 + 232));
  if (*(a1 + 176) == 1)
  {
    *(a1 + 176) = 0;
  }

  std::__tree<std::__value_type<unsigned short,grl::codec::PathLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::PathLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::PathLayerData>,grl::zone_mallocator>>::destroy(*(a1 + 152));
  std::__tree<std::__value_type<unsigned short,grl::codec::PathLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::PathLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::PathLayerData>,grl::zone_mallocator>>::destroy(*(a1 + 120));
  std::__tree<std::__value_type<unsigned short,grl::codec::TextLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::TextLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::TextLayerData>,grl::zone_mallocator>>::destroy(*(a1 + 88));
  if (*(a1 + 24) == 1)
  {
    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 32));
    *(a1 + 24) = 0;
  }
}

void std::__tree<std::__value_type<unsigned short,grl::codec::PathLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::PathLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::PathLayerData>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned short,grl::codec::PathLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::PathLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::PathLayerData>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned short,grl::codec::PathLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::PathLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::PathLayerData>,grl::zone_mallocator>>::destroy(a1[1]);
    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 5));
    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void std::__tree<std::__value_type<unsigned short,grl::codec::TextLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::TextLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::TextLayerData>,grl::zone_mallocator>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned short,grl::codec::TextLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::TextLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::TextLayerData>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned short,grl::codec::TextLayerData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::TextLayerData>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::TextLayerData>,grl::zone_mallocator>>::destroy(*(a1 + 1));
    if (a1[207] < 0)
    {
      operator delete(*(a1 + 23));
    }

    if (a1[151] < 0)
    {
      operator delete(*(a1 + 16));
    }

    if (a1[103] < 0)
    {
      operator delete(*(a1 + 10));
    }

    std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 40));
    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void std::__shared_ptr_emplace<grl::codec::IconRenderItem>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F3E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconRenderItem>,std::less<grl::IconKey>,geo::allocator_adapter<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconRenderItem>>,grl::zone_mallocator>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F3B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::codec::IconDataPack::packLog(grl::codec::IconDataPack *this@<X0>, _BYTE *a2@<X8>)
{
  std::mutex::lock((this + 336));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v23);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v24, "IconDataPack: ", 14);
  grl::codec::ResourcePack::fileName(__p, this);
  if ((v22 & 0x80u) == 0)
  {
    v4 = __p;
  }

  else
  {
    v4 = __p[0];
  }

  if ((v22 & 0x80u) == 0)
  {
    v5 = v22;
  }

  else
  {
    v5 = __p[1];
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v24, v4, v5);
  std::ios_base::getloc((&v24 + *(v24 - 24)));
  v6 = std::locale::use_facet(&v33, MEMORY[0x1E69E5318]);
  (v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v33);
  std::ostream::put();
  std::ostream::flush();
  if (v22 < 0)
  {
    operator delete(__p[0]);
  }

  v7 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v24, "Number of Atlas Images: ", 24);
  v8 = MEMORY[0x1B8C61CB0](v7, *(this + 13));
  std::ios_base::getloc((v8 + *(*v8 - 24)));
  v9 = MEMORY[0x1E69E5318];
  v10 = std::locale::use_facet(__p, MEMORY[0x1E69E5318]);
  (v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(__p);
  std::ostream::put();
  std::ostream::flush();
  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v24, "Cache| hits: ", 13);
  v12 = MEMORY[0x1B8C61C90](v11, *(this + 36));
  v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, " misses: ", 9);
  v14 = MEMORY[0x1B8C61C90](v13, *(this + 37));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v14, " hitRate: ", 10);
  v15 = std::ostream::operator<<();
  std::ios_base::getloc((v15 + *(*v15 - 24)));
  v16 = std::locale::use_facet(__p, v9);
  (v16->__vftable[2].~facet_0)(v16, 10);
  std::locale::~locale(__p);
  std::ostream::put();
  std::ostream::flush();
  if ((v31 & 0x10) != 0)
  {
    v18 = v30;
    if (v30 < v27)
    {
      v30 = v27;
      v18 = v27;
    }

    locale = v26[4].__locale_;
  }

  else
  {
    if ((v31 & 8) == 0)
    {
      v17 = 0;
      a2[23] = 0;
      goto LABEL_22;
    }

    locale = v26[1].__locale_;
    v18 = v26[3].__locale_;
  }

  v17 = v18 - locale;
  if ((v18 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v17 >= 0x17)
  {
    operator new();
  }

  a2[23] = v17;
  if (v17)
  {
    memmove(a2, locale, v17);
  }

LABEL_22:
  a2[v17] = 0;
  v23[0] = *MEMORY[0x1E69E54D8];
  v20 = *(MEMORY[0x1E69E54D8] + 72);
  *(v23 + *(v23[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v24 = v20;
  v25 = MEMORY[0x1E69E5548] + 16;
  if (v29 < 0)
  {
    operator delete(v28);
  }

  v25 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v26);
  std::iostream::~basic_iostream();
  MEMORY[0x1B8C620C0](&v32);
  std::mutex::unlock((this + 336));
}

unint64_t grl::codec::IconDataPack::hash(grl::codec::IconDataPack *this)
{
  v1 = this + 120;
  v2 = *(this + 16);
  if (v2 == (this + 120))
  {
    return 0;
  }

  v3 = 0;
  v4 = MEMORY[0x1E69E5310];
  v5 = MEMORY[0x1E69E5318];
  do
  {
    v6 = *(v2 + 16);
    if (*(v2 + 64) == 1)
    {
      v7 = *(v2 + 63);
      if (v7 >= 0)
      {
        v8 = (v2 + 40);
      }

      else
      {
        v8 = *(v2 + 40);
      }

      if (v7 >= 0)
      {
        v9 = *(v2 + 63);
      }

      else
      {
        v9 = *(v2 + 48);
      }

      v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v8, v9);
    }

    else
    {
      v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, "No imageAsPngString found for atlasPageIndex: ", 46);
      v12 = MEMORY[0x1B8C61CD0](v11, *(v2 + 16));
      v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v12, ". Will use easel hash as fallback.", 34);
      std::ios_base::getloc((v13 + *(*v13 - 24)));
      v14 = std::locale::use_facet(&v17, v5);
      (v14->__vftable[2].~facet_0)(v14, 10);
      std::locale::~locale(&v17);
      std::ostream::put();
      std::ostream::flush();
      v10 = *(*(v2 + 24) + 8);
    }

    v15 = ((v3 << 6) - 0x61C8864680B583EBLL + (v3 >> 2) + v6) ^ v3;
    v3 = ((v15 << 6) - 0x61C8864680B583EBLL + (v15 >> 2) + v10) ^ v15;
    v2 = *(v2 + 8);
  }

  while (v2 != v1);
  return v3;
}

uint64_t grl::codec::IconDataPack::decode(uint64_t a1, uint64_t *a2)
{
  v81[3] = *MEMORY[0x1E69E9840];
  v3 = *a2;
  v4 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  v5 = *(a1 + 192);
  *(a1 + 184) = v3;
  *(a1 + 192) = v4;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v5);
    v3 = *(a1 + 184);
    v4 = *(a1 + 192);
  }

  memset(__p, 0, sizeof(__p));
  v81[2] = 0;
  v80 = v81;
  v81[0] = 0;
  v68[0] = v3;
  v68[1] = v4;
  if (!v4)
  {
    if (grl::codec::ResourcePack::decodeHeader(v68, __p))
    {
      goto LABEL_5;
    }

LABEL_77:
    v46 = 229;
    v47 = "decodeHeader(_packStream, headerName, chapterDataPositions)";
    v48 = "Failed to decode Pack Header";
    goto LABEL_78;
  }

  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  v6 = grl::codec::ResourcePack::decodeHeader(v68, __p);
  std::__shared_weak_count::__release_shared[abi:nn200100](v4);
  if ((v6 & 1) == 0)
  {
    goto LABEL_77;
  }

LABEL_5:
  if (*__p[0] != 73 || *(__p[0] + 1) != 67 || *(__p[0] + 2) != 79 || *(__p[0] + 3) != 78 || *(__p[0] + 4) != 68 || *(__p[0] + 5) != 65 || *(__p[0] + 6) != 84 || *(__p[0] + 7) != 65 || *(__p[0] + 8) != 80 || *(__p[0] + 9) != 65 || *(__p[0] + 10) != 67 || *(__p[0] + 11) != 75)
  {
    v46 = 231;
    v47 = "headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] == 'D' && headerName[5] == 'A' && headerName[6] == 'T' && headerName[7] == 'A' && headerName[8] == 'P' && headerName[9] == 'A' && headerName[10] == 'C' && headerName[11] == 'K'";
    v48 = "Magic code is wrong";
LABEL_78:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v48, v47, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp", v46);
    goto LABEL_79;
  }

  v67 = 0;
  v7 = v80;
  v8 = 1;
  if (v80 == v81)
  {
    goto LABEL_80;
  }

  v59 = (a1 + 48);
  while (1)
  {
    v9 = *(v7 + 16);
    if (v9 != 14)
    {
      break;
    }

    v15 = *(a1 + 192);
    v63[0] = *(a1 + 184);
    v63[1] = v15;
    v64 = 0;
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      v16 = grl::codec::ResourcePack::decodeChapterSize(v63, v7[5], &v70, &v64);
      std::__shared_weak_count::__release_shared[abi:nn200100](v15);
      if (!v16)
      {
        goto LABEL_95;
      }
    }

    else if (!grl::codec::ResourcePack::decodeChapterSize(v63, v7[5], &v70, &v64))
    {
LABEL_95:
      v46 = 251;
      v47 = "decodeChapterSize(_packStream, chapterPair.second, rawSize, compressedSize)";
      v48 = "Could not decode Chapter Data";
      goto LABEL_78;
    }

    if (v64)
    {
      v46 = 252;
      v47 = "compressedSize == 0";
      v48 = "Atlases can't be compressed. This allows each one to individualy be read from disk.";
      goto LABEL_78;
    }

    std::istream::tellg();
    v33 = v78;
    *(a1 + 296) = v77;
    *(a1 + 312) = v33;
    *(a1 + 328) = v79;
    v34 = v74;
    *(a1 + 232) = v73;
    *(a1 + 248) = v34;
    v35 = v76;
    *(a1 + 264) = v75;
    *(a1 + 280) = v35;
    v36 = v72;
    *(a1 + 200) = *v71;
    *(a1 + 216) = v36;
LABEL_59:
    v39 = v7[1];
    if (v39)
    {
      do
      {
        v40 = v39;
        v39 = *v39;
      }

      while (v39);
    }

    else
    {
      do
      {
        v40 = v7[2];
        v41 = *v40 == v7;
        v7 = v40;
      }

      while (!v41);
    }

    v7 = v40;
    if (v40 == v81)
    {
      v8 = 1;
      goto LABEL_80;
    }
  }

  if (v9 != 13)
  {
    if (v9 == 1)
    {
      v71[0] = 0;
      v71[1] = 0;
      *&v72 = 0;
      v10 = *(a1 + 192);
      v66[0] = *(a1 + 184);
      v66[1] = v10;
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        v11 = grl::codec::ResourcePack::decodeChapterData(v66, v7 + 5, v71);
        std::__shared_weak_count::__release_shared[abi:nn200100](v10);
        if ((v11 & 1) == 0)
        {
          goto LABEL_96;
        }
      }

      else if ((grl::codec::ResourcePack::decodeChapterData(v66, v7 + 5, v71) & 1) == 0)
      {
LABEL_96:
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Could not decode Chapter Data", "decodeChapterData(_packStream, chapterPair.second, chapterData)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp", 239);
        v37 = v71[0];
        goto LABEL_101;
      }

      v37 = v71[0];
      if ((grl::codec::ResourcePack::decodePackInfo(a1, v71[0], v71[1], &v67) & 1) == 0)
      {
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Could not decode Pack Info Chapter", "decodePackInfo(chapterData, context)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp", 240);
LABEL_101:
        if (v37)
        {
          v56 = v37;
          goto LABEL_106;
        }

        goto LABEL_79;
      }

      if (v37)
      {
        v38 = v37;
LABEL_58:
        operator delete(v38);
        goto LABEL_59;
      }
    }

    goto LABEL_59;
  }

  v71[0] = 0;
  v71[1] = 0;
  *&v72 = 0;
  v12 = *(a1 + 192);
  v65[0] = *(a1 + 184);
  v65[1] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    v13 = grl::codec::ResourcePack::decodeChapterData(v65, v7 + 5, v71);
    std::__shared_weak_count::__release_shared[abi:nn200100](v12);
    if ((v13 & 1) == 0)
    {
      goto LABEL_97;
    }
  }

  else
  {
    inserted = grl::codec::ResourcePack::decodeChapterData(v65, v7 + 5, v71);
    if ((inserted & 1) == 0)
    {
LABEL_97:
      v53 = 244;
      v54 = "decodeChapterData(_packStream, chapterPair.second, chapterData)";
      v55 = "Could not decode Chapter Data";
      goto LABEL_105;
    }
  }

  v17 = v71[1] - v71[0];
  if ((v71[1] - v71[0]) < 4)
  {
    v50 = 266;
    v51 = "numImages.has_value()";
    v52 = "Number of Images could not be read";
    goto LABEL_104;
  }

  v60 = v71[0];
  v58 = v71[0] - 2;
  v57 = *v71[0];
  if (!*v71[0])
  {
    v32 = 6;
LABEL_67:
    if (v32 > v17)
    {
      v50 = 296;
      v51 = "numIndices.has_value()";
      v52 = "Number of Indices could not be read";
      goto LABEL_104;
    }

    v42 = *&v60[v32 - 2];
    if (*&v60[v32 - 2])
    {
      while (1)
      {
        if (v32 + 2 > v17)
        {
          LOBYTE(v64) = 0;
          v50 = 300;
          goto LABEL_92;
        }

        v43 = *&v60[v32];
        WORD1(v64) = v43;
        LOBYTE(v64) = 1;
        if (v32 + 6 > v17)
        {
          v50 = 303;
          v51 = "byteStart.has_value()";
          v52 = "Byte Start could not be read";
          goto LABEL_104;
        }

        v44 = v32 + 10;
        if (v32 + 10 > v17)
        {
          break;
        }

        v45 = *&v60[v32 + 2];
        v70 = &v64 + 1;
        std::__tree<std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((a1 + 152), v43, &v70)[4] = v45;
        v32 = v44;
        if (!--v42)
        {
          goto LABEL_73;
        }
      }

      v50 = 306;
      v51 = "byteLength.has_value()";
      v52 = "Byte Length could not be read";
      goto LABEL_104;
    }

LABEL_73:
    v38 = v71[0];
    if (!v71[0])
    {
      goto LABEL_59;
    }

    goto LABEL_58;
  }

  v18 = 0;
  v19 = 4;
  while (2)
  {
    if (v19 + 4 > v17)
    {
      v50 = 270;
      v51 = "imageID.has_value()";
      v52 = "Image ID could not be read";
      goto LABEL_104;
    }

    v20 = v19;
    v21 = v19 + 6;
    if (v19 + 6 > v17)
    {
      v50 = 273;
LABEL_92:
      v51 = "atlasPageIndex.has_value()";
      v52 = "Atlas Index could not be read";
      goto LABEL_104;
    }

    if (v19 + 10 > v17)
    {
      v50 = 276;
      v51 = "atlasOffsetX.has_value()";
LABEL_87:
      v52 = "Atlas Offset could not be read";
      goto LABEL_104;
    }

    if (v19 + 14 > v17)
    {
      v50 = 279;
      v51 = "atlasOffsetY.has_value()";
      goto LABEL_87;
    }

    if (v19 + 18 > v17)
    {
      v50 = 282;
      v51 = "imageSizeX.has_value()";
      goto LABEL_90;
    }

    v19 += 22;
    if (v20 + 22 <= v17)
    {
      v22 = *&v60[v20];
      v62 = *&v58[v21];
      v23 = (a1 + 48);
      v24 = *&v60[v21];
      v25 = (a1 + 48);
      v26 = *&v60[v20 + 10];
      v27 = *&v60[v20 + 14];
      v28 = *v59;
      if (*v59)
      {
        while (1)
        {
          while (1)
          {
            v25 = v28;
            v29 = *(v28 + 7);
            if (v22 >= v29)
            {
              break;
            }

            v28 = *v25;
            v23 = v25;
            if (!*v25)
            {
              goto LABEL_48;
            }
          }

          if (v29 >= v22)
          {
            break;
          }

          v28 = v25[1];
          if (!v28)
          {
            v23 = v25 + 1;
            goto LABEL_48;
          }
        }
      }

      else
      {
LABEL_48:
        v61 = v25;
        v30 = grl::zone_mallocator::instance(inserted);
        v31 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,void *>>(v30);
        *(v31 + 7) = v22;
        *(v31 + 16) = v62;
        *(v31 + 9) = v24;
        *(v31 + 10) = v26;
        *(v31 + 44) = v27;
        inserted = std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::__insert_node_at((a1 + 40), v61, v23, v31);
      }

      if (++v18 == v57)
      {
        v32 = v20 + 24;
        goto LABEL_67;
      }

      continue;
    }

    break;
  }

  v50 = 285;
  v51 = "imageSizeY.has_value()";
LABEL_90:
  v52 = "Image Size could not be read";
LABEL_104:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v52, v51, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp", v50);
  v53 = 245;
  v54 = "decodeImageLocations(chapterData, context)";
  v55 = "Could not decode Image Locations Chapter";
LABEL_105:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v55, v54, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp", v53);
  v56 = v71[0];
  if (v71[0])
  {
LABEL_106:
    operator delete(v56);
  }

LABEL_79:
  v8 = 0;
LABEL_80:
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(v81[0]);
  if (__p[0])
  {
    operator delete(__p[0]);
  }

  return v8;
}

void *std::__tree<std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::codec::IconDataPack::DataRange>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[14];
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = (v7 + 1);
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x28uLL, 0x1020040A08860DFuLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 14) = **a3;
    v7[4] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,void *>>(uint64_t a1)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v2 = malloc_type_zone_malloc(*a1, 0x38uLL, 0x10200409294C6EBuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v2;
}

void grl::codec::IconDataPack::encode(grl::codec::IconDataPack *this, __int16 a2)
{
  v12[3] = *MEMORY[0x1E69E9840];
  v7 = 0;
  v6 = 0;
  v9 = 0;
  v8 = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](&v10);
  LOBYTE(v4[0]) = 73;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 79;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 78;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 68;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 84;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 80;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  LOBYTE(v4[0]) = 75;
  geo::obitstream::appendBytes(&v6, v4, 1);
  memset(v5, 0, sizeof(v5));
  if (v7 != v6)
  {
    if (v7 - v6 >= 0)
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  std::vector<unsigned char>::__append(v5, 0x40uLL);
  v12[2] = 0;
  v11 = v12;
  v12[0] = 0;
  grl::codec::ResourcePack::encodePackInfo(v4, this, a2);
  operator new();
}

void grl::codec::IconDataPack::~IconDataPack(grl::codec::IconDataPack *this)
{
  grl::codec::IconDataPack::~IconDataPack(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F420;
  std::mutex::~mutex((this + 336));
  v2 = *(this + 24);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(this + 20));
  if (*(this + 17))
  {
    v3 = *(this + 16);
    v4 = *(*(this + 15) + 8);
    v5 = *v3;
    *(v5 + 8) = v4;
    *v4 = v5;
    *(this + 17) = 0;
    if (v3 != (this + 120))
    {
      do
      {
        v6 = *(v3 + 1);
        std::__list_imp<std::pair<unsigned short,grl::codec::IconDataPack::AtlasPageImage>>::__delete_node[abi:nn200100](v3);
        v3 = v6;
      }

      while (v6 != (this + 120));
    }
  }

  v7 = *(this + 12);
  if (v7)
  {
    do
    {
      v8 = *v7;
      operator delete(v7);
      v7 = v8;
    }

    while (v8);
  }

  v9 = *(this + 10);
  *(this + 10) = 0;
  if (v9)
  {
    operator delete(v9);
  }

  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(this + 6));
  *this = &unk_1F2A5F9A0;
  if (*(this + 31) < 0)
  {
    operator delete(*(this + 1));
  }
}

void std::__list_imp<std::pair<unsigned short,grl::codec::IconDataPack::AtlasPageImage>>::__delete_node[abi:nn200100](uint64_t a1)
{
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(a1 + 80));
  if (*(a1 + 64) == 1 && *(a1 + 63) < 0)
  {
    operator delete(*(a1 + 40));
  }

  v2 = *(a1 + 32);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  operator delete(a1);
}

void grl::codec::IconDataPack::setNumberOfAtlasPages(grl::codec::IconDataPack *this, uint64_t a2)
{
  std::mutex::lock((this + 336));
  *(this + 9) = a2;
  while (*(this + 17) > *(this + 9))
  {
    geo::Cache<unsigned short,grl::codec::IconDataPack::AtlasPageImage,std::hash<unsigned short>,geo::LRUPolicy>::_pop(this + 9);
  }

  std::mutex::unlock((this + 336));
}

void geo::Cache<unsigned short,grl::codec::IconDataPack::AtlasPageImage,std::hash<unsigned short>,geo::LRUPolicy>::_pop(void *a1)
{
  v16 = *MEMORY[0x1E69E9840];
  v2 = a1[6];
  v8 = *(v2 + 16);
  v3 = *(v2 + 32);
  v9 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  __p.__r_.__value_.__s.__data_[0] = 0;
  v11 = 0;
  std::__optional_storage_base<std::string,false>::__construct_from[abi:nn200100]<std::__optional_copy_base<std::string,false> const&>(&__p, (v2 + 40));
  v14 = *(v2 + 88);
  v15 = 0;
  v12 = &v13;
  v13 = 0;
  std::map<unsigned int,grl::codec::IconDataPack::ImageLocation,std::less<unsigned int>,geo::allocator_adapter<std::pair<unsigned int const,grl::codec::IconDataPack::ImageLocation>,grl::zone_mallocator>>::insert[abi:nn200100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,std::__tree_node<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,void *> *,long>>>(&v12, *(v2 + 72), (v2 + 80));
  v4 = a1[6];
  v6 = *v4;
  v5 = v4[1];
  *(v6 + 8) = v5;
  *v5 = v6;
  --a1[8];
  std::__list_imp<std::pair<unsigned short,grl::codec::IconDataPack::AtlasPageImage>>::__delete_node[abi:nn200100](v4);
  v7 = std::__hash_table<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::mallocator>>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::mallocator>>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::mallocator>>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::mallocator>>>,geo::mallocator>>::find<unsigned short>(a1 + 1, v8);
  if (v7)
  {
    std::__hash_table<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::__list_iterator<std::pair<geo::QuadTile,md::TerrainTileMesh>,void *>>>>::erase(a1 + 1, v7);
  }

  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(v13);
  if (v11 == 1 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v9);
  }
}

uint64_t *std::map<unsigned int,grl::codec::IconDataPack::ImageLocation,std::less<unsigned int>,geo::allocator_adapter<std::pair<unsigned int const,grl::codec::IconDataPack::ImageLocation>,grl::zone_mallocator>>::insert[abi:nn200100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,std::__tree_node<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,void *> *,long>>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    v6 = result + 1;
    do
    {
      v7 = v5[1];
      v8 = v6;
      if (*v5 == v6)
      {
        goto LABEL_9;
      }

      v9 = v5[1];
      v10 = v6;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = *(v9 + 8);
        }

        while (v9);
      }

      else
      {
        do
        {
          v8 = v10[2];
          v11 = *v8 == v10;
          v10 = v8;
        }

        while (v11);
      }

      v12 = *(v4 + 7);
      if (*(v8 + 7) < v12)
      {
LABEL_9:
        if (v7)
        {
          v13 = v8;
        }

        else
        {
          v13 = v6;
        }

        if (v7)
        {
          v14 = (v8 + 1);
        }

        else
        {
          v14 = v6;
        }
      }

      else
      {
        v13 = v6;
        v14 = v6;
        if (v7)
        {
          v14 = v6;
          while (1)
          {
            while (1)
            {
              v13 = v7;
              v20 = *(v7 + 7);
              if (v12 >= v20)
              {
                break;
              }

              v7 = *v13;
              v14 = v13;
              if (!*v13)
              {
                goto LABEL_16;
              }
            }

            if (v20 >= v12)
            {
              break;
            }

            v14 = v13 + 1;
            v7 = v13[1];
            if (!v7)
            {
              goto LABEL_16;
            }
          }
        }
      }

      if (!*v14)
      {
LABEL_16:
        v15 = grl::zone_mallocator::instance(result);
        v16 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned int,grl::codec::IconDataPack::ImageLocation>,void *>>(v15);
        v17 = *(v4 + 44);
        *(v16 + 28) = *(v4 + 28);
        *(v16 + 44) = v17;
        result = std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::__insert_node_at(v5, v13, v14, v16);
      }

      v18 = v4[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = *v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          v19 = v4[2];
          v11 = *v19 == v4;
          v4 = v19;
        }

        while (!v11);
      }

      v4 = v19;
    }

    while (v19 != a3);
  }

  return result;
}

void std::__function::__func<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0,std::allocator<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy_deallocate(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0,std::allocator<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F468;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0,std::allocator<grl::codec::IconDataPack::imageProviderForID(unsigned int)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F468;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  return a1;
}

uint64_t grl::codec::IconMapPack::packLog@<X0>(grl::codec::IconMapPack *this@<X0>, _BYTE *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v22);
  v4 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, "Number of Key Value Pairs: ", 27);
  v5 = MEMORY[0x1B8C61CB0](v4, *(this + 10));
  std::ios_base::getloc((v5 + *(*v5 - 24)));
  v6 = MEMORY[0x1E69E5318];
  v7 = std::locale::use_facet(&v32, MEMORY[0x1E69E5318]);
  (v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v8 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, "Number of Names: ", 17);
  v9 = MEMORY[0x1B8C61CB0](v8, *(this + 17));
  std::ios_base::getloc((v9 + *(*v9 - 24)));
  v10 = std::locale::use_facet(&v32, v6);
  (v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v11 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, "Number of Data Identifiers: ", 28);
  v12 = MEMORY[0x1B8C61CB0](v11, *(this + 24));
  std::ios_base::getloc((v12 + *(*v12 - 24)));
  v13 = std::locale::use_facet(&v32, v6);
  (v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v14 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v23, "Number of Data Text Values: ", 28);
  v15 = MEMORY[0x1B8C61CB0](v14, *(this + 31));
  std::ios_base::getloc((v15 + *(*v15 - 24)));
  v16 = std::locale::use_facet(&v32, v6);
  (v16->__vftable[2].~facet_0)(v16, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  if ((v30 & 0x10) != 0)
  {
    v18 = v29;
    if (v29 < v26)
    {
      v29 = v26;
      v18 = v26;
    }

    locale = v25[4].__locale_;
  }

  else
  {
    if ((v30 & 8) == 0)
    {
      v17 = 0;
      a2[23] = 0;
      goto LABEL_14;
    }

    locale = v25[1].__locale_;
    v18 = v25[3].__locale_;
  }

  v17 = v18 - locale;
  if ((v18 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v17 >= 0x17)
  {
    operator new();
  }

  a2[23] = v17;
  if (v17)
  {
    memmove(a2, locale, v17);
  }

LABEL_14:
  a2[v17] = 0;
  v22[0] = *MEMORY[0x1E69E54D8];
  v20 = *(MEMORY[0x1E69E54D8] + 72);
  *(v22 + *(v22[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
  v23 = v20;
  v24 = MEMORY[0x1E69E5548] + 16;
  if (v28 < 0)
  {
    operator delete(__p);
  }

  v24 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v25);
  std::iostream::~basic_iostream();
  return MEMORY[0x1B8C620C0](&v31);
}

unint64_t grl::codec::IconMapPack::hash(grl::codec::IconMapPack *this)
{
  v1 = (this + 8);
  v2 = *(this + 31);
  v3 = *(this + 2);
  if ((v2 & 0x80u) == 0)
  {
    v4 = (this + 8);
  }

  else
  {
    v4 = *(this + 1);
  }

  if ((v2 & 0x80u) == 0)
  {
    v5 = v2;
  }

  else
  {
    v5 = v3;
  }

  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v4, v5);
  v7 = 0x9E3779B97F4A7C15;
  v8 = v1[6];
  if (v8 != 0.0)
  {
    v7 = LODWORD(v8) - 0x61C8864680B583EBLL;
  }

  return (((v6 - 0x61C8864680B583EBLL) >> 2) + ((v6 - 0x61C8864680B583EBLL) << 6) + v7) ^ (v6 - 0x61C8864680B583EBLL);
}

uint64_t grl::codec::IconMapPack::decode(uint64_t a1, void *a2)
{
  v352[2] = *MEMORY[0x1E69E9840];
  memset(v340, 0, sizeof(v340));
  v342[2] = 0;
  v342[0] = 0;
  v341 = v342;
  v5 = a2[1];
  v339[0] = *a2;
  v339[1] = v5;
  if (!v5)
  {
    if (grl::codec::ResourcePack::decodeHeader(v339, v340))
    {
      goto LABEL_3;
    }

LABEL_543:
    v256 = 318;
    v257 = "decodeHeader(packStream, headerName, chapterDataPositions)";
    v258 = "Failed to decode Pack Header";
    goto LABEL_544;
  }

  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  v6 = grl::codec::ResourcePack::decodeHeader(v339, v340);
  std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  if ((v6 & 1) == 0)
  {
    goto LABEL_543;
  }

LABEL_3:
  if (*v340[0] != 73 || *(v340[0] + 1) != 67 || *(v340[0] + 2) != 79 || *(v340[0] + 3) != 78 || *(v340[0] + 4) != 77 || *(v340[0] + 5) != 65 || *(v340[0] + 6) != 80 || *(v340[0] + 7) != 80 || *(v340[0] + 8) != 65 || *(v340[0] + 9) != 67 || *(v340[0] + 10) != 75)
  {
    v256 = 320;
    v257 = "headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] == 'M' && headerName[5] == 'A' && headerName[6] == 'P' && headerName[7] == 'P' && headerName[8] == 'A' && headerName[9] == 'C' && headerName[10] == 'K'";
    v258 = "Magic code is wrong";
LABEL_544:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v258, v257, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v256);
    goto LABEL_545;
  }

  v338 = 0;
  v7 = v341;
  v8 = 1;
  if (v341 == v342)
  {
    goto LABEL_546;
  }

  v290 = (a1 + 416);
  v291 = (a1 + 456);
  v287 = (a1 + 64);
  v284 = (a1 + 120);
  v286 = (a1 + 176);
  v285 = (a1 + 232);
  while (1)
  {
    v9 = *(v7 + 16);
    if (v9 <= 0xC)
    {
      break;
    }

    if (v9 == 13)
    {
      v295 = v7;
      v346 = 0;
      *&v347.__r_.__value_.__l.__data_ = 0uLL;
      v18 = a2[1];
      v331[0] = *a2;
      v331[1] = v18;
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        v19 = grl::codec::ResourcePack::decodeChapterData(v331, v7 + 5, &v346);
        std::__shared_weak_count::__release_shared[abi:nn200100](v18);
        if ((v19 & 1) == 0)
        {
LABEL_574:
          v268 = 343;
          v269 = "decodeChapterData(packStream, chapterPair.second, chapterData)";
          v270 = "Could not decode Chapter Data";
LABEL_566:
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v270, v269, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v268);
          v271 = v346;
          if (!v346)
          {
            goto LABEL_545;
          }

          goto LABEL_602;
        }
      }

      else if ((grl::codec::ResourcePack::decodeChapterData(v331, v7 + 5, &v346) & 1) == 0)
      {
        goto LABEL_574;
      }

      __pb = v346;
      v319 = v347.__r_.__value_.__r.__words[0] - v346;
      if (v347.__r_.__value_.__r.__words[0] - v346 < 4)
      {
        v261 = 514;
        v262 = "keyFallbackCount.has_value()";
      }

      else
      {
        v64 = *v346;
        v316 = (v346 - 1);
        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 392), vcvtps_u32_f32(*v346 / *(a1 + 440)));
        v309 = v64;
        if (v64)
        {
          v66 = 0;
          v67 = 4;
          v68 = v319;
          while (1)
          {
            if (v67 + 4 > v68)
            {
              v261 = 519;
              v262 = "key.has_value()";
              v263 = "Key could not be read";
              goto LABEL_565;
            }

            v69 = v67;
            v67 += 8;
            if (v67 > v68)
            {
              v261 = 521;
              goto LABEL_564;
            }

            v70 = *(__pb + v69);
            v329 = *(v316 + v67);
            v71 = *(a1 + 400);
            v303 = v69;
            if (v71)
            {
              v72 = vcnt_s8(v71);
              v72.i16[0] = vaddlv_u8(v72);
              if (v72.u32[0] > 1uLL)
              {
                p_dst = *(__pb + v69);
                if (v71 <= v70)
                {
                  p_dst = v70 % v71;
                }
              }

              else
              {
                p_dst = (v71 - 1) & v70;
              }

              v73 = *(*(a1 + 392) + 8 * p_dst);
              if (v73)
              {
                for (i = *v73; i; i = *i)
                {
                  v75 = *(i + 1);
                  if (v75 == v70)
                  {
                    if (*(i + 4) == v70)
                    {
                      goto LABEL_151;
                    }
                  }

                  else
                  {
                    if (v72.u32[0] > 1uLL)
                    {
                      if (v75 >= v71)
                      {
                        v75 %= v71;
                      }
                    }

                    else
                    {
                      v75 &= v71 - 1;
                    }

                    if (v75 != p_dst)
                    {
                      break;
                    }
                  }
                }
              }
            }

            v76 = grl::zone_mallocator::instance(v65);
            v65 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<unsigned int,unsigned int>,void *>>(v76);
            i = v65;
            *v65 = 0;
            *(v65 + 1) = v70;
            *(v65 + 4) = v70;
            *(v65 + 5) = 0;
            v77 = (*(a1 + 432) + 1);
            v78 = *(a1 + 440);
            if (!v71 || (v78 * v71) < v77)
            {
              v79 = (v71 & (v71 - 1)) != 0;
              if (v71 < 3)
              {
                v79 = 1;
              }

              v80 = v79 | (2 * v71);
              v81 = vcvtps_u32_f32(v77 / v78);
              if (v80 <= v81)
              {
                v82 = v81;
              }

              else
              {
                v82 = v80;
              }

              std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 392), v82);
              v71 = *(a1 + 400);
              if ((v71 & (v71 - 1)) != 0)
              {
                if (v71 <= v70)
                {
                  p_dst = v70 % v71;
                }

                else
                {
                  p_dst = v70;
                }
              }

              else
              {
                p_dst = (v71 - 1) & v70;
              }
            }

            v83 = *(a1 + 392);
            v84 = *(v83 + 8 * p_dst);
            if (v84)
            {
              *i = *v84;
            }

            else
            {
              *i = *v290;
              *v290 = i;
              *(v83 + 8 * p_dst) = v290;
              if (!*i)
              {
                goto LABEL_150;
              }

              v85 = *(*i + 8);
              if ((v71 & (v71 - 1)) != 0)
              {
                if (v85 >= v71)
                {
                  v85 %= v71;
                }
              }

              else
              {
                v85 &= v71 - 1;
              }

              v84 = (*(a1 + 392) + 8 * v85);
            }

            *v84 = i;
LABEL_150:
            ++*(a1 + 432);
LABEL_151:
            *(i + 5) = v329;
            ++v66;
            v68 = v319;
            if (v66 == v309)
            {
              v86 = v303 + 12;
              goto LABEL_503;
            }
          }
        }

        v86 = 8;
LABEL_503:
        if (v86 <= v319)
        {
          v297 = *(__pb + v86 - 4);
          if (!v297)
          {
LABEL_531:
            v187 = __pb;
            goto LABEL_532;
          }

          v239 = 0;
          while (v86 + 4 <= v319)
          {
            if (v86 + 8 > v319)
            {
              v261 = 532;
              v262 = "max.has_value()";
              v263 = "Max could not be read";
              goto LABEL_565;
            }

            v240 = v86 + 12;
            if (v86 + 12 > v319)
            {
              v261 = 534;
LABEL_564:
              v262 = "value.has_value()";
              v263 = "Value could not be read";
              goto LABEL_565;
            }

            v241 = *(__pb + v86);
            v242 = *(v316 + v86 + 8);
            v86 += 12;
            v243 = *(v316 + v240);
            v244 = (a1 + 456);
            v245 = *v291;
            v246 = (a1 + 456);
            if (*v291)
            {
              while (1)
              {
                v246 = v245;
                v247 = v245[7];
                if (v241 == v247)
                {
                  v248 = *(v246 + 8);
                  if (v242 >= v248)
                  {
                    v249 = v248 == v242;
                    if (v248 >= v242)
                    {
                      v250 = 1;
                    }

                    else
                    {
                      v250 = -1;
                    }

                    if (v249)
                    {
                      v250 = 0;
                    }

                    goto LABEL_524;
                  }

LABEL_519:
                  v245 = *v246;
                  v244 = v246;
                  if (!*v246)
                  {
                    break;
                  }
                }

                else
                {
                  if (v241 < v247)
                  {
                    goto LABEL_519;
                  }

                  if (v247 >= v241)
                  {
                    v250 = 1;
                  }

                  else
                  {
                    v250 = -1;
                  }

LABEL_524:
                  if ((v250 & 0x80) == 0)
                  {
                    goto LABEL_529;
                  }

                  v244 = (v246 + 8);
                  v245 = *(v246 + 1);
                  if (!v245)
                  {
                    break;
                  }
                }
              }
            }

            v307 = v243;
            v315 = v239;
            v330 = v86;
            __srcc = v246;
            v251 = grl::zone_mallocator::instance(v65);
            geo::read_write_lock::read_lock((v251 + 32));
            p_dst = v251 + 24;
            v246 = malloc_type_zone_malloc(*v251, 0x28uLL, 0x1020040DC041F22uLL);
            atomic_fetch_add((v251 + 24), 1u);
            geo::read_write_lock::unlock((v251 + 32));
            *(v246 + 28) = v241 | (v242 << 32);
            *(v246 + 9) = 0;
            *v246 = 0;
            *(v246 + 1) = 0;
            *(v246 + 2) = __srcc;
            *v244 = v246;
            v252 = **(a1 + 448);
            v253 = v246;
            if (v252)
            {
              *(a1 + 448) = v252;
              v253 = *v244;
            }

            v65 = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(*(a1 + 456), v253);
            ++*(a1 + 472);
            v86 = v330;
            v239 = v315;
            v243 = v307;
LABEL_529:
            *(v246 + 9) = v243;
            if (++v239 == v297)
            {
              __pb = v346;
              if (!v346)
              {
                goto LABEL_533;
              }

              goto LABEL_531;
            }
          }

          v261 = 530;
          v262 = "min.has_value()";
          v263 = "Min could not be read";
LABEL_565:
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v263, v262, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v261);
          v268 = 344;
          v269 = "decodeFallbackMapping(chapterData, context)";
          v270 = "Could not decode Fallback chapter";
          goto LABEL_566;
        }

        v261 = 526;
        v262 = "dataFallbackCount.has_value()";
      }

      v263 = "Count could not be read";
      goto LABEL_565;
    }

    if (v9 == 14)
    {
      v295 = v7;
      v343 = 0uLL;
      v344 = 0;
      v12 = a2[1];
      v332[0] = *a2;
      v332[1] = v12;
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        v13 = grl::codec::ResourcePack::decodeChapterData(v332, v7 + 5, &v343);
        std::__shared_weak_count::__release_shared[abi:nn200100](v12);
        if ((v13 & 1) == 0)
        {
          goto LABEL_573;
        }
      }

      else
      {
        v14 = grl::codec::ResourcePack::decodeChapterData(v332, v7 + 5, &v343);
        if ((v14 & 1) == 0)
        {
LABEL_573:
          v275 = 338;
          v276 = "decodeChapterData(packStream, chapterPair.second, chapterData)";
          v277 = "Could not decode Chapter Data";
          goto LABEL_601;
        }
      }

      __pa = v343;
      v328 = *(&v343 + 1) - v343;
      if (*(&v343 + 1) - v343 < 4uLL)
      {
        v272 = 443;
        v273 = "defaultRegionCount.has_value()";
        v274 = "Count could not be read";
      }

      else
      {
        v320 = *v343;
        if (*v343)
        {
          v50 = 0;
          v51 = 4;
          do
          {
            v52 = v51;
            v51 += 4;
            if (v51 > v328)
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Region could not be read", "regionName.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 447);
              goto LABEL_600;
            }

            v53 = (a1 + 272);
            v54 = *&__pa[v52];
LABEL_91:
            v55 = *v53;
            v56 = v53;
            if (*v53)
            {
              do
              {
                v53 = v55;
                v57 = *(v55 + 7);
                if (v54 < v57)
                {
                  goto LABEL_91;
                }

                if (v57 >= v54)
                {
                  goto LABEL_100;
                }

                v55 = v53[1];
              }

              while (v55);
              v56 = v53 + 1;
            }

            v58 = grl::zone_mallocator::instance(v14);
            v59 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<unsigned int,void *>>(v58);
            v59[7] = v54;
            *v59 = 0;
            *(v59 + 1) = 0;
            *(v59 + 2) = v53;
            *v56 = v59;
            v60 = **(a1 + 264);
            if (v60)
            {
              *(a1 + 264) = v60;
              v61 = *v56;
            }

            else
            {
              v61 = v59;
            }

            v14 = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(*(a1 + 272), v61);
            ++*(a1 + 288);
LABEL_100:
            ++v50;
          }

          while (v50 != v320);
          v62 = v52 + 8;
        }

        else
        {
          v62 = 8;
        }

        if (v62 > v328)
        {
          v272 = 452;
          v273 = "numberOfIconIDToRegions.has_value()";
          v274 = "Number of Regions to Icon ID could not be read";
        }

        else
        {
          v319 = (__pa - 4);
          v312 = *&__pa[v62 - 4];
          if (v312)
          {
            LODWORD(v316) = 0;
            while (v62 + 4 <= v328)
            {
              HIDWORD(v334) = *&__pa[v62];
              LOBYTE(v334) = 1;
              v188 = v62 + 8;
              if (v62 + 8 > v328)
              {
                v272 = 459;
                goto LABEL_598;
              }

              v189 = *(v319 + v188);
              memset(&__dst, 0, sizeof(__dst));
              v190 = std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::reserve(&__dst, v189);
              if (v189)
              {
                do
                {
                  v62 = v188 + 4;
                  if (v188 + 4 > v328)
                  {
                    v260 = 465;
                    goto LABEL_560;
                  }

                  v191 = *&__pa[v188];
                  size = __dst.__r_.__value_.__l.__size_;
                  if (__dst.__r_.__value_.__l.__size_ >= __dst.__r_.__value_.__r.__words[2])
                  {
                    v194 = __dst.__r_.__value_.__r.__words[0];
                    v195 = __dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0];
                    v196 = (__dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0]) >> 2;
                    v197 = v196 + 1;
                    if ((v196 + 1) >> 62)
                    {
LABEL_606:
                      std::__throw_bad_array_new_length[abi:nn200100]();
                    }

                    v198 = __dst.__r_.__value_.__r.__words[2] - __dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] - __dst.__r_.__value_.__r.__words[0]) >> 1 > v197)
                    {
                      v197 = v198 >> 1;
                    }

                    if (v198 >= 0x7FFFFFFFFFFFFFFCLL)
                    {
                      v199 = 0x3FFFFFFFFFFFFFFFLL;
                    }

                    else
                    {
                      v199 = v197;
                    }

                    v348 = v352;
                    if (v199)
                    {
                      v200 = grl::zone_mallocator::instance(v190);
                      v201 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned int>(v200, v199);
                      v194 = __dst.__r_.__value_.__r.__words[0];
                      v195 = __dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0];
                    }

                    else
                    {
                      v201 = 0;
                    }

                    v202 = &v201[4 * v196];
                    v203 = &v201[4 * v199];
                    v204 = &v202[-4 * ((__dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0]) >> 2)];
                    *v202 = v191;
                    v193 = (v202 + 4);
                    memcpy(v204, v194, v195);
                    v205 = __dst.__r_.__value_.__r.__words[0];
                    v206 = __dst.__r_.__value_.__r.__words[2];
                    __dst.__r_.__value_.__r.__words[0] = v204;
                    __dst.__r_.__value_.__l.__size_ = v193;
                    __dst.__r_.__value_.__r.__words[2] = v203;
                    v347.__r_.__value_.__l.__size_ = v205;
                    v347.__r_.__value_.__r.__words[2] = v206;
                    v346 = v205;
                    v347.__r_.__value_.__r.__words[0] = v205;
                    v190 = std::__split_buffer<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator> &>::~__split_buffer(&v346);
                  }

                  else
                  {
                    *__dst.__r_.__value_.__l.__size_ = v191;
                    v193 = size + 4;
                  }

                  __dst.__r_.__value_.__l.__size_ = v193;
                  v188 = v62;
                  LODWORD(v189) = v189 - 1;
                }

                while (v189);
              }

              else
              {
                v62 += 8;
              }

              v346 = &v334 + 1;
              v207 = std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((a1 + 328), HIDWORD(v334), &v346);
              std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__vdeallocate((v207 + 5));
              *(v207 + 5) = __dst;
              memset(&__dst, 0, sizeof(__dst));
              std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&__dst);
              LODWORD(v316) = v316 + 1;
              if (v316 == v312)
              {
                goto LABEL_443;
              }
            }

            LOBYTE(v334) = 0;
            v272 = 456;
            v273 = "iconID.has_value()";
            v274 = "Icon ID could not be read";
          }

          else
          {
LABEL_443:
            p_dst = v62 + 4;
            if (v62 + 4 > v328)
            {
              v272 = 473;
              v273 = "numberOfCountryCodeToRegions.has_value()";
              v274 = "Number of Regions to Country Code could not be read";
              goto LABEL_599;
            }

            v313 = *&__pa[v62];
            if (v313)
            {
              LODWORD(v316) = 0;
              while (1)
              {
                if (p_dst + 4 > v328)
                {
                  LOBYTE(v334) = 0;
                  v272 = 477;
                  v273 = "countryCode.has_value()";
                  v274 = "Country Code could not be read";
                  goto LABEL_599;
                }

                HIDWORD(v334) = *&__pa[p_dst];
                LOBYTE(v334) = 1;
                v208 = p_dst + 8;
                if (p_dst + 8 > v328)
                {
                  break;
                }

                v209 = *(v319 + v208);
                memset(&__dst, 0, sizeof(__dst));
                v210 = std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::reserve(&__dst, v209);
                if (v209)
                {
                  while (1)
                  {
                    p_dst = v208 + 4;
                    if (v208 + 4 > v328)
                    {
                      break;
                    }

                    v211 = *&__pa[v208];
                    v212 = __dst.__r_.__value_.__l.__size_;
                    if (__dst.__r_.__value_.__l.__size_ >= __dst.__r_.__value_.__r.__words[2])
                    {
                      v214 = __dst.__r_.__value_.__r.__words[0];
                      v215 = __dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0];
                      v216 = (__dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0]) >> 2;
                      v217 = v216 + 1;
                      if ((v216 + 1) >> 62)
                      {
                        goto LABEL_606;
                      }

                      v218 = __dst.__r_.__value_.__r.__words[2] - __dst.__r_.__value_.__r.__words[0];
                      if ((__dst.__r_.__value_.__r.__words[2] - __dst.__r_.__value_.__r.__words[0]) >> 1 > v217)
                      {
                        v217 = v218 >> 1;
                      }

                      if (v218 >= 0x7FFFFFFFFFFFFFFCLL)
                      {
                        v219 = 0x3FFFFFFFFFFFFFFFLL;
                      }

                      else
                      {
                        v219 = v217;
                      }

                      v348 = v352;
                      if (v219)
                      {
                        v220 = grl::zone_mallocator::instance(v210);
                        v221 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned int>(v220, v219);
                        v214 = __dst.__r_.__value_.__r.__words[0];
                        v215 = __dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0];
                      }

                      else
                      {
                        v221 = 0;
                      }

                      v222 = &v221[4 * v216];
                      v223 = &v221[4 * v219];
                      v224 = &v222[-4 * ((__dst.__r_.__value_.__l.__size_ - __dst.__r_.__value_.__r.__words[0]) >> 2)];
                      *v222 = v211;
                      v213 = (v222 + 4);
                      memcpy(v224, v214, v215);
                      v225 = __dst.__r_.__value_.__r.__words[0];
                      v226 = __dst.__r_.__value_.__r.__words[2];
                      __dst.__r_.__value_.__r.__words[0] = v224;
                      __dst.__r_.__value_.__l.__size_ = v213;
                      __dst.__r_.__value_.__r.__words[2] = v223;
                      v347.__r_.__value_.__l.__size_ = v225;
                      v347.__r_.__value_.__r.__words[2] = v226;
                      v346 = v225;
                      v347.__r_.__value_.__r.__words[0] = v225;
                      v210 = std::__split_buffer<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator> &>::~__split_buffer(&v346);
                    }

                    else
                    {
                      *__dst.__r_.__value_.__l.__size_ = v211;
                      v213 = v212 + 4;
                    }

                    __dst.__r_.__value_.__l.__size_ = v213;
                    v208 = p_dst;
                    LODWORD(v209) = v209 - 1;
                    if (!v209)
                    {
                      goto LABEL_465;
                    }
                  }

                  v260 = 486;
LABEL_560:
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Region ID could not be read", "regionID.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v260);
                  std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&__dst);
                  goto LABEL_600;
                }

                p_dst += 8;
LABEL_465:
                v346 = &v334 + 1;
                v227 = std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((a1 + 360), HIDWORD(v334), &v346);
                std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__vdeallocate((v227 + 5));
                *(v227 + 5) = __dst;
                memset(&__dst, 0, sizeof(__dst));
                std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&__dst);
                LODWORD(v316) = v316 + 1;
                if (v316 == v313)
                {
                  goto LABEL_466;
                }
              }

              v272 = 480;
LABEL_598:
              v273 = "numberOfRegions.has_value()";
              v274 = "Number of Regions could not be read";
            }

            else
            {
LABEL_466:
              if (p_dst + 4 <= v328)
              {
                LODWORD(v316) = *&__pa[p_dst];
                if (!v316)
                {
                  goto LABEL_500;
                }

                p_dst += 4;
              }

              LODWORD(v319) = 0;
              while (v328 >= p_dst + 4)
              {
                if (v328 == p_dst + 4)
                {
LABEL_475:
                  LOBYTE(v346) = 0;
                  v14 = printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Region Name could not be read", "regionName.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 501);
                  v231 = 0;
                  p_dst += 4;
                }

                else
                {
                  v228 = 0;
                  v229 = *&__pa[p_dst];
                  v230 = &__pa[p_dst + 4];
                  while (v230[v228])
                  {
                    if (v328 - (p_dst + 4) == ++v228)
                    {
                      goto LABEL_475;
                    }
                  }

                  if (v228 > 0x7FFFFFFFFFFFFFF7)
                  {
LABEL_607:
                    std::__throw_bad_array_new_length[abi:nn200100]();
                  }

                  if (v228 >= 0x17)
                  {
                    operator new();
                  }

                  *(&__dst.__r_.__value_.__s + 23) = v228;
                  if (v228)
                  {
                    v14 = memmove(&__dst, v230, v228);
                  }

                  __dst.__r_.__value_.__s.__data_[v228] = 0;
                  LOBYTE(v346) = 1;
                  v347 = __dst;
                  v232 = (a1 + 304);
                  while (1)
                  {
                    v233 = *v232;
                    v234 = v232;
                    if (!*v232)
                    {
                      break;
                    }

                    while (1)
                    {
                      v232 = v233;
                      v235 = *(v233 + 8);
                      if (v229 < v235)
                      {
                        break;
                      }

                      if (v235 >= v229)
                      {
                        goto LABEL_491;
                      }

                      v233 = *(v232 + 1);
                      if (!v233)
                      {
                        v234 = (v232 + 8);
                        goto LABEL_488;
                      }
                    }
                  }

LABEL_488:
                  v314 = v232;
                  v306 = grl::zone_mallocator::instance(v14);
                  geo::read_write_lock::read_lock((v306 + 32));
                  v232 = malloc_type_zone_malloc(*v306, 0x40uLL, 0x1032040C21377B2uLL);
                  atomic_fetch_add((v306 + 24), 1u);
                  geo::read_write_lock::unlock((v306 + 32));
                  *(v232 + 8) = v229;
                  *(v232 + 6) = 0;
                  *(v232 + 7) = 0;
                  *(v232 + 5) = 0;
                  *v232 = 0;
                  *(v232 + 1) = 0;
                  *(v232 + 2) = v314;
                  *v234 = v232;
                  v236 = **(a1 + 296);
                  v237 = v232;
                  if (v236)
                  {
                    *(a1 + 296) = v236;
                    v237 = *v234;
                  }

                  std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(*(a1 + 304), v237);
                  ++*(a1 + 320);
LABEL_491:
                  p_dst += v228 + 5;
                  v14 = std::string::operator=((v232 + 40), &v347);
                  v231 = 1;
                }

                if (v346 == 1 && SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v347.__r_.__value_.__l.__data_);
                }

                LODWORD(v319) = v319 + 1;
                if (v319 == v316)
                {
                  v238 = 0;
                }

                else
                {
                  v238 = v231;
                }

                if ((v238 & 1) == 0)
                {
                  if (v231)
                  {
LABEL_500:
                    v187 = v343;
                    if (v343)
                    {
                      goto LABEL_532;
                    }

LABEL_533:
                    v7 = v295;
                    goto LABEL_534;
                  }

LABEL_600:
                  v275 = 339;
                  v276 = "decodeRegionMapping(chapterData, context)";
                  v277 = "Could not decode Region Name chapter";
LABEL_601:
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v277, v276, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v275);
                  v271 = v343;
                  if (!v343)
                  {
                    goto LABEL_545;
                  }

LABEL_602:
                  operator delete(v271);
                  goto LABEL_545;
                }
              }

              v272 = 498;
              v273 = "region.has_value()";
              v274 = "Region ID could not be read";
            }
          }
        }
      }

LABEL_599:
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v274, v273, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v272);
      goto LABEL_600;
    }

LABEL_534:
    v254 = v7[1];
    if (v254)
    {
      do
      {
        v255 = v254;
        v254 = *v254;
      }

      while (v254);
    }

    else
    {
      do
      {
        v255 = v7[2];
        v36 = *v255 == v7;
        v7 = v255;
      }

      while (!v36);
    }

    v7 = v255;
    if (v255 == v342)
    {
      v8 = 1;
      goto LABEL_546;
    }
  }

  if (v9 == 1)
  {
    v15 = v7;
    v346 = 0;
    *&v347.__r_.__value_.__l.__data_ = 0uLL;
    v16 = a2[1];
    v337[0] = *a2;
    v337[1] = v16;
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      v17 = grl::codec::ResourcePack::decodeChapterData(v337, v7 + 5, &v346);
      std::__shared_weak_count::__release_shared[abi:nn200100](v16);
      if ((v17 & 1) == 0)
      {
        goto LABEL_575;
      }
    }

    else if ((grl::codec::ResourcePack::decodeChapterData(v337, v7 + 5, &v346) & 1) == 0)
    {
LABEL_575:
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Could not decode Chapter Data", "decodeChapterData(packStream, chapterPair.second, chapterData)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 328);
      v63 = v346;
LABEL_581:
      if (!v63)
      {
        goto LABEL_545;
      }

      v271 = v63;
      goto LABEL_602;
    }

    v63 = v346;
    if ((grl::codec::ResourcePack::decodePackInfo(a1, v346, v347.__r_.__value_.__l.__data_, &v338) & 1) == 0)
    {
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Could not decode Pack Info chapter", "decodePackInfo(chapterData, context)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 329);
      goto LABEL_581;
    }

    if (v63)
    {
      operator delete(v63);
    }

    v7 = v15;
    goto LABEL_534;
  }

  if (v9 != 11)
  {
    goto LABEL_534;
  }

  v295 = v7;
  v334 = 0;
  v335 = 0;
  v336 = 0;
  v10 = a2[1];
  v333[0] = *a2;
  v333[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    v11 = grl::codec::ResourcePack::decodeChapterData(v333, v7 + 5, &v334);
    std::__shared_weak_count::__release_shared[abi:nn200100](v10);
    if ((v11 & 1) == 0)
    {
      goto LABEL_576;
    }
  }

  else if ((grl::codec::ResourcePack::decodeChapterData(v333, v7 + 5, &v334) & 1) == 0)
  {
LABEL_576:
    v278 = 333;
    v279 = "decodeChapterData(packStream, chapterPair.second, chapterData)";
    v280 = "Could not decode Chapter Data";
    goto LABEL_594;
  }

  __p = v334;
  v327 = v335 - v334;
  if ((v335 - v334) < 4)
  {
    v264 = 364;
    v265 = "mapCount.has_value()";
LABEL_591:
    v266 = "Map Count could not be read";
    goto LABEL_592;
  }

  v20 = *v334;
  v296 = v334 - 1;
  std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 40), vcvtps_u32_f32(*v334 / *(a1 + 88)));
  v292 = v20;
  if (v20)
  {
    v22 = 0;
    v23 = 4;
    v24 = v327;
    while (1)
    {
      if (v23 + 4 > v24)
      {
        v264 = 369;
        v265 = "key.has_value()";
        v266 = "Key could not be read";
        goto LABEL_592;
      }

      v25 = v23;
      v26 = v23 + 8;
      if (v23 + 8 > v24)
      {
        v264 = 372;
        v265 = "value.has_value()";
        v266 = "Value could not be read";
        goto LABEL_592;
      }

      v23 += 12;
      if (v25 + 12 > v24)
      {
        v267 = 375;
LABEL_571:
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Identifier could not be read", "identifer.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v267);
        goto LABEL_593;
      }

      v288 = v25;
      v27 = *(__p + v25);
      v28 = *(v296 + v26);
      v308 = *(v296 + v23);
      v317 = v27;
      v29 = v28 - 0x61C8864680B583EBLL + ((v27 - 0x61C8864680B583EBLL) << 6) + ((v27 - 0x61C8864680B583EBLL) >> 2);
      p_dst = v29 ^ (v27 - 0x61C8864680B583EBLL);
      v30 = *(a1 + 48);
      if (v30)
      {
        v31 = vcnt_s8(v30);
        v31.i16[0] = vaddlv_u8(v31);
        if (v31.u32[0] > 1uLL)
        {
          v32 = v29 ^ (v27 - 0x61C8864680B583EBLL);
          if (p_dst >= v30)
          {
            v32 = p_dst % v30;
          }
        }

        else
        {
          v32 = p_dst & (v30 - 1);
        }

        v319 = v32;
        v33 = *(*(a1 + 40) + 8 * v32);
        if (v33)
        {
          for (j = *v33; j; j = *j)
          {
            v35 = j[1];
            if (v35 == p_dst)
            {
              v36 = *(j + 4) == v317 && *(j + 5) == v28;
              if (v36)
              {
                goto LABEL_83;
              }
            }

            else
            {
              if (v31.u32[0] > 1uLL)
              {
                if (v35 >= v30)
                {
                  v35 %= v30;
                }
              }

              else
              {
                v35 &= v30 - 1;
              }

              if (v35 != v32)
              {
                break;
              }
            }
          }
        }
      }

      __src = v23;
      v302 = v22;
      v37 = grl::zone_mallocator::instance(v21);
      geo::read_write_lock::read_lock((v37 + 32));
      v38 = malloc_type_zone_malloc(*v37, 0x20uLL, 0x1020040FA731AC5uLL);
      atomic_fetch_add((v37 + 24), 1u);
      geo::read_write_lock::unlock((v37 + 32));
      *v38 = 0;
      v38[1] = p_dst;
      v38[2] = v317 | (v28 << 32);
      *(v38 + 6) = v308;
      v39 = (*(a1 + 80) + 1);
      v40 = *(a1 + 88);
      if (!v30 || (v40 * v30) < v39)
      {
        v41 = (v30 & (v30 - 1)) != 0;
        if (v30 < 3)
        {
          v41 = 1;
        }

        v42 = v41 | (2 * v30);
        v43 = vcvtps_u32_f32(v39 / v40);
        if (v42 <= v43)
        {
          v44 = v43;
        }

        else
        {
          v44 = v42;
        }

        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 40), v44);
        v30 = *(a1 + 48);
        if ((v30 & (v30 - 1)) != 0)
        {
          if (p_dst < v30)
          {
            v319 = p_dst;
            goto LABEL_73;
          }

          v45 = p_dst % v30;
        }

        else
        {
          v45 = (v30 - 1) & p_dst;
        }

        v319 = v45;
      }

LABEL_73:
      v46 = *(a1 + 40);
      v47 = *(v46 + 8 * v319);
      if (v47)
      {
        *v38 = *v47;
      }

      else
      {
        *v38 = *v287;
        *v287 = v38;
        *(v46 + 8 * v319) = v287;
        if (!*v38)
        {
          goto LABEL_82;
        }

        v48 = *(*v38 + 8);
        if ((v30 & (v30 - 1)) != 0)
        {
          if (v48 >= v30)
          {
            v48 %= v30;
          }
        }

        else
        {
          v48 &= v30 - 1;
        }

        v47 = (*(a1 + 40) + 8 * v48);
      }

      *v47 = v38;
LABEL_82:
      ++*(a1 + 80);
      v24 = v327;
      v22 = v302;
      v23 = __src;
LABEL_83:
      if (++v22 == v292)
      {
        v49 = v288 + 16;
        goto LABEL_154;
      }
    }
  }

  v49 = 8;
LABEL_154:
  if (v49 > v327)
  {
    v264 = 381;
    v265 = "nameMapCount.has_value()";
    goto LABEL_591;
  }

  v87 = *(__p + v49 - 4);
  std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 96), vcvtps_u32_f32(v87 / *(a1 + 144)));
  v318 = v87;
  if (v87)
  {
    v321 = 0;
    while (1)
    {
      if (v327 == v49)
      {
LABEL_551:
        LOBYTE(v346) = 0;
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Name could not be read", "name.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 386);
        if (v346 == 1 && SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v347.__r_.__value_.__l.__data_);
        }

        goto LABEL_593;
      }

      v88 = 0;
      v89 = __p + v49;
      while (v89[v88])
      {
        if (v327 - v49 == ++v88)
        {
          goto LABEL_551;
        }
      }

      if (v88 > 0x7FFFFFFFFFFFFFF7)
      {
        goto LABEL_607;
      }

      if (v88 >= 0x17)
      {
        operator new();
      }

      *(&__dst.__r_.__value_.__s + 23) = v88;
      p_dst = &__dst;
      if (v88)
      {
        memmove(&__dst, v89, v88);
      }

      __dst.__r_.__value_.__s.__data_[v88] = 0;
      v90 = v49 + v88;
      v49 += v88 + 1;
      LOBYTE(v346) = 1;
      v347 = __dst;
      v91 = v90 + 5;
      if (v90 + 5 <= v327)
      {
        break;
      }

      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Identifier could not be read", "identifer.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 389);
LABEL_226:
      if (v346 == 1 && SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v347.__r_.__value_.__l.__data_);
      }

      if (v91 > v327)
      {
        goto LABEL_593;
      }

      if (++v321 == v318)
      {
        goto LABEL_231;
      }
    }

    v304 = *(__p + v49);
    if ((v347.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v92 = &v347;
    }

    else
    {
      v92 = v347.__r_.__value_.__r.__words[0];
    }

    if ((v347.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v93 = HIBYTE(v347.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v93 = v347.__r_.__value_.__l.__size_;
    }

    std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(&__dst, v92, v92 + v93, v93);
    v310 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    __srca = __dst.__r_.__value_.__r.__words[0];
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v94 = &__dst;
    }

    else
    {
      v94 = __dst.__r_.__value_.__r.__words[0];
    }

    v293 = __dst.__r_.__value_.__l.__size_;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v95 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v95 = __dst.__r_.__value_.__l.__size_;
    }

    inited = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v94, v95);
    v97 = inited;
    v98 = *(a1 + 104);
    if (v98)
    {
      v99 = vcnt_s8(v98);
      v99.i16[0] = vaddlv_u8(v99);
      v100 = v99.u32[0];
      if (v99.u32[0] > 1uLL)
      {
        v49 = inited;
        if (inited >= v98)
        {
          v49 = inited % v98;
        }
      }

      else
      {
        v49 = (v98 - 1) & inited;
      }

      v101 = *(*(a1 + 96) + 8 * v49);
      if (v101)
      {
        for (p_dst = *v101; p_dst; p_dst = *p_dst)
        {
          v102 = *(p_dst + 8);
          if (v102 == v97)
          {
            inited = std::equal_to<std::string>::operator()[abi:nn200100]((p_dst + 16), &__dst);
            if (inited)
            {
              goto LABEL_223;
            }
          }

          else
          {
            if (v100 > 1)
            {
              if (v102 >= v98)
              {
                v102 %= v98;
              }
            }

            else
            {
              v102 &= v98 - 1;
            }

            if (v102 != v49)
            {
              break;
            }
          }
        }
      }
    }

    v103 = grl::zone_mallocator::instance(inited);
    inited = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,void *>>(v103);
    v104 = inited;
    *inited = 0;
    *(inited + 8) = v97;
    *(inited + 40) = v352[0];
    if (v310 < 0)
    {
      inited = std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_copy_ctor_external((inited + 16), __srca, v293);
    }

    else
    {
      *(inited + 16) = __dst;
    }

    v104[12] = v304;
    v105 = (*(a1 + 136) + 1);
    v106 = *(a1 + 144);
    if (!v98 || (v106 * v98) < v105)
    {
      v107 = (v98 & (v98 - 1)) != 0;
      if (v98 < 3)
      {
        v107 = 1;
      }

      v108 = v107 | (2 * v98);
      v109 = vcvtps_u32_f32(v105 / v106);
      if (v108 <= v109)
      {
        v110 = v109;
      }

      else
      {
        v110 = v108;
      }

      std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 96), v110);
      v98 = *(a1 + 104);
      if ((v98 & (v98 - 1)) != 0)
      {
        if (v97 >= v98)
        {
          v49 = v97 % v98;
        }

        else
        {
          v49 = v97;
        }
      }

      else
      {
        v49 = (v98 - 1) & v97;
      }
    }

    v111 = *(a1 + 96);
    v112 = *(v111 + 8 * v49);
    if (v112)
    {
      *v104 = *v112;
    }

    else
    {
      *v104 = *v284;
      *v284 = v104;
      *(v111 + 8 * v49) = v284;
      if (!*v104)
      {
        goto LABEL_222;
      }

      v113 = *(*v104 + 8);
      if ((v98 & (v98 - 1)) != 0)
      {
        if (v113 >= v98)
        {
          v113 %= v98;
        }
      }

      else
      {
        v113 &= v98 - 1;
      }

      v112 = (*(a1 + 96) + 8 * v113);
    }

    *v112 = v104;
LABEL_222:
    ++*(a1 + 136);
LABEL_223:
    if (v310 < 0)
    {
      v114 = grl::zone_mallocator::instance(inited);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v114, __srca);
    }

    v49 = v91;
    goto LABEL_226;
  }

LABEL_231:
  v115 = v49 + 4;
  if (v49 + 4 > v327)
  {
    v264 = 395;
    v265 = "dataMapCount.has_value()";
    v266 = "Data Count could not be read";
    goto LABEL_592;
  }

  v116 = *(__p + v49);
  std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 152), vcvtps_u32_f32(v116 / *(a1 + 200)));
  LODWORD(v316) = v116;
  if (v116)
  {
    for (k = 0; k != v316; ++k)
    {
      if (v115 + 4 > v327)
      {
        v264 = 400;
        goto LABEL_585;
      }

      v119 = v115 + 8;
      if (v115 + 8 > v327)
      {
        v267 = 403;
        goto LABEL_571;
      }

      v120 = *(__p + v115);
      v115 += 8;
      v322 = *(v296 + v119);
      v121 = *(a1 + 160);
      if (v121)
      {
        v122 = vcnt_s8(v121);
        v122.i16[0] = vaddlv_u8(v122);
        if (v122.u32[0] > 1uLL)
        {
          p_dst = v120;
          if (v121 <= v120)
          {
            p_dst = v120 % v121;
          }
        }

        else
        {
          p_dst = (v121 - 1) & v120;
        }

        v123 = *(*(a1 + 152) + 8 * p_dst);
        if (v123)
        {
          for (m = *v123; m; m = *m)
          {
            v125 = m[1];
            if (v125 == v120)
            {
              if (*(m + 4) == v120)
              {
                goto LABEL_274;
              }
            }

            else
            {
              if (v122.u32[0] > 1uLL)
              {
                if (v125 >= v121)
                {
                  v125 %= v121;
                }
              }

              else
              {
                v125 &= v121 - 1;
              }

              if (v125 != p_dst)
              {
                break;
              }
            }
          }
        }
      }

      v126 = grl::zone_mallocator::instance(v117);
      v117 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<unsigned int,unsigned int>,void *>>(v126);
      v127 = v117;
      *v117 = 0;
      *(v117 + 1) = v120;
      *(v117 + 4) = v120;
      *(v117 + 5) = v322;
      v128 = (*(a1 + 192) + 1);
      v129 = *(a1 + 200);
      if (!v121 || (v129 * v121) < v128)
      {
        v130 = (v121 & (v121 - 1)) != 0;
        if (v121 < 3)
        {
          v130 = 1;
        }

        v131 = v130 | (2 * v121);
        v132 = vcvtps_u32_f32(v128 / v129);
        if (v131 <= v132)
        {
          v133 = v132;
        }

        else
        {
          v133 = v131;
        }

        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 152), v133);
        v121 = *(a1 + 160);
        if ((v121 & (v121 - 1)) != 0)
        {
          if (v121 <= v120)
          {
            p_dst = v120 % v121;
          }

          else
          {
            p_dst = v120;
          }
        }

        else
        {
          p_dst = (v121 - 1) & v120;
        }
      }

      v134 = *(a1 + 152);
      v135 = *(v134 + 8 * p_dst);
      if (v135)
      {
        *v127 = *v135;
      }

      else
      {
        *v127 = *v286;
        *v286 = v127;
        *(v134 + 8 * p_dst) = v286;
        if (!*v127)
        {
          goto LABEL_273;
        }

        v136 = *(*v127 + 8);
        if ((v121 & (v121 - 1)) != 0)
        {
          if (v136 >= v121)
          {
            v136 %= v121;
          }
        }

        else
        {
          v136 &= v121 - 1;
        }

        v135 = (*(a1 + 152) + 8 * v136);
      }

      *v135 = v127;
LABEL_273:
      ++*(a1 + 192);
LABEL_274:
      ;
    }
  }

  v319 = v115 + 4;
  if (v115 + 4 > v327)
  {
    v264 = 409;
    v265 = "textDataMapCount.has_value()";
    v266 = "Text Data Count could not be read";
    goto LABEL_592;
  }

  v137 = *(__p + v115);
  std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 208), vcvtps_u32_f32(v137 / *(a1 + 256)));
  v294 = v137;
  if (!v137)
  {
    goto LABEL_417;
  }

  v311 = 0;
  do
  {
    if (v319 + 4 > v327)
    {
      v264 = 414;
LABEL_585:
      v265 = "dataID.has_value()";
      v266 = "Data ID could not be read";
LABEL_592:
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v266, v265, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v264);
      goto LABEL_593;
    }

    v138 = v319 + 8;
    if (v319 + 8 > v327)
    {
      v264 = 417;
      v265 = "textMapCount.has_value()";
      v266 = "Text Map Count could not be read";
      goto LABEL_592;
    }

    v316 = *(__p + v319);
    v139 = *(v296 + v138);
    v346 = 0;
    v347.__r_.__value_.__r.__words[0] = 0;
    v349 = 0;
    *(&v347.__r_.__value_.__r.__words[1] + 1) = 0;
    v347.__r_.__value_.__r.__words[2] = 0;
    v350 = 1.0;
    std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>(&v346, v139);
    __srcb = v139;
    if (!v139)
    {
      v319 += 8;
LABEL_359:
      p_dst = *(a1 + 216);
      if (p_dst)
      {
        v165 = vcnt_s8(p_dst);
        v165.i16[0] = vaddlv_u8(v165);
        if (v165.u32[0] > 1uLL)
        {
          v138 = v316;
          if (p_dst <= v316)
          {
            v138 = v316 % p_dst;
          }
        }

        else
        {
          v138 = (p_dst - 1) & v316;
        }

        v166 = *(*(a1 + 208) + 8 * v138);
        if (v166)
        {
          v167 = *v166;
          if (*v166)
          {
            do
            {
              v168 = *(v167 + 1);
              if (v168 == v316)
              {
                if (*(v167 + 4) == v316)
                {
                  goto LABEL_397;
                }
              }

              else
              {
                if (v165.u32[0] > 1uLL)
                {
                  if (v168 >= p_dst)
                  {
                    v168 %= p_dst;
                  }
                }

                else
                {
                  v168 &= p_dst - 1;
                }

                if (v168 != v138)
                {
                  break;
                }
              }

              v167 = *v167;
            }

            while (v167);
          }
        }
      }

      v169 = grl::zone_mallocator::instance(v140);
      geo::read_write_lock::read_lock((v169 + 32));
      v167 = malloc_type_zone_malloc(*v169, 0x50uLL, 0x10A0040821D7242uLL);
      atomic_fetch_add((v169 + 24), 1u);
      geo::read_write_lock::unlock((v169 + 32));
      *v167 = 0;
      *(v167 + 1) = v316;
      *(v167 + 4) = v316;
      *(v167 + 3) = 0;
      *(v167 + 4) = 0;
      *(v167 + 8) = 0;
      *(v167 + 41) = 0;
      *(v167 + 6) = 0;
      *(v167 + 18) = 1065353216;
      v170 = (*(a1 + 248) + 1);
      v171 = *(a1 + 256);
      if (!p_dst || (v171 * p_dst) < v170)
      {
        v172 = (p_dst & (p_dst - 1)) != 0;
        if (p_dst < 3)
        {
          v172 = 1;
        }

        v173 = v172 | (2 * p_dst);
        v174 = vcvtps_u32_f32(v170 / v171);
        if (v173 <= v174)
        {
          v175 = v174;
        }

        else
        {
          v175 = v173;
        }

        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>((a1 + 208), v175);
        p_dst = *(a1 + 216);
        if ((p_dst & (p_dst - 1)) != 0)
        {
          if (p_dst <= v316)
          {
            v138 = v316 % p_dst;
          }

          else
          {
            v138 = v316;
          }
        }

        else
        {
          v138 = (p_dst - 1) & v316;
        }
      }

      v176 = *(a1 + 208);
      v177 = *(v176 + 8 * v138);
      if (v177)
      {
        *v167 = *v177;
      }

      else
      {
        *v167 = *v285;
        *v285 = v167;
        *(v176 + 8 * v138) = v285;
        if (!*v167)
        {
          goto LABEL_396;
        }

        v178 = *(*v167 + 8);
        if ((p_dst & (p_dst - 1)) != 0)
        {
          if (v178 >= p_dst)
          {
            v178 %= p_dst;
          }
        }

        else
        {
          v178 &= p_dst - 1;
        }

        v177 = (*(a1 + 208) + 8 * v178);
      }

      *v177 = v167;
LABEL_396:
      ++*(a1 + 248);
LABEL_397:
      if (*(v167 + 8))
      {
        std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::__deallocate_node(*(v167 + 6));
        *(v167 + 6) = 0;
        v179 = *(v167 + 4);
        if (v179)
        {
          for (n = 0; n != v179; ++n)
          {
            *(*(v167 + 3) + 8 * n) = 0;
          }
        }

        *(v167 + 8) = 0;
      }

      v181 = v346;
      v346 = 0;
      std::unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *,grl::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> **,0>((v167 + 24), v181);
      v182 = v347.__r_.__value_.__r.__words[0];
      v183 = v347.__r_.__value_.__r.__words[2];
      *(v167 + 6) = *(&v347.__r_.__value_.__l + 2);
      *(v167 + 4) = v182;
      v347.__r_.__value_.__r.__words[0] = 0;
      v184 = v349;
      *(v167 + 8) = v349;
      *(v167 + 18) = v350;
      if (v184)
      {
        v185 = *(v183 + 8);
        if ((v182 & (v182 - 1)) != 0)
        {
          if (v185 >= v182)
          {
            v185 %= v182;
          }
        }

        else
        {
          v185 &= v182 - 1;
        }

        *(*(v167 + 3) + 8 * v185) = v167 + 48;
        v347.__r_.__value_.__r.__words[2] = 0;
        v349 = 0;
      }

      v186 = 1;
      goto LABEL_414;
    }

    v305 = 0;
    v319 += 8;
    while (v327 != v319)
    {
      v141 = 0;
      v142 = __p + v319;
      while (v142[v141])
      {
        if (v327 - v319 == ++v141)
        {
          goto LABEL_410;
        }
      }

      if (v141 > 0x7FFFFFFFFFFFFFF7)
      {
        goto LABEL_607;
      }

      if (v141 >= 0x17)
      {
        operator new();
      }

      HIBYTE(v344) = v141;
      p_dst = &v343;
      if (v141)
      {
        memmove(&v343, v142, v141);
      }

      *(&v343 + v141) = 0;
      v143 = v319 + v141;
      v319 += v141 + 1;
      __dst.__r_.__value_.__s.__data_[0] = 1;
      *&__dst.__r_.__value_.__r.__words[1] = v343;
      v352[0] = v344;
      v144 = v143 + 5;
      if (v143 + 5 > v327)
      {
        v140 = printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Identifier could not be read", "identifier.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 426);
        goto LABEL_352;
      }

      v289 = *(__p + v319);
      if (v352[0] >= 0)
      {
        p_size = &__dst.__r_.__value_.__l.__size_;
      }

      else
      {
        p_size = __dst.__r_.__value_.__l.__size_;
      }

      if (v352[0] >= 0)
      {
        v146 = HIBYTE(v352[0]);
      }

      else
      {
        v146 = __dst.__r_.__value_.__r.__words[2];
      }

      std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(&v343, p_size, p_size + v146, v146);
      v323 = SHIBYTE(v344);
      v282 = *(&v343 + 1);
      v283 = v343;
      if (v344 >= 0)
      {
        v147 = &v343;
      }

      else
      {
        v147 = v343;
      }

      if (v344 >= 0)
      {
        v148 = HIBYTE(v344);
      }

      else
      {
        v148 = *(&v343 + 1);
      }

      v140 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v147, v148);
      v149 = v140;
      v150 = v347.__r_.__value_.__r.__words[0];
      if (v347.__r_.__value_.__r.__words[0])
      {
        v151 = vcnt_s8(v347.__r_.__value_.__l.__data_);
        v151.i16[0] = vaddlv_u8(v151);
        p_dst = v151.u32[0];
        if (v151.u32[0] > 1uLL)
        {
          v138 = v140;
          if (v140 >= v347.__r_.__value_.__r.__words[0])
          {
            v138 = v140 % v347.__r_.__value_.__r.__words[0];
          }
        }

        else
        {
          v138 = (v347.__r_.__value_.__r.__words[0] - 1) & v140;
        }

        v152 = *&v346[2 * v138];
        if (v152)
        {
          v153 = *v152;
          if (*v152)
          {
            v281 = v347.__r_.__value_.__r.__words[0] - 1;
            do
            {
              v154 = *(v153 + 8);
              if (v154 == v149)
              {
                v140 = std::equal_to<std::string>::operator()[abi:nn200100]((v153 + 16), &v343);
                if (v140)
                {
                  goto LABEL_349;
                }
              }

              else
              {
                if (p_dst > 1)
                {
                  if (v154 >= v150)
                  {
                    v154 %= v150;
                  }
                }

                else
                {
                  v154 &= v281;
                }

                if (v154 != v138)
                {
                  break;
                }
              }

              v153 = *v153;
            }

            while (v153);
          }
        }
      }

      v155 = grl::zone_mallocator::instance(v140);
      v140 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,void *>>(v155);
      v153 = v140;
      *v140 = 0;
      *(v140 + 8) = v149;
      *(v140 + 40) = v345;
      if (v323 < 0)
      {
        v140 = std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_copy_ctor_external((v140 + 16), v283, v282);
      }

      else
      {
        *(v140 + 16) = v343;
        *(v140 + 32) = v344;
      }

      *(v153 + 48) = 0;
      v156 = (v349 + 1);
      if (!v150 || (v350 * v150) < v156)
      {
        v157 = (v150 & (v150 - 1)) != 0;
        if (v150 < 3)
        {
          v157 = 1;
        }

        v158 = v157 | (2 * v150);
        v159 = vcvtps_u32_f32(v156 / v350);
        if (v158 <= v159)
        {
          v160 = v159;
        }

        else
        {
          v160 = v158;
        }

        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>(&v346, v160);
        v150 = v347.__r_.__value_.__r.__words[0];
        if ((v150 & (v150 - 1)) != 0)
        {
          if (v149 >= v347.__r_.__value_.__r.__words[0])
          {
            v138 = v149 % v347.__r_.__value_.__r.__words[0];
          }

          else
          {
            v138 = v149;
          }
        }

        else
        {
          v138 = (v347.__r_.__value_.__r.__words[0] - 1) & v149;
        }
      }

      v161 = v346;
      v162 = *&v346[2 * v138];
      if (v162)
      {
        *v153 = *v162;
      }

      else
      {
        *v153 = *(&v347.__r_.__value_.__l + 2);
        v347.__r_.__value_.__r.__words[2] = v153;
        *&v161[2 * v138] = &v347.__r_.__value_.__l + 16;
        if (!*v153)
        {
          goto LABEL_348;
        }

        v163 = *(*v153 + 8);
        if ((v150 & (v150 - 1)) != 0)
        {
          if (v163 >= v150)
          {
            v163 %= v150;
          }
        }

        else
        {
          v163 &= v150 - 1;
        }

        v162 = &v346[2 * v163];
      }

      *v162 = v153;
LABEL_348:
      ++v349;
LABEL_349:
      *(v153 + 48) = v289;
      if (v323 < 0)
      {
        v164 = grl::zone_mallocator::instance(v140);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v164, v283);
      }

      v319 = v144;
LABEL_352:
      if (__dst.__r_.__value_.__s.__data_[0] == 1 && SHIBYTE(v352[0]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__size_);
      }

      if (v144 > v327)
      {
        goto LABEL_413;
      }

      if (++v305 == __srcb)
      {
        goto LABEL_359;
      }
    }

    v319 = v327;
LABEL_410:
    __dst.__r_.__value_.__s.__data_[0] = 0;
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Text could not be read", "text.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", 423);
    if (__dst.__r_.__value_.__s.__data_[0] == 1 && SHIBYTE(v352[0]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__size_);
    }

LABEL_413:
    v186 = 0;
LABEL_414:
    std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::~__hash_table(&v346);
    if (!v186)
    {
      break;
    }

    ++v311;
  }

  while (v311 != v294);
  if (v186)
  {
LABEL_417:
    v187 = v334;
    if (!v334)
    {
      goto LABEL_533;
    }

LABEL_532:
    operator delete(v187);
    goto LABEL_533;
  }

LABEL_593:
  v278 = 334;
  v279 = "decodeIconIDMapping(chapterData, context)";
  v280 = "Could not decode Icon ID chapter";
LABEL_594:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v280, v279, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v278);
  v271 = v334;
  if (v334)
  {
    goto LABEL_602;
  }

LABEL_545:
  v8 = 0;
LABEL_546:
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(v342[0]);
  if (v340[0])
  {
    operator delete(v340[0]);
  }

  return v8;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<unsigned int,unsigned int>,void *>>(uint64_t a1)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v2 = malloc_type_zone_malloc(*a1, 0x18uLL, 0x102004024DAA5DEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v2;
}

grl::zone_mallocator *std::__split_buffer<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator> &>::~__split_buffer(grl::zone_mallocator *a1)
{
  v3 = *(a1 + 1);
  v2 = *(a1 + 2);
  if (v2 != v3)
  {
    *(a1 + 2) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }

  v4 = *a1;
  if (*a1)
  {
    v5 = grl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v5, v4);
  }

  return a1;
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 8);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x48uLL, 0x1030040482059EAuLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 8) = **a3;
    v7[6] = 0;
    v7[7] = 0;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

void std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__vdeallocate(grl::zone_mallocator *a1)
{
  v1 = *a1;
  if (*a1)
  {
    *(a1 + 1) = v1;
    v3 = grl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v3, v1);
    *a1 = 0;
    *(a1 + 1) = 0;
    *(a1 + 2) = 0;
  }
}

void std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](grl::zone_mallocator *a1)
{
  v1 = *a1;
  if (*a1)
  {
    *(a1 + 1) = v1;
    v2 = grl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v2, v1);
  }
}

void std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::allocator_adapter<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::zone_mallocator>>::__rehash<true>(grl::zone_mallocator *prime, size_t __n)
{
  v2 = prime;
  if (__n == 1)
  {
    v3 = 2;
  }

  else
  {
    v3 = __n;
    if ((__n & (__n - 1)) != 0)
    {
      prime = std::__next_prime(__n);
      v3 = prime;
    }
  }

  v4 = *(v2 + 8);
  if (*&v3 <= *&v4)
  {
    if (*&v3 >= *&v4)
    {
      return;
    }

    prime = vcvtps_u32_f32(*(v2 + 5) / *(v2 + 12));
    if (*&v4 < 3uLL || (v11 = vcnt_s8(v4), v11.i16[0] = vaddlv_u8(v11), v11.u32[0] > 1uLL))
    {
      prime = std::__next_prime(prime);
    }

    else
    {
      v12 = 1 << -__clz(prime - 1);
      if (prime >= 2)
      {
        prime = v12;
      }
    }

    if (*&v3 <= prime)
    {
      v3 = prime;
    }

    if (*&v3 >= *&v4)
    {
      return;
    }

    if (!*&v3)
    {
      std::unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *,grl::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> **,0>(v2, 0);
      *(v2 + 1) = 0;
      return;
    }
  }

  v5 = grl::zone_mallocator::instance(prime);
  geo::read_write_lock::read_lock((v5 + 32));
  v6 = malloc_type_zone_malloc(*v5, 8 * *&v3, 0x2004093837F09uLL);
  atomic_fetch_add((v5 + 24), 1u);
  geo::read_write_lock::unlock((v5 + 32));
  std::unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *,grl::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> **,0>(v2, v6);
  v7 = 0;
  *(v2 + 1) = v3;
  do
  {
    *(*v2 + 8 * v7++) = 0;
  }

  while (*&v3 != v7);
  v8 = *(v2 + 3);
  if (v8)
  {
    v9 = v8[1];
    v10 = vcnt_s8(v3);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= *&v3)
      {
        v9 %= *&v3;
      }
    }

    else
    {
      v9 &= *&v3 - 1;
    }

    *(*v2 + 8 * v9) = v2 + 24;
    v13 = *v8;
    if (*v8)
    {
      do
      {
        v14 = v13[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v14 >= *&v3)
          {
            v14 %= *&v3;
          }
        }

        else
        {
          v14 &= *&v3 - 1;
        }

        if (v14 != v9)
        {
          v15 = *v2;
          if (!*(*v2 + 8 * v14))
          {
            *(v15 + 8 * v14) = v8;
            goto LABEL_28;
          }

          *v8 = *v13;
          *v13 = **(v15 + 8 * v14);
          **(v15 + 8 * v14) = v13;
          v13 = v8;
        }

        v14 = v9;
LABEL_28:
        v8 = v13;
        v13 = *v13;
        v9 = v14;
      }

      while (v13);
    }
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::__deallocate_node(*(a1 + 24));
  v3 = *a1;
  *a1 = 0;
  if (v3)
  {
    v4 = grl::zone_mallocator::instance(v2);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v4, v3);
  }

  return a1;
}

void std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::__deallocate_node(grl::zone_mallocator *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *v1;
      if (*(v1 + 39) < 0)
      {
        v3 = *(v1 + 2);
        v4 = grl::zone_mallocator::instance(a1);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v4, v3);
      }

      v5 = grl::zone_mallocator::instance(a1);
      geo::read_write_lock::read_lock((v5 + 32));
      atomic_fetch_add((v5 + 24), 0xFFFFFFFF);
      malloc_zone_free(*v5, v1);
      geo::read_write_lock::unlock((v5 + 32));
      v1 = v2;
    }

    while (v2);
  }
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,void *>>(uint64_t a1)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v2 = malloc_type_zone_malloc(*a1, 0x38uLL, 0x103204089C9A3D5uLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v2;
}

void *std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_copy_ctor_external(grl::zone_mallocator *__dst, void *__src, unint64_t a3)
{
  v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    if ((a3 | 7) == 0x17)
    {
      v6 = 25;
    }

    else
    {
      v6 = (a3 | 7) + 1;
    }

    v7 = grl::zone_mallocator::instance(__dst);
    v8 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<char>(v7, v6);
    *(v5 + 1) = a3;
    *(v5 + 2) = v6 | 0x8000000000000000;
    *v5 = v8;
    v5 = v8;
  }

  else
  {
    *(__dst + 23) = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void std::unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *[],std::__bucket_list_deallocator<geo::allocator_adapter<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> *,grl::zone_mallocator>>>::reset[abi:nn200100]<std::__hash_node_base<std::__hash_node<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,void *> *> **,0>(grl::zone_mallocator *a1, uint64_t a2)
{
  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = grl::zone_mallocator::instance(a1);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v3, v2);
  }
}

void grl::codec::IconMapPack::encode(grl::codec::IconMapPack *this, __int16 a2)
{
  v12[3] = *MEMORY[0x1E69E9840];
  v7 = 0;
  v6 = 0;
  v9 = 0;
  v8 = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](v10);
  v4[0] = 73;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 79;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 78;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 77;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 80;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 80;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 65;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 67;
  geo::obitstream::appendBytes(&v6, v4, 1);
  v4[0] = 75;
  geo::obitstream::appendBytes(&v6, v4, 1);
  memset(v5, 0, sizeof(v5));
  if (v7 != v6)
  {
    if (v7 - v6 >= 0)
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  std::vector<unsigned char>::__append(v5, 0x40uLL);
  v12[0] = 0;
  v12[2] = 0;
  v11 = v12;
  grl::codec::ResourcePack::encodePackInfo(v4, this, a2);
  operator new();
}

void grl::codec::IconMapPack::~IconMapPack(grl::codec::IconMapPack *this)
{
  grl::codec::IconMapPack::~IconMapPack(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F958;
  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(*(this + 57));
  std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned int,unsigned int>,grl::zone_mallocator>>::~__hash_table((this + 392));
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::destroy(*(this + 46));
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::destroy(*(this + 42));
  std::__tree<std::__value_type<grl::PropertyID,std::string>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,std::string>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,std::string>,grl::zone_mallocator>>::destroy(*(this + 38));
  std::__tree<unsigned int,std::less<unsigned int>,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::destroy(*(this + 34));
  v3 = *(this + 29);
  if (v3)
  {
    do
    {
      v4 = *v3;
      v5 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::~__hash_table((v3 + 3));
      v6 = grl::zone_mallocator::instance(v5);
      geo::read_write_lock::read_lock((v6 + 32));
      atomic_fetch_add((v6 + 24), 0xFFFFFFFF);
      malloc_zone_free(*v6, v3);
      geo::read_write_lock::unlock((v6 + 32));
      v3 = v4;
    }

    while (v4);
  }

  v7 = *(this + 26);
  *(this + 26) = 0;
  if (v7)
  {
    v8 = grl::zone_mallocator::instance(v2);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v8, v7);
  }

  std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned int,unsigned int>,grl::zone_mallocator>>::~__hash_table((this + 152));
  v9 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>>,true>,geo::allocator_adapter<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>,unsigned int>,grl::zone_mallocator>>::~__hash_table(this + 96);
  v10 = *(this + 8);
  if (v10)
  {
    do
    {
      v11 = *v10;
      v12 = grl::zone_mallocator::instance(v9);
      geo::read_write_lock::read_lock((v12 + 32));
      atomic_fetch_add((v12 + 24), 0xFFFFFFFF);
      malloc_zone_free(*v12, v10);
      geo::read_write_lock::unlock((v12 + 32));
      v10 = v11;
    }

    while (v11);
  }

  v13 = *(this + 5);
  *(this + 5) = 0;
  if (v13)
  {
    v14 = grl::zone_mallocator::instance(v9);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v14, v13);
  }

  *this = &unk_1F2A5F9A0;
  if (*(this + 31) < 0)
  {
    operator delete(*(this + 1));
  }
}

grl::zone_mallocator *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned int,unsigned int>,grl::zone_mallocator>>::~__hash_table(grl::zone_mallocator *a1)
{
  v2 = *(a1 + 3);
  if (v2)
  {
    do
    {
      v3 = *v2;
      v4 = grl::zone_mallocator::instance(a1);
      geo::read_write_lock::read_lock((v4 + 32));
      atomic_fetch_add((v4 + 24), 0xFFFFFFFF);
      malloc_zone_free(*v4, v2);
      geo::read_write_lock::unlock((v4 + 32));
      v2 = v3;
    }

    while (v3);
  }

  v5 = *a1;
  *a1 = 0;
  if (v5)
  {
    v6 = grl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v6, v5);
  }

  return a1;
}

void std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,std::less<unsigned int>,true>,geo::allocator_adapter<std::__value_type<unsigned int,std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>>,grl::zone_mallocator>>::destroy(a1[1]);
    std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100]((a1 + 5));
    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void std::__tree<unsigned int,std::less<unsigned int>,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<unsigned int,std::less<unsigned int>,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::destroy(*a1);
    v2 = std::__tree<unsigned int,std::less<unsigned int>,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::destroy(a1[1]);
    v3 = grl::zone_mallocator::instance(v2);

    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__tree_node<unsigned int,void *>>(v3, a1);
  }
}

_BYTE *std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(_BYTE *__dst, void *__src, uint64_t a3, unint64_t a4)
{
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v7 = __dst;
  if (a4 > 0x16)
  {
    if ((a4 | 7) == 0x17)
    {
      v8 = 25;
    }

    else
    {
      v8 = (a4 | 7) + 1;
    }

    v9 = grl::zone_mallocator::instance(__dst);
    __dst = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<char>(v9, v8);
    v7[1] = a4;
    v7[2] = v8 | 0x8000000000000000;
    *v7 = __dst;
    v7 = __dst;
  }

  else
  {
    __dst[23] = a4;
  }

  v10 = a3 - __src;
  if (v10)
  {
    __dst = memmove(v7, __src, v10);
  }

  *(v7 + v10) = 0;
  return __dst;
}

uint64_t grl::codec::IconMapPack::dataIDFallback(grl::codec::IconMapPack *this, const unsigned int *a2)
{
  v2 = *(this + 56);
  v3 = this + 456;
  if (v2 != this + 456)
  {
    while (*(v2 + 7) > a2 || *(v2 + 8) < a2)
    {
      v5 = *(v2 + 1);
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          v6 = *(v2 + 2);
          v7 = *v6 == v2;
          v2 = v6;
        }

        while (!v7);
      }

      v2 = v6;
      if (v6 == v3)
      {
        return 0;
      }
    }
  }

  if (v2 == v3)
  {
    return 0;
  }

  else
  {
    return *(v2 + 9);
  }
}

uint64_t grl::codec::IconRenderItem::decode(uint64_t *a1, _BYTE *a2, unint64_t a3, uint64_t a4)
{
  v415[2] = *MEMORY[0x1E69E9840];
  if (!a3)
  {
    v22 = 87;
    v23 = "imageCount.has_value()";
    v24 = "Icon Image Count could not be read";
LABEL_817:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v24, v23, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", v22);
    return 0;
  }

  v4 = a3;
  v5 = a2;
  v405 = a2 - 4;
  v402 = a1;
  v403 = *a2;
  if (*a2)
  {
    v6 = 0;
    v400 = (a1 + 26);
    v7 = 1;
    while (1)
    {
      if (v7 + 2 > v4)
      {
        v22 = 91;
        v23 = "imageLayerIndex.has_value()";
        v24 = "Image Layer Index could not be read";
        goto LABEL_817;
      }

      v8 = v7 + 6;
      if (v7 + 6 > v4)
      {
        v22 = 94;
        v23 = "imageID.has_value()";
        v24 = "Image ID could not be read";
        goto LABEL_817;
      }

      if (v7 + 10 > v4)
      {
        v22 = 96;
        v23 = "imageSizeX.has_value()";
        v24 = "Image Size X could not be read";
        goto LABEL_817;
      }

      v9 = v7 + 14;
      if (v7 + 14 > v4)
      {
        break;
      }

      v10 = *&v5[v7];
      v11 = *&v405[v8];
      v12 = v400;
      v13 = v400;
      v14 = *&v5[v8];
      v15 = *v400;
      if (*v400)
      {
        while (1)
        {
          while (1)
          {
            v13 = v15;
            v16 = v15[14];
            if (v10 >= v16)
            {
              break;
            }

            v15 = *v13;
            v12 = v13;
            if (!*v13)
            {
              goto LABEL_15;
            }
          }

          if (v16 >= v10)
          {
            break;
          }

          v15 = v13[1];
          if (!v15)
          {
            v12 = (v13 + 1);
            goto LABEL_15;
          }
        }
      }

      else
      {
LABEL_15:
        v406 = *&v405[v8];
        v17 = v5;
        v18 = v13;
        v19 = grl::zone_mallocator::instance(a1);
        geo::read_write_lock::read_lock((v19 + 32));
        v13 = malloc_type_zone_malloc(*v19, 0x30uLL, 0x1020040A06574B7uLL);
        atomic_fetch_add((v19 + 24), 1u);
        geo::read_write_lock::unlock((v19 + 32));
        *(v13 + 14) = v10;
        v13[4] = 0;
        *(v13 + 10) = 0;
        *v13 = 0;
        v13[1] = 0;
        v13[2] = v18;
        *v12 = v13;
        v20 = *v402[25];
        v21 = v13;
        if (v20)
        {
          v402[25] = v20;
          v21 = *v12;
        }

        a1 = std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v402[26], v21);
        v402[28] = (v402[28] + 1);
        v5 = v17;
        v11 = v406;
      }

      *(v13 + 8) = v11;
      *(v13 + 36) = v14;
      ++v6;
      v7 = v9;
      if (v6 >= v403)
      {
        goto LABEL_22;
      }
    }

    v22 = 98;
    v23 = "imageSizeY.has_value()";
    v24 = "Image Size Y could not be read";
    goto LABEL_817;
  }

  v9 = 1;
LABEL_22:
  v25 = v9 + 1;
  if (v9 + 1 > v4)
  {
    v22 = 106;
    v23 = "layerCount.has_value()";
    v24 = "Icon Layer Count could not be read";
    goto LABEL_817;
  }

  v26 = v5[v9];
  if (v26)
  {
    v384 = 0;
    v385 = 0;
    v391 = 0;
    v392 = 0;
    v27 = 0;
    v390 = 0;
    v28 = 0;
    v399 = (a4 + 8);
    v401 = v5 - 2;
    v382 = v402 + 47;
    v383 = (v402 + 6);
    v389 = v5;
    while (1)
    {
      if (v25 + 2 > v4)
      {
        v377 = 110;
        v378 = "layerTypeRaw.has_value()";
        v379 = "Layer Type could not be read";
        goto LABEL_824;
      }

      v29 = *&v5[v25];
      v30 = v29;
      if (v29 >= 5)
      {
        if (GEOGetGeoResourceLibCodecLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibCodecLog::onceToken, &__block_literal_global_5_53784);
        }

        v31 = GEOGetGeoResourceLibCodecLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibCodecLog::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 67109890;
          *&buf[4] = v29;
          *&buf[8] = 2080;
          *&buf[10] = "false";
          *&buf[18] = 2080;
          *&buf[20] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Model/Generated/IconEnums.cpp";
          *&buf[28] = 1024;
          LODWORD(v412) = 337;
          _os_log_impl(&dword_1B2754000, v31, OS_LOG_TYPE_ERROR, "LayerType value is out of range with value %d.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x22u);
        }

        v30 = v27;
      }

      v32 = v25 + 4;
      if (v25 + 4 > v4)
      {
        break;
      }

      v33 = v25 + 8;
      if (v25 + 8 > v4)
      {
        v377 = 117;
        v378 = "layerLength.has_value()";
        v379 = "Layer Length could not be read";
        goto LABEL_824;
      }

      v34 = *&v405[v33];
      v25 = v33 + v34;
      if (v33 + v34 > v4)
      {
        v377 = 120;
        v378 = "layerData.has_value()";
        v379 = "Layer Data could not be read";
        goto LABEL_824;
      }

      v404 = v28;
      v35 = *&v401[v32];
      memset(buf, 0, 24);
      if (v34)
      {
        std::vector<unsigned char>::__append(buf, v34);
        v36 = *buf;
        v407 = *buf;
      }

      else
      {
        v407 = 0uLL;
        v36 = 0;
      }

      v37 = memcpy(v36, &v5[v33], v34);
      if (v29 > 4)
      {
        v40 = 19;
        v44 = v404;
        v41 = v30;
        *&v42 = v407;
      }

      else
      {
        v40 = 0;
        v41 = v30;
        if (v30 <= 1)
        {
          v42 = v407;
          if (v30)
          {
            v45 = v402 + 16;
            while (1)
            {
              v46 = *v45;
              v47 = v45;
              if (!*v45)
              {
                break;
              }

              while (1)
              {
                v45 = v46;
                v48 = v46[16];
                if (v35 < v48)
                {
                  break;
                }

                if (v48 >= v35)
                {
                  v53 = v385;
                  v44 = v404;
                  goto LABEL_604;
                }

                v46 = v45[1];
                if (!v46)
                {
                  v47 = (v45 + 1);
                  goto LABEL_54;
                }
              }
            }

LABEL_54:
            v49 = v45;
            v50 = grl::zone_mallocator::instance(v37);
            geo::read_write_lock::read_lock((v50 + 32));
            v45 = malloc_type_zone_malloc(*v50, 0xB0uLL, 0x10A0040EB1E5B49uLL);
            atomic_fetch_add((v50 + 24), 1u);
            geo::read_write_lock::unlock((v50 + 32));
            *(v45 + 16) = v35;
            grl::codec::PathLayerData::PathLayerData((v45 + 5));
            *v45 = 0;
            v45[1] = 0;
            v45[2] = v49;
            *v47 = v45;
            v51 = *v402[15];
            v52 = v45;
            if (v51)
            {
              v402[15] = v51;
              v52 = *v47;
            }

            std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v402[16], v52);
            v402[18] = (v402[18] + 1);
            v53 = v385;
            v44 = v404;
            v42 = v407;
LABEL_604:
            *buf = v42;
            *&buf[8] = *(&v42 + 1) - v42;
            if (*(&v42 + 1) - v42 >= 2uLL)
            {
              *&buf[16] = 2;
              v388 = *v42;
              if (!*v42)
              {
LABEL_767:
                v385 = v53;
                v40 = 0;
                v5 = v389;
                goto LABEL_768;
              }

              v304 = 0;
              while (1)
              {
                if ((*&buf[16] + 2) > *&buf[8])
                {
                  v385 = v53;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type could not be read", "propertyTypeValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/PathLayerData.cpp", 207);
                  goto LABEL_789;
                }

                v305 = v4;
                v306 = *(*buf + *&buf[16]);
                v53 = v306 >= 7 ? v53 : *(*buf + *&buf[16]);
                v307 = *&buf[16] + 4;
                if ((*&buf[16] + 4) > *&buf[8])
                {
                  break;
                }

                *&buf[16] += 4;
                v308 = *v399;
                if (!*v399)
                {
                  goto LABEL_787;
                }

                v309 = *(*buf + v307 - 2);
                v310 = v399;
                do
                {
                  v311 = *(v308 + 28);
                  v82 = v311 >= v306;
                  v312 = v311 < v306;
                  if (v82)
                  {
                    v310 = v308;
                  }

                  v308 = *(v308 + 8 * v312);
                }

                while (v308);
                if (v310 == v399 || *(v310 + 7) > v306)
                {
LABEL_787:
                  v385 = v53;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type read from set that wasnt in the Property Info Chapter", "decoderMapIter != propertyContext.decoderMap.end()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/PathLayerData.cpp", 214);
LABEL_788:
                  v4 = v305;
                  v44 = v404;
                  goto LABEL_789;
                }

                v397 = v304;
                if (*(*buf + v307 - 2))
                {
                  while (1)
                  {
                    v313 = *&buf[16];
                    v314 = *&buf[16] + 2;
                    if ((*&buf[16] + 2) > *&buf[8])
                    {
                      break;
                    }

                    *&buf[16] += 2;
                    v315 = *(v310 + 32);
                    if (v306 <= 6 && v315 == (0x41008040401uLL >> (8 * v53)) && ((v316 = *(*buf + v313), v316 > 0x30) ? (v317 = 0) : (v317 = word_1B341DC50[v316]), v317 == v53))
                    {
                      switch(*(*buf + v313))
                      {
                        case 0:
                          v318 = v313 + 6;
                          if (v318 <= *&buf[8])
                          {
                            v319 = *(*buf + v314);
                            *&buf[16] = v318;
                            *(v45 + 35) = v319;
                          }

                          break;
                        case 1:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            v338 = *(*buf + v314);
                            *&buf[16] = v313 + 6;
                            if ((v313 + 10) <= *&buf[8])
                            {
                              v339 = *(*buf + v313 + 6);
                              *&buf[16] = v313 + 10;
                              *(v45 + 23) = v338;
                              *(v45 + 24) = v339;
                            }
                          }

                          break;
                        case 2:
                          v332 = v313 + 6;
                          if (v332 <= *&buf[8])
                          {
                            v333 = *(*buf + v314);
                            *&buf[16] = v332;
                            *(v45 + 33) = v333;
                          }

                          break;
                        case 3:
                          v347 = v313 + 6;
                          if (v347 <= *&buf[8])
                          {
                            v348 = *(*buf + v314);
                            *&buf[16] = v347;
                            *(v45 + 39) = v348;
                          }

                          break;
                        case 4:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            v349 = *(*buf + v314);
                            *&buf[16] = v313 + 6;
                            if ((v313 + 10) <= *&buf[8])
                            {
                              v350 = *(*buf + v313 + 6);
                              *&buf[16] = v313 + 10;
                              *(v45 + 37) = v349;
                              *(v45 + 38) = v350;
                            }
                          }

                          break;
                        case 5:
                          v334 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v335 = v313 + 4;
                            v314 = v334;
                          }

                          else
                          {
                            v335 = v313 + 3;
                          }

                          if (v335 <= *&buf[8])
                          {
                            *&buf[16] = v335;
                            v38 = *(*buf + v314);
                            v364 = v335 + 1;
                            v314 = v335;
                          }

                          else
                          {
                            v364 = v335;
                          }

                          if (v364 <= *&buf[8])
                          {
                            *&buf[16] = v364;
                            LOBYTE(v316) = *(*buf + v314);
                            v365 = v364 + 1;
                            v314 = v364;
                          }

                          else
                          {
                            v365 = v364;
                          }

                          if (v365 <= *&buf[8])
                          {
                            *&buf[16] = v365;
                            if (v334 <= *&buf[8] && v335 <= *&buf[8] && v364 <= *&buf[8])
                            {
                              v366 = *(*buf + v314);
                              *(v45 + 84) = v317;
                              *(v45 + 85) = v38;
                              *(v45 + 86) = v316;
                              *(v45 + 87) = v366;
                            }
                          }

                          break;
                        case 6:
                          v340 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v341 = v313 + 4;
                            v314 = v340;
                          }

                          else
                          {
                            v341 = v313 + 3;
                          }

                          if (v341 <= *&buf[8])
                          {
                            *&buf[16] = v341;
                            v38 = *(*buf + v314);
                            v367 = v341 + 1;
                            v314 = v341;
                          }

                          else
                          {
                            v367 = v341;
                          }

                          if (v367 <= *&buf[8])
                          {
                            *&buf[16] = v367;
                            LOBYTE(v316) = *(*buf + v314);
                            v368 = v367 + 1;
                            v314 = v367;
                          }

                          else
                          {
                            v368 = v367;
                          }

                          if (v368 <= *&buf[8])
                          {
                            *&buf[16] = v368;
                            if (v340 <= *&buf[8] && v341 <= *&buf[8] && v367 <= *&buf[8])
                            {
                              v369 = *(*buf + v314);
                              *(v45 + 125) = v317;
                              *(v45 + 126) = v38;
                              *(v45 + 127) = v316;
                              *(v45 + 128) = v369;
                            }
                          }

                          break;
                        case 7:
                          v342 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v343 = v313 + 4;
                            v314 = v342;
                          }

                          else
                          {
                            v343 = v313 + 3;
                          }

                          if (v343 <= *&buf[8])
                          {
                            *&buf[16] = v343;
                            v38 = *(*buf + v314);
                            v370 = v343 + 1;
                            v314 = v343;
                          }

                          else
                          {
                            v370 = v343;
                          }

                          if (v370 <= *&buf[8])
                          {
                            *&buf[16] = v370;
                            LOBYTE(v316) = *(*buf + v314);
                            v371 = v370 + 1;
                            v314 = v370;
                          }

                          else
                          {
                            v371 = v370;
                          }

                          if (v371 <= *&buf[8])
                          {
                            *&buf[16] = v371;
                            if (v342 <= *&buf[8] && v343 <= *&buf[8] && v370 <= *&buf[8])
                            {
                              v372 = *(*buf + v314);
                              *(v45 + 144) = v317;
                              *(v45 + 145) = v38;
                              *(v45 + 146) = v316;
                              *(v45 + 147) = v372;
                            }
                          }

                          break;
                        case 8:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 6;
                            v352 = *(*buf + v313 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v352) = *(v45 + 72);
                          }

                          *(v45 + 72) = v352;
                          break;
                        case 0xC:
                          v351 = v313 + 3;
                          if (v351 <= *&buf[8])
                          {
                            *&buf[16] = v351;
                            *(v45 + 73) = *(*buf + v314) != 0;
                          }

                          break;
                        case 0xD:
                          v327 = v313 + 6;
                          if (v327 <= *&buf[8])
                          {
                            v328 = *(*buf + v314);
                            *&buf[16] = v327;
                            *(v45 + 20) = v328;
                          }

                          break;
                        case 0xE:
                          v336 = v313 + 6;
                          if (v336 <= *&buf[8])
                          {
                            v337 = *(*buf + v314);
                            *&buf[16] = v336;
                            *(v45 + 41) = v337;
                          }

                          break;
                        case 0xF:
                          v330 = v313 + 3;
                          if (v330 <= *&buf[8])
                          {
                            *&buf[16] = v330;
                            *(v45 + 168) = *(*buf + v314) != 0;
                          }

                          break;
                        case 0x10:
                          v323 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v324 = v313 + 4;
                            v314 = v323;
                          }

                          else
                          {
                            v324 = v313 + 3;
                          }

                          if (v324 <= *&buf[8])
                          {
                            *&buf[16] = v324;
                            v38 = *(*buf + v314);
                            v358 = v324 + 1;
                            v314 = v324;
                          }

                          else
                          {
                            v358 = v324;
                          }

                          if (v358 <= *&buf[8])
                          {
                            *&buf[16] = v358;
                            LOBYTE(v316) = *(*buf + v314);
                            v359 = v358 + 1;
                            v314 = v358;
                          }

                          else
                          {
                            v359 = v358;
                          }

                          if (v359 <= *&buf[8])
                          {
                            *&buf[16] = v359;
                            if (v323 <= *&buf[8] && v324 <= *&buf[8] && v358 <= *&buf[8])
                            {
                              v360 = *(*buf + v314);
                              *(v45 + 116) = v317;
                              *(v45 + 117) = v38;
                              *(v45 + 118) = v316;
                              *(v45 + 119) = v360;
                            }
                          }

                          break;
                        case 0x11:
                          v344 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v345 = v313 + 4;
                            v314 = v344;
                          }

                          else
                          {
                            v345 = v313 + 3;
                          }

                          if (v345 <= *&buf[8])
                          {
                            *&buf[16] = v345;
                            v38 = *(*buf + v314);
                            v373 = v345 + 1;
                            v314 = v345;
                          }

                          else
                          {
                            v373 = v345;
                          }

                          if (v373 <= *&buf[8])
                          {
                            *&buf[16] = v373;
                            LOBYTE(v316) = *(*buf + v314);
                            v374 = v373 + 1;
                            v314 = v373;
                          }

                          else
                          {
                            v374 = v373;
                          }

                          if (v374 <= *&buf[8])
                          {
                            *&buf[16] = v374;
                            if (v344 <= *&buf[8] && v345 <= *&buf[8] && v373 <= *&buf[8])
                            {
                              v375 = *(*buf + v314);
                              *(v45 + 108) = v317;
                              *(v45 + 109) = v38;
                              *(v45 + 110) = v316;
                              *(v45 + 111) = v375;
                            }
                          }

                          break;
                        case 0x12:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 6;
                            v346 = *(*buf + v313 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v346) = *(v45 + 100);
                          }

                          *(v45 + 100) = v346;
                          break;
                        case 0x15:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 6;
                            v355 = *(*buf + v313 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v355) = *(v45 + 160);
                          }

                          *(v45 + 160) = v355;
                          break;
                        case 0x20:
                          v353 = v313 + 6;
                          if (v353 <= *&buf[8])
                          {
                            v354 = *(*buf + v314);
                            *&buf[16] = v353;
                            *(v45 + 30) = v354;
                          }

                          break;
                        case 0x21:
                          v320 = v313 + 6;
                          if (v320 <= *&buf[8])
                          {
                            v321 = *(*buf + v314);
                            *&buf[16] = v320;
                            *(v45 + 28) = v321;
                          }

                          break;
                        case 0x23:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 6;
                            v331 = *(*buf + v313 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v331) = *(v45 + 88);
                          }

                          *(v45 + 88) = v331;
                          break;
                        case 0x27:
                          v356 = v313 + 6;
                          if (v356 <= *&buf[8])
                          {
                            v357 = *(*buf + v314);
                            *&buf[16] = v356;
                            *(v45 + 26) = v357;
                          }

                          break;
                        case 0x28:
                          if ((v313 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 6;
                            v322 = *(*buf + v313 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v322) = *(v45 + 124);
                          }

                          *(v45 + 124) = v322;
                          break;
                        case 0x2B:
                          v329 = v313 + 3;
                          if (v329 <= *&buf[8])
                          {
                            *&buf[16] = v329;
                            *(v45 + 136) = *(*buf + v314) != 0;
                          }

                          break;
                        case 0x2F:
                          v325 = v313 + 3;
                          if ((v313 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v313 + 3;
                            LOBYTE(v317) = *(*buf + v314);
                            v326 = v313 + 4;
                            v314 = v325;
                          }

                          else
                          {
                            v326 = v313 + 3;
                          }

                          if (v326 <= *&buf[8])
                          {
                            *&buf[16] = v326;
                            v38 = *(*buf + v314);
                            v361 = v326 + 1;
                            v314 = v326;
                          }

                          else
                          {
                            v361 = v326;
                          }

                          if (v361 <= *&buf[8])
                          {
                            *&buf[16] = v361;
                            LOBYTE(v316) = *(*buf + v314);
                            v362 = v361 + 1;
                            v314 = v361;
                          }

                          else
                          {
                            v362 = v361;
                          }

                          if (v362 <= *&buf[8])
                          {
                            *&buf[16] = v362;
                            if (v325 <= *&buf[8] && v326 <= *&buf[8] && v361 <= *&buf[8])
                            {
                              v363 = *(*buf + v314);
                              *(v45 + 74) = v317;
                              *(v45 + 75) = v38;
                              *(v45 + 76) = v316;
                              *(v45 + 77) = v363;
                            }
                          }

                          break;
                        default:
                          v315 = (0x41008040401uLL >> (8 * v53));
                          goto LABEL_632;
                      }
                    }

                    else
                    {
LABEL_632:
                      grl::SkipStreamBytes(buf, v315);
                      *&v42 = v407;
                    }

                    if (!--v309)
                    {
                      goto LABEL_766;
                    }
                  }

                  v385 = v53;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/PathLayerData.cpp", 218);
                  goto LABEL_788;
                }

LABEL_766:
                v304 = v397 + 1;
                v4 = v305;
                v44 = v404;
                if (v397 + 1 == v388)
                {
                  goto LABEL_767;
                }
              }

              v385 = v53;
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Count could not be read", "numPropertiesForType.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/PathLayerData.cpp", 211);
              v4 = v305;
LABEL_789:
              v41 = v30;
            }

            else
            {
              v41 = v30;
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/PathLayerData.cpp", 203);
            }

            printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Path Layer could not be read", "internalLayers.pathLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", 129);
            goto LABEL_791;
          }

          LOWORD(v408) = 515;
          BYTE2(v408) = 1;
          std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::vector[abi:nn200100](buf, &v408, 3uLL);
          *(&v412 + 2) = 0;
          BYTE6(v412) = -1;
          v413 = 1119092736;
          v414 = 257;
          if (*v402 == 1)
          {
            std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::__vdeallocate((v402 + 1));
            *(v402 + 1) = *buf;
            v402[3] = *&buf[16];
            memset(buf, 0, 24);
            *(v402 + 40) = BYTE2(v412);
            *(v402 + 41) = *(&v412 + 3);
            *v383 = v413;
            *(v402 + 26) = v414;
          }

          else
          {
            *(v402 + 32) = buf[24];
            *(v402 + 1) = *buf;
            v402[3] = *&buf[16];
            memset(buf, 0, 24);
            *(v402 + 40) = 0;
            *(v402 + 41) = *(&v412 + 3);
            *v383 = v413;
            *(v402 + 26) = v414;
            *v402 = 1;
          }

          v44 = v404;
          std::vector<void const*,geo::allocator_adapter<void const*,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](buf);
          *&v42 = v407;
          *buf = v407;
          *&buf[8] = *(&v407 + 1) - v407;
          if (*(&v407 + 1) - v407 < 2uLL)
          {
            v41 = v30;
            printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ColorLayerData.cpp", 89);
LABEL_781:
            printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Color Layer could not be read", "internalLayers.colorLayer->decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", 133);
            goto LABEL_786;
          }

          *&buf[16] = 2;
          v393 = *v407;
          if (!*v407)
          {
            goto LABEL_267;
          }

          v72 = 0;
          while (1)
          {
            if ((*&buf[16] + 2) > *&buf[8])
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type could not be read", "propertyTypeValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ColorLayerData.cpp", 93);
              goto LABEL_780;
            }

            v73 = v4;
            v74 = *(*buf + *&buf[16]);
            if (v74 >= 7)
            {
              v75 = v392;
            }

            else
            {
              v75 = *(*buf + *&buf[16]);
            }

            v392 = v75;
            v76 = *&buf[16] + 4;
            if ((*&buf[16] + 4) > *&buf[8])
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Count could not be read", "numPropertiesForType.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ColorLayerData.cpp", 97);
              v4 = v73;
              goto LABEL_780;
            }

            v77 = v5;
            *&buf[16] += 4;
            v78 = *v399;
            if (!*v399)
            {
              goto LABEL_778;
            }

            v79 = *(*buf + v76 - 2);
            v80 = v399;
            do
            {
              v81 = *(v78 + 28);
              v82 = v81 >= v74;
              v83 = v81 < v74;
              if (v82)
              {
                v80 = v78;
              }

              v78 = *(v78 + 8 * v83);
            }

            while (v78);
            if (v80 == v399 || *(v80 + 7) > v74)
            {
LABEL_778:
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type read from set that wasnt in the Property Info Chapter", "decoderMapIter != propertyContext.decoderMap.end()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ColorLayerData.cpp", 100);
LABEL_779:
              v4 = v73;
              v5 = v77;
              v44 = v404;
LABEL_780:
              v41 = v30;
              goto LABEL_781;
            }

            if (*(*buf + v76 - 2))
            {
              break;
            }

LABEL_141:
            ++v72;
            v4 = v73;
            v5 = v77;
            v44 = v404;
            if (v72 == v393)
            {
              goto LABEL_267;
            }
          }

          v84 = (0x41008040401uLL >> (8 * v75));
          while (2)
          {
            v85 = *&buf[16];
            v86 = *&buf[16] + 2;
            if ((*&buf[16] + 2) > *&buf[8])
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ColorLayerData.cpp", 104);
              goto LABEL_779;
            }

            *&buf[16] += 2;
            v87 = *(v80 + 32);
            if (v74 > 6 || v87 != v84)
            {
              goto LABEL_111;
            }

            v88 = *(*buf + v85);
            v89 = v88 > 0x30 ? 0 : word_1B341DC50[*(*buf + v85)];
            v90 = v392;
            if (v89 != v392)
            {
              goto LABEL_111;
            }

            if (*(*buf + v85) <= 0xEu)
            {
              if (v88 == 5)
              {
                v98 = v85 + 3;
                if ((v85 + 3) <= *&buf[8])
                {
                  *&buf[16] = v85 + 3;
                  LOBYTE(v88) = *(*buf + v86);
                  v99 = v85 + 4;
                  v86 = v98;
                }

                else
                {
                  v99 = v85 + 3;
                }

                if (v99 <= *&buf[8])
                {
                  *&buf[16] = v99;
                  v90 = *(*buf + v86);
                  v100 = v99 + 1;
                  v86 = v99;
                }

                else
                {
                  v100 = v99;
                }

                if (v100 <= *&buf[8])
                {
                  *&buf[16] = v100;
                  v71 = *(*buf + v86);
                  v101 = v100 + 1;
                  v86 = v100;
                }

                else
                {
                  v101 = v100;
                }

                if (v101 <= *&buf[8])
                {
                  *&buf[16] = v101;
                  if (v98 <= *&buf[8] && v99 <= *&buf[8] && v100 <= *&buf[8])
                  {
                    v102 = *(*buf + v86);
                    *(v402 + 41) = v88;
                    *(v402 + 42) = v90;
                    *(v402 + 43) = v71;
                    *(v402 + 44) = v102;
                  }
                }
              }

              else
              {
                if (v88 != 8)
                {
                  goto LABEL_124;
                }

                if ((v85 + 6) <= *&buf[8])
                {
                  *&buf[16] = v85 + 6;
                  v94 = *(*buf + v85 + 6 - 4);
                  v93 = v402;
                }

                else
                {
                  v93 = v402;
                  LOBYTE(v94) = *(v402 + 40);
                }

                *(v93 + 40) = v94;
              }
            }

            else
            {
              switch(v88)
              {
                case 0xFu:
                  v95 = v85 + 3;
                  if (v95 <= *&buf[8])
                  {
                    *&buf[16] = v95;
                    *(v402 + 53) = *(*buf + v86) != 0;
                  }

                  break;
                case 0x27u:
                  v96 = v85 + 6;
                  if (v96 <= *&buf[8])
                  {
                    v97 = *(*buf + v86);
                    *&buf[16] = v96;
                    *v383 = v97;
                  }

                  break;
                case 0x28u:
                  if ((v85 + 6) <= *&buf[8])
                  {
                    *&buf[16] = v85 + 6;
                    v92 = *(*buf + v85 + 6 - 4);
                    v91 = v402;
                  }

                  else
                  {
                    v91 = v402;
                    LOBYTE(v92) = *(v402 + 52);
                  }

                  *(v91 + 52) = v92;
                  break;
                default:
LABEL_124:
                  v87 = v84;
LABEL_111:
                  grl::SkipStreamBytes(buf, v87);
                  *&v42 = v407;
                  break;
              }
            }

            if (!--v79)
            {
              goto LABEL_141;
            }

            continue;
          }
        }

        v42 = v407;
        switch(v30)
        {
          case 2:
            v54 = v402 + 12;
            while (1)
            {
              v55 = *v54;
              v56 = v54;
              if (!*v54)
              {
                break;
              }

              while (1)
              {
                v54 = v55;
                v57 = v55[16];
                if (v35 < v57)
                {
                  break;
                }

                if (v57 >= v35)
                {
                  v62 = v384;
                  v44 = v404;
                  goto LABEL_269;
                }

                v55 = v54[1];
                if (!v55)
                {
                  v56 = (v54 + 1);
                  goto LABEL_63;
                }
              }
            }

LABEL_63:
            v58 = v54;
            v59 = grl::zone_mallocator::instance(v37);
            geo::read_write_lock::read_lock((v59 + 32));
            v54 = malloc_type_zone_malloc(*v59, 0xC0uLL, 0x10A00404AA8A851uLL);
            atomic_fetch_add((v59 + 24), 1u);
            geo::read_write_lock::unlock((v59 + 32));
            *(v54 + 16) = v35;
            grl::codec::ImageLayerData::ImageLayerData((v54 + 5));
            *v54 = 0;
            v54[1] = 0;
            v54[2] = v58;
            *v56 = v54;
            v60 = *v402[11];
            v61 = v54;
            if (v60)
            {
              v402[11] = v60;
              v61 = *v56;
            }

            std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v402[12], v61);
            v402[14] = (v402[14] + 1);
            v62 = v384;
            v44 = v404;
            v42 = v407;
LABEL_269:
            *buf = v42;
            *&buf[8] = *(&v42 + 1) - v42;
            v41 = v30;
            if (*(&v42 + 1) - v42 >= 2uLL)
            {
              *&buf[16] = 2;
              v386 = *v42;
              if (!*v42)
              {
LABEL_430:
                v384 = v62;
                goto LABEL_602;
              }

              v154 = 0;
              while ((*&buf[16] + 2) <= *&buf[8])
              {
                v155 = v4;
                v156 = *(*buf + *&buf[16]);
                if (v156 >= 7)
                {
                  v62 = v62;
                }

                else
                {
                  v62 = *(*buf + *&buf[16]);
                }

                v157 = *&buf[16] + 4;
                if ((*&buf[16] + 4) > *&buf[8])
                {
                  v384 = v62;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Count could not be read", "numPropertiesForType.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ImageLayerData.cpp", 241);
                  v4 = v155;
                  goto LABEL_776;
                }

                *&buf[16] += 4;
                v158 = *v399;
                if (!*v399)
                {
                  goto LABEL_774;
                }

                v159 = *(*buf + v157 - 2);
                v160 = v399;
                do
                {
                  v161 = *(v158 + 28);
                  v82 = v161 >= v156;
                  v162 = v161 < v156;
                  if (v82)
                  {
                    v160 = v158;
                  }

                  v158 = *(v158 + 8 * v162);
                }

                while (v158);
                if (v160 == v399 || *(v160 + 7) > v156)
                {
LABEL_774:
                  v384 = v62;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type read from set that wasnt in the Property Info Chapter", "decoderMapIter != propertyContext.decoderMap.end()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ImageLayerData.cpp", 244);
                  goto LABEL_775;
                }

                v395 = v154;
                if (*(*buf + v157 - 2))
                {
                  while (1)
                  {
                    v163 = *&buf[8];
                    v164 = *&buf[16];
                    v165 = *&buf[16] + 2;
                    if ((*&buf[16] + 2) > *&buf[8])
                    {
                      break;
                    }

                    *&buf[16] += 2;
                    v166 = *(v160 + 32);
                    if (v156 <= 6 && v166 == (0x41008040401uLL >> (8 * v62)) && ((v167 = *buf, v168 = *(*buf + v164), v168 > 0x30) ? (v169 = 0) : (v169 = word_1B341DC50[*(*buf + v164)]), v169 == v62))
                    {
                      v170 = v168 - 1;
                      switch(*(*buf + v164))
                      {
                        case 1:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            v171 = *(*buf + v165);
                            *&buf[16] = v164 + 6;
                            if ((v164 + 10) <= *&buf[8])
                            {
                              v172 = *(*buf + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 20) = v171;
                              *(v54 + 21) = v172;
                            }
                          }

                          break;
                        case 2:
                          v195 = v164 + 6;
                          if (v195 <= *&buf[8])
                          {
                            v196 = *(*buf + v165);
                            *&buf[16] = v195;
                            *(v54 + 30) = v196;
                          }

                          break;
                        case 3:
                          v181 = v164 + 6;
                          if (v181 <= *&buf[8])
                          {
                            v182 = *(*buf + v165);
                            *&buf[16] = v181;
                            *(v54 + 43) = v182;
                          }

                          break;
                        case 4:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            v193 = *(*buf + v165);
                            *&buf[16] = v164 + 6;
                            if ((v164 + 10) <= *&buf[8])
                            {
                              v194 = *(*buf + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 41) = v193;
                              *(v54 + 42) = v194;
                            }
                          }

                          break;
                        case 5:
                          v183 = v164 + 3;
                          if ((v164 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 3;
                            LOBYTE(v168) = *(*buf + v165);
                            v184 = v164 + 4;
                            v165 = v183;
                          }

                          else
                          {
                            v184 = v164 + 3;
                          }

                          if (v184 <= *&buf[8])
                          {
                            *&buf[16] = v184;
                            v38 = *(*buf + v165);
                            v217 = v184 + 1;
                            v165 = v184;
                          }

                          else
                          {
                            v217 = v184;
                          }

                          if (v217 <= *&buf[8])
                          {
                            *&buf[16] = v217;
                            v170 = *(*buf + v165);
                            v218 = v217 + 1;
                            v165 = v217;
                          }

                          else
                          {
                            v218 = v217;
                          }

                          if (v218 <= *&buf[8])
                          {
                            *&buf[16] = v218;
                            if (v183 <= *&buf[8] && v184 <= *&buf[8] && v217 <= *&buf[8])
                            {
                              v219 = *(*buf + v165);
                              *(v54 + 74) = v168;
                              *(v54 + 75) = v38;
                              *(v54 + 76) = v170;
                              *(v54 + 77) = v219;
                            }
                          }

                          break;
                        case 6:
                          v190 = v164 + 3;
                          if ((v164 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 3;
                            LOBYTE(v168) = *(*buf + v165);
                            v191 = v164 + 4;
                            v165 = v190;
                          }

                          else
                          {
                            v191 = v164 + 3;
                          }

                          if (v191 <= *&buf[8])
                          {
                            *&buf[16] = v191;
                            v38 = *(*buf + v165);
                            v220 = v191 + 1;
                            v165 = v191;
                          }

                          else
                          {
                            v220 = v191;
                          }

                          if (v220 <= *&buf[8])
                          {
                            *&buf[16] = v220;
                            v170 = *(*buf + v165);
                            v221 = v220 + 1;
                            v165 = v220;
                          }

                          else
                          {
                            v221 = v220;
                          }

                          if (v221 <= *&buf[8])
                          {
                            *&buf[16] = v221;
                            if (v190 <= *&buf[8] && v191 <= *&buf[8] && v220 <= *&buf[8])
                            {
                              v222 = *(*buf + v165);
                              *(v54 + 113) = v168;
                              *(v54 + 114) = v38;
                              *(v54 + 115) = v170;
                              *(v54 + 116) = v222;
                            }
                          }

                          break;
                        case 7:
                          v199 = v164 + 3;
                          if ((v164 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 3;
                            LOBYTE(v168) = *(*buf + v165);
                            v200 = v164 + 4;
                            v165 = v199;
                          }

                          else
                          {
                            v200 = v164 + 3;
                          }

                          if (v200 <= *&buf[8])
                          {
                            *&buf[16] = v200;
                            v38 = *(*buf + v165);
                            v223 = v200 + 1;
                            v165 = v200;
                          }

                          else
                          {
                            v223 = v200;
                          }

                          if (v223 <= *&buf[8])
                          {
                            *&buf[16] = v223;
                            v170 = *(*buf + v165);
                            v224 = v223 + 1;
                            v165 = v223;
                          }

                          else
                          {
                            v224 = v223;
                          }

                          if (v224 <= *&buf[8])
                          {
                            *&buf[16] = v224;
                            if (v199 <= *&buf[8] && v200 <= *&buf[8] && v223 <= *&buf[8])
                            {
                              v225 = *(*buf + v165);
                              *(v54 + 160) = v168;
                              *(v54 + 161) = v38;
                              *(v54 + 162) = v170;
                              *(v54 + 163) = v225;
                            }
                          }

                          break;
                        case 8:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v201 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v201) = *(v54 + 72);
                          }

                          *(v54 + 72) = v201;
                          break;
                        case 9:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v207 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v207) = *(v54 + 152);
                          }

                          *(v54 + 152) = v207;
                          break;
                        case 0xA:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            v205 = *(*buf + v165);
                            *&buf[16] = v164 + 6;
                            if ((v164 + 10) <= *&buf[8])
                            {
                              v206 = *(*buf + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 31) = v205;
                              *(v54 + 32) = v206;
                            }
                          }

                          break;
                        case 0xB:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            v179 = *(*buf + v165);
                            *&buf[16] = v164 + 6;
                            if ((v164 + 10) <= *&buf[8])
                            {
                              v180 = *(*buf + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 45) = v179;
                              *(v54 + 46) = v180;
                            }
                          }

                          break;
                        case 0xC:
                          v192 = v164 + 3;
                          if (v192 <= *&buf[8])
                          {
                            *&buf[16] = v192;
                            *(v54 + 73) = *(*buf + v165) != 0;
                          }

                          break;
                        case 0xF:
                          v187 = v164 + 3;
                          if (v187 <= *&buf[8])
                          {
                            *&buf[16] = v187;
                            *(v54 + 188) = *(*buf + v165) != 0;
                          }

                          break;
                        case 0x10:
                          v175 = v164 + 3;
                          if ((v164 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 3;
                            LOBYTE(v168) = *(*buf + v165);
                            v176 = v164 + 4;
                            v165 = v175;
                          }

                          else
                          {
                            v176 = v164 + 3;
                          }

                          if (v176 <= *&buf[8])
                          {
                            *&buf[16] = v176;
                            v38 = *(*buf + v165);
                            v214 = v176 + 1;
                            v165 = v176;
                          }

                          else
                          {
                            v214 = v176;
                          }

                          if (v214 <= *&buf[8])
                          {
                            *&buf[16] = v214;
                            v170 = *(*buf + v165);
                            v215 = v214 + 1;
                            v165 = v214;
                          }

                          else
                          {
                            v215 = v214;
                          }

                          if (v215 <= *&buf[8])
                          {
                            *&buf[16] = v215;
                            if (v175 <= *&buf[8] && v176 <= *&buf[8] && v214 <= *&buf[8])
                            {
                              v216 = *(*buf + v165);
                              *(v54 + 104) = v168;
                              *(v54 + 105) = v38;
                              *(v54 + 106) = v170;
                              *(v54 + 107) = v216;
                            }
                          }

                          break;
                        case 0x11:
                          v202 = v164 + 3;
                          if ((v164 + 3) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 3;
                            LOBYTE(v168) = *(*buf + v165);
                            v203 = v164 + 4;
                            v165 = v202;
                          }

                          else
                          {
                            v203 = v164 + 3;
                          }

                          if (v203 <= *&buf[8])
                          {
                            *&buf[16] = v203;
                            v38 = *(*buf + v165);
                            v226 = v203 + 1;
                            v165 = v203;
                          }

                          else
                          {
                            v226 = v203;
                          }

                          if (v226 <= *&buf[8])
                          {
                            *&buf[16] = v226;
                            v170 = *(*buf + v165);
                            v227 = v226 + 1;
                            v165 = v226;
                          }

                          else
                          {
                            v227 = v226;
                          }

                          if (v227 <= *&buf[8])
                          {
                            *&buf[16] = v227;
                            if (v202 <= *&buf[8] && v203 <= *&buf[8] && v226 <= *&buf[8])
                            {
                              v228 = *(*buf + v165);
                              *(v54 + 96) = v168;
                              *(v54 + 97) = v38;
                              *(v54 + 98) = v170;
                              *(v54 + 99) = v228;
                            }
                          }

                          break;
                        case 0x12:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v204 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v204) = *(v54 + 88);
                          }

                          *(v54 + 88) = v204;
                          break;
                        case 0x20:
                          v210 = v164 + 6;
                          if (v210 <= *&buf[8])
                          {
                            v211 = *(*buf + v165);
                            *&buf[16] = v210;
                            *(v54 + 27) = v211;
                          }

                          break;
                        case 0x21:
                          v208 = v164 + 6;
                          if (v208 <= *&buf[8])
                          {
                            v209 = *(*buf + v165);
                            *&buf[16] = v208;
                            *(v54 + 25) = v209;
                          }

                          break;
                        case 0x23:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v173 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v173) = *(v54 + 78);
                          }

                          *(v54 + 78) = v173;
                          break;
                        case 0x24:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            v188 = *(*buf + v165);
                            *&buf[16] = v164 + 6;
                            if ((v164 + 10) <= *&buf[8])
                            {
                              v189 = *(*buf + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 33) = v188;
                              *(v54 + 34) = v189;
                            }
                          }

                          break;
                        case 0x27:
                          v212 = v164 + 6;
                          if (v212 <= *&buf[8])
                          {
                            v213 = *(*buf + v165);
                            *&buf[16] = v212;
                            *(v54 + 23) = v213;
                          }

                          break;
                        case 0x28:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v174 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v174) = *(v54 + 112);
                          }

                          *(v54 + 112) = v174;
                          break;
                        case 0x2A:
                          *(v54 + 189) = 1;
                          if (v164 + 6 <= v163)
                          {
                            v185 = *(v167 + v165);
                            *&buf[16] = v164 + 6;
                            if (v164 + 10 <= v163)
                            {
                              v186 = *(v167 + v164 + 6);
                              *&buf[16] = v164 + 10;
                              *(v54 + 36) = v185;
                              *(v54 + 37) = v186;
                            }
                          }

                          break;
                        case 0x2D:
                          v178 = v164 + 3;
                          if (v178 <= *&buf[8])
                          {
                            *&buf[16] = v178;
                            *(v54 + 176) = *(*buf + v165) != 0;
                          }

                          break;
                        case 0x2E:
                          v197 = v164 + 6;
                          if (v197 <= *&buf[8])
                          {
                            v198 = *(*buf + v165);
                            *&buf[16] = v197;
                            *(v54 + 39) = v198;
                          }

                          break;
                        case 0x30:
                          if ((v164 + 6) <= *&buf[8])
                          {
                            *&buf[16] = v164 + 6;
                            v177 = *(*buf + v164 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v177) = *(v54 + 140);
                          }

                          *(v54 + 140) = v177;
                          break;
                        default:
                          v166 = (0x41008040401uLL >> (8 * v62));
                          goto LABEL_298;
                      }
                    }

                    else
                    {
LABEL_298:
                      grl::SkipStreamBytes(buf, v166);
                      *&v42 = v407;
                    }

                    if (!--v159)
                    {
                      goto LABEL_429;
                    }
                  }

                  v384 = v62;
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ImageLayerData.cpp", 248);
LABEL_775:
                  v4 = v155;
                  v44 = v404;
LABEL_776:
                  v41 = v30;
                  goto LABEL_777;
                }

LABEL_429:
                v154 = v395 + 1;
                v4 = v155;
                v44 = v404;
                v41 = v30;
                if (v395 + 1 == v386)
                {
                  goto LABEL_430;
                }
              }

              v384 = v62;
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type could not be read", "propertyTypeValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ImageLayerData.cpp", 237);
            }

            else
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/ImageLayerData.cpp", 233);
            }

LABEL_777:
            printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Image Layer could not be read", "internalLayers.imageLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", 136);
LABEL_791:
            v40 = 1;
            v5 = v389;
            goto LABEL_795;
          case 3:
            v63 = (v402 + 8);
            while (1)
            {
              v64 = *v63;
              v65 = v63;
              if (!*v63)
              {
                break;
              }

              while (1)
              {
                v63 = v64;
                v66 = v64[16];
                if (v35 < v66)
                {
                  break;
                }

                if (v66 >= v35)
                {
                  v44 = v404;
                  goto LABEL_432;
                }

                v64 = *(v63 + 1);
                if (!v64)
                {
                  v65 = (v63 + 8);
                  goto LABEL_72;
                }
              }
            }

LABEL_72:
            v67 = v63;
            v68 = grl::zone_mallocator::instance(v37);
            geo::read_write_lock::read_lock((v68 + 32));
            v63 = malloc_type_zone_malloc(*v68, 0xE0uLL, 0x10B204009CF1EAFuLL);
            atomic_fetch_add((v68 + 24), 1u);
            geo::read_write_lock::unlock((v68 + 32));
            *(v63 + 16) = v35;
            grl::codec::TextLayerData::TextLayerData((v63 + 40));
            *v63 = 0;
            *(v63 + 1) = 0;
            *(v63 + 2) = v67;
            *v65 = v63;
            v69 = *v402[7];
            v70 = v63;
            if (v69)
            {
              v402[7] = v69;
              v70 = *v65;
            }

            std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v402[8], v70);
            v402[10] = (v402[10] + 1);
            v44 = v404;
            v42 = v407;
LABEL_432:
            v408 = v42;
            v409 = *(&v42 + 1) - v42;
            if (*(&v42 + 1) - v42 < 2uLL)
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/TextLayerData.cpp", 185);
LABEL_794:
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Text Layer could not be read", "internalLayers.textLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", 139);
              v40 = 1;
              v5 = v389;
              v41 = v30;
              goto LABEL_795;
            }

            v410 = 2;
            v41 = v30;
            v381 = *v42;
            if (*v42)
            {
              v229 = 0;
              while (1)
              {
                if (v410 + 2 > v409)
                {
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type could not be read", "propertyTypeValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/TextLayerData.cpp", 189);
                  goto LABEL_794;
                }

                v230 = *(v408 + v410);
                v231 = v230 >= 7 ? v390 : *(v408 + v410);
                v390 = v231;
                v232 = v410 + 4;
                if (v410 + 4 > v409)
                {
                  break;
                }

                v410 += 4;
                v233 = *v399;
                if (!*v399)
                {
                  goto LABEL_792;
                }

                v396 = *(v408 + v232 - 2);
                v234 = v399;
                do
                {
                  v235 = *(v233 + 28);
                  v82 = v235 >= v230;
                  v236 = v235 < v230;
                  if (v82)
                  {
                    v234 = v233;
                  }

                  v233 = *(v233 + 8 * v236);
                }

                while (v233);
                if (v234 == v399 || *(v234 + 7) > v230)
                {
LABEL_792:
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type read from set that wasnt in the Property Info Chapter", "decoderMapIter != propertyContext.decoderMap.end()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/TextLayerData.cpp", 196);
LABEL_793:
                  v44 = v404;
                  goto LABEL_794;
                }

                if (*(v408 + v232 - 2))
                {
                  v237 = 0;
                  v387 = (0x41008040401uLL >> (8 * v231));
                  while (1)
                  {
                    v238 = v409;
                    v239 = v410;
                    v240 = v410 + 2;
                    if (v409 < v410 + 2)
                    {
                      break;
                    }

                    v410 += 2;
                    v241 = *(v234 + 32);
                    if (v230 <= 6 && v241 == v387 && ((v242 = v408, v243 = *(v408 + v239), v243 > 0x30) ? (v244 = 0) : (v244 = word_1B341DC50[*(v408 + v239)]), v245 = v390, v244 == v390))
                    {
                      v246 = v243 - 2;
                      v247 = (v408 + v240);
                      switch(*(v408 + v239))
                      {
                        case 2:
                          if (v239 + 6 <= v409)
                          {
                            v248 = *v247;
                            v410 = v239 + 6;
                            *(v63 + 28) = v248;
                          }

                          goto LABEL_462;
                        case 3:
                          if (v239 + 6 <= v409)
                          {
                            v256 = *v247;
                            v410 = v239 + 6;
                            *(v63 + 44) = v256;
                          }

                          goto LABEL_462;
                        case 4:
                          v262 = v239 + 6;
                          if (v239 + 6 <= v409)
                          {
                            v263 = *v247;
                            v410 = v239 + 6;
                            v264 = v239 + 10;
                            if (v264 <= v409)
                            {
                              v265 = *(v408 + v262);
                              v410 = v264;
                              *(v63 + 42) = v263;
                              *(v63 + 43) = v265;
                            }
                          }

                          goto LABEL_462;
                        case 5:
                          v260 = v239 + 3;
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            LOBYTE(v243) = *v247;
                            v261 = v239 + 4;
                            v240 = v260;
                          }

                          else
                          {
                            v261 = v239 + 3;
                          }

                          if (v261 <= v409)
                          {
                            v410 = v261;
                            v245 = *(v408 + v240);
                            v289 = v261 + 1;
                            v240 = v261;
                          }

                          else
                          {
                            v289 = v261;
                          }

                          if (v289 <= v409)
                          {
                            v410 = v289;
                            v246 = *(v408 + v240);
                            v290 = v289 + 1;
                            v240 = v289;
                          }

                          else
                          {
                            v290 = v289;
                          }

                          if (v290 <= v409)
                          {
                            v410 = v290;
                            if (v260 <= v409 && v261 <= v409 && v289 <= v409)
                            {
                              v291 = *(v408 + v240);
                              v63[72] = v243;
                              v63[73] = v245;
                              v63[74] = v246;
                              v63[75] = v291;
                            }
                          }

                          goto LABEL_462;
                        case 6:
                          v252 = v239 + 3;
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            LOBYTE(v243) = *v247;
                            v253 = v239 + 4;
                            v240 = v252;
                          }

                          else
                          {
                            v253 = v239 + 3;
                          }

                          if (v253 <= v409)
                          {
                            v410 = v253;
                            v245 = *(v408 + v240);
                            v280 = v253 + 1;
                            v240 = v253;
                          }

                          else
                          {
                            v280 = v253;
                          }

                          if (v280 <= v409)
                          {
                            v410 = v280;
                            v246 = *(v408 + v240);
                            v281 = v280 + 1;
                            v240 = v280;
                          }

                          else
                          {
                            v281 = v280;
                          }

                          if (v281 <= v409)
                          {
                            v410 = v281;
                            if (v252 <= v409 && v253 <= v409 && v280 <= v409)
                            {
                              v282 = *(v408 + v240);
                              v63[108] = v243;
                              v63[109] = v245;
                              v63[110] = v246;
                              v63[111] = v282;
                            }
                          }

                          goto LABEL_462;
                        case 7:
                          v257 = v239 + 3;
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            LOBYTE(v243) = *v247;
                            v258 = v239 + 4;
                            v240 = v257;
                          }

                          else
                          {
                            v258 = v239 + 3;
                          }

                          if (v258 <= v409)
                          {
                            v410 = v258;
                            v245 = *(v408 + v240);
                            v286 = v258 + 1;
                            v240 = v258;
                          }

                          else
                          {
                            v286 = v258;
                          }

                          if (v286 <= v409)
                          {
                            v410 = v286;
                            v246 = *(v408 + v240);
                            v287 = v286 + 1;
                            v240 = v286;
                          }

                          else
                          {
                            v287 = v286;
                          }

                          if (v287 <= v409)
                          {
                            v410 = v287;
                            if (v257 <= v409 && v258 <= v409 && v286 <= v409)
                            {
                              v288 = *(v408 + v240);
                              v63[164] = v243;
                              v63[165] = v245;
                              v63[166] = v246;
                              v63[167] = v288;
                            }
                          }

                          goto LABEL_462;
                        case 0xA:
                          v266 = v239 + 6;
                          if (v239 + 6 <= v409)
                          {
                            v267 = *v247;
                            v410 = v239 + 6;
                            v268 = v239 + 10;
                            if (v268 <= v409)
                            {
                              v269 = *(v408 + v266);
                              v410 = v268;
                              *(v63 + 29) = v267;
                              *(v63 + 30) = v269;
                            }
                          }

                          goto LABEL_462;
                        case 0xF:
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            v63[216] = *v247 != 0;
                          }

                          goto LABEL_462;
                        case 0x16:
                          if (v239 + 6 <= v409)
                          {
                            v274 = *v247;
                            v410 = v239 + 6;
                            *(v63 + 26) = v274;
                          }

                          goto LABEL_462;
                        case 0x17:
                          if (v239 + 6 <= v409)
                          {
                            v273 = *v247;
                            v410 = v239 + 6;
                            *(v63 + 38) = v273;
                          }

                          goto LABEL_462;
                        case 0x18:
                          v380 = v26;
                          v249 = v4;
                          if (v409 == v240)
                          {
                            goto LABEL_600;
                          }

                          v251 = 0;
                          while (*(v247 + v251))
                          {
                            if (v409 - v240 == ++v251)
                            {
                              goto LABEL_600;
                            }
                          }

                          if (v251 > 0x7FFFFFFFFFFFFFF7)
                          {
                            goto LABEL_825;
                          }

                          if (v251 >= 0x17)
                          {
                            operator new();
                          }

                          buf[23] = v251;
                          if (v251)
                          {
                            memmove(buf, v247, v251);
                          }

                          *&v42 = v407;
                          buf[v251] = 0;
                          v410 += v251 + 1;
                          v298 = *buf;
                          v415[0] = *&buf[8];
                          *(v415 + 7) = *&buf[15];
                          v299 = buf[23];
                          if (v63[103] < 0)
                          {
                            operator delete(*(v63 + 10));
                            *&v42 = v407;
                          }

                          v300 = v415[0];
                          *(v63 + 10) = v298;
                          *(v63 + 11) = v300;
                          *(v63 + 95) = *(v415 + 7);
                          v63[103] = v299;
                          goto LABEL_600;
                        case 0x19:
                          v380 = v26;
                          v249 = v4;
                          if (v409 == v240)
                          {
                            goto LABEL_600;
                          }

                          v259 = 0;
                          while (*(v247 + v259))
                          {
                            if (v409 - v240 == ++v259)
                            {
                              goto LABEL_600;
                            }
                          }

                          if (v259 > 0x7FFFFFFFFFFFFFF7)
                          {
                            goto LABEL_825;
                          }

                          if (v259 >= 0x17)
                          {
                            operator new();
                          }

                          buf[23] = v259;
                          if (v259)
                          {
                            memmove(buf, v247, v259);
                          }

                          *&v42 = v407;
                          buf[v259] = 0;
                          v410 += v259 + 1;
                          v301 = *buf;
                          v415[0] = *&buf[8];
                          *(v415 + 7) = *&buf[15];
                          v302 = buf[23];
                          if (v63[151] < 0)
                          {
                            operator delete(*(v63 + 16));
                            *&v42 = v407;
                          }

                          v303 = v415[0];
                          *(v63 + 16) = v301;
                          *(v63 + 17) = v303;
                          *(v63 + 143) = *(v415 + 7);
                          v63[151] = v302;
                          goto LABEL_600;
                        case 0x1A:
                          v254 = v239 + 3;
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            LOBYTE(v243) = *v247;
                            v255 = v239 + 4;
                            v240 = v254;
                          }

                          else
                          {
                            v255 = v239 + 3;
                          }

                          if (v255 <= v409)
                          {
                            v410 = v255;
                            v245 = *(v408 + v240);
                            v283 = v255 + 1;
                            v240 = v255;
                          }

                          else
                          {
                            v283 = v255;
                          }

                          if (v283 <= v409)
                          {
                            v410 = v283;
                            v246 = *(v408 + v240);
                            v284 = v283 + 1;
                            v240 = v283;
                          }

                          else
                          {
                            v284 = v283;
                          }

                          if (v284 <= v409)
                          {
                            v410 = v284;
                            if (v254 <= v409 && v255 <= v409 && v283 <= v409)
                            {
                              v285 = *(v408 + v240);
                              v63[124] = v243;
                              v63[125] = v245;
                              v63[126] = v246;
                              v63[127] = v285;
                            }
                          }

                          goto LABEL_462;
                        case 0x1C:
                          v380 = v26;
                          v249 = v4;
                          if (v409 == v240)
                          {
                            goto LABEL_600;
                          }

                          v250 = 0;
                          break;
                        case 0x1D:
                          if (v239 + 6 <= v409)
                          {
                            v270 = *v247;
                            v410 = v239 + 6;
                            *(v63 + 40) = v270;
                          }

                          goto LABEL_462;
                        case 0x1E:
                          v271 = v239 + 3;
                          if (v239 + 3 <= v409)
                          {
                            v410 = v239 + 3;
                            LOBYTE(v243) = *v247;
                            v272 = v239 + 4;
                            v240 = v271;
                          }

                          else
                          {
                            v272 = v239 + 3;
                          }

                          if (v272 <= v409)
                          {
                            v410 = v272;
                            v245 = *(v408 + v240);
                            v292 = v272 + 1;
                            v240 = v272;
                          }

                          else
                          {
                            v292 = v272;
                          }

                          if (v292 <= v409)
                          {
                            v410 = v292;
                            v246 = *(v408 + v240);
                            v293 = v292 + 1;
                            v240 = v292;
                          }

                          else
                          {
                            v293 = v292;
                          }

                          if (v293 <= v409)
                          {
                            v410 = v293;
                            if (v271 <= v409 && v272 <= v409 && v292 <= v409)
                            {
                              v294 = *(v408 + v240);
                              v63[156] = v243;
                              v63[157] = v245;
                              v63[158] = v246;
                              v63[159] = v294;
                            }
                          }

                          goto LABEL_462;
                        case 0x1F:
                          v63[217] = 1;
                          v276 = v239 + 6;
                          if (v239 + 6 <= v238)
                          {
                            v277 = *v247;
                            v410 = v239 + 6;
                            v278 = v239 + 10;
                            if (v278 <= v238)
                            {
                              v279 = *(v242 + v276);
                              v410 = v278;
                              *(v63 + 52) = v277;
                              *(v63 + 53) = v279;
                            }
                          }

                          goto LABEL_462;
                        case 0x23:
                          if (v239 + 6 <= v409)
                          {
                            v410 = v239 + 6;
                            v275 = *(v408 + v239 + 6 - 4);
                          }

                          else
                          {
                            LOBYTE(v275) = v63[76];
                          }

                          v63[76] = v275;
                          goto LABEL_462;
                        default:
                          v241 = v387;
                          goto LABEL_461;
                      }

                      while (*(v247 + v250))
                      {
                        if (v409 - v240 == ++v250)
                        {
                          goto LABEL_600;
                        }
                      }

                      if (v250 > 0x7FFFFFFFFFFFFFF7)
                      {
LABEL_825:
                        std::__throw_bad_array_new_length[abi:nn200100]();
                      }

                      if (v250 >= 0x17)
                      {
                        operator new();
                      }

                      buf[23] = v250;
                      if (v250)
                      {
                        memmove(buf, v247, v250);
                      }

                      *&v42 = v407;
                      buf[v250] = 0;
                      v410 += v250 + 1;
                      v295 = *buf;
                      v415[0] = *&buf[8];
                      *(v415 + 7) = *&buf[15];
                      v296 = buf[23];
                      if (v63[207] < 0)
                      {
                        operator delete(*(v63 + 23));
                        *&v42 = v407;
                      }

                      v297 = v415[0];
                      *(v63 + 23) = v295;
                      *(v63 + 24) = v297;
                      *(v63 + 199) = *(v415 + 7);
                      v63[207] = v296;
LABEL_600:
                      v4 = v249;
                      v26 = v380;
                      v41 = v30;
                    }

                    else
                    {
LABEL_461:
                      grl::SkipStreamBytes(&v408, v241);
                      *&v42 = v407;
                    }

LABEL_462:
                    if (++v237 == v396)
                    {
                      goto LABEL_601;
                    }
                  }

                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/TextLayerData.cpp", 200);
                  goto LABEL_793;
                }

LABEL_601:
                ++v229;
                v44 = v404;
                if (v229 == v381)
                {
                  goto LABEL_602;
                }
              }

              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Count could not be read", "numPropertiesForType.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/TextLayerData.cpp", 193);
              goto LABEL_794;
            }

LABEL_602:
            v40 = 0;
            v5 = v389;
            goto LABEL_796;
          case 4:
            *buf = 0xFFFFFFFF00000000;
            *&buf[8] = 0xFF000000FF000000;
            *&buf[16] = 0;
            *&buf[20] = 0xFF000000FFLL;
            buf[28] = -1;
            *(&v412 + 2) = 1065353216;
            HIWORD(v412) = 0;
            v43 = *(v402 + 152);
            *(v402 + 156) = 0xFFFFFFFF00000000;
            v44 = v404;
            if (v43 == 1)
            {
              *(v402 + 164) = *&buf[8];
              *(v402 + 172) = 0;
              *(v402 + 173) = *&buf[17];
              *(v402 + 181) = *&buf[25];
              *v382 = *(&v412 + 2);
              *(v402 + 96) = HIWORD(v412);
            }

            else
            {
              *(v402 + 164) = 0xFF000000FF000000;
              *(v402 + 172) = 0;
              *(v402 + 173) = *&buf[17];
              *(v402 + 177) = -16777216;
              *(v402 + 181) = *&buf[25];
              *v382 = *(&v412 + 2);
              *(v402 + 96) = HIWORD(v412);
              *(v402 + 152) = 1;
            }

            *buf = v407;
            *&buf[8] = *(&v407 + 1) - v407;
            if (*(&v407 + 1) - v407 < 2uLL)
            {
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/InfoLayerData.cpp", 148);
              goto LABEL_785;
            }

            *&buf[16] = 2;
            v394 = *v407;
            if (*v407)
            {
              v103 = 0;
              while (1)
              {
                if ((*&buf[16] + 2) > *&buf[8])
                {
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type could not be read", "propertyTypeValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/InfoLayerData.cpp", 152);
                  goto LABEL_784;
                }

                v104 = v4;
                v105 = *(*buf + *&buf[16]);
                if (v105 >= 7)
                {
                  v106 = v391;
                }

                else
                {
                  v106 = *(*buf + *&buf[16]);
                }

                v391 = v106;
                v107 = *&buf[16] + 4;
                if ((*&buf[16] + 4) > *&buf[8])
                {
                  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Count could not be read", "numPropertiesForType.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/InfoLayerData.cpp", 156);
                  v4 = v104;
                  goto LABEL_784;
                }

                v108 = v5;
                *&buf[16] += 4;
                v109 = *v399;
                if (!*v399)
                {
                  break;
                }

                v110 = *(*buf + v107 - 2);
                v111 = v399;
                do
                {
                  v112 = *(v109 + 28);
                  v82 = v112 >= v105;
                  v113 = v112 < v105;
                  if (v82)
                  {
                    v111 = v109;
                  }

                  v109 = *(v109 + 8 * v113);
                }

                while (v109);
                if (v111 == v399 || *(v111 + 7) > v105)
                {
                  break;
                }

                if (*(*buf + v107 - 2))
                {
                  v114 = (0x41008040401uLL >> (8 * v106));
                  do
                  {
                    v115 = *&buf[8];
                    v116 = *&buf[16];
                    v117 = *&buf[16] + 2;
                    if ((*&buf[16] + 2) > *&buf[8])
                    {
                      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/InfoLayerData.cpp", 163);
                      goto LABEL_783;
                    }

                    *&buf[16] += 2;
                    v118 = *(v111 + 32);
                    if (v105 <= 6 && v118 == v114)
                    {
                      v119 = *buf;
                      v120 = *(*buf + v116);
                      v121 = v120 > 0x30 ? 0 : word_1B341DC50[*(*buf + v116)];
                      v122 = v391;
                      if (v121 == v391)
                      {
                        if (*(*buf + v116) <= 0x21u)
                        {
                          if (*(*buf + v116) > 0x13u)
                          {
                            if (v120 == 20)
                            {
                              if ((v116 + 6) <= *&buf[8])
                              {
                                *&buf[16] = v116 + 6;
                                *(v402 + 39) = *(*buf + v116 + 6 - 4);
                              }

                              goto LABEL_178;
                            }

                            if (v120 == 27)
                            {
                              v125 = v402;
                              *(v402 + 192) = 1;
                              v126 = v116 + 3;
                              if (v116 + 3 <= v115)
                              {
                                *&buf[16] = v116 + 3;
                                v125 = *(v119 + v117);
                                v127 = v116 + 4;
                                v117 = v126;
                              }

                              else
                              {
                                v127 = v116 + 3;
                              }

                              if (v127 <= v115)
                              {
                                *&buf[16] = v127;
                                v122 = *(v119 + v117);
                                v139 = v127 + 1;
                                v117 = v127;
                              }

                              else
                              {
                                v139 = v127;
                              }

                              if (v139 <= v115)
                              {
                                *&buf[16] = v139;
                                v39 = *(v119 + v117);
                                v140 = v139 + 1;
                                v117 = v139;
                              }

                              else
                              {
                                v140 = v139;
                              }

                              if (v140 <= v115)
                              {
                                *&buf[16] = v140;
                                if (v126 <= v115 && v127 <= v115 && v139 <= v115)
                                {
                                  v141 = *(v119 + v117);
                                  *(v402 + 168) = v125;
                                  *(v402 + 169) = v122;
                                  *(v402 + 170) = v39;
                                  *(v402 + 171) = v141;
                                }
                              }

                              goto LABEL_178;
                            }
                          }

                          else
                          {
                            if (!*(*buf + v116))
                            {
                              v130 = v116 + 6;
                              if (v130 <= *&buf[8])
                              {
                                v131 = *(*buf + v117);
                                *&buf[16] = v130;
                                *v382 = v131;
                              }

                              goto LABEL_178;
                            }

                            if (v120 == 19)
                            {
                              if ((v116 + 6) <= *&buf[8])
                              {
                                *&buf[16] = v116 + 6;
                                *(v402 + 40) = *(*buf + v116 + 6 - 4);
                              }

                              goto LABEL_178;
                            }
                          }
                        }

                        else if (*(*buf + v116) <= 0x25u)
                        {
                          if (v120 == 34)
                          {
                            v134 = v116 + 3;
                            if ((v116 + 3) <= *&buf[8])
                            {
                              *&buf[16] = v116 + 3;
                              LOBYTE(v120) = *(*buf + v117);
                              v135 = v116 + 4;
                              v117 = v134;
                            }

                            else
                            {
                              v135 = v116 + 3;
                            }

                            if (v135 <= *&buf[8])
                            {
                              *&buf[16] = v135;
                              v122 = *(*buf + v117);
                              v145 = v135 + 1;
                              v117 = v135;
                            }

                            else
                            {
                              v145 = v135;
                            }

                            if (v145 <= *&buf[8])
                            {
                              *&buf[16] = v145;
                              v39 = *(*buf + v117);
                              v146 = v145 + 1;
                              v117 = v145;
                            }

                            else
                            {
                              v146 = v145;
                            }

                            if (v146 <= *&buf[8])
                            {
                              *&buf[16] = v146;
                              if (v134 <= *&buf[8] && v135 <= *&buf[8] && v145 <= *&buf[8])
                              {
                                v147 = *(*buf + v117);
                                *(v402 + 164) = v120;
                                *(v402 + 165) = v122;
                                *(v402 + 166) = v39;
                                *(v402 + 167) = v147;
                              }
                            }

                            goto LABEL_178;
                          }

                          if (v120 == 37)
                          {
                            if ((v116 + 6) <= *&buf[8])
                            {
                              *&buf[16] = v116 + 6;
                              v129 = *(*buf + v116 + 6 - 4);
                              v128 = v402;
                            }

                            else
                            {
                              v128 = v402;
                              LOBYTE(v129) = *(v402 + 172);
                            }

                            *(v128 + 172) = v129;
                            goto LABEL_178;
                          }
                        }

                        else
                        {
                          switch(v120)
                          {
                            case '&':
                              v132 = v116 + 3;
                              if ((v116 + 3) <= *&buf[8])
                              {
                                *&buf[16] = v116 + 3;
                                LOBYTE(v120) = *(*buf + v117);
                                v133 = v116 + 4;
                                v117 = v132;
                              }

                              else
                              {
                                v133 = v116 + 3;
                              }

                              if (v133 <= *&buf[8])
                              {
                                *&buf[16] = v133;
                                v122 = *(*buf + v117);
                                v142 = v133 + 1;
                                v117 = v133;
                              }

                              else
                              {
                                v142 = v133;
                              }

                              if (v142 <= *&buf[8])
                              {
                                *&buf[16] = v142;
                                v39 = *(*buf + v117);
                                v143 = v142 + 1;
                                v117 = v142;
                              }

                              else
                              {
                                v143 = v142;
                              }

                              if (v143 <= *&buf[8])
                              {
                                *&buf[16] = v143;
                                if (v132 <= *&buf[8] && v133 <= *&buf[8] && v142 <= *&buf[8])
                                {
                                  v144 = *(*buf + v117);
                                  *(v402 + 181) = v120;
                                  *(v402 + 182) = v122;
                                  *(v402 + 183) = v39;
                                  *(v402 + 184) = v144;
                                }
                              }

                              goto LABEL_178;
                            case ')':
                              v136 = v402;
                              *(v402 + 193) = 1;
                              v137 = v116 + 3;
                              if (v116 + 3 <= v115)
                              {
                                *&buf[16] = v116 + 3;
                                v136 = *(v119 + v117);
                                v138 = v116 + 4;
                                v117 = v137;
                              }

                              else
                              {
                                v138 = v116 + 3;
                              }

                              if (v138 <= v115)
                              {
                                *&buf[16] = v138;
                                v122 = *(v119 + v117);
                                v151 = v138 + 1;
                                v117 = v138;
                              }

                              else
                              {
                                v151 = v138;
                              }

                              if (v151 <= v115)
                              {
                                *&buf[16] = v151;
                                v39 = *(v119 + v117);
                                v152 = v151 + 1;
                                v117 = v151;
                              }

                              else
                              {
                                v152 = v151;
                              }

                              if (v152 <= v115)
                              {
                                *&buf[16] = v152;
                                if (v137 <= v115 && v138 <= v115 && v151 <= v115)
                                {
                                  v153 = *(v119 + v117);
                                  *(v402 + 173) = v136;
                                  *(v402 + 174) = v122;
                                  *(v402 + 175) = v39;
                                  *(v402 + 176) = v153;
                                }
                              }

                              goto LABEL_178;
                            case ',':
                              v123 = v116 + 3;
                              if ((v116 + 3) <= *&buf[8])
                              {
                                *&buf[16] = v116 + 3;
                                LOBYTE(v120) = *(*buf + v117);
                                v124 = v116 + 4;
                                v117 = v123;
                              }

                              else
                              {
                                v124 = v116 + 3;
                              }

                              if (v124 <= *&buf[8])
                              {
                                *&buf[16] = v124;
                                v122 = *(*buf + v117);
                                v148 = v124 + 1;
                                v117 = v124;
                              }

                              else
                              {
                                v148 = v124;
                              }

                              if (v148 <= *&buf[8])
                              {
                                *&buf[16] = v148;
                                v39 = *(*buf + v117);
                                v149 = v148 + 1;
                                v117 = v148;
                              }

                              else
                              {
                                v149 = v148;
                              }

                              if (v149 <= *&buf[8])
                              {
                                *&buf[16] = v149;
                                if (v123 <= *&buf[8] && v124 <= *&buf[8] && v148 <= *&buf[8])
                                {
                                  v150 = *(*buf + v117);
                                  *(v402 + 177) = v120;
                                  *(v402 + 178) = v122;
                                  *(v402 + 179) = v39;
                                  *(v402 + 180) = v150;
                                }
                              }

                              goto LABEL_178;
                          }
                        }

                        v118 = v114;
                      }
                    }

                    grl::SkipStreamBytes(buf, v118);
                    *&v42 = v407;
LABEL_178:
                    --v110;
                  }

                  while (v110);
                }

                ++v103;
                v4 = v104;
                v5 = v108;
                v44 = v404;
                if (v103 == v394)
                {
                  goto LABEL_267;
                }
              }

              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type read from set that wasnt in the Property Info Chapter", "decoderMapIter != propertyContext.decoderMap.end()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/Generated/InfoLayerData.cpp", 159);
LABEL_783:
              v4 = v104;
              v5 = v108;
              v44 = v404;
LABEL_784:
              v41 = v30;
LABEL_785:
              printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Information Layer could not be read", "internalLayers.infoLayer->decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", 143);
LABEL_786:
              v40 = 1;
LABEL_795:
              *&v42 = v407;
LABEL_796:
              if (v25 > v4)
              {
                goto LABEL_799;
              }

              goto LABEL_797;
            }

LABEL_267:
            v40 = 0;
LABEL_768:
            v41 = v30;
            goto LABEL_796;
        }

        v44 = v404;
      }

LABEL_797:
      if (v42)
      {
        operator delete(v42);
      }

LABEL_799:
      if (v40 && v40 != 19)
      {
        return 0;
      }

      v28 = v44 + 1;
      result = 1;
      v27 = v41;
      if (v28 >= v26)
      {
        return result;
      }
    }

    v377 = 114;
    v378 = "layerIndex.has_value()";
    v379 = "Layer Index could not be read";
LABEL_824:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v379, v378, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconRenderItem.cpp", v377);
    return 0;
  }

  return 1;
}

void std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::__vdeallocate(grl::zone_mallocator *a1)
{
  v1 = *a1;
  if (*a1)
  {
    *(a1 + 1) = v1;
    v3 = grl::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<ggl::ShaderLibrary::ComputeShaderEntry>(v3, v1);
    *a1 = 0;
    *(a1 + 1) = 0;
    *(a1 + 2) = 0;
  }
}

uint64_t std::__function::__func<grl::codec::IconRenderItem::requiresFonts(std::set<std::string,std::less<std::string>,geo::allocator_adapter<std::string,grl::zone_mallocator>> &,grl::IconModifiers const&)::$_0,std::allocator<grl::codec::IconRenderItem::requiresFonts(std::set<std::string,std::less<std::string>,geo::allocator_adapter<std::string,grl::zone_mallocator>> &,grl::IconModifiers const&)::$_0>,void ()(unsigned short,grl::codec::TextLayerData const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A5F4E8;
  a2[1] = v2;
  return result;
}

void std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::__assign_with_size[abi:nn200100]<grl::LayerStyle const*,grl::LayerStyle const*>(void **a1, char *__src, char *a3, unint64_t a4)
{
  v6 = __src;
  v8 = *a1;
  if (a1[2] - *a1 >= a4)
  {
    v14 = a1[1];
    v15 = v14 - v8;
    if (v14 - v8 >= a4)
    {
      v19 = a3 - __src;
      if (v19)
      {
        memmove(*a1, __src, v19);
      }

      v12 = &v8[v19];
    }

    else
    {
      v16 = &__src[v15];
      if (v14 != v8)
      {
        memmove(*a1, __src, v15);
        v14 = a1[1];
      }

      v17 = v14;
      if (v16 != a3)
      {
        v17 = v14;
        do
        {
          v18 = *v16++;
          *v17++ = v18;
        }

        while (v16 != a3);
      }

      v12 = v17;
    }
  }

  else
  {
    std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::__vdeallocate(a1);
    v9 = a1[2] - *a1;
    v10 = 2 * v9;
    if (2 * v9 <= a4)
    {
      v10 = a4;
    }

    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v10;
    }

    std::vector<grl::LayerStyle,geo::allocator_adapter<grl::LayerStyle,grl::zone_mallocator>>::__vallocate[abi:nn200100](a1, v11);
    v12 = a1[1];
    while (v6 != a3)
    {
      v13 = *v6++;
      *v12++ = v13;
    }
  }

  a1[1] = v12;
}

uint64_t geo::Color<float,4,(geo::ColorSpace)2>::Color<(geo::ColorSpace)5,int,void>(uint64_t a1, float *a2)
{
  v3 = geo::toLinear<float,4,(geo::ColorSpace)5,int,void>::operator()(gm::Matrix<float,4,1> const&)const::{lambda(gm::Matrix<float,4,1> const&)#1}::operator()(a2);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  if (v3 >= 0.0031308)
  {
    v10 = (powf(v3, 0.41667) * 1.055) + -0.055;
  }

  else
  {
    v10 = v3 * 12.92;
  }

  if (v5 >= 0.0031308)
  {
    v11 = (powf(v5, 0.41667) * 1.055) + -0.055;
  }

  else
  {
    v11 = v5 * 12.92;
  }

  if (v7 >= 0.0031308)
  {
    v12 = (powf(v7, 0.41667) * 1.055) + -0.055;
  }

  else
  {
    v12 = v7 * 12.92;
  }

  *a1 = v10;
  *(a1 + 4) = v11;
  *(a1 + 8) = v12;
  *(a1 + 12) = v9;
  return a1;
}

void grl::codec::ResourcePack::compressData(uint64_t a1, uint64_t a2)
{
  v14.next_in = *a2;
  v14.avail_in = *(a2 + 8) - LODWORD(v14.next_in);
  v14.total_out = 0;
  memset(&v14.zalloc, 0, 24);
  v4 = deflateInit_(&v14, -1, "1.2.12", 112);
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  *a1 = 0;
  if (!v4)
  {
    v5 = *(a2 + 8) - *a2;
    if (v5 >> 3 <= 0x200)
    {
      v6 = 512;
    }

    else
    {
      v6 = v5 >> 3;
    }

    v7 = v5 >> 1;
    if (v7 <= 0x200)
    {
      v8 = 512;
    }

    else
    {
      v8 = v7;
    }

    std::vector<unsigned char>::__append(a1, v8);
    v9 = *a1;
    v10 = *(a1 + 8);
    do
    {
      total_out = v14.total_out;
      v12 = v10 - v9;
      if (v14.total_out >= v10 - v9)
      {
        v13 = v12 + v6;
        if (v12 >= v12 + v6)
        {
          if (v12 > v12 + v6)
          {
            v10 = &v9[v13];
            *(a1 + 8) = &v9[v13];
          }
        }

        else
        {
          std::vector<unsigned char>::__append(a1, v6);
          total_out = v14.total_out;
          v9 = *a1;
          v10 = *(a1 + 8);
        }
      }

      v14.next_out = &v9[total_out];
      v14.avail_out = v10 - v9 - total_out;
      deflate(&v14, 4);
    }

    while (!v14.avail_out);
    deflateEnd(&v14);
    if (v14.total_out <= v10 - v9)
    {
      if (v14.total_out < v10 - v9)
      {
        *(a1 + 8) = &v9[v14.total_out];
      }
    }

    else
    {
      std::vector<unsigned char>::__append(a1, v14.total_out - (v10 - v9));
    }
  }
}

void grl::codec::ResourcePack::decompressData(uint64_t a1, Bytef *a2, Bytef *a3, char *a4)
{
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 16) = 0;
  if (a3 != a2)
  {
    v12 = v4;
    v13 = v5;
    v11.next_in = a2;
    v11.avail_in = a3 - a2;
    v11.zalloc = 0;
    v11.zfree = 0;
    v11.total_out = 0;
    if (!inflateInit_(&v11, "1.2.12", 112))
    {
      if (a4)
      {
        std::vector<unsigned char>::__append(a1, a4);
        a4 = *a1;
        v8 = *(a1 + 8);
      }

      else
      {
        v8 = 0;
      }

      v9 = 0;
      v10 = v8 - a4;
      while (!v9)
      {
        v11.next_out = &a4[v11.total_out];
        v11.avail_out = v10 - LODWORD(v11.total_out);
        v9 = inflate(&v11, 2);
        if (v9 >= 2)
        {
          goto LABEL_11;
        }
      }

      if (inflateEnd(&v11))
      {
LABEL_11:
        if (v8 != a4)
        {
          *(a1 + 8) = a4;
        }

        return;
      }

      if (v11.total_out <= v10)
      {
        if (v11.total_out < v10)
        {
          *(a1 + 8) = &a4[v11.total_out];
        }
      }

      else
      {
        std::vector<unsigned char>::__append(a1, v11.total_out - v10);
      }
    }
  }
}

uint64_t grl::codec::ResourcePack::fileName(grl::codec::ResourcePack *this, uint64_t a2)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v17);
  v4 = *(a2 + 31);
  if (v4 >= 0)
  {
    v5 = a2 + 8;
  }

  else
  {
    v5 = *(a2 + 8);
  }

  if (v4 >= 0)
  {
    v6 = *(a2 + 31);
  }

  else
  {
    v6 = *(a2 + 16);
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v17, v5, v6);
  v7 = MEMORY[0x1E69E54E8];
  if (*(a2 + 32) != 1.0)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v17, "@", 1);
    std::ostringstream::basic_ostringstream[abi:nn200100](&v22);
    v8 = v22;
    *(&v24[0].__locale_ + *(v22 - 24)) = 0;
    *(&v22 + *(v8 - 24) + 8) = *(&v22 + *(v8 - 24) + 8) & 0xFFFFFEFB | 4;
    v9 = std::ostream::operator<<();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, "x", 1);
    std::ostringstream::str[abi:nn200100](v15, &v22);
    v22 = *v7;
    *(&v22 + *(v22 - 24)) = v7[3];
    v23 = MEMORY[0x1E69E5548] + 16;
    if (v25 < 0)
    {
      operator delete(v24[7].__locale_);
    }

    v23 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v24);
    std::ostream::~ostream();
    MEMORY[0x1B8C620C0](&v26);
    if ((v16 & 0x80u) == 0)
    {
      v10 = v15;
    }

    else
    {
      v10 = v15[0];
    }

    if ((v16 & 0x80u) == 0)
    {
      v11 = v16;
    }

    else
    {
      v11 = v15[1];
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v17, v10, v11);
    if (v16 < 0)
    {
      operator delete(v15[0]);
    }
  }

  std::ostringstream::str[abi:nn200100](this, &v17);
  v12 = *(this + 23);
  if ((v12 & 0x80u) == 0)
  {
    v13 = this;
  }

  else
  {
    v13 = *this;
  }

  if ((v12 & 0x80u) != 0)
  {
    v12 = *(this + 1);
  }

  for (; v12; --v12)
  {
    if (*v13 == 32)
    {
      *v13 = 95;
    }

    v13 = (v13 + 1);
  }

  v17 = *v7;
  *(&v17 + *(v17 - 24)) = v7[3];
  v18 = MEMORY[0x1E69E5548] + 16;
  if (v20 < 0)
  {
    operator delete(v19[7].__locale_);
  }

  v18 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v19);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v21);
}

void grl::codec::ResourcePack::encodeHeaderAndData(uint64_t a1, uint64_t a2, void *a3)
{
  v57[3] = *MEMORY[0x1E69E9840];
  *a1 = 0;
  *(a1 + 8) = 0;
  *(a1 + 24) = 0;
  *(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100]((a1 + 32));
  std::string::basic_string[abi:nn200100]<0>(&__p, "header");
  v56 = off_1E7B58018;
  geo::obitstream::markDebugLog(a1, &__p, &v56);
  if (SHIBYTE(v49) < 0)
  {
    operator delete(__p);
  }

  geo::obitstream::appendBytes(a1, *a2, *(a2 + 8) - *a2);
  LOWORD(__p) = a3[3];
  geo::obitstream::appendBytes(a1, &__p, 2);
  v6 = a3[3];
  v57[2] = 0;
  v56 = v57;
  v57[0] = 0;
  __p = 0;
  v48 = 0;
  v50 = 0;
  v49 = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](&v51);
  v7 = *a3;
  if (*a3 != a3 + 1)
  {
    v8 = 10 * v6 + 66;
    while (1)
    {
      if (*(v7 + 48) != 1)
      {
        if (v50)
        {
          v16 = &v48[v8] - __p + 1;
        }

        else
        {
          v16 = &v48[v8] - __p;
        }

        v44 = v7 + 4;
        std::__tree<std::__value_type<unsigned short,unsigned long long>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned long long>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,unsigned long long>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(&v56, *(v7 + 16), &v44)[5] = v16;
        v17 = v7[5];
        if (*(v17 + 24))
        {
          v18 = (*(v17 + 8) - *v17 + 1);
        }

        else
        {
          v18 = (*(v17 + 8) - *v17);
        }

        v44 = v18;
        geo::obitstream::appendBytes(&__p, &v44, 8);
        v44 = 0;
        geo::obitstream::appendBytes(&__p, &v44, 8);
        v19 = v7[5];
        if (v50)
        {
          v20 = v50 - 8;
        }

        else
        {
          v20 = 0;
        }

        v21 = *(v19 + 8) - *v19;
        if (*(v19 + 24))
        {
          v22 = *(v19 + 24) - 8;
        }

        else
        {
          v22 = 0;
        }

        v23 = (v21 + v48 - __p + ((v22 + v20) >> 3)) & 0x1FFFFFFFFFFFFFFFLL;
        geo::obitstream::appendBytes(&__p, *v19, v21);
        v24 = ((*(v19 + 24) + v50) & 7) == 0;
        v50 = (*(v19 + 24) + v50) & 7;
        if (v24)
        {
          v25 = v23;
        }

        else
        {
          v25 = v23 + 1;
        }

        if (v48 - __p > v25)
        {
          --v48;
        }

        goto LABEL_36;
      }

      grl::codec::ResourcePack::compressData(&v44, v7[5]);
      if (v50)
      {
        v9 = &v48[v8] - __p + 1;
      }

      else
      {
        v9 = &v48[v8] - __p;
      }

      v42[0] = v7 + 4;
      std::__tree<std::__value_type<unsigned short,unsigned long long>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned long long>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,unsigned long long>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(&v56, *(v7 + 16), v42)[5] = v9;
      v10 = v7[5];
      if (*(v10 + 24))
      {
        v11 = (*(v10 + 8) - *v10 + 1);
      }

      else
      {
        v11 = (*(v10 + 8) - *v10);
      }

      v42[0] = v11;
      geo::obitstream::appendBytes(&__p, v42, 8);
      v12 = v44;
      v13 = v45 - v44;
      v42[0] = (v45 - v44);
      geo::obitstream::appendBytes(&__p, v42, 8);
      geo::obitstream::appendBytes(&__p, v12, v13);
      std::ostringstream::str[abi:nn200100](&v41, v7[5] + 32);
      v14 = std::string::insert(&v41, 0, "compressed chapter contents\n", 0x1CuLL);
      v15 = v14->__r_.__value_.__r.__words[2];
      *v42 = *&v14->__r_.__value_.__l.__data_;
      v43 = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v40 = off_1E7B58030;
      geo::obitstream::markDebugLog(&__p, v42, &v40);
      if (SHIBYTE(v43) < 0)
      {
        operator delete(v42[0]);
      }

      if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        break;
      }

      operator delete(v41.__r_.__value_.__l.__data_);
      if (v12)
      {
        goto LABEL_35;
      }

LABEL_36:
      v26 = v7[1];
      if (v26)
      {
        do
        {
          v27 = v26;
          v26 = *v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          v27 = v7[2];
          v24 = *v27 == v7;
          v7 = v27;
        }

        while (!v24);
      }

      v7 = v27;
      if (v27 == a3 + 1)
      {
        goto LABEL_42;
      }
    }

    if (!v12)
    {
      goto LABEL_36;
    }

LABEL_35:
    operator delete(v12);
    goto LABEL_36;
  }

LABEL_42:
  std::string::basic_string[abi:nn200100]<0>(&v44, "chapters index");
  v42[0] = off_1E7B58048;
  geo::obitstream::markDebugLog(a1, &v44, v42);
  if (v46 < 0)
  {
    operator delete(v44);
  }

  v28 = v56;
  if (v56 != v57)
  {
    do
    {
      std::string::basic_string[abi:nn200100]<0>(&v44, "chapter ID");
      v42[0] = off_1E7B58060;
      geo::obitstream::markDebugLog(a1, &v44, v42);
      if (v46 < 0)
      {
        operator delete(v44);
      }

      LOWORD(v44) = *(v28 + 16);
      geo::obitstream::appendBytes(a1, &v44, 2);
      std::string::basic_string[abi:nn200100]<0>(&v44, "chapter data start");
      v42[0] = off_1E7B58078;
      geo::obitstream::markDebugLog(a1, &v44, v42);
      if (v46 < 0)
      {
        operator delete(v44);
      }

      v44 = v28[5];
      geo::obitstream::appendBytes(a1, &v44, 8);
      v29 = v28[1];
      if (v29)
      {
        do
        {
          v30 = v29;
          v29 = *v29;
        }

        while (v29);
      }

      else
      {
        do
        {
          v30 = v28[2];
          v24 = *v30 == v28;
          v28 = v30;
        }

        while (!v24);
      }

      v28 = v30;
    }

    while (v30 != v57);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "chapters data");
  v42[0] = off_1E7B58090;
  geo::obitstream::markDebugLog(a1, &v44, v42);
  if (v46 < 0)
  {
    operator delete(v44);
  }

  if (*(a1 + 24))
  {
    v31 = *(a1 + 24) - 8;
  }

  else
  {
    v31 = 0;
  }

  v32 = v48 - __p;
  if (v50)
  {
    v33 = v50 - 8;
  }

  else
  {
    v33 = 0;
  }

  v34 = (v32 + *(a1 + 8) - *a1 + ((v33 + v31) >> 3)) & 0x1FFFFFFFFFFFFFFFLL;
  geo::obitstream::appendBytes(a1, __p, v32);
  v35 = v50 + *(a1 + 24);
  v36 = *(a1 + 8);
  v37 = v36 - *a1;
  v38 = v35 & 7;
  *(a1 + 24) = v35 & 7;
  if ((v35 & 7) != 0)
  {
    v39 = v34 + 1;
  }

  else
  {
    v39 = v34;
  }

  if (v37 > v39)
  {
    *(a1 + 8) = v36 - 1;
  }

  if (v38)
  {
    operator new();
  }

  v51 = *MEMORY[0x1E69E54E8];
  *(&v51 + *(v51 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v52 = MEMORY[0x1E69E5548] + 16;
  if (v54 < 0)
  {
    operator delete(v53[7].__locale_);
  }

  v52 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v53);
  std::ostream::~ostream();
  MEMORY[0x1B8C620C0](&v55);
  if (__p)
  {
    v48 = __p;
    operator delete(__p);
  }

  std::__tree<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::__map_value_compare<grl::PropertyID,std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,std::less<grl::PropertyID>,true>,geo::allocator_adapter<std::__value_type<grl::PropertyID,geo::Color<unsigned char,4,(geo::ColorSpace)2>>,grl::zone_mallocator>>::destroy(v57[0]);
}

void *std::__tree<std::__value_type<unsigned short,unsigned long long>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned long long>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,unsigned long long>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[16];
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = (v7 + 1);
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v10 = grl::zone_mallocator::instance(a1);
    geo::read_write_lock::read_lock((v10 + 32));
    v7 = malloc_type_zone_malloc(*v10, 0x30uLL, 0x1020040F1C9ACE0uLL);
    atomic_fetch_add((v10 + 24), 1u);
    geo::read_write_lock::unlock((v10 + 32));
    *(v7 + 16) = **a3;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v11 = **a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[3] = (a1[3] + 1);
  }

  return v7;
}

uint64_t grl::codec::ResourcePack::decodeHeader(void *a1, uint64_t a2)
{
  v19 = *MEMORY[0x1E69E9840];
  if (*a1)
  {
    std::istream::read();
    v12 = 0;
    v13 = 0uLL;
    std::vector<unsigned char>::__append(&v12, 0x40uLL);
    v3 = v12;
    v4 = v16;
    v5 = v17;
    v6 = v15;
    *v12 = v14;
    *(v3 + 1) = v6;
    *(v3 + 2) = v4;
    *(v3 + 3) = v5;
    v7 = v13;
    v8 = *a2;
    if (*a2)
    {
      *(a2 + 8) = v8;
      v11 = v7;
      operator delete(v8);
      v7 = v11;
    }

    *a2 = v3;
    *(a2 + 8) = v7;
    if (v18)
    {
      operator new();
    }

    std::istream::read();
    v9 = 1;
  }

  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Pack Stream Is Invalid", "packStream", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ResourcePack.cpp", 217);
    v9 = 0;
  }

  return v9 & 1;
}

BOOL grl::codec::ResourcePack::decodeChapterSize(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v4 = *a1;
  if (*a1)
  {
    std::istream::seekg();
    std::istream::read();
    *a3 = 0;
    *a4 = 0;
  }

  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Pack Stream Is Invalid", "packStream", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ResourcePack.cpp", 266);
  }

  return v4 != 0;
}

uint64_t grl::codec::ResourcePack::decodeChapterData(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  v3 = *a1;
  if (!*a1)
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Pack Stream Is Invalid", "packStream", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ResourcePack.cpp", 302);
    return 0;
  }

  v10 = 0;
  v11 = 0;
  v5 = a1[1];
  v9[0] = v3;
  v9[1] = v5;
  if (!v5)
  {
    if (grl::codec::ResourcePack::decodeChapterSize(v9, *a2, &v11, &v10))
    {
      goto LABEL_7;
    }

    return 0;
  }

  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  v6 = grl::codec::ResourcePack::decodeChapterSize(v9, *a2, &v11, &v10);
  std::__shared_weak_count::__release_shared[abi:nn200100](v5);
  if (!v6)
  {
    return 0;
  }

LABEL_7:
  if (v10)
  {
    if ((v10 & 0x8000000000000000) == 0)
    {
      operator new();
    }

    goto LABEL_17;
  }

  if (v11)
  {
    if ((v11 & 0x8000000000000000) == 0)
    {
      operator new();
    }

LABEL_17:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  std::istream::read();
  v8 = *a3;
  if (*a3)
  {
    *(a3 + 8) = v8;
    operator delete(v8);
  }

  *a3 = 0;
  *(a3 + 8) = 0;
  result = 1;
  *(a3 + 16) = 0;
  return result;
}

void grl::codec::ResourcePack::encodePackInfo(grl::codec::ResourcePack *this, uint64_t a2, __int16 a3)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 24) = 0;
  *(this + 2) = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](this + 4);
  std::string::basic_string[abi:nn200100]<0>(&__p, "pack info");
  v8 = off_1E7B580A8;
  geo::obitstream::markDebugLog(this, &__p, &v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  LOWORD(__p.__r_.__value_.__l.__data_) = a3;
  geo::obitstream::appendBytes(this, &__p, 2);
  if (*(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(a2 + 8), *(a2 + 16));
  }

  else
  {
    __p = *(a2 + 8);
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  v7 = strlen(p_p);
  geo::obitstream::appendBytes(this, p_p, v7 + 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  LODWORD(__p.__r_.__value_.__l.__data_) = *(a2 + 32);
  geo::obitstream::appendBytes(this, &__p, 4);
}

uint64_t grl::codec::ResourcePack::decodePackInfo(uint64_t a1, _WORD *a2, uint64_t a3, _WORD *a4)
{
  v4 = a3 - a2;
  if ((a3 - a2) < 2)
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Pack Version could not be read", "version.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ResourcePack.cpp", 359);
    return 0;
  }

  *a4 = *a2;
  if (a3 - a2 == 2)
  {
LABEL_7:
    v13 = 0;
    v9 = 363;
    v10 = "streamRegion.has_value()";
    v11 = "Region could not be read";
  }

  else
  {
    v8 = 0;
    while (*(a2 + v8 + 2))
    {
      if (a3 - a2 - 2 == ++v8)
      {
        goto LABEL_7;
      }
    }

    if (v8 >= 0x7FFFFFFFFFFFFFF8)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    if (v8 >= 0x17)
    {
      operator new();
    }

    *(&__dst.__r_.__value_.__s + 23) = v8;
    if (v8)
    {
      memcpy(&__dst, a2 + 1, v8);
    }

    __dst.__r_.__value_.__s.__data_[v8] = 0;
    v13 = 1;
    __p = __dst;
    std::string::operator=((a1 + 8), &__p);
    if (v8 + 7 <= v4)
    {
      *(a1 + 32) = *(a2 + v8 + 3);
      v5 = 1;
      goto LABEL_9;
    }

    v9 = 367;
    v10 = "streamContentScale.has_value()";
    v11 = "Content Scale could not be read";
  }

  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v11, v10, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ResourcePack.cpp", v9);
  v5 = 0;
LABEL_9:
  if (v13 == 1 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  return v5;
}

os_log_t __GEOGetGeoResourceLibIconManagerLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "IconManager");
  GEOGetGeoResourceLibIconManagerLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibCodecLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Codec");
  GEOGetGeoResourceLibCodecLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibRendererLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Renderer");
  GEOGetGeoResourceLibRendererLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibFontLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Font");
  GEOGetGeoResourceLibFontLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibMetricsLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Metrics");
  GEOGetGeoResourceLibMetricsLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibMathLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Math");
  GEOGetGeoResourceLibMathLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibEaselLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "Easel");
  GEOGetGeoResourceLibEaselLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibCoreFoundationLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "CoreFoundation");
  GEOGetGeoResourceLibCoreFoundationLog::log = result;
  return result;
}

os_log_t __GEOGetGeoResourceLibCoreGraphicsLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "CoreGraphics");
  GEOGetGeoResourceLibCoreGraphicsLog::log = result;
  return result;
}

BOOL grl::IconKey::decode(grl::IconKey *this, const unsigned __int8 *a2, unint64_t a3, unsigned int a4)
{
  if (a3 < 4)
  {
    v4 = 82;
    v5 = "id.has_value()";
    v6 = "ID could not be read";
LABEL_14:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v6, v5, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Model/IconKey.cpp", v4);
    return 0;
  }

  *(this + 4) = *a2;
  if (a4 < 3)
  {
    v7 = 0;
    v8 = 6;
  }

  else
  {
    if (a3 < 6)
    {
      v4 = 87;
      v5 = "dataVariant.has_value()";
      v6 = "Data Variant could not be read";
      goto LABEL_14;
    }

    v7 = *(a2 + 2);
    v8 = 8;
  }

  *(this + 10) = v7;
  if (v8 > a3)
  {
    v4 = 94;
    v5 = "variant.has_value()";
    v6 = "Variant could not be read";
    goto LABEL_14;
  }

  *(this + 11) = *&a2[v8 - 2];
  if (v8 >= a3)
  {
    v4 = 98;
    v5 = "sizeGroupRaw.has_value()";
    v6 = "Size Group could not be read";
    goto LABEL_14;
  }

  v9 = a2[v8];
  v10 = v9 < 0xA;
  if (v9 <= 9)
  {
    *(this + 24) = v9;
    return 1;
  }

  return v10;
}

void grl::IconKey::encode(grl::IconKey *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *a3 = 0;
  *(a3 + 8) = 0;
  *(a3 + 24) = 0;
  *(a3 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100]((a3 + 32));
  *v6 = *(this + 4);
  geo::obitstream::appendBytes(a3, v6, 4);
  if (a2 >= 3)
  {
    *v7 = *(this + 10);
    geo::obitstream::appendBytes(a3, v7, 2);
  }

  *v8 = *(this + 11);
  geo::obitstream::appendBytes(a3, v8, 2);
  v9 = *(this + 24);
  geo::obitstream::appendBytes(a3, &v9, 1);
}

float grl::IconModifiers::setOpacity(grl::IconModifiers *this, float a2)
{
  result = fminf(fmaxf(a2, 0.0), 1.0);
  *(this + 2) = result;
  return result;
}

uint64_t grl::IconModifiers::setPathScale(uint64_t this, float a2)
{
  if ((*(this + 16) & 1) == 0)
  {
    *(this + 16) = 1;
  }

  *(this + 20) = a2;
  return this;
}

float grl::IconModifiers::setScale(grl::IconModifiers *this, float a2)
{
  result = fmaxf(a2, 0.0);
  *(this + 3) = result;
  return result;
}

uint64_t grl::IconModifiers::setTailDirection(uint64_t this, float a2)
{
  if ((*(this + 60) & 1) == 0)
  {
    *(this + 60) = 1;
  }

  *(this + 64) = a2;
  return this;
}

double grl::IconModifiers::setText(uint64_t a1, std::string *this)
{
  size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0)
  {
    size = this->__r_.__value_.__l.__size_;
  }

  if (size)
  {
    v5 = std::string::find(this, 10, 0);
    v6 = (a1 + 112);
    std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,std::string>,grl::zone_mallocator>>::destroy(*(a1 + 112));
    *(a1 + 104) = a1 + 112;
    v8 = a1 + 104;
    *(v8 + 24) = 0;
    *v6 = 0;
    if (v5 == -1)
    {
      v10 = 0;
      v9 = 0;
    }

    else
    {
      v9 = 0;
      v10 = 0;
      do
      {
        std::string::basic_string(&v17, this, v10, v5, &v18);
        v16 = v9;
        v18 = &v16;
        v11 = std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,std::string>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(v8, v9, &v18);
        v12 = v11;
        if (*(v11 + 63) < 0)
        {
          operator delete(v11[5]);
        }

        ++v9;
        *(v12 + 5) = v17;
        v10 = v5 + 1;
        v5 = std::string::find(this, 10, v5 + 1);
      }

      while (v5 != -1);
    }

    v13 = HIBYTE(this->__r_.__value_.__r.__words[2]);
    if ((v13 & 0x80u) != 0)
    {
      v13 = this->__r_.__value_.__l.__size_;
    }

    if (v10 < v13)
    {
      std::string::basic_string(&v17, this, v10, 0xFFFFFFFFFFFFFFFFLL, &v18);
      v16 = v9;
      v18 = &v16;
      v14 = std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,std::string>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(v8, v9, &v18);
      v15 = v14;
      if (*(v14 + 63) < 0)
      {
        operator delete(v14[5]);
      }

      result = *&v17.__r_.__value_.__l.__data_;
      *(v15 + 5) = v17;
    }
  }

  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,std::string>,grl::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(uint64_t **a1, unsigned __int16 a2, _WORD **a3)
{
  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(v5 + 16);
        if (v8 <= a2)
        {
          break;
        }

        v5 = *v7;
        v6 = v7;
        if (!*v7)
        {
          goto LABEL_9;
        }
      }

      if (v8 >= a2)
      {
        break;
      }

      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = grl::zone_mallocator::instance(a1);
    v10 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::__tree_node<std::__value_type<unsigned short,std::string>,void *>>(v9);
    v10[16] = **a3;
    *(v10 + 6) = 0;
    *(v10 + 7) = 0;
    *(v10 + 5) = 0;
    std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::__insert_node_at(a1, v7, v6, v10);
    return v10;
  }

  return v7;
}

uint64_t grl::IconModifiers::setGlyphColor(uint64_t result, _DWORD *a2)
{
  if ((*(result + 30) & 1) == 0)
  {
    *(result + 30) = 1;
  }

  *(result + 31) = *a2;
  return result;
}

uint64_t grl::IconModifiers::setGradientBaseColor(uint64_t result, _DWORD *a2)
{
  if ((*(result + 35) & 1) == 0)
  {
    *(result + 35) = 1;
  }

  *(result + 36) = *a2;
  return result;
}

uint64_t grl::IconModifiers::setFillColor(uint64_t result, _DWORD *a2)
{
  if ((*(result + 40) & 1) == 0)
  {
    *(result + 40) = 1;
  }

  *(result + 41) = *a2;
  return result;
}

uint64_t grl::IconModifiers::setHaloColor(uint64_t result, _DWORD *a2)
{
  if ((*(result + 45) & 1) == 0)
  {
    *(result + 45) = 1;
  }

  *(result + 46) = *a2;
  return result;
}

char **grl::IconModifiers::setClusterIconValues(uint64_t a1, char **a2)
{
  result = (a1 + 136);
  if (result != a2)
  {
    return std::vector<unsigned int>::__assign_with_size[abi:nn200100]<unsigned int *,unsigned int *>(result, *a2, a2[1], (a2[1] - *a2) >> 2);
  }

  return result;
}

void grl::PropertySet::encode(grl::PropertySet *this, void *a2)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 24) = 0;
  *(this + 2) = 0;
  std::ostringstream::basic_ostringstream[abi:nn200100](this + 4);
  std::vector<unsigned char>::reserve(this, *(this + 2) - *this + 1000);
  std::string::basic_string[abi:nn200100]<0>(__p, "property set");
  v30 = off_1E7B58388;
  geo::obitstream::markDebugLog(this, __p, &v30);
  if (v32 < 0)
  {
    operator delete(__p[0]);
  }

  v4 = a2[3] != 0;
  if (a2[7])
  {
    ++v4;
  }

  if (a2[11])
  {
    ++v4;
  }

  if (a2[15])
  {
    ++v4;
  }

  if (a2[19])
  {
    ++v4;
  }

  if (a2[23])
  {
    ++v4;
  }

  if (a2[27])
  {
    ++v4;
  }

  LOWORD(__p[0]) = v4;
  geo::obitstream::appendBytes(this, __p, 2);
  if (a2[3])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "BOOL");
    v30 = off_1E7B583A0;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 0;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[3];
    geo::obitstream::appendBytes(this, __p, 2);
    v5 = *a2;
    if (*a2 != a2 + 1)
    {
      do
      {
        LOWORD(__p[0]) = *(v5 + 13);
        geo::obitstream::appendBytes(this, __p, 2);
        LOBYTE(__p[0]) = *(v5 + 28);
        geo::obitstream::appendBytes(this, __p, 1);
        v6 = v5[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = *v6;
          }

          while (v6);
        }

        else
        {
          do
          {
            v7 = v5[2];
            v8 = *v7 == v5;
            v5 = v7;
          }

          while (!v8);
        }

        v5 = v7;
      }

      while (v7 != a2 + 1);
    }
  }

  if (a2[7])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "int");
    v30 = off_1E7B583B8;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 2;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[7];
    geo::obitstream::appendBytes(this, __p, 2);
    v9 = a2[4];
    if (v9 != a2 + 5)
    {
      do
      {
        LOWORD(__p[0]) = *(v9 + 14);
        geo::obitstream::appendBytes(this, __p, 2);
        LODWORD(__p[0]) = *(v9 + 8);
        geo::obitstream::appendBytes(this, __p, 4);
        v10 = v9[1];
        if (v10)
        {
          do
          {
            v11 = v10;
            v10 = *v10;
          }

          while (v10);
        }

        else
        {
          do
          {
            v11 = v9[2];
            v8 = *v11 == v9;
            v9 = v11;
          }

          while (!v8);
        }

        v9 = v11;
      }

      while (v11 != a2 + 5);
    }
  }

  if (a2[11])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "float");
    v30 = off_1E7B583D0;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 1;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[11];
    geo::obitstream::appendBytes(this, __p, 2);
    v12 = a2[8];
    if (v12 != a2 + 9)
    {
      do
      {
        LOWORD(__p[0]) = *(v12 + 14);
        geo::obitstream::appendBytes(this, __p, 2);
        LODWORD(__p[0]) = *(v12 + 8);
        geo::obitstream::appendBytes(this, __p, 4);
        v13 = v12[1];
        if (v13)
        {
          do
          {
            v14 = v13;
            v13 = *v13;
          }

          while (v13);
        }

        else
        {
          do
          {
            v14 = v12[2];
            v8 = *v14 == v12;
            v12 = v14;
          }

          while (!v8);
        }

        v12 = v14;
      }

      while (v14 != a2 + 9);
    }
  }

  if (a2[15])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "vec2");
    v30 = off_1E7B583E8;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 3;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[15];
    geo::obitstream::appendBytes(this, __p, 2);
    v15 = a2[12];
    if (v15 != a2 + 13)
    {
      do
      {
        LOWORD(__p[0]) = *(v15 + 14);
        geo::obitstream::appendBytes(this, __p, 2);
        LODWORD(__p[0]) = *(v15 + 8);
        geo::obitstream::appendBytes(this, __p, 4);
        LODWORD(__p[0]) = *(v15 + 9);
        geo::obitstream::appendBytes(this, __p, 4);
        v16 = v15[1];
        if (v16)
        {
          do
          {
            v17 = v16;
            v16 = *v16;
          }

          while (v16);
        }

        else
        {
          do
          {
            v17 = v15[2];
            v8 = *v17 == v15;
            v15 = v17;
          }

          while (!v8);
        }

        v15 = v17;
      }

      while (v17 != a2 + 13);
    }
  }

  if (a2[19])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "vec4");
    v30 = off_1E7B58400;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 4;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[19];
    geo::obitstream::appendBytes(this, __p, 2);
    v18 = a2[16];
    if (v18 != a2 + 17)
    {
      do
      {
        LOWORD(__p[0]) = *(v18 + 14);
        geo::obitstream::appendBytes(this, __p, 2);
        LODWORD(__p[0]) = *(v18 + 8);
        geo::obitstream::appendBytes(this, __p, 4);
        LODWORD(__p[0]) = *(v18 + 9);
        geo::obitstream::appendBytes(this, __p, 4);
        LODWORD(__p[0]) = *(v18 + 10);
        geo::obitstream::appendBytes(this, __p, 4);
        LODWORD(__p[0]) = *(v18 + 11);
        geo::obitstream::appendBytes(this, __p, 4);
        v19 = v18[1];
        if (v19)
        {
          do
          {
            v20 = v19;
            v19 = *v19;
          }

          while (v19);
        }

        else
        {
          do
          {
            v20 = v18[2];
            v8 = *v20 == v18;
            v18 = v20;
          }

          while (!v8);
        }

        v18 = v20;
      }

      while (v20 != a2 + 17);
    }
  }

  if (a2[23])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "color");
    v30 = off_1E7B58418;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 5;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[23];
    geo::obitstream::appendBytes(this, __p, 2);
    v21 = a2[20];
    if (v21 != a2 + 21)
    {
      do
      {
        LOWORD(__p[0]) = *(v21 + 13);
        geo::obitstream::appendBytes(this, __p, 2);
        LOBYTE(__p[0]) = *(v21 + 28);
        geo::obitstream::appendBytes(this, __p, 1);
        LOBYTE(__p[0]) = *(v21 + 29);
        geo::obitstream::appendBytes(this, __p, 1);
        LOBYTE(__p[0]) = *(v21 + 30);
        geo::obitstream::appendBytes(this, __p, 1);
        LOBYTE(__p[0]) = *(v21 + 31);
        geo::obitstream::appendBytes(this, __p, 1);
        v22 = v21[1];
        if (v22)
        {
          do
          {
            v23 = v22;
            v22 = *v22;
          }

          while (v22);
        }

        else
        {
          do
          {
            v23 = v21[2];
            v8 = *v23 == v21;
            v21 = v23;
          }

          while (!v8);
        }

        v21 = v23;
      }

      while (v23 != a2 + 21);
    }
  }

  if (a2[27])
  {
    std::string::basic_string[abi:nn200100]<0>(__p, "string");
    v30 = off_1E7B58430;
    geo::obitstream::markDebugLog(this, __p, &v30);
    if (v32 < 0)
    {
      operator delete(__p[0]);
    }

    LOWORD(__p[0]) = 6;
    geo::obitstream::appendBytes(this, __p, 2);
    LOWORD(__p[0]) = a2[27];
    geo::obitstream::appendBytes(this, __p, 2);
    v24 = a2[24];
    v25 = a2 + 25;
    if (v24 != a2 + 25)
    {
      do
      {
        LOWORD(__p[0]) = *(v24 + 16);
        geo::obitstream::appendBytes(this, __p, 2);
        if (*(v24 + 63) >= 0)
        {
          v26 = (v24 + 5);
        }

        else
        {
          v26 = v24[5];
        }

        v27 = strlen(v26);
        geo::obitstream::appendBytes(this, v26, v27 + 1);
        v28 = v24[1];
        if (v28)
        {
          do
          {
            v29 = v28;
            v28 = *v28;
          }

          while (v28);
        }

        else
        {
          do
          {
            v29 = v24[2];
            v8 = *v29 == v24;
            v24 = v29;
          }

          while (!v8);
        }

        v24 = v29;
      }

      while (v29 != v25);
    }
  }
}

void grl::SkipStreamBytes(void *a1, uint64_t a2)
{
  v3 = a1[1];
  v4 = a1[2];
  if (a2)
  {
    v5 = v4 + a2;
    if (v5 < v3)
    {
      v3 = v5;
    }

    a1[2] = v3;
  }

  else
  {
    v6 = v3 - v4;
    if (v6)
    {
      v7 = 0;
      v8 = (*a1 + v4);
      while (v8[v7])
      {
        if (v6 == ++v7)
        {
          return;
        }
      }

      if (v7 >= 0x7FFFFFFFFFFFFFF8)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      if (v7 >= 0x17)
      {
        operator new();
      }

      v11 = v7;
      if (v7)
      {
        memmove(__dst, v8, v7);
      }

      *(__dst + v7) = 0;
      a1[2] += v7 + 1;
      if (v11 < 0)
      {
        v9 = __dst[0];

        operator delete(v9);
      }
    }
  }
}

void grl::FontManager::clearFontCache(grl::FontManager *this)
{
  std::mutex::lock((this + 168));
  if (*(this + 16))
  {
    std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::__deallocate_node(*(this + 15));
    *(this + 15) = 0;
    v2 = *(this + 14);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        *(*(this + 13) + 8 * i) = 0;
      }
    }

    *(this + 16) = 0;
  }

  std::__list_imp<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>>::clear(this + 18);
  CGFontDBGetLocal();
  CGFontDBPurgeAllFonts();

  std::mutex::unlock((this + 168));
}

void std::__list_imp<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    v2 = a1[1];
    v3 = *(*a1 + 8);
    v4 = *v2;
    *(v4 + 8) = v3;
    *v3 = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = v2[1];
        std::__destroy_at[abi:nn200100]<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,0>((v2 + 2));
        operator delete(v2);
        v2 = v5;
      }

      while (v5 != a1);
    }
  }
}

void std::__destroy_at[abi:nn200100]<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,0>(esl::FontKey *this)
{
  *(this + 16) = &unk_1F2A5F810;
  v2 = *(this + 17);
  if (v2)
  {
    CFRelease(v2);
  }

  esl::FontKey::~FontKey(this);
}

void std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *v1;
      esl::FontKey::~FontKey((v1 + 2));
      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

void grl::FontManager::~FontManager(grl::FontManager *this)
{
  grl::FontManager::~FontManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F650;
  std::mutex::~mutex((this + 168));
  std::__list_imp<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>>::clear(this + 18);
  std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::__deallocate_node(*(this + 15));
  v2 = *(this + 13);
  *(this + 13) = 0;
  if (v2)
  {
    operator delete(v2);
  }

  grl::ResourceManager::~ResourceManager(this);
}

uint64_t geo::LRUPolicy<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::hash<grl::FontKey>>::get(uint64_t a1, void *a2, esl::FontKey *this)
{
  v4 = std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::find<grl::FontKey>(a2, this);
  if (v4)
  {
    v5 = *(a1 + 8);
    v6 = v4[18];
    if (v5 == v6)
    {
      return *(a1 + 8);
    }

    v7 = v6[1];
    if (v7 == v5)
    {
      return *(a1 + 8);
    }

    else
    {
      v8 = *v6;
      *(v8 + 8) = v7;
      *v7 = v8;
      v9 = *v5;
      *(v9 + 8) = v6;
      *v6 = v9;
      *v5 = v6;
      v6[1] = v5;
      return *(a1 + 8);
    }
  }

  return a1;
}

void geo::Cache<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::hash<grl::FontKey>,geo::LRUPolicy>::insert(uint64_t a1, esl::FontKey *this, CFTypeRef cf)
{
  v11[19] = *MEMORY[0x1E69E9840];
  v5 = (a1 + 8);
  if (cf)
  {
    CFRetain(cf);
  }

  v6 = std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::find<grl::FontKey>(v5, this);
  if (v6)
  {
    v7 = v6;
    v8 = v6[18];
    v10 = *v8;
    v9 = v8[1];
    *(v10 + 8) = v9;
    *v9 = v10;
    --*(a1 + 64);
    std::__destroy_at[abi:nn200100]<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,0>((v8 + 2));
    operator delete(v8);
    std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::remove(v11, v5, v7);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::~unique_ptr[abi:nn200100](v11);
  }

  operator new();
}

void *std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::find<grl::FontKey>(void *a1, esl::FontKey *this)
{
  v4 = esl::FontKey::hash(this);
  v5 = a1[1];
  if (!*&v5)
  {
    return 0;
  }

  v6 = v4;
  v7 = vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *&v5)
    {
      v9 = v4 % *&v5;
    }
  }

  else
  {
    v9 = (*&v5 - 1) & v4;
  }

  v10 = *(*a1 + 8 * v9);
  if (!v10)
  {
    return 0;
  }

  v11 = *v10;
  if (*v10)
  {
    do
    {
      v12 = v11[1];
      if (v12 == v6)
      {
        if (esl::FontKey::operator==((v11 + 2), this))
        {
          return v11;
        }
      }

      else
      {
        if (v8 > 1)
        {
          if (v12 >= *&v5)
          {
            v12 %= *&v5;
          }
        }

        else
        {
          v12 &= *&v5 - 1;
        }

        if (v12 != v9)
        {
          return 0;
        }
      }

      v11 = *v11;
    }

    while (v11);
  }

  return v11;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::~unique_ptr[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      esl::FontKey::~FontKey((v2 + 16));
    }

    operator delete(v2);
  }

  return a1;
}

void geo::_retain_ptr<CGDataProvider *,geo::_retain_cf<CGDataProvider *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F738;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<CGDataProvider *,geo::_retain_cf<CGDataProvider *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F738;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

void geo::_retain_ptr<__CFData const*,geo::_retain_cf<__CFData const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F718;
  v1 = a1[1];
  if (v1)
  {
    CFRelease(v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *geo::_retain_ptr<__CFData const*,geo::_retain_cf<__CFData const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1F2A5F718;
  v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
  }

  return a1;
}

BOOL grl::FontManager::fontHasSmallCaps(CFTypeRef cf)
{
  v67 = *MEMORY[0x1E69E9840];
  v2 = &unk_1F2A5F810;
  v48 = &unk_1F2A5F810;
  if (cf)
  {
    CFRetain(cf);
    v49 = cf;
    v3 = &unk_1F2A5F810;
    v50 = &unk_1F2A5F810;
    CFRetain(cf);
  }

  else
  {
    v49 = 0;
    v3 = &unk_1F2A5F810;
    v50 = &unk_1F2A5F810;
  }

  v51 = cf;
  v4 = CTFontCopyFeaturesInternal();
  v5 = &unk_1F2A5F6B8;
  v65 = &unk_1F2A5F6B8;
  v66 = v4;
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count > 0)
    {
      v7 = Count;
      v8 = 0;
      v9 = *MEMORY[0x1E69657B0];
      key = *MEMORY[0x1E69657B8];
      v44 = *MEMORY[0x1E69657A0];
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v66, v8);
        v63 = &unk_1F2A5F698;
        if (ValueAtIndex)
        {
          break;
        }

        v64 = 0;
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
        }

        v18 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 0;
          _os_log_impl(&dword_1B2754000, v18, OS_LOG_TYPE_ERROR, "Failed to get feature dictionary for font.", buf, 2u);
        }

        v52 = &unk_1F2A5F698;
        cfa = 0;
        v17 = 1;
LABEL_24:
        v63 = &unk_1F2A5F698;
        if (v64)
        {
          CFRelease(v64);
        }

        if (v17 && v17 != 4)
        {
          goto LABEL_93;
        }

        if (++v8 == v7)
        {
          goto LABEL_92;
        }
      }

      v11 = ValueAtIndex;
      CFRetain(ValueAtIndex);
      v64 = v11;
      Value = CFDictionaryGetValue(v11, v9);
      v61 = &unk_1F2A5F6D8;
      if (!Value)
      {
        v17 = 4;
        goto LABEL_24;
      }

      v13 = Value;
      CFRetain(Value);
      v62 = v13;
      if (CFNumberIsFloatType(v13))
      {
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
        }

        v14 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (!os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_15;
        }

        *buf = 0;
        v15 = v14;
        v16 = "Font feature type is not int, can't read feature.";
      }

      else
      {
        valuePtr = 0;
        if (CFNumberGetValue(v62, kCFNumberSInt32Type, &valuePtr))
        {
          if (valuePtr == 38)
          {
            v19 = CFDictionaryGetValue(v64, key);
            v59 = &unk_1F2A5F6B8;
            if (v19)
            {
              v20 = v19;
              CFRetain(v19);
              v60 = v20;
              v21 = CFArrayGetCount(v20);
              if (v21 < 1)
              {
                v17 = 0;
              }

              else
              {
                v22 = v21;
                v40 = v5;
                v41 = v3;
                v42 = v2;
                v23 = 0;
                while (1)
                {
                  v24 = CFArrayGetValueAtIndex(v60, v23);
                  v57 = &unk_1F2A5F698;
                  if (!v24)
                  {
                    break;
                  }

                  v25 = v24;
                  CFRetain(v24);
                  v58 = v25;
                  v26 = CFDictionaryGetValue(v25, v44);
                  *buf = &unk_1F2A5F6D8;
                  if (!v26)
                  {
                    *&buf[8] = 0;
                    v2 = v42;
                    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
                    {
                      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
                    }

                    v31 = GEOGetGeoResourceLibCoreFoundationLog::log;
                    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
                    {
                      *v46 = 0;
                      v32 = v31;
                      v33 = "Failed to get feature selector id for font.";
                      goto LABEL_70;
                    }

LABEL_71:
                    v52 = &unk_1F2A5F698;
                    cfa = 0;
                    goto LABEL_79;
                  }

                  v27 = v26;
                  CFRetain(v26);
                  *&buf[8] = v27;
                  if (CFNumberIsFloatType(v27))
                  {
                    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
                    {
                      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
                    }

                    v2 = v42;
                    v34 = GEOGetGeoResourceLibCoreFoundationLog::log;
                    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
                    {
                      *v46 = 0;
                      v32 = v34;
                      v33 = "Font feature selector is not int, can't read feature.";
LABEL_70:
                      _os_log_impl(&dword_1B2754000, v32, OS_LOG_TYPE_ERROR, v33, v46, 2u);
                    }

                    goto LABEL_71;
                  }

                  *v46 = 0;
                  if (!CFNumberGetValue(*&buf[8], kCFNumberSInt32Type, v46))
                  {
                    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
                    {
                      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
                    }

                    v2 = v42;
                    v35 = GEOGetGeoResourceLibCoreFoundationLog::log;
                    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
                    {
                      *v45 = 0;
                      _os_log_impl(&dword_1B2754000, v35, OS_LOG_TYPE_ERROR, "Failed to get value from feature type for font.", v45, 2u);
                    }

                    v52 = &unk_1F2A5F698;
                    p_cfa = &cfa;
LABEL_78:
                    *p_cfa = 0;
LABEL_79:
                    *buf = &unk_1F2A5F6D8;
                    if (*&buf[8])
                    {
                      CFRelease(*&buf[8]);
                    }

                    goto LABEL_81;
                  }

                  if (*v46 == 1)
                  {
                    v52 = &unk_1F2A5F698;
                    cfa = v58;
                    p_cfa = &v58;
                    v2 = v42;
                    goto LABEL_78;
                  }

                  *buf = &unk_1F2A5F6D8;
                  if (*&buf[8])
                  {
                    CFRelease(*&buf[8]);
                  }

                  v57 = &unk_1F2A5F698;
                  if (v58)
                  {
                    CFRelease(v58);
                  }

                  if (v22 == ++v23)
                  {
                    v17 = 0;
                    v2 = v42;
                    goto LABEL_84;
                  }
                }

                v58 = 0;
                if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
                {
                  dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
                }

                v2 = v42;
                v30 = GEOGetGeoResourceLibCoreFoundationLog::log;
                if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
                {
                  *buf = 136315650;
                  *&buf[4] = "!GRL_SUFFIX_LINE_NUMBER(didTriggerAssert)";
                  *&buf[12] = 2080;
                  *&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Manager/FontManager.cpp";
                  v55 = 1024;
                  v56 = 132;
                  _os_log_impl(&dword_1B2754000, v30, OS_LOG_TYPE_ERROR, "Failed to get features selector array value for font.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
                }

                v52 = &unk_1F2A5F698;
                cfa = 0;
LABEL_81:
                v57 = &unk_1F2A5F698;
                if (v58)
                {
                  CFRelease(v58);
                }

                v17 = 1;
LABEL_84:
                v5 = v40;
                v3 = v41;
              }
            }

            else
            {
              v60 = 0;
              if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
              {
                dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
              }

              v29 = GEOGetGeoResourceLibCoreFoundationLog::log;
              if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
              {
                *buf = 0;
                _os_log_impl(&dword_1B2754000, v29, OS_LOG_TYPE_ERROR, "Failed to get feature selectors array for font.", buf, 2u);
              }

              v52 = &unk_1F2A5F698;
              cfa = 0;
              v17 = 1;
            }

            v59 = &unk_1F2A5F6B8;
            if (v60)
            {
              CFRelease(v60);
            }
          }

          else
          {
            v17 = 4;
          }

          goto LABEL_16;
        }

        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
        }

        v28 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (!os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
LABEL_15:
          v52 = &unk_1F2A5F698;
          cfa = 0;
          v17 = 1;
LABEL_16:
          v61 = &unk_1F2A5F6D8;
          if (v62)
          {
            CFRelease(v62);
          }

          goto LABEL_24;
        }

        *buf = 0;
        v15 = v28;
        v16 = "Failed to get value from feature type for font.";
      }

      _os_log_impl(&dword_1B2754000, v15, OS_LOG_TYPE_ERROR, v16, buf, 2u);
      goto LABEL_15;
    }
  }

  else
  {
    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_53824);
    }

    v37 = GEOGetGeoResourceLibCoreFoundationLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 0;
      _os_log_impl(&dword_1B2754000, v37, OS_LOG_TYPE_ERROR, "Failed to get feature information for font.", buf, 2u);
    }
  }

LABEL_92:
  v52 = &unk_1F2A5F698;
  cfa = 0;
LABEL_93:
  v65 = v5;
  if (v66)
  {
    CFRelease(v66);
  }

  v38 = cfa;
  v52 = &unk_1F2A5F698;
  if (cfa)
  {
    CFRelease(cfa);
  }

  v50 = v3;
  if (v51)
  {
    CFRelease(v51);
  }

  v48 = v2;
  if (v49)
  {
    CFRelease(v49);
  }

  return v38 != 0;
}

uint64_t *std::unique_ptr<grl::IconManager::PackInfo>::reset[abi:nn200100](uint64_t *result, uint64_t a2)
{
  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::mutex::~mutex((v2 + 304));
    std::mutex::~mutex((v2 + 240));
    std::mutex::~mutex((v2 + 176));
    if (*(v2 + 168))
    {
      v3 = *(v2 + 160);
      v4 = *(*(v2 + 152) + 8);
      v5 = *v3;
      *(v5 + 8) = v4;
      *v4 = v5;
      *(v2 + 168) = 0;
      if (v3 != (v2 + 152))
      {
        do
        {
          v6 = v3[1];
          std::__destroy_at[abi:nn200100]<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>,0>((v3 + 2));
          operator delete(v3);
          v3 = v6;
        }

        while (v6 != (v2 + 152));
      }
    }

    v7 = *(v2 + 128);
    if (v7)
    {
      do
      {
        v8 = *v7;
        if (*(v7 + 39) < 0)
        {
          operator delete(v7[2]);
        }

        operator delete(v7);
        v7 = v8;
      }

      while (v8);
    }

    v9 = *(v2 + 112);
    *(v2 + 112) = 0;
    if (v9)
    {
      operator delete(v9);
    }

    if (*(v2 + 96))
    {
      v10 = *(v2 + 88);
      v11 = *(*(v2 + 80) + 8);
      v12 = *v10;
      *(v12 + 8) = v11;
      *v11 = v12;
      *(v2 + 96) = 0;
      if (v10 != (v2 + 80))
      {
        do
        {
          v13 = v10[1];
          std::__destroy_at[abi:nn200100]<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>,0>((v10 + 2));
          operator delete(v10);
          v10 = v13;
        }

        while (v13 != (v2 + 80));
      }
    }

    v14 = *(v2 + 56);
    if (v14)
    {
      do
      {
        v15 = *v14;
        if (*(v14 + 39) < 0)
        {
          operator delete(v14[2]);
        }

        operator delete(v14);
        v14 = v15;
      }

      while (v15);
    }

    v16 = *(v2 + 40);
    *(v2 + 40) = 0;
    if (v16)
    {
      operator delete(v16);
    }

    std::__tree<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,grl::zone_mallocator>>::destroy(*(v2 + 8));

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void std::__tree<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,grl::zone_mallocator>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconMapPack>>,grl::zone_mallocator>>::destroy(*(a1 + 1));
    v2 = *(a1 + 9);
    if (v2)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v2);
    }

    if (a1[55] < 0)
    {
      operator delete(*(a1 + 4));
    }

    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

void grl::IconManager::~IconManager(grl::IconManager *this)
{
  grl::IconManager::~IconManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A5F778;
  grl::ResourceProvider::removeObserver(*(this + 1), this);
  v2 = *(this + 63);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  std::__tree<std::__value_type<std::pair<std::string,float>,std::mutex>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::mutex>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::mutex>,grl::zone_mallocator>>::destroy(*(this + 56));
  std::condition_variable::~condition_variable(this + 8);
  std::condition_variable::~condition_variable(this + 7);
  std::mutex::~mutex((this + 272));
  std::condition_variable::~condition_variable((this + 216));
  std::condition_variable::~condition_variable((this + 168));
  std::mutex::~mutex((this + 104));
  std::unique_ptr<grl::IconManager::PackInfo>::reset[abi:nn200100](this + 12, 0);

  grl::ResourceManager::~ResourceManager(this);
}

void std::__tree<std::__value_type<std::pair<std::string,float>,std::mutex>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::mutex>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::mutex>,grl::zone_mallocator>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::pair<std::string,float>,std::mutex>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::mutex>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::mutex>,grl::zone_mallocator>>::destroy(*a1);
    std::__tree<std::__value_type<std::pair<std::string,float>,std::mutex>,std::__map_value_compare<std::pair<std::string,float>,std::__value_type<std::pair<std::string,float>,std::mutex>,std::less<std::pair<std::string,float>>,true>,geo::allocator_adapter<std::__value_type<std::pair<std::string,float>,std::mutex>,grl::zone_mallocator>>::destroy(*(a1 + 1));
    std::mutex::~mutex(a1 + 1);
    if (a1[55] < 0)
    {
      operator delete(*(a1 + 4));
    }

    v3 = grl::zone_mallocator::instance(v2);
    geo::read_write_lock::read_lock((v3 + 32));
    atomic_fetch_add((v3 + 24), 0xFFFFFFFF);
    malloc_zone_free(*v3, a1);

    geo::read_write_lock::unlock((v3 + 32));
  }
}

_BYTE *grl::buildStringFromResourceNames(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    v5 = a2;
    std::ostringstream::basic_ostringstream[abi:nn200100](&v11);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v11, "[", 1);
    v6 = 0;
    do
    {
      v7 = *(v5 + 23);
      if (v7 >= 0)
      {
        v8 = v5;
      }

      else
      {
        v8 = *v5;
      }

      if (v7 >= 0)
      {
        v9 = *(v5 + 23);
      }

      else
      {
        v9 = *(v5 + 8);
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v11, v8, v9);
      if (v6 < a3 - 1)
      {
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v11, ", ", 2);
      }

      ++v6;
      v5 += 24;
    }

    while (a3 != v6);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v11, "]", 1);
    std::stringbuf::str[abi:nn200100](a1, &v12);
    v11 = *MEMORY[0x1E69E54E8];
    *(&v11 + *(v11 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
    v12 = MEMORY[0x1E69E5548] + 16;
    if (v14 < 0)
    {
      operator delete(v13[7].__locale_);
    }

    v12 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v13);
    std::ostream::~ostream();
    return MEMORY[0x1B8C620C0](&v15);
  }

  else
  {

    return std::string::basic_string[abi:nn200100]<0>(a1, "nullptr");
  }
}

void geo::Cache<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash,geo::LRUPolicy>::_pop(void *a1)
{
  v2 = a1[6];
  if (*(v2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(v2 + 16), *(v2 + 24));
  }

  else
  {
    __p = *(v2 + 16);
  }

  v9 = *(v2 + 40);
  v3 = *(v2 + 56);
  v10 = *(v2 + 48);
  v11 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v4 = a1[6];
  v6 = *v4;
  v5 = v4[1];
  *(v6 + 8) = v5;
  *v5 = v6;
  --a1[8];
  std::__destroy_at[abi:nn200100]<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>,0>((v4 + 2));
  operator delete(v4);
  v7 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>(a1 + 1, &__p);
  if (v7)
  {
    std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase(a1 + 1, v7);
  }

  if (v11)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v11);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase(void *a1, char *__p)
{
  v3 = a1[1];
  v4 = *(__p + 1);
  v5 = vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *&v3)
    {
      v4 %= *&v3;
    }
  }

  else
  {
    v4 &= *&v3 - 1;
  }

  v6 = *(*a1 + 8 * v4);
  do
  {
    v7 = v6;
    v6 = *v6;
  }

  while (v6 != __p);
  if (v7 == (a1 + 2))
  {
    goto LABEL_18;
  }

  v8 = *(v7 + 1);
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *&v3)
    {
      v8 %= *&v3;
    }
  }

  else
  {
    v8 &= *&v3 - 1;
  }

  if (v8 != v4)
  {
LABEL_18:
    if (!*__p)
    {
      goto LABEL_19;
    }

    v9 = *(*__p + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *&v3)
      {
        v9 %= *&v3;
      }
    }

    else
    {
      v9 &= *&v3 - 1;
    }

    if (v9 != v4)
    {
LABEL_19:
      *(*a1 + 8 * v4) = 0;
    }
  }

  v10 = *__p;
  if (*__p)
  {
    v11 = *(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *&v3)
      {
        v11 %= *&v3;
      }
    }

    else
    {
      v11 &= *&v3 - 1;
    }

    if (v11 != v4)
    {
      *(*a1 + 8 * v11) = v7;
      v10 = *__p;
    }
  }

  *v7 = v10;
  *__p = 0;
  --a1[3];
  if (__p[39] < 0)
  {
    operator delete(*(__p + 2));
  }

  operator delete(__p);
}

grl::IconModifiers *grl::IconModifiers::IconModifiers(grl::IconModifiers *this, const grl::IconModifiers *a2)
{
  *this = *a2;
  *(this + 16) = 0;
  if (*(a2 + 16) == 1)
  {
    *(this + 5) = *(a2 + 5);
    *(this + 16) = 1;
  }

  *(this + 24) = *(a2 + 24);
  *(this + 25) = 0;
  if (*(a2 + 25) == 1)
  {
    *(this + 26) = *(a2 + 26);
    *(this + 25) = 1;
  }

  *(this + 30) = 0;
  if (*(a2 + 30) == 1)
  {
    *(this + 31) = *(a2 + 31);
    *(this + 30) = 1;
  }

  *(this + 35) = 0;
  if (*(a2 + 35) == 1)
  {
    *(this + 9) = *(a2 + 9);
    *(this + 35) = 1;
  }

  *(this + 40) = 0;
  if (*(a2 + 40) == 1)
  {
    *(this + 41) = *(a2 + 41);
    *(this + 40) = 1;
  }

  *(this + 45) = 0;
  if (*(a2 + 45) == 1)
  {
    *(this + 46) = *(a2 + 46);
    *(this + 45) = 1;
  }

  *(this + 52) = 0;
  if (*(a2 + 52) == 1)
  {
    *(this + 14) = *(a2 + 14);
    *(this + 52) = 1;
  }

  *(this + 60) = 0;
  if (*(a2 + 60) == 1)
  {
    *(this + 16) = *(a2 + 16);
    *(this + 60) = 1;
  }

  *(this + 72) = 0;
  if (*(a2 + 72) == 1)
  {
    if (*(a2 + 103) < 0)
    {
      std::string::__init_copy_ctor_external((this + 80), *(a2 + 10), *(a2 + 11));
    }

    else
    {
      v4 = *(a2 + 5);
      *(this + 12) = *(a2 + 12);
      *(this + 5) = v4;
    }

    *(this + 72) = 1;
  }

  *(this + 13) = 0;
  *(this + 14) = 0;
  v5 = (this + 112);
  *(this + 120) = *(a2 + 120);
  *(this + 16) = 0;
  *(this + 13) = this + 112;
  v6 = *(a2 + 13);
  if (v6 != (a2 + 112))
  {
    do
    {
      v7 = *v5;
      v8 = (this + 112);
      if (*(this + 13) == v5)
      {
        goto LABEL_29;
      }

      v9 = *v5;
      v10 = this + 112;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = v9[1];
        }

        while (v9);
      }

      else
      {
        do
        {
          v8 = *(v10 + 2);
          v11 = *v8 == v10;
          v10 = v8;
        }

        while (v11);
      }

      v12 = *(v6 + 16);
      if (*(v8 + 16) < v12)
      {
LABEL_29:
        if (v7)
        {
          v13 = v8;
        }

        else
        {
          v13 = (this + 112);
        }

        if (v7)
        {
          v14 = v8 + 1;
        }

        else
        {
          v14 = (this + 112);
        }
      }

      else
      {
        v13 = (this + 112);
        v14 = (this + 112);
        if (v7)
        {
          v14 = (this + 112);
          while (1)
          {
            while (1)
            {
              v13 = v7;
              v17 = *(v7 + 16);
              if (v12 >= v17)
              {
                break;
              }

              v7 = *v13;
              v14 = v13;
              if (!*v13)
              {
                goto LABEL_36;
              }
            }

            if (v17 >= v12)
            {
              break;
            }

            v14 = v13 + 1;
            v7 = v13[1];
            if (!v7)
            {
              goto LABEL_36;
            }
          }
        }
      }

      if (!*v14)
      {
LABEL_36:
        std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,std::string>,grl::zone_mallocator>>::__construct_node<std::pair<unsigned short const,std::string> const&>(&v21, this + 104, v6 + 32);
        std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::__insert_node_at(this + 13, v13, v14, v21);
      }

      v15 = *(v6 + 1);
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = *v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          v16 = *(v6 + 2);
          v11 = *v16 == v6;
          v6 = v16;
        }

        while (!v11);
      }

      v6 = v16;
    }

    while (v16 != (a2 + 112));
  }

  std::vector<unsigned int>::vector[abi:nn200100](this + 17, a2 + 17);
  *(this + 20) = 0;
  *(this + 21) = 0;
  *(this + 22) = 0;
  v18 = *(a2 + 20);
  v19 = *(a2 + 21);
  if (v19 != v18)
  {
    std::vector<unsigned int>::__vallocate[abi:nn200100](this + 160, (v19 - v18) >> 2);
  }

  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn200100](this + 184, a2 + 184);
  return this;
}

std::string *std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<std::string const*>,std::__wrap_iter<std::string const*>>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    words = result->__r_.__value_.__r.__words;
    v8 = grl::zone_mallocator::instance(result);
    v9 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::string>(v8, a4);
    *words = v9;
    words[1] = v9;
    words[2] = &v9[a4];
    result = std::__uninitialized_allocator_copy[abi:nn200100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(a2, a3, v9);
    words[1] = result;
  }

  return result;
}

void grl::IconManager::image(void *a1, uint64_t a2, uint64_t a3, grl::IconModifiers *a4, unsigned int a5, uint64_t **a6, uint64_t a7, uint64_t a8, float a9)
{
  v269 = *MEMORY[0x1E69E9840];
  v251 = 0uLL;
  v250 = &unk_1F2A5F7A0;
  LOBYTE(v252) = 4;
  v12 = *(a3 + 16);
  v13 = ceilf(a9);
  std::string::basic_string[abi:nn200100]<0>(&v262, "Default");
  v264 = v13;
  grl::IconManager::retrieveResourcePack(buf, a2, &v262, 2);
  v16 = *buf;
  v15 = *&buf[8];
  v243 = a2;
  v235 = a5;
  if (*buf)
  {
    v17 = *&buf[8];
  }

  else
  {
    grl::IconManager::loadGlobalResourcePack(buf, a2, &v262);
    v16 = *buf;
    v17 = *&buf[8];
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v15);
    }

    if (!v16)
    {
      __src = 0;
      v248 = 0uLL;
      goto LABEL_215;
    }
  }

  v18 = *(v16 + 336);
  if (!v18)
  {
    goto LABEL_14;
  }

  v19 = v16 + 336;
  do
  {
    v20 = *(v18 + 32);
    v207 = v20 >= v12;
    v21 = v20 < v12;
    if (v207)
    {
      v19 = v18;
    }

    v18 = *(v18 + 8 * v21);
  }

  while (v18);
  if (v19 != v16 + 336 && v12 >= *(v19 + 32))
  {
    v14 = std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::vector[abi:nn200100](&v256, v19 + 40);
  }

  else
  {
LABEL_14:
    v256 = 0;
    v257 = 0;
    v258 = 0;
  }

  if (a5 == 0xFFFF)
  {
    __src = 0;
    v248 = 0uLL;
    v23 = v256;
    v22 = v257;
    v24 = v257 - v256;
    if (v257 != v256)
    {
      v25 = v24 >> 2;
      if ((v24 >> 2) >> 59)
      {
        goto LABEL_345;
      }

      *&v266 = &v249;
      v26 = grl::zone_mallocator::instance(v14);
      v27 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v26, v25);
      memcpy(&v27[-(v248 - __src)], __src, v248 - __src);
      v28 = __src;
      v29 = *(&v248 + 1);
      __src = &v27[-(v248 - __src)];
      *&v248 = v27;
      *(&v248 + 1) = &v27[32 * v25];
      *&buf[16] = v28;
      *&buf[24] = v29;
      *buf = v28;
      *&buf[8] = v28;
      v14 = std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
      v23 = v256;
      v22 = v257;
    }

    v260 = 0;
    v30 = 0uLL;
    *v259 = 0u;
    if (v23 == v22)
    {
      goto LABEL_185;
    }

    v244 = v22;
    v238 = v17;
    v31 = (v16 + 272);
    while (1)
    {
      grl::codec::IconMapPack::regionNameForID(&__p, v16, *v23);
      v32 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      v33 = *&__p.__r_.__value_.__l.__data_;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        p_p = &__p;
      }

      else
      {
        p_p = __p.__r_.__value_.__r.__words[0];
      }

      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = __p.__r_.__value_.__l.__size_;
      }

      if (size < 7)
      {
        goto LABEL_40;
      }

      v36 = p_p + size;
      v14 = p_p;
      while (1)
      {
        v14 = memchr(v14, 68, size - 6);
        if (!v14)
        {
          goto LABEL_40;
        }

        v37 = *v14 == 1634100548 && *(v14 + 3) == 1953264993;
        if (v37)
        {
          break;
        }

        size = &v36[-++v14];
        if (&v36[-v14] < 7)
        {
          goto LABEL_40;
        }
      }

      if (v14 == v36 || v14 - p_p == -1)
      {
LABEL_40:
        v38 = *v31;
        if (*v31)
        {
          v39 = *v23;
          v40 = v16 + 272;
          do
          {
            v41 = *(v38 + 28);
            v207 = v41 >= v39;
            v42 = v41 < v39;
            if (v207)
            {
              v40 = v38;
            }

            v38 = *(v38 + 8 * v42);
          }

          while (v38);
          if (v40 != v31 && v39 >= *(v40 + 28))
          {
            v51 = __src;
            if (v32 < 0)
            {
              std::string::__init_copy_ctor_external(&v253, v33, *(&v33 + 1));
            }

            else
            {
              v253 = __p;
            }

            v52 = __src;
            *&v254 = v13;
            v61 = v51 - __src;
            v62 = v248;
            if (v248 >= *(&v248 + 1))
            {
              v64 = ((v248 - __src) >> 5) + 1;
              if (v64 >> 59)
              {
                goto LABEL_345;
              }

              v65 = *(&v248 + 1) - __src;
              if ((*(&v248 + 1) - __src) >> 4 > v64)
              {
                v64 = v65 >> 4;
              }

              if (v65 >= 0x7FFFFFFFFFFFFFE0)
              {
                v66 = 0x7FFFFFFFFFFFFFFLL;
              }

              else
              {
                v66 = v64;
              }

              *&v268 = &v249;
              if (v66)
              {
                v67 = grl::zone_mallocator::instance(v14);
                v68 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v67, v66);
              }

              else
              {
                v68 = 0;
              }

              v70 = v68 + 32 * (v61 >> 5);
              *v267 = v68;
              *&v267[8] = v70;
              *&v267[16] = v70;
              *&v267[24] = v68 + 32 * v66;
              if (v61 >> 5 == v66)
              {
                if (v61 < 1)
                {
                  if (v52 == v51)
                  {
                    v79 = 1;
                  }

                  else
                  {
                    v79 = v61 >> 4;
                  }

                  *&v266 = v268;
                  v80 = grl::zone_mallocator::instance(v68);
                  v81 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v80, v79);
                  v82 = *&v267[8];
                  v83 = *&v267[8];
                  v84 = &v81[32 * (v79 >> 2)];
                  if (*&v267[16] != *&v267[8])
                  {
                    v84 = &v81[32 * (v79 >> 2) + *&v267[16] - *&v267[8]];
                    v85 = &v81[32 * (v79 >> 2)];
                    do
                    {
                      v86 = *v83;
                      *(v85 + 2) = *(v83 + 2);
                      *v85 = v86;
                      *(v83 + 1) = 0;
                      *(v83 + 2) = 0;
                      *v83 = 0;
                      *(v85 + 6) = *(v83 + 6);
                      v85 += 32;
                      v83 += 2;
                    }

                    while (v85 != v84);
                    v82 = *&v267[8];
                  }

                  v87 = *v267;
                  v88 = *&v267[24];
                  *v267 = v81;
                  *&v267[8] = &v81[32 * (v79 >> 2)];
                  *&buf[8] = v82;
                  *&v267[16] = v84;
                  *&v267[24] = &v81[32 * v79];
                  *buf = v87;
                  *&buf[24] = v88;
                  std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
                  v70 = *&v267[16];
                }

                else
                {
                  v70 -= ((v61 >> 1) + 16) & 0xFFFFFFFFFFFFFFE0;
                  *&v267[8] = v70;
                  *&v267[16] = v70;
                }
              }

              v89 = *&v253.__r_.__value_.__l.__data_;
              *(v70 + 2) = *(&v253.__r_.__value_.__l + 2);
              *v70 = v89;
              memset(&v253, 0, sizeof(v253));
              *(v70 + 6) = v254;
              v90 = (*&v267[16] + 32);
              *&v267[16] = v90;
              v91 = v248 - v51;
              memcpy(v90, v51, v248 - v51);
              *&v267[16] = &v90[v91];
              *&v248 = v51;
              v92 = (*&v267[8] - (v51 - __src));
              memcpy(v92, __src, v51 - __src);
              v93 = __src;
              v94 = *(&v248 + 1);
              __src = v92;
              v248 = *&v267[16];
              *&v267[16] = v93;
              *&v267[24] = v94;
              *v267 = v93;
              *&v267[8] = v93;
              v14 = std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(v267);
            }

            else if (v51 == v248)
            {
              v69 = *&v253.__r_.__value_.__l.__data_;
              *(v248 + 16) = *(&v253.__r_.__value_.__l + 2);
              *v62 = v69;
              memset(&v253, 0, sizeof(v253));
              *(v62 + 24) = v254;
              *&v248 = v62 + 32;
            }

            else
            {
              std::vector<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator>>::__move_range(&__src, v51, v248, (v51 + 4));
              if (*(v51 + 23) < 0)
              {
                operator delete(*v51);
              }

              v63 = *&v253.__r_.__value_.__l.__data_;
              v51[2] = v253.__r_.__value_.__r.__words[2];
              *v51 = v63;
              *(&v253.__r_.__value_.__s + 23) = 0;
              v253.__r_.__value_.__s.__data_[0] = 0;
              *(v51 + 6) = v254;
            }

            if ((SHIBYTE(v253.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_108;
            }

            v60 = v253.__r_.__value_.__r.__words[0];
            goto LABEL_107;
          }
        }

        if (v32 < 0)
        {
          std::string::__init_copy_ctor_external(v267, v33, *(&v33 + 1));
        }

        else
        {
          *v267 = __p;
        }

        *&v267[24] = v13;
        v43 = v259[1];
        if (v259[1] >= v260)
        {
          v45 = (v259[1] - v259[0]) >> 5;
          v46 = v45 + 1;
          if ((v45 + 1) >> 59)
          {
            goto LABEL_345;
          }

          v47 = v260 - v259[0];
          if ((v260 - v259[0]) >> 4 > v46)
          {
            v46 = v47 >> 4;
          }

          if (v47 >= 0x7FFFFFFFFFFFFFE0)
          {
            v48 = 0x7FFFFFFFFFFFFFFLL;
          }

          else
          {
            v48 = v46;
          }

          *&v266 = &v261;
          if (v48)
          {
            v49 = grl::zone_mallocator::instance(v14);
            v50 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v49, v48);
          }

          else
          {
            v50 = 0;
          }

          v53 = &v50[32 * v45];
          v54 = &v50[32 * v48];
          v55 = *v267;
          *(v53 + 2) = *&v267[16];
          *v53 = v55;
          memset(v267, 0, 24);
          *(v53 + 6) = *&v267[24];
          v56 = v53 + 32;
          v57 = &v53[-(v259[1] - v259[0])];
          memcpy(v57, v259[0], v259[1] - v259[0]);
          v58 = v259[0];
          v59 = v260;
          v259[0] = v57;
          v259[1] = v56;
          v260 = v54;
          *&buf[16] = v58;
          *&buf[24] = v59;
          *buf = v58;
          *&buf[8] = v58;
          v14 = std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
          v259[1] = v56;
          if ((v267[23] & 0x80000000) == 0)
          {
            goto LABEL_108;
          }

          goto LABEL_65;
        }

        v44 = *v267;
        *(v259[1] + 2) = *&v267[16];
        *v43 = v44;
        v43[6] = *&v267[24];
        v259[1] = v43 + 8;
      }

      else
      {
        if (v32 < 0)
        {
          std::string::__init_copy_ctor_external(v267, v33, *(&v33 + 1));
        }

        else
        {
          *v267 = __p;
        }

        *&v267[24] = v13;
        v71 = v248;
        if (v248 >= *(&v248 + 1))
        {
          v73 = (v248 - __src) >> 5;
          v74 = v73 + 1;
          if ((v73 + 1) >> 59)
          {
            goto LABEL_345;
          }

          v75 = *(&v248 + 1) - __src;
          if ((*(&v248 + 1) - __src) >> 4 > v74)
          {
            v74 = v75 >> 4;
          }

          if (v75 >= 0x7FFFFFFFFFFFFFE0)
          {
            v76 = 0x7FFFFFFFFFFFFFFLL;
          }

          else
          {
            v76 = v74;
          }

          *&v266 = &v249;
          if (v76)
          {
            v77 = grl::zone_mallocator::instance(v14);
            v78 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v77, v76);
          }

          else
          {
            v78 = 0;
          }

          v95 = &v78[32 * v73];
          v96 = &v78[32 * v76];
          v97 = *v267;
          *(v95 + 2) = *&v267[16];
          *v95 = v97;
          memset(v267, 0, 24);
          *(v95 + 6) = *&v267[24];
          v98 = v95 + 32;
          v99 = &v95[-(v248 - __src)];
          memcpy(v99, __src, v248 - __src);
          v100 = __src;
          v101 = *(&v248 + 1);
          __src = v99;
          *&v248 = v98;
          *(&v248 + 1) = v96;
          *&buf[16] = v100;
          *&buf[24] = v101;
          *buf = v100;
          *&buf[8] = v100;
          v14 = std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
          *&v248 = v98;
          if ((v267[23] & 0x80000000) == 0)
          {
            goto LABEL_108;
          }

LABEL_65:
          v60 = *v267;
LABEL_107:
          operator delete(v60);
          goto LABEL_108;
        }

        v72 = *v267;
        *(v248 + 16) = *&v267[16];
        *v71 = v72;
        *(v71 + 24) = *&v267[24];
        *&v248 = v71 + 32;
      }

LABEL_108:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (++v23 == v244)
      {
        v30 = *v259;
        v17 = v238;
LABEL_185:
        v167 = v30;
        v168 = *(&v30 + 1) - v30;
        v169 = (*(&v30 + 1) - v30) >> 5;
        if (v169 >= 1)
        {
          v170 = v248;
          if (*(&v248 + 1) - v248 < v168)
          {
            v171 = v169 + ((v248 - __src) >> 5);
            if (!(v171 >> 59))
            {
              v172 = (v248 - __src) >> 5;
              v173 = *(&v248 + 1) - __src;
              if ((*(&v248 + 1) - __src) >> 4 > v171)
              {
                v171 = v173 >> 4;
              }

              if (v173 >= 0x7FFFFFFFFFFFFFE0)
              {
                v174 = 0x7FFFFFFFFFFFFFFLL;
              }

              else
              {
                v174 = v171;
              }

              *&v266 = &v249;
              if (v174)
              {
                v175 = grl::zone_mallocator::instance(v14);
                v176 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v175, v174);
              }

              else
              {
                v176 = 0;
              }

              v181 = 0;
              v182 = &v176[32 * v172];
              *buf = v176;
              *&buf[8] = v182;
              *&buf[16] = v182;
              *&buf[24] = &v176[32 * v174];
              do
              {
                v183 = &v182[v181];
                v184 = (v167 + v181);
                if (*(v167 + v181 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(v183, *v184, *(v184 + 1));
                }

                else
                {
                  v185 = *v184;
                  v183->__r_.__value_.__r.__words[2] = *(v184 + 2);
                  *&v183->__r_.__value_.__l.__data_ = v185;
                }

                *&v182[v181 + 24] = *(v167 + v181 + 24);
                v181 += 32;
              }

              while (v168 != v181);
              *&buf[16] = &v182[v168];
              memcpy(&v182[v168], v170, v248 - v170);
              *&buf[16] += v248 - v170;
              *&v248 = v170;
              v186 = v170 - __src;
              v187 = (*&buf[8] - (v170 - __src));
              memcpy(v187, __src, v186);
              v188 = __src;
              v189 = *(&v248 + 1);
              __src = v187;
              v248 = *&buf[16];
              *&buf[16] = v188;
              *&buf[24] = v189;
              *buf = v188;
              *&buf[8] = v188;
              std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
              goto LABEL_213;
            }

LABEL_345:
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          if (*(&v30 + 1) != v30)
          {
            v177 = 0;
            do
            {
              v178 = (v167 + v177);
              v179 = &v170[v177];
              if (*(v167 + v177 + 23) < 0)
              {
                std::string::__init_copy_ctor_external(v179, *v178, *(v178 + 1));
              }

              else
              {
                v180 = *v178;
                v179->__r_.__value_.__r.__words[2] = *(v178 + 2);
                *&v179->__r_.__value_.__l.__data_ = v180;
              }

              *&v170[v177 + 24] = *(v167 + v177 + 24);
              v177 += 32;
            }

            while (v167 + v177 != *(&v167 + 1));
            v170 += v177;
          }

          *&v248 = v170;
        }

LABEL_213:
        *buf = v259;
        std::vector<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](buf);
        goto LABEL_214;
      }
    }
  }

  v102 = *(v16 + 368);
  if (!v102)
  {
    goto LABEL_123;
  }

  v103 = v16 + 368;
  do
  {
    v104 = *(v102 + 32);
    v207 = v104 >= a5;
    v105 = v104 < a5;
    if (v207)
    {
      v103 = v102;
    }

    v102 = *(v102 + 8 * v105);
  }

  while (v102);
  if (v103 != v16 + 368 && *(v103 + 32) <= a5)
  {
    std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::vector[abi:nn200100](v267, v103 + 40);
  }

  else
  {
LABEL_123:
    memset(v267, 0, 24);
  }

  v239 = v17;
  v259[0] = 0;
  v259[1] = 0;
  v260 = 0;
  v106 = std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::reserve(v259, v257 - v256);
  v108 = *&v267[8];
  for (i = *v267; i != v108; ++i)
  {
    v109 = *i;
    v110 = v256;
    if (v256 != v257)
    {
      while (*v110 != v109)
      {
        if (++v110 == v257)
        {
          goto LABEL_143;
        }
      }
    }

    if (v110 != v257)
    {
      v111 = v259[1];
      if (v259[1] >= v260)
      {
        v113 = v259[0];
        v114 = v259[1] - v259[0];
        v115 = (v259[1] - v259[0]) >> 2;
        v116 = v115 + 1;
        if ((v115 + 1) >> 62)
        {
LABEL_346:
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v117 = v260 - v259[0];
        if ((v260 - v259[0]) >> 1 > v116)
        {
          v116 = v117 >> 1;
        }

        if (v117 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v118 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v118 = v116;
        }

        *&v266 = &v261;
        if (v118)
        {
          v119 = grl::zone_mallocator::instance(v106);
          v120 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned int>(v119, v118);
          v113 = v259[0];
          v114 = v259[1] - v259[0];
        }

        else
        {
          v120 = 0;
        }

        v121 = &v120[4 * v115];
        v122 = &v120[4 * v118];
        v123 = &v121[-4 * ((v259[1] - v259[0]) >> 2)];
        *v121 = v109;
        v112 = v121 + 4;
        memcpy(v123, v113, v114);
        v124 = v259[0];
        v125 = v260;
        v259[0] = v123;
        v259[1] = v112;
        v260 = v122;
        *&buf[16] = v124;
        *&buf[24] = v125;
        *buf = v124;
        *&buf[8] = v124;
        v106 = std::__split_buffer<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator> &>::~__split_buffer(buf);
      }

      else
      {
        *v259[1] = v109;
        v112 = v111 + 4;
      }

      v259[1] = v112;
    }

LABEL_143:
    ;
  }

  v126 = v256;
  v127 = v257;
  if (v256 != v257)
  {
    v128 = (v16 + 272);
    do
    {
      v129 = *v128;
      if (*v128)
      {
        v130 = *v126;
        v131 = v16 + 272;
        do
        {
          v132 = *(v129 + 28);
          v207 = v132 >= v130;
          v133 = v132 < v130;
          if (v207)
          {
            v131 = v129;
          }

          v129 = *(v129 + 8 * v133);
        }

        while (v129);
        if (v131 != v128 && v130 >= *(v131 + 28))
        {
          v134 = v259[1];
          if (v259[1] >= v260)
          {
            v136 = v259[0];
            v137 = v259[1] - v259[0];
            v138 = (v259[1] - v259[0]) >> 2;
            v139 = v138 + 1;
            if ((v138 + 1) >> 62)
            {
              goto LABEL_346;
            }

            v140 = v260 - v259[0];
            if ((v260 - v259[0]) >> 1 > v139)
            {
              v139 = v140 >> 1;
            }

            if (v140 >= 0x7FFFFFFFFFFFFFFCLL)
            {
              v141 = 0x3FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v141 = v139;
            }

            *&v266 = &v261;
            if (v141)
            {
              v142 = grl::zone_mallocator::instance(v106);
              v143 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned int>(v142, v141);
              v136 = v259[0];
              v137 = v259[1] - v259[0];
            }

            else
            {
              v143 = 0;
            }

            v144 = &v143[4 * v138];
            v145 = &v143[4 * v141];
            v146 = &v144[-4 * ((v259[1] - v259[0]) >> 2)];
            *v144 = v130;
            v135 = v144 + 4;
            memcpy(v146, v136, v137);
            v147 = v259[0];
            v148 = v260;
            v259[0] = v146;
            v259[1] = v135;
            v260 = v145;
            *&buf[16] = v147;
            *&buf[24] = v148;
            *buf = v147;
            *&buf[8] = v147;
            v106 = std::__split_buffer<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator> &>::~__split_buffer(buf);
          }

          else
          {
            *v259[1] = v130;
            v135 = v134 + 4;
          }

          v259[1] = v135;
        }
      }

      ++v126;
    }

    while (v126 != v127);
  }

  __src = 0;
  v248 = 0uLL;
  v149 = v259[0];
  for (j = v259[1]; v149 != j; ++v149)
  {
    grl::codec::IconMapPack::regionNameForID(&v253, v16, *v149);
    __p.__r_.__value_.__r.__words[0] = v253.__r_.__value_.__l.__size_;
    v152 = v253.__r_.__value_.__r.__words[0];
    *(__p.__r_.__value_.__r.__words + 7) = *(&v253.__r_.__value_.__r.__words[1] + 7);
    v153 = HIBYTE(v253.__r_.__value_.__r.__words[2]);
    memset(&v253, 0, sizeof(v253));
    v154 = v248;
    if (v248 >= *(&v248 + 1))
    {
      v156 = (v248 - __src) >> 5;
      v157 = v156 + 1;
      if ((v156 + 1) >> 59)
      {
        goto LABEL_345;
      }

      v158 = *(&v248 + 1) - __src;
      if ((*(&v248 + 1) - __src) >> 4 > v157)
      {
        v157 = v158 >> 4;
      }

      if (v158 >= 0x7FFFFFFFFFFFFFE0)
      {
        v159 = 0x7FFFFFFFFFFFFFFLL;
      }

      else
      {
        v159 = v157;
      }

      *&v266 = &v249;
      if (v159)
      {
        v160 = grl::zone_mallocator::instance(v151);
        v161 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(v160, v159);
      }

      else
      {
        v161 = 0;
      }

      v162 = &v161[32 * v156];
      v163 = &v161[32 * v159];
      *v162 = v152;
      *(v162 + 1) = __p.__r_.__value_.__r.__words[0];
      *(v162 + 15) = *(__p.__r_.__value_.__r.__words + 7);
      v162[23] = v153;
      __p.__r_.__value_.__r.__words[0] = 0;
      *(__p.__r_.__value_.__r.__words + 7) = 0;
      *(v162 + 6) = v13;
      v155 = v162 + 32;
      v164 = &v162[-(v248 - __src)];
      memcpy(v164, __src, v248 - __src);
      v165 = __src;
      v166 = *(&v248 + 1);
      __src = v164;
      *&v248 = v155;
      *(&v248 + 1) = v163;
      *&buf[16] = v165;
      *&buf[24] = v166;
      *buf = v165;
      *&buf[8] = v165;
      std::__split_buffer<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator> &>::~__split_buffer(buf);
    }

    else
    {
      *v248 = v152;
      *(v154 + 8) = __p.__r_.__value_.__r.__words[0];
      *(v154 + 15) = *(__p.__r_.__value_.__r.__words + 7);
      *(v154 + 23) = v153;
      *(v154 + 24) = v13;
      v155 = (v154 + 32);
    }

    *&v248 = v155;
    if (SHIBYTE(v253.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v253.__r_.__value_.__l.__data_);
    }
  }

  std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v259);
  std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](v267);
  v17 = v239;
LABEL_214:
  std::vector<unsigned int,geo::allocator_adapter<unsigned int,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](&v256);
LABEL_215:
  v190 = v243;
  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v17);
  }

  if (SHIBYTE(v263) < 0)
  {
    operator delete(v262);
  }

  v192 = __src;
  v191 = v248;
  if (__src != v248)
  {
    v193 = 0;
    v242 = 0;
    v245 = 0;
    v194 = 0;
    while (1)
    {
      grl::IconManager::retrieveResourcePack(buf, v190, v192, 1);
      v195 = *buf;
      v196 = *&buf[8];
      if (*buf)
      {
        v197 = *&buf[8];
      }

      else
      {
        grl::IconManager::loadResourcePack(buf, v190, v192, 1, a6);
        v195 = *buf;
        v197 = *&buf[8];
        if (v196)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v196);
        }

        if (!v195)
        {
          if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
          }

          v209 = GEOGetGeoResourceLibIconManagerLog::log;
          if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
          {
            v210 = v192;
            if (*(v192 + 23) < 0)
            {
              v210 = *v192;
            }

            *buf = 136315138;
            *&buf[4] = v210;
            _os_log_impl(&dword_1B2754000, v209, OS_LOG_TYPE_ERROR, "No config pack found for key %s", buf, 0xCu);
          }

          v206 = 3;
          goto LABEL_285;
        }
      }

      grl::IconManager::retrieveResourcePack(buf, v190, v192, 0);
      v199 = *buf;
      v198 = *&buf[8];
      if (*buf)
      {
        v200 = *&buf[8];
      }

      else
      {
        grl::IconManager::loadResourcePack(buf, v190, v192, 0, a6);
        v199 = *buf;
        v200 = *&buf[8];
        if (v198)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v198);
        }

        if (!v199)
        {
          if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
          }

          v211 = GEOGetGeoResourceLibIconManagerLog::log;
          if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
          {
            v212 = v192;
            if (*(v192 + 23) < 0)
            {
              v212 = *v192;
            }

            *buf = 136315138;
            *&buf[4] = v212;
            v202 = v211;
            v203 = "No data pack found for key %s";
            v204 = 12;
LABEL_282:
            _os_log_impl(&dword_1B2754000, v202, OS_LOG_TYPE_ERROR, v203, buf, v204);
          }

LABEL_283:
          v206 = 3;
          if (!v200)
          {
            goto LABEL_285;
          }

LABEL_284:
          std::__shared_weak_count::__release_shared[abi:nn200100](v200);
          goto LABEL_285;
        }
      }

      if (*(v195 + 32) != *(v199 + 32))
      {
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
        }

        v201 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          *buf = 0;
          v202 = v201;
          v203 = "Mismatching config and data packs";
          v204 = 2;
          goto LABEL_282;
        }

        goto LABEL_283;
      }

      *buf = &unk_1F2A5F7A0;
      *&buf[8] = 0;
      *&buf[16] = 0;
      buf[24] = 4;
      grl::codec::IconConfigPack::iconRenderItemForKey(v267, v195, a3, buf);
      v205 = *v267;
      if (*v267 && *&buf[16] == *(a3 + 16) && __PAIR64__(*&buf[22], *&buf[20]) == __PAIR64__(*(a3 + 22), *(a3 + 20)) && buf[24] == *(a3 + 24))
      {
        if (v200)
        {
          atomic_fetch_add_explicit(&v200->__shared_owners_, 1uLL, memory_order_relaxed);
        }

        if (v242)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v242);
        }

        if (a8)
        {
          std::string::operator=((a8 + 8), (v199 + 8));
          std::string::operator=((a8 + 32), (v195 + 8));
        }

        v206 = 1;
        v242 = v200;
      }

      else
      {
        v207 = DWORD2(v251) >= *&buf[16];
        if (DWORD2(v251) == *&buf[16])
        {
          v207 = WORD6(v251) >= *&buf[20];
          if (WORD6(v251) == *&buf[20])
          {
            v207 = HIWORD(v251) >= *&buf[22];
            if (HIWORD(v251) == *&buf[22])
            {
              v207 = v252 >= buf[24];
            }
          }
        }

        if (v207)
        {
          v199 = v193;
          v208 = v194;
          v205 = v245;
        }

        else
        {
          v251 = *&buf[8];
          LOBYTE(v252) = buf[24];
          if (v200)
          {
            atomic_fetch_add_explicit(&v200->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          if (v242)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v242);
          }

          v208 = *&v267[8];
          if (*&v267[8])
          {
            atomic_fetch_add_explicit((*&v267[8] + 8), 1uLL, memory_order_relaxed);
          }

          if (v194)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v194);
          }

          if (a8)
          {
            std::string::operator=((a8 + 8), (v199 + 8));
            std::string::operator=((a8 + 32), (v195 + 8));
          }

          v242 = v200;
        }

        if (*&v267[8])
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](*&v267[8]);
        }

        v206 = 0;
        v245 = v205;
        v194 = v208;
        v190 = v243;
      }

      v193 = v199;
      if (v200)
      {
        goto LABEL_284;
      }

LABEL_285:
      if (v197)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v197);
      }

      if (v206 != 3 && v206)
      {
        *buf = &__src;
        std::vector<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](buf);
        v213 = v235;
        if (v194)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v194);
        }

        goto LABEL_293;
      }

      v192 += 4;
      if (v192 == v191)
      {
        goto LABEL_292;
      }
    }
  }

  v193 = 0;
  v242 = 0;
  v194 = 0;
  v245 = 0;
LABEL_292:
  *v267 = v245;
  *&v267[8] = v194;
  *buf = &__src;
  std::vector<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator>>::__destroy_vector::operator()[abi:nn200100](buf);
  v213 = v235;
LABEL_293:
  v214 = *&v267[8];
  if (*v267 && v193)
  {
    v215 = *(a4 + 13);
    if (v215 == (a4 + 112))
    {
LABEL_307:
      v254 = 0;
      v253.__r_.__value_.__r.__words[0] = &v253.__r_.__value_.__l.__size_;
      v253.__r_.__value_.__l.__size_ = 0;
      v252 = 0;
      v250 = &v251;
      *&v251 = 0;
      if (*(v190 + 496))
      {
        *buf = &unk_1F2A5F4E8;
        *&buf[8] = &v250;
        *&buf[24] = buf;
        grl::codec::IconRenderItem::forEachTextLayer(*v267, a4, buf);
        std::__function::__value_func<void ()(unsigned short,grl::codec::TextLayerData const&)>::~__value_func[abi:nn200100](buf);
        if (v252)
        {
          v220 = v250;
          if (v250 != &v251)
          {
            do
            {
              grl::FontManager::fontForKey(buf, *(v190 + 496), v220 + 2, 0.0);
              v222 = v253.__r_.__value_.__l.__size_;
              p_size = &v253.__r_.__value_.__l.__size_;
              v224 = &v253.__r_.__value_.__l.__size_;
              if (v253.__r_.__value_.__l.__size_)
              {
                while (1)
                {
                  while (1)
                  {
                    p_size = v222;
                    v221 = std::operator<=>[abi:nn200100]<char,std::char_traits<char>,std::allocator<char>>(v220 + 4, (v222 + 32));
                    if ((v221 & 0x80) == 0)
                    {
                      break;
                    }

                    v222 = *p_size;
                    v224 = p_size;
                    if (!*p_size)
                    {
                      goto LABEL_316;
                    }
                  }

                  v221 = std::operator<=>[abi:nn200100]<char,std::char_traits<char>,std::allocator<char>>(p_size + 4, v220 + 4);
                  if ((v221 & 0x80) == 0)
                  {
                    break;
                  }

                  v224 = p_size + 1;
                  v222 = p_size[1];
                  if (!v222)
                  {
                    goto LABEL_316;
                  }
                }

                v226 = p_size;
              }

              else
              {
LABEL_316:
                v225 = grl::zone_mallocator::instance(v221);
                geo::read_write_lock::read_lock((v225 + 32));
                v226 = malloc_type_zone_malloc(*v225, 0x50uLL, 0x10F20409B65940FuLL);
                atomic_fetch_add((v225 + 24), 1u);
                geo::read_write_lock::unlock((v225 + 32));
                if (*(v220 + 55) < 0)
                {
                  std::string::__init_copy_ctor_external((v226 + 32), *(v220 + 4), *(v220 + 5));
                }

                else
                {
                  v227 = v220[2];
                  *(v226 + 6) = *(v220 + 6);
                  *(v226 + 2) = v227;
                }

                *(v226 + 7) = &unk_1F2A5F810;
                *(v226 + 8) = 0;
                *v226 = 0;
                *(v226 + 1) = 0;
                *(v226 + 2) = p_size;
                *v224 = v226;
                v228 = v226;
                if (*v253.__r_.__value_.__l.__data_)
                {
                  v253.__r_.__value_.__r.__words[0] = *v253.__r_.__value_.__l.__data_;
                  v228 = *v224;
                }

                std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v253.__r_.__value_.__l.__size_, v228);
                ++v254;
              }

              v229 = *(v226 + 8);
              if (v229)
              {
                CFRelease(v229);
              }

              *(v226 + 8) = *&buf[8];
              v230 = *(v220 + 1);
              if (v230)
              {
                do
                {
                  v231 = v230;
                  v230 = *v230;
                }

                while (v230);
              }

              else
              {
                do
                {
                  v231 = *(v220 + 2);
                  v37 = *v231 == v220;
                  v220 = v231;
                }

                while (!v37);
              }

              v220 = v231;
              v190 = v243;
            }

            while (v231 != &v251);
          }
        }
      }

      if (v242)
      {
        atomic_fetch_add_explicit(&v242->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      *a1 = 0;
      a1[1] = 0;
      if (*(a7 + 24))
      {
        operator new();
      }

      operator new();
    }

    while (1)
    {
      v216 = 0xFFFFFFFF00000000;
      if (*(*v267 + 152))
      {
        v216 = *(*v267 + 156);
      }

      v217 = *(v215 + 63);
      if ((v217 & 0x8000000000000000) != 0)
      {
        v217 = v215[6];
      }

      if (v217 > SHIDWORD(v216))
      {
        break;
      }

      v218 = v215[1];
      if (v218)
      {
        do
        {
          v219 = v218;
          v218 = *v218;
        }

        while (v218);
      }

      else
      {
        do
        {
          v219 = v215[2];
          v37 = *v219 == v215;
          v215 = v219;
        }

        while (!v37);
      }

      v215 = v219;
      if (v219 == (a4 + 112))
      {
        goto LABEL_307;
      }
    }

    *&buf[8] = *(a3 + 8);
    buf[24] = *(a3 + 24);
    *&buf[16] = v216;
    v232 = v216 - 0x61C8864680B583EBLL;
    v233 = (*&buf[22] + ((((v232 << 6) + (v232 >> 2) + *&buf[20] - 0x61C8864680B583EBLL) ^ v232) << 6) + ((((v232 << 6) + (v232 >> 2) + *&buf[20] - 0x61C8864680B583EBLL) ^ v232) >> 2) - 0x61C8864680B583EBLL) ^ ((v232 << 6) + (v232 >> 2) + *&buf[20] - 0x61C8864680B583EBLL) ^ v232;
    *buf = &unk_1F2A5F7A0;
    *&buf[8] = (buf[24] + (v233 << 6) + (v233 >> 2) - 0x61C8864680B583EBLL) ^ v233;
    *&v267[24] = 0;
    *v267 = &v267[8];
    *&v267[8] = 0;
    grl::IconManager::image(a1, v190, buf, a4, v213, a6, v267, 0, a9);
    std::__tree<std::__value_type<unsigned short,grl::ImageProvider>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageProvider>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::ImageProvider>,grl::zone_mallocator>>::destroy(*&v267[8]);
  }

  else
  {
    *a1 = 0;
    a1[1] = 0;
  }

  if (v242)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v242);
  }

  if (v214)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v214);
  }
}

void std::__shared_ptr_pointer<grl::IconImage  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::IconManager::loadResourcePack(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t **a5)
{
  v107 = *MEMORY[0x1E69E9840];
  std::__shared_mutex_base::lock_shared((a2 + 272));
  v9 = (a2 + 448);
  v10 = *(a2 + 448);
  if (!v10)
  {
    goto LABEL_9;
  }

  v11 = (a2 + 448);
  do
  {
    v12 = std::operator<=>[abi:nn200100]<std::string,float,std::string,float>((v10 + 4), a3);
    if (v12 != 255)
    {
      v11 = v10;
    }

    v10 = v10[v12 == 255];
  }

  while (v10);
  if (v11 == v9 || std::operator<=>[abi:nn200100]<std::string,float,std::string,float>(a3, (v11 + 4)) == 0xFF)
  {
LABEL_9:
    std::__shared_mutex_base::unlock_shared((a2 + 272));
    std::__shared_mutex_base::lock((a2 + 272));
    v14 = *v9;
    v15 = (a2 + 448);
    if (*v9)
    {
      while (1)
      {
        while (1)
        {
          v9 = v14;
          v13 = std::operator<=>[abi:nn200100]<std::string,float,std::string,float>(a3, (v14 + 4));
          if (v13 != 0xFF)
          {
            break;
          }

          v14 = *v9;
          v15 = v9;
          if (!*v9)
          {
            goto LABEL_15;
          }
        }

        v13 = std::operator<=>[abi:nn200100]<std::string,float,std::string,float>((v9 + 4), a3);
        if (v13 != 0xFF)
        {
          break;
        }

        v15 = v9 + 1;
        v14 = v9[1];
        if (!v14)
        {
          goto LABEL_15;
        }
      }

      v11 = v9;
    }

    else
    {
LABEL_15:
      v16 = grl::zone_mallocator::instance(v13);
      geo::read_write_lock::read_lock((v16 + 32));
      v11 = malloc_type_zone_malloc(*v16, 0x80uLL, 0x103204099827942uLL);
      atomic_fetch_add((v16 + 24), 1u);
      geo::read_write_lock::unlock((v16 + 32));
      if (*(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((v11 + 4), *a3, *(a3 + 8));
      }

      else
      {
        v17 = *a3;
        v11[6] = *(a3 + 16);
        *(v11 + 2) = v17;
      }

      *(v11 + 14) = *(a3 + 24);
      v11[8] = 850045863;
      *(v11 + 9) = 0u;
      *(v11 + 11) = 0u;
      *(v11 + 13) = 0u;
      v11[15] = 0;
      *v11 = 0;
      v11[1] = 0;
      v11[2] = v9;
      *v15 = v11;
      v18 = **(a2 + 440);
      v19 = v11;
      if (v18)
      {
        *(a2 + 440) = v18;
        v19 = *v15;
      }

      std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(*(a2 + 448), v19);
      ++*(a2 + 464);
    }

    std::__shared_mutex_base::unlock((a2 + 272));
  }

  else
  {
    std::__shared_mutex_base::unlock_shared((a2 + 272));
  }

  std::mutex::lock(v11 + 1);
  grl::IconManager::retrieveResourcePack(&v95, a2, a3, a4);
  if (v95)
  {
    v20 = v96;
    *a1 = v95;
    a1[1] = v20;
    goto LABEL_191;
  }

  v89 = a1;
  std::string::basic_string[abi:nn200100]<0>(&__p, "");
  LODWORD(v100) = 0;
  v22 = **a5;
  v21 = (*a5)[1];
  if (v22 != v21)
  {
    v90 = 0;
    v92 = a4;
    do
    {
      v23 = *(v22 + 23);
      if ((v23 & 0x80u) == 0)
      {
        v24 = v22;
      }

      else
      {
        v24 = *v22;
      }

      if ((v23 & 0x80u) != 0)
      {
        v23 = *(v22 + 8);
      }

      if (v23)
      {
        v25 = &v24[v23];
        while (v23)
        {
          v26 = *--v25;
          --v23;
          if (v26 == 46)
          {
            v27 = v25 - v24 + 1;
            if (v27 <= 1)
            {
              break;
            }

            v28 = std::string::basic_string(&v105, v22, v27, 0xFFFFFFFFFFFFFFFFLL, &v98);
            goto LABEL_38;
          }
        }
      }

      v28 = std::string::basic_string[abi:nn200100]<0>(&v105, "");
LABEL_38:
      v29 = std::string::compare(v28, off_1E7B58490[a4]);
      v30 = v29;
      if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v105.__r_.__value_.__l.__data_);
        if (v30)
        {
          goto LABEL_113;
        }
      }

      else if (v29)
      {
        goto LABEL_113;
      }

      v31 = std::string::find(v22, 64, 0);
      if (v31 == -1)
      {
        v31 = std::string::find(v22, 46, 0);
      }

      std::string::basic_string(&__str, v22, 0, v31, &v105);
      v32 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      v33 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      size = __str.__r_.__value_.__l.__size_;
      v34 = __str.__r_.__value_.__r.__words[0];
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v37 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }

      else
      {
        v37 = __str.__r_.__value_.__l.__size_;
        p_str = __str.__r_.__value_.__r.__words[0];
      }

      if (v37)
      {
        do
        {
          if (p_str->__r_.__value_.__s.__data_[0] == 95)
          {
            p_str->__r_.__value_.__s.__data_[0] = 32;
          }

          p_str = (p_str + 1);
          --v37;
        }

        while (v37);
        v32 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        size = __str.__r_.__value_.__l.__size_;
        v34 = __str.__r_.__value_.__r.__words[0];
        v33 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }

      if (v33 >= 0)
      {
        v38 = &__str;
      }

      else
      {
        v38 = v34;
      }

      if (v33 >= 0)
      {
        v39 = v32;
      }

      else
      {
        v39 = size;
      }

      if (v39)
      {
        v40 = v38 + v39;
        v41 = v39;
        while (v41)
        {
          v42 = *--v40;
          --v41;
          if (v42 == 45)
          {
            v43 = v40 - v38;
            if (v40 - v38 == -1)
            {
              break;
            }

            if (v43 + 1 >= v39)
            {
              v45 = 0;
            }

            else
            {
              v44 = std::string::basic_string(&v105, &__str, v43 + 1, 0xFFFFFFFFFFFFFFFFLL, &v98);
              if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
              {
                v62 = v105.__r_.__value_.__r.__words[0];
                v45 = atoi(v105.__r_.__value_.__l.__data_);
                operator delete(v62);
              }

              else
              {
                v45 = atoi(v44);
              }
            }

            std::string::basic_string(&v105, &__str, 0, v43, &v98);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__str.__r_.__value_.__l.__data_);
            }

            __str = v105;
            v32 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
            size = v105.__r_.__value_.__l.__size_;
            v34 = v105.__r_.__value_.__r.__words[0];
            v33 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
            goto LABEL_67;
          }
        }
      }

      v45 = 0;
LABEL_67:
      v46 = *(a3 + 23);
      if (v46 >= 0)
      {
        v47 = *(a3 + 23);
      }

      else
      {
        v47 = *(a3 + 8);
      }

      if (v46 >= 0)
      {
        v48 = a3;
      }

      else
      {
        v48 = *a3;
      }

      if (v33 >= 0)
      {
        v49 = v32;
      }

      else
      {
        v49 = size;
      }

      if (v33 >= 0)
      {
        v50 = &__str;
      }

      else
      {
        v50 = v34;
      }

      if (v49 >= v47)
      {
        v51 = v47;
      }

      else
      {
        v51 = v49;
      }

      v52 = memcmp(v48, v50, v51);
      if (v49 == v47 && v52 == 0)
      {
        v54 = *(a3 + 24);
        v55 = std::string::find(v22, 64, 0);
        if (v55 == -1)
        {
          v59 = 1.0;
          a4 = v92;
        }

        else
        {
          v56 = v55;
          v57 = std::string::find(v22, 120, v55);
          std::string::basic_string(&v105, v22, v56 + 1, v57 - (v56 + 1), &v98);
          if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          {
            v58 = &v105;
          }

          else
          {
            v58 = v105.__r_.__value_.__r.__words[0];
          }

          std::string::basic_string[abi:nn200100]<0>(&v98, v58);
          v59 = std::stof(&v98, 0);
          if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v98.__r_.__value_.__l.__data_);
          }

          a4 = v92;
          if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v105.__r_.__value_.__l.__data_);
          }
        }

        if (v59 <= ceilf(v54))
        {
          if (v59 > *&v100 || (v59 == *&v100 ? (v60 = v45 < v90) : (v60 = 1), !v60))
          {
            if (*(v22 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v105, *v22, *(v22 + 8));
            }

            else
            {
              v61 = *v22;
              v105.__r_.__value_.__r.__words[2] = *(v22 + 16);
              *&v105.__r_.__value_.__l.__data_ = v61;
            }

            *&v106 = v59;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__p.__r_.__value_.__l.__data_);
              v59 = *&v106;
            }

            __p = v105;
            *&v100 = v59;
            v90 = v45;
          }
        }

        if ((*(&__str.__r_.__value_.__s + 23) & 0x80) == 0)
        {
          goto LABEL_113;
        }

LABEL_112:
        operator delete(__str.__r_.__value_.__l.__data_);
        goto LABEL_113;
      }

      a4 = v92;
      if (v33 < 0)
      {
        goto LABEL_112;
      }

LABEL_113:
      v22 += 24;
    }

    while (v22 != v21);
  }

  v63 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v63 = __p.__r_.__value_.__l.__size_;
  }

  if (!v63)
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
    }

    v64 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      v65 = off_1E7B58478[a4];
      if (*(a3 + 23) >= 0)
      {
        v66 = a3;
      }

      else
      {
        v66 = *a3;
      }

      v67 = *(a3 + 24);
      LODWORD(v105.__r_.__value_.__l.__data_) = 136315650;
      *(v105.__r_.__value_.__r.__words + 4) = v65;
      WORD2(v105.__r_.__value_.__r.__words[1]) = 2080;
      *(&v105.__r_.__value_.__r.__words[1] + 6) = v66;
      HIWORD(v105.__r_.__value_.__r.__words[2]) = 2048;
      v106 = v67;
      _os_log_impl(&dword_1B2754000, v64, OS_LOG_TYPE_ERROR, "No packs of type %s available for key: [%s, %f]", &v105, 0x20u);
    }
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v105, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  else
  {
    v105 = __p;
  }

  v68 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
  if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
  {
    v68 = v105.__r_.__value_.__l.__size_;
  }

  if (v68)
  {
    (*(**(a2 + 8) + 56))(&__str);
    v69 = __str.__r_.__value_.__r.__words[0];
    if (__str.__r_.__value_.__r.__words[0])
    {
      v70 = __str.__r_.__value_.__l.__size_;
      if (__str.__r_.__value_.__l.__size_)
      {
        atomic_fetch_add_explicit((__str.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        grl::IconManager::decodePack(&v93, a2, v69, v70, a3, a4);
        std::__shared_weak_count::__release_shared[abi:nn200100](v70);
      }

      else
      {
        grl::IconManager::decodePack(&v93, a2, __str.__r_.__value_.__l.__data_, 0, a3, a4);
      }

      if (v93)
      {
        v82 = v94;
        *v89 = v93;
        v89[1] = v82;
      }

      else
      {
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
        }

        v83 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          v84 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v105 : v105.__r_.__value_.__r.__words[0];
          v85 = *(a3 + 23) >= 0 ? a3 : *a3;
          v86 = *(a3 + 24);
          v87 = off_1E7B58478[a4];
          grl::buildStringFromResourceNames(&v98, **a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3));
          v88 = (v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v98 : v98.__r_.__value_.__r.__words[0];
          LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
          *(__p.__r_.__value_.__r.__words + 4) = v84;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(&__p.__r_.__value_.__r.__words[1] + 6) = v85;
          HIWORD(__p.__r_.__value_.__r.__words[2]) = 2048;
          v100 = v86;
          v101 = 2080;
          v102 = v87;
          v103 = 2080;
          v104 = v88;
          _os_log_impl(&dword_1B2754000, v83, OS_LOG_TYPE_ERROR, "Failed to decode pack for packName:%s packKey:%s.%f packType:%s resourceNames:%s", &__p, 0x34u);
          if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v98.__r_.__value_.__l.__data_);
          }
        }

        *v89 = 0;
        v89[1] = 0;
        if (v94)
        {
          std::__shared_weak_count::__release_shared[abi:nn200100](v94);
        }
      }
    }

    else
    {
      if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
      }

      v76 = GEOGetGeoResourceLibIconManagerLog::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
      {
        v77 = (v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v105 : v105.__r_.__value_.__r.__words[0];
        v78 = *(a3 + 23) >= 0 ? a3 : *a3;
        v79 = *(a3 + 24);
        v80 = off_1E7B58478[a4];
        grl::buildStringFromResourceNames(&v98, **a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3));
        v81 = (v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v98 : v98.__r_.__value_.__r.__words[0];
        LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
        *(__p.__r_.__value_.__r.__words + 4) = v77;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
        *(&__p.__r_.__value_.__r.__words[1] + 6) = v78;
        HIWORD(__p.__r_.__value_.__r.__words[2]) = 2048;
        v100 = v79;
        v101 = 2080;
        v102 = v80;
        v103 = 2080;
        v104 = v81;
        _os_log_impl(&dword_1B2754000, v76, OS_LOG_TYPE_ERROR, "Failed to stream resource for packName:%s packKey:%s.%f packType:%s resourceNames:%s", &__p, 0x34u);
        if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v98.__r_.__value_.__l.__data_);
        }
      }

      *v89 = 0;
      v89[1] = 0;
    }

    if (__str.__r_.__value_.__l.__size_)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](__str.__r_.__value_.__l.__size_);
    }
  }

  else
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
    }

    v71 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      v72 = *(a3 + 23) >= 0 ? a3 : *a3;
      v73 = *(a3 + 24);
      v74 = off_1E7B58478[a4];
      grl::buildStringFromResourceNames(&v98, **a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3));
      v75 = (v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v98 : v98.__r_.__value_.__r.__words[0];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
      *(__p.__r_.__value_.__r.__words + 4) = v72;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
      *(&__p.__r_.__value_.__r.__words[1] + 6) = v73;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      v100 = *&v74;
      v101 = 2080;
      v102 = v75;
      _os_log_impl(&dword_1B2754000, v71, OS_LOG_TYPE_ERROR, "Failed to resolve packName for packKey:%s.%f packType:%s with resourceNames:%s", &__p, 0x2Au);
      if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v98.__r_.__value_.__l.__data_);
      }
    }

    *v89 = 0;
    v89[1] = 0;
  }

  if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v105.__r_.__value_.__l.__data_);
  }

  if (v96)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v96);
  }

LABEL_191:
  std::mutex::unlock(v11 + 1);
}

void grl::IconManager::decodePack(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, int a6)
{
  if (a6 == 2)
  {
    if (a4)
    {
      atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (a3)
    {
      operator new();
    }

    v8 = 0uLL;
    v40 = 0uLL;
    if (a4)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a4);
      v8 = 0uLL;
    }

    if (v8)
    {
      if (*(a2 + 88))
      {
LABEL_70:
        *a1 = v8;
        return;
      }

      std::__shared_mutex_base::lock_shared((a2 + 104));
      v17 = *(a2 + 96);
      if (!v17)
      {
        goto LABEL_68;
      }

      std::mutex::lock((v17 + 176));
      v19 = *(a2 + 96);
      v21 = v19 + 1;
      v20 = v19[1];
      if (v20)
      {
        while (1)
        {
          while (1)
          {
            v21 = v20;
            v18 = std::operator<=>[abi:nn200100]<std::string,float,std::string,float>(a5, (v20 + 4));
            if (v18 != 0xFF)
            {
              break;
            }

            v20 = *v21;
            v22 = v21;
            if (!*v21)
            {
              goto LABEL_51;
            }
          }

          v18 = std::operator<=>[abi:nn200100]<std::string,float,std::string,float>((v21 + 4), a5);
          if (v18 != 0xFF)
          {
            break;
          }

          v22 = v21 + 1;
          v20 = v21[1];
          if (!v20)
          {
            goto LABEL_51;
          }
        }

        v32 = v21;
      }

      else
      {
        v22 = v19 + 1;
LABEL_51:
        v31 = grl::zone_mallocator::instance(v18);
        geo::read_write_lock::read_lock((v31 + 32));
        v32 = malloc_type_zone_malloc(*v31, 0x50uLL, 0x1032040911F0A16uLL);
        atomic_fetch_add((v31 + 24), 1u);
        geo::read_write_lock::unlock((v31 + 32));
        if (*(a5 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((v32 + 32), *a5, *(a5 + 8));
        }

        else
        {
          v33 = *a5;
          *(v32 + 6) = *(a5 + 16);
          *(v32 + 2) = v33;
        }

        *(v32 + 14) = *(a5 + 24);
        *(v32 + 8) = 0;
        *(v32 + 9) = 0;
        *v32 = 0;
        *(v32 + 1) = 0;
        *(v32 + 2) = v21;
        *v22 = v32;
        v34 = **v19;
        v35 = v32;
        if (v34)
        {
          *v19 = v34;
          v35 = *v22;
        }

        std::__tree_balance_after_insert[abi:nn200100]<std::__tree_node_base<void *> *>(v19[1], v35);
        v19[3] = (v19[3] + 1);
      }

      v36 = *(v32 + 9);
      *(v32 + 4) = 0uLL;
      if (v36)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v36);
      }

      v37 = (v17 + 176);
      goto LABEL_67;
    }
  }

  else if (a6 == 1)
  {
    if (a4)
    {
      atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (a3)
    {
      operator new();
    }

    v8 = 0uLL;
    v40 = 0uLL;
    if (a4)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a4);
      v8 = 0uLL;
    }

    if (v8)
    {
      grl::codec::IconConfigPack::setLocationCacheSize(v8, *(a2 + 480));
      if ((*(a2 + 88) & 1) == 0)
      {
        std::__shared_mutex_base::lock_shared((a2 + 104));
        v9 = *(a2 + 96);
        if (v9)
        {
          std::mutex::lock((v9 + 304));
          v10 = *(a2 + 96);
          v11 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(v10 + 152, (v10 + 112), a5);
          if (v10 + 152 == v11)
          {
            v12 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>((v10 + 112), a5);
            if (v12)
            {
              v13 = v12;
              v14 = *(v12 + 6);
              v16 = *v14;
              v15 = v14[1];
              *(v16 + 8) = v15;
              *v15 = v16;
              --*(v10 + 168);
              std::__destroy_at[abi:nn200100]<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>,0>((v14 + 2));
              operator delete(v14);
              std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase((v10 + 112), v13);
            }

            operator new();
          }

          v38 = *(v11 + 56);
          *(v11 + 48) = 0uLL;
          if (v38)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v38);
          }

          v37 = (v9 + 304);
LABEL_67:
          std::mutex::unlock(v37);
          goto LABEL_68;
        }

        goto LABEL_68;
      }

      goto LABEL_69;
    }
  }

  else
  {
    if (a4)
    {
      atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (a3)
    {
      operator new();
    }

    v8 = 0uLL;
    v40 = 0uLL;
    if (a4)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](a4);
      v8 = 0uLL;
    }

    if (v8)
    {
      grl::codec::IconDataPack::setNumberOfAtlasPages(v8, *(a2 + 472));
      if ((*(a2 + 88) & 1) == 0)
      {
        std::__shared_mutex_base::lock_shared((a2 + 104));
        v23 = *(a2 + 96);
        if (v23)
        {
          std::mutex::lock((v23 + 240));
          v24 = *(a2 + 96);
          v25 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(v24 + 80, (v24 + 40), a5);
          if (v24 + 80 == v25)
          {
            v26 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>((v24 + 40), a5);
            if (v26)
            {
              v27 = v26;
              v28 = *(v26 + 6);
              v30 = *v28;
              v29 = v28[1];
              *(v30 + 8) = v29;
              *v29 = v30;
              --*(v24 + 96);
              std::__destroy_at[abi:nn200100]<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>,0>((v28 + 2));
              operator delete(v28);
              std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase((v24 + 40), v27);
            }

            operator new();
          }

          v39 = *(v25 + 56);
          *(v25 + 48) = 0uLL;
          if (v39)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v39);
          }

          v37 = (v23 + 240);
          goto LABEL_67;
        }

LABEL_68:
        std::__shared_mutex_base::unlock_shared((a2 + 104));
      }

LABEL_69:
      v8 = v40;
      goto LABEL_70;
    }
  }

  *a1 = 0;
  *(a1 + 8) = 0;
  if (*(&v8 + 1))
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](*(&v8 + 1));
  }
}

void std::__shared_ptr_emplace<grl::codec::IconMapPack>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F920;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<grl::codec::IconConfigPack>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F8E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::__shared_ptr_emplace<grl::codec::IconDataPack>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5F8B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::IconManager::loadGlobalResourcePack(void *a1, uint64_t a2, uint64_t a3)
{
  (*(**(a2 + 8) + 40))(&v6);
  grl::IconManager::loadResourcePack(a1, a2, a3, 2, &v6);
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v7);
  }
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::pair<std::string,float>>(uint64_t a1, uint64_t a2)
{
  geo::read_write_lock::read_lock((a1 + 32));
  v4 = malloc_type_zone_malloc(*a1, 32 * a2, 0x10120405C87E9CEuLL);
  atomic_fetch_add((a1 + 24), 1u);
  geo::read_write_lock::unlock((a1 + 32));
  return v4;
}

float std::vector<std::pair<std::string,float>,geo::allocator_adapter<std::pair<std::string,float>,grl::zone_mallocator>>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v4 = *(a1 + 8);
  v5 = a2 + v4 - a4;
  if (v5 >= a3)
  {
    v7 = *(a1 + 8);
  }

  else
  {
    v6 = (a2 + v4 - a4);
    v7 = *(a1 + 8);
    do
    {
      v8 = *v6;
      *(v7 + 16) = *(v6 + 2);
      *v7 = v8;
      *(v6 + 1) = 0;
      *(v6 + 2) = 0;
      *v6 = 0;
      result = *(v6 + 6);
      *(v7 + 24) = result;
      v6 += 2;
      v7 += 32;
    }

    while (v6 < a3);
  }

  *(a1 + 8) = v7;
  if (v4 != a4)
  {
    v10 = 0;
    v11 = a4 - v4;
    do
    {
      v12 = (v4 + v10 - 32);
      if (*(v4 + v10 - 9) < 0)
      {
        operator delete(*v12);
      }

      v13 = (v5 + v10 - 32);
      v14 = *v13;
      *(v4 + v10 - 16) = *(v5 + v10 - 16);
      *v12 = v14;
      *(v5 + v10 - 9) = 0;
      *v13 = 0;
      result = *(v5 + v10 - 8);
      *(v4 + v10 - 8) = result;
      v10 -= 32;
    }

    while (v11 != v10);
  }

  return result;
}

void grl::IconManager::imageForDataID(void *a1, uint64_t a2, const unsigned int *a3, grl::IconModifiers *a4, float *a5)
{
  v25 = *MEMORY[0x1E69E9840];
  v10 = ceilf(*a5);
  std::string::basic_string[abi:nn200100]<0>(&__p, "Default");
  *&v24 = v10;
  grl::IconManager::retrieveResourcePack(&v19, a2, &__p, 2);
  v12 = v19;
  v11 = v20[0];
  if (v19)
  {
    v13 = v20[0];
  }

  else
  {
    grl::IconManager::loadGlobalResourcePack(&v19, a2, &__p);
    v12 = v19;
    v13 = v20[0];
    if (v11)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v11);
    }

    if (!v12)
    {
      goto LABEL_25;
    }
  }

  v14 = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(v12 + 19, a3);
  if (v14)
  {
    v15 = *(v14 + 5);
    if (v15)
    {
LABEL_10:
      if (!v13)
      {
        goto LABEL_12;
      }

      goto LABEL_11;
    }
  }

  v16 = grl::codec::IconMapPack::dataIDFallback(v12, a3);
  if (v16)
  {
    v15 = v16;
    goto LABEL_10;
  }

  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
  }

  v18 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v19) = 67109376;
    HIDWORD(v19) = a3;
    LOWORD(v20[0]) = 2048;
    *(v20 + 2) = v10;
    _os_log_impl(&dword_1B2754000, v18, OS_LOG_TYPE_ERROR, "Failed to find ID for Data Identifier\nData Identifier: %i - Content Scale: %f", &v19, 0x12u);
  }

LABEL_25:
  v15 = 0;
  if (v13)
  {
LABEL_11:
    std::__shared_weak_count::__release_shared[abi:nn200100](v13);
  }

LABEL_12:
  if (v23 < 0)
  {
    operator delete(__p);
    if (v15)
    {
      goto LABEL_14;
    }
  }

  else if (v15)
  {
LABEL_14:
    v24 = 0;
    __p = &v22;
    v22 = 0;
    grl::IconManager::imageForIconID(a1, a2, v15, a4, a5, &__p, 0);
    std::__tree<std::__value_type<unsigned short,grl::ImageProvider>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageProvider>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::ImageProvider>,grl::zone_mallocator>>::destroy(v22);
    return;
  }

  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
  }

  v17 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    LODWORD(__p) = 67109120;
    HIDWORD(__p) = a3;
    _os_log_impl(&dword_1B2754000, v17, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for Data ID: %i", &__p, 8u);
  }

  *a1 = 0;
  a1[1] = 0;
}

void grl::IconManager::imageForDataIDAndText(void *a1, uint64_t a2, const unsigned int *a3, void **a4, grl::IconModifiers *a5, float *a6, _DWORD *a7)
{
  v43 = *MEMORY[0x1E69E9840];
  v14 = ceilf(*a6);
  std::string::basic_string[abi:nn200100]<0>(__p, "Default");
  v38 = v14;
  grl::IconManager::retrieveResourcePack(buf, a2, __p, 2);
  v15 = *buf;
  v16 = *v40;
  if (*buf)
  {
    v17 = *v40;
  }

  else
  {
    grl::IconManager::loadGlobalResourcePack(buf, a2, __p);
    v15 = *buf;
    v17 = *v40;
    if (v16)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v16);
    }

    if (!v15)
    {
      goto LABEL_47;
    }
  }

  v18 = *(v15 + 27);
  if (!v18)
  {
    goto LABEL_22;
  }

  v19 = vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    v20 = a3;
    if (v18 <= a3)
    {
      v20 = a3 % v18;
    }
  }

  else
  {
    v20 = (v18 - 1) & a3;
  }

  v21 = *(*(v15 + 26) + 8 * v20);
  if (!v21 || (v22 = *v21) == 0)
  {
LABEL_22:
    v24 = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(v15 + 19, a3);
    if (v24)
    {
      LODWORD(v22) = *(v24 + 5);
      goto LABEL_24;
    }

LABEL_25:
    v25 = grl::codec::IconMapPack::dataIDFallback(v15, a3);
    if (v25)
    {
      LODWORD(v22) = v25;
      goto LABEL_27;
    }

    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
    }

    v28 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      *buf = 67109376;
      *&buf[4] = a3;
      *v40 = 2048;
      *&v40[2] = v14;
      _os_log_impl(&dword_1B2754000, v28, OS_LOG_TYPE_ERROR, "Failed to find ID for Data Identifier\nData Identifier: %i - Content Scale: %f", buf, 0x12u);
    }

LABEL_47:
    LODWORD(v22) = 0;
    if (v17)
    {
      goto LABEL_28;
    }

    goto LABEL_29;
  }

  while (1)
  {
    v23 = v22[1];
    if (v23 == a3)
    {
      break;
    }

    if (v19.u32[0] > 1uLL)
    {
      if (v23 >= v18)
      {
        v23 %= v18;
      }
    }

    else
    {
      v23 &= v18 - 1;
    }

    if (v23 != v20)
    {
      goto LABEL_22;
    }

LABEL_21:
    v22 = *v22;
    if (!v22)
    {
      goto LABEL_22;
    }
  }

  if (*(v22 + 4) != a3)
  {
    goto LABEL_21;
  }

  v29 = *(a4 + 23);
  if (v29 >= 0)
  {
    v30 = a4;
  }

  else
  {
    v30 = *a4;
  }

  if (v29 >= 0)
  {
    v31 = *(a4 + 23);
  }

  else
  {
    v31 = a4[1];
  }

  std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(buf, v30, v30 + v31, v31);
  v32 = std::__hash_table<std::__hash_value_type<std::string,unsigned long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long long>>>::find<std::string>(v22 + 3, buf);
  if (v32)
  {
    LODWORD(v22) = *(v32 + 12);
  }

  if (v41 < 0)
  {
    v34 = *buf;
    v35 = v32;
    v33 = grl::zone_mallocator::instance(v32);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v33, v34);
    v32 = v35;
  }

  if (!v32)
  {
    goto LABEL_22;
  }

LABEL_24:
  if (!v22)
  {
    goto LABEL_25;
  }

LABEL_27:
  if (v17)
  {
LABEL_28:
    std::__shared_weak_count::__release_shared[abi:nn200100](v17);
  }

LABEL_29:
  if (v37 < 0)
  {
    operator delete(__p[0]);
  }

  if (a7)
  {
    *a7 = v22;
  }

  if (v22)
  {
    v42 = 0;
    *buf = v40;
    *v40 = 0;
    grl::IconManager::imageForIconID(a1, a2, v22, a5, a6, buf, a7);
    std::__tree<std::__value_type<unsigned short,grl::ImageProvider>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageProvider>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::ImageProvider>,grl::zone_mallocator>>::destroy(*v40);
  }

  else
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
    }

    v26 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      if (*(a4 + 23) >= 0)
      {
        v27 = a4;
      }

      else
      {
        v27 = *a4;
      }

      *buf = 67109378;
      *&buf[4] = a3;
      *v40 = 2080;
      *&v40[2] = v27;
      _os_log_impl(&dword_1B2754000, v26, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for Data ID: %i - Text: %s", buf, 0x12u);
    }

    *a1 = 0;
    a1[1] = 0;
  }
}

void grl::IconManager::imageForName(void *a1, uint64_t a2, uint64_t a3, grl::IconModifiers *a4, float *a5, unsigned int *a6)
{
  v17 = *MEMORY[0x1E69E9840];
  v12 = grl::IconManager::identifierForName(a2, a3, ceilf(*a5));
  if (a6)
  {
    *a6 = v12;
  }

  if (v12)
  {
    v16 = 0;
    *&v15 = &v15 + 8;
    *(&v15 + 1) = 0;
    grl::IconManager::imageForIconID(a1, a2, v12, a4, a5, &v15, a6);
    std::__tree<std::__value_type<unsigned short,grl::ImageProvider>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageProvider>,std::less<unsigned short>,true>,geo::allocator_adapter<std::__value_type<unsigned short,grl::ImageProvider>,grl::zone_mallocator>>::destroy(*(&v15 + 1));
  }

  else
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
    }

    v13 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      if (*(a3 + 23) >= 0)
      {
        v14 = a3;
      }

      else
      {
        v14 = *a3;
      }

      LODWORD(v15) = 136315138;
      *(&v15 + 4) = v14;
      _os_log_impl(&dword_1B2754000, v13, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for name: %s", &v15, 0xCu);
    }

    *a1 = 0;
    a1[1] = 0;
  }
}

uint64_t grl::IconManager::identifierForName(uint64_t a1, void **a2, float a3)
{
  v24 = *MEMORY[0x1E69E9840];
  v5 = ceilf(a3);
  std::string::basic_string[abi:nn200100]<0>(__p, "Default");
  v21 = v5;
  grl::IconManager::retrieveResourcePack(buf, a1, __p, 2);
  v7 = *buf;
  v6 = *&buf[8];
  if (*buf)
  {
    v8 = *&buf[8];
  }

  else
  {
    grl::IconManager::loadGlobalResourcePack(buf, a1, __p);
    v7 = *buf;
    v8 = *&buf[8];
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v6);
    }

    if (!v7)
    {
      goto LABEL_30;
    }
  }

  v9 = *(a2 + 23);
  if (v9 >= 0)
  {
    v10 = a2;
  }

  else
  {
    v10 = *a2;
  }

  if (v9 >= 0)
  {
    v11 = *(a2 + 23);
  }

  else
  {
    v11 = a2[1];
  }

  std::basic_string<char,std::char_traits<char>,geo::allocator_adapter<char,grl::zone_mallocator>>::__init_with_size[abi:nn200100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(buf, v10, v10 + v11, v11);
  v12 = std::__hash_table<std::__hash_value_type<std::string,unsigned long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long long>>>::find<std::string>((v7 + 96), buf);
  if (v12)
  {
    v13 = v12[12];
  }

  else
  {
    v13 = 0;
  }

  if (v23 < 0)
  {
    v15 = *buf;
    v16 = grl::zone_mallocator::instance(v12);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<char>(v16, v15);
    if (v13)
    {
LABEL_17:
      if (!v8)
      {
        goto LABEL_19;
      }

      goto LABEL_18;
    }
  }

  else if (v13)
  {
    goto LABEL_17;
  }

  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_53776);
  }

  v17 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled(GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    if (*(a2 + 23) >= 0)
    {
      v18 = a2;
    }

    else
    {
      v18 = *a2;
    }

    *buf = 136315394;
    *&buf[4] = v18;
    *&buf[12] = 2048;
    *&buf[14] = v5;
    _os_log_impl(&dword_1B2754000, v17, OS_LOG_TYPE_ERROR, "Failed to find ID for Icon Name\nName: %s - Content Scale: %f", buf, 0x16u);
  }

LABEL_30:
  v13 = 0;
  if (v8)
  {
LABEL_18:
    std::__shared_weak_count::__release_shared[abi:nn200100](v8);
  }

LABEL_19:
  if (v20 < 0)
  {
    operator delete(__p[0]);
  }

  return v13;
}

void grl::IconManager::multiPOIBalloonContent(int a1, int a2, float ***a3, int a4, grl::IconModifiers *a5)
{
  v62 = *MEMORY[0x1E69E9840];
  v6 = -11250604;
  v58[2] = 0;
  v57 = v58;
  v58[0] = 0;
  grl::IconModifiers::IconModifiers(v52, a5);
  v7 = *a3;
  v8 = a3[1];
  if (*a3 == v8)
  {
    v11 = 0;
    v10 = 0;
LABEL_27:
    if ((v53 & 1) == 0)
    {
      v53 = 1;
    }

    v54 = v6;
    if ((v55 & 1) == 0)
    {
      v55 = 1;
    }

    v56 = v6;
    goto LABEL_33;
  }

  v48 = a3;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  while (1)
  {
    v14 = *v7;
    v13 = v7[1];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v16 = v14[12];
    v15 = v14[13];
    v18 = v14[10];
    v17 = v14[11];
    LayerMetrics = grl::IconMetricsRenderResult::getLayerMetrics((v14 + 6), 1u, 0);
    if (*(v14 + 163) == 1 && (v20 = LayerMetrics, LODWORD(v50) = gm::Box<float,2>::operator+((LayerMetrics + 12), (LayerMetrics + 52)), HIDWORD(v50) = v21, image = __PAIR64__(v23, v22), LODWORD(v59) = gm::Box<float,2>::operator+((v20 + 28), (v20 + 52)), HIDWORD(v59) = v24, v60 = v25, v61 = v26, !md::DaVinciGroundRenderLayer::ColorCorrectionKey::operator==(&v50, &v59)))
    {
      if ((v9 & 1) == 0)
      {
        *&a3 = v14[41];
LABEL_19:
        v49 = a3;
        v9 = 1;
        v12 = 1;
        if (!v13)
        {
          goto LABEL_15;
        }

LABEL_14:
        std::__shared_weak_count::__release_shared[abi:nn200100](v13);
        goto LABEL_15;
      }

      v27 = v49;
      v28 = *(v14 + 41);
    }

    else
    {
      if (*(v14 + 153) != 1)
      {
        goto LABEL_13;
      }

      if ((v9 & 1) == 0)
      {
        *&a3 = *(v14 + 154);
        goto LABEL_19;
      }

      v27 = v49;
      v28 = *(v14 + 154);
    }

    v12 = v27 == v28;
LABEL_13:
    if (v13)
    {
      goto LABEL_14;
    }

LABEL_15:
    v11 += (v16 - v18);
    v10 = fmax(v10, (v15 - v17));
    v7 += 2;
    if (v7 == v8)
    {
      v29 = v9 | ~v12;
      if (v12)
      {
        v6 = a3;
      }

      else
      {
        v6 = -11250604;
      }

      if (v29)
      {
        a3 = v48;
        goto LABEL_27;
      }

      a3 = v48;
LABEL_33:
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      v31 = CGBitmapContextCreate(0, v11, v10, 8uLL, 4 * v11, DeviceRGB, 2u);
      v32 = *a3;
      v33 = a3[1];
      if (*a3 != v33)
      {
        v34 = v10;
        v35 = 0.0;
        do
        {
          v37 = *v32;
          v36 = v32[1];
          if (v36)
          {
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          }

          v50 = __PAIR64__(((v34 - v37[13]) + v37[11]) * 0.5, LODWORD(v35));
          v38 = gm::Box<float,2>::operator+(v37 + 10, &v50);
          v39 = v38;
          v41 = v40;
          v44 = fmaxf(v42 - v38, 0.0);
          v45 = fmaxf(v43 - v40, 0.0);
          grl::IconImage::image(&v50, v37);
          v63.origin.x = v39;
          v63.origin.y = v41;
          v63.size.width = v44;
          v63.size.height = v45;
          CGContextDrawImage(v31, v63, image);
          v50 = &unk_1F29E1200;
          if (image)
          {
            CFRelease(image);
          }

          v46 = v37[12];
          v47 = v37[10];
          if (v36)
          {
            std::__shared_weak_count::__release_shared[abi:nn200100](v36);
          }

          v35 = fmaxf(v46 - v47, 0.0) + v35;
          v32 += 2;
        }

        while (v32 != v33);
      }

      CGBitmapContextCreateImage(v31);
      CFRelease(DeviceRGB);
      CFRelease(v31);
      operator new();
    }
  }
}

uint64_t std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::operator()@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  v2 = *(result + 16);
  *a2 = *(result + 8);
  a2[1] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy_deallocate(void *__p)
{
  v2 = __p[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy(uint64_t a1)
{
  v1 = *(a1 + 16);
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }
}

uint64_t std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::__clone(uint64_t result, void *a2)
{
  v3 = *(result + 8);
  v2 = *(result + 16);
  *a2 = &unk_1F2A5F868;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    atomic_fetch_add_explicit((v2 + 8), 1uLL, memory_order_relaxed);
  }

  return result;
}

void std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F868;
  v1 = a1[2];
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v1);
  }

  JUMPOUT(0x1B8C62190);
}

void *std::__function::__func<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0,std::allocator<grl::IconManager::multiPOIBalloonContent(std::vector<std::shared_ptr<grl::IconImage>> const&,unsigned int,grl::IconModifiers const&,grl::IconRequestOptions const&)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1F2A5F868;
  v2 = a1[2];
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }

  return a1;
}

void grl::IconManager::clearFontCache(grl::FontManager *this)
{
  if (this)
  {
    grl::FontManager::clearFontCache(this);
  }
}

void grl::IconManager::packLogs(grl::IconManager *this, uint64_t a2)
{
  v2 = a2;
  std::__shared_mutex_base::lock_shared((a2 + 104));
  if (*(v2 + 96))
  {
    v76 = this;
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v81);
    v4 = v82;
    *(&v82 + *(v82 - 24) + 8) = *(&v82 + *(v82 - 24) + 8) & 0xFFFFFEFB | 4;
    *(&v84[0].__locale_ + *(v4 - 24)) = 1;
    v5 = *(v2 + 96);
    v6 = *(v5 + 368);
    v7 = *(v5 + 372);
    v8 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "hits=", 5);
    v9 = MEMORY[0x1B8C61C90](v8, v6);
    v10 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, " misses=", 8);
    v11 = MEMORY[0x1B8C61C90](v10, v7);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v11, "hit%=", 5);
    v12 = std::ostream::operator<<();
    std::ios_base::getloc((v12 + *(*v12 - 24)));
    v13 = MEMORY[0x1E69E5318];
    v14 = std::locale::use_facet(&v78, MEMORY[0x1E69E5318]);
    (v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v15 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Number of Config Packs: ", 24);
    v16 = MEMORY[0x1B8C61CB0](v15, *(*(v2 + 96) + 136));
    std::ios_base::getloc((v16 + *(*v16 - 24)));
    v17 = std::locale::use_facet(&v78, v13);
    (v17->__vftable[2].~facet_0)(v17, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v18 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Number of Image Packs: ", 23);
    v19 = MEMORY[0x1B8C61CB0](v18, *(*(v2 + 96) + 64));
    std::ios_base::getloc((v19 + *(*v19 - 24)));
    v20 = std::locale::use_facet(&v78, v13);
    (v20->__vftable[2].~facet_0)(v20, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v21 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Number of Map Packs: ", 21);
    v22 = MEMORY[0x1B8C61CB0](v21, *(*(v2 + 96) + 24));
    std::ios_base::getloc((v22 + *(*v22 - 24)));
    v23 = std::locale::use_facet(&v78, v13);
    (v23->__vftable[2].~facet_0)(v23, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v24 = std::locale::use_facet(&v78, v13);
    (v24->__vftable[2].~facet_0)(v24, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Config Packs: ", 14);
    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v25 = std::locale::use_facet(&v78, v13);
    (v25->__vftable[2].~facet_0)(v25, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v77 = v2;
    v26 = *(v2 + 96);
    v27 = v26 + 152;
    v28 = *(v26 + 160);
    if (v28 != v26 + 152)
    {
      v29 = MEMORY[0x1E69E5318];
      do
      {
        v30 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Pack Key: ", 10);
        v31 = *(v28 + 39);
        if (v31 >= 0)
        {
          v32 = v28 + 16;
        }

        else
        {
          v32 = *(v28 + 16);
        }

        if (v31 >= 0)
        {
          v33 = *(v28 + 39);
        }

        else
        {
          v33 = *(v28 + 24);
        }

        v34 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, v32, v33);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v34, " - ", 3);
        v35 = std::ostream::operator<<();
        std::ios_base::getloc((v35 + *(*v35 - 24)));
        v36 = std::locale::use_facet(&v78, v29);
        (v36->__vftable[2].~facet_0)(v36, 10);
        std::locale::~locale(&v78);
        std::ostream::put();
        std::ostream::flush();
        (*(**(v28 + 48) + 48))(&v78);
        if ((v80 & 0x80u) == 0)
        {
          locale = &v78;
        }

        else
        {
          locale = v78.__locale_;
        }

        if ((v80 & 0x80u) == 0)
        {
          v38 = v80;
        }

        else
        {
          v38 = v79;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, locale, v38);
        if (v80 < 0)
        {
          operator delete(v78.__locale_);
        }

        v28 = *(v28 + 8);
      }

      while (v28 != v27);
    }

    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v39 = MEMORY[0x1E69E5318];
    v40 = std::locale::use_facet(&v78, MEMORY[0x1E69E5318]);
    (v40->__vftable[2].~facet_0)(v40, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Image Packs: ", 13);
    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v41 = std::locale::use_facet(&v78, v39);
    (v41->__vftable[2].~facet_0)(v41, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v42 = *(v77 + 96);
    v43 = v42 + 80;
    v44 = *(v42 + 88);
    if (v44 != v42 + 80)
    {
      v45 = MEMORY[0x1E69E5318];
      do
      {
        v46 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Pack Key: ", 10);
        v47 = *(v44 + 39);
        if (v47 >= 0)
        {
          v48 = v44 + 16;
        }

        else
        {
          v48 = *(v44 + 16);
        }

        if (v47 >= 0)
        {
          v49 = *(v44 + 39);
        }

        else
        {
          v49 = *(v44 + 24);
        }

        v50 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v46, v48, v49);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v50, " - ", 3);
        v51 = std::ostream::operator<<();
        std::ios_base::getloc((v51 + *(*v51 - 24)));
        v52 = std::locale::use_facet(&v78, v45);
        (v52->__vftable[2].~facet_0)(v52, 10);
        std::locale::~locale(&v78);
        std::ostream::put();
        std::ostream::flush();
        (*(**(v44 + 48) + 48))(&v78);
        if ((v80 & 0x80u) == 0)
        {
          v53 = &v78;
        }

        else
        {
          v53 = v78.__locale_;
        }

        if ((v80 & 0x80u) == 0)
        {
          v54 = v80;
        }

        else
        {
          v54 = v79;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, v53, v54);
        if (v80 < 0)
        {
          operator delete(v78.__locale_);
        }

        v44 = *(v44 + 8);
      }

      while (v44 != v43);
    }

    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v55 = MEMORY[0x1E69E5318];
    v56 = std::locale::use_facet(&v78, MEMORY[0x1E69E5318]);
    (v56->__vftable[2].~facet_0)(v56, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Map Packs: ", 11);
    std::ios_base::getloc((&v82 + *(v82 - 24)));
    v57 = std::locale::use_facet(&v78, v55);
    (v57->__vftable[2].~facet_0)(v57, 10);
    std::locale::~locale(&v78);
    std::ostream::put();
    std::ostream::flush();
    v58 = *(v77 + 96);
    v61 = *v58;
    v60 = v58 + 1;
    v59 = v61;
    if (v61 != v60)
    {
      v62 = MEMORY[0x1E69E5318];
      do
      {
        v63 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, "Pack Key: ", 10);
        v64 = *(v59 + 55);
        if (v64 >= 0)
        {
          v65 = (v59 + 4);
        }

        else
        {
          v65 = v59[4];
        }

        if (v64 >= 0)
        {
          v66 = *(v59 + 55);
        }

        else
        {
          v66 = v59[5];
        }

        v67 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v63, v65, v66);
        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v67, " - ", 3);
        v68 = std::ostream::operator<<();
        std::ios_base::getloc((v68 + *(*v68 - 24)));
        v69 = std::locale::use_facet(&v78, v62);
        (v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v78);
        std::ostream::put();
        std::ostream::flush();
        (*(*v59[8] + 48))(&v78);
        if ((v80 & 0x80u) == 0)
        {
          v70 = &v78;
        }

        else
        {
          v70 = v78.__locale_;
        }

        if ((v80 & 0x80u) == 0)
        {
          v71 = v80;
        }

        else
        {
          v71 = v79;
        }

        std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v82, v70, v71);
        if (v80 < 0)
        {
          operator delete(v78.__locale_);
        }

        v72 = v59[1];
        if (v72)
        {
          do
          {
            v73 = v72;
            v72 = *v72;
          }

          while (v72);
        }

        else
        {
          do
          {
            v73 = v59[2];
            v74 = *v73 == v59;
            v59 = v73;
          }

          while (!v74);
        }

        v59 = v73;
      }

      while (v73 != v60);
    }

    std::stringbuf::str[abi:nn200100](v76, &v83);
    v81[0] = *MEMORY[0x1E69E54D8];
    v75 = *(MEMORY[0x1E69E54D8] + 72);
    *(v81 + *(v81[0] - 24)) = *(MEMORY[0x1E69E54D8] + 64);
    v82 = v75;
    v83 = MEMORY[0x1E69E5548] + 16;
    if (v85 < 0)
    {
      operator delete(v84[7].__locale_);
    }

    v83 = MEMORY[0x1E69E5538] + 16;
    std::locale::~locale(v84);
    std::iostream::~basic_iostream();
    MEMORY[0x1B8C620C0](&v86);
    v2 = v77;
  }

  else
  {
    std::string::basic_string[abi:nn200100]<0>(this, "Pack Info Is Null");
  }

  std::__shared_mutex_base::unlock_shared((v2 + 104));
}

void grl::ResourceManager::~ResourceManager(grl::ResourceManager *this)
{
  *this = &unk_1F2A5F9E8;
  std::mutex::~mutex((this + 24));
  v2 = *(this + 2);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn200100](v2);
  }
}

void grl::ResourceProvider::resourceNamesOfResourceAndPackType(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, unint64_t a4@<X3>, void *a5@<X8>)
{
  v66 = *MEMORY[0x1E69E9840];
  v57[0] = a2;
  v57[1] = a3;
  v58 = a4;
  std::mutex::lock((a1 + 176));
  v10 = std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>> const>>>>::find<grl::ResourceProvider::ResourceCacheKey>(a1 + 240, v57);
  if (a1 + 248 == v10)
  {
    std::mutex::unlock((a1 + 176));
    v63 = 0;
    v64 = 0;
    v65 = 0;
    (*(*a1 + 24))(&v56, a1, a4);
    if (!v56)
    {
      operator new();
    }

    v46 = a2;
    v44 = a4;
    v45 = a1;
    std::mutex::lock((a1 + 112));
    v13 = *v56;
    v12 = v56[1];
    v54[0] = &v63;
    if (v13 != v12)
    {
      v47 = v12;
      do
      {
        v14 = *(v13 + 23);
        if ((v14 & 0x80u) == 0)
        {
          v15 = v13;
        }

        else
        {
          v15 = *v13;
        }

        if ((v14 & 0x80u) != 0)
        {
          v14 = *(v13 + 8);
        }

        if (v14)
        {
          v16 = v15 + v14;
          do
          {
            if (!v14)
            {
              goto LABEL_49;
            }

            v17 = *--v16;
            --v14;
          }

          while (v17 != 46);
          v18 = v16 - v15;
          if (v18 != -1)
          {
            std::string::basic_string(&v59, v13, v18 + 1, 0xFFFFFFFFFFFFFFFFLL, v52);
            grl::ResourceTypeFromPackExtension(v52, &v59);
            v19 = 0;
            v49 = SHIBYTE(v59.__r_.__value_.__r.__words[2]);
            __p = v59.__r_.__value_.__r.__words[0];
            if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              v20 = &v59;
            }

            else
            {
              v20 = v59.__r_.__value_.__r.__words[0];
            }

            if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            {
              size = HIBYTE(v59.__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = v59.__r_.__value_.__l.__size_;
            }

            v22 = v20 + size;
            do
            {
              v23 = off_1E7B58478[v19];
              v24 = strlen(v23);
              if (!v24)
              {
                goto LABEL_39;
              }

              v25 = v24;
              if (size >= v24)
              {
                v26 = *v23;
                v27 = size;
                v28 = v20;
                while (1)
                {
                  v29 = v27 - v25;
                  if (v29 == -1)
                  {
                    goto LABEL_29;
                  }

                  v30 = memchr(v28, v26, v29 + 1);
                  if (!v30)
                  {
                    goto LABEL_29;
                  }

                  v31 = v30;
                  if (!memcmp(v30, v23, v25))
                  {
                    break;
                  }

                  v28 = (v31 + 1);
                  v27 = v22 - (v31 + 1);
                  if (v27 < v25)
                  {
                    goto LABEL_29;
                  }
                }

                if (v31 != v22 && v31 - v20 != -1)
                {
LABEL_39:
                  v33 = 0;
                  v12 = v47;
                  if (v52[0])
                  {
                    v33 = BYTE1(v52[0]) == v46 && v19 == a3;
                  }

                  if ((v49 & 0x80000000) == 0)
                  {
                    goto LABEL_47;
                  }

LABEL_52:
                  operator delete(__p);
                  if (v33)
                  {
                    goto LABEL_48;
                  }

                  goto LABEL_49;
                }
              }

LABEL_29:
              ++v19;
            }

            while (v19 != 3);
            v33 = 0;
            v12 = v47;
            if (v49 < 0)
            {
              goto LABEL_52;
            }

LABEL_47:
            if (v33)
            {
LABEL_48:
              std::back_insert_iterator<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>>>::operator=[abi:nn200100](v54, v13);
            }
          }
        }

LABEL_49:
        v13 += 24;
      }

      while (v13 != v12);
    }

    if (v63 == v64 && *v56 != v56[1])
    {
      if (GEOGetGeoResourceLibResourceProviderLog(void)::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoResourceLibResourceProviderLog(void)::onceToken, &__block_literal_global_54332);
      }

      v34 = GEOGetGeoResourceLibResourceProviderLog(void)::log;
      if (os_log_type_enabled(GEOGetGeoResourceLibResourceProviderLog(void)::log, OS_LOG_TYPE_ERROR))
      {
        v35 = v54;
        grl::buildStringFromResourceNames(v54, *v56, 0xAAAAAAAAAAAAAAABLL * ((v56[1] - *v56) >> 3));
        if (v55 < 0)
        {
          v35 = v54[0];
        }

        if (v46 > 3)
        {
          v36 = "";
        }

        else
        {
          v36 = off_1E7B584C8[v46];
        }

        v37 = 0;
        v38 = 0;
        v53 = 2;
        strcpy(v52, "00");
        do
        {
          v39 = v37;
          if ((v44 >> v38))
          {
            v40 = v38 ^ 1;
            if (v53 >= 0)
            {
              v41 = v52;
            }

            else
            {
              v41 = v52[0];
            }

            *(v41 + v40) = 49;
          }

          v37 = 1;
          v38 = 1;
        }

        while ((v39 & 1) == 0);
        if (v53 >= 0)
        {
          v42 = v52;
        }

        else
        {
          v42 = v52[0];
        }

        grl::buildStringFromResourceNames(v50, v63, 0xAAAAAAAAAAAAAAABLL * ((v64 - v63) >> 3));
        if (v51 >= 0)
        {
          v43 = v50;
        }

        else
        {
          v43 = v50[0];
        }

        LODWORD(v59.__r_.__value_.__l.__data_) = 136315906;
        *(v59.__r_.__value_.__r.__words + 4) = v35;
        WORD2(v59.__r_.__value_.__r.__words[1]) = 2080;
        *(&v59.__r_.__value_.__r.__words[1] + 6) = v36;
        HIWORD(v59.__r_.__value_.__r.__words[2]) = 2080;
        v60 = v42;
        v61 = 2080;
        v62 = v43;
        _os_log_impl(&dword_1B2754000, v34, OS_LOG_TYPE_ERROR, "Resources names got filtered to empty set for resourceType:%s location:%s input:%s output:%s", &v59, 0x2Au);
        if (v51 < 0)
        {
          operator delete(v50[0]);
        }

        if (v53 < 0)
        {
          operator delete(v52[0]);
        }

        if (v55 < 0)
        {
          operator delete(v54[0]);
        }
      }
    }

    std::mutex::unlock((v45 + 112));
    std::mutex::lock((v45 + 176));
    operator new();
  }

  v11 = *(v10 + 56);
  *a5 = *(v10 + 48);
  a5[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((v11 + 8), 1uLL, memory_order_relaxed);
  }

  std::mutex::unlock((a1 + 176));
}

os_log_t ___ZL39GEOGetGeoResourceLibResourceProviderLogv_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoResourceLib", "ResourceProvider");
  GEOGetGeoResourceLibResourceProviderLog(void)::log = result;
  return result;
}

void std::__shared_ptr_emplace<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>> const,std::allocator<std::vector<std::string,geo::allocator_adapter<std::string,grl::zone_mallocator>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FA80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void grl::ResourceProvider::clearResourceNamesCache(grl::ResourceProvider *this)
{
  std::mutex::lock((this + 176));
  std::__tree<std::__value_type<geo::c3mm::C3mmFileIndex,std::shared_ptr<geo::c3mm::C3mmFile>>,std::__map_value_compare<geo::c3mm::C3mmFileIndex,std::__value_type<geo::c3mm::C3mmFileIndex,std::shared_ptr<geo::c3mm::C3mmFile>>,std::less<geo::c3mm::C3mmFileIndex>,true>,std::allocator<std::__value_type<geo::c3mm::C3mmFileIndex,std::shared_ptr<geo::c3mm::C3mmFile>>>>::destroy(*(this + 31));
  *(this + 31) = 0;
  *(this + 32) = 0;
  *(this + 30) = this + 248;

  std::mutex::unlock((this + 176));
}

void grl::ResourceProvider::notifyObserversOfTileGroupChange(grl::ResourceProvider *this)
{
  std::mutex::lock((this + 48));
  for (i = *(this + 3); i; i = *i)
  {
    (*(*i[2] + 16))(i[2]);
  }

  std::mutex::unlock((this + 48));
}

void grl::ResourceProvider::removeObserver(uint64_t a1, unint64_t a2)
{
  std::mutex::lock((a1 + 48));
  v4 = *(a1 + 16);
  if (v4)
  {
    v5 = 0x9DDFEA08EB382D69 * ((8 * (a2 & 0x1FFFFFFF) + 8) ^ HIDWORD(a2));
    v6 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v5 >> 47) ^ v5);
    v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
    v8 = vcnt_s8(v4);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v9 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
      if (v7 >= *&v4)
      {
        v9 = v7 % *&v4;
      }
    }

    else
    {
      v9 = v7 & (*&v4 - 1);
    }

    v10 = *(a1 + 8);
    v11 = *(v10 + 8 * v9);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        v13 = *&v4 - 1;
        do
        {
          v14 = v12[1];
          if (v14 == v7)
          {
            if (v12[2] == a2)
            {
              v15 = v12[1];
              if (v8.u32[0] > 1uLL)
              {
                if (v15 >= *&v4)
                {
                  v15 %= *&v4;
                }
              }

              else
              {
                v15 &= v13;
              }

              v16 = *(v10 + 8 * v15);
              do
              {
                v17 = v16;
                v16 = *v16;
              }

              while (v16 != v12);
              if (v17 == (a1 + 24))
              {
                goto LABEL_36;
              }

              v18 = v17[1];
              if (v8.u32[0] > 1uLL)
              {
                if (v18 >= *&v4)
                {
                  v18 %= *&v4;
                }
              }

              else
              {
                v18 &= v13;
              }

              if (v18 != v15)
              {
LABEL_36:
                if (!*v12)
                {
                  goto LABEL_37;
                }

                v19 = *(*v12 + 8);
                if (v8.u32[0] > 1uLL)
                {
                  if (v19 >= *&v4)
                  {
                    v19 %= *&v4;
                  }
                }

                else
                {
                  v19 &= v13;
                }

                if (v19 != v15)
                {
LABEL_37:
                  *(v10 + 8 * v15) = 0;
                }
              }

              v20 = *v12;
              if (*v12)
              {
                v21 = *(v20 + 8);
                if (v8.u32[0] > 1uLL)
                {
                  if (v21 >= *&v4)
                  {
                    v21 %= *&v4;
                  }
                }

                else
                {
                  v21 &= v13;
                }

                if (v21 != v15)
                {
                  *(*(a1 + 8) + 8 * v21) = v17;
                  v20 = *v12;
                }
              }

              *v17 = v20;
              *v12 = 0;
              --*(a1 + 32);
              operator delete(v12);
              break;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v14 >= *&v4)
              {
                v14 %= *&v4;
              }
            }

            else
            {
              v14 &= v13;
            }

            if (v14 != v9)
            {
              break;
            }
          }

          v12 = *v12;
        }

        while (v12);
      }
    }
  }

  std::mutex::unlock((a1 + 48));
}

_BYTE *grl::SizeGroupToString(_BYTE *a1, unsigned int a2)
{
  if (a2 > 9)
  {
    v2 = "";
  }

  else
  {
    v2 = off_1E7B584E8[a2];
  }

  return std::string::basic_string[abi:nn200100]<0>(a1, v2);
}

geo::codec::zone_mallocator *std::vector<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator>>::~vector[abi:ne200100](geo::codec::zone_mallocator *a1)
{
  v2 = *a1;
  if (*a1)
  {
    v3 = *(a1 + 1);
    v4 = *a1;
    if (v3 != v2)
    {
      v5 = *(a1 + 1);
      do
      {
        v7 = *(v5 - 4);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *(v3 - 3) = v6;
          v8 = geo::codec::zone_mallocator::instance(a1);
          geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v8, v6);
        }

        v3 = v5;
      }

      while (v5 != v2);
      v4 = *a1;
    }

    *(a1 + 1) = v2;
    v9 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>>(v9, v4);
  }

  return a1;
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Box<float,2>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B3340FD8(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B334108C(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

uint64_t geo::codec::VectorTile::transitSystemInfoForFeatureID(geo::codec::VectorTile *this, uint64_t a2)
{
  v2 = *(this + 161);
  v3 = *(this + 162) - v2;
  if (!v3)
  {
    return 0;
  }

  v4 = 0x4EC4EC4EC4EC4EC5 * (v3 >> 3);
  if (v4 <= 1)
  {
    v4 = 1;
  }

  while (*(v2 + 40) != a2)
  {
    v2 += 104;
    if (!--v4)
    {
      return 0;
    }
  }

  v6 = *(v2 + 80);
  v7 = *(this + 165);
  v8 = 0x8E38E38E38E38E39 * ((*(this + 166) - v7) >> 3);
  v9 = v7 + 72 * v6;
  if (v8 <= v6)
  {
    return 0;
  }

  else
  {
    return v9;
  }
}

uint64_t geo::codec::VectorTile::transitLineForFeatureID(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (a2 == this)
  {
    return 0;
  }

  v3 = 0x4EC4EC4EC4EC4EC5 * ((a2 - this) >> 3);
  if (v3 <= 1)
  {
    v3 = 1;
  }

  while (*(this + 40) != a3)
  {
    this += 104;
    if (!--v3)
    {
      return 0;
    }
  }

  return this;
}

uint64_t geo::codec::VectorTile::transitNodeForFeatureID(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (a2 == this)
  {
    return 0;
  }

  v3 = 0x82FA0BE82FA0BE83 * ((a2 - this) >> 3);
  if (v3 <= 1)
  {
    v3 = 1;
  }

  while (*(this + 40) != a3)
  {
    this += 344;
    if (!--v3)
    {
      return 0;
    }
  }

  return this;
}

uint64_t geo::codec::VectorTile::transitAccessPointForFeatureID(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (a2 == this)
  {
    return 0;
  }

  v3 = 0xEF7BDEF7BDEF7BDFLL * ((a2 - this) >> 3);
  if (v3 <= 1)
  {
    v3 = 1;
  }

  while (*(this + 40) != a3)
  {
    this += 248;
    if (!--v3)
    {
      return 0;
    }
  }

  return this;
}

void std::__hash_table<std::__hash_value_type<std::variant<ChapterType,DetailType>,DebugChapterInfo>,std::__unordered_map_hasher<std::variant<ChapterType,DetailType>,std::__hash_value_type<std::variant<ChapterType,DetailType>,DebugChapterInfo>,std::hash<std::variant<ChapterType,DetailType>>,std::equal_to<std::variant<ChapterType,DetailType>>,true>,std::__unordered_map_equal<std::variant<ChapterType,DetailType>,std::__hash_value_type<std::variant<ChapterType,DetailType>,DebugChapterInfo>,std::equal_to<std::variant<ChapterType,DetailType>>,std::hash<std::variant<ChapterType,DetailType>>,true>,std::allocator<std::__hash_value_type<std::variant<ChapterType,DetailType>,DebugChapterInfo>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (!(a2 >> 61))
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:ne200100]();
  }

  v3 = *a1;
  *a1 = 0;
  if (v3)
  {
    operator delete(v3);
  }

  *(a1 + 8) = 0;
}

geo::codec::zone_mallocator *geo::codec::VectorTile::_tileBoundsForBuildings(geo::codec::VectorTile *this, double a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  v66 = (this + 2440);
  v5 = *(this + 305);
  if (v5 == *(this + 306))
  {
    v65 = *(this + 291);
    v67 = *(this + 284);
    v8 = *(this + 289);
    v9 = (-13107 * ((*(this + 586) - *(this + 584)) >> 3));
    if (v9 > (*(this + 307) - v5) >> 4)
    {
      v10 = geo::codec::zone_mallocator::instance(this);
      v11 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gm::Box<float,2>>(v10, v9);
      v12 = v11 + 16 * v9;
      v13 = *(this + 306);
      v14 = *(this + 305);
      v15 = v11 + v14 - v13;
      if (v14 != v13)
      {
        v16 = (v11 + v14 - v13);
        do
        {
          v17 = *v14;
          v14 += 16;
          *v16++ = v17;
        }

        while (v14 != v13);
        v14 = *v66;
      }

      *(this + 305) = v15;
      *(this + 306) = v11;
      *(this + 307) = v12;
      if (v14)
      {
        v18 = geo::codec::zone_mallocator::instance(v11);
        geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Box<float,2>>(v18, v14);
      }
    }

    v19 = *(this + 292);
    v20 = v67;
    if (-13107 * ((*(this + 586) - v19) >> 3))
    {
      v21 = 0;
      do
      {
        v23.i32[1] = 2139095039;
        v68 = xmmword_1B33B0730;
        v24 = v19 + 40 * v21;
        v25 = *(v24 + 34);
        if (*(v24 + 34))
        {
          v26 = 0;
          v27 = v65 + 20 * *(v24 + 32);
          v23.i32[0] = -8388609;
          a3.i32[0] = 2139095039;
          a4.i32[0] = 2139095039;
          a5.i32[0] = -8388609;
          do
          {
            v28 = (v8 + 8 * *(v27 + 20 * v26 + 12));
            v29 = *(v28 + 2);
            if (*(v28 + 2))
            {
              v30 = *v28;
              if (v29 > 8 && ((v31 = (v20 + 12 * v30), &v68 < v67 - 4 + 12 * (v29 + v30)) ? (v32 = v31 >= &v69) : (v32 = 1), v32))
              {
                v33 = v29 & 7;
                if ((v29 & 7) == 0)
                {
                  v33 = 8;
                }

                v34 = vdupq_lane_s32(*a5.f32, 0);
                v35 = v29 - v33;
                v36 = vdupq_lane_s32(*a4.f32, 0);
                v37 = vdupq_lane_s32(*v23.f32, 0);
                v38 = v35;
                v39 = vdupq_lane_s32(*a3.f32, 0);
                v40 = v34;
                v41 = v36;
                v42 = v37;
                v43 = v39;
                do
                {
                  v44 = v31;
                  v31 += 24;
                  v70 = vld3q_f32(v44);
                  v44 += 12;
                  v39 = vminnmq_f32(v70.val[0], v39);
                  v71 = vld3q_f32(v44);
                  v43 = vminnmq_f32(v71.val[0], v43);
                  v37 = vmaxnmq_f32(v37, v70.val[0]);
                  v42 = vmaxnmq_f32(v42, v71.val[0]);
                  v36 = vminnmq_f32(v70.val[1], v36);
                  v41 = vminnmq_f32(v71.val[1], v41);
                  v34 = vmaxnmq_f32(v34, v70.val[1]);
                  v40 = vmaxnmq_f32(v40, v71.val[1]);
                  v38 -= 8;
                }

                while (v38);
                a5 = vmaxnmq_f32(v34, v40);
                a5.f32[0] = vmaxnmvq_f32(a5);
                a4 = vminnmq_f32(v36, v41);
                a4.f32[0] = vminnmvq_f32(a4);
                v23 = vmaxnmq_f32(v37, v42);
                v23.f32[0] = vmaxnmvq_f32(v23);
                a3 = vminnmq_f32(v39, v43);
                a3.f32[0] = vminnmvq_f32(a3);
              }

              else
              {
                v35 = 0;
              }

              v45 = v29 - v35;
              v46 = (v67 + 4 + 12 * v35 + 12 * v30);
              do
              {
                v47 = *(v46 - 1);
                v48 = *v46;
                a3.f32[0] = fminf(v47, a3.f32[0]);
                v23.f32[0] = fmaxf(v23.f32[0], v47);
                a4.f32[0] = fminf(*v46, a4.f32[0]);
                *&v68 = __PAIR64__(a4.u32[0], a3.u32[0]);
                a5.f32[0] = fmaxf(a5.f32[0], v48);
                *(&v68 + 1) = __PAIR64__(a5.u32[0], v23.u32[0]);
                v46 += 3;
                --v45;
              }

              while (v45);
            }

            ++v26;
          }

          while (v26 != v25);
        }

        v49 = *(this + 306);
        v50 = *(this + 307);
        if (v49 < v50)
        {
          *v49 = v68;
          v22 = v49 + 1;
        }

        else
        {
          v51 = (v49 - *v66) >> 4;
          v52 = v51 + 1;
          if ((v51 + 1) >> 60)
          {
            std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
          }

          v53 = v50 - *v66;
          if (v53 >> 3 > v52)
          {
            v52 = v53 >> 3;
          }

          if (v53 >= 0x7FFFFFFFFFFFFFF0)
          {
            v54 = 0xFFFFFFFFFFFFFFFLL;
          }

          else
          {
            v54 = v52;
          }

          if (v54)
          {
            v55 = geo::codec::zone_mallocator::instance(&v68);
            v56 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gm::Box<float,2>>(v55, v54);
          }

          else
          {
            v56 = 0;
          }

          v57 = (v56 + 16 * v51);
          *v57 = v68;
          v58 = *(this + 306);
          v59 = *(this + 305);
          v60 = v57 + v59 - v58;
          if (v59 != v58)
          {
            v61 = (v57 + v59 - v58);
            do
            {
              v62 = *v59;
              v59 += 16;
              *v61++ = v62;
            }

            while (v59 != v58);
            v59 = *v66;
          }

          v63 = v56 + 16 * v54;
          *(this + 305) = v60;
          v22 = v57 + 1;
          *(this + 306) = v57 + 1;
          *(this + 307) = v63;
          if (v59)
          {
            v64 = geo::codec::zone_mallocator::instance(v56);
            geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Box<float,2>>(v64, v59);
          }
        }

        *(this + 306) = v22;
        ++v21;
        v19 = *(this + 292);
        v20 = v67;
      }

      while (v21 < (-13107 * ((*(this + 586) - v19) >> 3)));
    }
  }

  return v66;
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gm::Box<float,2>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 16 * a2, 0x1000040451B5BE8uLL);
  atomic_fetch_add((a1 + 24), 1u);
  v7 = pthread_rwlock_unlock((a1 + 32));
  if (v7)
  {
    geo::read_write_lock::logFailure(v7, "unlock", v8);
  }

  return v6;
}

void sub_1B33419C0(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

int16x8_t **geo::codec::VectorTile::daVinciSubTileBuildingIndices(std::mutex *this, int a2, int a3, unsigned int a4)
{
  std::mutex::lock(this + 42);
  v12 = geo::codec::VectorTile::daVinciSubTileBuildingIndicesInternal(this, a2, a3, a4, v8, v9, v10, v11);
  std::mutex::unlock(this + 42);
  return v12;
}

int16x8_t **geo::codec::VectorTile::daVinciSubTileBuildingIndicesInternal(geo::codec::VectorTile *this, int a2, int a3, unsigned int a4, double a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  v8 = a4;
  v9 = this;
  v10 = (this + 24 * a4);
  v11 = v10[315];
  v12 = v10[316];
  if (v11 != v12)
  {
    return &v11[3 * ((a3 << v8) + a2)];
  }

  v101 = a2;
  v102 = a3;
  v13 = (v10 + 315);
  v14 = (1 << a4 << a4);
  if (!v14)
  {
    if (!a4)
    {
      goto LABEL_103;
    }

LABEL_11:
    v17 = geo::codec::VectorTile::_tileBoundsForBuildings(v9, a5, a6, a7, a8);
    v18 = 0;
    v108 = (1 << (v8 - 1));
    LODWORD(v19) = 1065353216 - ((v8 - 1) << 23);
    v114 = v13;
    v104 = v9;
    do
    {
      v20 = 0;
      v21 = (v18 + 0.5) * v19;
      v106 = ((2 * v18) | 1) << a4;
      v107 = (2 * v18) << a4;
      v105 = v18;
      do
      {
        v22 = (v20 + 0.5) * v19;
        v23 = geo::codec::VectorTile::daVinciSubTileBuildingIndicesInternal(v9, v20, v18, v8 - 1);
        v24 = *v23;
        v25 = *(v23 + 8);
        if (*v23 == v25)
        {
          v29 = 0;
          v28 = 0;
          v27 = 0;
          v26 = 0;
        }

        else
        {
          LODWORD(v26) = 0;
          LODWORD(v27) = 0;
          LODWORD(v28) = 0;
          LODWORD(v29) = 0;
          do
          {
            v30 = *v24++;
            v31 = (*v17 + 16 * v30);
            v32 = v31[1];
            v33 = *v31 < v22;
            v34 = v31[3];
            LODWORD(v31) = v31[2] >= v22;
            v35 = (1.0 - v34) < v21;
            v36 = (1.0 - v32) >= v21;
            v26 = v26 + (v35 && v33);
            v27 = v27 + (v35 & v31);
            v28 = v28 + (v36 && v33);
            v29 = v29 + (v36 & v31);
          }

          while (v24 != v25);
        }

        v109 = v20;
        v113 = 2 * v20 + v107;
        if (v26 > ((*v13)[3 * v113 + 2] - (*v13)[3 * v113]) >> 1)
        {
          operator new();
        }

        v111 = v113 | 1;
        if (v27 > ((*v13)[3 * v111 + 2] - (*v13)[3 * v111]) >> 1)
        {
          operator new();
        }

        v112 = 2 * v20 + v106;
        if (v28 > ((*v13)[3 * v112 + 2] - (*v13)[3 * v112]) >> 1)
        {
          operator new();
        }

        v110 = v112 + 1;
        if (v29 > ((*v13)[3 * v110 + 2] - (*v13)[3 * v110]) >> 1)
        {
          operator new();
        }

        v38 = *v23;
        v37 = *(v23 + 8);
        while (v38 != v37)
        {
          v40 = *v38;
          v41 = (*v17 + 16 * v40);
          v42 = v41[2];
          v43 = *v41;
          v44 = v41[1];
          if ((1.0 - v41[3]) < v21)
          {
            if (v43 < v22)
            {
              v45 = &(*v13)[3 * v113];
              v47 = *(v45 + 8);
              v46 = *(v45 + 16);
              if (v47 >= v46)
              {
                v49 = *v45;
                v50 = v47 - *v45;
                v51 = v50 >> 1;
                if (v50 >> 1 <= -2)
                {
                  goto LABEL_124;
                }

                v52 = v46 - v49;
                if (v52 <= v51 + 1)
                {
                  v53 = v51 + 1;
                }

                else
                {
                  v53 = v52;
                }

                if (v52 >= 0x7FFFFFFFFFFFFFFELL)
                {
                  v54 = 0x7FFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v54 = v53;
                }

                if (v54)
                {
                  if ((v54 & 0x8000000000000000) == 0)
                  {
                    operator new();
                  }

LABEL_125:
                  std::__throw_bad_array_new_length[abi:ne200100]();
                }

                *(2 * v51) = v40;
                v48 = 2 * v51 + 2;
                memcpy(0, v49, v50);
                *v45 = 0;
                *(v45 + 8) = v48;
                *(v45 + 16) = 0;
                if (v49)
                {
                  operator delete(v49);
                }

                v13 = v114;
              }

              else
              {
                *v47 = v40;
                v48 = (v47 + 1);
              }

              *(v45 + 8) = v48;
            }

            if (v42 >= v22)
            {
              v55 = &(*v13)[3 * v111];
              v57 = *(v55 + 8);
              v56 = *(v55 + 16);
              if (v57 >= v56)
              {
                v59 = *v55;
                v60 = v57 - *v55;
                v61 = v60 >> 1;
                if (v60 >> 1 <= -2)
                {
                  goto LABEL_124;
                }

                v62 = v56 - v59;
                if (v62 <= v61 + 1)
                {
                  v63 = v61 + 1;
                }

                else
                {
                  v63 = v62;
                }

                if (v62 >= 0x7FFFFFFFFFFFFFFELL)
                {
                  v64 = 0x7FFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v64 = v63;
                }

                if (v64)
                {
                  if ((v64 & 0x8000000000000000) == 0)
                  {
                    operator new();
                  }

                  goto LABEL_125;
                }

                *(2 * v61) = v40;
                v58 = 2 * v61 + 2;
                memcpy(0, v59, v60);
                *v55 = 0;
                *(v55 + 8) = v58;
                *(v55 + 16) = 0;
                if (v59)
                {
                  operator delete(v59);
                }

                v13 = v114;
              }

              else
              {
                *v57 = v40;
                v58 = (v57 + 1);
              }

              *(v55 + 8) = v58;
            }
          }

          if ((1.0 - v44) >= v21)
          {
            if (v43 < v22)
            {
              v65 = &(*v13)[3 * v112];
              v67 = *(v65 + 8);
              v66 = *(v65 + 16);
              if (v67 >= v66)
              {
                v69 = *v65;
                v70 = v67 - *v65;
                v71 = v70 >> 1;
                if (v70 >> 1 <= -2)
                {
                  goto LABEL_124;
                }

                v72 = v66 - v69;
                if (v72 <= v71 + 1)
                {
                  v73 = v71 + 1;
                }

                else
                {
                  v73 = v72;
                }

                if (v72 >= 0x7FFFFFFFFFFFFFFELL)
                {
                  v74 = 0x7FFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v74 = v73;
                }

                if (v74)
                {
                  if ((v74 & 0x8000000000000000) == 0)
                  {
                    operator new();
                  }

                  goto LABEL_125;
                }

                *(2 * v71) = v40;
                v68 = 2 * v71 + 2;
                memcpy(0, v69, v70);
                *v65 = 0;
                *(v65 + 8) = v68;
                *(v65 + 16) = 0;
                if (v69)
                {
                  operator delete(v69);
                }

                v13 = v114;
              }

              else
              {
                *v67 = v40;
                v68 = (v67 + 1);
              }

              *(v65 + 8) = v68;
            }

            if (v42 >= v22)
            {
              v75 = &(*v13)[3 * v110];
              v77 = *(v75 + 8);
              v76 = *(v75 + 16);
              if (v77 < v76)
              {
                *v77 = v40;
                v39 = (v77 + 1);
              }

              else
              {
                v78 = *v75;
                v79 = v77 - *v75;
                v80 = v79 >> 1;
                if (v79 >> 1 <= -2)
                {
LABEL_124:
                  std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                }

                v81 = v76 - v78;
                if (v81 <= v80 + 1)
                {
                  v82 = v80 + 1;
                }

                else
                {
                  v82 = v81;
                }

                if (v81 >= 0x7FFFFFFFFFFFFFFELL)
                {
                  v83 = 0x7FFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v83 = v82;
                }

                if (v83)
                {
                  if ((v83 & 0x8000000000000000) == 0)
                  {
                    operator new();
                  }

                  goto LABEL_125;
                }

                *(2 * v80) = v40;
                v39 = 2 * v80 + 2;
                memcpy(0, v78, v79);
                *v75 = 0;
                *(v75 + 8) = v39;
                *(v75 + 16) = 0;
                if (v78)
                {
                  operator delete(v78);
                }

                v13 = v114;
              }

              *(v75 + 8) = v39;
            }
          }

          ++v38;
        }

        v20 = v109 + 1;
        v9 = v104;
        v18 = v105;
      }

      while (v109 + 1 != v108);
      v18 = v105 + 1;
    }

    while (v105 + 1 != v108);
    v11 = *v13;
    a2 = v101;
    a3 = v102;
    LOBYTE(v8) = a4;
    return &v11[3 * ((a3 << v8) + a2)];
  }

  v15 = 0xAAAAAAAAAAAAAAABLL * ((v10[317] - v11) >> 3);
  if (v15 < v14)
  {
    v16 = 0x5555555555555556 * ((v10[317] - v11) >> 3);
    if (0x5555555555555556 * (v13[2] - v11) <= v14)
    {
      v16 = (1 << a4 << a4);
    }

    if (v15 >= 0x555555555555555)
    {
      v16 = 0xAAAAAAAAAAAAAAALL;
    }

    if (v16 <= 0xAAAAAAAAAAAAAAALL)
    {
      operator new();
    }

    goto LABEL_125;
  }

  bzero(v12, 24 * ((24 * v14 - 24) / 0x18) + 24);
  v8 = a4;
  v13[1] = &v12[3 * ((24 * v14 - 24) / 0x18) + 3];
  if (a4)
  {
    goto LABEL_11;
  }

LABEL_103:
  v11 = *v13;
  v84 = (-13107 * ((*(v9 + 586) - *(v9 + 584)) >> 3));
  v85 = **v13;
  v86 = (*v13)[1];
  v87 = (v86 - v85) >> 1;
  if (v84 <= v87)
  {
    if (v84 < v87)
    {
      v86 = (v85 + 2 * v84);
      v11[1] = v86;
    }
  }

  else
  {
    std::vector<unsigned short>::__append(v11, v84 - v87);
    v11 = *v13;
    v85 = **v13;
    v86 = (*v13)[1];
  }

  a2 = v101;
  a3 = v102;
  if (v85 != v86)
  {
    v88 = v86 - v85 - 2;
    if (v88 < 6)
    {
      LODWORD(v89) = 0;
      goto LABEL_122;
    }

    v90 = (v88 >> 1) + 1;
    if (v88 >= 0x1E)
    {
      v89 = v90 & 0xFFFFFFFFFFFFFFF0;
      v92 = xmmword_1B33B1600;
      v93 = v85 + 1;
      v94.i64[0] = 0x8000800080008;
      v94.i64[1] = 0x8000800080008;
      v95.i64[0] = 0x10001000100010;
      v95.i64[1] = 0x10001000100010;
      v96 = v90 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        v93[-1] = v92;
        *v93 = vaddq_s16(v92, v94);
        v92 = vaddq_s16(v92, v95);
        v93 += 2;
        v96 -= 16;
      }

      while (v96);
      if (v90 == v89)
      {
        return &v11[3 * ((a3 << v8) + a2)];
      }

      if ((v90 & 0xC) == 0)
      {
        v85 = (v85 + 2 * v89);
        do
        {
LABEL_122:
          v85->i16[0] = v89;
          v85 = (v85 + 2);
          LODWORD(v89) = v89 + 1;
        }

        while (v85 != v86);
        return &v11[3 * ((a3 << v8) + a2)];
      }

      v91 = v90 & 0xFFFFFFFFFFFFFFF0;
    }

    else
    {
      LODWORD(v89) = 0;
      v91 = 0;
    }

    v97 = vadd_s16(vdup_n_s16(v89), 0x3000200010000);
    v98 = v91 - (v90 & 0xFFFFFFFFFFFFFFFCLL);
    v99 = (v85 + 2 * v91);
    do
    {
      *v99++ = v97;
      v97 = vadd_s16(v97, 0x4000400040004);
      v98 += 4;
    }

    while (v98);
    if (v90 != (v90 & 0xFFFFFFFFFFFFFFFCLL))
    {
      v85 = (v85 + 2 * (v90 & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v89) = v90 & 0xFFFFFFFC;
      goto LABEL_122;
    }
  }

  return &v11[3 * ((a3 << v8) + a2)];
}

void **geo::codec::VectorTile::buildingTileIntersectionInfo(void **this, double a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  v6 = geo::codec::VectorTile::_tileBoundsForBuildings(this, a2, a3, a4, a5);
  if (-13107 * ((*(this + 586) - *(this + 584)) >> 3))
  {
    v7 = this[309];
    v8 = this[310];
    if (v7 == v8)
    {
      v10 = *(v6 + 1) - *v6;
      if (v10)
      {
        v11 = v10 >> 4;
        if (this[311] - v7 < (v10 >> 4))
        {
          if ((v11 & 0x8000000000000000) == 0)
          {
            operator new();
          }

          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v12 = &v8[v11];
        v13 = v6;
        bzero(this[310], v10 >> 4);
        v6 = v13;
        this[310] = v12;
      }

      v14 = *(v6 + 1);
      v15 = v14 - *v6;
      if (v14 != *v6)
      {
        v16 = 0;
        v17 = v15 >> 4;
        v18 = (this[292] + 16);
        v19 = (*v6 + 8);
        do
        {
          v21 = *v18;
          v18 += 5;
          v20 = v21;
          if (v21 == 0x1102AA1513BA17CALL || v20 == 0x110205D497D8D032)
          {
            v24 = *v19;
            v23 = v19[1];
            v25 = *(v19 - 2);
            v26 = *(v19 - 1);
            if (v25 < 0.0 && v23 > 1.0)
            {
              *(this[309] + v16) = 1;
            }

            v27 = 1.0 - v26;
            if (v25 < 0.0 && v23 <= 1.0 && v27 < 1.0)
            {
              *(this[309] + v16) = 2;
            }

            if (v25 < 0.0 && v27 >= 1.0)
            {
              *(this[309] + v16) = 3;
            }

            v28 = v25 < 0.0 || v27 < 1.0;
            if (!v28 && v24 < 1.0)
            {
              *(this[309] + v16) = 4;
            }

            if (v27 >= 1.0 && v24 >= 1.0)
            {
              *(this[309] + v16) = 5;
            }

            if (v24 >= 1.0 && v23 <= 1.0 && v27 < 1.0)
            {
              *(this[309] + v16) = 6;
            }

            if (v24 >= 1.0 && v23 > 1.0)
            {
              *(this[309] + v16) = 7;
            }

            if (v25 >= 0.0 && v23 > 1.0 && v24 < 1.0)
            {
              *(this[309] + v16) = 8;
            }

            if (v25 >= 0.0 && v24 < 1.0 && v23 <= 1.0 && v27 < 1.0)
            {
              *(this[309] + v16) = 0;
            }
          }

          ++v16;
          v19 += 4;
        }

        while (v17 > v16);
      }
    }
  }

  return this + 309;
}

void *geo::codec::VectorTile::liveMetadataForID(int8x8_t *this, unint64_t a2)
{
  v2 = this[78];
  if (!*&v2)
  {
    return 0;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*&v2 <= a2)
    {
      v4 = a2 % *&v2;
    }
  }

  else
  {
    v4 = (*&v2 - 1) & a2;
  }

  v5 = *(*&this[77] + 8 * v4);
  if (!v5)
  {
    return 0;
  }

  v6 = *v5;
  if (!v6)
  {
    return 0;
  }

  if (v3.u32[0] < 2uLL)
  {
    v7 = *&v2 - 1;
    while (1)
    {
      v8 = v6[1];
      if (v8 == a2)
      {
        if (v6[2] == a2)
        {
          return v6 + 3;
        }
      }

      else if ((v8 & v7) != v4)
      {
        return 0;
      }

      v6 = *v6;
      if (!v6)
      {
        return 0;
      }
    }
  }

  while (1)
  {
    v9 = v6[1];
    if (v9 == a2)
    {
      break;
    }

    if (v9 >= *&v2)
    {
      v9 %= *&v2;
    }

    if (v9 != v4)
    {
      return 0;
    }

LABEL_16:
    v6 = *v6;
    if (!v6)
    {
      return 0;
    }
  }

  if (v6[2] != a2)
  {
    goto LABEL_16;
  }

  return v6 + 3;
}

void geo::codec::VectorTile::daVinciTileMaterialList(geo::codec::VectorTile *this, uint64_t a2)
{
  v28 = *MEMORY[0x1E69E9840];
  *this = 0u;
  *(this + 1) = 0u;
  *(this + 8) = 1065353216;
  prime = *(a2 + 2760);
  if (prime == 1)
  {
    v5 = (this + 8);
    prime = 2;
LABEL_7:
    std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::__do_rehash<true>(this, prime);
    goto LABEL_8;
  }

  if ((prime & (prime - 1)) != 0)
  {
    prime = std::__next_prime(*(a2 + 2760));
    v6 = *(this + 8);
  }

  else
  {
    v6 = 0;
  }

  v5 = (this + 8);
  if (prime > *&v6)
  {
    goto LABEL_7;
  }

  if (prime < *&v6)
  {
    v23 = vcvtps_u32_f32(*(this + 3) / *(this + 8));
    if (*&v6 < 3uLL || (v24 = vcnt_s8(v6), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
    {
      v23 = std::__next_prime(v23);
    }

    else
    {
      v25 = 1 << -__clz(v23 - 1);
      if (v23 >= 2)
      {
        v23 = v25;
      }
    }

    if (prime <= v23)
    {
      prime = v23;
    }

    if (prime < *&v6)
    {
      goto LABEL_7;
    }
  }

LABEL_8:
  if (*(a2 + 2760))
  {
    v7 = 0;
    do
    {
      v8 = *(*(a2 + 2784) + 8 * v7);
      if (v8 > 0xFF)
      {
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(this, v8);
      }

      else
      {
        v9 = *(a2 + 2816);
        if (*(a2 + 2816))
        {
          v10 = *(a2 + 2808);
          while (*v10 != v8)
          {
            v10 += 80;
            if (!--v9)
            {
              goto LABEL_17;
            }
          }

          v12 = vcvtps_u32_f32((*(this + 3) + *(v10 + 20)) / *(this + 8));
          if (v12 == 1)
          {
            v12 = 2;
          }

          else if ((v12 & (v12 - 1)) != 0)
          {
            v12 = std::__next_prime(v12);
          }

          v13 = *v5;
          if (v12 > *v5)
          {
            goto LABEL_26;
          }

          if (v12 < *v5)
          {
            v14 = vcvtps_u32_f32(*(this + 3) / *(this + 8));
            if (*&v13 < 3uLL || (v15 = vcnt_s8(v13), v15.i16[0] = vaddlv_u8(v15), v15.u32[0] > 1uLL))
            {
              v14 = std::__next_prime(v14);
            }

            else
            {
              v16 = 1 << -__clz(v14 - 1);
              if (v14 >= 2)
              {
                v14 = v16;
              }
            }

            if (v12 <= v14)
            {
              v12 = v14;
            }

            if (v12 < *&v13)
            {
LABEL_26:
              std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::__do_rehash<true>(this, v12);
            }
          }

          if (*(v10 + 20))
          {
            v17 = 0;
            v18 = 0;
            do
            {
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(this, *(*(v10 + 4) + v17));
              ++v18;
              v17 += 8;
            }

            while (v18 < *(v10 + 20));
          }
        }

        else
        {
LABEL_17:
          if (GEOGetGeoCodecsDecodeLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoCodecsDecodeLog::onceToken, &__block_literal_global_54942);
          }

          v11 = GEOGetGeoCodecsDecodeLog::log;
          if (os_log_type_enabled(GEOGetGeoCodecsDecodeLog::log, OS_LOG_TYPE_ERROR))
          {
            *buf = 134217984;
            v27 = v8;
            _os_log_impl(&dword_1B2754000, v11, OS_LOG_TYPE_ERROR, "Failed to find material raster %lld", buf, 0xCu);
          }
        }
      }

      ++v7;
    }

    while (v7 < *(a2 + 2760));
  }

  v19 = *(a2 + 2336);
  v20 = *(a2 + 2344);
  if (v19 != v20)
  {
    v21 = v19 + 2;
    do
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(this, *v21);
      v22 = v21 + 3;
      v21 += 5;
    }

    while (v22 != v20);
  }
}

void sub_1B3342BC0(_Unwind_Exception *exception_object)
{
  v3 = *(v1 + 16);
  if (v3)
  {
    do
    {
      v4 = *v3;
      operator delete(v3);
      v3 = v4;
    }

    while (v4);
  }

  v5 = *v1;
  *v1 = 0;
  if (v5)
  {
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

os_log_t __GEOGetGeoCodecsMaterialDecodeLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoCodecs", "MaterialDecode");
  GEOGetGeoCodecsMaterialDecodeLog::log = result;
  return result;
}

BOOL geo::codec::MaterialSheet::decodeProperty(uint64_t *a1, unsigned __int8 a2, unsigned __int8 *a3, unsigned __int16 *a4, void *a5)
{
  result = 0;
  if (a2 > 4u)
  {
    if (a2 > 6u)
    {
      if (a2 == 7)
      {
        v68 = *(a1 + 24);
        v69 = v68 != 0;
        v70 = a1[1];
        v71 = a1[2];
        v72 = v71 + 2;
        if (!v68)
        {
          v72 = v71 + 1;
        }

        if (v70 < v72)
        {
          return 0;
        }

        v73 = v71 + 1;
        v74 = *a1;
        if (*(a1 + 24))
        {
          if (v73 >= v70)
          {
            v75 = 0;
          }

          else
          {
            v75 = *(v74 + v73);
          }

          v157 = *(v74 + v71);
          a1[2] = v73;
          v158 = v71 + 2;
          if (v70 < v71 + 2 + v69)
          {
            return 0;
          }

          v159 = v158 >= v70 ? 0 : *(v74 + v158);
          v348 = *(v74 + v73);
          a1[2] = v158;
          v349 = v71 + 3;
          if (v70 < v349 + v69)
          {
            return 0;
          }

          v350 = (1 << (8 - v68)) + 255;
          v351 = 0xFFFF << (8 - v68);
          v112 = ((v159 & v351) >> (8 - v68)) | ((v350 & v348) << v68);
          v352 = *(v74 + v158);
          if (v349 >= v70)
          {
            v353 = 0;
          }

          else
          {
            v353 = *(v74 + v349);
          }

          v609 = ((v75 & v351) >> (8 - v68)) | ((v350 & v157) << v68);
          a1[2] = v349;
          v114 = ((v353 & v351) >> (8 - v68)) | ((v350 & v352) << v68);
        }

        else
        {
          v110 = *(v74 + v71);
          a1[2] = v73;
          v111 = v71 + 2;
          if (v70 < v71 + 2 + v69)
          {
            return 0;
          }

          LOBYTE(v112) = *(v74 + v73);
          a1[2] = v111;
          v113 = v71 + 3;
          if (v70 < v113 + v69)
          {
            return 0;
          }

          LOBYTE(v609) = v110;
          LOBYTE(v114) = *(v74 + v111);
          a1[2] = v113;
        }

        v407 = *a3;
        v408 = a5[6];
        if (v408)
        {
          v409 = vcnt_s8(v408);
          v409.i16[0] = vaddlv_u8(v409);
          if (v409.u32[0] > 1uLL)
          {
            v410 = *a3;
            if (*&v408 <= v407)
            {
              v410 = v407 % a5[6];
            }
          }

          else
          {
            v410 = (v408.i32[0] - 1) & v407;
          }

          v411 = *(a5[5] + 8 * v410);
          if (v411)
          {
            v412 = *v411;
            if (*v411)
            {
              if (v409.u32[0] < 2uLL)
              {
                while (1)
                {
                  v414 = v412[1];
                  if (v414 == v407)
                  {
                    if (*(v412 + 16) == v407)
                    {
                      goto LABEL_782;
                    }
                  }

                  else if ((v414 & (*&v408 - 1)) != v410)
                  {
                    goto LABEL_536;
                  }

                  v412 = *v412;
                  if (!v412)
                  {
                    goto LABEL_536;
                  }
                }
              }

              do
              {
                v413 = v412[1];
                if (v413 == v407)
                {
                  if (*(v412 + 16) == v407)
                  {
LABEL_782:
                    v570 = v112 * 0.0039216;
                    v571 = v609 * 0.0039216;
                    v572 = v114 * 0.0039216;
                    v573 = *a4;
                    v575 = v412[4];
                    v574 = v412[5];
                    if (v575 < v574)
                    {
                      *v575 = v573;
                      v575[1] = v571;
                      v575[2] = v570;
                      v576 = (v575 + 4);
                      v575[3] = v572;
LABEL_829:
                      v412[4] = v576;
                      return 1;
                    }

                    v577 = v412[3];
                    v578 = (v575 - v577) >> 4;
                    v579 = v578 + 1;
                    if ((v578 + 1) >> 60)
                    {
                      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                    }

                    v580 = v574 - v577;
                    if (v580 >> 3 > v579)
                    {
                      v579 = v580 >> 3;
                    }

                    if (v580 >= 0x7FFFFFFFFFFFFFF0)
                    {
                      v581 = 0xFFFFFFFFFFFFFFFLL;
                    }

                    else
                    {
                      v581 = v579;
                    }

                    if (v581)
                    {
                      if (!(v581 >> 60))
                      {
                        operator new();
                      }

                      goto LABEL_832;
                    }

                    v582 = 16 * v578;
                    *v582 = v573;
                    *(v582 + 4) = v571;
                    *(v582 + 8) = v570;
                    *(v582 + 12) = v572;
                    v576 = 16 * v578 + 16;
                    v583 = 0;
                    if (v577 == v575)
                    {
                      goto LABEL_827;
                    }

                    v584 = 0;
                    do
                    {
                      *v584 = *v577;
                      v585 = *(v577 + 1);
                      *(v584 + 12) = v577[3];
                      *(v584 + 4) = v585;
                      v577 += 4;
                      v584 += 16;
                    }

                    while (v577 != v575);
LABEL_826:
                    v577 = v412[3];
                    goto LABEL_827;
                  }
                }

                else
                {
                  if (v413 >= *&v408)
                  {
                    v413 %= *&v408;
                  }

                  if (v413 != v410)
                  {
                    break;
                  }
                }

                v412 = *v412;
              }

              while (v412);
            }
          }
        }

LABEL_536:
        operator new();
      }

      if (a2 != 8)
      {
        if (a2 != 9)
        {
          return result;
        }

        v18 = a1[1];
        v19 = a1[2];
        v20 = v19 + 4;
        v21 = *(a1 + 24);
        v22 = v21 != 0;
        v23 = v19 + 5;
        if (!v21)
        {
          v23 = v19 + 4;
        }

        if (v18 >= v23)
        {
          v24 = *a1;
          if (*(a1 + 24))
          {
            v25 = *(v24 + v19);
            v26 = v19 + 1;
            if (v19 + 1 >= v18)
            {
              v27 = 0;
            }

            else
            {
              v27 = *(v24 + v26);
            }

            a1[2] = v26;
            v181 = v19 + 2;
            if (v19 + 2 >= v18)
            {
              v182 = 0;
            }

            else
            {
              v182 = *(v24 + v181);
            }

            v194 = *(v24 + v26);
            a1[2] = v181;
            v195 = v19 + 3;
            if (v19 + 3 >= v18)
            {
              v196 = 0;
            }

            else
            {
              v196 = *(v24 + v195);
            }

            v201 = *(v24 + v181);
            a1[2] = v195;
            if (v20 >= v18)
            {
              v202 = 0;
            }

            else
            {
              v202 = *(v24 + v20);
            }

            v207 = *(v24 + v195);
            a1[2] = v20;
            v208 = v20 + 4;
            if (v18 < v20 + 4 + v22)
            {
              return 0;
            }

            v209 = (1 << (8 - v21)) + 255;
            v210 = 0xFFFF << (8 - v21);
            v211 = 8 - v21;
            v116 = ((v27 & v210) >> v211) | ((v209 & v25) << v21) | ((((v182 & v210) >> v211) | ((v209 & v194) << v21)) << 8) & 0xFF00 | ((((v196 & v210) >> v211) | ((v209 & v201) << v21)) << 16) & 0xFF0000 | ((((v202 & v210) >> v211) | ((v209 & v207) << v21)) << 24);
            v212 = *a1;
            v213 = v20 + 1;
            v214 = v20 + 1 >= v18 ? 0 : *(v212 + v213);
            v383 = *(v212 + v20);
            a1[2] = v213;
            v384 = v20 + 2;
            v385 = v20 + 2 >= v18 ? 0 : *(v212 + v384);
            v386 = *(v212 + v213);
            a1[2] = v384;
            v387 = v20 + 3;
            v388 = v387 >= v18 ? 0 : *(v212 + v387);
            v389 = *(v212 + v384);
            a1[2] = v387;
            v390 = v208 >= v18 ? 0 : *(v212 + v208);
            v391 = *(v212 + v387);
            a1[2] = v208;
            v392 = v208 + 4;
            if (v18 < v208 + 4 + v22)
            {
              return 0;
            }

            v393 = (1 << (8 - v21)) + 255;
            v394 = 0xFFFF << (8 - v21);
            v223 = ((v214 & v394) >> (8 - v21)) | ((v393 & v383) << v21) | ((((v385 & v394) >> (8 - v21)) | ((v393 & v386) << v21)) << 8) & 0xFF00 | ((((v388 & v394) >> (8 - v21)) | ((v393 & v389) << v21)) << 16) & 0xFF0000 | ((((v390 & v394) >> (8 - v21)) | ((v393 & v391) << v21)) << 24);
            v395 = *a1;
            v396 = 8 - v21;
            v397 = v393;
            v398 = v208 + 1;
            if (v208 + 1 >= v18)
            {
              v399 = 0;
            }

            else
            {
              v399 = *(v395 + v398);
            }

            v464 = (v393 & *(v395 + v208)) << v21;
            v465 = (v399 & v394) >> v396;
            a1[2] = v398;
            v466 = *(v395 + v398);
            v467 = v208 + 2;
            if (v208 + 2 >= v18)
            {
              v468 = 0;
            }

            else
            {
              v468 = *(v395 + v467);
            }

            v469 = v465 | v464;
            a1[2] = v467;
            v470 = *(v395 + v467);
            v471 = v208 + 3;
            if (v471 >= v18)
            {
              v472 = 0;
            }

            else
            {
              v472 = *(v395 + v471);
            }

            a1[2] = v471;
            v473 = (((v472 & v394) >> v396) | ((v397 & v470) << v21)) << 16;
            v474 = v469 | ((((v468 & v394) >> v396) | ((v397 & v466) << v21)) << 8) & 0xFF00;
            v475 = *(v395 + v471);
            if (v392 >= v18)
            {
              v476 = 0;
            }

            else
            {
              v476 = *(v395 + v392);
            }

            a1[2] = v392;
            v610 = v474 | v473 & 0xFF0000 | ((((v476 & v394) >> v396) | ((v397 & v475) << v21)) << 24);
          }

          else
          {
            v116 = *(v24 + v19);
            a1[2] = v20;
            v117 = v19 + 8;
            if (v18 < v19 + 8 + v22)
            {
              return 0;
            }

            v223 = *(*a1 + v20);
            a1[2] = v117;
            if (v18 < v19 + 12 + v22)
            {
              return 0;
            }

            v610 = *(*a1 + v117);
            a1[2] = v19 + 12;
          }

          v477 = *a3;
          v478 = a5[46];
          if (!*&v478)
          {
            goto LABEL_656;
          }

          v479 = a4;
          v480 = vcnt_s8(v478);
          v480.i16[0] = vaddlv_u8(v480);
          if (v480.u32[0] > 1uLL)
          {
            v481 = *a3;
            if (*&v478 <= v477)
            {
              v481 = v477 % a5[46];
            }
          }

          else
          {
            v481 = (v478.i32[0] - 1) & v477;
          }

          v482 = *(a5[45] + 8 * v481);
          if (!v482 || (v412 = *v482) == 0)
          {
LABEL_656:
            operator new();
          }

          if (v480.u32[0] < 2uLL)
          {
            while (1)
            {
              v484 = v412[1];
              if (v484 == v477)
              {
                if (*(v412 + 16) == v477)
                {
                  goto LABEL_797;
                }
              }

              else if ((v484 & (*&v478 - 1)) != v481)
              {
                goto LABEL_656;
              }

              v412 = *v412;
              if (!v412)
              {
                goto LABEL_656;
              }
            }
          }

          while (1)
          {
            v483 = v412[1];
            if (v483 == v477)
            {
              if (*(v412 + 16) == v477)
              {
LABEL_797:
                v586 = *v479;
                v588 = v412[4];
                v587 = v412[5];
                if (v588 < v587)
                {
                  *v588 = v586;
                  *(v588 + 1) = v116;
                  *(v588 + 2) = v223;
                  v576 = (v588 + 16);
                  *(v588 + 3) = v610;
                  goto LABEL_829;
                }

                v577 = v412[3];
                v589 = (v588 - v577) >> 4;
                v590 = v589 + 1;
                if ((v589 + 1) >> 60)
                {
                  std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                }

                v591 = v587 - v577;
                if (v591 >> 3 > v590)
                {
                  v590 = v591 >> 3;
                }

                if (v591 >= 0x7FFFFFFFFFFFFFF0)
                {
                  v592 = 0xFFFFFFFFFFFFFFFLL;
                }

                else
                {
                  v592 = v590;
                }

                if (v592)
                {
                  if (!(v592 >> 60))
                  {
                    operator new();
                  }

                  goto LABEL_832;
                }

                v593 = 16 * v589;
                *v593 = v586;
                *(v593 + 4) = v116;
                *(v593 + 8) = v223;
                *(v593 + 12) = v610;
                v576 = 16 * v589 + 16;
                v583 = 0;
                if (v577 == v588)
                {
                  goto LABEL_827;
                }

                v594 = 0;
                do
                {
                  v595 = *v577;
                  v577 += 4;
                  *v594++ = v595;
                }

                while (v577 != v588);
                goto LABEL_826;
              }
            }

            else
            {
              if (v483 >= *&v478)
              {
                v483 %= *&v478;
              }

              if (v483 != v481)
              {
                goto LABEL_656;
              }
            }

            v412 = *v412;
            if (!v412)
            {
              goto LABEL_656;
            }
          }
        }

        return 0;
      }

      *v621 = 0u;
      *v622 = 0u;
      v623 = 1.0;
      v87 = *(a1 + 24);
      v89 = a1[1];
      v88 = a1[2];
      v90 = v88 + 2;
      if (!v87)
      {
        v90 = v88 + 1;
      }

      if (v89 < v90)
      {
        goto LABEL_69;
      }

      v96 = v88 + 1;
      v97 = *a1;
      if (*(a1 + 24))
      {
        v98 = *(v97 + v88);
        if (v96 >= v89)
        {
          v99 = 0;
        }

        else
        {
          v99 = *(v97 + v96);
        }

        a1[2] = v96;
        v119 = (((v99 & (0xFFFF << (8 - v87))) >> (8 - v87)) | ((((1 << (8 - v87)) + 255) & v98) << v87));
      }

      else
      {
        v119 = *(v97 + v88);
        a1[2] = v96;
      }

      v188 = v119;
      if (v119 == 1)
      {
        prime = 2;
      }

      else
      {
        if ((v119 & (v119 - 1)) != 0)
        {
          prime = std::__next_prime(v119);
          v190 = v621[1];
        }

        else
        {
          v190 = 0;
          prime = v119;
        }

        if (prime <= v190)
        {
          if (prime >= v190)
          {
            goto LABEL_334;
          }

          v342 = vcvtps_u32_f32(v622[1] / v623);
          if (v190 < 3 || (v343 = vcnt_s8(v190), v343.i16[0] = vaddlv_u8(v343), v343.u32[0] > 1uLL))
          {
            v342 = std::__next_prime(v342);
          }

          else
          {
            v344 = 1 << -__clz(v342 - 1);
            if (v342 >= 2)
            {
              v342 = v344;
            }
          }

          if (prime <= v342)
          {
            prime = v342;
          }

          if (prime >= v190)
          {
            goto LABEL_334;
          }
        }
      }

      std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::__do_rehash<true>(v621, prime);
LABEL_334:
      v613 = a4;
      if (!v188)
      {
        goto LABEL_401;
      }

      v282 = 0;
LABEL_336:
      v283 = a1[1];
      v284 = a1[2];
      v285 = v284 + 4;
      v286 = *(a1 + 24);
      v287 = v286 != 0;
      v288 = v284 + 5;
      if (!v286)
      {
        v288 = v284 + 4;
      }

      if (v283 >= v288)
      {
        v289 = *a1;
        if (*(a1 + 24))
        {
          v290 = v284 + 1;
          if (v284 + 1 >= v283)
          {
            v291 = 0;
          }

          else
          {
            v291 = *(v289 + v290);
          }

          v295 = *(v289 + v284);
          a1[2] = v290;
          v296 = v284 + 2;
          if (v284 + 2 >= v283)
          {
            v297 = 0;
          }

          else
          {
            v297 = *(v289 + v296);
          }

          v298 = *(v289 + v290);
          a1[2] = v296;
          v299 = *(v289 + v296);
          v300 = v284 + 3;
          if (v300 >= v283)
          {
            v301 = 0;
          }

          else
          {
            v301 = *(v289 + v300);
          }

          a1[2] = v300;
          v302 = *(v289 + v300);
          if (v285 >= v283)
          {
            v303 = 0;
          }

          else
          {
            v303 = *(v289 + v285);
          }

          a1[2] = v285;
          v304 = v285 + 1;
          if (v283 < v285 + 1 + v287)
          {
            goto LABEL_69;
          }

          v305 = 8 - v286;
          v306 = 8 - v286;
          v307 = (1 << (8 - v286)) + 255;
          v308 = 0xFFFF << (8 - v286);
          LODWORD(v292) = ((v291 & v308) >> v306) | ((v307 & v295) << v286) | ((((v297 & v308) >> v306) | ((v307 & v298) << v286)) << 8) & 0xFF00 | ((((v301 & v308) >> v306) | ((v307 & v299) << v286)) << 16) & 0xFF0000 | ((((v303 & v308) >> v306) | ((v307 & v302) << v286)) << 24);
          v309 = *a1;
          v310 = v304 >= v283 ? 0 : *(v309 + v304);
          v316 = *(v309 + v285);
          a1[2] = v304;
          v317 = v285 + 2;
          if (v283 < v285 + 2 + v287)
          {
            goto LABEL_69;
          }

          v318 = v317 >= v283 ? 0 : *(v309 + v317);
          v319 = *(v309 + v304);
          a1[2] = v317;
          v320 = v285 + 3;
          if (v283 < v320 + v287)
          {
            goto LABEL_69;
          }

          if (v320 >= v283)
          {
            v321 = 0;
          }

          else
          {
            v321 = *(v309 + v320);
          }

          v322 = (1 << v305) + 255;
          v323 = 0xFFFF << v305;
          v311 = ((v310 & (0xFFFF << v305)) >> v305) | ((v322 & v316) << v286);
          v313 = ((v318 & v323) >> (8 - v286)) | ((v322 & v319) << v286);
          v324 = *(v309 + v317);
          a1[2] = v320;
          v315 = ((v321 & v323) >> (8 - v286)) | ((v322 & v324) << v286);
        }

        else
        {
          v292 = *(v289 + v284);
          a1[2] = v285;
          v293 = v284 + 5;
          if (v283 < v285 + 1 + v287)
          {
            goto LABEL_69;
          }

          v294 = *a1;
          LOBYTE(v311) = *(v294 + v285);
          a1[2] = v293;
          v312 = v285 + 2;
          if (v283 < v285 + 2 + v287)
          {
            goto LABEL_69;
          }

          LOBYTE(v313) = *(v294 + v293);
          a1[2] = v312;
          v314 = v285 + 3;
          if (v283 < v314 + v287)
          {
            goto LABEL_69;
          }

          LOBYTE(v315) = *(v294 + v312);
          a1[2] = v314;
        }

        v325 = v311;
        if ((v325 * 0.0039216) >= 0.04045)
        {
          powf((v325 * 0.0037171) + 0.052133, 2.4);
        }

        v326 = v313;
        if ((v326 * 0.0039216) >= 0.04045)
        {
          powf((v326 * 0.0037171) + 0.052133, 2.4);
        }

        v327 = v315;
        if ((v327 * 0.0039216) >= 0.04045)
        {
          powf((v327 * 0.0037171) + 0.052133, 2.4);
        }

        if (v292 == 0.0)
        {
          v328 = 0;
        }

        else
        {
          v328 = LODWORD(v292);
        }

        if (!v621[1])
        {
          goto LABEL_399;
        }

        v329 = vcnt_s8(v621[1]);
        v329.i16[0] = vaddlv_u8(v329);
        if (v329.u32[0] > 1uLL)
        {
          v330 = v328;
          if (v328 >= v621[1])
          {
            v330 = v328 % LODWORD(v621[1]);
          }
        }

        else
        {
          v330 = v328 & (v621[1] + 0xFFFFFFFF);
        }

        v331 = *(v621[0] + v330);
        if (!v331 || (v332 = *v331) == 0)
        {
LABEL_399:
          operator new();
        }

        if (v329.u32[0] < 2uLL)
        {
          while (1)
          {
            v334 = *(v332 + 1);
            if (v334 == v328)
            {
              if (v332[4] == v292)
              {
                goto LABEL_400;
              }
            }

            else if ((v334 & (v621[1] - 1)) != v330)
            {
              goto LABEL_399;
            }

            v332 = *v332;
            if (!v332)
            {
              goto LABEL_399;
            }
          }
        }

        while (1)
        {
          v333 = *(v332 + 1);
          if (v333 == v328)
          {
            if (v332[4] == v292)
            {
LABEL_400:
              if (++v282 >= v188)
              {
LABEL_401:
                v335 = *a3;
                v336 = a5[41];
                if (!*&v336)
                {
                  goto LABEL_443;
                }

                v337 = vcnt_s8(v336);
                v337.i16[0] = vaddlv_u8(v337);
                if (v337.u32[0] > 1uLL)
                {
                  v338 = *a3;
                  if (*&v336 <= v335)
                  {
                    v338 = v335 % a5[41];
                  }
                }

                else
                {
                  v338 = (v336.i32[0] - 1) & v335;
                }

                v354 = *(a5[40] + 8 * v338);
                if (!v354 || (v355 = *v354) == 0)
                {
LABEL_443:
                  operator new();
                }

                if (v337.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    v357 = v355[1];
                    if (v357 == v335)
                    {
                      if (*(v355 + 16) == v335)
                      {
                        goto LABEL_675;
                      }
                    }

                    else if ((v357 & (*&v336 - 1)) != v338)
                    {
                      goto LABEL_443;
                    }

                    v355 = *v355;
                    if (!v355)
                    {
                      goto LABEL_443;
                    }
                  }
                }

                while (1)
                {
                  v356 = v355[1];
                  if (v356 == v335)
                  {
                    if (*(v355 + 16) == v335)
                    {
LABEL_675:
                      v614 = *v613;
                      v497 = v621[0];
                      v498 = v621[1];
                      v621[0] = 0;
                      v621[1] = 0;
                      v616 = v498;
                      v499 = v622[1];
                      __p = v622[0];
                      v619 = v622[1];
                      v500 = v623;
                      v620 = v623;
                      if (v622[1])
                      {
                        v501 = *(v622[0] + 1);
                        if ((v498 & (v498 - 1)) != 0)
                        {
                          if (v501 >= v498)
                          {
                            v501 %= v498;
                          }
                        }

                        else
                        {
                          v501 &= v498 - 1;
                        }

                        v497[v501] = &__p;
                        v622[0] = 0;
                        v622[1] = 0;
                      }

                      v502 = v355[4];
                      v503 = v355[5];
                      if (v502 >= v503)
                      {
                        v508 = v355[3];
                        v509 = 0xAAAAAAAAAAAAAAABLL * ((v502 - v508) >> 4);
                        v510 = v509 + 1;
                        if (v509 + 1 > 0x555555555555555)
                        {
                          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                        }

                        v511 = 0xAAAAAAAAAAAAAAABLL * ((v503 - v508) >> 4);
                        if (2 * v511 > v510)
                        {
                          v510 = 2 * v511;
                        }

                        if (v511 >= 0x2AAAAAAAAAAAAAALL)
                        {
                          v512 = 0x555555555555555;
                        }

                        else
                        {
                          v512 = v510;
                        }

                        if (v512)
                        {
                          if (v512 <= 0x555555555555555)
                          {
                            operator new();
                          }

                          std::__throw_bad_array_new_length[abi:ne200100]();
                        }

                        v513 = 48 * v509;
                        *v513 = v614;
                        v514 = __p;
                        *(v513 + 8) = v497;
                        *(v513 + 16) = v616;
                        *(48 * v509 + 0x18) = v514;
                        *(v513 + 32) = v499;
                        *(v513 + 40) = v500;
                        if (v499)
                        {
                          v515 = v514[1];
                          if ((v616 & (v616 - 1)) != 0)
                          {
                            if (v515 >= v616)
                            {
                              v515 %= v616;
                            }
                          }

                          else
                          {
                            v515 &= v616 - 1;
                          }

                          v497[v515] = 48 * v509 + 24;
                          __p = 0;
                          v619 = 0;
                        }

                        v517 = v355[3];
                        v518 = v355[4];
                        v519 = v513 - (v518 - v517);
                        v516 = v513 + 48;
                        if (v518 != v517)
                        {
                          v520 = 0;
                          do
                          {
                            v522 = v519 + v520;
                            *v522 = *&v517[v520];
                            v523 = &v517[v520 + 24];
                            v524 = *v523;
                            v525 = *&v517[v520 + 8];
                            *(v523 - 2) = 0;
                            *(v522 + 8) = v525;
                            *(v522 + 16) = *&v517[v520 + 16];
                            *(v523 - 1) = 0;
                            *(v519 + v520 + 24) = v524;
                            v526 = *&v517[v520 + 32];
                            *(v522 + 32) = v526;
                            *(-16 * ((v518 - v517) >> 4) + 48 * v509 + v520 + 40) = *&v517[v520 + 40];
                            if (v526)
                            {
                              v521 = *(v524 + 8);
                              v527 = *(v522 + 16);
                              if ((v527 & (v527 - 1)) != 0)
                              {
                                if (v521 >= v527)
                                {
                                  v521 %= v527;
                                }
                              }

                              else
                              {
                                v521 &= v527 - 1;
                              }

                              *(v525 + 8 * v521) = v519 + v520 + 24;
                              *v523 = 0;
                              *&v517[v520 + 32] = 0;
                            }

                            v520 += 48;
                          }

                          while (&v517[v520] != v518);
                          do
                          {
                            v528 = *(v517 + 3);
                            if (v528)
                            {
                              do
                              {
                                v529 = *v528;
                                operator delete(v528);
                                v528 = v529;
                              }

                              while (v529);
                            }

                            v530 = *(v517 + 1);
                            *(v517 + 1) = 0;
                            if (v530)
                            {
                              operator delete(v530);
                            }

                            v517 += 48;
                          }

                          while (v517 != v518);
                          v517 = v355[3];
                        }

                        v355[3] = v519;
                        v355[4] = v516;
                        v355[5] = 0;
                        if (v517)
                        {
                          operator delete(v517);
                        }

                        v504 = __p;
                      }

                      else
                      {
                        *v502 = v614;
                        *(v502 + 8) = v497;
                        *(v502 + 16) = v616;
                        v504 = __p;
                        *(v502 + 24) = __p;
                        v505 = v619;
                        *(v502 + 32) = v619;
                        *(v502 + 40) = v620;
                        if (v505)
                        {
                          v506 = v504[1];
                          v507 = *(v502 + 16);
                          if ((v507 & (v507 - 1)) != 0)
                          {
                            if (v506 >= v507)
                            {
                              v506 %= v507;
                            }
                          }

                          else
                          {
                            v506 &= v507 - 1;
                          }

                          v504 = 0;
                          v497[v506] = v502 + 24;
                          __p = 0;
                          v619 = 0;
                        }

                        v516 = v502 + 48;
                      }

                      v355[4] = v516;
                      if (v504)
                      {
                        do
                        {
                          v531 = *v504;
                          operator delete(v504);
                          v504 = v531;
                        }

                        while (v531);
                      }

                      v40 = 1;
                      v91 = v622[0];
                      if (v622[0])
                      {
                        do
                        {
LABEL_725:
                          v532 = *v91;
                          operator delete(v91);
                          v91 = v532;
                        }

                        while (v532);
                      }

LABEL_778:
                      v569 = v621[0];
                      v621[0] = 0;
                      if (v569)
                      {
                        operator delete(v569);
                      }

                      return (v40 & 1) != 0;
                    }
                  }

                  else
                  {
                    if (v356 >= *&v336)
                    {
                      v356 %= *&v336;
                    }

                    if (v356 != v338)
                    {
                      goto LABEL_443;
                    }
                  }

                  v355 = *v355;
                  if (!v355)
                  {
                    goto LABEL_443;
                  }
                }
              }

              goto LABEL_336;
            }
          }

          else
          {
            if (v333 >= v621[1])
            {
              v333 %= v621[1];
            }

            if (v333 != v330)
            {
              goto LABEL_399;
            }
          }

          v332 = *v332;
          if (!v332)
          {
            goto LABEL_399;
          }
        }
      }

LABEL_69:
      v40 = 0;
      v91 = v622[0];
      if (v622[0])
      {
        goto LABEL_725;
      }

      goto LABEL_778;
    }

    if (a2 == 5)
    {
      v50 = a1[1];
      v51 = a1[2];
      v52 = v51 + 4;
      v53 = *(a1 + 24);
      v54 = v53 != 0;
      v55 = v51 + 5;
      if (!v53)
      {
        v55 = v51 + 4;
      }

      if (v50 < v55)
      {
        return 0;
      }

      v56 = *a1;
      if (*(a1 + 24))
      {
        v57 = v51 + 1;
        if (v51 + 1 >= v50)
        {
          v58 = 0;
        }

        else
        {
          v58 = *(v56 + v57);
        }

        v127 = *(v56 + v51);
        a1[2] = v57;
        v128 = v51 + 2;
        if (v51 + 2 >= v50)
        {
          v129 = 0;
        }

        else
        {
          v129 = *(v56 + v128);
        }

        v137 = *(v56 + v57);
        a1[2] = v128;
        v138 = v51 + 3;
        if (v51 + 3 >= v50)
        {
          v139 = 0;
        }

        else
        {
          v139 = *(v56 + v138);
        }

        v140 = *(v56 + v128);
        a1[2] = v138;
        if (v52 >= v50)
        {
          v141 = 0;
        }

        else
        {
          v141 = *(v56 + v52);
        }

        v142 = *(v56 + v138);
        a1[2] = v52;
        v143 = v52 + 4;
        if (v50 < v52 + 4 + v54)
        {
          return 0;
        }

        v144 = (1 << (8 - v53)) + 255;
        v145 = 0xFFFF << (8 - v53);
        v107 = ((v58 & v145) >> (8 - v53)) | ((v144 & v127) << v53) | ((((v129 & v145) >> (8 - v53)) | ((v144 & v137) << v53)) << 8) & 0xFF00 | ((((v139 & v145) >> (8 - v53)) | ((v144 & v140) << v53)) << 16) & 0xFF0000 | ((((v141 & v145) >> (8 - v53)) | ((v144 & v142) << v53)) << 24);
        v146 = *a1;
        v147 = 8 - v53;
        v148 = v144;
        v149 = v52 + 1;
        if (v52 + 1 >= v50)
        {
          v150 = 0;
        }

        else
        {
          v150 = *(v146 + v149);
        }

        v362 = (v144 & *(v146 + v52)) << v53;
        v363 = (v150 & v145) >> v147;
        a1[2] = v149;
        v364 = *(v146 + v149);
        v365 = v52 + 2;
        if (v52 + 2 >= v50)
        {
          v366 = 0;
        }

        else
        {
          v366 = *(v146 + v365);
        }

        v367 = v363 | v362;
        a1[2] = v365;
        v368 = *(v146 + v365);
        v369 = v52 + 3;
        if (v369 >= v50)
        {
          v370 = 0;
        }

        else
        {
          v370 = *(v146 + v369);
        }

        a1[2] = v369;
        v371 = (((v370 & v145) >> v147) | ((v148 & v368) << v53)) << 16;
        v372 = v367 | ((((v366 & v145) >> v147) | ((v148 & v364) << v53)) << 8) & 0xFF00;
        v373 = *(v146 + v369);
        if (v143 >= v50)
        {
          v374 = 0;
        }

        else
        {
          v374 = *(v146 + v143);
        }

        a1[2] = v143;
        v222 = v372 | v371 & 0xFF0000 | ((((v374 & v145) >> v147) | ((v148 & v373) << v53)) << 24);
      }

      else
      {
        v107 = *(v56 + v51);
        a1[2] = v52;
        if (v50 < v51 + 8 + v54)
        {
          return 0;
        }

        v222 = *(*a1 + v52);
        a1[2] = v51 + 8;
      }

      v375 = *a3;
      v376 = a5[31];
      if (v376)
      {
        v377 = vcnt_s8(v376);
        v377.i16[0] = vaddlv_u8(v377);
        if (v377.u32[0] > 1uLL)
        {
          v378 = *a3;
          if (*&v376 <= v375)
          {
            v378 = v375 % a5[31];
          }
        }

        else
        {
          v378 = (v376.i32[0] - 1) & v375;
        }

        v379 = *(a5[30] + 8 * v378);
        if (v379)
        {
          v380 = *v379;
          if (*v379)
          {
            if (v377.u32[0] < 2uLL)
            {
              while (1)
              {
                v382 = v380[1];
                if (v382 == v375)
                {
                  if (*(v380 + 16) == v375)
                  {
                    goto LABEL_657;
                  }
                }

                else if ((v382 & (*&v376 - 1)) != v378)
                {
                  goto LABEL_494;
                }

                v380 = *v380;
                if (!v380)
                {
                  goto LABEL_494;
                }
              }
            }

            do
            {
              v381 = v380[1];
              if (v381 == v375)
              {
                if (*(v380 + 16) == v375)
                {
LABEL_657:
                  v485 = *a4;
                  v486 = v380[4];
                  v487 = v380[5];
                  if (v486 < v487)
                  {
                    *v486 = v485;
                    *(v486 + 1) = v107;
                    *(v486 + 2) = v222;
                    v380[4] = (v486 + 12);
                    return 1;
                  }

                  v488 = v380[3];
                  v489 = 0xAAAAAAAAAAAAAAABLL * ((v486 - v488) >> 2) + 1;
                  if (v489 > 0x1555555555555555)
                  {
                    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                  }

                  v490 = 0xAAAAAAAAAAAAAAABLL * ((v487 - v488) >> 2);
                  if (2 * v490 > v489)
                  {
                    v489 = 2 * v490;
                  }

                  if (v490 >= 0xAAAAAAAAAAAAAAALL)
                  {
                    v491 = 0x1555555555555555;
                  }

                  else
                  {
                    v491 = v489;
                  }

                  if (!v491)
                  {
                    v492 = 4 * ((v486 - v488) >> 2);
                    *v492 = v485;
                    *(v492 + 4) = v107;
                    *(v492 + 8) = v222;
                    v493 = v492 + 12;
                    v494 = v492 - (v486 - v488);
                    if (v488 != v486)
                    {
                      v495 = 4 * ((v486 - v488) >> 2) - (v486 - v488);
                      do
                      {
                        v496 = *v488;
                        *(v495 + 8) = *(v488 + 2);
                        *v495 = v496;
                        v495 += 12;
                        v488 += 12;
                      }

                      while (v488 != v486);
                      v488 = v380[3];
                    }

                    v380[3] = v494;
                    v380[4] = v493;
                    v380[5] = 0;
                    if (v488)
                    {
                      operator delete(v488);
                    }

                    v380[4] = v493;
                    return 1;
                  }

                  if (v491 <= 0x1555555555555555)
                  {
                    operator new();
                  }

                  goto LABEL_832;
                }
              }

              else
              {
                if (v381 >= *&v376)
                {
                  v381 %= *&v376;
                }

                if (v381 != v378)
                {
                  break;
                }
              }

              v380 = *v380;
            }

            while (v380);
          }
        }
      }

LABEL_494:
      operator new();
    }

    if (a2 != 6)
    {
      return result;
    }

    *v621 = 0u;
    *v622 = 0u;
    v623 = 1.0;
    v36 = *(a1 + 24);
    v38 = a1[1];
    v37 = a1[2];
    v39 = v37 + 2;
    if (!v36)
    {
      v39 = v37 + 1;
    }

    if (v38 < v39)
    {
      goto LABEL_34;
    }

    v92 = v37 + 1;
    v93 = *a1;
    if (*(a1 + 24))
    {
      v94 = *(v93 + v37);
      if (v92 >= v38)
      {
        v95 = 0;
      }

      else
      {
        v95 = *(v93 + v92);
      }

      a1[2] = v92;
      v108 = (((v95 & (0xFFFF << (8 - v36))) >> (8 - v36)) | ((((1 << (8 - v36)) + 255) & v94) << v36));
    }

    else
    {
      v108 = *(v93 + v37);
      a1[2] = v92;
    }

    v130 = v108;
    if (v108 == 1)
    {
      v131 = 2;
    }

    else
    {
      if ((v108 & (v108 - 1)) != 0)
      {
        v131 = std::__next_prime(v108);
        v132 = v621[1];
      }

      else
      {
        v132 = 0;
        v131 = v108;
      }

      if (v131 <= v132)
      {
        if (v131 >= v132)
        {
          goto LABEL_259;
        }

        v339 = vcvtps_u32_f32(v622[1] / v623);
        if (v132 < 3 || (v340 = vcnt_s8(v132), v340.i16[0] = vaddlv_u8(v340), v340.u32[0] > 1uLL))
        {
          v339 = std::__next_prime(v339);
        }

        else
        {
          v341 = 1 << -__clz(v339 - 1);
          if (v339 >= 2)
          {
            v339 = v341;
          }
        }

        if (v131 <= v339)
        {
          v131 = v339;
        }

        if (v131 >= v132)
        {
          goto LABEL_259;
        }
      }
    }

    std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::__do_rehash<true>(v621, v131);
LABEL_259:
    v612 = a4;
    if (!v130)
    {
      goto LABEL_328;
    }

    v224 = 0;
LABEL_261:
    v225 = a1[1];
    v226 = a1[2];
    v227 = v226 + 4;
    v228 = *(a1 + 24);
    v229 = v228 != 0;
    v230 = v226 + 5;
    if (!v228)
    {
      v230 = v226 + 4;
    }

    if (v225 >= v230)
    {
      v231 = *a1;
      if (*(a1 + 24))
      {
        v232 = v226 + 1;
        if (v226 + 1 >= v225)
        {
          v233 = 0;
        }

        else
        {
          v233 = *(v231 + v232);
        }

        v237 = *(v231 + v226);
        a1[2] = v232;
        v238 = v226 + 2;
        if (v226 + 2 >= v225)
        {
          v239 = 0;
        }

        else
        {
          v239 = *(v231 + v238);
        }

        v240 = *(v231 + v232);
        a1[2] = v238;
        v241 = *(v231 + v238);
        v242 = v226 + 3;
        if (v242 >= v225)
        {
          v243 = 0;
        }

        else
        {
          v243 = *(v231 + v242);
        }

        a1[2] = v242;
        v244 = *(v231 + v242);
        if (v227 >= v225)
        {
          v245 = 0;
        }

        else
        {
          v245 = *(v231 + v227);
        }

        a1[2] = v227;
        v246 = v227 + 1;
        if (v225 < v227 + 1 + v229)
        {
          goto LABEL_34;
        }

        v247 = 8 - v228;
        v248 = 8 - v228;
        v249 = (1 << (8 - v228)) + 255;
        v250 = 0xFFFF << (8 - v228);
        LODWORD(v234) = ((v233 & v250) >> v248) | ((v249 & v237) << v228) | ((((v239 & v250) >> v248) | ((v249 & v240) << v228)) << 8) & 0xFF00 | ((((v243 & v250) >> v248) | ((v249 & v241) << v228)) << 16) & 0xFF0000 | ((((v245 & v250) >> v248) | ((v249 & v244) << v228)) << 24);
        v251 = *a1;
        v252 = v246 >= v225 ? 0 : *(v251 + v246);
        v258 = *(v251 + v227);
        a1[2] = v246;
        v259 = v227 + 2;
        if (v225 < v227 + 2 + v229)
        {
          goto LABEL_34;
        }

        v260 = v259 >= v225 ? 0 : *(v251 + v259);
        v261 = *(v251 + v246);
        a1[2] = v259;
        v262 = v227 + 3;
        if (v225 < v227 + 3 + v229)
        {
          goto LABEL_34;
        }

        v263 = v262 >= v225 ? 0 : *(v251 + v262);
        v264 = *(v251 + v259);
        a1[2] = v262;
        v265 = v227 + 4;
        if (v225 < v265 + v229)
        {
          goto LABEL_34;
        }

        v266 = (1 << v247) + 255;
        v267 = 0xFFFF << v247;
        v253 = ((v252 & (0xFFFF << v247)) >> v247) | ((v266 & v258) << v228);
        v255 = ((v260 & v267) >> (8 - v228)) | ((v266 & v261) << v228);
        v256 = ((v263 & v267) >> (8 - v228)) | ((v266 & v264) << v228);
        a1[2] = v265;
      }

      else
      {
        v234 = *(v231 + v226);
        a1[2] = v227;
        v235 = v226 + 5;
        if (v225 < v226 + 5 + v229)
        {
          goto LABEL_34;
        }

        v236 = *a1;
        LOBYTE(v253) = *(v236 + v227);
        a1[2] = v235;
        v254 = v227 + 2;
        if (v225 < v227 + 2 + v229)
        {
          goto LABEL_34;
        }

        LOBYTE(v255) = *(v236 + v235);
        a1[2] = v254;
        if (v225 < v227 + 3 + v229)
        {
          goto LABEL_34;
        }

        LOBYTE(v256) = *(v236 + v254);
        a1[2] = v227 + 3;
        v257 = v227 + 4;
        if (v225 < v257 + v229)
        {
          goto LABEL_34;
        }

        a1[2] = v257;
      }

      v268 = v253;
      if ((v268 * 0.0039216) >= 0.04045)
      {
        powf((v268 * 0.0037171) + 0.052133, 2.4);
      }

      v269 = v255;
      if ((v269 * 0.0039216) >= 0.04045)
      {
        powf((v269 * 0.0037171) + 0.052133, 2.4);
      }

      v270 = v256;
      if ((v270 * 0.0039216) >= 0.04045)
      {
        powf((v270 * 0.0037171) + 0.052133, 2.4);
      }

      if (v234 == 0.0)
      {
        v271 = 0;
      }

      else
      {
        v271 = LODWORD(v234);
      }

      if (!v621[1])
      {
        goto LABEL_326;
      }

      v272 = vcnt_s8(v621[1]);
      v272.i16[0] = vaddlv_u8(v272);
      if (v272.u32[0] > 1uLL)
      {
        v273 = v271;
        if (v271 >= v621[1])
        {
          v273 = v271 % LODWORD(v621[1]);
        }
      }

      else
      {
        v273 = v271 & (v621[1] + 0xFFFFFFFF);
      }

      v274 = *(v621[0] + v273);
      if (!v274 || (v275 = *v274) == 0)
      {
LABEL_326:
        operator new();
      }

      if (v272.u32[0] < 2uLL)
      {
        while (1)
        {
          v277 = *(v275 + 1);
          if (v277 == v271)
          {
            if (v275[4] == v234)
            {
              goto LABEL_327;
            }
          }

          else if ((v277 & (v621[1] - 1)) != v273)
          {
            goto LABEL_326;
          }

          v275 = *v275;
          if (!v275)
          {
            goto LABEL_326;
          }
        }
      }

      while (1)
      {
        v276 = *(v275 + 1);
        if (v276 == v271)
        {
          if (v275[4] == v234)
          {
LABEL_327:
            if (++v224 >= v130)
            {
LABEL_328:
              v278 = *a3;
              v279 = a5[36];
              if (!*&v279)
              {
                goto LABEL_461;
              }

              v280 = vcnt_s8(v279);
              v280.i16[0] = vaddlv_u8(v280);
              if (v280.u32[0] > 1uLL)
              {
                v281 = *a3;
                if (*&v279 <= v278)
                {
                  v281 = v278 % a5[36];
                }
              }

              else
              {
                v281 = (v279.i32[0] - 1) & v278;
              }

              v358 = *(a5[35] + 8 * v281);
              if (!v358 || (v359 = *v358) == 0)
              {
LABEL_461:
                operator new();
              }

              if (v280.u32[0] < 2uLL)
              {
                while (1)
                {
                  v361 = v359[1];
                  if (v361 == v278)
                  {
                    if (*(v359 + 16) == v278)
                    {
                      goto LABEL_727;
                    }
                  }

                  else if ((v361 & (*&v279 - 1)) != v281)
                  {
                    goto LABEL_461;
                  }

                  v359 = *v359;
                  if (!v359)
                  {
                    goto LABEL_461;
                  }
                }
              }

              while (1)
              {
                v360 = v359[1];
                if (v360 == v278)
                {
                  if (*(v359 + 16) == v278)
                  {
LABEL_727:
                    v615 = *v612;
                    v533 = v621[0];
                    v534 = v621[1];
                    v621[0] = 0;
                    v621[1] = 0;
                    v617 = v534;
                    v535 = v622[1];
                    __p = v622[0];
                    v619 = v622[1];
                    v536 = v623;
                    v620 = v623;
                    if (v622[1])
                    {
                      v537 = *(v622[0] + 1);
                      if ((v534 & (v534 - 1)) != 0)
                      {
                        if (v537 >= v534)
                        {
                          v537 %= v534;
                        }
                      }

                      else
                      {
                        v537 &= v534 - 1;
                      }

                      v533[v537] = &__p;
                      v622[0] = 0;
                      v622[1] = 0;
                    }

                    v538 = v359[4];
                    v539 = v359[5];
                    if (v538 >= v539)
                    {
                      v544 = v359[3];
                      v545 = 0xAAAAAAAAAAAAAAABLL * ((v538 - v544) >> 4);
                      v546 = v545 + 1;
                      if (v545 + 1 > 0x555555555555555)
                      {
                        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
                      }

                      v547 = 0xAAAAAAAAAAAAAAABLL * ((v539 - v544) >> 4);
                      if (2 * v547 > v546)
                      {
                        v546 = 2 * v547;
                      }

                      if (v547 >= 0x2AAAAAAAAAAAAAALL)
                      {
                        v548 = 0x555555555555555;
                      }

                      else
                      {
                        v548 = v546;
                      }

                      if (v548)
                      {
                        if (v548 <= 0x555555555555555)
                        {
                          operator new();
                        }

                        std::__throw_bad_array_new_length[abi:ne200100]();
                      }

                      v549 = 48 * v545;
                      *v549 = v615;
                      v550 = __p;
                      *(v549 + 8) = v533;
                      *(v549 + 16) = v617;
                      *(48 * v545 + 0x18) = v550;
                      *(v549 + 32) = v535;
                      *(v549 + 40) = v536;
                      if (v535)
                      {
                        v551 = v550[1];
                        if ((v617 & (v617 - 1)) != 0)
                        {
                          if (v551 >= v617)
                          {
                            v551 %= v617;
                          }
                        }

                        else
                        {
                          v551 &= v617 - 1;
                        }

                        v533[v551] = 48 * v545 + 24;
                        __p = 0;
                        v619 = 0;
                      }

                      v553 = v359[3];
                      v554 = v359[4];
                      v555 = v549 - (v554 - v553);
                      v552 = v549 + 48;
                      if (v554 != v553)
                      {
                        v556 = 0;
                        do
                        {
                          v558 = v555 + v556;
                          *v558 = *&v553[v556];
                          v559 = &v553[v556 + 24];
                          v560 = *v559;
                          v561 = *&v553[v556 + 8];
                          *(v559 - 2) = 0;
                          *(v558 + 8) = v561;
                          *(v558 + 16) = *&v553[v556 + 16];
                          *(v559 - 1) = 0;
                          *(v555 + v556 + 24) = v560;
                          v562 = *&v553[v556 + 32];
                          *(v558 + 32) = v562;
                          *(-16 * ((v554 - v553) >> 4) + 48 * v545 + v556 + 40) = *&v553[v556 + 40];
                          if (v562)
                          {
                            v557 = *(v560 + 8);
                            v563 = *(v558 + 16);
                            if ((v563 & (v563 - 1)) != 0)
                            {
                              if (v557 >= v563)
                              {
                                v557 %= v563;
                              }
                            }

                            else
                            {
                              v557 &= v563 - 1;
                            }

                            *(v561 + 8 * v557) = v555 + v556 + 24;
                            *v559 = 0;
                            *&v553[v556 + 32] = 0;
                          }

                          v556 += 48;
                        }

                        while (&v553[v556] != v554);
                        do
                        {
                          v564 = *(v553 + 3);
                          if (v564)
                          {
                            do
                            {
                              v565 = *v564;
                              operator delete(v564);
                              v564 = v565;
                            }

                            while (v565);
                          }

                          v566 = *(v553 + 1);
                          *(v553 + 1) = 0;
                          if (v566)
                          {
                            operator delete(v566);
                          }

                          v553 += 48;
                        }

                        while (v553 != v554);
                        v553 = v359[3];
                      }

                      v359[3] = v555;
                      v359[4] = v552;
                      v359[5] = 0;
                      if (v553)
                      {
                        operator delete(v553);
                      }

                      v540 = __p;
                    }

                    else
                    {
                      *v538 = v615;
                      *(v538 + 8) = v533;
                      *(v538 + 16) = v617;
                      v540 = __p;
                      *(v538 + 24) = __p;
                      v541 = v619;
                      *(v538 + 32) = v619;
                      *(v538 + 40) = v620;
                      if (v541)
                      {
                        v542 = v540[1];
                        v543 = *(v538 + 16);
                        if ((v543 & (v543 - 1)) != 0)
                        {
                          if (v542 >= v543)
                          {
                            v542 %= v543;
                          }
                        }

                        else
                        {
                          v542 &= v543 - 1;
                        }

                        v540 = 0;
                        v533[v542] = v538 + 24;
                        __p = 0;
                        v619 = 0;
                      }

                      v552 = v538 + 48;
                    }

                    v359[4] = v552;
                    if (v540)
                    {
                      do
                      {
                        v567 = *v540;
                        operator delete(v540);
                        v540 = v567;
                      }

                      while (v567);
                    }

                    v40 = 1;
                    v41 = v622[0];
                    if (!v622[0])
                    {
                      goto LABEL_778;
                    }

                    goto LABEL_777;
                  }
                }

                else
                {
                  if (v360 >= *&v279)
                  {
                    v360 %= *&v279;
                  }

                  if (v360 != v281)
                  {
                    goto LABEL_461;
                  }
                }

                v359 = *v359;
                if (!v359)
                {
                  goto LABEL_461;
                }
              }
            }

            goto LABEL_261;
          }
        }

        else
        {
          if (v276 >= v621[1])
          {
            v276 %= v621[1];
          }

          if (v276 != v273)
          {
            goto LABEL_326;
          }
        }

        v275 = *v275;
        if (!v275)
        {
          goto LABEL_326;
        }
      }
    }

LABEL_34:
    v40 = 0;
    v41 = v622[0];
    if (!v622[0])
    {
      goto LABEL_778;
    }

    do
    {
LABEL_777:
      v568 = *v41;
      operator delete(v41);
      v41 = v568;
    }

    while (v568);
    goto LABEL_778;
  }

  if (a2 <= 1u)
  {
    if (!a2)
    {
      v42 = *(a1 + 24);
      v43 = v42 != 0;
      v44 = a1[1];
      v45 = a1[2];
      v46 = v45 + 2;
      if (!v42)
      {
        v46 = v45 + 1;
      }

      if (v44 < v46)
      {
        return 0;
      }

      v47 = v45 + 1;
      v48 = *a1;
      if (*(a1 + 24))
      {
        if (v47 >= v44)
        {
          v49 = 0;
        }

        else
        {
          v49 = *(v48 + v47);
        }

        v124 = *(v48 + v45);
        a1[2] = v47;
        v125 = v45 + 2;
        if (v44 < v45 + 2 + v43)
        {
          return 0;
        }

        v126 = v125 >= v44 ? 0 : *(v48 + v125);
        v345 = *(v48 + v47);
        a1[2] = v125;
        v346 = v45 + 3;
        if (v44 < v346 + v43)
        {
          return 0;
        }

        v347 = v346 >= v44 ? 0 : *(v48 + v346);
        v400 = *(v48 + v125);
        a1[2] = v346;
        v401 = v346 + 1;
        if (v44 < v346 + 1 + v43)
        {
          return 0;
        }

        v402 = (1 << (8 - v42)) + 255;
        v403 = 0xFFFF << (8 - v42);
        v101 = ((v49 & v403) >> (8 - v42)) | ((v402 & v124) << v42);
        v103 = ((v126 & v403) >> (8 - v42)) | ((v402 & v345) << v42);
        v404 = ((v347 & v403) >> (8 - v42)) | ((v402 & v400) << v42);
        v405 = *(v48 + v346);
        v611 = a4;
        if (v401 >= v44)
        {
          v406 = 0;
        }

        else
        {
          v406 = *(v48 + v401);
        }

        v608 = v404;
        a1[2] = v401;
        v106 = ((v406 & (0xFFFF << (8 - v42))) >> (8 - v42)) | ((((1 << (8 - v42)) + 255) & v405) << v42);
      }

      else
      {
        LOBYTE(v101) = *(v48 + v45);
        a1[2] = v47;
        v102 = v45 + 2;
        if (v44 < v45 + 2 + v43)
        {
          return 0;
        }

        LOBYTE(v103) = *(v48 + v47);
        a1[2] = v102;
        v104 = v45 + 3;
        if (v44 < v104 + v43)
        {
          return 0;
        }

        v105 = *(v48 + v102);
        a1[2] = v104;
        if (v44 < v104 + 1 + v43)
        {
          return 0;
        }

        v608 = v105;
        v611 = a4;
        LOBYTE(v106) = *(v48 + v104);
        a1[2] = v104 + 1;
      }

      v457 = *a3;
      v458 = a5[1];
      if (!*&v458)
      {
        goto LABEL_623;
      }

      v459 = vcnt_s8(v458);
      v459.i16[0] = vaddlv_u8(v459);
      if (v459.u32[0] > 1uLL)
      {
        v460 = *a3;
        if (*&v458 <= v457)
        {
          v460 = v457 % a5[1];
        }
      }

      else
      {
        v460 = (v458.i32[0] - 1) & v457;
      }

      v461 = *(*a5 + 8 * v460);
      if (!v461 || (v412 = *v461) == 0)
      {
LABEL_623:
        operator new();
      }

      if (v459.u32[0] < 2uLL)
      {
        while (1)
        {
          v463 = v412[1];
          if (v463 == v457)
          {
            if (*(v412 + 16) == v457)
            {
              goto LABEL_812;
            }
          }

          else if ((v463 & (*&v458 - 1)) != v460)
          {
            goto LABEL_623;
          }

          v412 = *v412;
          if (!v412)
          {
            goto LABEL_623;
          }
        }
      }

      while (1)
      {
        v462 = v412[1];
        if (v462 == v457)
        {
          if (*(v412 + 16) == v457)
          {
LABEL_812:
            v596 = v106 * 0.0039216;
            v597 = v103 * 0.0039216;
            v598 = v101 * 0.0039216;
            v599 = v608 * 0.0039216;
            v600 = *v611;
            v601 = v412[4];
            v602 = v412[5];
            if (v601 < v602)
            {
              *v601 = v600;
              v601[1] = v598;
              v601[2] = v597;
              v576 = (v601 + 5);
              v601[3] = v599;
              v601[4] = v596;
              goto LABEL_829;
            }

            v577 = v412[3];
            v603 = 0xCCCCCCCCCCCCCCCDLL * (v601 - v577) + 1;
            if (v603 > 0xCCCCCCCCCCCCCCCLL)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
            }

            v604 = 0xCCCCCCCCCCCCCCCDLL * ((v602 - v577) >> 2);
            if (2 * v604 > v603)
            {
              v603 = 2 * v604;
            }

            if (v604 >= 0x666666666666666)
            {
              v605 = 0xCCCCCCCCCCCCCCCLL;
            }

            else
            {
              v605 = v603;
            }

            if (v605)
            {
              if (v605 <= 0xCCCCCCCCCCCCCCCLL)
              {
                operator new();
              }

              goto LABEL_832;
            }

            v606 = 4 * (v601 - v577);
            *v606 = v600;
            *(v606 + 4) = v598;
            *(v606 + 8) = v597;
            *(v606 + 12) = v599;
            *(v606 + 16) = v596;
            v576 = v606 + 20;
            v583 = v606 - (v601 - v577);
            if (v577 != v601)
            {
              v607 = 4 * (v601 - v577) - (v601 - v577);
              do
              {
                *v607 = *v577;
                *(v607 + 4) = *(v577 + 1);
                v577 += 5;
                v607 += 20;
              }

              while (v577 != v601);
              goto LABEL_826;
            }

LABEL_827:
            v412[3] = v583;
            v412[4] = v576;
            v412[5] = 0;
            if (v577)
            {
              operator delete(v577);
            }

            goto LABEL_829;
          }
        }

        else
        {
          if (v462 >= *&v458)
          {
            v462 %= *&v458;
          }

          if (v462 != v460)
          {
            goto LABEL_623;
          }
        }

        v412 = *v412;
        if (!v412)
        {
          goto LABEL_623;
        }
      }
    }

    v28 = *(a1 + 24);
    v30 = a1[1];
    v29 = a1[2];
    v31 = v29 + 2;
    if (!v28)
    {
      v31 = v29 + 1;
    }

    if (v30 >= v31)
    {
      v32 = v29 + 1;
      v33 = *a1;
      if (*(a1 + 24))
      {
        v34 = *(v33 + v29);
        if (v32 >= v30)
        {
          v35 = 0;
        }

        else
        {
          v35 = *(v33 + v32);
        }

        a1[2] = v32;
        v100 = ((v35 & (0xFFFF << (8 - v28))) >> (8 - v28)) | ((((1 << (8 - v28)) + 255) & v34) << v28);
      }

      else
      {
        LOBYTE(v100) = *(v33 + v29);
        a1[2] = v32;
      }

      v120 = *a3;
      v121 = a5[16];
      if (!*&v121)
      {
        goto LABEL_130;
      }

      v122 = vcnt_s8(v121);
      v122.i16[0] = vaddlv_u8(v122);
      if (v122.u32[0] > 1uLL)
      {
        v123 = *a3;
        if (*&v121 <= v120)
        {
          v123 = v120 % a5[16];
        }
      }

      else
      {
        v123 = (v121.i32[0] - 1) & v120;
      }

      v133 = *(a5[15] + 8 * v123);
      if (!v133 || (v134 = *v133) == 0)
      {
LABEL_130:
        operator new();
      }

      if (v122.u32[0] < 2uLL)
      {
        while (1)
        {
          v136 = v134[1];
          if (v136 == v120)
          {
            if (*(v134 + 16) == v120)
            {
              goto LABEL_547;
            }
          }

          else if ((v136 & (*&v121 - 1)) != v123)
          {
            goto LABEL_130;
          }

          v134 = *v134;
          if (!v134)
          {
            goto LABEL_130;
          }
        }
      }

      while (1)
      {
        v135 = v134[1];
        if (v135 == v120)
        {
          if (*(v134 + 16) == v120)
          {
LABEL_547:
            v415 = *a4;
            v416 = v134[4];
            v417 = v134[5];
            if (v416 < v417)
            {
              *v416 = v415;
              *(v416 + 2) = v100;
              goto LABEL_573;
            }

            v418 = v134[3];
            v419 = 0xAAAAAAAAAAAAAAABLL * (v416 - v418) + 1;
            if (v419 >= 0x5555555555555556)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
            }

            v420 = 0xAAAAAAAAAAAAAAABLL * (v417 - v418);
            if (2 * v420 > v419)
            {
              v419 = 2 * v420;
            }

            v421 = v420 >= 0x2AAAAAAAAAAAAAAALL;
            v422 = 0x5555555555555555;
            if (!v421)
            {
              v422 = v419;
            }

            v423 = 3 * v422;
            if (v422)
            {
              if (v422 < 0x5555555555555556)
              {
                operator new();
              }

              goto LABEL_832;
            }

            v424 = v416 - v418;
            v425 = v423;
            *v424 = v415;
            *(v424 + 2) = v100;
LABEL_583:
            v438 = v424 + 3;
            v446 = v416 - v418;
            v447 = (v424 - (v416 - v418));
            goto LABEL_596;
          }
        }

        else
        {
          if (v135 >= *&v121)
          {
            v135 %= *&v121;
          }

          if (v135 != v123)
          {
            goto LABEL_130;
          }
        }

        v134 = *v134;
        if (!v134)
        {
          goto LABEL_130;
        }
      }
    }

    return 0;
  }

  if (a2 == 2)
  {
    v59 = a1[1];
    v60 = a1[2];
    v61 = v60 + 4;
    v62 = *(a1 + 24);
    v63 = v60 + 5;
    if (!v62)
    {
      v63 = v60 + 4;
    }

    if (v59 >= v63)
    {
      v64 = *a1;
      if (*(a1 + 24))
      {
        v65 = 8 - v62;
        v66 = v60 + 1;
        if (v60 + 1 >= v59)
        {
          v67 = 0;
        }

        else
        {
          v67 = *(v64 + v66);
        }

        v151 = (1 << (8 - v62)) + 255;
        v152 = *(v64 + v60);
        v153 = 0xFFFF << v65;
        a1[2] = v66;
        v154 = *(v64 + v66);
        v155 = v60 + 2;
        if (v60 + 2 >= v59)
        {
          v156 = 0;
        }

        else
        {
          v156 = *(v64 + v155);
        }

        v160 = v151 & v152;
        v161 = v67 & v153;
        v162 = v151 & v154;
        v163 = v156 & v153;
        a1[2] = v155;
        v164 = *(v64 + v155);
        v165 = v60 + 3;
        if (v60 + 3 >= v59)
        {
          v166 = 0;
        }

        else
        {
          v166 = *(v64 + v165);
        }

        v167 = v161 >> v65;
        a1[2] = v165;
        v168 = *(v64 + v165);
        if (v61 >= v59)
        {
          v169 = 0;
        }

        else
        {
          v169 = *(v64 + v61);
        }

        a1[2] = v61;
        v109 = ((((v166 & v153) >> v65) | ((v151 & v164) << v62)) << 16) | ((((v169 & v153) >> v65) | ((v151 & v168) << v62)) << 24) | (((v163 >> v65) | (v162 << v62)) << 8) | (v160 << v62) | v167;
      }

      else
      {
        v109 = *(v64 + v60);
        a1[2] = v61;
      }

      v170 = *a3;
      v171 = a5[21];
      if (!*&v171)
      {
        goto LABEL_177;
      }

      v172 = vcnt_s8(v171);
      v172.i16[0] = vaddlv_u8(v172);
      if (v172.u32[0] > 1uLL)
      {
        v173 = *a3;
        if (*&v171 <= v170)
        {
          v173 = v170 % a5[21];
        }
      }

      else
      {
        v173 = (v171.i32[0] - 1) & v170;
      }

      v174 = *(a5[20] + 8 * v173);
      if (!v174 || (v134 = *v174) == 0)
      {
LABEL_177:
        operator new();
      }

      if (v172.u32[0] < 2uLL)
      {
        while (1)
        {
          v176 = v134[1];
          if (v176 == v170)
          {
            if (*(v134 + 16) == v170)
            {
              goto LABEL_558;
            }
          }

          else if ((v176 & (*&v171 - 1)) != v173)
          {
            goto LABEL_177;
          }

          v134 = *v134;
          if (!v134)
          {
            goto LABEL_177;
          }
        }
      }

      while (1)
      {
        v175 = v134[1];
        if (v175 == v170)
        {
          if (*(v134 + 16) == v170)
          {
LABEL_558:
            v426 = *a4;
            v428 = v134[4];
            v427 = v134[5];
            if (v428 < v427)
            {
              *v428 = v426 | (v109 << 32);
              v134[4] = (v428 + 8);
              return 1;
            }

            v418 = v134[3];
            v429 = v428 - v418;
            v430 = (v428 - v418) >> 3;
            v431 = v430 + 1;
            if ((v430 + 1) >> 61)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
            }

            v432 = v427 - v418;
            if (v432 >> 2 > v431)
            {
              v431 = v432 >> 2;
            }

            if (v432 >= 0x7FFFFFFFFFFFFFF8)
            {
              v433 = 0x1FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v433 = v431;
            }

            if (!v433)
            {
              v434 = v430;
              v435 = (8 * v430);
              v436 = v426 | (v109 << 32);
              v437 = &v435[-v434];
              *v435 = v436;
              v438 = (v435 + 1);
              memcpy(v437, v418, v429);
              v134[3] = v437;
              v134[4] = v438;
              v134[5] = 0;
              if (v418)
              {
                goto LABEL_597;
              }

              goto LABEL_598;
            }

            if (!(v433 >> 61))
            {
              operator new();
            }

LABEL_832:
            std::__throw_bad_array_new_length[abi:ne200100]();
          }
        }

        else
        {
          if (v175 >= *&v171)
          {
            v175 %= *&v171;
          }

          if (v175 != v173)
          {
            goto LABEL_177;
          }
        }

        v134 = *v134;
        if (!v134)
        {
          goto LABEL_177;
        }
      }
    }

    return 0;
  }

  if (a2 == 3)
  {
    v76 = a1[1];
    v77 = a1[2];
    v78 = v77 + 4;
    v79 = *(a1 + 24);
    v80 = v77 + 5;
    if (!v79)
    {
      v80 = v77 + 4;
    }

    if (v76 >= v80)
    {
      v81 = *a1;
      if (*(a1 + 24))
      {
        v82 = 8 - v79;
        v83 = (1 << (8 - v79)) + 255;
        v84 = 0xFFFF << (8 - v79);
        v85 = v77 + 1;
        if (v77 + 1 >= v76)
        {
          v86 = 0;
        }

        else
        {
          v86 = *(v81 + v85);
        }

        v183 = (((1 << (8 - v79)) - 1) & *(v81 + v77)) << v79;
        v184 = (v86 & v84) >> v82;
        a1[2] = v85;
        v185 = *(v81 + v85);
        v186 = v77 + 2;
        if (v77 + 2 >= v76)
        {
          v187 = 0;
        }

        else
        {
          v187 = *(v81 + v186);
        }

        v197 = v184 | v183;
        a1[2] = v186;
        v198 = *(v81 + v186);
        v199 = v77 + 3;
        if (v199 >= v76)
        {
          v200 = 0;
        }

        else
        {
          v200 = *(v81 + v199);
        }

        a1[2] = v199;
        v203 = (((v200 & v84) >> v82) | ((v83 & v198) << v79)) << 16;
        v204 = v197 | ((((v187 & v84) >> v82) | ((v83 & v185) << v79)) << 8) & 0xFF00;
        v205 = *(v81 + v199);
        if (v78 >= v76)
        {
          v206 = 0;
        }

        else
        {
          v206 = *(v81 + v78);
        }

        a1[2] = v78;
        v118 = v204 | v203 & 0xFF0000 | ((((v206 & v84) >> v82) | ((v83 & v205) << v79)) << 24);
      }

      else
      {
        v118 = *(v81 + v77);
        a1[2] = v78;
      }

      v215 = *a3;
      v216 = a5[11];
      if (!*&v216)
      {
        goto LABEL_253;
      }

      v217 = vcnt_s8(v216);
      v217.i16[0] = vaddlv_u8(v217);
      if (v217.u32[0] > 1uLL)
      {
        v218 = *a3;
        if (*&v216 <= v215)
        {
          v218 = v215 % a5[11];
        }
      }

      else
      {
        v218 = (v216.i32[0] - 1) & v215;
      }

      v219 = *(a5[10] + 8 * v218);
      if (!v219 || (v134 = *v219) == 0)
      {
LABEL_253:
        operator new();
      }

      if (v217.u32[0] < 2uLL)
      {
        while (1)
        {
          v221 = v134[1];
          if (v221 == v215)
          {
            if (*(v134 + 16) == v215)
            {
              goto LABEL_584;
            }
          }

          else if ((v221 & (*&v216 - 1)) != v218)
          {
            goto LABEL_253;
          }

          v134 = *v134;
          if (!v134)
          {
            goto LABEL_253;
          }
        }
      }

      while (1)
      {
        v220 = v134[1];
        if (v220 == v215)
        {
          if (*(v134 + 16) == v215)
          {
LABEL_584:
            v448 = *a4;
            v450 = v134[4];
            v449 = v134[5];
            if (v450 < v449)
            {
              *v450 = v448;
              *(v450 + 1) = v118;
              v134[4] = (v450 + 8);
              return 1;
            }

            v418 = v134[3];
            v446 = v450 - v418;
            v451 = (v450 - v418) >> 3;
            v452 = v451 + 1;
            if ((v451 + 1) >> 61)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
            }

            v453 = v449 - v418;
            if (v453 >> 2 > v452)
            {
              v452 = v453 >> 2;
            }

            if (v453 >= 0x7FFFFFFFFFFFFFF8)
            {
              v454 = 0x1FFFFFFFFFFFFFFFLL;
            }

            else
            {
              v454 = v452;
            }

            if (v454)
            {
              if (!(v454 >> 61))
              {
                operator new();
              }

              goto LABEL_832;
            }

            v455 = v451;
            v456 = (8 * v451);
            v425 = 0;
            *v456 = v448;
            v456[1] = v118;
            v438 = 8 * v451 + 8;
            v447 = &v456[-2 * v455];
LABEL_596:
            memcpy(v447, v418, v446);
            v134[3] = v447;
            v134[4] = v438;
            v134[5] = v425;
            if (v418)
            {
LABEL_597:
              operator delete(v418);
            }

LABEL_598:
            v134[4] = v438;
            return 1;
          }
        }

        else
        {
          if (v220 >= *&v216)
          {
            v220 %= *&v216;
          }

          if (v220 != v218)
          {
            goto LABEL_253;
          }
        }

        v134 = *v134;
        if (!v134)
        {
          goto LABEL_253;
        }
      }
    }

    return 0;
  }

  if (a2 != 4)
  {
    return result;
  }

  v10 = *(a1 + 24);
  v12 = a1[1];
  v11 = a1[2];
  v13 = v11 + 2;
  if (!v10)
  {
    v13 = v11 + 1;
  }

  if (v12 < v13)
  {
    return 0;
  }

  v14 = v11 + 1;
  v15 = *a1;
  if (*(a1 + 24))
  {
    v16 = *(v15 + v11);
    if (v14 >= v12)
    {
      v17 = 0;
    }

    else
    {
      v17 = *(v15 + v14);
    }

    a1[2] = v14;
    v115 = (((v17 & (0xFFFF << (8 - v10))) >> (8 - v10)) | ((((1 << (8 - v10)) - 1) & v16) << v10));
  }

  else
  {
    v115 = *(v15 + v11);
    a1[2] = v14;
  }

  v177 = *a3;
  v178 = a5[26];
  if (!*&v178)
  {
    goto LABEL_213;
  }

  v179 = vcnt_s8(v178);
  v179.i16[0] = vaddlv_u8(v179);
  if (v179.u32[0] > 1uLL)
  {
    v180 = *a3;
    if (*&v178 <= v177)
    {
      v180 = v177 % a5[26];
    }
  }

  else
  {
    v180 = (v178.i32[0] - 1) & v177;
  }

  v191 = *(a5[25] + 8 * v180);
  if (!v191 || (v134 = *v191) == 0)
  {
LABEL_213:
    operator new();
  }

  if (v179.u32[0] < 2uLL)
  {
    while (1)
    {
      v193 = v134[1];
      if (v193 == v177)
      {
        if (*(v134 + 16) == v177)
        {
          goto LABEL_571;
        }
      }

      else if ((v193 & (*&v178 - 1)) != v180)
      {
        goto LABEL_213;
      }

      v134 = *v134;
      if (!v134)
      {
        goto LABEL_213;
      }
    }
  }

  while (1)
  {
    v192 = v134[1];
    if (v192 == v177)
    {
      break;
    }

    if (v192 >= *&v178)
    {
      v192 %= *&v178;
    }

    if (v192 != v180)
    {
      goto LABEL_213;
    }

LABEL_203:
    v134 = *v134;
    if (!v134)
    {
      goto LABEL_213;
    }
  }

  if (*(v134 + 16) != v177)
  {
    goto LABEL_203;
  }

LABEL_571:
  v439 = v115 != 0;
  v440 = *a4;
  v416 = v134[4];
  v441 = v134[5];
  if (v416 >= v441)
  {
    v418 = v134[3];
    v442 = 0xAAAAAAAAAAAAAAABLL * (v416 - v418) + 1;
    if (v442 >= 0x5555555555555556)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v443 = 0xAAAAAAAAAAAAAAABLL * (v441 - v418);
    if (2 * v443 > v442)
    {
      v442 = 2 * v443;
    }

    v421 = v443 >= 0x2AAAAAAAAAAAAAAALL;
    v444 = 0x5555555555555555;
    if (!v421)
    {
      v444 = v442;
    }

    v445 = 3 * v444;
    if (v444)
    {
      if (v444 < 0x5555555555555556)
      {
        operator new();
      }

      goto LABEL_832;
    }

    v424 = v416 - v418;
    v425 = v445;
    *v424 = v440;
    *(v424 + 2) = v439;
    goto LABEL_583;
  }

  *v416 = v440;
  *(v416 + 2) = v439;
LABEL_573:
  v134[4] = (v416 + 3);
  return 1;
}

void sub_1B334744C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *__p)
{
  v22 = *v20;
  if (*v20)
  {
    v19[4] = v22;
    operator delete(v22);
  }

  operator delete(v19);
  _Unwind_Resume(a1);
}

BOOL geo::codec::MaterialSheet::decodeMaterial(unint64_t this, geo::ibitstream *a2, unsigned int a3, uint64_t a4)
{
  v567 = *MEMORY[0x1E69E9840];
  v5 = (a2 + 16);
  v4 = *(a2 + 2);
  v6 = v4 + 2;
  v7 = *(a2 + 24);
  v8 = *(a2 + 24) != 0;
  v9 = v4 + 3;
  if (!*(a2 + 24))
  {
    v9 = v4 + 2;
  }

  v10 = *(a2 + 1);
  if (v10 < v9)
  {
    return 0;
  }

  v12 = this;
  v13 = *a2;
  if (*(a2 + 24))
  {
    v14 = 8 - v7;
    v15 = 0xFFFF << (8 - v7);
    v16 = v4 + 1;
    v17 = v4 + 1 >= v10 ? 0 : *(v13 + v16);
    v18 = ((v17 & v15) >> v14) | ((((1 << (8 - v7)) - 1) & *(v13 + v4)) << v7);
    *v5 = v16;
    this = *(v13 + v16);
    v20 = v6 >= v10 ? 0 : *(v13 + v6);
    v19 = ((v20 & v15) >> v14) | ((((1 << (8 - v7)) + 255) & this) << v7);
  }

  else
  {
    v18 = *(v13 + v4);
    v19 = v18 >> 8;
  }

  *v5 = v6;
  v21 = v18 | (v19 << 8);
  *v12 = v21;
  v22 = v4 + 4;
  if (v10 < v4 + 4 + v8)
  {
    return 0;
  }

  v24 = *a2;
  if (v7)
  {
    v25 = 8 - v7;
    v26 = (1 << (8 - v7)) + 255;
    v27 = 0xFFFF << (8 - v7);
    v28 = *(v24 + v6);
    v29 = v4 + 3;
    if (v4 + 3 >= v10)
    {
      v30 = 0;
    }

    else
    {
      v30 = *(v24 + v29);
    }

    this = (v26 & v28) << v7;
    v31 = ((v30 & v27) >> v25) | this;
    *v5 = v29;
    v33 = *(v24 + v29);
    if (v22 >= v10)
    {
      v34 = 0;
    }

    else
    {
      v34 = *(v24 + v22);
    }

    v32 = ((v34 & v27) >> v25) | ((v26 & v33) << v7);
  }

  else
  {
    v31 = *(v24 + v6);
    v32 = v31 >> 8;
  }

  *v5 = v22;
  v35 = v31 | (v32 << 8);
  v531 = v12;
  if (!v35)
  {
LABEL_169:
    *(v12 + 504) = v21;
    v102 = v22 + 2;
    v103 = *(a2 + 24);
    if (*(a2 + 24))
    {
      v104 = v22 + 3;
    }

    else
    {
      v104 = v22 + 2;
    }

    v105 = *(a2 + 1);
    if (v105 < v104)
    {
      return 0;
    }

    v106 = *a2;
    if (*(a2 + 24))
    {
      v107 = 8 - v103;
      v108 = (1 << (8 - v103)) + 255;
      v109 = 0xFFFF << (8 - v103);
      v110 = *(v106 + v22);
      v111 = v22 + 1;
      if (v22 + 1 >= v105)
      {
        v112 = 0;
      }

      else
      {
        v112 = *(v106 + v111);
      }

      v113 = ((v112 & v109) >> v107) | ((v108 & v110) << v103);
      *v5 = v111;
      v115 = *(v106 + v111);
      if (v102 >= v105)
      {
        v116 = 0;
      }

      else
      {
        v116 = *(v106 + v102);
      }

      v114 = ((v116 & v109) >> v107) | ((v108 & v115) << v103);
    }

    else
    {
      v113 = *(v106 + v22);
      v114 = v113 >> 8;
    }

    *v5 = v102;
    v527 = v113 | (v114 << 8);
    if (v527)
    {
      v117 = 0;
      while (1)
      {
        memset(buf, 0, sizeof(buf));
        *&v537[1] = 0u;
        v538 = 0u;
        LODWORD(v537[0]) = 1065353216;
        v539 = 1065353216;
        v540 = 0u;
        v541 = 0u;
        v543 = 0u;
        v544 = 0u;
        v542 = 1065353216;
        v545 = 1065353216;
        v546 = 0u;
        v547 = 0u;
        v549 = 0u;
        v550 = 0u;
        v548 = 1065353216;
        v551 = 1065353216;
        v552 = 0u;
        v553 = 0u;
        v554 = 1065353216;
        v555 = 0u;
        v556 = 0u;
        v557 = 1065353216;
        v558 = 0u;
        v559 = 0u;
        v560 = 1065353216;
        v561 = 0u;
        v562 = 0u;
        v563 = 1065353216;
        v564 = 0;
        memset(v565, 0, 36);
        v565[9] = 1065353216;
        v566 = *v12;
        v118 = *(a2 + 24);
        v119 = *(a2 + 1);
        v120 = *(a2 + 2);
        if (a3 < 0x13)
        {
          v121 = *(a2 + 2);
        }

        else
        {
          v121 = v120 + 2;
          v122 = v120 + 3;
          if (!*(a2 + 24))
          {
            v122 = v120 + 2;
          }

          if (v119 < v122)
          {
LABEL_565:
            geo::codec::MaterialSheet::Material::~Material(buf);
            return 0;
          }

          v123 = *a2;
          if (*(a2 + 24))
          {
            v124 = v120 + 1;
            if (v120 + 1 >= v119)
            {
              v125 = 0;
            }

            else
            {
              v125 = *(v123 + v124);
            }

            v128 = *(v123 + v120);
            *v5 = v124;
            if (v121 >= v119)
            {
              v129 = 0;
            }

            else
            {
              v129 = *(v123 + v121);
            }

            v130 = 0xFFFF << (8 - v118);
            v127 = (((v125 & v130) >> (8 - v118)) | ((((1 << (8 - v118)) + 255) & v128) << v118));
            LOWORD(v123) = (((v129 & v130) >> (8 - v118)) | ((((1 << (8 - v118)) - 1) & *(v123 + v124)) << v118));
          }

          else
          {
            v126 = *(v123 + v120);
            v127 = v126;
            LODWORD(v123) = v126 >> 8;
          }

          *v5 = v121;
          v564 = v127 | (v123 << 8);
        }

        v131 = v121 + 2;
        v132 = v121 + 3;
        if (!v118)
        {
          v132 = v121 + 2;
        }

        if (v119 < v132)
        {
          goto LABEL_565;
        }

        v133 = *a2;
        if (v118)
        {
          v134 = v121 + 1;
          if (v121 + 1 >= v119)
          {
            v135 = 0;
          }

          else
          {
            v135 = *(v133 + v134);
          }

          v139 = *(v133 + v121);
          *v5 = v134;
          if (v131 >= v119)
          {
            v140 = 0;
          }

          else
          {
            v140 = *(v133 + v131);
          }

          v141 = 0xFFFF << (8 - v118);
          v137 = (((v135 & v141) >> (8 - v118)) | ((((1 << (8 - v118)) + 255) & v139) << v118));
          v138 = (((v140 & v141) >> (8 - v118)) | ((((1 << (8 - v118)) - 1) & *(v133 + v134)) << v118));
        }

        else
        {
          v136 = *(v133 + v121);
          v137 = v136;
          v138 = v136 >> 8;
        }

        *v5 = v131;
        if (v137 | (v138 << 8))
        {
          operator new();
        }

        v142 = v131 + 2;
        v143 = v131 + 3;
        if (!v118)
        {
          v143 = v131 + 2;
        }

        if (v119 < v143)
        {
LABEL_216:
          v144 = 0;
          goto LABEL_484;
        }

        v145 = *a2;
        if (v118)
        {
          v146 = v131 + 1;
          if (v131 + 1 >= v119)
          {
            v147 = 0;
          }

          else
          {
            v147 = *(v145 + v146);
          }

          v150 = *(v145 + v131);
          *v5 = v146;
          if (v142 >= v119)
          {
            v151 = 0;
          }

          else
          {
            v151 = *(v145 + v142);
          }

          v152 = 0xFFFF << (8 - v118);
          v148 = ((v147 & v152) >> (8 - v118)) | ((((1 << (8 - v118)) + 255) & v150) << v118);
          v149 = ((v151 & v152) >> (8 - v118)) | ((((1 << (8 - v118)) - 1) & *(v145 + v146)) << v118);
        }

        else
        {
          v148 = *(v145 + v131);
          v149 = v148 >> 8;
        }

        *v5 = v142;
        v528 = v148 | (v149 << 8);
        if (v528)
        {
          for (i = 0; i != v528; ++i)
          {
            v154 = *(a2 + 24);
            v155 = *(a2 + 24) != 0;
            v156 = *(a2 + 1);
            v157 = *(a2 + 2);
            v158 = v157 + 2;
            if (!*(a2 + 24))
            {
              v158 = v157 + 1;
            }

            if (v156 < v158)
            {
              goto LABEL_216;
            }

            v159 = v157 + 1;
            v160 = *a2;
            if (*(a2 + 24))
            {
              if (v159 >= v156)
              {
                v161 = 0;
              }

              else
              {
                v161 = *(v160 + v159);
              }

              v163 = *(v160 + v157);
              *v5 = v159;
              v162 = ((v161 & (0xFFFF << (8 - v154))) >> (8 - v154)) | ((((1 << (8 - v154)) + 255) & v163) << v154);
            }

            else
            {
              LOBYTE(v162) = *(v160 + v157);
              *v5 = v159;
            }

            if (a3 < 0x15)
            {
              v170 = 0;
              goto LABEL_259;
            }

            v164 = v157 + 2;
            if (v156 < v157 + 2 + v155)
            {
              goto LABEL_378;
            }

            v165 = 8 - v154;
            v166 = (1 << (8 - v154)) + 255;
            v167 = 0xFFFF << (8 - v154);
            v168 = *(v160 + v159);
            if (v154)
            {
              if (v164 >= v156)
              {
                v169 = 0;
              }

              else
              {
                v169 = *(v160 + v164);
              }

              *v5 = v164;
              v171 = ((v169 & v167) >> v165) | ((v166 & v168) << v154);
              v170 = v171 & 0x7F;
              if ((v171 & 0x80) == 0)
              {
                goto LABEL_249;
              }
            }

            else
            {
              *v5 = v164;
              v170 = v168 & 0x7F;
              if ((v168 & 0x80) == 0)
              {
                goto LABEL_249;
              }
            }

            v159 = v157 + 3;
            if (v156 < v157 + 3 + v155)
            {
              goto LABEL_378;
            }

            v172 = *(v160 + v164);
            if (v154)
            {
              if (v159 >= v156)
              {
                v173 = 0;
              }

              else
              {
                v173 = *(v160 + v159);
              }

              *v5 = v159;
              v172 = ((v173 & v167) >> v165) | ((v166 & v172) << v154);
            }

            else
            {
              *v5 = v159;
            }

            v170 = v170 & 0xFFFFFFFFFFFFC07FLL | ((v172 & 0x7F) << 7);
            if ((v172 & 0x80) == 0)
            {
              goto LABEL_258;
            }

            v164 = v157 + 4;
            if (v156 < v157 + 4 + v155)
            {
              goto LABEL_378;
            }

            v208 = *(v160 + v159);
            if (v154)
            {
              if (v164 >= v156)
              {
                v209 = 0;
              }

              else
              {
                v209 = *(v160 + v164);
              }

              *v5 = v164;
              v208 = ((v209 & v167) >> v165) | ((v166 & v208) << v154);
            }

            else
            {
              *v5 = v164;
            }

            v170 = v170 & 0xFFFFFFFFFFE03FFFLL | ((v208 & 0x7F) << 14);
            if ((v208 & 0x80) == 0)
            {
              goto LABEL_249;
            }

            v159 = v157 + 5;
            if (v156 < v157 + 5 + v155)
            {
              goto LABEL_378;
            }

            v210 = *(v160 + v164);
            if (v154)
            {
              v211 = v159 >= v156 ? 0 : *(v160 + v159);
              *v5 = v159;
              v210 = ((v211 & v167) >> v165) | ((v166 & v210) << v154);
            }

            else
            {
              *v5 = v159;
            }

            v170 = v170 & 0xFFFFFFFFF01FFFFFLL | ((v210 & 0x7F) << 21);
            if ((v210 & 0x80) == 0)
            {
              goto LABEL_258;
            }

            v164 = v157 + 6;
            if (v156 < v157 + 6 + v155)
            {
              goto LABEL_378;
            }

            v212 = *(v160 + v159);
            if (v154)
            {
              if (v164 >= v156)
              {
                v213 = 0;
              }

              else
              {
                v213 = *(v160 + v164);
              }

              *v5 = v164;
              v212 = ((v213 & v167) >> v165) | ((v166 & v212) << v154);
            }

            else
            {
              *v5 = v164;
            }

            v170 = v170 & 0xFFFFFFF80FFFFFFFLL | ((v212 & 0x7F) << 28);
            if ((v212 & 0x80) == 0)
            {
              goto LABEL_249;
            }

            v159 = v157 + 7;
            if (v156 < v157 + 7 + v155)
            {
              goto LABEL_378;
            }

            v214 = *(v160 + v164);
            if (v154)
            {
              v215 = v159 >= v156 ? 0 : *(v160 + v159);
              *v5 = v159;
              v214 = ((v215 & v167) >> v165) | ((v166 & v214) << v154);
            }

            else
            {
              *v5 = v159;
            }

            v170 |= (v214 & 0x7F) << 35;
            if ((v214 & 0x80) == 0)
            {
              goto LABEL_258;
            }

            v164 = v157 + 8;
            if (v156 < v157 + 8 + v155)
            {
LABEL_378:
              v144 = 0;
              goto LABEL_484;
            }

            v216 = *(v160 + v159);
            if (v154)
            {
              if (v164 >= v156)
              {
                v217 = 0;
              }

              else
              {
                v217 = *(v160 + v164);
              }

              *v5 = v164;
              v216 = ((v217 & v167) >> v165) | ((v166 & v216) << v154);
            }

            else
            {
              *v5 = v164;
            }

            v170 |= (v216 & 0x7F) << 42;
            if ((v216 & 0x80) == 0)
            {
LABEL_249:
              v159 = v164;
LABEL_258:
              v525 = v170;
              goto LABEL_259;
            }

            v159 = v157 + 9;
            if (v156 < v157 + 9 + v155)
            {
              goto LABEL_516;
            }

            v218 = *(v160 + v164);
            if (v154)
            {
              if (v159 >= v156)
              {
                v219 = 0;
              }

              else
              {
                v219 = *(v160 + v159);
              }

              *v5 = v159;
              v218 = ((v219 & v167) >> v165) | ((v166 & v218) << v154);
            }

            else
            {
              *v5 = v159;
            }

            v170 |= (v218 & 0x7F) << 49;
            if ((v218 & 0x80) != 0)
            {
              v220 = v157 + 10;
              if (v156 < v157 + 10 + v155)
              {
                goto LABEL_516;
              }

              v221 = *(v160 + v159);
              if (v154)
              {
                if (v220 >= v156)
                {
                  v222 = 0;
                }

                else
                {
                  v222 = *(v160 + v220);
                }

                *v5 = v220;
                v221 = ((v222 & v167) >> v165) | ((v166 & v221) << v154);
              }

              else
              {
                *v5 = v220;
              }

              v170 |= (v221 & 0x7F) << 56;
              if ((v221 & 0x80) != 0)
              {
                v159 = v157 + 11;
                if (v156 < v157 + 11 + v155)
                {
                  goto LABEL_516;
                }

                v223 = *(v160 + v220);
                if (v154)
                {
                  if (v159 >= v156)
                  {
                    v224 = 0;
                  }

                  else
                  {
                    v224 = *(v160 + v159);
                  }

                  *v5 = v159;
                  v223 = (((v224 & v167) >> v165) | ((v166 & v223) << v154));
                }

                else
                {
                  *v5 = v159;
                }

                v225 = v170 | (v223 << 63);
                v226 = v525;
                if ((v223 & 0x80u) == 0)
                {
                  v226 = v225;
                }

                v525 = v226;
                if ((v223 & 0x80) != 0)
                {
LABEL_516:
                  v144 = 0;
                  goto LABEL_484;
                }

                v170 = v226;
                goto LABEL_358;
              }

              v159 = v157 + 10;
            }

            v525 = v170;
LABEL_358:
            v12 = v531;
LABEL_259:
            if (v162 < 0xAu)
            {
              v174 = v159 + 1;
              if (v156 < v159 + 1 + v155)
              {
                goto LABEL_378;
              }

              v175 = v117;
              if (v154)
              {
                if (v174 >= v156)
                {
                  v176 = 0;
                }

                else
                {
                  v176 = *(v160 + v174);
                }

                v180 = (1 << (8 - v154)) + 255;
                v181 = 0xFFFF << (8 - v154);
                v182 = *(v160 + v159);
                *v5 = v174;
                v177 = ((v176 & v181) >> (8 - v154)) | ((v180 & v182) << v154);
                v535 = ((v176 & v181) >> (8 - v154)) | ((((1 << (8 - v154)) - 1) & v182) << v154);
                v178 = v159 + 2;
                if (v156 < v159 + 2 + v155)
                {
                  goto LABEL_377;
                }

                if (v178 >= v156)
                {
                  v183 = 0;
                }

                else
                {
                  v183 = *(v160 + v178);
                }

                v184 = *(v160 + v174);
                *v5 = v178;
                v185 = (((v183 & v181) >> (8 - v154)) | ((v180 & v184) << v154));
                v534 = v185;
                if (v185)
                {
                  goto LABEL_274;
                }

LABEL_266:
                v533 = 6144;
                if (!geo::codec::MaterialSheet::decodeProperty(a2, v162, &v535, &v533, buf))
                {
                  goto LABEL_377;
                }
              }

              else
              {
                LOBYTE(v177) = *(v160 + v159);
                *v5 = v174;
                v535 = v177;
                v178 = v159 + 2;
                if (v156 < v159 + 2 + v155)
                {
                  goto LABEL_377;
                }

                v179 = *(v160 + v174);
                *v5 = v178;
                v534 = v179;
                if (!v179)
                {
                  goto LABEL_266;
                }

LABEL_274:
                v186 = v159 + 3;
                if (v156 < v186 + v155)
                {
                  goto LABEL_377;
                }

                if (v154)
                {
                  if (v186 >= v156)
                  {
                    v187 = 0;
                  }

                  else
                  {
                    v187 = *(v160 + v186);
                  }

                  v189 = *(v160 + v178);
                  *v5 = v186;
                  v188 = (((v187 & (0xFFFF << (8 - v154))) >> (8 - v154)) | ((((1 << (8 - v154)) - 1) & v189) << v154));
                }

                else
                {
                  v188 = *(v160 + v178);
                  *v5 = v186;
                }

                if (v188)
                {
                  v190 = 0;
                  while (1)
                  {
                    v191 = *(a2 + 24);
                    v192 = v191 != 0;
                    v193 = *(a2 + 1);
                    v194 = *(a2 + 2);
                    v195 = v194 + 2;
                    if (!v191)
                    {
                      v195 = v194 + 1;
                    }

                    if (v193 < v195)
                    {
                      break;
                    }

                    v196 = v194 + 1;
                    v197 = *a2;
                    if (*(a2 + 24))
                    {
                      if (v196 >= v193)
                      {
                        v198 = 0;
                      }

                      else
                      {
                        v198 = *(v197 + v196);
                      }

                      v202 = *(v197 + v194);
                      *v5 = v196;
                      v203 = v194 + 2;
                      if (v193 < v203 + v192)
                      {
                        break;
                      }

                      if (v203 >= v193)
                      {
                        v204 = 0;
                      }

                      else
                      {
                        v204 = *(v197 + v203);
                      }

                      v205 = (1 << (8 - v191)) + 255;
                      v206 = 0xFFFF << (8 - v191);
                      v199 = ((v198 & v206) >> (8 - v191)) | ((v205 & v202) << v191);
                      v207 = *(v197 + v196);
                      *v5 = v203;
                      v201 = ((v204 & v206) >> (8 - v191)) | ((v205 & v207) << v191);
                    }

                    else
                    {
                      LOBYTE(v199) = *(v197 + v194);
                      *v5 = v196;
                      v200 = v194 + 2;
                      if (v193 < v200 + v192)
                      {
                        break;
                      }

                      LOBYTE(v201) = *(v197 + v196);
                      *v5 = v200;
                    }

                    LOBYTE(v533) = v199;
                    HIBYTE(v533) = v201;
                    if (!geo::codec::MaterialSheet::decodeProperty(a2, v162, &v535, &v533, buf))
                    {
                      break;
                    }

                    if (v188 <= ++v190)
                    {
                      goto LABEL_299;
                    }
                  }

LABEL_377:
                  v144 = 0;
                  LODWORD(v117) = v175;
                  goto LABEL_484;
                }
              }

LABEL_299:
              std::__hash_table<std::__hash_value_type<unsigned char,BOOL>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,unsigned char &,unsigned char &>(&v565[1], v177);
              v117 = v175;
              v12 = v531;
              continue;
            }

            *v5 = v159 + v170;
          }
        }

        if (a3 >= 0x14)
        {
          break;
        }

LABEL_384:
        v241 = *(v12 + 16);
        v240 = *(v12 + 24);
        if (v241 >= v240)
        {
          v244 = *(v12 + 8);
          v245 = 0x823EE08FB823EE09 * ((v241 - v244) >> 3);
          v246 = v245 + 1;
          if (v245 + 1 > 0x8FB823EE08FB82)
          {
            std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
          }

          v247 = 0x823EE08FB823EE09 * ((v240 - v244) >> 3);
          if (2 * v247 > v246)
          {
            v246 = 2 * v247;
          }

          if (v247 >= 0x47DC11F7047DC1)
          {
            v248 = 0x8FB823EE08FB82;
          }

          else
          {
            v248 = v246;
          }

          if (v248)
          {
            if (v248 <= 0x8FB823EE08FB82)
            {
              operator new();
            }

LABEL_842:
            std::__throw_bad_array_new_length[abi:ne200100]();
          }

          v249 = (8 * ((v241 - v244) >> 3));
          geo::codec::MaterialSheet::Material::Material(v249, buf);
          v250 = v531[1];
          v251 = v531[2];
          v252 = v251 - v250;
          if (v251 == v250)
          {
            v334 = v531;
          }

          else
          {
            v529 = v251 - v250;
            v253 = 0;
            v254 = -8 * ((v251 - v250) >> 3) + 456 * v245;
            do
            {
              v256 = v254 + v253;
              v257 = (v250 + v253);
              v258 = *(v250 + v253);
              *v257 = 0;
              *v256 = v258;
              *(v256 + 8) = *(v250 + v253 + 8);
              v257[1] = 0;
              v259 = *(v250 + v253 + 16);
              *(v254 + v253 + 16) = v259;
              v260 = *(v250 + v253 + 24);
              *(v256 + 24) = v260;
              *(v256 + 32) = *(v250 + v253 + 32);
              if (v260)
              {
                v261 = *(v259 + 8);
                v262 = *(v256 + 8);
                if ((v262 & (v262 - 1)) != 0)
                {
                  if (v261 >= v262)
                  {
                    v261 %= v262;
                  }
                }

                else
                {
                  v261 &= v262 - 1;
                }

                *(v258 + 8 * v261) = v254 + v253 + 16;
                *(v250 + v253 + 16) = 0;
                *(v250 + v253 + 24) = 0;
              }

              v265 = v257[7];
              v263 = v257 + 7;
              v264 = v265;
              v266 = *(v263 - 2);
              *(v263 - 2) = 0;
              *(v256 + 40) = v266;
              *(v256 + 48) = *(v263 - 1);
              *(v263 - 1) = 0;
              *(v256 + 56) = v265;
              v267 = v256 + 56;
              v268 = v263[1];
              *(v256 + 64) = v268;
              *(v256 + 72) = *(v263 + 4);
              if (v268)
              {
                v269 = *(v264 + 8);
                v270 = *(v256 + 48);
                if ((v270 & (v270 - 1)) != 0)
                {
                  if (v269 >= v270)
                  {
                    v269 %= v270;
                  }
                }

                else
                {
                  v269 &= v270 - 1;
                }

                *(v266 + 8 * v269) = v267;
                *v263 = 0;
                v263[1] = 0;
              }

              v271 = v254 + v253;
              v272 = v250 + v253;
              v273 = (v250 + v253 + 96);
              v274 = *v273;
              v275 = *(v250 + v253 + 80);
              *(v273 - 2) = 0;
              *(v271 + 80) = v275;
              *(v271 + 88) = *(v250 + v253 + 88);
              *(v273 - 1) = 0;
              *(v254 + v253 + 96) = v274;
              v276 = *(v250 + v253 + 104);
              *(v271 + 104) = v276;
              *(v271 + 112) = *(v250 + v253 + 112);
              if (v276)
              {
                v277 = *(v274 + 8);
                v278 = *(v271 + 88);
                if ((v278 & (v278 - 1)) != 0)
                {
                  if (v277 >= v278)
                  {
                    v277 %= v278;
                  }
                }

                else
                {
                  v277 &= v278 - 1;
                }

                *(v275 + 8 * v277) = v254 + v253 + 96;
                *v273 = 0;
                *(v250 + v253 + 104) = 0;
              }

              v281 = *(v272 + 17);
              v279 = v272 + 136;
              v280 = v281;
              v282 = *(v279 - 2);
              *(v279 - 2) = 0;
              *(v271 + 120) = v282;
              *(v271 + 128) = *(v279 - 1);
              *(v279 - 1) = 0;
              *(v271 + 136) = v281;
              v283 = v271 + 136;
              v284 = *(v279 + 1);
              *(v271 + 144) = v284;
              *(v271 + 152) = *(v279 + 4);
              if (v284)
              {
                v285 = *(v280 + 8);
                v286 = *(v271 + 128);
                if ((v286 & (v286 - 1)) != 0)
                {
                  if (v285 >= v286)
                  {
                    v285 %= v286;
                  }
                }

                else
                {
                  v285 &= v286 - 1;
                }

                *(v282 + 8 * v285) = v283;
                *v279 = 0;
                *(v279 + 1) = 0;
              }

              v287 = v254 + v253;
              v288 = v250 + v253;
              v289 = (v250 + v253 + 176);
              v290 = *v289;
              v291 = *(v250 + v253 + 160);
              *(v289 - 2) = 0;
              *(v287 + 160) = v291;
              *(v287 + 168) = *(v250 + v253 + 168);
              *(v289 - 1) = 0;
              *(v254 + v253 + 176) = v290;
              v292 = *(v250 + v253 + 184);
              *(v287 + 184) = v292;
              *(v287 + 192) = *(v250 + v253 + 192);
              if (v292)
              {
                v293 = *(v290 + 8);
                v294 = *(v287 + 168);
                if ((v294 & (v294 - 1)) != 0)
                {
                  if (v293 >= v294)
                  {
                    v293 %= v294;
                  }
                }

                else
                {
                  v293 &= v294 - 1;
                }

                *(v291 + 8 * v293) = v254 + v253 + 176;
                *v289 = 0;
                *(v250 + v253 + 184) = 0;
              }

              v297 = *(v288 + 27);
              v295 = v288 + 216;
              v296 = v297;
              v298 = *(v295 - 2);
              *(v295 - 2) = 0;
              *(v287 + 200) = v298;
              *(v287 + 208) = *(v295 - 1);
              *(v295 - 1) = 0;
              *(v287 + 216) = v297;
              v299 = v287 + 216;
              v300 = *(v295 + 1);
              *(v287 + 224) = v300;
              *(v287 + 232) = *(v295 + 4);
              if (v300)
              {
                v301 = *(v296 + 8);
                v302 = *(v287 + 208);
                if ((v302 & (v302 - 1)) != 0)
                {
                  if (v301 >= v302)
                  {
                    v301 %= v302;
                  }
                }

                else
                {
                  v301 &= v302 - 1;
                }

                *(v298 + 8 * v301) = v299;
                *v295 = 0;
                *(v295 + 1) = 0;
              }

              v303 = v254 + v253;
              v304 = v250 + v253;
              v305 = *(v250 + v253 + 240);
              *(v304 + 30) = 0;
              *(v303 + 240) = v305;
              *(v303 + 248) = *(v250 + v253 + 248);
              *(v304 + 31) = 0;
              v306 = *(v250 + v253 + 256);
              *(v303 + 256) = v306;
              v307 = *(v250 + v253 + 264);
              *(v303 + 264) = v307;
              *(v303 + 272) = *(v250 + v253 + 272);
              if (v307)
              {
                v308 = *(v306 + 8);
                v309 = *(v303 + 248);
                if ((v309 & (v309 - 1)) != 0)
                {
                  if (v308 >= v309)
                  {
                    v308 %= v309;
                  }
                }

                else
                {
                  v308 &= v309 - 1;
                }

                *(v305 + 8 * v308) = v303 + 256;
                *(v304 + 32) = 0;
                *(v304 + 33) = 0;
              }

              v310 = *(v304 + 35);
              *(v304 + 35) = 0;
              *(v303 + 280) = v310;
              *(v303 + 288) = *(v304 + 36);
              *(v304 + 36) = 0;
              v311 = *(v304 + 37);
              *(v303 + 296) = v311;
              v312 = *(v304 + 38);
              *(v303 + 304) = v312;
              *(v303 + 312) = *(v304 + 78);
              if (v312)
              {
                v313 = *(v311 + 8);
                v314 = *(v303 + 288);
                if ((v314 & (v314 - 1)) != 0)
                {
                  if (v313 >= v314)
                  {
                    v313 %= v314;
                  }
                }

                else
                {
                  v313 &= v314 - 1;
                }

                *(v310 + 8 * v313) = v303 + 296;
                *(v304 + 37) = 0;
                *(v304 + 38) = 0;
              }

              v315 = v254 + v253;
              v316 = v250 + v253;
              v317 = *(v250 + v253 + 320);
              *(v316 + 40) = 0;
              *(v315 + 320) = v317;
              *(v315 + 328) = *(v250 + v253 + 328);
              *(v316 + 41) = 0;
              v318 = *(v250 + v253 + 336);
              *(v315 + 336) = v318;
              v319 = *(v250 + v253 + 344);
              *(v315 + 344) = v319;
              *(v315 + 352) = *(v250 + v253 + 352);
              if (v319)
              {
                v320 = *(v318 + 8);
                v321 = *(v315 + 328);
                if ((v321 & (v321 - 1)) != 0)
                {
                  if (v320 >= v321)
                  {
                    v320 %= v321;
                  }
                }

                else
                {
                  v320 &= v321 - 1;
                }

                *(v317 + 8 * v320) = v315 + 336;
                *(v316 + 42) = 0;
                *(v316 + 43) = 0;
              }

              v322 = *(v316 + 45);
              *(v316 + 45) = 0;
              *(v315 + 360) = v322;
              *(v315 + 368) = *(v316 + 46);
              *(v316 + 46) = 0;
              v323 = *(v316 + 47);
              *(v315 + 376) = v323;
              v324 = *(v316 + 48);
              *(v315 + 384) = v324;
              *(v315 + 392) = *(v316 + 98);
              if (v324)
              {
                v325 = *(v323 + 8);
                v326 = *(v315 + 368);
                if ((v326 & (v326 - 1)) != 0)
                {
                  if (v325 >= v326)
                  {
                    v325 %= v326;
                  }
                }

                else
                {
                  v325 &= v326 - 1;
                }

                *(v322 + 8 * v325) = v315 + 376;
                *(v316 + 47) = 0;
                *(v316 + 48) = 0;
              }

              v327 = v254 + v253;
              v328 = v250 + v253;
              *(v327 + 400) = *(v250 + v253 + 400);
              v329 = *(v250 + v253 + 408);
              *(v328 + 51) = 0;
              *(v327 + 408) = v329;
              *(v327 + 416) = *(v250 + v253 + 416);
              *(v328 + 52) = 0;
              v330 = *(v250 + v253 + 424);
              *(v327 + 424) = v330;
              v331 = *(v250 + v253 + 432);
              *(v327 + 432) = v331;
              *(v327 + 440) = *(v250 + v253 + 440);
              if (v331)
              {
                v255 = *(v330 + 8);
                v332 = *(v327 + 416);
                if ((v332 & (v332 - 1)) != 0)
                {
                  if (v255 >= v332)
                  {
                    v255 %= v332;
                  }
                }

                else
                {
                  v255 &= v332 - 1;
                }

                *(v329 + 8 * v255) = v327 + 424;
                *(v328 + 53) = 0;
                *(v328 + 54) = 0;
              }

              *(v327 + 448) = *(v328 + 224);
              v253 += 456;
            }

            while ((v250 + v253) != v251);
            do
            {
              geo::codec::MaterialSheet::Material::~Material(v250);
              v250 = (v333 + 456);
            }

            while (v250 != v251);
            v250 = v531[1];
            v334 = v531;
            v252 = v529;
          }

          v242 = v249 + 456;
          v334[1] = v249 - v252;
          v334[2] = v249 + 456;
          v334[3] = 0;
          if (v250)
          {
            operator delete(v250);
          }

          v243 = v531;
        }

        else
        {
          geo::codec::MaterialSheet::Material::Material(*(v12 + 16), buf);
          v242 = (v241 + 456);
          v243 = v531;
          v531[2] = v241 + 456;
        }

        v243[2] = v242;
        v336 = v243[5];
        v335 = v243[6];
        if (v336 >= v335)
        {
          v339 = v243[4];
          v340 = 0xAAAAAAAAAAAAAAABLL * ((v336 - v339) >> 3);
          v341 = v340 + 1;
          if (v340 + 1 > 0xAAAAAAAAAAAAAAALL)
          {
            std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
          }

          v342 = 0xAAAAAAAAAAAAAAABLL * ((v335 - v339) >> 3);
          if (2 * v342 > v341)
          {
            v341 = 2 * v342;
          }

          if (v342 >= 0x555555555555555)
          {
            v343 = 0xAAAAAAAAAAAAAAALL;
          }

          else
          {
            v343 = v341;
          }

          if (v343)
          {
            if (v343 <= 0xAAAAAAAAAAAAAAALL)
            {
              operator new();
            }

            goto LABEL_842;
          }

          v344 = 24 * v340;
          *v344 = 0;
          *(v344 + 8) = 0;
          *(v344 + 16) = 0;
          v337 = (v344 + 24);
          v345 = v531[4];
          v346 = v531[5] - v345;
          v347 = (v344 - v346);
          v338 = v531;
          memcpy(v347, v345, v346);
          v531[4] = v347;
          v531[5] = v337;
          v531[6] = 0;
          if (v345)
          {
            operator delete(v345);
          }
        }

        else
        {
          *v336 = 0;
          v336[1] = 0;
          v336[2] = 0;
          v337 = v336 + 3;
          v338 = v531;
          v531[5] = v337;
        }

        v338[5] = v337;
        v144 = 1;
LABEL_484:
        geo::codec::MaterialSheet::Material::~Material(buf);
        if ((v144 & 1) == 0)
        {
          return 0;
        }

        v117 = (v117 + 1);
        v12 = v531;
        if (v117 == v527)
        {
          v103 = *(a2 + 24);
          v105 = *(a2 + 1);
          v102 = *(a2 + 2);
          goto LABEL_566;
        }
      }

      v227 = *(a2 + 24);
      v228 = *(a2 + 24) != 0;
      v229 = *(a2 + 1);
      v230 = *(a2 + 2);
      v231 = v230 + 2;
      if (!*(a2 + 24))
      {
        v231 = v230 + 1;
      }

      if (v229 < v231)
      {
        goto LABEL_216;
      }

      v232 = 8 - v227;
      v233 = (1 << (8 - v227)) + 255;
      v234 = 0xFFFF << (8 - v227);
      v235 = *a2;
      v236 = v230 + 1;
      v237 = *(*a2 + v230);
      if (*(a2 + 24))
      {
        if (v236 >= v229)
        {
          v238 = 0;
        }

        else
        {
          v238 = *(v235 + v236);
        }

        *v5 = v236;
        v237 = ((v238 & v234) >> v232) | ((v233 & v237) << v227);
      }

      else
      {
        *v5 = v236;
      }

      v239 = v237 & 0x7F;
      if ((v237 & 0x80) != 0)
      {
        v348 = v230 + 2;
        if (v229 < v230 + 2 + v228)
        {
          goto LABEL_216;
        }

        v349 = *(v235 + v236);
        if (v227)
        {
          v350 = v348 >= v229 ? 0 : *(v235 + v348);
          *v5 = v348;
          v349 = ((v350 & v234) >> v232) | ((v233 & v349) << v227);
        }

        else
        {
          *v5 = v348;
        }

        v239 = v239 & 0xFFFFFFFFFFFFC07FLL | ((v349 & 0x7F) << 7);
        if ((v349 & 0x80) != 0)
        {
          v351 = v230 + 3;
          if (v229 < v230 + 3 + v228)
          {
            goto LABEL_216;
          }

          v352 = *(v235 + v348);
          if (v227)
          {
            v353 = v351 >= v229 ? 0 : *(v235 + v351);
            *v5 = v351;
            v352 = ((v353 & v234) >> v232) | ((v233 & v352) << v227);
          }

          else
          {
            *v5 = v351;
          }

          v239 = v239 & 0xFFFFFFFFFFE03FFFLL | ((v352 & 0x7F) << 14);
          if ((v352 & 0x80) != 0)
          {
            v354 = v230 + 4;
            if (v229 < v230 + 4 + v228)
            {
              goto LABEL_216;
            }

            v355 = *(v235 + v351);
            if (v227)
            {
              v356 = v354 >= v229 ? 0 : *(v235 + v354);
              *v5 = v354;
              v355 = ((v356 & v234) >> v232) | ((v233 & v355) << v227);
            }

            else
            {
              *v5 = v354;
            }

            v239 = v239 & 0xFFFFFFFFF01FFFFFLL | ((v355 & 0x7F) << 21);
            v12 = v531;
            if ((v355 & 0x80) != 0)
            {
              v357 = v230 + 5;
              if (v229 < v230 + 5 + v228)
              {
                goto LABEL_512;
              }

              v358 = *(v235 + v354);
              if (v227)
              {
                if (v357 >= v229)
                {
                  v359 = 0;
                }

                else
                {
                  v359 = *(v235 + v357);
                }

                *v5 = v357;
                v358 = (((v359 & v234) >> v232) | ((v233 & v358) << v227));
              }

              else
              {
                *v5 = v357;
              }

              v239 |= v358 << 28;
              if ((v358 & 0x80) != 0)
              {
                v360 = v230 + 6;
                if (v229 < v230 + 6 + v228)
                {
                  goto LABEL_512;
                }

                v361 = *(v235 + v357);
                if (v227)
                {
                  v362 = v360 >= v229 ? 0 : *(v235 + v360);
                  *v5 = v360;
                  v361 = ((v362 & v234) >> v232) | ((v233 & v361) << v227);
                }

                else
                {
                  *v5 = v360;
                }

                if ((v361 & 0x80) != 0)
                {
                  v363 = v230 + 7;
                  if (v229 < v230 + 7 + v228)
                  {
                    goto LABEL_512;
                  }

                  v364 = *(v235 + v360);
                  if (v227)
                  {
                    v365 = v363 >= v229 ? 0 : *(v235 + v363);
                    *v5 = v363;
                    v364 = ((v365 & v234) >> v232) | ((v233 & v364) << v227);
                  }

                  else
                  {
                    *v5 = v363;
                  }

                  if ((v364 & 0x80) != 0)
                  {
                    v366 = v230 + 8;
                    if (v229 < v230 + 8 + v228)
                    {
                      goto LABEL_512;
                    }

                    v367 = *(v235 + v363);
                    if (v227)
                    {
                      v368 = v366 >= v229 ? 0 : *(v235 + v366);
                      *v5 = v366;
                      v367 = ((v368 & v234) >> v232) | ((v233 & v367) << v227);
                    }

                    else
                    {
                      *v5 = v366;
                    }

                    if ((v367 & 0x80) != 0)
                    {
                      v369 = v230 + 9;
                      if (v229 < v230 + 9 + v228)
                      {
                        goto LABEL_512;
                      }

                      v370 = *(v235 + v366);
                      if (v227)
                      {
                        if (v369 >= v229)
                        {
                          v371 = 0;
                        }

                        else
                        {
                          v371 = *(v235 + v369);
                        }

                        *v5 = v369;
                        v370 = ((v371 & v234) >> v232) | ((v233 & v370) << v227);
                      }

                      else
                      {
                        *v5 = v369;
                      }

                      v12 = v531;
                      if ((v370 & 0x80) == 0)
                      {
                        goto LABEL_383;
                      }

                      v372 = v230 + 10;
                      if (v229 < v372 + v228)
                      {
                        goto LABEL_512;
                      }

                      v373 = *(v235 + v369);
                      if (v227)
                      {
                        if (v372 >= v229)
                        {
                          v374 = 0;
                        }

                        else
                        {
                          v374 = *(v235 + v372);
                        }

                        *v5 = v372;
                        v373 = ((v374 & v234) >> v232) | ((v233 & v373) << v227);
                      }

                      else
                      {
                        *v5 = v372;
                      }

                      v375 = v524;
                      if ((v373 & 0x80u) == 0)
                      {
                        v375 = v239;
                      }

                      v524 = v375;
                      if ((v373 & 0x80) != 0)
                      {
LABEL_512:
                        v144 = 0;
                        goto LABEL_484;
                      }

                      v239 = v375;
                    }
                  }
                }
              }

              v12 = v531;
            }
          }
        }
      }

LABEL_383:
      v565[0] = v239;
      v524 = v239;
      goto LABEL_384;
    }

LABEL_566:
    v376 = v102 + 2;
    if (!v103)
    {
      v376 = v102 + 1;
    }

    if (v105 < v376)
    {
      return 0;
    }

    v377 = v102 + 1;
    v378 = *a2;
    if (v103)
    {
      v379 = *(v378 + v102);
      if (v377 >= v105)
      {
        v380 = 0;
      }

      else
      {
        v380 = *(v378 + v377);
      }

      *v5 = v377;
      v381 = ((v380 & (0xFFFF << (8 - v103))) >> (8 - v103)) | ((((1 << (8 - v103)) + 255) & v379) << v103);
    }

    else
    {
      LOBYTE(v381) = *(v378 + v102);
      *v5 = v377;
    }

    v382 = v381;
    v383 = *(v12 + 520);
    v384 = *(v12 + 512);
    v385 = &v383[-v384];
    v386 = 0xCCCCCCCCCCCCCCCDLL * (&v383[-v384] >> 3);
    v387 = v382 >= v386;
    v388 = v382 - v386;
    if (v388 != 0 && v387)
    {
      v389 = *(v12 + 528);
      if (0xCCCCCCCCCCCCCCCDLL * ((v389 - v383) >> 3) < v388)
      {
        v390 = 0xCCCCCCCCCCCCCCCDLL * ((v389 - v384) >> 3);
        v391 = 0x999999999999999ALL * ((v389 - v384) >> 3);
        if (v391 <= v382)
        {
          v391 = v382;
        }

        if (v390 >= 0x333333333333333)
        {
          v392 = 0x666666666666666;
        }

        else
        {
          v392 = v391;
        }

        v393 = geo::codec::zone_mallocator::instance(this);
        v394 = pthread_rwlock_rdlock((v393 + 32));
        if (v394)
        {
          geo::read_write_lock::logFailure(v394, "read lock", v395);
        }

        v396 = malloc_type_zone_malloc(*v393, 40 * v392, 0x1010040FC026F3AuLL);
        atomic_fetch_add((v393 + 24), 1u);
        v397 = pthread_rwlock_unlock((v393 + 32));
        if (v397)
        {
          geo::read_write_lock::logFailure(v397, "unlock", v398);
        }

        v399 = &v396[40 * v382];
        v400 = &v385[v396];
        do
        {
          *(v400 + 4) = 0;
          *v400 = 0uLL;
          *(v400 + 1) = 0uLL;
          v400[33] = 2;
          v400 += 40;
        }

        while (v400 != v399);
        v401 = v531[65];
        v402 = v531[64];
        v382 = &v385[v396 + v402 - v401];
        if (v401 == v402)
        {
          v411 = v531;
        }

        else
        {
          v403 = v531[64];
          v404 = &v385[v396 + v402 - v401];
          do
          {
            *v404 = 0;
            *(v404 + 1) = 0;
            *(v404 + 2) = 0;
            v404[24] = v403[24];
            *v404 = *v403;
            *(v404 + 2) = *(v403 + 2);
            *v403 = 0;
            *(v403 + 1) = 0;
            *(v403 + 2) = 0;
            *(v404 + 4) = *(v403 + 4);
            v403 += 40;
            v404 += 40;
          }

          while (v403 != v401);
          do
          {
            v405 = *v402;
            if (*v402)
            {
              *(v402 + 1) = v405;
              v406 = geo::codec::zone_mallocator::instance(v397);
              geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v406, v405);
            }

            v402 += 40;
          }

          while (v402 != v401);
          v411 = v531;
          v402 = v531[64];
        }

        v411[64] = v382;
        v411[65] = v399;
        v411[66] = &v396[40 * v392];
        v12 = v411;
        if (v402)
        {
          v412 = geo::codec::zone_mallocator::instance(v397);
          v413 = pthread_rwlock_rdlock((v412 + 32));
          if (v413)
          {
            geo::read_write_lock::logFailure(v413, "read lock", v414);
          }

          atomic_fetch_add((v412 + 24), 0xFFFFFFFF);
          malloc_zone_free(*v412, v402);
          v415 = pthread_rwlock_unlock((v412 + 32));
          if (v415)
          {
            geo::read_write_lock::logFailure(v415, "unlock", v416);
          }

          v399 = *(v12 + 520);
        }

LABEL_616:
        v417 = *(v12 + 512);
        if (v417 == v399)
        {
          return 1;
        }

        v418 = *v5;
        if (a3 > 0x13)
        {
          while (1)
          {
            v419 = v418 + 4;
            v420 = *(a2 + 24);
            v421 = v420 != 0;
            if (v420)
            {
              v422 = v418 + 5;
            }

            else
            {
              v422 = v418 + 4;
            }

            v423 = *(a2 + 1);
            if (v423 < v422)
            {
              return 0;
            }

            v424 = *a2;
            if (*(a2 + 24))
            {
              v425 = v418 + 1;
              if (v418 + 1 >= v423)
              {
                v426 = 0;
              }

              else
              {
                v426 = *(v424 + v425);
              }

              v429 = *(v424 + v418);
              *v5 = v425;
              v430 = v418 + 2;
              if (v418 + 2 >= v423)
              {
                v431 = 0;
              }

              else
              {
                v431 = *(v424 + v430);
              }

              v432 = *(v424 + v425);
              *v5 = v430;
              v433 = *(v424 + v430);
              v434 = v418 + 3;
              if (v418 + 3 >= v423)
              {
                v435 = 0;
              }

              else
              {
                v435 = *(v424 + v434);
              }

              *v5 = v434;
              v436 = *(v424 + v434);
              if (v419 >= v423)
              {
                v437 = 0;
              }

              else
              {
                v437 = *(v424 + v419);
              }

              v438 = 8 - v420;
              v439 = (1 << (8 - v420)) + 255;
              v440 = 0xFFFF << (8 - v420);
              *v5 = v419;
              *(v417 + 36) = ((((v435 & v440) >> v438) | ((v439 & v433) << v420)) << 16) | ((((v437 & v440) >> v438) | ((v439 & v436) << v420)) << 24) | ((((v431 & v440) >> v438) | ((v439 & v432) << v420)) << 8) | ((v426 & v440) >> v438) | ((v439 & v429) << v420);
              v428 = v419 + 1;
              if (v423 < v419 + 1 + v421)
              {
                return 0;
              }

              v441 = *a2;
              v442 = v428 >= v423 ? 0 : *(v441 + v428);
              v444 = *(v441 + v419);
              *v5 = v428;
              v443 = ((v442 & (0xFFFF << (8 - v420))) >> (8 - v420)) | ((((1 << (8 - v420)) + 255) & v444) << v420);
            }

            else
            {
              v427 = *(v424 + v418);
              *v5 = v419;
              *(v417 + 36) = v427;
              v428 = v419 + 1;
              if (v423 < v419 + 1 + v421)
              {
                return 0;
              }

              LOBYTE(v443) = *(*a2 + v419);
              *v5 = v428;
            }

            *(v417 + 32) = v443;
            v445 = v419 + 2;
            v446 = *(a2 + 24);
            v447 = *(a2 + 24) != 0;
            v448 = v419 + 3;
            v449 = *(a2 + 24) ? v448 : v445;
            v450 = *(a2 + 1);
            if (v450 < v449)
            {
              return 0;
            }

            v451 = *a2;
            if (*(a2 + 24))
            {
              v452 = v445 >= v450 ? 0 : *(v451 + v445);
              v453 = *(v451 + v428);
              *v5 = v445;
              LODWORD(v428) = ((v452 & (0xFFFF << (8 - v446))) >> (8 - v446)) | ((((1 << (8 - v446)) + 255) & v453) << v446);
            }

            else
            {
              LOBYTE(v428) = *(v451 + v428);
              *v5 = v445;
            }

            *(v417 + 33) = v428;
            v454 = *(a2 + 2);
            v455 = v454 + 1;
            if (v450 < v454 + 1 + v447)
            {
              return 0;
            }

            v456 = 8 - v446;
            v457 = (1 << (8 - v446)) + 255;
            v458 = 0xFFFF << (8 - v446);
            v459 = *a2;
            v460 = *(*a2 + v454);
            if (v446)
            {
              v461 = v455 >= v450 ? 0 : *(v459 + v455);
              *v5 = v455;
              v460 = ((v461 & v458) >> v456) | ((v457 & v460) << v446);
            }

            else
            {
              *v5 = v455;
            }

            v462 = v460 & 0x7F;
            if ((v460 & 0x80) != 0)
            {
              v464 = v454 + 2;
              if (v450 < v454 + 2 + v447)
              {
                return 0;
              }

              v465 = *(v459 + v455);
              if (v446)
              {
                if (v464 >= v450)
                {
                  v466 = 0;
                }

                else
                {
                  v466 = *(v459 + v464);
                }

                *v5 = v464;
                v465 = ((v466 & v458) >> v456) | ((v457 & v465) << v446);
              }

              else
              {
                *v5 = v464;
              }

              v462 = v462 & 0xFFFFFFFFFFFFC07FLL | ((v465 & 0x7F) << 7);
              if ((v465 & 0x80) == 0)
              {
                goto LABEL_669;
              }

              v455 = v454 + 3;
              if (v450 < v454 + 3 + v447)
              {
                return 0;
              }

              v467 = *(v459 + v464);
              if (v446)
              {
                v468 = v455 >= v450 ? 0 : *(v459 + v455);
                *v5 = v455;
                v467 = ((v468 & v458) >> v456) | ((v457 & v467) << v446);
              }

              else
              {
                *v5 = v455;
              }

              v462 = v462 & 0xFFFFFFFFFFE03FFFLL | ((v467 & 0x7F) << 14);
              if ((v467 & 0x80) != 0)
              {
                v464 = v454 + 4;
                if (v450 < v454 + 4 + v447)
                {
                  return 0;
                }

                v469 = *(v459 + v455);
                if (v446)
                {
                  if (v464 >= v450)
                  {
                    v470 = 0;
                  }

                  else
                  {
                    v470 = *(v459 + v464);
                  }

                  *v5 = v464;
                  v469 = ((v470 & v458) >> v456) | ((v457 & v469) << v446);
                }

                else
                {
                  *v5 = v464;
                }

                v462 = v462 & 0xFFFFFFFFF01FFFFFLL | ((v469 & 0x7F) << 21);
                if ((v469 & 0x80) == 0)
                {
                  goto LABEL_669;
                }

                v455 = v454 + 5;
                if (v450 < v454 + 5 + v447)
                {
                  return 0;
                }

                v471 = *(v459 + v464);
                if (v446)
                {
                  v472 = v455 >= v450 ? 0 : *(v459 + v455);
                  *v5 = v455;
                  v471 = ((v472 & v458) >> v456) | ((v457 & v471) << v446);
                }

                else
                {
                  *v5 = v455;
                }

                v462 = v462 & 0xFFFFFFF80FFFFFFFLL | ((v471 & 0x7F) << 28);
                if ((v471 & 0x80) != 0)
                {
                  break;
                }
              }
            }

            v463 = 0;
LABEL_670:
            v382 = v462;
LABEL_671:
            result = 0;
            if (!v463 && v382)
            {
              if (v382 > *(a2 + 1) - ((v455 + (*(a2 + 24) >> 3)) & 0x1FFFFFFFFFFFFFFFLL))
              {
                goto LABEL_838;
              }

              std::vector<unsigned char,geo::allocator_adapter<unsigned char,geo::codec::zone_mallocator>>::__assign_with_size[abi:ne200100]<unsigned char const*,unsigned char const*>(v417, (v459 + v455), (v459 + v455 + v382), v382);
              v418 = *v5 + v382;
              *v5 = v418;
              v417 += 40;
              result = 1;
              if (v417 != v399)
              {
                continue;
              }
            }

            return result;
          }

          v464 = v454 + 6;
          if (v450 < v454 + 6 + v447)
          {
            return 0;
          }

          v473 = *(v459 + v455);
          if (v446)
          {
            if (v464 >= v450)
            {
              v474 = 0;
            }

            else
            {
              v474 = *(v459 + v464);
            }

            *v5 = v464;
            v473 = ((v474 & v458) >> v456) | ((v457 & v473) << v446);
          }

          else
          {
            *v5 = v464;
          }

          v462 |= (v473 & 0x7F) << 35;
          if ((v473 & 0x80) != 0)
          {
            v455 = v454 + 7;
            if (v450 < v454 + 7 + v447)
            {
              return 0;
            }

            v475 = *(v459 + v464);
            if (v446)
            {
              if (v455 >= v450)
              {
                v476 = 0;
              }

              else
              {
                v476 = *(v459 + v455);
              }

              *v5 = v455;
              v475 = ((v476 & v458) >> v456) | ((v457 & v475) << v446);
            }

            else
            {
              *v5 = v455;
            }

            v477 = v462 | ((v475 & 0x7F) << 42);
            if ((v475 & 0x80) == 0)
            {
              v463 = 0;
              v382 = v462 | ((v475 & 0x7F) << 42);
              goto LABEL_671;
            }

            v478 = v454 + 8;
            if (v450 < v454 + 8 + v447)
            {
              return 0;
            }

            v479 = *(v459 + v455);
            if (v446)
            {
              if (v478 >= v450)
              {
                v480 = 0;
              }

              else
              {
                v480 = *(v459 + v478);
              }

              *v5 = v478;
              v479 = ((v480 & v458) >> v456) | ((v457 & v479) << v446);
            }

            else
            {
              *v5 = v478;
            }

            v481 = v477 | ((v479 & 0x7F) << 49);
            if ((v479 & 0x80) == 0)
            {
              v463 = 0;
              v455 = v454 + 8;
              v382 = v481;
              goto LABEL_671;
            }

            v464 = v454 + 9;
            if (v450 < v454 + 9 + v447)
            {
              return 0;
            }

            v482 = *(v459 + v478);
            if (v446)
            {
              if (v464 >= v450)
              {
                v483 = 0;
              }

              else
              {
                v483 = *(v459 + v464);
              }

              *v5 = v464;
              v482 = ((v483 & v458) >> v456) | ((v457 & v482) << v446);
            }

            else
            {
              *v5 = v464;
            }

            v462 = v481 | ((v482 & 0x7F) << 56);
            if ((v482 & 0x80) != 0)
            {
              v455 = v454 + 10;
              if (v450 < v454 + 10 + v447)
              {
                return 0;
              }

              v484 = *(v459 + v464);
              if (v446)
              {
                if (v455 >= v450)
                {
                  v485 = 0;
                }

                else
                {
                  v485 = *(v459 + v455);
                }

                *v5 = v455;
                v484 = (((v485 & v458) >> v456) | ((((1 << (8 - v446)) - 1) & v484) << v446));
              }

              else
              {
                *v5 = v455;
              }

              v463 = (v484 & 0x80u) != 0;
              if ((v484 & 0x80u) == 0)
              {
                v382 = v462 | (v484 << 63);
              }

              goto LABEL_671;
            }
          }

LABEL_669:
          v463 = 0;
          v455 = v464;
          goto LABEL_670;
        }

        while (1)
        {
          v486 = *(a2 + 24);
          v487 = *(a2 + 24) != 0;
          v488 = *(a2 + 1);
          v489 = v418 + 2;
          if (!*(a2 + 24))
          {
            v489 = v418 + 1;
          }

          if (v488 < v489)
          {
            return 0;
          }

          v490 = 8 - v486;
          v491 = (1 << (8 - v486)) + 255;
          v492 = 0xFFFF << (8 - v486);
          v493 = *a2;
          v494 = v418 + 1;
          v495 = *(*a2 + v418);
          if (*(a2 + 24))
          {
            if (v494 >= v488)
            {
              v496 = 0;
            }

            else
            {
              v496 = *(v493 + v494);
            }

            *v5 = v494;
            v495 = ((v496 & v492) >> v490) | ((v491 & v495) << v486);
          }

          else
          {
            *v5 = v494;
          }

          v497 = v495 & 0x7F;
          if ((v495 & 0x80) == 0)
          {
LABEL_754:
            v382 = v497;
            goto LABEL_764;
          }

          v498 = v418 + 2;
          if (v488 < v418 + 2 + v487)
          {
            return 0;
          }

          v499 = *(v493 + v494);
          if (v486)
          {
            v500 = v498 >= v488 ? 0 : *(v493 + v498);
            *v5 = v498;
            v499 = ((v500 & v492) >> v490) | ((v491 & v499) << v486);
          }

          else
          {
            *v5 = v498;
          }

          v501 = v497 & 0xFFFFFFFFFFFFC07FLL | ((v499 & 0x7F) << 7);
          if ((v499 & 0x80) == 0)
          {
            break;
          }

          v494 = v418 + 3;
          if (v488 < v418 + 3 + v487)
          {
            return 0;
          }

          v502 = *(v493 + v498);
          if (v486)
          {
            if (v494 >= v488)
            {
              v503 = 0;
            }

            else
            {
              v503 = *(v493 + v494);
            }

            *v5 = v494;
            v502 = ((v503 & v492) >> v490) | ((v491 & v502) << v486);
          }

          else
          {
            *v5 = v494;
          }

          v497 = v501 & 0xFFFFFFFFFFE03FFFLL | ((v502 & 0x7F) << 14);
          if ((v502 & 0x80) == 0)
          {
            goto LABEL_754;
          }

          v498 = v418 + 4;
          if (v488 < v418 + 4 + v487)
          {
            return 0;
          }

          v504 = *(v493 + v494);
          if (v486)
          {
            v505 = v498 >= v488 ? 0 : *(v493 + v498);
            *v5 = v498;
            v504 = ((v505 & v492) >> v490) | ((v491 & v504) << v486);
          }

          else
          {
            *v5 = v498;
          }

          v501 = v497 & 0xFFFFFFFFF01FFFFFLL | ((v504 & 0x7F) << 21);
          if ((v504 & 0x80) == 0)
          {
            break;
          }

          v494 = v418 + 5;
          if (v488 < v418 + 5 + v487)
          {
            return 0;
          }

          v506 = *(v493 + v498);
          if (v486)
          {
            if (v494 >= v488)
            {
              v507 = 0;
            }

            else
            {
              v507 = *(v493 + v494);
            }

            *v5 = v494;
            v506 = ((v507 & v492) >> v490) | ((v491 & v506) << v486);
          }

          else
          {
            *v5 = v494;
          }

          v497 = v501 & 0xFFFFFFF80FFFFFFFLL | ((v506 & 0x7F) << 28);
          if ((v506 & 0x80) == 0)
          {
            goto LABEL_754;
          }

          v498 = v418 + 6;
          if (v488 < v418 + 6 + v487)
          {
            return 0;
          }

          v508 = *(v493 + v494);
          if (v486)
          {
            v509 = v498 >= v488 ? 0 : *(v493 + v498);
            *v5 = v498;
            v508 = ((v509 & v492) >> v490) | ((v491 & v508) << v486);
          }

          else
          {
            *v5 = v498;
          }

          v501 = v497 | ((v508 & 0x7F) << 35);
          if ((v508 & 0x80) == 0)
          {
            break;
          }

          v494 = v418 + 7;
          if (v488 < v418 + 7 + v487)
          {
            return 0;
          }

          v510 = *(v493 + v498);
          if (v486)
          {
            if (v494 >= v488)
            {
              v511 = 0;
            }

            else
            {
              v511 = *(v493 + v494);
            }

            *v5 = v494;
            v510 = ((v511 & v492) >> v490) | ((v491 & v510) << v486);
          }

          else
          {
            *v5 = v494;
          }

          v512 = v501 | ((v510 & 0x7F) << 42);
          if ((v510 & 0x80) != 0)
          {
            v513 = v418 + 8;
            if (v488 < v418 + 8 + v487)
            {
              return 0;
            }

            v514 = *(v493 + v494);
            if (v486)
            {
              if (v513 >= v488)
              {
                v515 = 0;
              }

              else
              {
                v515 = *(v493 + v513);
              }

              *v5 = v513;
              v514 = ((v515 & v492) >> v490) | ((v491 & v514) << v486);
            }

            else
            {
              *v5 = v513;
            }

            v516 = v512 | ((v514 & 0x7F) << 49);
            if ((v514 & 0x80) != 0)
            {
              v498 = v418 + 9;
              if (v488 < v418 + 9 + v487)
              {
                return 0;
              }

              v517 = *(v493 + v513);
              if (v486)
              {
                if (v498 >= v488)
                {
                  v518 = 0;
                }

                else
                {
                  v518 = *(v493 + v498);
                }

                *v5 = v498;
                v517 = ((v518 & v492) >> v490) | ((v491 & v517) << v486);
              }

              else
              {
                *v5 = v498;
              }

              v501 = v516 | ((v517 & 0x7F) << 56);
              if ((v517 & 0x80) == 0)
              {
                break;
              }

              v494 = v418 + 10;
              if (v488 < v418 + 10 + v487)
              {
                return 0;
              }

              v519 = *(v493 + v498);
              if (v486)
              {
                if (v494 >= v488)
                {
                  v520 = 0;
                }

                else
                {
                  v520 = *(v493 + v494);
                }

                *v5 = v494;
                v519 = (((v520 & v492) >> v490) | ((v491 & v519) << v486));
              }

              else
              {
                *v5 = v494;
              }

              if ((v519 & 0x80u) == 0)
              {
                v382 = v501 | (v519 << 63);
              }

              if ((v519 & 0x80) != 0)
              {
                return 0;
              }
            }

            else
            {
              v382 = v512 | ((v514 & 0x7F) << 49);
              v494 = v418 + 8;
            }
          }

          else
          {
            v382 = v501 | ((v510 & 0x7F) << 42);
          }

LABEL_764:
          result = v382 != 0;
          if (!v382)
          {
            return result;
          }

          if (v382 > v488 - ((v494 + (v486 >> 3)) & 0x1FFFFFFFFFFFFFFFLL))
          {
LABEL_838:
            if (GEOGetGeoCodecsMaterialDecodeLog::onceToken != -1)
            {
              dispatch_once(&GEOGetGeoCodecsMaterialDecodeLog::onceToken, &__block_literal_global_54655);
            }

            v521 = GEOGetGeoCodecsMaterialDecodeLog::log;
            result = os_log_type_enabled(GEOGetGeoCodecsMaterialDecodeLog::log, OS_LOG_TYPE_ERROR);
            if (result)
            {
              v522 = *(a2 + 1);
              v523 = *(a2 + 24) + 8 * *(a2 + 2);
              *buf = 134218752;
              *&buf[4] = a4;
              *&buf[12] = 2048;
              *&buf[14] = v522;
              *&buf[22] = 2048;
              *&buf[24] = v523;
              LOWORD(v537[0]) = 2048;
              *(v537 + 2) = v382;
              _os_log_impl(&dword_1B2754000, v521, OS_LOG_TYPE_ERROR, "Texture size overflows the buffer for MaterialID = %llu, binary size = %zu, current bit offset = %llu, raw texture size = %llu", buf, 0x2Au);
              return 0;
            }

            return result;
          }

          std::vector<unsigned char,geo::allocator_adapter<unsigned char,geo::codec::zone_mallocator>>::__assign_with_size[abi:ne200100]<unsigned char const*,unsigned char const*>(v417, (v493 + v494), (v493 + v494 + v382), v382);
          v418 = *v5 + v382;
          *v5 = v418;
          v417 += 40;
          result = 1;
          if (v417 == v399)
          {
            return result;
          }
        }

        v382 = v501;
        v494 = v498;
        goto LABEL_764;
      }

      v399 = &v383[40 * v388];
      do
      {
        *(v383 + 4) = 0;
        *v383 = 0uLL;
        *(v383 + 1) = 0uLL;
        v383[33] = 2;
        v383 += 40;
      }

      while (v383 != v399);
    }

    else
    {
      if (v387)
      {
        v399 = *(v12 + 520);
        goto LABEL_616;
      }

      v399 = (v384 + 40 * v382);
      if (v383 != v399)
      {
        v407 = *(v12 + 520);
        do
        {
          v409 = *(v407 - 5);
          v407 -= 40;
          v408 = v409;
          if (v409)
          {
            *(v383 - 4) = v408;
            v410 = geo::codec::zone_mallocator::instance(this);
            geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v410, v408);
          }

          v383 = v407;
        }

        while (v407 != v399);
      }

      v12 = v531;
    }

    *(v12 + 520) = v399;
    goto LABEL_616;
  }

  v36 = 0;
  while (1)
  {
    v37 = *(a2 + 24);
    v38 = *(a2 + 24) != 0;
    v39 = *(a2 + 1);
    v40 = *(a2 + 2);
    v41 = v40 + 2;
    if (!*(a2 + 24))
    {
      v41 = v40 + 1;
    }

    if (v39 < v41)
    {
      return 0;
    }

    v42 = v40 + 1;
    v43 = *a2;
    if (*(a2 + 24))
    {
      if (v42 >= v39)
      {
        v44 = 0;
      }

      else
      {
        v44 = *(v43 + v42);
      }

      this = *(v43 + v40);
      *v5 = v42;
      v45 = ((v44 & (0xFFFF << (8 - v37))) >> (8 - v37)) | ((((1 << (8 - v37)) + 255) & this) << v37);
    }

    else
    {
      LOBYTE(v45) = *(v43 + v40);
      *v5 = v42;
    }

    if (a3 < 0x15)
    {
      v51 = 0;
      goto LABEL_50;
    }

    this = v40 + 2;
    if (v39 < v40 + 2 + v38)
    {
      return 0;
    }

    v46 = 8 - v37;
    v47 = (1 << (8 - v37)) + 255;
    v48 = 0xFFFF << (8 - v37);
    v49 = *(v43 + v42);
    if (v37)
    {
      if (this >= v39)
      {
        v50 = 0;
      }

      else
      {
        v50 = *(v43 + this);
      }

      *v5 = this;
      v52 = ((v50 & v48) >> v46) | ((v47 & v49) << v37);
      v51 = v52 & 0x7F;
      if ((v52 & 0x80) == 0)
      {
        goto LABEL_48;
      }
    }

    else
    {
      *v5 = this;
      v51 = v49 & 0x7F;
      if ((v49 & 0x80) == 0)
      {
        goto LABEL_48;
      }
    }

    v42 = v40 + 3;
    if (v39 < v40 + 3 + v38)
    {
      return 0;
    }

    this = *(v43 + this);
    if (v37)
    {
      if (v42 >= v39)
      {
        v55 = 0;
      }

      else
      {
        v55 = *(v43 + v42);
      }

      *v5 = v42;
      this = ((v55 & v48) >> v46) | ((v47 & this) << v37);
      v51 = v51 & 0xFFFFFFFFFFFFC07FLL | ((this & 0x7F) << 7);
      if ((this & 0x80) == 0)
      {
        goto LABEL_49;
      }
    }

    else
    {
      *v5 = v42;
      v51 = v51 & 0xFFFFFFFFFFFFC07FLL | ((this & 0x7F) << 7);
      if ((this & 0x80) == 0)
      {
        goto LABEL_49;
      }
    }

    this = v40 + 4;
    if (v39 < v40 + 4 + v38)
    {
      return 0;
    }

    v88 = *(v43 + v42);
    if (v37)
    {
      if (this >= v39)
      {
        v89 = 0;
      }

      else
      {
        v89 = *(v43 + this);
      }

      *v5 = this;
      v88 = ((v89 & v48) >> v46) | ((v47 & v88) << v37);
    }

    else
    {
      *v5 = this;
    }

    v51 = v51 & 0xFFFFFFFFFFE03FFFLL | ((v88 & 0x7F) << 14);
    if ((v88 & 0x80) == 0)
    {
      goto LABEL_48;
    }

    v42 = v40 + 5;
    if (v39 < v40 + 5 + v38)
    {
      return 0;
    }

    this = *(v43 + this);
    if (v37)
    {
      if (v42 >= v39)
      {
        v90 = 0;
      }

      else
      {
        v90 = *(v43 + v42);
      }

      *v5 = v42;
      this = ((v90 & v48) >> v46) | ((v47 & this) << v37);
    }

    else
    {
      *v5 = v42;
    }

    v51 = v51 & 0xFFFFFFFFF01FFFFFLL | ((this & 0x7F) << 21);
    if ((this & 0x80) == 0)
    {
      goto LABEL_49;
    }

    this = v40 + 6;
    if (v39 < v40 + 6 + v38)
    {
      return 0;
    }

    v91 = *(v43 + v42);
    if (v37)
    {
      v92 = this >= v39 ? 0 : *(v43 + this);
      *v5 = this;
      v91 = ((v92 & v48) >> v46) | ((v47 & v91) << v37);
    }

    else
    {
      *v5 = this;
    }

    v51 = v51 & 0xFFFFFFF80FFFFFFFLL | ((v91 & 0x7F) << 28);
    if ((v91 & 0x80) == 0)
    {
      goto LABEL_48;
    }

    v42 = v40 + 7;
    if (v39 < v40 + 7 + v38)
    {
      return 0;
    }

    this = *(v43 + this);
    if (v37)
    {
      if (v42 >= v39)
      {
        v93 = 0;
      }

      else
      {
        v93 = *(v43 + v42);
      }

      *v5 = v42;
      this = ((v93 & v48) >> v46) | ((v47 & this) << v37);
    }

    else
    {
      *v5 = v42;
    }

    v51 |= (this & 0x7F) << 35;
    if ((this & 0x80) == 0)
    {
      goto LABEL_49;
    }

    this = v40 + 8;
    if (v39 < v40 + 8 + v38)
    {
      return 0;
    }

    v94 = *(v43 + v42);
    if (v37)
    {
      v95 = this >= v39 ? 0 : *(v43 + this);
      *v5 = this;
      v94 = ((v95 & v48) >> v46) | ((v47 & v94) << v37);
    }

    else
    {
      *v5 = this;
    }

    v51 |= (v94 & 0x7F) << 42;
    if ((v94 & 0x80) == 0)
    {
LABEL_48:
      v42 = this;
LABEL_49:
      __src = v51;
      goto LABEL_50;
    }

    v42 = v40 + 9;
    if (v39 < v40 + 9 + v38)
    {
      return 0;
    }

    this = *(v43 + this);
    if (v37)
    {
      if (v42 >= v39)
      {
        v96 = 0;
      }

      else
      {
        v96 = *(v43 + v42);
      }

      *v5 = v42;
      this = ((v96 & v48) >> v46) | ((v47 & this) << v37);
    }

    else
    {
      *v5 = v42;
    }

    v51 |= (this & 0x7F) << 49;
    if ((this & 0x80) == 0)
    {
      goto LABEL_49;
    }

    this = v40 + 10;
    if (v39 < v40 + 10 + v38)
    {
      return 0;
    }

    v97 = *(v43 + v42);
    if (v37)
    {
      v98 = this >= v39 ? 0 : *(v43 + this);
      *v5 = this;
      v97 = ((v98 & v48) >> v46) | ((v47 & v97) << v37);
    }

    else
    {
      *v5 = this;
    }

    v51 |= (v97 & 0x7F) << 56;
    if ((v97 & 0x80) != 0)
    {
      v42 = v40 + 11;
      if (v39 < v40 + 11 + v38)
      {
        return 0;
      }

      v99 = *(v43 + this);
      if (v37)
      {
        if (v42 >= v39)
        {
          this = 0;
        }

        else
        {
          this = *(v43 + v42);
        }

        *v5 = v42;
        v99 = (((this & v48) >> v46) | ((v47 & v99) << v37));
      }

      else
      {
        *v5 = v42;
      }

      v100 = v51 | (v99 << 63);
      v101 = __src;
      if ((v99 & 0x80u) == 0)
      {
        v101 = v100;
      }

      __src = v101;
      if ((v99 & 0x80) != 0)
      {
        return 0;
      }

      v51 = v101;
    }

    else
    {
      v42 = v40 + 10;
      __src = v51;
    }

    v12 = v531;
LABEL_50:
    if (v45 < 0xAu)
    {
      break;
    }

    *v5 = v42 + v51;
LABEL_28:
    if (++v36 == v35)
    {
      v21 = *v12;
      v22 = *v5;
      goto LABEL_169;
    }
  }

  v53 = v42 + 1;
  if (v39 < v42 + 1 + v38)
  {
    return 0;
  }

  if (!v37)
  {
    LOBYTE(v56) = *(v43 + v42);
    *v5 = v53;
    LOBYTE(v533) = v56;
    v57 = v42 + 2;
    if (v39 < v42 + 2 + v38)
    {
      return 0;
    }

    v58 = *(v43 + v53);
    *v5 = v57;
    v59 = v531;
    v535 = v58;
    if (v58)
    {
      goto LABEL_69;
    }

    goto LABEL_61;
  }

  if (v53 >= v39)
  {
    v54 = 0;
  }

  else
  {
    v54 = *(v43 + v53);
  }

  v60 = (1 << (8 - v37)) + 255;
  v61 = 0xFFFF << (8 - v37);
  v62 = *(v43 + v42);
  *v5 = v53;
  v56 = ((v54 & v61) >> (8 - v37)) | ((v60 & v62) << v37);
  LOBYTE(v533) = ((v54 & v61) >> (8 - v37)) | ((((1 << (8 - v37)) - 1) & v62) << v37);
  v57 = v42 + 2;
  if (v39 < v42 + 2 + v38)
  {
    return 0;
  }

  if (v57 >= v39)
  {
    v63 = 0;
  }

  else
  {
    v63 = *(v43 + v57);
  }

  v59 = v531;
  v64 = *(v43 + v53);
  *v5 = v57;
  v65 = (((v63 & v61) >> (8 - v37)) | ((v60 & v64) << v37));
  v535 = v65;
  if (!v65)
  {
LABEL_61:
    *buf = 6144;
    result = geo::codec::MaterialSheet::decodeProperty(a2, v45, &v533, buf, v59 + 7);
    if (!result)
    {
      return result;
    }

    goto LABEL_94;
  }

LABEL_69:
  v66 = v42 + 3;
  if (v39 < v66 + v38)
  {
    return 0;
  }

  if (!v37)
  {
    v68 = *(v43 + v57);
    *v5 = v66;
    if (v68)
    {
      goto LABEL_77;
    }

    goto LABEL_94;
  }

  if (v66 >= v39)
  {
    v67 = 0;
  }

  else
  {
    v67 = *(v43 + v66);
  }

  v69 = *(v43 + v57);
  *v5 = v66;
  v68 = (((v67 & (0xFFFF << (8 - v37))) >> (8 - v37)) | ((((1 << (8 - v37)) - 1) & v69) << v37));
  if (!(((v67 & (0xFFFF << (8 - v37))) >> (8 - v37)) | ((((1 << (8 - v37)) - 1) & v69) << v37)))
  {
LABEL_94:
    this = std::__hash_table<std::__hash_value_type<unsigned char,BOOL>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,unsigned char &,unsigned char &>(v531 + 58, v56);
    v12 = v531;
    goto LABEL_28;
  }

LABEL_77:
  v70 = 0;
  while (1)
  {
    v71 = *(a2 + 24);
    v72 = v71 != 0;
    v73 = *(a2 + 1);
    v74 = *(a2 + 2);
    v75 = v74 + 2;
    if (!v71)
    {
      v75 = v74 + 1;
    }

    if (v73 < v75)
    {
      return 0;
    }

    v76 = v74 + 1;
    v77 = *a2;
    if (*(a2 + 24))
    {
      if (v76 >= v73)
      {
        v78 = 0;
      }

      else
      {
        v78 = *(v77 + v76);
      }

      v82 = *(v77 + v74);
      *v5 = v76;
      v83 = v74 + 2;
      if (v73 < v83 + v72)
      {
        return 0;
      }

      if (v83 >= v73)
      {
        v84 = 0;
      }

      else
      {
        v84 = *(v77 + v83);
      }

      v85 = (1 << (8 - v71)) + 255;
      v86 = 0xFFFF << (8 - v71);
      v79 = ((v78 & v86) >> (8 - v71)) | ((v85 & v82) << v71);
      v87 = *(v77 + v76);
      *v5 = v83;
      v81 = ((v84 & v86) >> (8 - v71)) | ((v85 & v87) << v71);
    }

    else
    {
      LOBYTE(v79) = *(v77 + v74);
      *v5 = v76;
      v80 = v74 + 2;
      if (v73 < v80 + v72)
      {
        return 0;
      }

      LOBYTE(v81) = *(v77 + v76);
      *v5 = v80;
    }

    buf[0] = v79;
    buf[1] = v81;
    if (!geo::codec::MaterialSheet::decodeProperty(a2, v45, &v533, buf, v531 + 7))
    {
      return 0;
    }

    if (v68 <= ++v70)
    {
      goto LABEL_94;
    }
  }
}

void sub_1B334A890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, char a21)
{
  if (a2)
  {
    __clang_call_terminate(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<unsigned char,BOOL>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,BOOL>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,unsigned char &,unsigned char &>(void *result, unsigned __int8 a2)
{
  v2 = result[1];
  if (!v2)
  {
    goto LABEL_22;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % result[1];
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v5 = *(*result + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_22:
    operator new();
  }

  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      v7 = v6[1];
      if (v7 == a2)
      {
        if (*(v6 + 16) == a2)
        {
          return result;
        }
      }

      else if ((v7 & (v2 - 1)) != v4)
      {
        goto LABEL_22;
      }

      v6 = *v6;
      if (!v6)
      {
        goto LABEL_22;
      }
    }
  }

  while (1)
  {
    v8 = v6[1];
    if (v8 == a2)
    {
      break;
    }

    if (v8 >= v2)
    {
      v8 %= v2;
    }

    if (v8 != v4)
    {
      goto LABEL_22;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_22;
    }
  }

  if (*(v6 + 16) != a2)
  {
    goto LABEL_17;
  }

  return result;
}

void geo::codec::MaterialSheet::Material::~Material(geo::codec::MaterialSheet::Material *this)
{
  v2 = *(this + 53);
  if (v2)
  {
    do
    {
      v3 = *v2;
      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }

  v4 = *(this + 51);
  *(this + 51) = 0;
  if (v4)
  {
    operator delete(v4);
  }

  v5 = *(this + 47);
  if (v5)
  {
    do
    {
      v21 = *v5;
      v22 = v5[3];
      if (v22)
      {
        v5[4] = v22;
        operator delete(v22);
      }

      operator delete(v5);
      v5 = v21;
    }

    while (v21);
  }

  v6 = *(this + 45);
  *(this + 45) = 0;
  if (v6)
  {
    operator delete(v6);
  }

  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>>>::~__hash_table(this + 320);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>>>::~__hash_table(this + 280);
  v7 = *(this + 32);
  if (v7)
  {
    do
    {
      v23 = *v7;
      v24 = v7[3];
      if (v24)
      {
        v7[4] = v24;
        operator delete(v24);
      }

      operator delete(v7);
      v7 = v23;
    }

    while (v23);
  }

  v8 = *(this + 30);
  *(this + 30) = 0;
  if (v8)
  {
    operator delete(v8);
  }

  v9 = *(this + 27);
  if (v9)
  {
    do
    {
      v25 = *v9;
      v26 = v9[3];
      if (v26)
      {
        v9[4] = v26;
        operator delete(v26);
      }

      operator delete(v9);
      v9 = v25;
    }

    while (v25);
  }

  v10 = *(this + 25);
  *(this + 25) = 0;
  if (v10)
  {
    operator delete(v10);
  }

  v11 = *(this + 22);
  if (v11)
  {
    do
    {
      v27 = *v11;
      v28 = v11[3];
      if (v28)
      {
        v11[4] = v28;
        operator delete(v28);
      }

      operator delete(v11);
      v11 = v27;
    }

    while (v27);
  }

  v12 = *(this + 20);
  *(this + 20) = 0;
  if (v12)
  {
    operator delete(v12);
  }

  v13 = *(this + 17);
  if (v13)
  {
    do
    {
      v29 = *v13;
      v30 = v13[3];
      if (v30)
      {
        v13[4] = v30;
        operator delete(v30);
      }

      operator delete(v13);
      v13 = v29;
    }

    while (v29);
  }

  v14 = *(this + 15);
  *(this + 15) = 0;
  if (v14)
  {
    operator delete(v14);
  }

  v15 = *(this + 12);
  if (v15)
  {
    do
    {
      v31 = *v15;
      v32 = v15[3];
      if (v32)
      {
        v15[4] = v32;
        operator delete(v32);
      }

      operator delete(v15);
      v15 = v31;
    }

    while (v31);
  }

  v16 = *(this + 10);
  *(this + 10) = 0;
  if (v16)
  {
    operator delete(v16);
  }

  v17 = *(this + 7);
  if (v17)
  {
    do
    {
      v33 = *v17;
      v34 = v17[3];
      if (v34)
      {
        v17[4] = v34;
        operator delete(v34);
      }

      operator delete(v17);
      v17 = v33;
    }

    while (v33);
  }

  v18 = *(this + 5);
  *(this + 5) = 0;
  if (v18)
  {
    operator delete(v18);
  }

  v19 = *(this + 2);
  if (v19)
  {
    do
    {
      v35 = *v19;
      v36 = v19[3];
      if (v36)
      {
        v19[4] = v36;
        operator delete(v36);
      }

      operator delete(v19);
      v19 = v35;
    }

    while (v35);
  }

  v20 = *this;
  *this = 0;
  if (v20)
  {
    operator delete(v20);
  }
}

void *std::vector<unsigned char,geo::allocator_adapter<unsigned char,geo::codec::zone_mallocator>>::__assign_with_size[abi:ne200100]<unsigned char const*,unsigned char const*>(void *result, char *__src, char *a3, unint64_t a4)
{
  v6 = result;
  v7 = result[2];
  v8 = *result;
  if (v7 - *result < a4)
  {
    if (v8)
    {
      v9 = a4;
      result[1] = v8;
      v10 = geo::codec::zone_mallocator::instance(result);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v10, v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      a4 = v9;
    }

    if ((a4 & 0x8000000000000000) != 0)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v11 = 2 * v7;
    if (2 * v7 <= a4)
    {
      v11 = a4;
    }

    if (v7 >= 0x3FFFFFFFFFFFFFFFLL)
    {
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v12 = v11;
    }

    v13 = geo::codec::zone_mallocator::instance(result);
    result = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned char>(v13, v12);
    *v6 = result;
    v6[1] = result;
    v6[2] = result + v12;
    if (__src == a3)
    {
      goto LABEL_35;
    }

    v14 = a3 - __src;
    if ((a3 - __src) < 0x20)
    {
      v16 = __src;
    }

    else if ((result - __src) < 0x20)
    {
      v16 = __src;
    }

    else
    {
      v15 = v14 & 0xFFFFFFFFFFFFFFE0;
      v16 = &__src[v14 & 0xFFFFFFFFFFFFFFE0];
      v17 = result + 2;
      v18 = (__src + 16);
      v19 = v14 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 32;
      }

      while (v19);
      result = (result + v15);
      if (v14 == v15)
      {
        goto LABEL_35;
      }
    }

    do
    {
      v34 = *v16++;
      *result = v34;
      result = (result + 1);
    }

    while (v16 != a3);
LABEL_35:
    v6[1] = result;
    return result;
  }

  v21 = result[1];
  v22 = v21 - v8;
  if (v21 - v8 < a4)
  {
    v23 = &__src[v22];
    if (v21 != v8)
    {
      result = memmove(*result, __src, v22);
    }

    v24 = v6[1];
    v26 = v24;
    if (v23 == a3)
    {
      goto LABEL_31;
    }

    v27 = &a3[v8] - &__src[v21];
    if (v27 >= 0x20)
    {
      v26 = v6[1];
      if (v8 + v24 - &__src[v21] >= 0x20)
      {
        v28 = v27 & 0xFFFFFFFFFFFFFFE0;
        v23 += v27 & 0xFFFFFFFFFFFFFFE0;
        v29 = (v24 + 16);
        v30 = &__src[v21 - v8 + 16];
        v31 = v27 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v32 = *v30;
          *(v29 - 1) = *(v30 - 1);
          *v29 = v32;
          v29 += 2;
          v30 += 32;
          v31 -= 32;
        }

        while (v31);
        v26 = (v24 + v28);
        if (v27 == v28)
        {
          goto LABEL_31;
        }
      }
    }

    else
    {
      v26 = v6[1];
    }

    do
    {
      v33 = *v23++;
      *v26++ = v33;
    }

    while (v23 != a3);
LABEL_31:
    v6[1] = v26;
    return result;
  }

  v25 = a3 - __src;
  if (v25)
  {
    result = memmove(*result, __src, v25);
  }

  v6[1] = v8 + v25;
  return result;
}

BOOL geo::codec::MaterialSheet::decodeExternalMaterial(geo::codec::MaterialSheet *this, geo::ibitstream *a2)
{
  __p = 0;
  v33 = 0;
  v34 = 0;
  if (geo::ibitstream::readBytes(a2, &__p))
  {
    if (v33 != __p)
    {
      if (((v33 - __p) & 0x8000000000000000) == 0)
      {
        operator new();
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    if (__p)
    {
      operator delete(__p);
    }

    if (MEMORY[0] != 68 || MEMORY[1] != 118 || MEMORY[2] != 77 || MEMORY[3] != 116)
    {
      goto LABEL_37;
    }

    v4 = *(a2 + 1);
    v5 = *(a2 + 2);
    v6 = v5 + 4;
    v7 = *(a2 + 24);
    v8 = v5 + 5;
    if (!v7)
    {
      v8 = v5 + 4;
    }

    if (v4 < v8)
    {
      goto LABEL_37;
    }

    v9 = *a2;
    if (*(a2 + 24))
    {
      v10 = 8 - v7;
      v11 = v5 + 1;
      if (v5 + 1 >= v4)
      {
        v12 = 0;
      }

      else
      {
        v12 = *(v9 + v11);
      }

      v15 = (1 << (8 - v7)) + 255;
      v16 = *(v9 + v5);
      v17 = 0xFFFF << v10;
      *(a2 + 2) = v11;
      v18 = *(v9 + v11);
      v19 = v5 + 2;
      if (v5 + 2 >= v4)
      {
        v20 = 0;
      }

      else
      {
        v20 = *(v9 + v19);
      }

      v21 = v15 & v16;
      v22 = v12 & v17;
      v23 = v15 & v18;
      v24 = v20 & v17;
      *(a2 + 2) = v19;
      v25 = *(v9 + v19);
      v26 = v5 + 3;
      if (v5 + 3 >= v4)
      {
        v27 = 0;
      }

      else
      {
        v27 = *(v9 + v26);
      }

      v28 = v22 >> v10;
      *(a2 + 2) = v26;
      v29 = *(v9 + v26);
      if (v6 >= v4)
      {
        v30 = 0;
      }

      else
      {
        v30 = *(v9 + v6);
      }

      *(a2 + 2) = v6;
      v14 = ((((v27 & v17) >> v10) | ((v15 & v25) << v7)) << 16) | ((((v30 & v17) >> v10) | ((v15 & v29) << v7)) << 24) | (((v24 >> v10) | (v23 << v7)) << 8) | v28 | (v21 << v7);
    }

    else
    {
      v14 = *(v9 + v5);
      *(a2 + 2) = v6;
    }

    v13 = 0;
    if (v4 < v8 || v14 < 0x13)
    {
      goto LABEL_38;
    }

    geo::ibitstream::readUInt64(&__p, a2);
    if (__p)
    {
      v13 = geo::codec::MaterialSheet::decodeMaterial(this, a2, v14, v33);
    }

    else
    {
LABEL_37:
      v13 = 0;
    }

LABEL_38:
    operator delete(0);
    return v13;
  }

  if (__p)
  {
    operator delete(__p);
  }

  return 0;
}

BOOL geo::ibitstream::readBytes(uint64_t *a1, void *a2)
{
  v4 = a2[1];
  v5 = v4 - *a2;
  if (v5 > 3)
  {
    if (v5 != 4)
    {
      a2[1] = *a2 + 4;
    }
  }

  else
  {
    v6 = a2[2];
    if (v6 - v4 < 4 - v5)
    {
      operator new();
    }

    v7 = *a2 + 4;
    bzero(v4, 4 - v5);
    a2[1] = v7;
  }

  v8 = a1[1];
  v9 = a1[2];
  if (*(a1 + 24))
  {
    v10 = v9 + 1;
  }

  else
  {
    v10 = a1[2];
  }

  v11 = v10 + 4;
  if (v8 >= v11)
  {
    v12 = *a2;
    v13 = *a1;
    if (*(a1 + 24))
    {
      v14 = *(v13 + v9);
      v15 = v9 + 1;
      if (v9 + 1 >= v8)
      {
        v16 = 0;
      }

      else
      {
        v16 = *(v13 + v15);
      }

      v17 = *(a1 + 24);
      a1[2] = v15;
      *v12 = ((((1 << (8 - v17)) - 1) & v14) << v17) | (((0xFFFF << (8 - v17)) & v16) >> (8 - v17));
      v18 = a1[2];
      v19 = *(*a1 + v18);
      v20 = v18 + 1;
      if (v20 >= a1[1])
      {
        v21 = 0;
      }

      else
      {
        v21 = *(*a1 + v20);
      }

      v22 = *(a1 + 24);
      a1[2] = v20;
      v12[1] = ((((1 << (8 - v22)) - 1) & v19) << v22) | (((0xFFFF << (8 - v22)) & v21) >> (8 - v22));
      v23 = a1[2];
      v24 = *(*a1 + v23);
      v25 = v23 + 1;
      if (v23 + 1 >= a1[1])
      {
        v26 = 0;
      }

      else
      {
        v26 = *(*a1 + v25);
      }

      v27 = *(a1 + 24);
      a1[2] = v25;
      v12[2] = ((((1 << (8 - v27)) - 1) & v24) << v27) | (((0xFFFF << (8 - v27)) & v26) >> (8 - v27));
      v28 = a1[2];
      v29 = *(*a1 + v28);
      v30 = v28 + 1;
      if (v30 >= a1[1])
      {
        v31 = 0;
      }

      else
      {
        v31 = *(*a1 + v30);
      }

      v32 = ((((1 << (8 - *(a1 + 24))) - 1) & v29) << *(a1 + 24)) | (((0xFFFF << (8 - *(a1 + 24))) & v31) >> (8 - *(a1 + 24)));
      a1[2] = v30;
      v12[3] = v32;
    }

    else
    {
      *v12 = *(v13 + v9);
      a1[2] += 4;
    }
  }

  return v8 >= v11;
}

uint64_t geo::ibitstream::readUInt64(uint64_t this, uint64_t *a2)
{
  v2 = a2[1];
  v3 = a2[2];
  v4 = v3 + 8;
  v5 = *(a2 + 24);
  v6 = v3 + 9;
  if (!v5)
  {
    v6 = v3 + 8;
  }

  if (v2 >= v6)
  {
    v7 = *a2;
    if (*(a2 + 24))
    {
      v8 = 8 - v5;
      v9 = v3 + 1;
      if (v3 + 1 >= v2)
      {
        v10 = 0;
      }

      else
      {
        v10 = *(v7 + v9);
      }

      v19 = *(v7 + v3);
      a2[2] = v9;
      v20 = v3 + 2;
      if (v3 + 2 >= v2)
      {
        v21 = 0;
      }

      else
      {
        v21 = *(v7 + v20);
      }

      v22 = *(v7 + v9);
      a2[2] = v20;
      v23 = v3 + 3;
      if (v3 + 3 >= v2)
      {
        v24 = 0;
      }

      else
      {
        v24 = *(v7 + v23);
      }

      v25 = (1 << v8) + 255;
      v26 = *(v7 + v20);
      v27 = 0xFFFF << v8;
      a2[2] = v23;
      v28 = *(v7 + v23);
      v29 = v3 + 4;
      if (v3 + 4 >= v2)
      {
        v30 = 0;
      }

      else
      {
        v30 = *(v7 + v29);
      }

      v31 = v25 & v19;
      v32 = v10 & v27;
      v33 = v25 & v22;
      v34 = v21 & v27;
      v35 = v25 & v26;
      v36 = v24 & v27;
      v37 = v25 & v28;
      v38 = v30 & v27;
      a2[2] = v29;
      v39 = *(v7 + v29);
      v40 = v3 + 5;
      if (v3 + 5 >= v2)
      {
        v41 = 0;
      }

      else
      {
        v41 = *(v7 + v40);
      }

      LODWORD(v12) = v31 << v5;
      LODWORD(v13) = v32 >> v8;
      LODWORD(v14) = v33 << v5;
      LODWORD(v15) = v34 >> v8;
      v42 = v35 << v5;
      v43 = v36 >> v8;
      v44 = v37 << v5;
      v45 = v38 >> v8;
      v46 = (v25 & v39) << v5;
      a2[2] = v40;
      v47 = v3 + 6;
      v48 = (v41 & v27) >> v8;
      v49 = *(v7 + v40);
      if (v3 + 6 >= v2)
      {
        v50 = 0;
      }

      else
      {
        v50 = *(v7 + v47);
      }

      LOBYTE(v11) = v13 | v12;
      LOBYTE(v12) = v15 | v14;
      LOBYTE(v13) = v43 | v42;
      LOBYTE(v14) = v45 | v44;
      LOBYTE(v15) = v48 | v46;
      LODWORD(v16) = ((v50 & v27) >> v8) | ((v25 & v49) << v5);
      a2[2] = v47;
      v51 = v3 + 7;
      if (v3 + 7 >= v2)
      {
        v52 = 0;
      }

      else
      {
        v52 = *(v7 + v51);
      }

      LODWORD(v17) = ((v52 & v27) >> v8) | ((((1 << v8) - 1) & *(v7 + v47)) << v5);
      a2[2] = v51;
      v53 = *(v7 + v51);
      if (v4 >= v2)
      {
        v54 = 0;
      }

      else
      {
        v54 = *(v7 + v4);
      }

      v18 = ((v54 & v27) >> v8) | ((v25 & v53) << v5);
    }

    else
    {
      v11 = *(v7 + v3);
      v12 = v11 >> 8;
      v13 = v11 >> 16;
      v14 = v11 >> 24;
      v15 = HIDWORD(v11);
      v16 = v11 >> 40;
      v17 = HIWORD(v11);
      v18 = HIBYTE(v11);
    }

    a2[2] = v4;
    *this = 1;
    *(this + 8) = (v17 << 48) | (v18 << 56) | (v16 << 40) | (v15 << 32) | (v14 << 24) | (v13 << 16) | (v12 << 8) | v11;
  }

  else
  {
    *this = 0;
  }

  return this;
}

uint64_t geo::codec::zone_mallocator::instance(geo::codec::zone_mallocator *this)
{
  v2 = *MEMORY[0x1E69E9840];
  {
    operator new();
  }

  return geo::codec::zone_mallocator::instance(void)::zone;
}

void sub_1B334BAA8(_Unwind_Exception *a1)
{
  if (*v1)
  {
    malloc_destroy_zone(*v1);
    *v1 = 0;
  }

  MEMORY[0x1B8C62190](v1, 0x1070C4011BAD943);
  _Unwind_Resume(a1);
}

void geo::codec::resetAllocator(geo::codec *this)
{
  v1 = geo::codec::zone_mallocator::instance(this);

  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::reset(v1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<int>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B334BBB8(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::__throw_bad_function_call[abi:ne200100]()
{
  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E69E5558] + 16;
  __cxa_throw(exception, MEMORY[0x1E69E53C0], MEMORY[0x1E69E52E8]);
}

uint64_t geo::codec::transitLinkFirstPoint(uint64_t a1)
{
  if (!*(a1 + 20))
  {
    return 0;
  }

  v2 = *(a1 + 8);
  if (!v2)
  {
    return 0;
  }

  v3 = 0;
  v4 = 1;
LABEL_4:
  v5 = std::__shared_weak_count::lock(v2);
  if (!v5)
  {
    goto LABEL_12;
  }

  if (*a1 && (v6 = *(*a1 + 1408)) != 0)
  {
    v7 = (*(v6 + 32) + 16 * *(a1 + 16) + v3);
    v8 = *(v6 + 8) + 8 * *v7;
    v9 = v7[1] == 0;
  }

  else
  {
    v8 = 0;
    v9 = 1;
  }

  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    v10 = v5;
    (v5->__on_zero_shared)();
    std::__shared_weak_count::__release_weak(v10);
  }

  if (v9)
  {
LABEL_12:
    while (v4 < *(a1 + 20))
    {
      v2 = *(a1 + 8);
      ++v4;
      v3 += 16;
      if (v2)
      {
        goto LABEL_4;
      }
    }

    return 0;
  }

  return v8;
}

std::__shared_weak_count *geo::codec::transitLinkPoints(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(a1 + 20))
  {
    result = *(a1 + 8);
    if (result)
    {
      result = std::__shared_weak_count::lock(result);
      if (result)
      {
        if (*a1)
        {
          v7 = *(*a1 + 1408);
          if (v7)
          {
            v8 = (*(v7 + 32) + 16 * *(a1 + 16) + 16 * a2);
            v10 = *v8;
            v9 = v8[1];
            v11 = *(v7 + 8) + 8 * v10;
          }

          else
          {
            v9 = 0;
            v11 = 0;
          }

          *a3 = v9;
        }

        else
        {
          v11 = 0;
        }

        if (!atomic_fetch_add(&result->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v12 = result;
          (result->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v12);
        }

        return v11;
      }
    }
  }

  else
  {
    result = 0;
    *a3 = 0;
  }

  return result;
}

void geo::codec::transitNodeFeatureGetSystem(void *a1, unint64_t a2, void *a3)
{
  if (a3)
  {
    *a3 = 0;
  }

  if (a1)
  {
    if (a1[29] > a2)
    {
      v4 = a1[1];
      if (v4)
      {
        v7 = std::__shared_weak_count::lock(v4);
        if (v7)
        {
          v8 = *a1;
          if (*a1)
          {
            if (a3)
            {
              v9 = *(v8[181] + 8 * a1[28] + 8 * a2);
              v10 = v8[166];
              v11 = v8[165];
              if (v9 < 0x8E38E38E38E38E39 * ((v10 - v11) >> 3))
              {
                *a3 = v11 + 72 * v9;
              }
            }
          }

          if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            v12 = v7;
            (v7->__on_zero_shared)();

            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }
    }
  }
}

uint64_t geo::codec::tileGetNativeLabel(uint64_t result, uint64_t a2, void *a3, void *a4)
{
  if (result)
  {
    v4 = (*(result + 1056) + 24 * a2);
    if (a3)
    {
      *a3 = *v4;
    }

    if (a4)
    {
      v5 = v4[1];
LABEL_10:
      *a4 = v5;
    }
  }

  else
  {
    if (a3)
    {
      *a3 = 0;
    }

    if (a4)
    {
      v5 = 0;
      goto LABEL_10;
    }
  }

  return result;
}

uint64_t geo::codec::transitSystemInfoGetNativeLabel(uint64_t result, uint64_t a2, void *a3, void *a4)
{
  if (a2)
  {
    if (*(a2 + 40))
    {
      v4 = result == 0;
    }

    else
    {
      v4 = 1;
    }

    if (v4)
    {
      if (a3)
      {
        *a3 = 0;
      }

      if (a4)
      {
        v5 = 0;
LABEL_15:
        *a4 = v5;
      }
    }

    else
    {
      v6 = (*(result + 1056) + 24 * *(a2 + 48));
      if (a3)
      {
        *a3 = *v6;
      }

      if (a4)
      {
        v5 = v6[1];
        goto LABEL_15;
      }
    }
  }

  return result;
}

void geo::codec::transitLineGetSubtitleNativeLabel(unsigned int *a1, void *a2)
{
  v4 = a1[22];
  v5 = *(a1 + 1);
  if (v4 == -1)
  {
    if (v5)
    {
      v5 = std::__shared_weak_count::lock(v5);
      if (v5)
      {
        if (*(a1 + 72) && *a1)
        {
          if (!a2)
          {
            goto LABEL_17;
          }

          v6 = *(*a1 + 1072);
          v7 = 32 * a1[15];
LABEL_13:
          *a2 = *(v6 + v7);
LABEL_17:
          if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            v8 = v5;
            (v5->__on_zero_shared)();

            std::__shared_weak_count::__release_weak(v8);
          }

          return;
        }
      }
    }
  }

  else if (v5)
  {
    v5 = std::__shared_weak_count::lock(v5);
    if (v5)
    {
      if (*a1)
      {
        if (!a2)
        {
          goto LABEL_17;
        }

        v6 = *(*a1 + 1056);
        v7 = 24 * a1[22];
        goto LABEL_13;
      }
    }
  }

  if (a2)
  {
    *a2 = 0;
  }

  if (v5)
  {
    goto LABEL_17;
  }
}

void std::__destroy_at[abi:ne200100]<GeoCodecsVertexAttributesData,0>(geo::codec::zone_mallocator *a1)
{
  v2 = *(a1 + 5);
  if (v2)
  {
    *(a1 + 6) = v2;
    v3 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned char>(v3, v2);
  }

  v4 = *(a1 + 1);
  if (v4)
  {
    *(a1 + 2) = v4;
    v5 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<int>(v5, v4);
  }
}

void std::vector<gm::Matrix<int,3,1>,geo::allocator_adapter<gm::Matrix<int,3,1>,geo::codec::zone_mallocator>>::__append(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v2 = *(a1 + 1);
  v3 = *(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 2) >= a2)
  {
    *(a1 + 1) = &v2[12 * (12 * a2 / 0xC)];
  }

  else
  {
    v4 = *a1;
    v5 = &v2[-*a1];
    v6 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 2);
    v7 = v6 + a2;
    if (v6 + a2 > 0x1555555555555555)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v8 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 2);
    if (2 * v8 > v7)
    {
      v7 = 2 * v8;
    }

    if (v8 >= 0xAAAAAAAAAAAAAAALL)
    {
      v9 = 0x1555555555555555;
    }

    else
    {
      v9 = v7;
    }

    if (v9)
    {
      v10 = a2;
      v11 = a1;
      v12 = geo::codec::zone_mallocator::instance(a1);
      v13 = pthread_rwlock_rdlock((v12 + 32));
      if (v13)
      {
        geo::read_write_lock::logFailure(v13, "read lock", v14);
      }

      v15 = malloc_type_zone_malloc(*v12, 12 * v9, 0x10000403E1C8BA9uLL);
      atomic_fetch_add((v12 + 24), 1u);
      v16 = pthread_rwlock_unlock((v12 + 32));
      if (v16)
      {
        geo::read_write_lock::logFailure(v16, "unlock", v17);
      }

      a1 = v11;
      v4 = *v11;
      v2 = *(v11 + 1);
      v5 = &v2[-*v11];
      a2 = v10;
    }

    else
    {
      v15 = 0;
    }

    v18 = &v15[12 * v6];
    v19 = &v18[12 * (12 * a2 / 0xC)];
    v20 = &v18[-v5];
    if (v4 != v2)
    {
      v21 = v20;
      do
      {
        v22 = *v4;
        *(v21 + 2) = *(v4 + 2);
        *v21 = v22;
        v21 += 12;
        v4 += 12;
      }

      while (v4 != v2);
      v4 = *a1;
    }

    *a1 = v20;
    *(a1 + 1) = v19;
    *(a1 + 2) = &v15[12 * v9];
    if (v4)
    {
      v23 = geo::codec::zone_mallocator::instance(a1);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<int,3,1>>(v23, v4);
    }
  }
}

void sub_1B334C2E4(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::vector<int,geo::allocator_adapter<int,geo::codec::zone_mallocator>>::__append(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (a2 <= (v3 - v4) >> 2)
  {
    if (a2)
    {
      v19 = 4 * a2;
      bzero(*(a1 + 8), 4 * a2);
      v4 += v19;
    }

    *(a1 + 8) = v4;
  }

  else
  {
    v5 = *a1;
    v6 = v4 - *a1;
    v7 = v6 >> 2;
    v8 = (v6 >> 2) + a2;
    if (v8 >> 62)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v9 = v3 - v5;
    if (v9 >> 1 > v8)
    {
      v8 = v9 >> 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      v11 = a2;
      v12 = geo::codec::zone_mallocator::instance(a1);
      v13 = pthread_rwlock_rdlock((v12 + 32));
      if (v13)
      {
        geo::read_write_lock::logFailure(v13, "read lock", v14);
      }

      v15 = malloc_type_zone_malloc(*v12, 4 * v10, 0x100004052888210uLL);
      atomic_fetch_add((v12 + 24), 1u);
      v16 = pthread_rwlock_unlock((v12 + 32));
      if (v16)
      {
        geo::read_write_lock::logFailure(v16, "unlock", v17);
      }

      v5 = *a1;
      v6 = *(a1 + 8) - *a1;
      v18 = v6 >> 2;
      a2 = v11;
    }

    else
    {
      v15 = 0;
      v18 = v6 >> 2;
    }

    v20 = &v15[4 * v7];
    v21 = 4 * a2;
    v22 = &v15[4 * v10];
    bzero(v20, 4 * a2);
    v23 = &v20[v21];
    v24 = &v20[-4 * v18];
    v25 = memcpy(v24, v5, v6);
    v26 = *a1;
    *a1 = v24;
    *(a1 + 8) = v23;
    *(a1 + 16) = v22;
    if (v26)
    {
      v27 = geo::codec::zone_mallocator::instance(v25);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<int>(v27, v26);
    }
  }
}

void sub_1B334C48C(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<GeoCodecsVertexAttributesData>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B334C544(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<int,3,1>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B334C5F4(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

uint64_t geo::codec::transitLinkGetLineCount(uint64_t result)
{
  if (result)
  {
    return *(result + 32);
  }

  return result;
}

std::__shared_weak_count *geo::codec::transitLinkGetLineDirection(std::__shared_weak_count *result, unint64_t a2)
{
  if (result)
  {
    v2 = &result->__vftable;
    result = result->__shared_owners_;
    if (result)
    {
      result = std::__shared_weak_count::lock(result);
      if (result)
      {
        v4 = result;
        result = 0;
        if (v2[4] > a2 && *v2)
        {
          v5 = *(*v2 + 1664);
          if (v5)
          {
            result = *(v5 + v2[3] + a2);
          }

          else
          {
            result = 0;
          }
        }

        if (!atomic_fetch_add(v4 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          v6 = result;
          v7 = v4;
          (*(*v4 + 16))(v4);
          std::__shared_weak_count::__release_weak(v7);
          return v6;
        }
      }
    }
  }

  return result;
}

std::__shared_weak_count *geo::codec::transitLinkGetFromNodeID(std::__shared_weak_count *result, uint64_t a2)
{
  if (result)
  {
    v2 = &result->__vftable;
    result = result->__shared_owners_;
    if (result)
    {
      result = std::__shared_weak_count::lock(result);
      if (result)
      {
        if (*v2 && v2[14] > (2 * a2))
        {
          v4 = **(*(*v2 + 1688) + 8 * v2[13] + 16 * a2);
        }

        else
        {
          v4 = 0;
        }

        if (!atomic_fetch_add(&result->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v5 = result;
          (result->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v5);
        }

        return v4;
      }
    }
  }

  return result;
}

std::__shared_weak_count *geo::codec::transitLinkGetToNodeID(std::__shared_weak_count *result, uint64_t a2)
{
  if (result)
  {
    v2 = &result->__vftable;
    result = result->__shared_owners_;
    if (result)
    {
      result = std::__shared_weak_count::lock(result);
      if (result)
      {
        if (*v2 && (v4 = (2 * a2) | 1, v2[14] > v4))
        {
          v5 = **(*(*v2 + 1688) + 8 * v2[13] + 8 * v4);
        }

        else
        {
          v5 = 0;
        }

        if (!atomic_fetch_add(&result->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v6 = result;
          (result->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v6);
        }

        return v5;
      }
    }
  }

  return result;
}

uint64_t geo::codec::transitLinkGetShouldDrawFromEndPoint(void *a1, uint64_t a2)
{
  if (a1 && (v3 = a1[1]) != 0 && (v5 = std::__shared_weak_count::lock(v3)) != 0)
  {
    if (*a1 && 2 * a2 < (2 * a1[4]))
    {
      v6 = *(*(*a1 + 1776) + 2 * a1[3] + 2 * a2);
    }

    else
    {
      v6 = 0;
    }

    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      v8 = v5;
      (v5->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  else
  {
    v6 = 0;
  }

  return v6 & 1;
}

uint64_t geo::codec::transitLinkGetShouldDrawToEndPoint(void *a1, uint64_t a2)
{
  if (a1 && (v3 = a1[1]) != 0 && (v5 = std::__shared_weak_count::lock(v3)) != 0)
  {
    if (*a1 && (v6 = (2 * a2) | 1, v6 < 2 * a1[4]))
    {
      v7 = *(*(*a1 + 1776) + 2 * a1[3] + v6);
    }

    else
    {
      v7 = 0;
    }

    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      v9 = v5;
      (v5->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  else
  {
    v7 = 0;
  }

  return v7 & 1;
}

uint64_t geo::codec::featureStyleAttributesCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    return 0;
  }

  if (!a1)
  {
    return 0xFFFFFFFFLL;
  }

  if (!a2)
  {
    return 1;
  }

  v3 = *(a1 + 33);
  v4 = *(a2 + 33);
  v5 = v3 >= v4;
  if (v3 != v4)
  {
    goto LABEL_14;
  }

  if (*(a1 + 33))
  {
    v6 = a1;
    v7 = a2;
    v8 = memcmp(*a1, *a2, 8 * v3);
    a2 = v7;
    v9 = v8;
    a1 = v6;
    if (v9)
    {
      return v9;
    }
  }

  v9 = *(a1 + 32);
  v10 = *(a2 + 32);
  v5 = v9 >= v10;
  if (v9 != v10)
  {
LABEL_14:
    if (v5)
    {
      return 1;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  if (!*(a1 + 32))
  {
    return v9;
  }

  v11 = *(a1 + 24);
  v12 = *(a2 + 24);

  return memcmp(v11, v12, 12 * v9);
}

uint64_t geo::codec::vectorTransitLineAlongLink(void *a1, uint64_t a2)
{
  v3 = a1[1];
  if (!v3)
  {
    return 0;
  }

  v5 = std::__shared_weak_count::lock(v3);
  if (!v5)
  {
    return 0;
  }

  v6 = *a1;
  if (!*a1 || ((v7 = v6[161], v8 = v6[174], v7) ? (v9 = v8 == 0) : (v9 = 1), v9 || (v10 = a1[3] + a2, v10 >= v6[175])))
  {
    v14 = 0;
  }

  else
  {
    v11 = *(v8 + 8 * v10);
    v12 = 0x4EC4EC4EC4EC4EC5 * ((v6[162] - v7) >> 3);
    v13 = v7 + 104 * v11;
    if (v11 >= v12)
    {
      v14 = 0;
    }

    else
    {
      v14 = v13;
    }
  }

  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    v15 = v5;
    (v5->__on_zero_shared)();
    std::__shared_weak_count::__release_weak(v15);
  }

  return v14;
}

std::__shared_weak_count *geo::codec::polygonFeatureGetStrokeSpecifications(void *a1, int64_t *a2)
{
  result = a1[1];
  if (result)
  {
    result = std::__shared_weak_count::lock(result);
    if (result)
    {
      v5 = result;
      v6 = *a1;
      if (*a1 && (v7 = v6[158], v8 = v6[157], __key = (a1 - v6[12]) >> 7, v9 = bsearch(&__key, v8, v7, 0x10uLL, geo::codec::compareStrokeSpecifications), a2))
      {
        v10 = v9;
        if (v9)
        {
          do
          {
            result = v10;
            if (v10 <= v8)
            {
              break;
            }

            v10 = (v10 - 16);
          }

          while (__key == LODWORD(result[-1].__shared_owners_));
          v11 = (&v8->std::__shared_count + v7);
          v12 = result;
          if (result < v11)
          {
            v12 = result;
            do
            {
              if (__key != *v12)
              {
                break;
              }

              v12 += 16;
            }

            while (v12 < v11);
          }

          *a2 = (v12 - result) >> 4;
        }

        else
        {
          result = 0;
          *a2 = 0;
        }
      }

      else
      {
        result = 0;
      }

      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        v13 = result;
        (v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
        return v13;
      }
    }
  }

  return result;
}

void sub_1B334CCCC(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t geo::codec::compareStrokeSpecifications(geo::codec *this, unsigned int *a2, const void *a3)
{
  v3 = *a2;
  v4 = *this >= v3;
  v5 = *this > v3;
  if (v4)
  {
    return v5;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

std::__shared_weak_count *geo::codec::multiSectionFeatureGetGhostPoint(uint64_t a1, uint64_t a2, std::__shared_weak_count_vtbl *a3)
{
  result = geo::codec::vertexPoolForFeature(a1);
  if (result)
  {
    v7 = result[3].__vftable;
    if (v7 && (v8 = &v7->~__shared_weak_count + 2 * *(a1 + 92) + 2 * a2, (v9 = v8[1]) != 0))
    {
      for (result = (result[2].__shared_owners_ + 32 * *v8); result[1].__vftable != a3; result = (result + 32))
      {
        if (!--v9)
        {
          return 0;
        }
      }
    }

    else
    {
      return 0;
    }
  }

  return result;
}

std::__shared_weak_count *geo::codec::polygonFeatureGetCharacteristicPointsForSection(void *a1, uint64_t a2, uint64_t *a3)
{
  __key[2] = *MEMORY[0x1E69E9840];
  result = a1[1];
  if (result)
  {
    result = std::__shared_weak_count::lock(result);
    if (result)
    {
      v7 = result;
      v8 = *a1;
      if (*a1)
      {
        v9 = v8[154];
        v10 = v8[153];
        v11 = (a1 - v8[12]) >> 7;
        __key[0] = v11;
        __key[1] = a2;
        v12 = bsearch(__key, v10, v9, 0x64uLL, geo::codec::_searchForCharacteristicPointsInSection(GeoCodecsCharacteristicPoint const*,unsigned long,unsigned long,unsigned long,unsigned long *)::$_0::__invoke);
        if (a3)
        {
          v13 = v12;
          if (v12)
          {
            do
            {
              result = v13;
              if (v13 <= v10)
              {
                break;
              }

              if (v11 != LODWORD(v13[-4].__vftable))
              {
                break;
              }

              v13 = (v13 - 100);
            }

            while (HIDWORD(result[-4].__vftable) == a2);
            *a3 = 0;
            v14 = (v10 + 100 * v9);
            if (result < v14)
            {
              v15 = 1;
              v16 = result;
              do
              {
                if (v11 != HIDWORD(v16->__vftable))
                {
                  break;
                }

                if (LODWORD(v16->__shared_owners_) != a2)
                {
                  break;
                }

                *a3 = v15;
                v16 = (v16 + 100);
                ++v15;
              }

              while (v16 < v14);
            }

            goto LABEL_17;
          }

          *a3 = 0;
        }
      }

      result = 0;
LABEL_17:
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        v17 = result;
        (v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        return v17;
      }
    }
  }

  return result;
}

void sub_1B334CF40(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t geo::codec::_searchForCharacteristicPointsInSection(GeoCodecsCharacteristicPoint const*,unsigned long,unsigned long,unsigned long,unsigned long *)::$_0::__invoke(unint64_t *a1, uint64_t a2)
{
  v2 = *a1;
  v3 = a1[1];
  v4 = *(a2 + 4);
  v5 = *(a2 + 8);
  v7 = v3 >= v5;
  v6 = v3 > v5;
  if (!v7)
  {
    v6 = -1;
  }

  v7 = v2 >= v4;
  if (v2 <= v4)
  {
    v8 = v6;
  }

  else
  {
    v8 = 1;
  }

  if (v7)
  {
    return v8;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }
}

std::__shared_weak_count *geo::codec::polygonFeatureGetCharacteristicPoints(void *a1, uint64_t *a2)
{
  result = a1[1];
  if (result)
  {
    result = std::__shared_weak_count::lock(result);
    if (result)
    {
      v5 = result;
      v6 = *a1;
      if (*a1)
      {
        v7 = v6[154];
        v8 = v6[153];
        __key = (a1 - v6[12]) >> 7;
        result = bsearch(&__key, v8, v7, 0x64uLL, geo::codec::_searchForCharacteristicPoints(GeoCodecsCharacteristicPoint const*,unsigned long,unsigned long,unsigned long *)::$_0::__invoke);
        if (a2)
        {
          if (result)
          {
            for (; result > v8; result = (result - 100))
            {
              if (__key != LODWORD(result[-4].__vftable))
              {
                break;
              }
            }

            *a2 = 0;
            v9 = (v8 + 100 * v7);
            if (result < v9)
            {
              v10 = __key;
              v11 = 1;
              v12 = result;
              do
              {
                if (v10 != HIDWORD(v12->__vftable))
                {
                  break;
                }

                *a2 = v11;
                v12 = (v12 + 100);
                ++v11;
              }

              while (v12 < v9);
            }

            goto LABEL_16;
          }

          *a2 = 0;
        }
      }

      result = 0;
LABEL_16:
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        v13 = result;
        (v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
        return v13;
      }
    }
  }

  return result;
}

void sub_1B334D110(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }

  _Unwind_Resume(exception_object);
}

uint64_t geo::codec::_searchForCharacteristicPoints(GeoCodecsCharacteristicPoint const*,unsigned long,unsigned long,unsigned long *)::$_0::__invoke(unint64_t *a1, uint64_t a2)
{
  v2 = *(a2 + 4);
  if (*a1 < v2)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return *a1 > v2;
  }
}

std::__shared_weak_count *geo::codec::multiSectionFeaturePrecision(std::__shared_weak_count *a1)
{
  result = geo::codec::vertexPoolForFeature(a1);
  if (result)
  {
    return LOBYTE(result->__vftable);
  }

  return result;
}

float geo::codec::buildingFootprintExtrusionHeight(uint64_t a1, unint64_t a2)
{
  v2 = 0.0;
  if (*(a1 + 96) > a2)
  {
    v4 = *(a1 + 8);
    if (v4)
    {
      v6 = std::__shared_weak_count::lock(v4);
      if (v6)
      {
        if (*a1)
        {
          v2 = *(*(*a1 + 312) + 4 * *(a1 + 112) + 4 * a2);
        }

        if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v7 = v6;
          (v6->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }

  return v2;
}

float geo::codec::buildingFootprintBaseHeight(uint64_t a1, unint64_t a2)
{
  v2 = 0.0;
  if (*(a1 + 96) > a2)
  {
    v4 = *(a1 + 8);
    if (v4)
    {
      v6 = std::__shared_weak_count::lock(v4);
      if (v6)
      {
        if (*a1)
        {
          v7 = *(*a1 + 344);
          if (v7)
          {
            v2 = *(v7 + 4 * *(a1 + 120) + 4 * a2);
          }
        }

        if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v8 = v6;
          (v6->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }

  return v2;
}

uint64_t geo::codec::buildingFootprintFeatureAtIndex(void *a1, unint64_t a2)
{
  v2 = a1[35];
  v3 = 0xF0F0F0F0F0F0F0F1 * ((a1[36] - v2) >> 3);
  v4 = a1[47];
  if (v3 - 0xF0F0F0F0F0F0F0FLL * ((a1[48] - v4) >> 3) <= a2)
  {
    return 0;
  }

  v5 = a2 >= v3;
  v6 = a2 - v3;
  if (v5)
  {
    return v4 + 136 * v6;
  }

  else
  {
    return v2 + 136 * a2;
  }
}

uint64_t geo::codec::threeDBuildingFeatureAtIndex(void *a1, unint64_t a2)
{
  v2 = a1[55];
  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[56] - v2) >> 4);
  v4 = a1[59];
  if (v3 + 0x6DB6DB6DB6DB6DB7 * ((a1[60] - v4) >> 4) <= a2)
  {
    return 0;
  }

  v5 = a2 >= v3;
  v6 = a2 - v3;
  if (v5)
  {
    return v4 + 112 * v6;
  }

  else
  {
    return v2 + 112 * a2;
  }
}

std::__shared_weak_count *geo::codec::pBTransitStationTransferGetPoints(void *a1, unint64_t a2, void *a3)
{
  if (a3)
  {
    *a3 = 0;
  }

  if (!a1)
  {
    return 0;
  }

  result = a1[1];
  if (result)
  {
    result = std::__shared_weak_count::lock(result);
    if (result)
    {
      if (*a1 && a1[11] > a2 && (v7 = *(*a1 + 1464)) != 0 && (v8 = v7[1]) != 0 && (v9 = v7[4]) != 0 && (v10 = a1[10] + a2, v10 <= v7[5]))
      {
        if (a3)
        {
          *a3 = *(v9 + 16 * v10 + 8);
        }

        v11 = v8 + 8 * *(v9 + 16 * v10);
      }

      else
      {
        v11 = 0;
      }

      if (!atomic_fetch_add(&result->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        v12 = result;
        (result->__on_zero_shared)();
        std::__shared_weak_count::__release_weak(v12);
      }

      return v11;
    }
  }

  return result;
}

void geo::codec::transitLinkExtractLineInfo(void *a1, uint64_t a2, void *a3, void *a4)
{
  v7 = a1[1];
  if (v7 && (v9 = std::__shared_weak_count::lock(v7)) != 0)
  {
    v10 = *a1;
    if (!*a1 || ((v11 = v10[161], v12 = v10[174], v11) ? (v13 = v12 == 0) : (v13 = 1), v13 || (v14 = a1[3] + a2, v14 >= v10[175])))
    {
      v18 = 0;
    }

    else
    {
      v15 = *(v12 + 8 * v14);
      v16 = 0x4EC4EC4EC4EC4EC5 * ((v10[162] - v11) >> 3);
      v17 = v11 + 104 * v15;
      if (v15 >= v16)
      {
        v18 = 0;
      }

      else
      {
        v18 = v17;
      }
    }

    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      v19 = v9;
      (v9->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v19);
    }

    *a3 = v18;
    *a4 = 0;
    if (v18)
    {
      v20 = a1[1];
      if (v20)
      {
        v21 = *(v18 + 80);
        v22 = std::__shared_weak_count::lock(v20);
        if (v22)
        {
          v23 = *a1;
          if (*a1)
          {
            v24 = v23[166];
            v25 = v23[165];
            if (0x8E38E38E38E38E39 * ((v24 - v25) >> 3) > v21)
            {
              *a4 = v25 + 72 * v21;
            }
          }

          if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            v26 = v22;
            (v22->__on_zero_shared)();

            std::__shared_weak_count::__release_weak(v26);
          }
        }
      }
    }
  }

  else
  {
    *a3 = 0;
    *a4 = 0;
  }
}

uint64_t geo::codec::vectorTransitLineForTransitNodeSubtitleIndex(uint64_t a1, unsigned int a2)
{
  v3 = *(a1 + 8);
  if (!v3)
  {
    return 0;
  }

  v5 = std::__shared_weak_count::lock(v3);
  if (!v5)
  {
    return 0;
  }

  v6 = *a1;
  if (!*a1 || *(a1 + 274) <= a2 || (v7 = *(a1 + 292) + a2, v6[205] <= v7) || (v8 = *(v6[204] + 8 * v7), v8 == -1))
  {
    v9 = 0;
  }

  else
  {
    v9 = v6[161] + 104 * v8;
  }

  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    v10 = v5;
    (v5->__on_zero_shared)();
    std::__shared_weak_count::__release_weak(v10);
  }

  return v9;
}

void geo::codec::transitNodeFeatureGetStyleAttributes(void *a1, void *a2)
{
  if (!a2)
  {
    *a1 = 0;
    a1[1] = 0;
    return;
  }

  v4 = a2[1];
  if (v4)
  {
    v4 = std::__shared_weak_count::lock(v4);
    if (v4)
    {
      if (*a2 && a2[39])
      {
        v5 = *(*(*a2 + 1728) + 16 * a2[38]);
        *a1 = v5;
        if (*(&v5 + 1))
        {
          atomic_fetch_add_explicit((*(&v5 + 1) + 8), 1uLL, memory_order_relaxed);
        }

LABEL_14:
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v7 = v4;
          (v4->__on_zero_shared)();

          std::__shared_weak_count::__release_weak(v7);
        }

        return;
      }
    }
  }

  if (a2[39])
  {
    *a1 = 0;
    a1[1] = 0;
  }

  else
  {
    v6 = a2[4];
    *a1 = a2[3];
    a1[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit((v6 + 8), 1uLL, memory_order_relaxed);
    }
  }

  if (v4)
  {
    goto LABEL_14;
  }
}

void geo::codec::transitNodeFeatureGetNativeParentheticalLabels(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v6 = a1[1];
  if (!v6)
  {
    return;
  }

  v11 = std::__shared_weak_count::lock(v6);
  if (!v11)
  {
    return;
  }

  if (*a1)
  {
    v12 = a1[35];
    if (v12 == -1)
    {
      if (a2)
      {
        *a2 = 0;
      }

      if (a3)
      {
        *a3 = 0;
      }

      if (!a4)
      {
        goto LABEL_20;
      }

      v14 = 0;
    }

    else
    {
      v13 = (*(*a1 + 1056) + 24 * v12);
      if (a2)
      {
        *a2 = *v13;
      }

      if (a5)
      {
        *a5 = v13[1];
      }

      if (a3)
      {
        *a3 = v13[3];
      }

      if (!a4)
      {
        goto LABEL_20;
      }

      v14 = v13[6];
    }

    *a4 = v14;
  }

LABEL_20:
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    v15 = v11;
    (v11->__on_zero_shared)();

    std::__shared_weak_count::__release_weak(v15);
  }
}

void geo::codec::transitNodeFeatureGetLocalizedParentheticalLabels(void *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, void *a5)
{
  v10 = a1[1];
  if (v10)
  {
    v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      if (!*a1 || (v12 = a1[35], v12 == -1))
      {
        v14 = 0;
        v16 = 0;
        v17 = 0;
        v15 = 0;
      }

      else
      {
        v13 = (*(*a1 + 1056) + 24 * v12);
        v14 = *v13;
        v15 = v13[1];
        v16 = v13[3];
        v17 = v13[6];
      }

      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        v18 = v11;
        (v11->__on_zero_shared)();
        std::__shared_weak_count::__release_weak(v18);
      }

      if (v14 && v16 && v17)
      {
        v19 = a1[1];
        v62 = v15;
        v63 = v17;
        if (!v19)
        {
          v21 = 0;
          v32 = 0;
          v33 = 0;
          v34 = 0;
LABEL_77:
          if (v32 && v33 && v34 && v21)
          {
            if (a2)
            {
              *a2 = v32;
            }

            if (a3)
            {
              *a3 = v33;
            }

            if (a4)
            {
              *a4 = v34;
            }
          }

          else
          {
            if (a2)
            {
              *a2 = v14;
            }

            v21 = v62;
            if (a3)
            {
              *a3 = v16;
            }

            if (a4)
            {
              *a4 = v63;
            }
          }

          if (!a5)
          {
            return;
          }

LABEL_32:
          *a5 = v21;
          return;
        }

        v20 = std::__shared_weak_count::lock(v19);
        if (!v20)
        {
          v21 = 0;
          v61 = 0;
          goto LABEL_41;
        }

        v21 = *a1;
        if (*a1)
        {
          v22 = v21[108];
          if (v22 <= v14 && v21[109] > v14)
          {
            v23 = v20;
            v24 = v21[136];
            v25 = v21[137];
            __key = v14 - v22;
            v26 = bsearch(&__key, v24, (v25 - v24) >> 5, 0x20uLL, geo::codec::compareSearchingLocalizationTableEntries);
            if (!v26)
            {
              goto LABEL_37;
            }

            v27 = v26[1];
            if (v27 == -1)
            {
              goto LABEL_37;
            }

            v28 = 114;
            if (v26[3])
            {
              v28 = 128;
            }

            v29 = &v21[v28];
            v30 = v21[v28];
            if (v27 >= v29[1] - v30)
            {
LABEL_37:
              v20 = v23;
            }

            else
            {
              v31 = v26;
              v20 = v23;
              if (v30)
              {
                v21 = v31[2];
                v61 = v30 + v27;
                goto LABEL_39;
              }
            }
          }

          v61 = 0;
          v21 = 0;
        }

        else
        {
          v61 = 0;
        }

LABEL_39:
        if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v35 = v20;
          (v20->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v35);
        }

LABEL_41:
        v36 = a1[1];
        if (!v36)
        {
          v33 = 0;
          v34 = 0;
          goto LABEL_76;
        }

        v37 = std::__shared_weak_count::lock(v36);
        if (!v37)
        {
          v33 = 0;
LABEL_59:
          v48 = a1[1];
          if (v48)
          {
            v49 = std::__shared_weak_count::lock(v48);
            if (v49)
            {
              v50 = *a1;
              if (v50)
              {
                v51 = v50[108];
                if (v51 <= v63 && v50[109] > v63)
                {
                  v52 = v49;
                  v53 = v50[136];
                  v54 = v50[137];
                  __key = v63 - v51;
                  v55 = bsearch(&__key, v53, (v54 - v53) >> 5, 0x20uLL, geo::codec::compareSearchingLocalizationTableEntries);
                  if (!v55)
                  {
                    goto LABEL_72;
                  }

                  v56 = v55[1];
                  if (v56 == -1)
                  {
                    goto LABEL_72;
                  }

                  v57 = 114;
                  if (v55[3])
                  {
                    v57 = 128;
                  }

                  v58 = &v50[v57];
                  v59 = v50[v57];
                  if (v56 >= v58[1] - v59)
                  {
LABEL_72:
                    v49 = v52;
                  }

                  else
                  {
                    v49 = v52;
                    if (v59)
                    {
                      v34 = v59 + v56;
                      goto LABEL_74;
                    }
                  }
                }
              }

              v34 = 0;
LABEL_74:
              if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                v60 = v49;
                (v49->__on_zero_shared)();
                std::__shared_weak_count::__release_weak(v60);
              }

              goto LABEL_76;
            }
          }

          v34 = 0;
LABEL_76:
          v32 = v61;
          goto LABEL_77;
        }

        v33 = *a1;
        if (*a1)
        {
          v38 = v33[108];
          if (v38 <= v16 && v33[109] > v16)
          {
            v39 = v37;
            v40 = v33[136];
            v41 = v33[137];
            __key = v16 - v38;
            v42 = bsearch(&__key, v40, (v41 - v40) >> 5, 0x20uLL, geo::codec::compareSearchingLocalizationTableEntries);
            if (!v42)
            {
              goto LABEL_55;
            }

            v43 = v42[1];
            if (v43 == -1)
            {
              goto LABEL_55;
            }

            v44 = 114;
            if (v42[3])
            {
              v44 = 128;
            }

            v45 = &v33[v44];
            v46 = v33[v44];
            if (v43 >= v45[1] - v46)
            {
LABEL_55:
              v37 = v39;
            }

            else
            {
              v37 = v39;
              if (v46)
              {
                v33 = (v46 + v43);
                goto LABEL_57;
              }
            }
          }

          v33 = 0;
        }

LABEL_57:
        if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          v47 = v37;
          (v37->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v47);
        }

        goto LABEL_59;
      }
    }
  }

  if (a2)
  {
    *a2 = 0;
  }

  if (a3)
  {
    *a3 = 0;
  }

  if (a4)
  {
    *a4 = 0;
  }

  if (a5)
  {
    v21 = 0;
    goto LABEL_32;
  }
}

void sub_1B334DE1C(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }

  _Unwind_Resume(exception_object);
}

std::__shared_weak_count **geo::codec::forEachEdgeOnJunction(std::__shared_weak_count **result, unsigned int *a2, uint64_t a3)
{
  v13 = *MEMORY[0x1E69E9840];
  v10 = a2;
  if (a2)
  {
    v3 = result;
    v4 = *result;
    if (*result)
    {
      if (*(a3 + 24) && *a2)
      {
        v6 = 0;
        shared_owners = v4[1].__shared_owners_;
        v8 = &v4[30].~__shared_weak_count + 4;
        do
        {
          v9 = shared_owners + 168 * *(v8 + 16 * a2[1]);
          v11[0] = &unk_1F2A5FB08;
          v11[1] = &v10;
          v11[2] = a3;
          v12 = v11;
          geo::codec::forEachEdgeInRoad(*v3, v9, 1, v11);
          result = v12;
          if (v12 == v11)
          {
            result = ((*v12)[1].__shared_owners_)(v12);
          }

          else if (v12)
          {
            result = ((*v12)[1].__shared_weak_owners_)();
          }

          v8 += 16;
          ++v6;
          a2 = v10;
        }

        while (v6 < *v10);
      }
    }
  }

  return result;
}

void sub_1B334DFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  if (a13 == &a10)
  {
    (*(*a13 + 32))(a13);
    _Unwind_Resume(exception_object);
  }

  if (a13)
  {
    (*(*a13 + 40))();
  }

  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0,std::allocator<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0>,void ()(GeoCodecsRoadEdge *)>::target(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 8);
  if (v2 == "ZN3geo5codec21forEachEdgeOnJunctionERKNSt3__110shared_ptrINS0_10VectorTileEEEPK29GeoCodecsConnectivityJunctionNS1_8functionIFvP17GeoCodecsRoadEdgeEEEE3$_0")
  {
    return a1 + 8;
  }

  if (((v2 & "ZN3geo5codec21forEachEdgeOnJunctionERKNSt3__110shared_ptrINS0_10VectorTileEEEPK29GeoCodecsConnectivityJunctionNS1_8functionIFvP17GeoCodecsRoadEdgeEEEE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v2, "ZN3geo5codec21forEachEdgeOnJunctionERKNSt3__110shared_ptrINS0_10VectorTileEEEPK29GeoCodecsConnectivityJunctionNS1_8functionIFvP17GeoCodecsRoadEdgeEEEE3$_0"))
  {
    return 0;
  }

  v4 = a1;
  v5 = strcmp((v2 & 0x7FFFFFFFFFFFFFFFLL), ("ZN3geo5codec21forEachEdgeOnJunctionERKNSt3__110shared_ptrINS0_10VectorTileEEEPK29GeoCodecsConnectivityJunctionNS1_8functionIFvP17GeoCodecsRoadEdgeEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL));
  a1 = v4;
  if (!v5)
  {
    return a1 + 8;
  }

  return 0;
}

uint64_t std::__function::__func<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0,std::allocator<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0>,void ()(GeoCodecsRoadEdge *)>::operator()(uint64_t result, uint64_t *a2)
{
  if (*(*a2 + 40) == **(result + 8))
  {
    v2 = *(result + 16);
    v4 = *a2;
    v3 = *(v2 + 24);
    if (!v3)
    {
      std::__throw_bad_function_call[abi:ne200100]();
    }

    return (*(*v3 + 48))(v3, &v4);
  }

  return result;
}

__n128 std::__function::__func<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0,std::allocator<geo::codec::forEachEdgeOnJunction(std::shared_ptr<geo::codec::VectorTile> const&,GeoCodecsConnectivityJunction const*,std::function<void ()(GeoCodecsRoadEdge *)>)::$_0>,void ()(GeoCodecsRoadEdge *)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A5FB08;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t geo::codec::chapterDetailTypeAsString(unint64_t a1)
{
  v3 = a1;
  if (HIDWORD(a1) == 0xFFFFFFFF)
  {
    std::__throw_bad_variant_access[abi:ne200100]();
  }

  v4 = &v2;
  return (off_1F2A5FAE8[HIDWORD(a1)])(&v4, &v3);
}

void std::__throw_bad_variant_access[abi:ne200100]()
{
  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E69E55D0] + 16;
  __cxa_throw(exception, MEMORY[0x1E69E5410], std::bad_variant_access::~bad_variant_access);
}

const char *std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne200100]<std::__variant_detail::__visitation::__variant::__value_visitor<geo::codec::chapterDetailTypeAsString(std::variant<ChapterType,DetailType>)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,ChapterType,DetailType> &>(uint64_t a1, _BYTE *a2)
{
  if (*a2 - 1 > 0xC)
  {
    return "unknown_detail";
  }

  else
  {
    return off_1E7B58558[(*a2 - 1)];
  }
}

const char *std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne200100]<std::__variant_detail::__visitation::__variant::__value_visitor<geo::codec::chapterDetailTypeAsString(std::variant<ChapterType,DetailType>)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,ChapterType,DetailType> &>(uint64_t a1, _WORD *a2)
{
  result = "ChapterGlobal";
  switch(*a2)
  {
    case 1:
      return result;
    case 0xA:
      result = "ChapterLabels";
      break;
    case 0xB:
      result = "ChapterLabelLanguages";
      break;
    case 0xD:
      result = "ChapterLabelLocalizations2";
      break;
    case 0x14:
      result = "ChapterVertices";
      break;
    case 0x1E:
      result = "ChapterPointFeatures";
      break;
    case 0x1F:
      result = "ChapterLineFeatures";
      break;
    case 0x20:
      result = "ChapterPolygonFeatures";
      break;
    case 0x21:
      result = "ChapterBuildingFeatures";
      break;
    case 0x22:
      result = "ChapterCoastlineFeatures";
      break;
    case 0x26:
      result = "ChapterWrappingCoastlineFeatures";
      break;
    case 0x27:
      result = "ChapterBuildingMeshes";
      break;
    case 0x33:
      result = "ChapterLinePointCharacteristics";
      break;
    case 0x34:
      result = "ChapterPolygonPointCharacteristics";
      break;
    case 0x37:
      result = "ChapterPolygonPointLabelPositions";
      break;
    case 0x3C:
      result = "ChapterConnectivity";
      break;
    case 0x50:
      result = "ChapterGeoIDSegments";
      break;
    case 0x5A:
      result = "ChapterAddressRanges";
      break;
    case 0x5D:
      result = "ChapterTileReferences";
      break;
    case 0x60:
      result = "ChapterHighResBuildings";
      break;
    case 0x64:
      result = "ChapterDaVinci3DData";
      break;
    case 0x65:
      result = "ChapterElevationRaster";
      break;
    case 0x66:
      result = "ChapterStyleAttributeRaster";
      break;
    case 0x67:
      result = "ChapterDaVinciMetadata";
      break;
    case 0x68:
      result = "ChapterLowResBuildings";
      break;
    case 0x70:
      result = "ChapterTransitMZROverride";
      break;
    case 0x77:
      result = "ChapterCoverage";
      break;
    case 0x80:
      result = "ChapterTransitSystems";
      break;
    case 0x81:
      result = "ChapterTransitNetwork";
      break;
    case 0x87:
      result = "ChapterRoadNetwork";
      break;
    case 0x88:
      result = "ChapterVenueMZROverride";
      break;
    case 0x89:
      result = "ChapterVenues";
      break;
    case 0x8A:
      result = "ChapterStorefronts";
      break;
    case 0x8B:
      result = "ChapterLowResBorderBuildings";
      break;
    case 0x8C:
      result = "ChapterBorderBuildingMeshes";
      break;
    case 0x8D:
      result = "ChapterLabelPlacementMetadata";
      break;
    case 0x8E:
      result = "ChapterDaVinciBuildings";
      break;
    case 0x90:
      result = "ChapterPointFeaturesAddendum";
      break;
    case 0x91:
      result = "ChapterLinesExtended";
      break;
    case 0x92:
      result = "ChapterTrafficSkeleton1";
      break;
    case 0x93:
      result = "ChapterDaVinciLandmarks";
      break;
    case 0x94:
      result = "ChapterLineWidths1";
      break;
    case 0x95:
      result = "ChapterPointLabelAnnotations";
      break;
    case 0x97:
      result = "ChapterPOIMzrOverrides";
      break;
    case 0x98:
      result = "ChapterTrafficSkeleton2";
      break;
    case 0x99:
      result = "ChapterLineWidths2";
      break;
    case 0x9A:
      result = "ChapterStyleAttributeRaster2";
      break;
    case 0x9B:
      result = "ChapterMaterialRaster";
      break;
    case 0x9C:
      result = "ChapterDaVinciAssetMetadata";
      break;
    case 0x9D:
      result = "ChapterRunningTracks";
      break;
    case 0x9E:
      result = "ChapterHikingHillShadeRaster";
      break;
    case 0x9F:
      result = "ChapterLiveFeatures";
      break;
    case 0xA0:
      result = "ChapterAnnotationLabels";
      break;
    case 0xA1:
      result = "ChapterContourLinesFeet";
      break;
    case 0xA2:
      result = "ChapterSupplementalFeatureIDs";
      break;
    case 0xA4:
      result = "ChapterContourLinesMeters";
      break;
    case 0xA5:
      result = "ChapterLiveFeaturesMetadatas";
      break;
    case 0xA6:
      result = "ChapterPOIUpdates";
      break;
    case 0xA7:
      result = "ChapterDaVinciLandmarkBuildings";
      break;
    case 0xA8:
      result = "ChapterRegionMetadata";
      break;
    case 0xA9:
      result = "ChapterCompressedPolygons";
      break;
    case 0xAA:
      result = "ChapterDTMRaster";
      break;
    case 0xAB:
      result = "ChapterGlobalContourLinesFeet";
      break;
    case 0xAC:
      result = "ChapterGlobalContourLinesMeters";
      break;
    default:
      result = "unknown_chapter";
      break;
  }

  return result;
}

void geo::codec::AssetDecoder::decodeAsset(geo::codec::AssetDecoder *this, geo::ibitstream *a2, unsigned int *a3)
{
  __p = 0;
  v34 = 0;
  v35 = 0;
  if (geo::ibitstream::readBytes(a2, &__p))
  {
    if (v34 != __p)
    {
      if (((v34 - __p) & 0x8000000000000000) == 0)
      {
        operator new();
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    if (__p)
    {
      operator delete(__p);
    }

    if (MEMORY[0] == 68)
    {
      if (MEMORY[1] == 86)
      {
        if (MEMORY[2] == 97)
        {
          if (MEMORY[3] == 115)
          {
            v6 = *(a2 + 1);
            v7 = *(a2 + 2);
            v8 = v7 + 4;
            v9 = *(a2 + 24);
            v10 = v7 + 5;
            if (!v9)
            {
              v10 = v7 + 4;
            }

            if (v6 >= v10)
            {
              v12 = *a2;
              if (*(a2 + 24))
              {
                v13 = 8 - v9;
                v14 = v7 + 1;
                if (v7 + 1 >= v6)
                {
                  v15 = 0;
                }

                else
                {
                  v15 = *(v12 + v14);
                }

                v17 = (1 << (8 - v9)) + 255;
                v18 = *(v12 + v7);
                v19 = 0xFFFF << v13;
                *(a2 + 2) = v14;
                v20 = *(v12 + v14);
                v21 = v7 + 2;
                if (v7 + 2 >= v6)
                {
                  v22 = 0;
                }

                else
                {
                  v22 = *(v12 + v21);
                }

                v23 = v17 & v18;
                v24 = v15 & v19;
                v25 = v17 & v20;
                v26 = v22 & v19;
                *(a2 + 2) = v21;
                v27 = *(v12 + v21);
                v28 = v7 + 3;
                if (v7 + 3 >= v6)
                {
                  v29 = 0;
                }

                else
                {
                  v29 = *(v12 + v28);
                }

                v30 = v24 >> v13;
                *(a2 + 2) = v28;
                v31 = *(v12 + v28);
                if (v8 >= v6)
                {
                  v32 = 0;
                }

                else
                {
                  v32 = *(v12 + v8);
                }

                *(a2 + 2) = v8;
                v16 = ((((v29 & v19) >> v13) | ((v17 & v27) << v9)) << 16) | ((((v32 & v19) >> v13) | ((v17 & v31) << v9)) << 24) | (((v26 >> v13) | (v25 << v9)) << 8) | v30 | (v23 << v9);
              }

              else
              {
                v16 = *(v12 + v7);
                *(a2 + 2) = v8;
              }

              *a3 = v16;
              if (v16 > 0x12)
              {
                if (v16 == 19)
                {
                  geo::codec::AssetDecoder::decodeAssetDeprecated(this, a2, a3);
                }

                geo::codec::AssetDecoder::decodeAssetV20(this, a2, a3);
              }

              fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Non supported version\n");
            }

            else
            {
              fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Read error\n");
            }

            goto LABEL_24;
          }

          v11 = *MEMORY[0x1E69E9848];
        }

        else
        {
          v11 = *MEMORY[0x1E69E9848];
        }
      }

      else
      {
        v11 = *MEMORY[0x1E69E9848];
      }
    }

    else
    {
      v11 = *MEMORY[0x1E69E9848];
    }

    fprintf(v11, "%s:%d Asset Parse: Magic header does not match\n");
LABEL_24:
    *this = 0;

    operator delete(0);
    return;
  }

  if (__p)
  {
    operator delete(__p);
  }

  fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Read error\n", "/Library/Caches/com.apple.xbs/Sources/GeoServices/geo/GeoCodecs/GeoCodecs/VMP4/AssetDecoder.cpp", 301);
  *this = 0;
}

void sub_1B33533F0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __clang_call_terminate(a1);
  }

  _Unwind_Resume(a1);
}

void sub_1B3358B54(geo::codec::zone_mallocator *a1)
{
  for (i = *(v2 - 208); i; i = v5)
  {
    v5 = *i;
    v6 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *>>(v6, i);
  }

  v7 = *(v2 - 232);
  *(v2 - 232) = 0;
  if (v7)
  {
    v8 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *> *> *>(v8, v7);
  }

  v9 = *(v2 - 176);
  if (v9)
  {
    *(v2 - 168) = v9;
    v11 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v11, v9);
  }

  v10 = *(v2 - 144);
  if (v10)
  {
    *(v2 - 136) = v10;
    v12 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v12, v10);
  }

  geo::codec::Asset::~Asset(v1);
  MEMORY[0x1B8C62190]();
  _Unwind_Resume(a1);
}

void sub_1B3358E18(_Unwind_Exception *a1, int a2)
{
  if (!a2)
  {
    _Unwind_Resume(a1);
  }

  __clang_call_terminate(a1);
}

void std::vector<unsigned int,geo::allocator_adapter<unsigned int,geo::codec::zone_mallocator>>::__append(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (a2 <= (v3 - v4) >> 2)
  {
    if (a2)
    {
      v14 = 4 * a2;
      bzero(*(a1 + 8), 4 * a2);
      v4 += v14;
    }

    *(a1 + 8) = v4;
  }

  else
  {
    v5 = *a1;
    v6 = v4 - *a1;
    v7 = v6 >> 2;
    v8 = (v6 >> 2) + a2;
    if (v8 >> 62)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v9 = v3 - v5;
    if (v9 >> 1 > v8)
    {
      v8 = v9 >> 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v10 = v8;
    }

    if (v10)
    {
      v11 = a2;
      v12 = geo::codec::zone_mallocator::instance(a1);
      v13 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned int>(v12, v10);
      a2 = v11;
      v5 = *a1;
      v6 = *(a1 + 8) - *a1;
    }

    else
    {
      v13 = 0;
    }

    v15 = &v13[4 * v7];
    v16 = 4 * a2;
    v17 = &v13[4 * v10];
    bzero(v15, 4 * a2);
    v18 = memcpy(&v15[-4 * (v6 >> 2)], v5, v6);
    v19 = *a1;
    *a1 = &v15[-4 * (v6 >> 2)];
    *(a1 + 8) = &v15[v16];
    *(a1 + 16) = v17;
    if (v19)
    {
      v20 = geo::codec::zone_mallocator::instance(v18);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v20, v19);
    }
  }
}

void std::vector<geo::codec::Asset::LodInfo,geo::allocator_adapter<geo::codec::Asset::LodInfo,geo::codec::zone_mallocator>>::__append(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (a2 <= (v3 - v4) >> 2)
  {
    if (a2)
    {
      v16 = 4 * a2;
      bzero(*(a1 + 8), 4 * a2);
      v4 += v16;
    }

    *(a1 + 8) = v4;
  }

  else
  {
    v5 = (v4 - *a1) >> 2;
    if ((v5 + a2) >> 62)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v6 = v3 - *a1;
    v7 = v6 >> 1;
    if (v6 >> 1 <= v5 + a2)
    {
      v7 = v5 + a2;
    }

    if (v6 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v8 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v8 = v7;
    }

    if (v8)
    {
      v9 = a2;
      v10 = geo::codec::zone_mallocator::instance(a1);
      v11 = pthread_rwlock_rdlock((v10 + 32));
      if (v11)
      {
        geo::read_write_lock::logFailure(v11, "read lock", v12);
      }

      v13 = malloc_type_zone_malloc(*v10, 4 * v8, 0x10000407B5B4437uLL);
      atomic_fetch_add((v10 + 24), 1u);
      v14 = pthread_rwlock_unlock((v10 + 32));
      if (v14)
      {
        geo::read_write_lock::logFailure(v14, "unlock", v15);
      }

      a2 = v9;
    }

    else
    {
      v13 = 0;
    }

    v17 = &v13[4 * v5];
    v18 = 4 * a2;
    v19 = &v13[4 * v8];
    bzero(v17, 4 * a2);
    v20 = &v17[v18];
    v21 = *(a1 + 8) - *a1;
    v22 = &v17[-v21];
    v23 = memcpy(&v17[-v21], *a1, v21);
    v24 = *a1;
    *a1 = v22;
    *(a1 + 8) = v20;
    *(a1 + 16) = v19;
    if (v24)
    {
      v25 = geo::codec::zone_mallocator::instance(v23);
      v26 = pthread_rwlock_rdlock((v25 + 32));
      if (v26)
      {
        geo::read_write_lock::logFailure(v26, "read lock", v27);
      }

      atomic_fetch_add((v25 + 24), 0xFFFFFFFF);
      malloc_zone_free(*v25, v24);
      v28 = pthread_rwlock_unlock((v25 + 32));
      if (v28)
      {

        geo::read_write_lock::logFailure(v28, "unlock", v29);
      }
    }
  }
}

void sub_1B3359120(void *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
    __clang_call_terminate(a1);
  }

  __clang_call_terminate(a1);
}

void std::vector<std::shared_ptr<geo::codec::AssetLodInstance>,geo::allocator_adapter<std::shared_ptr<geo::codec::AssetLodInstance>,geo::codec::zone_mallocator>>::reserve(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  if (a2 > (*(a1 + 2) - *a1) >> 4)
  {
    v3 = *(a1 + 1) - *a1;
    v5 = geo::codec::zone_mallocator::instance(a1);
    v6 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::shared_ptr<geo::codec::AssetLodInstance>>(v5, a2);
    v7 = &v6[v3];
    v8 = &v6[16 * a2];
    v9 = *(a1 + 1) - *a1;
    v10 = &v6[v3 - v9];
    v11 = memcpy(v10, *a1, v9);
    v12 = *a1;
    *a1 = v10;
    *(a1 + 1) = v7;
    *(a1 + 2) = v8;
    if (v12)
    {
      v13 = geo::codec::zone_mallocator::instance(v11);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::shared_ptr<geo::codec::AssetLodInstance>>(v13, v12);
    }
  }
}

void std::vector<unsigned long long,geo::allocator_adapter<unsigned long long,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = *(a1 + 1);
  v5 = v4 - *a1;
  v6 = a2 - (v5 >> 3);
  if (a2 <= v5 >> 3)
  {
    if (a2 >= v5 >> 3)
    {
      return;
    }

    v22 = v3 + 8 * a2;
    goto LABEL_14;
  }

  v7 = *(a1 + 2);
  if (v6 <= (v7 - v4) >> 3)
  {
    bzero(*(a1 + 1), 8 * v6);
    v22 = v4 + 8 * v6;
LABEL_14:
    *(a1 + 1) = v22;
    return;
  }

  if (a2 >> 61)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v8 = v7 - v3;
  v9 = v8 >> 2;
  if (v8 >> 2 <= a2)
  {
    v9 = a2;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFF8)
  {
    v10 = 0x1FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v9;
  }

  v11 = geo::codec::zone_mallocator::instance(a1);
  v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned long long>(v11, v10);
  v13 = *a1;
  v14 = *(a1 + 1) - *a1;
  v15 = &v12[v5];
  v16 = &v12[8 * v10];
  bzero(v15, 8 * v6);
  v17 = &v15[8 * v6];
  v18 = &v15[-v14];
  v19 = memcpy(v18, v13, v14);
  v20 = *a1;
  *a1 = v18;
  *(a1 + 1) = v17;
  *(a1 + 2) = v16;
  if (v20)
  {
    v21 = geo::codec::zone_mallocator::instance(v19);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned long long>(v21, v20);
  }
}

void std::vector<gm::Matrix<float,3,1>,geo::allocator_adapter<gm::Matrix<float,3,1>,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v2 = *a1;
  v3 = *(a1 + 1);
  v4 = v3 - *a1;
  v5 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 2);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 >= v5)
    {
      return;
    }

    v22 = &v2[12 * a2];
    goto LABEL_18;
  }

  v7 = *(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 2) >= v6)
  {
    v22 = (v3 + 12 * (12 * v6 / 0xC));
LABEL_18:
    *(a1 + 1) = v22;
    return;
  }

  if (a2 > 0x1555555555555555)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v2) >> 2);
  v10 = 2 * v9;
  if (2 * v9 <= a2)
  {
    v10 = a2;
  }

  if (v9 >= 0xAAAAAAAAAAAAAAALL)
  {
    v11 = 0x1555555555555555;
  }

  else
  {
    v11 = v10;
  }

  v12 = geo::codec::zone_mallocator::instance(a1);
  v13 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gm::Matrix<float,3,1>>(v12, v11);
  v14 = a1;
  v17 = a1;
  v16 = *a1;
  v15 = *(v17 + 1);
  v18 = v13 + v4 + v16 - v15;
  if (v16 != v15)
  {
    v19 = v13 + v4 + v16 - v15;
    do
    {
      v20 = *v16;
      *(v19 + 2) = *(v16 + 2);
      *v19 = v20;
      v19 += 12;
      v16 += 12;
    }

    while (v16 != v15);
    v16 = *v14;
  }

  *v14 = v18;
  *(v14 + 1) = v13 + 12 * (12 * v6 / 0xC) + v4;
  *(v14 + 2) = v13 + 12 * v11;
  if (v16)
  {
    v21 = geo::codec::zone_mallocator::instance(v13);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,3,1>>(v21, v16);
  }
}

void std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = *(a1 + 1);
  v5 = v4 - *a1;
  v6 = a2 - (v5 >> 1);
  if (a2 <= v5 >> 1)
  {
    if (a2 >= v5 >> 1)
    {
      return;
    }

    v22 = v3 + 2 * a2;
    goto LABEL_15;
  }

  v7 = *(a1 + 2);
  if (v6 <= (v7 - v4) >> 1)
  {
    bzero(*(a1 + 1), 2 * v6);
    v22 = v4 + 2 * v6;
LABEL_15:
    *(a1 + 1) = v22;
    return;
  }

  if ((a2 & 0x8000000000000000) != 0)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v8 = v7 - v3;
  if (v8 <= a2)
  {
    v9 = a2;
  }

  else
  {
    v9 = v8;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFFELL)
  {
    v10 = 0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v9;
  }

  v11 = geo::codec::zone_mallocator::instance(a1);
  v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned short>(v11, v10);
  v13 = *a1;
  v14 = *(a1 + 1) - *a1;
  v15 = &v12[v5];
  v16 = &v12[2 * v10];
  bzero(v15, 2 * v6);
  v17 = &v15[2 * v6];
  v18 = &v15[-v14];
  v19 = memcpy(v18, v13, v14);
  v20 = *a1;
  *a1 = v18;
  *(a1 + 1) = v17;
  *(a1 + 2) = v16;
  if (v20)
  {
    v21 = geo::codec::zone_mallocator::instance(v19);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v21, v20);
  }
}

void std::vector<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v4 = *a1;
  v3 = *(a1 + 1);
  v5 = v3 - *a1;
  v6 = a2 - (v5 >> 5);
  if (a2 <= v5 >> 5)
  {
    if (a2 < v5 >> 5)
    {
      v22 = &v4[32 * a2];
      if (v3 != v22)
      {
        v23 = *(a1 + 1);
        do
        {
          v25 = *(v23 - 4);
          v23 -= 4;
          v24 = v25;
          if (v25)
          {
            *(v3 - 3) = v24;
            v26 = geo::codec::zone_mallocator::instance(a1);
            geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v26, v24);
          }

          v3 = v23;
        }

        while (v23 != v22);
      }

      *(a1 + 1) = v22;
    }
  }

  else
  {
    v7 = *(a1 + 2);
    if (v6 <= (v7 - v3) >> 5)
    {
      v27 = &v3[4 * v6];
      v28 = 32 * a2 - 32 * (v5 >> 5);
      do
      {
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
        v3 += 4;
        v28 -= 32;
      }

      while (v28);
      *(a1 + 1) = v27;
    }

    else
    {
      if (a2 >> 59)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v8 = (v7 - v4) >> 4;
      if (v8 <= a2)
      {
        v8 = a2;
      }

      if ((v7 - v4) >= 0x7FFFFFFFFFFFFFE0)
      {
        v9 = 0x7FFFFFFFFFFFFFFLL;
      }

      else
      {
        v9 = v8;
      }

      v29[4] = a1 + 24;
      v11 = geo::codec::zone_mallocator::instance(a1);
      v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>>(v11, v9);
      v13 = &v12[v5];
      v14 = &v12[32 * a2];
      v15 = &v4[32 * a2] - v3;
      v16 = v13;
      do
      {
        *v16 = 0;
        *(v16 + 1) = 0;
        *(v16 + 2) = 0;
        v16 += 32;
        v15 -= 32;
      }

      while (v15);
      v17 = &v12[32 * v9];
      v18 = *(a1 + 1) - *a1;
      v19 = &v13[-v18];
      memcpy(&v13[-v18], *a1, v18);
      v20 = *a1;
      *a1 = v19;
      *(a1 + 1) = v14;
      v21 = *(a1 + 2);
      *(a1 + 2) = v17;
      v29[2] = v20;
      v29[3] = v21;
      v29[0] = v20;
      v29[1] = v20;
      std::__split_buffer<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator> &>::~__split_buffer(v29);
    }
  }
}

void std::vector<geo::codec::ModelNode,geo::allocator_adapter<geo::codec::ModelNode,geo::codec::zone_mallocator>>::resize(geo::codec::ModelNode **a1, unint64_t a2)
{
  v2 = a1;
  v3 = a1[1];
  v4 = *v2;
  v5 = v3 - *v2;
  v6 = 0x8E38E38E38E38E39 * (v5 >> 4);
  v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 >= v6)
    {
      return;
    }

    v58 = (v4 + 144 * a2);
    while (v3 != v58)
    {
      geo::codec::ModelNode::~ModelNode((v3 - 144));
    }

LABEL_33:
    v2[1] = v58;
    return;
  }

  v8 = v2[2];
  if (0x8E38E38E38E38E39 * ((v8 - v3) >> 4) >= v7)
  {
    v58 = (v3 + 144 * v7);
    __asm { FMOV            V1.4S, #1.0 }

    do
    {
      *(v3 + 7) = 0uLL;
      *(v3 + 8) = 0uLL;
      *(v3 + 5) = 0uLL;
      *(v3 + 6) = 0uLL;
      *(v3 + 3) = 0uLL;
      *(v3 + 4) = 0uLL;
      *(v3 + 1) = 0uLL;
      *(v3 + 2) = 0uLL;
      *v3 = 0uLL;
      *(v3 + 120) = _Q1;
      v3 = (v3 + 144);
    }

    while (v3 != v58);
    goto LABEL_33;
  }

  if (a2 > 0x1C71C71C71C71C7)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v9 = 0x8E38E38E38E38E39 * ((v8 - v4) >> 4);
  v10 = 2 * v9;
  if (2 * v9 <= a2)
  {
    v10 = a2;
  }

  if (v9 >= 0xE38E38E38E38E3)
  {
    v12 = 0x1C71C71C71C71C7;
  }

  else
  {
    v12 = v10;
  }

  v13 = geo::codec::zone_mallocator::instance(v3);
  v14 = pthread_rwlock_rdlock((v13 + 32));
  if (v14)
  {
    geo::read_write_lock::logFailure(v14, "read lock", v15);
  }

  v16 = malloc_type_zone_malloc(*v13, 144 * v12, 0x101004088F5EF07uLL);
  atomic_fetch_add((v13 + 24), 1u);
  v17 = pthread_rwlock_unlock((v13 + 32));
  if (v17)
  {
    geo::read_write_lock::logFailure(v17, "unlock", v18);
  }

  v19 = &v16[144 * a2];
  __asm { FMOV            V1.4S, #1.0 }

  v25 = v5;
  do
  {
    v26 = &v16[v25];
    *(v26 + 7) = 0uLL;
    *(v26 + 8) = 0uLL;
    *(v26 + 5) = 0uLL;
    *(v26 + 6) = 0uLL;
    *(v26 + 3) = 0uLL;
    *(v26 + 4) = 0uLL;
    *(v26 + 1) = 0uLL;
    *(v26 + 2) = 0uLL;
    *v26 = 0uLL;
    v25 += 144;
    *(v26 + 120) = _Q1;
  }

  while (v26 + 144 != v19);
  v28 = *v2;
  v27 = v2[1];
  v29 = &v16[v5 + *v2 - v27];
  if (v27 != *v2)
  {
    v61 = &v16[144 * a2];
    v62 = v2;
    v63 = v16;
    v30 = 0;
    v64 = v2[1];
    v65 = v29;
    do
    {
      v35 = v28 + v30;
      v36 = v29 + v30;
      *(v29 + v30 + 8) = 0;
      *v36 = 0;
      *(v36 + 2) = 0;
      v36[24] = *(v28 + v30 + 24);
      v38 = *(v28 + v30);
      v37 = *(v28 + v30 + 8);
      v39 = v37 - v38;
      if (v37 != v38)
      {
        if (v39 >> 1 < 0)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v40 = geo::codec::zone_mallocator::instance(v17);
        v41 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned short>(v40, v39 >> 1);
        *v36 = v41;
        *(v36 + 1) = v41;
        v42 = &v41[v39];
        *(v36 + 2) = &v41[v39];
        v17 = memmove(v41, v38, v39);
        *(v36 + 1) = v42;
      }

      *(v36 + 4) = 0;
      *(v36 + 5) = 0;
      v66 = (v36 + 40);
      *(v36 + 6) = 0;
      v36[56] = v35[56];
      v44 = *(v35 + 4);
      v43 = *(v35 + 5);
      v45 = v43 - v44;
      if (v43 != v44)
      {
        if (v45 >> 1 < 0)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v46 = geo::codec::zone_mallocator::instance(v17);
        v47 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned short>(v46, v45 >> 1);
        *(v36 + 4) = v47;
        *v66 = v47;
        v48 = &v47[v45];
        *(v36 + 6) = &v47[v45];
        v17 = memmove(v47, v44, v45);
        *v66 = v48;
      }

      *(v29 + v30 + 64) = 0;
      v50 = v29 + v30 + 64;
      v51 = v28 + v30;
      v49 = v29 + v30;
      *(v49 + 9) = 0;
      v52 = v29 + v30 + 72;
      *(v49 + 10) = 0;
      v49[88] = *(v28 + v30 + 88);
      v54 = *(v28 + v30 + 64);
      v53 = *(v28 + v30 + 72);
      v55 = v53 - v54;
      if (v53 != v54)
      {
        if (v55 >> 1 < 0)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v56 = geo::codec::zone_mallocator::instance(v17);
        v57 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned short>(v56, v55 >> 1);
        *v50 = v57;
        *v52 = v57;
        v31 = &v57[v55];
        *(v49 + 10) = &v57[v55];
        v17 = memmove(v57, v54, v55);
        *v52 = v31;
      }

      v32 = *(v51 + 12);
      *(v49 + 26) = *(v51 + 26);
      *(v49 + 12) = v32;
      v33 = *(v51 + 108);
      *(v49 + 29) = *(v51 + 29);
      *(v49 + 108) = v33;
      *(v49 + 30) = *(v51 + 30);
      v34 = *(v51 + 124);
      *(v49 + 33) = *(v51 + 33);
      *(v49 + 124) = v34;
      LOWORD(v34) = *(v51 + 68);
      v49[138] = v51[138];
      *(v49 + 68) = v34;
      v30 += 144;
      v29 = v65;
    }

    while ((v28 + v30) != v64);
    v16 = v63;
    do
    {
      geo::codec::ModelNode::~ModelNode(v28);
      v28 = (v28 + 144);
    }

    while (v28 != v64);
    v2 = v62;
    v28 = *v62;
    v19 = v61;
  }

  *v2 = v29;
  v2[1] = v19;
  v2[2] = &v16[144 * v12];
  if (v28)
  {
    v60 = geo::codec::zone_mallocator::instance(v17);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::ModelNode>(v60, v28);
  }
}

void sub_1B3359B20(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

void std::vector<geo::codec::Mesh,geo::allocator_adapter<geo::codec::Mesh,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = *(a1 + 1);
  v5 = v4 - *a1;
  v6 = 0x86BCA1AF286BCA1BLL * (v5 >> 3);
  v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 >= v6)
    {
      return;
    }

    v30 = (v3 + 152 * a2);
    while (v4 != v30)
    {
      v4 = (v4 - 152);
      geo::codec::Mesh::~Mesh(v4);
    }

    goto LABEL_25;
  }

  v8 = *(a1 + 2);
  if (0x86BCA1AF286BCA1BLL * ((v8 - v4) >> 3) >= v7)
  {
    bzero(*(a1 + 1), 152 * ((152 * v7 - 152) / 0x98) + 152);
    v30 = (v4 + 152 * ((152 * v7 - 152) / 0x98) + 152);
LABEL_25:
    *(a1 + 1) = v30;
    return;
  }

  if (a2 > 0x1AF286BCA1AF286)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v9 = 0x86BCA1AF286BCA1BLL * ((v8 - v3) >> 3);
  v10 = 2 * v9;
  if (2 * v9 <= a2)
  {
    v10 = a2;
  }

  if (v9 >= 0xD79435E50D7943)
  {
    v11 = 0x1AF286BCA1AF286;
  }

  else
  {
    v11 = v10;
  }

  v12 = geo::codec::zone_mallocator::instance(a1);
  v13 = pthread_rwlock_rdlock((v12 + 32));
  if (v13)
  {
    geo::read_write_lock::logFailure(v13, "read lock", v14);
  }

  v15 = malloc_type_zone_malloc(*v12, 152 * v11, 0x10300405004E887uLL);
  atomic_fetch_add((v12 + 24), 1u);
  v16 = pthread_rwlock_unlock((v12 + 32));
  if (v16)
  {
    geo::read_write_lock::logFailure(v16, "unlock", v17);
  }

  v18 = &v15[v5];
  v19 = &v15[152 * v11];
  bzero(v18, 152 * ((152 * v7 - 152) / 0x98) + 152);
  v21 = &v18[152 * ((152 * v7 - 152) / 0x98) + 152];
  v22 = *a1;
  v23 = *(a1 + 1);
  v24 = &v18[*a1 - v23];
  if (v23 != *a1)
  {
    v25 = 0;
    do
    {
      v26 = &v24[v25];
      v27 = (v22 + v25);
      *v26 = 0;
      *(v26 + 1) = 0;
      *(v26 + 2) = 0;
      v26[24] = *(v22 + v25 + 24);
      *v26 = *(v22 + v25);
      *(v26 + 2) = *(v22 + v25 + 16);
      *v27 = 0;
      v27[1] = 0;
      v27[2] = 0;
      *(v26 + 4) = 0;
      *(v26 + 5) = 0;
      *(v26 + 6) = 0;
      v26[56] = *(v22 + v25 + 56);
      *(v26 + 2) = *(v22 + v25 + 32);
      *(v26 + 6) = *(v22 + v25 + 48);
      v27[4] = 0;
      v27[5] = 0;
      v27[6] = 0;
      *(v26 + 8) = 0;
      *(v26 + 9) = 0;
      *(v26 + 10) = 0;
      v26[88] = *(v22 + v25 + 88);
      *(v26 + 4) = *(v22 + v25 + 64);
      *(v26 + 10) = *(v22 + v25 + 80);
      v27[8] = 0;
      v27[9] = 0;
      v27[10] = 0;
      *(v26 + 12) = 0;
      *(v26 + 13) = 0;
      *(v26 + 14) = 0;
      v26[120] = *(v22 + v25 + 120);
      *(v26 + 6) = *(v22 + v25 + 96);
      *(v26 + 14) = *(v22 + v25 + 112);
      v27[12] = 0;
      v27[13] = 0;
      v27[14] = 0;
      v28 = *(v22 + v25 + 128);
      *(v26 + 18) = *(v22 + v25 + 144);
      *(v26 + 8) = v28;
      v25 += 152;
    }

    while ((v22 + v25) != v23);
    do
    {
      geo::codec::Mesh::~Mesh(v22);
      v22 = (v22 + 152);
    }

    while (v22 != v23);
    v22 = *a1;
  }

  *a1 = v24;
  *(a1 + 1) = v21;
  *(a1 + 2) = v19;
  if (v22)
  {
    v29 = geo::codec::zone_mallocator::instance(v20);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::Mesh>(v29, v22);
  }
}

void sub_1B3359FDC(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>::reserve(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  if (a2 > (*(a1 + 2) - *a1) >> 1)
  {
    v3 = *(a1 + 1) - *a1;
    v5 = geo::codec::zone_mallocator::instance(a1);
    v6 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<unsigned short>(v5, a2);
    v7 = &v6[v3];
    v8 = &v6[2 * a2];
    v9 = *(a1 + 1) - *a1;
    v10 = &v6[v3 - v9];
    v11 = memcpy(v10, *a1, v9);
    v12 = *a1;
    *a1 = v10;
    *(a1 + 1) = v7;
    *(a1 + 2) = v8;
    if (v12)
    {
      v13 = geo::codec::zone_mallocator::instance(v11);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v13, v12);
    }
  }
}

unint64_t buildLocalTransformMatrix(float *a1, uint64_t *a2, unsigned int a3, void *a4, void *a5, __int128 *a6, char a7)
{
  result = 0;
  v10 = a6[1];
  v124 = *a6;
  v125 = v10;
  v11 = a6[3];
  v126 = a6[2];
  v127 = v11;
  if (!a5 || 0x8E38E38E38E38E39 * ((a4[1] - *a4) >> 4) < a3)
  {
    return result;
  }

  v13 = *a4 + 144 * a3;
  if (*(v13 + 138))
  {
    v15 = *(v13 + 112);
    v14 = *(v13 + 116);
    v16 = v15 + v15;
    v17 = (v15 + v15) * v15;
    v18 = (v14 + v14) * v14;
    v20 = *(v13 + 104);
    v19 = *(v13 + 108);
    v21 = (v19 + v19) * v15;
    v22 = *(v13 + 120);
    v23 = *(v13 + 124);
    v24 = (v14 + v14) * v22;
    v25 = v21 - v24;
    v26 = v14 * (v19 + v19);
    *v122 = 1.0 - (v17 + v18);
    *&v122[4] = v24 + v21;
    v27 = 1.0 - ((v19 + v19) * v19);
    *&v122[16] = v25;
    *&v122[20] = v27 - v18;
    v28 = v22 * v16;
    v29 = (v22 * v16) + v26;
    v30 = v16 * v14;
    v31 = v22 * (v19 + v19);
    *&v122[32] = v29;
    *&v122[36] = v30 - v31;
    *&v122[8] = COERCE_UNSIGNED_INT(v26 - v28);
    *&v122[24] = v31 + v30;
    *&v122[40] = v27 - v17;
    *&v122[28] = 0;
    *&v122[44] = 0;
    v32 = *(v13 + 96);
    *&v122[56] = v20;
    *&v122[48] = v32;
    *&v122[60] = 1065353216;
    v130 = 0u;
    v131 = 0u;
    v132 = 0;
    v129 = 0u;
    v133 = 1065353216;
    v33 = *(v13 + 128);
    v34 = *(v13 + 132);
    v128 = v23;
    LODWORD(v130) = v33;
    DWORD1(v131) = v34;
    gm::operator*<float,4,4,4>(v123, v122, &v128);
    result = gm::operator*<float,4,4,4>(v122, &v124, v123);
    v124 = *v122;
    v125 = *&v122[16];
    v126 = *&v122[32];
    v127 = *&v122[48];
LABEL_7:
    v36 = *v13;
    v37 = *(v13 + 8);
    if (*v13 != v37)
    {
      do
      {
        v38 = *v36++;
        *v122 = v38;
        *&v122[4] = v124;
        *&v122[20] = v125;
        *&v122[36] = v126;
        *&v122[52] = v127;
        std::__hash_table<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,geo::codec::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::pair<unsigned short const,gm::Matrix<float,4,4>>>(a1, v38, v122);
      }

      while (v36 != v37);
    }

    v39 = *(v13 + 32);
    v116 = *(v13 + 40);
    if (v39 != v116)
    {
      v119 = a1;
      v120 = a2 + 3;
      do
      {
        v118 = v39;
        v40 = *a5 + 32 * *v39;
        v42 = *v40;
        v41 = *(v40 + 8);
        v121 = v41;
        while (v42 != v41)
        {
          v43 = *v42;
          if ((*(v13 + 138) & 8) == 0)
          {
            *v122 = *v42;
            *&v122[4] = v124;
            *&v122[20] = v125;
            *&v122[36] = v126;
            *&v122[52] = v127;
            std::__hash_table<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,geo::codec::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::pair<unsigned short const,gm::Matrix<float,4,4>>>(a1, v43, v122);
            goto LABEL_14;
          }

          v44 = a2[1];
          if (v44)
          {
            v45 = vcnt_s8(v44);
            v45.i16[0] = vaddlv_u8(v45);
            if (v45.u32[0] > 1uLL)
            {
              v7 = *v42;
              if (v44 <= v43)
              {
                v7 = v43 % a2[1];
              }
            }

            else
            {
              v7 = (v44 - 1) & v43;
            }

            v46 = *(*a2 + 8 * v7);
            if (v46)
            {
              v47 = *v46;
              if (*v46)
              {
                if (v45.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    v49 = v47[1];
                    if (v49 == v43)
                    {
                      if (*(v47 + 8) == v43)
                      {
                        goto LABEL_96;
                      }
                    }

                    else if ((v49 & (v44 - 1)) != v7)
                    {
                      goto LABEL_38;
                    }

                    v47 = *v47;
                    if (!v47)
                    {
                      goto LABEL_38;
                    }
                  }
                }

                do
                {
                  v48 = v47[1];
                  if (v48 == v43)
                  {
                    if (*(v47 + 8) == v43)
                    {
                      goto LABEL_96;
                    }
                  }

                  else
                  {
                    if (v48 >= v44)
                    {
                      v48 %= v44;
                    }

                    if (v48 != v7)
                    {
                      break;
                    }
                  }

                  v47 = *v47;
                }

                while (v47);
              }
            }
          }

LABEL_38:
          v50 = geo::codec::zone_mallocator::instance(result);
          v51 = pthread_rwlock_rdlock((v50 + 32));
          if (v51)
          {
            geo::read_write_lock::logFailure(v51, "read lock", v52);
          }

          v47 = malloc_type_zone_malloc(*v50, 0x38uLL, 0x1020040B4F0FE30uLL);
          atomic_fetch_add((v50 + 24), 1u);
          result = pthread_rwlock_unlock((v50 + 32));
          if (result)
          {
            geo::read_write_lock::logFailure(result, "unlock", v53);
          }

          *v47 = 0;
          v47[1] = v43;
          *(v47 + 8) = v43;
          v47[3] = 0;
          v47[4] = 0;
          v47[5] = 0;
          v54 = (a2[5] + 1);
          v55 = *(a2 + 12);
          if (!v44 || (v55 * v44) < v54)
          {
            v56 = (v44 & (v44 - 1)) != 0;
            if (v44 < 3)
            {
              v56 = 1;
            }

            v57 = v56 | (2 * v44);
            v58 = vcvtps_u32_f32(v54 / v55);
            if (v57 <= v58)
            {
              v59 = v58;
            }

            else
            {
              v59 = v57;
            }

            if (v59 == 1)
            {
              v59 = 2;
            }

            else if ((v59 & (v59 - 1)) != 0)
            {
              result = std::__next_prime(v59);
              v59 = result;
            }

            v44 = a2[1];
            if (v59 <= v44)
            {
              if (v59 < v44)
              {
                result = vcvtps_u32_f32(a2[5] / *(a2 + 12));
                if (v44 < 3 || (v74 = vcnt_s8(v44), v74.i16[0] = vaddlv_u8(v74), v74.u32[0] > 1uLL))
                {
                  result = std::__next_prime(result);
                }

                else
                {
                  v75 = 1 << -__clz(result - 1);
                  if (result >= 2)
                  {
                    result = v75;
                  }
                }

                if (v59 <= result)
                {
                  v59 = result;
                }

                if (v59 >= v44)
                {
                  v44 = a2[1];
                }

                else
                {
                  if (v59)
                  {
                    goto LABEL_54;
                  }

                  v109 = *a2;
                  *a2 = 0;
                  if (v109)
                  {
                    v110 = geo::codec::zone_mallocator::instance(result);
                    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *> *> *>(v110, v109);
                  }

                  v44 = 0;
                  a2[1] = 0;
                }
              }

LABEL_79:
              if ((v44 & (v44 - 1)) != 0)
              {
                if (v44 <= v43)
                {
                  v7 = v43 % v44;
                }

                else
                {
                  v7 = v43;
                }
              }

              else
              {
                v7 = (v44 - 1) & v43;
              }

              goto LABEL_92;
            }

LABEL_54:
            v60 = geo::codec::zone_mallocator::instance(result);
            v61 = pthread_rwlock_rdlock((v60 + 32));
            if (v61)
            {
              geo::read_write_lock::logFailure(v61, "read lock", v62);
            }

            v63 = malloc_type_zone_malloc(*v60, 8 * v59, 0x2004093837F09uLL);
            atomic_fetch_add((v60 + 24), 1u);
            v64 = pthread_rwlock_unlock((v60 + 32));
            if (v64)
            {
              geo::read_write_lock::logFailure(v64, "unlock", v65);
            }

            v66 = *a2;
            *a2 = v63;
            if (v66)
            {
              v67 = geo::codec::zone_mallocator::instance(v64);
              geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *> *> *>(v67, v66);
              v63 = *a2;
            }

            a2[1] = v59;
            bzero(v63, 8 * v59);
            v68 = a2[3];
            if (!v68)
            {
              goto LABEL_78;
            }

            v69 = v68[1];
            v70 = v59 - 1;
            if ((v59 & (v59 - 1)) == 0)
            {
              v71 = v69 & v70;
              *(v63 + v71) = v120;
              while (1)
              {
                v72 = *v68;
                if (!*v68)
                {
                  break;
                }

                v73 = v72[1] & v70;
                if (v73 == v71)
                {
                  v68 = *v68;
                }

                else if (*(v63 + v73))
                {
                  *v68 = *v72;
                  *v72 = **(v63 + v73);
                  **(v63 + v73) = v72;
                }

                else
                {
                  *(v63 + v73) = v68;
                  v68 = v72;
                  v71 = v73;
                }
              }

              goto LABEL_78;
            }

            if (v69 >= v59)
            {
              v69 %= v59;
            }

            *(v63 + v69) = v120;
            v76 = *v68;
            if (!*v68)
            {
LABEL_78:
              v44 = v59;
              a1 = v119;
              goto LABEL_79;
            }

            while (2)
            {
              v77 = v76[1];
              if (v77 >= v59)
              {
                v77 %= v59;
              }

              if (v77 != v69)
              {
                if (!*(v63 + v77))
                {
                  *(v63 + v77) = v68;
LABEL_83:
                  v68 = v76;
                  v76 = *v76;
                  v69 = v77;
                  if (!v76)
                  {
                    goto LABEL_78;
                  }

                  continue;
                }

                *v68 = *v76;
                *v76 = **(v63 + v77);
                **(v63 + v77) = v76;
                v76 = v68;
              }

              break;
            }

            v77 = v69;
            goto LABEL_83;
          }

LABEL_92:
          v78 = *a2;
          v79 = *(*a2 + 8 * v7);
          if (v79)
          {
            *v47 = *v79;
LABEL_94:
            *v79 = v47;
            goto LABEL_95;
          }

          *v47 = *v120;
          *v120 = v47;
          *(v78 + 8 * v7) = v120;
          if (*v47)
          {
            v95 = *(*v47 + 8);
            if ((v44 & (v44 - 1)) != 0)
            {
              if (v95 >= v44)
              {
                v95 %= v44;
              }

              v79 = (v78 + 8 * v95);
            }

            else
            {
              v79 = (v78 + 8 * (v95 & (v44 - 1)));
            }

            goto LABEL_94;
          }

LABEL_95:
          ++a2[5];
LABEL_96:
          v80 = v47[4];
          v81 = v47[5];
          if (v80 >= v81)
          {
            v86 = v47[3];
            v87 = 0xF0F0F0F0F0F0F0F1 * ((v80 - v86) >> 2);
            v88 = v87 + 1;
            if (v87 + 1 > 0x3C3C3C3C3C3C3C3)
            {
              std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
            }

            v89 = 0xF0F0F0F0F0F0F0F1 * ((v81 - v86) >> 2);
            if (2 * v89 > v88)
            {
              v88 = 2 * v89;
            }

            if (v89 >= 0x1E1E1E1E1E1E1E1)
            {
              v7 = 0x3C3C3C3C3C3C3C3;
            }

            else
            {
              v7 = v88;
            }

            if (v7)
            {
              v90 = geo::codec::zone_mallocator::instance(result);
              v91 = pthread_rwlock_rdlock((v90 + 32));
              if (v91)
              {
                geo::read_write_lock::logFailure(v91, "read lock", v92);
              }

              v93 = malloc_type_zone_malloc(*v90, 68 * v7, 0x100004018969BB4uLL);
              atomic_fetch_add((v90 + 24), 1u);
              result = pthread_rwlock_unlock((v90 + 32));
              if (result)
              {
                geo::read_write_lock::logFailure(result, "unlock", v94);
              }
            }

            else
            {
              v93 = 0;
            }

            v96 = &v93[68 * v87];
            v97 = *(v13 + 136);
            v98 = v127;
            *(v96 + 2) = v126;
            *(v96 + 3) = v98;
            v99 = v125;
            *v96 = v124;
            *(v96 + 1) = v99;
            *(v96 + 32) = v97;
            v101 = v47[3];
            v100 = v47[4];
            v102 = &v96[v101 - v100];
            if (v101 != v100)
            {
              v103 = &v96[v101 - v100];
              do
              {
                *v103 = *v101;
                v104 = v101[1];
                v105 = v101[2];
                v106 = v101[3];
                *(v103 + 16) = *(v101 + 16);
                *(v103 + 2) = v105;
                *(v103 + 3) = v106;
                *(v103 + 1) = v104;
                v101 = (v101 + 68);
                v103 += 68;
              }

              while (v101 != v100);
              v101 = v47[3];
            }

            v107 = &v93[68 * v7];
            v85 = v96 + 68;
            v47[3] = v102;
            v47[4] = v96 + 68;
            v47[5] = v107;
            if (v101)
            {
              v108 = geo::codec::zone_mallocator::instance(result);
              geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::DynamicTransform>(v108, v101);
            }
          }

          else
          {
            v82 = *(v13 + 136);
            v83 = v125;
            *v80 = v124;
            *(v80 + 16) = v83;
            v84 = v127;
            *(v80 + 32) = v126;
            *(v80 + 48) = v84;
            *(v80 + 64) = v82;
            v85 = (v80 + 68);
          }

          v47[4] = v85;
LABEL_14:
          ++v42;
          v41 = v121;
        }

        v39 = v118 + 1;
      }

      while (v118 + 1 != v116);
    }

    v35 = 0;
    goto LABEL_133;
  }

  if ((a7 & 1) == 0)
  {
    goto LABEL_7;
  }

  v35 = 1;
LABEL_133:
  v111 = *(v13 + 64);
  v112 = *(v13 + 72);
  if (v111 == v112)
  {
    return 1;
  }

  v113 = v111 + 2;
  do
  {
    result = buildLocalTransformMatrix(a1, a2, *(v113 - 2), a4, a5, &v124, v35);
    if (result)
    {
      v114 = v113 == v112;
    }

    else
    {
      v114 = 1;
    }

    v113 += 2;
  }

  while (!v114);
  return result;
}

void sub_1B335A9E4(_Unwind_Exception *a1)
{
  v5 = pthread_rwlock_unlock((v1 + 32));
  if (v5)
  {
    geo::read_write_lock::logFailure(v5, "unlock", v6);
  }

  v7 = *v2;
  if (*v2)
  {
    v3[4] = v7;
    v8 = geo::codec::zone_mallocator::instance(v5);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::DynamicTransform>(v8, v7);
  }

  v9 = geo::codec::zone_mallocator::instance(v5);
  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *>>(v9, v3);
  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335AB14(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *> *> *>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335ABC4(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,geo::allocator_adapter<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,geo::codec::zone_mallocator>>::__emplace_unique_key_args<unsigned short,std::pair<unsigned short const,gm::Matrix<float,4,4>>>(float *a1, unsigned __int16 a2, uint64_t a3)
{
  v6 = a2;
  v7 = *(a1 + 1);
  if (v7)
  {
    v8 = vcnt_s8(v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
      {
        v3 = a2 % *(a1 + 1);
      }
    }

    else
    {
      v3 = (v7 - 1) & a2;
    }

    v9 = *(*a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            v11 = v10[1];
            if (v11 == a2)
            {
              if (*(v10 + 8) == a2)
              {
                return;
              }
            }

            else if ((v11 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }

            v10 = *v10;
            if (!v10)
            {
              goto LABEL_22;
            }
          }
        }

        do
        {
          v12 = v10[1];
          if (v12 == a2)
          {
            if (*(v10 + 8) == a2)
            {
              return;
            }
          }

          else
          {
            if (v12 >= v7)
            {
              v12 %= v7;
            }

            if (v12 != v3)
            {
              break;
            }
          }

          v10 = *v10;
        }

        while (v10);
      }
    }
  }

LABEL_22:
  v13 = geo::codec::zone_mallocator::instance(a1);
  v14 = pthread_rwlock_rdlock((v13 + 32));
  if (v14)
  {
    geo::read_write_lock::logFailure(v14, "read lock", v15);
  }

  v16 = malloc_type_zone_malloc(*v13, 0x58uLL, 0x1020040120D7901uLL);
  atomic_fetch_add((v13 + 24), 1u);
  prime = pthread_rwlock_unlock((v13 + 32));
  if (prime)
  {
    geo::read_write_lock::logFailure(prime, "unlock", v18);
  }

  *v16 = 0;
  v16[1] = v6;
  *(v16 + 1) = *a3;
  v19 = *(a3 + 16);
  v20 = *(a3 + 32);
  v21 = *(a3 + 48);
  *(v16 + 20) = *(a3 + 64);
  *(v16 + 3) = v20;
  *(v16 + 4) = v21;
  *(v16 + 2) = v19;
  v22 = (*(a1 + 5) + 1);
  v23 = a1[12];
  if (!v7 || (v23 * v7) < v22)
  {
    v24 = 1;
    if (v7 >= 3)
    {
      v24 = (v7 & (v7 - 1)) != 0;
    }

    v25 = v24 | (2 * v7);
    v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26)
    {
      v27 = v26;
    }

    else
    {
      v27 = v25;
    }

    if (v27 == 1)
    {
      v27 = 2;
    }

    else if ((v27 & (v27 - 1)) != 0)
    {
      prime = std::__next_prime(v27);
      v27 = prime;
    }

    v7 = *(a1 + 1);
    if (v27 <= v7)
    {
      if (v27 >= v7)
      {
        goto LABEL_64;
      }

      prime = vcvtps_u32_f32(*(a1 + 5) / a1[12]);
      if (v7 < 3 || (v43 = vcnt_s8(v7), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        prime = std::__next_prime(prime);
      }

      else
      {
        v44 = 1 << -__clz(prime - 1);
        if (prime >= 2)
        {
          prime = v44;
        }
      }

      if (v27 <= prime)
      {
        v27 = prime;
      }

      if (v27 >= v7)
      {
        v7 = *(a1 + 1);
LABEL_64:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6)
          {
            v3 = v6 % v7;
          }

          else
          {
            v3 = v6;
          }
        }

        else
        {
          v3 = (v7 - 1) & v6;
        }

        goto LABEL_77;
      }

      if (!v27)
      {
        v50 = *a1;
        *a1 = 0;
        if (v50)
        {
          v51 = geo::codec::zone_mallocator::instance(prime);
          geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *> *> *>(v51, v50);
        }

        v7 = 0;
        *(a1 + 1) = 0;
        goto LABEL_64;
      }
    }

    v28 = geo::codec::zone_mallocator::instance(prime);
    v29 = pthread_rwlock_rdlock((v28 + 32));
    if (v29)
    {
      geo::read_write_lock::logFailure(v29, "read lock", v30);
    }

    v31 = malloc_type_zone_malloc(*v28, 8 * v27, 0x2004093837F09uLL);
    atomic_fetch_add((v28 + 24), 1u);
    v32 = pthread_rwlock_unlock((v28 + 32));
    if (v32)
    {
      geo::read_write_lock::logFailure(v32, "unlock", v33);
    }

    v34 = *a1;
    *a1 = v31;
    if (v34)
    {
      v35 = geo::codec::zone_mallocator::instance(v32);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *> *> *>(v35, v34);
      v31 = *a1;
    }

    *(a1 + 1) = v27;
    bzero(v31, 8 * v27);
    v37 = (a1 + 6);
    v36 = *(a1 + 3);
    if (!v36)
    {
LABEL_63:
      v7 = v27;
      goto LABEL_64;
    }

    v38 = v36[1];
    v39 = v27 - 1;
    if ((v27 & (v27 - 1)) == 0)
    {
      v40 = v38 & v39;
      v31[v40] = v37;
      for (i = *v36; *v36; i = *v36)
      {
        v42 = i[1] & v39;
        if (v42 == v40)
        {
          v36 = i;
        }

        else if (v31[v42])
        {
          *v36 = *i;
          *i = *v31[v42];
          *v31[v42] = i;
        }

        else
        {
          v31[v42] = v36;
          v36 = i;
          v40 = v42;
        }
      }

      goto LABEL_63;
    }

    if (v38 >= v27)
    {
      v38 %= v27;
    }

    v31[v38] = v37;
    v45 = *v36;
    if (!*v36)
    {
      goto LABEL_63;
    }

    while (1)
    {
      v46 = v45[1];
      if (v46 >= v27)
      {
        v46 %= v27;
      }

      if (v46 != v38)
      {
        if (!v31[v46])
        {
          v31[v46] = v36;
          goto LABEL_68;
        }

        *v36 = *v45;
        *v45 = *v31[v46];
        *v31[v46] = v45;
        v45 = v36;
      }

      v46 = v38;
LABEL_68:
      v36 = v45;
      v45 = *v45;
      v38 = v46;
      if (!v45)
      {
        goto LABEL_63;
      }
    }
  }

LABEL_77:
  v47 = *a1;
  v48 = *(*a1 + 8 * v3);
  if (v48)
  {
    *v16 = *v48;
  }

  else
  {
    *v16 = *(a1 + 3);
    *(a1 + 3) = v16;
    v47[v3] = a1 + 6;
    if (!*v16)
    {
      goto LABEL_80;
    }

    v49 = *(*v16 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v49 >= v7)
      {
        v49 %= v7;
      }

      v48 = &v47[v49];
    }

    else
    {
      v48 = &v47[v49 & (v7 - 1)];
    }
  }

  *v48 = v16;
LABEL_80:
  ++*(a1 + 5);
}

void sub_1B335B0EC(_Unwind_Exception *a1)
{
  v4 = pthread_rwlock_unlock((v2 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "unlock", v5);
  }

  v6 = geo::codec::zone_mallocator::instance(v4);
  geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,gm::Matrix<float,4,4>>,void *>>(v6, v1);
  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::DynamicTransform>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335B1E0(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335B290(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *> *> *>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335B340(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 32 * a2, 0x10040E578F389uLL);
  atomic_fetch_add((a1 + 24), 1u);
  v7 = pthread_rwlock_unlock((a1 + 32));
  if (v7)
  {
    geo::read_write_lock::logFailure(v7, "unlock", v8);
  }

  return v6;
}

void sub_1B335B3F0(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

geo::codec::zone_mallocator *std::__split_buffer<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator> &>::~__split_buffer(geo::codec::zone_mallocator *a1)
{
  v3 = *(a1 + 1);
  for (i = *(a1 + 2); i != v3; i = *(a1 + 2))
  {
    while (1)
    {
      v4 = i - 32;
      v5 = *(i - 32);
      *(a1 + 2) = i - 32;
      if (v5)
      {
        break;
      }

      i -= 32;
      if (v4 == v3)
      {
        goto LABEL_6;
      }
    }

    *(i - 24) = v5;
    v6 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v6, v5);
  }

LABEL_6:
  v7 = *a1;
  if (*a1)
  {
    v8 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>>(v8, v7);
  }

  return a1;
}

void geo::codec::Mesh::~Mesh(geo::codec::Mesh *this)
{
  v2 = *(this + 12);
  if (v2)
  {
    *(this + 13) = v2;
    v3 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v3, v2);
  }

  v4 = *(this + 8);
  if (v4)
  {
    *(this + 9) = v4;
    v5 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,2,1>>(v5, v4);
  }

  v6 = *(this + 4);
  if (v6)
  {
    *(this + 5) = v6;
    v7 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,3,1>>(v7, v6);
  }

  v8 = *this;
  if (*this)
  {
    *(this + 1) = v8;
    v9 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,3,1>>(v9, v8);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::Mesh>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335B5C8(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::codec::ModelNode::~ModelNode(geo::codec::ModelNode *this)
{
  v2 = *(this + 8);
  if (v2)
  {
    *(this + 9) = v2;
    v3 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v3, v2);
  }

  v4 = *(this + 4);
  if (v4)
  {
    *(this + 5) = v4;
    v5 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v5, v4);
  }

  v6 = *this;
  if (*this)
  {
    *(this + 1) = v6;
    v7 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v7, v6);
  }
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::ModelNode>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  if (a2)
  {
    atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  }

  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335B6F4(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::codec::AssetLodInstance::~AssetLodInstance(geo::codec::AssetLodInstance *this)
{
  v2 = *(this + 48);
  if (v2)
  {
    *(this + 49) = v2;
    v3 = geo::codec::zone_mallocator::instance(this);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned int>(v3, v2);
  }

  v4 = std::vector<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator>>::~vector[abi:ne200100]((this + 352));
  v5 = *(this + 40);
  if (v5)
  {
    *(this + 41) = v5;
    v6 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,2,1>>(v6, v5);
  }

  v7 = *(this + 36);
  if (v7)
  {
    *(this + 37) = v7;
    v8 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,3,1>>(v8, v7);
  }

  v9 = *(this + 32);
  if (v9)
  {
    v10 = *(this + 33);
    v11 = *(this + 32);
    if (v10 != v9)
    {
      do
      {
        geo::codec::Mesh::~Mesh((v10 - 152));
      }

      while (v10 != v9);
      v11 = *(this + 32);
    }

    *(this + 33) = v9;
    v12 = geo::codec::zone_mallocator::instance(v10);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::Mesh>(v12, v11);
  }

  v13 = *(this + 28);
  if (v13)
  {
    *(this + 29) = v13;
    v14 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v14, v13);
  }

  v15 = *(this + 24);
  if (v15)
  {
    *(this + 25) = v15;
    v16 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,3,1>>(v16, v15);
  }

  v17 = *(this + 20);
  if (v17)
  {
    *(this + 21) = v17;
    v18 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<unsigned short>(v18, v17);
  }

  v19 = *(this + 16);
  if (v19)
  {
    v20 = *(this + 17);
    v21 = *(this + 16);
    if (v20 != v19)
    {
      do
      {
        geo::codec::ModelNode::~ModelNode((v20 - 144));
      }

      while (v20 != v19);
      v21 = *(this + 16);
    }

    *(this + 17) = v19;
    v22 = geo::codec::zone_mallocator::instance(v20);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::ModelNode>(v22, v21);
  }

  for (i = *(this + 12); i; i = v24)
  {
    v24 = *i;
    v25 = i[3];
    if (v25)
    {
      i[4] = v25;
      v26 = geo::codec::zone_mallocator::instance(v4);
      geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<geo::codec::DynamicTransform>(v26, v25);
    }

    v27 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *>>(v27, i);
  }

  v28 = *(this + 9);
  *(this + 9) = 0;
  if (v28)
  {
    v29 = geo::codec::zone_mallocator::instance(v4);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned short,std::vector<geo::codec::DynamicTransform,geo::allocator_adapter<geo::codec::DynamicTransform,geo::codec::zone_mallocator>>>,void *> *> *>(v29, v28);
  }

  v30 = *(this + 6);
  if (v30)
  {
    do
    {
      v32 = *v30;
      v33 = v30[5];
      if (v33)
      {
        do
        {
          v34 = *v33;
          operator delete(v33);
          v33 = v34;
        }

        while (v34);
      }

      v35 = v30[3];
      v30[3] = 0;
      if (v35)
      {
        operator delete(v35);
      }

      operator delete(v30);
      v30 = v32;
    }

    while (v32);
  }

  v31 = *(this + 4);
  *(this + 4) = 0;
  if (v31)
  {
    operator delete(v31);
  }

  std::vector<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::allocator_adapter<std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>,geo::codec::zone_mallocator>>::~vector[abi:ne200100](this);
}

void *geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<std::shared_ptr<geo::codec::AssetLodInstance>>(uint64_t a1, uint64_t a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  v6 = malloc_type_zone_malloc(*a1, 16 * a2, 0x20040A4A59CD2uLL);
  atomic_fetch_add((a1 + 24), 1u);
  v7 = pthread_rwlock_unlock((a1 + 32));
  if (v7)
  {
    geo::read_write_lock::logFailure(v7, "unlock", v8);
  }

  return v6;
}

void sub_1B335B9C4(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::shared_ptr<geo::codec::AssetLodInstance>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335BA74(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<geo::codec::AssetLodInstance  *>::__get_deleter(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 8);
  if (v2 != "NSt3__114default_deleteIN3geo5codec16AssetLodInstanceEEE")
  {
    if (((v2 & "NSt3__114default_deleteIN3geo5codec16AssetLodInstanceEEE" & 0x8000000000000000) != 0) == __OFSUB__(v2, "NSt3__114default_deleteIN3geo5codec16AssetLodInstanceEEE"))
    {
      return 0;
    }

    v3 = result;
    v4 = strcmp((v2 & 0x7FFFFFFFFFFFFFFFLL), ("NSt3__114default_deleteIN3geo5codec16AssetLodInstanceEEE" & 0x7FFFFFFFFFFFFFFFLL));
    result = v3;
    if (v4)
    {
      return 0;
    }
  }

  return result;
}

geo::codec::AssetLodInstance *std::__shared_ptr_pointer<geo::codec::AssetLodInstance  *>::__on_zero_shared(uint64_t a1)
{
  result = *(a1 + 24);
  if (result)
  {
    geo::codec::AssetLodInstance::~AssetLodInstance(result);

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void std::__shared_ptr_pointer<geo::codec::AssetLodInstance  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void std::vector<VertexFormat,geo::allocator_adapter<VertexFormat,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v3 = *a1;
  v4 = *(a1 + 1);
  v5 = v4 - *a1;
  v6 = a2 - (v5 >> 3);
  if (a2 <= v5 >> 3)
  {
    if (a2 >= v5 >> 3)
    {
      return;
    }

    v26 = v3 + 8 * a2;
    goto LABEL_18;
  }

  v7 = *(a1 + 2);
  if (v6 <= (v7 - v4) >> 3)
  {
    bzero(*(a1 + 1), 8 * v6);
    v26 = v4 + 8 * v6;
LABEL_18:
    *(a1 + 1) = v26;
    return;
  }

  if (a2 >> 61)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v8 = v7 - v3;
  v9 = v8 >> 2;
  if (v8 >> 2 <= a2)
  {
    v9 = a2;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFF8)
  {
    v10 = 0x1FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v9;
  }

  v11 = geo::codec::zone_mallocator::instance(a1);
  v12 = pthread_rwlock_rdlock((v11 + 32));
  if (v12)
  {
    geo::read_write_lock::logFailure(v12, "read lock", v13);
  }

  v14 = malloc_type_zone_malloc(*v11, 8 * v10, 0x100004000313F17uLL);
  atomic_fetch_add((v11 + 24), 1u);
  v15 = pthread_rwlock_unlock((v11 + 32));
  if (v15)
  {
    geo::read_write_lock::logFailure(v15, "unlock", v16);
  }

  v17 = &v14[v5];
  v18 = 8 * v6;
  v19 = &v14[8 * v10];
  bzero(v17, v18);
  v20 = &v17[v18];
  v21 = *(a1 + 1) - *a1;
  v22 = &v17[-v21];
  v23 = memcpy(&v17[-v21], *a1, v21);
  v24 = *a1;
  *a1 = v22;
  *(a1 + 1) = v20;
  *(a1 + 2) = v19;
  if (v24)
  {
    v25 = geo::codec::zone_mallocator::instance(v23);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<VertexFormat>(v25, v24);
  }
}

void sub_1B335BCD8(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

uint64_t buildAssetMesh(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5 = *(a1 + 24);
  v6 = *(a1 + 24) != 0;
  v7 = a1[1];
  v8 = a1[2];
  v9 = v8 + 2;
  if (!*(a1 + 24))
  {
    v9 = v8 + 1;
  }

  if (v7 < v9)
  {
    v10 = *MEMORY[0x1E69E9848];
LABEL_5:
    fprintf(v10, "%s:%d Asset Parse: Read error\n");
    return 0;
  }

  v15 = v8 + 1;
  v16 = *a1;
  if (*(a1 + 24))
  {
    v17 = *(v16 + v8);
    if (v15 >= v7)
    {
      v18 = 0;
    }

    else
    {
      v18 = *(v16 + v15);
    }

    a1[2] = v15;
    v19 = ((v18 & (0xFFFF << (8 - v5))) >> (8 - v5)) | ((((1 << (8 - v5)) + 255) & v17) << v5);
    if (a2)
    {
      goto LABEL_15;
    }

LABEL_12:
    v20 = v8 + 1;
    goto LABEL_24;
  }

  LOBYTE(v19) = *(v16 + v8);
  a1[2] = v15;
  if (!a2)
  {
    goto LABEL_12;
  }

LABEL_15:
  v20 = v8 + 2;
  if (v7 < v20 + v6)
  {
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  if (v5)
  {
    v21 = *(v16 + v15);
    if (v20 >= v7)
    {
      v22 = 0;
    }

    else
    {
      v22 = *(v16 + v20);
    }

    a1[2] = v20;
    LODWORD(v15) = ((v22 & (0xFFFF << (8 - v5))) >> (8 - v5)) | ((((1 << (8 - v5)) + 255) & v21) << v5);
  }

  else
  {
    LOBYTE(v15) = *(v16 + v15);
    a1[2] = v20;
  }

  *(a3 + 128) = v15;
LABEL_24:
  v23 = v19;
  if (v19 >= ((a5 - a4) >> 3))
  {
    fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: vertex format index exceeds its range\n");
    return 0;
  }

  v24 = v20 + 4;
  if (v7 < v20 + 4 + v6)
  {
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  v25 = *a1;
  if (v5)
  {
    v26 = *(v25 + v20);
    v27 = v20 + 1;
    if (v20 + 1 >= v7)
    {
      v28 = 0;
    }

    else
    {
      v28 = *(v25 + v27);
    }

    a1[2] = v27;
    v37 = *(v25 + v27);
    v38 = v20 + 2;
    if (v20 + 2 >= v7)
    {
      v39 = 0;
    }

    else
    {
      v39 = *(v25 + v38);
    }

    a1[2] = v38;
    v40 = *(v25 + v38);
    v41 = v20 + 3;
    if (v41 >= v7)
    {
      v42 = 0;
    }

    else
    {
      v42 = *(v25 + v41);
    }

    a1[2] = v41;
    v43 = *(v25 + v41);
    if (v24 >= v7)
    {
      v44 = 0;
    }

    else
    {
      v44 = *(v25 + v24);
    }

    a1[2] = v24;
    v45 = v24 + 4;
    if (v7 < v24 + 4 + v6)
    {
      goto LABEL_48;
    }

    v46 = *a1;
    v47 = *(*a1 + v24);
    v48 = v24 + 1;
    if (v24 + 1 >= v7)
    {
      v49 = 0;
    }

    else
    {
      v49 = *(v46 + v48);
    }

    a1[2] = v48;
    v50 = *(v46 + v48);
    v51 = v24 + 2;
    if (v24 + 2 >= v7)
    {
      v52 = 0;
    }

    else
    {
      v52 = *(v46 + v51);
    }

    a1[2] = v51;
    v53 = *(v46 + v51);
    v54 = v24 + 3;
    if (v54 >= v7)
    {
      v55 = 0;
    }

    else
    {
      v55 = *(v46 + v54);
    }

    a1[2] = v54;
    v56 = *(v46 + v54);
    if (v45 >= v7)
    {
      v57 = 0;
    }

    else
    {
      v57 = *(v46 + v45);
    }

    a1[2] = v45;
    v58 = v45 + 4;
    if (v7 < v45 + 4 + v6)
    {
      goto LABEL_62;
    }

    v59 = *a1;
    v60 = *(*a1 + v45);
    v61 = v45 + 1;
    if (v45 + 1 >= v7)
    {
      v422 = 0;
    }

    else
    {
      v422 = *(v59 + v61);
    }

    a1[2] = v61;
    v414 = *(v59 + v61);
    v62 = v45 + 2;
    if (v45 + 2 >= v7)
    {
      v411 = 0;
    }

    else
    {
      v411 = *(v59 + v62);
    }

    a1[2] = v62;
    v63 = *(v59 + v62);
    v64 = v45 + 3;
    if (v64 >= v7)
    {
      v417 = 0;
    }

    else
    {
      v417 = *(v59 + v64);
    }

    a1[2] = v64;
    v65 = *(v59 + v64);
    if (v58 >= v7)
    {
      v416 = 0;
    }

    else
    {
      v416 = *(v59 + v58);
    }

    a1[2] = v58;
    v66 = v58 + 4;
    if (v7 < v58 + 4 + v6)
    {
      goto LABEL_76;
    }

    v409 = v65;
    v67 = (1 << (8 - v5)) + 255;
    v68 = 0xFFFF << (8 - v5);
    v69 = ((v28 & v68) >> (8 - v5)) | ((v67 & v26) << v5) | ((((v39 & v68) >> (8 - v5)) | ((v67 & v37) << v5)) << 8) & 0xFF00;
    v70 = 8 - v5;
    v29 = v69 | ((((v42 & v68) >> (8 - v5)) | ((v67 & v40) << v5)) << 16) & 0xFF0000 | ((((v44 & v68) >> (8 - v5)) | ((v67 & v43) << v5)) << 24);
    v31 = ((v49 & v68) >> (8 - v5)) | ((v67 & v47) << v5) | ((((v52 & v68) >> (8 - v5)) | ((v67 & v50) << v5)) << 8) & 0xFF00 | ((((v55 & v68) >> (8 - v5)) | ((v67 & v53) << v5)) << 16) & 0xFF0000 | ((((v57 & v68) >> (8 - v5)) | ((v67 & v56) << v5)) << 24);
    LODWORD(v421) = ((v422 & v68) >> v70) | ((v67 & v60) << v5) | ((((v411 & v68) >> v70) | ((v67 & v414) << v5)) << 8) & 0xFF00 | ((((v417 & v68) >> v70) | ((v67 & v63) << v5)) << 16) & 0xFF0000 | ((((v416 & v68) >> v70) | ((v67 & v409) << v5)) << 24);
    v71 = *a1;
    v72 = *(*a1 + v58);
    v73 = v58 + 1;
    if (v58 + 1 >= v7)
    {
      v74 = 0;
    }

    else
    {
      v74 = *(v71 + v73);
    }

    a1[2] = v73;
    v75 = *(v71 + v73);
    v76 = v58 + 2;
    if (v58 + 2 >= v7)
    {
      v77 = 0;
    }

    else
    {
      v77 = *(v71 + v76);
    }

    a1[2] = v76;
    v78 = *(v71 + v76);
    v79 = v58 + 3;
    if (v79 >= v7)
    {
      v80 = 0;
    }

    else
    {
      v80 = *(v71 + v79);
    }

    a1[2] = v79;
    v81 = *(v71 + v79);
    if (v66 >= v7)
    {
      v82 = 0;
    }

    else
    {
      v82 = *(v71 + v66);
    }

    a1[2] = v66;
    v83 = v66 + 4;
    if (v7 < v66 + 4 + v6)
    {
      goto LABEL_90;
    }

    v84 = *a1;
    v85 = *(*a1 + v66);
    v86 = v66 + 1;
    if (v66 + 1 >= v7)
    {
      v87 = 0;
    }

    else
    {
      v87 = *(v84 + v86);
    }

    a1[2] = v86;
    v88 = *(v84 + v86);
    v89 = v66 + 2;
    if (v66 + 2 >= v7)
    {
      v90 = 0;
    }

    else
    {
      v90 = *(v84 + v89);
    }

    a1[2] = v89;
    v91 = *(v84 + v89);
    v92 = v66 + 3;
    if (v92 >= v7)
    {
      v93 = 0;
    }

    else
    {
      v93 = *(v84 + v92);
    }

    a1[2] = v92;
    v94 = *(v84 + v92);
    if (v83 >= v7)
    {
      v95 = 0;
    }

    else
    {
      v95 = *(v84 + v83);
    }

    a1[2] = v83;
    if (v7 < v83 + 4 + v6)
    {
      goto LABEL_104;
    }

    v418 = v83 + 4;
    v96 = (1 << (8 - v5)) + 255;
    v97 = 0xFFFF << (8 - v5);
    v98 = ((v74 & v97) >> (8 - v5)) | ((v96 & v72) << v5);
    v99 = ((((v77 & v97) >> (8 - v5)) | ((v96 & v75) << v5)) << 8) & 0xFF00;
    v100 = (v82 & v97) >> (8 - v5);
    v101 = ((((v80 & v97) >> (8 - v5)) | ((v96 & v78) << v5)) << 16) & 0xFF0000;
    v102 = ((v87 & v97) >> (8 - v5)) | ((v96 & v85) << v5) | ((((v90 & v97) >> (8 - v5)) | ((v96 & v88) << v5)) << 8) & 0xFF00;
    v103 = ((((v93 & v97) >> (8 - v5)) | ((v96 & v91) << v5)) << 16) & 0xFF0000;
    v104 = *a1;
    v106 = *(*a1 + v83);
    v107 = v83 + 1;
    if (v83 + 1 >= v7)
    {
      v108 = 0;
    }

    else
    {
      v108 = *(v104 + v107);
    }

    v109 = v102 | v103;
    a1[2] = v107;
    v110 = ((v96 & v106) << v5);
    v111 = *(v104 + v107);
    v112 = v83 + 2;
    v36 = v83 + 4;
    if (v83 + 2 >= v7)
    {
      v113 = 0;
    }

    else
    {
      v113 = *(v104 + v112);
    }

    v114 = v98 | v99 | v101 | ((v100 | ((v96 & v81) << v5)) << 24);
    v115 = v109 | ((((v95 & v97) >> (8 - v5)) | ((v96 & v94) << v5)) << 24);
    a1[2] = v112;
    v116 = *(v104 + v112);
    v117 = v83 + 3;
    if (v117 >= v7)
    {
      v118 = 0;
    }

    else
    {
      v118 = *(v104 + v117);
    }

    v34 = *&v114;
    v415 = *&v115;
    a1[2] = v117;
    v119 = *(v104 + v117);
    if (v418 >= v7)
    {
      v120 = 0;
    }

    else
    {
      v120 = *(v104 + v418);
    }

    a1[2] = v418;
    v105 = 8 - v5;
    LODWORD(v413) = ((v108 & v97) >> v105) | v110 | ((((v113 & v97) >> v105) | ((v96 & v111) << v5)) << 8) & 0xFF00 | ((((v118 & v97) >> v105) | ((v96 & v116) << v5)) << 16) & 0xFF0000 | ((((v120 & v97) >> v105) | ((v96 & v119) << v5)) << 24);
  }

  else
  {
    v29 = *(v25 + v20);
    a1[2] = v24;
    v30 = v20 + 8;
    if (v7 < v24 + 4 + v6)
    {
LABEL_48:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v31 = *(*a1 + v24);
    a1[2] = v30;
    v32 = v24 + 8;
    if (v7 < v30 + 4 + v6)
    {
LABEL_62:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v421 = *(*a1 + v30);
    a1[2] = v32;
    v33 = v30 + 8;
    if (v7 < v32 + 4 + v6)
    {
LABEL_76:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v34 = *(*a1 + v32);
    a1[2] = v33;
    v35 = v32 + 8;
    if (v7 < v32 + 8 + v6)
    {
LABEL_90:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v415 = *(*a1 + v33);
    a1[2] = v35;
    v36 = v33 + 8;
    if (v7 < v33 + 8 + v6)
    {
LABEL_104:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v413 = *(*a1 + v35);
    a1[2] = v36;
  }

  v121 = (a4 + 8 * v23);
  v122 = *v121;
  if ((*v121 & 8) != 0)
  {
    v123 = v36 + 4;
    if (v7 < v36 + 4 + v6)
    {
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v124 = *a1;
    if (v5)
    {
      v125 = *(v124 + v36);
      v126 = v36 + 1;
      if (v36 + 1 >= v7)
      {
        v127 = 0;
      }

      else
      {
        v127 = *(v124 + v126);
      }

      a1[2] = v126;
      v128 = *(v124 + v126);
      v129 = v36 + 2;
      if (v36 + 2 >= v7)
      {
        v130 = 0;
      }

      else
      {
        v130 = *(v124 + v129);
      }

      a1[2] = v129;
      v131 = *(v124 + v129);
      v132 = v36 + 3;
      if (v36 + 3 >= v7)
      {
        v133 = 0;
      }

      else
      {
        v133 = *(v124 + v132);
      }

      a1[2] = v132;
      v134 = *(v124 + v132);
      if (v123 >= v7)
      {
        v135 = 0;
      }

      else
      {
        v135 = *(v124 + v123);
      }

      a1[2] = v123;
      v36 += 8;
      if (v7 >= v123 + 4 + v6)
      {
        v136 = (1 << (8 - v5)) + 255;
        v137 = 0xFFFF << (8 - v5);
        v138 = ((v127 & v137) >> (8 - v5)) | ((v136 & v125) << v5);
        v139 = (((v133 & v137) >> (8 - v5)) | ((v136 & v131) << v5)) << 16;
        v140 = v138 | ((((v130 & v137) >> (8 - v5)) | ((v136 & v128) << v5)) << 8) & 0xFF00;
        v141 = (v136 & v134) << v5;
        v142 = (v135 & v137) >> (8 - v5);
        v143 = v139 & 0xFF0000;
        v144 = *a1;
        v145 = 8 - v5;
        v146 = v136;
        v147 = v123 + 1;
        if (v123 + 1 >= v7)
        {
          v148 = 0;
        }

        else
        {
          v148 = *(v144 + v147);
        }

        v149 = v142 | v141;
        v150 = v140 | v143;
        v151 = (v146 & *(*a1 + v123)) << v5;
        a1[2] = v147;
        v152 = *(v144 + v147);
        v153 = v123 + 2;
        if (v123 + 2 >= v7)
        {
          v154 = 0;
        }

        else
        {
          v154 = *(v144 + v153);
        }

        v155 = v150 | (v149 << 24);
        a1[2] = v153;
        v156 = (((v154 & v137) >> v145) | ((v146 & v152) << v5)) << 8;
        v157 = *(v144 + v153);
        v158 = v123 + 3;
        v410 = v34;
        if (v158 >= v7)
        {
          v159 = 0;
        }

        else
        {
          v159 = *(v144 + v158);
        }

        v408 = *&v155;
        a1[2] = v158;
        v160 = *(v144 + v158);
        if (v36 >= v7)
        {
          v161 = 0;
        }

        else
        {
          v161 = *(v144 + v36);
        }

        a1[2] = v36;
        LODWORD(v412) = ((v148 & v137) >> v145) | v151 | v156 & 0xFF00 | ((((v159 & v137) >> v145) | ((v146 & v157) << v5)) << 16) & 0xFF0000 | ((((v161 & v137) >> v145) | ((v146 & v160) << v5)) << 24);
        goto LABEL_153;
      }
    }

    else
    {
      v410 = v34;
      v408 = *(v124 + v36);
      a1[2] = v123;
      v36 += 8;
      if (v7 >= v123 + 4 + v6)
      {
        v412 = *(*a1 + v123);
        a1[2] = v36;
        goto LABEL_153;
      }
    }

    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  v410 = v34;
  v408 = -1.0;
  v412 = 2.0;
  if ((v122 & 2) != 0)
  {
    v412 = 2.0 / ~(-1 << *(v121 + 5));
  }

LABEL_153:
  if ((v122 & 0x10) == 0)
  {
    v406 = *&v29;
    v407 = *&v31;
    if ((v122 & 4) != 0)
    {
      v405 = 0.0;
      v401 = 1.0 / ~(-1 << *(v121 + 6));
      v399 = 1.0 / ~(-1 << *(v121 + 7));
      v403 = 0.0;
    }

    else
    {
      v401 = 1.0;
      v405 = 0.0;
      v403 = 0.0;
      v399 = 1.0;
    }

    goto LABEL_159;
  }

  v162 = v36 + 4;
  if (v7 < v36 + 4 + v6)
  {
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  v250 = *a1;
  v407 = *&v31;
  if (!v5)
  {
    v260 = *(v250 + v36);
    a1[2] = v162;
    v261 = v36 + 8;
    if (v7 < v36 + 8 + v6)
    {
LABEL_287:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v405 = v260;
    v403 = *(*a1 + v162);
    a1[2] = v261;
    v262 = v36 + 12;
    if (v7 < v36 + 12 + v6)
    {
LABEL_313:
      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }

    v406 = *&v29;
    v401 = *(*a1 + v261);
    a1[2] = v262;
    v419 = v36 + 16;
    if (v7 >= v36 + 16 + v6)
    {
      v399 = *(*a1 + v262);
      v36 += 16;
      a1[2] = v419;
      goto LABEL_159;
    }

LABEL_327:
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  v251 = *(v250 + v36);
  v252 = v36 + 1;
  if (v36 + 1 >= v7)
  {
    v253 = 0;
  }

  else
  {
    v253 = *(v250 + v252);
  }

  a1[2] = v252;
  v263 = *(v250 + v252);
  v264 = v36 + 2;
  if (v36 + 2 >= v7)
  {
    v265 = 0;
  }

  else
  {
    v265 = *(v250 + v264);
  }

  a1[2] = v264;
  v266 = *(v250 + v264);
  v267 = v36 + 3;
  if (v36 + 3 >= v7)
  {
    v268 = 0;
  }

  else
  {
    v268 = *(v250 + v267);
  }

  a1[2] = v267;
  v269 = *(v250 + v267);
  if (v162 >= v7)
  {
    v270 = 0;
  }

  else
  {
    v270 = *(v250 + v162);
  }

  a1[2] = v162;
  v271 = v36 + 8;
  if (v7 < v36 + 8 + v6)
  {
    goto LABEL_287;
  }

  v272 = *a1;
  v273 = *(*a1 + v162);
  v274 = v36 + 5;
  if (v36 + 5 >= v7)
  {
    v275 = 0;
  }

  else
  {
    v275 = *(v272 + v274);
  }

  a1[2] = v274;
  v280 = *(v272 + v274);
  v281 = v36 + 6;
  if (v36 + 6 >= v7)
  {
    v282 = 0;
  }

  else
  {
    v282 = *(v272 + v281);
  }

  a1[2] = v281;
  v283 = *(v272 + v281);
  v284 = v36 + 7;
  if (v36 + 7 >= v7)
  {
    v285 = 0;
  }

  else
  {
    v285 = *(v272 + v284);
  }

  a1[2] = v284;
  v286 = *(v272 + v284);
  if (v271 >= v7)
  {
    v287 = 0;
  }

  else
  {
    v287 = *(v272 + v271);
  }

  a1[2] = v271;
  v288 = v36 + 12;
  if (v7 < v36 + 12 + v6)
  {
    goto LABEL_313;
  }

  v406 = *&v29;
  v289 = *a1;
  v404 = *(*a1 + v271);
  v290 = v271 + 1;
  if (v271 + 1 >= v7)
  {
    v402 = 0;
  }

  else
  {
    v402 = *(v289 + v290);
  }

  a1[2] = v290;
  v395 = *(v289 + v290);
  v291 = v271 + 2;
  if (v271 + 2 >= v7)
  {
    v394 = 0;
  }

  else
  {
    v394 = *(v289 + v291);
  }

  a1[2] = v291;
  v400 = *(v289 + v291);
  v292 = v271 + 3;
  if (v292 >= v7)
  {
    v397 = 0;
  }

  else
  {
    v397 = *(v289 + v292);
  }

  a1[2] = v292;
  v398 = *(v289 + v292);
  if (v288 >= v7)
  {
    v396 = 0;
  }

  else
  {
    v396 = *(v289 + v288);
  }

  a1[2] = v288;
  v420 = v288 + 4;
  if (v7 < v288 + 4 + v6)
  {
    goto LABEL_327;
  }

  v293 = (1 << (8 - v5)) + 255;
  v294 = 0xFFFF << (8 - v5);
  v295 = ((v253 & v294) >> (8 - v5)) | ((v293 & v251) << v5) | ((((v265 & v294) >> (8 - v5)) | ((v293 & v263) << v5)) << 8) & 0xFF00 | ((((v268 & v294) >> (8 - v5)) | ((v293 & v266) << v5)) << 16) & 0xFF0000 | ((((v270 & v294) >> (8 - v5)) | ((v293 & v269) << v5)) << 24);
  v296 = ((v402 & v294) >> (8 - v5)) | ((v293 & v404) << v5);
  v405 = *&v295;
  LODWORD(v403) = ((v275 & v294) >> (8 - v5)) | ((v293 & v273) << v5) | ((((v282 & v294) >> (8 - v5)) | ((v293 & v280) << v5)) << 8) & 0xFF00 | ((((v285 & v294) >> (8 - v5)) | ((v293 & v283) << v5)) << 16) & 0xFF0000 | ((((v287 & v294) >> (8 - v5)) | ((v293 & v286) << v5)) << 24);
  LODWORD(v401) = v296 | ((((v394 & v294) >> (8 - v5)) | ((v293 & v395) << v5)) << 8) & 0xFF00 | ((((v397 & v294) >> (8 - v5)) | ((v293 & v400) << v5)) << 16) & 0xFF0000 | ((((v396 & v294) >> (8 - v5)) | ((v293 & v398) << v5)) << 24);
  v297 = *a1;
  v298 = 8 - v5;
  v299 = v293;
  v300 = v288 + 1;
  if (v288 + 1 >= v7)
  {
    v301 = 0;
  }

  else
  {
    v301 = *(v297 + v300);
  }

  v302 = (v293 & *(v297 + v288)) << v5;
  v303 = (v301 & v294) >> v298;
  a1[2] = v300;
  v304 = *(v297 + v300);
  v305 = v288 + 2;
  if (v288 + 2 >= v7)
  {
    v306 = 0;
  }

  else
  {
    v306 = *(v297 + v305);
  }

  a1[2] = v305;
  v307 = *(v297 + v305);
  v308 = v288 + 3;
  if (v308 >= v7)
  {
    v309 = 0;
  }

  else
  {
    v309 = *(v297 + v308);
  }

  a1[2] = v308;
  v310 = (((v309 & v294) >> v298) | ((v293 & v307) << v5)) << 16;
  v311 = v303 | v302 | ((((v306 & v294) >> v298) | ((v293 & v304) << v5)) << 8) & 0xFF00;
  v312 = *(v297 + v308);
  if (v420 >= v7)
  {
    v313 = 0;
  }

  else
  {
    v313 = *(v297 + v420);
  }

  v36 = v420;
  a1[2] = v420;
  LODWORD(v399) = v311 | v310 & 0xFF0000 | ((((v313 & v294) >> v298) | ((v299 & v312) << v5)) << 24);
LABEL_159:
  if (v122)
  {
    v249 = v36 + 1;
    if (v7 < v36 + 1 + v6)
    {
LABEL_264:
      fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Read error\n");
      return 0;
    }

    v254 = 8 - v5;
    v255 = (1 << (8 - v5)) + 255;
    v256 = 0xFFFF << (8 - v5);
    v257 = *a1;
    v258 = *(*a1 + v36);
    if (v5)
    {
      if (v249 >= v7)
      {
        v259 = 0;
      }

      else
      {
        v259 = *(v257 + v249);
      }

      a1[2] = v249;
      v258 = ((v259 & v256) >> v254) | ((v255 & v258) << v5);
    }

    else
    {
      a1[2] = v249;
    }

    v276 = v258 & 0x7F;
    if ((v258 & 0x80) != 0)
    {
      v277 = v36 + 2;
      if (v7 < v36 + 2 + v6)
      {
        goto LABEL_264;
      }

      v278 = *(v257 + v249);
      if (v5)
      {
        if (v277 >= v7)
        {
          v279 = 0;
        }

        else
        {
          v279 = *(v257 + v277);
        }

        a1[2] = v277;
        v278 = ((v279 & v256) >> v254) | ((v255 & v278) << v5);
      }

      else
      {
        a1[2] = v277;
      }

      v276 = v276 & 0xFFFFFFFFFFFFC07FLL | ((v278 & 0x7F) << 7);
      if ((v278 & 0x80) != 0)
      {
        v314 = v36 + 3;
        if (v7 < v36 + 3 + v6)
        {
          goto LABEL_264;
        }

        v315 = *(v257 + v277);
        if (v5)
        {
          if (v314 >= v7)
          {
            v316 = 0;
          }

          else
          {
            v316 = *(v257 + v314);
          }

          a1[2] = v314;
          v315 = ((v316 & v256) >> v254) | ((v255 & v315) << v5);
        }

        else
        {
          a1[2] = v314;
        }

        v276 = v276 & 0xFFFFFFFFFFE03FFFLL | ((v315 & 0x7F) << 14);
        if ((v315 & 0x80) != 0)
        {
          v373 = v36 + 4;
          if (v7 < v36 + 4 + v6)
          {
            goto LABEL_264;
          }

          v374 = *(v257 + v314);
          if (v5)
          {
            if (v373 >= v7)
            {
              v375 = 0;
            }

            else
            {
              v375 = *(v257 + v373);
            }

            a1[2] = v373;
            v374 = ((v375 & v256) >> v254) | ((v255 & v374) << v5);
          }

          else
          {
            a1[2] = v373;
          }

          v276 = v276 & 0xFFFFFFFFF01FFFFFLL | ((v374 & 0x7F) << 21);
          if ((v374 & 0x80) != 0)
          {
            v376 = v36 + 5;
            if (v7 < v36 + 5 + v6)
            {
              goto LABEL_264;
            }

            v377 = *(v257 + v373);
            if (v5)
            {
              if (v376 >= v7)
              {
                v378 = 0;
              }

              else
              {
                v378 = *(v257 + v376);
              }

              a1[2] = v376;
              v377 = ((v378 & v256) >> v254) | ((v255 & v377) << v5);
            }

            else
            {
              a1[2] = v376;
            }

            v276 = v276 & 0xFFFFFFF80FFFFFFFLL | ((v377 & 0x7F) << 28);
            if ((v377 & 0x80) != 0)
            {
              v379 = v36 + 6;
              if (v7 < v36 + 6 + v6)
              {
                goto LABEL_264;
              }

              v380 = *(v257 + v376);
              if (v5)
              {
                if (v379 >= v7)
                {
                  v381 = 0;
                }

                else
                {
                  v381 = *(v257 + v379);
                }

                a1[2] = v379;
                v380 = ((v381 & v256) >> v254) | ((v255 & v380) << v5);
              }

              else
              {
                a1[2] = v379;
              }

              v276 |= (v380 & 0x7F) << 35;
              if ((v380 & 0x80) != 0)
              {
                v382 = v36 + 7;
                if (v7 < v36 + 7 + v6)
                {
                  goto LABEL_264;
                }

                v383 = *(v257 + v379);
                if (v5)
                {
                  if (v382 >= v7)
                  {
                    v384 = 0;
                  }

                  else
                  {
                    v384 = *(v257 + v382);
                  }

                  a1[2] = v382;
                  v383 = ((v384 & v256) >> v254) | ((v255 & v383) << v5);
                }

                else
                {
                  a1[2] = v382;
                }

                v276 |= (v383 & 0x7F) << 42;
                if ((v383 & 0x80) != 0)
                {
                  v385 = v36 + 8;
                  if (v7 < v36 + 8 + v6)
                  {
                    goto LABEL_264;
                  }

                  v386 = *(v257 + v382);
                  if (v5)
                  {
                    if (v385 >= v7)
                    {
                      v387 = 0;
                    }

                    else
                    {
                      v387 = *(v257 + v385);
                    }

                    a1[2] = v385;
                    v386 = ((v387 & v256) >> v254) | ((v255 & v386) << v5);
                  }

                  else
                  {
                    a1[2] = v385;
                  }

                  v276 |= (v386 & 0x7F) << 49;
                  if ((v386 & 0x80) != 0)
                  {
                    v388 = v36 + 9;
                    if (v7 < v36 + 9 + v6)
                    {
                      goto LABEL_264;
                    }

                    v389 = *(v257 + v385);
                    if (v5)
                    {
                      if (v388 >= v7)
                      {
                        v390 = 0;
                      }

                      else
                      {
                        v390 = *(v257 + v388);
                      }

                      a1[2] = v388;
                      v389 = ((v390 & v256) >> v254) | ((v255 & v389) << v5);
                    }

                    else
                    {
                      a1[2] = v388;
                    }

                    v276 |= (v389 & 0x7F) << 56;
                    if ((v389 & 0x80) != 0)
                    {
                      v391 = v36 + 10;
                      if (v7 < v36 + 10 + v6)
                      {
                        goto LABEL_264;
                      }

                      v392 = *(v257 + v388);
                      if (v5)
                      {
                        v393 = v391 >= v7 ? 0 : *(v257 + v391);
                        a1[2] = v391;
                        v392 = ((v393 & v256) >> v254) | ((v255 & v392) << v5);
                      }

                      else
                      {
                        a1[2] = v391;
                      }

                      if ((v392 & 0x80) != 0)
                      {
                        goto LABEL_264;
                      }

                      v276 |= v392 << 63;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (v276 <= a1[1] - ((a1[2] + (*(a1 + 24) >> 3)) & 0x1FFFFFFFFFFFFFFFLL))
    {
      operator new();
    }

    fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Asset size overflows the buffer\n");
    return 0;
  }

  v163 = v36 + ((v5 + 16) >> 3);
  if (v163 > v7)
  {
    goto LABEL_268;
  }

  v164 = v5 & 7;
  if ((v5 & 7) != 0 && v163 == v7)
  {
    goto LABEL_268;
  }

  v165 = 0;
  v166 = *a1;
  v167 = 16;
  do
  {
    v168 = v167;
    if (8 - v5 < v167)
    {
      v168 = 8 - v5;
    }

    v165 = (*(v166 + v36) >> (8 - v5 - v168)) & ~(-1 << v168) | (v165 << v168);
    v167 -= v168;
    v36 += (v168 + v5) >> 3;
    a1[2] = v36;
    LODWORD(v5) = (v5 + v168) & 7;
    *(a1 + 24) = v5;
  }

  while (v167);
  v169 = v36 == v163 && v164 == v5;
  v11 = v169 ? v165 : 0;
  if (!v169)
  {
LABEL_268:
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  if (!v11)
  {
    fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Mesh has 0 vertex\n", "/Library/Caches/com.apple.xbs/Sources/GeoServices/geo/GeoCodecs/GeoCodecs/VMP4/AssetDecoder.cpp", 194);
    return v11;
  }

  std::vector<gm::Matrix<float,3,1>,geo::allocator_adapter<gm::Matrix<float,3,1>,geo::codec::zone_mallocator>>::resize(a3, v11);
  v173 = *a3;
  v174 = *(a3 + 8);
  if (*a3 != v174)
  {
    v175 = *(v121 + 2);
    v177 = *a1;
    v176 = a1[1];
    v178 = a1[2];
    LOBYTE(v179) = *(a1 + 24);
    while (1)
    {
      v180 = v179;
      v181 = v179 + v175;
      v182 = v178 + (v181 >> 3);
      if (v182 > v176)
      {
        goto LABEL_350;
      }

      v183 = v181 & 7;
      v184 = v183 != 0;
      if (v182 != v176)
      {
        v184 = 0;
      }

      if (v175 > 0x20 || v184)
      {
        goto LABEL_350;
      }

      v185 = 0;
      if (v175)
      {
        v186 = v175;
        do
        {
          v187 = v186;
          if (8 - v179 < v186)
          {
            v187 = 8 - v179;
          }

          v185 = (*(v177 + v178) >> (8 - v179 - v187)) & ~(-1 << v187) | (v185 << v187);
          v186 -= v187;
          v178 += (v187 + v179) >> 3;
          a1[2] = v178;
          v179 = (v179 + v187) & 7;
          *(a1 + 24) = v179;
        }

        while (v186);
        v180 = v179;
      }

      v188 = v178 == v182 && v183 == v180;
      if (v188)
      {
        v178 = v182;
        v170 = v185;
      }

      if (!v188)
      {
LABEL_350:
        v10 = *MEMORY[0x1E69E9848];
        goto LABEL_5;
      }

      v189 = *(v121 + 3);
      v190 = v179;
      v191 = v179 + v189;
      v192 = v178 + (v191 >> 3);
      if (v192 > v176)
      {
        goto LABEL_351;
      }

      v193 = v191 & 7;
      v194 = v193 != 0;
      if (v192 != v176)
      {
        v194 = 0;
      }

      if (v189 > 0x20 || v194)
      {
        goto LABEL_351;
      }

      v195 = 0;
      if (*(v121 + 3))
      {
        LOBYTE(v190) = v179;
        do
        {
          v196 = v189;
          if (8 - v190 < v189)
          {
            v196 = 8 - v190;
          }

          v195 = (*(v177 + v178) >> (8 - v190 - v196)) & ~(-1 << v196) | (v195 << v196);
          LOBYTE(v189) = v189 - v196;
          v178 += (v196 + v190) >> 3;
          a1[2] = v178;
          v197 = v190 + v196;
          v190 = v197 & 7;
          *(a1 + 24) = v197 & 7;
        }

        while (v189);
        LOBYTE(v179) = v197 & 7;
      }

      v198 = v178 == v192 && v193 == v190;
      if (v198)
      {
        v178 = v192;
        v171 = v195;
      }

      if (!v198)
      {
LABEL_351:
        v10 = *MEMORY[0x1E69E9848];
        goto LABEL_5;
      }

      v199 = *(v121 + 4);
      v200 = v179;
      v201 = v179 + v199;
      v202 = v178 + (v201 >> 3);
      if (v202 > v176)
      {
        break;
      }

      v203 = v201 & 7;
      v204 = v203 != 0;
      if (v202 != v176)
      {
        v204 = 0;
      }

      if (v199 > 0x20 || v204)
      {
        break;
      }

      v205 = 0;
      if (*(v121 + 4))
      {
        LOBYTE(v200) = v179;
        do
        {
          v206 = v199;
          if (8 - v200 < v199)
          {
            v206 = 8 - v200;
          }

          v205 = (*(v177 + v178) >> (8 - v200 - v206)) & ~(-1 << v206) | (v205 << v206);
          LOBYTE(v199) = v199 - v206;
          v178 += (v206 + v200) >> 3;
          a1[2] = v178;
          v207 = v200 + v206;
          v200 = v207 & 7;
          *(a1 + 24) = v207 & 7;
        }

        while (v199);
        LOBYTE(v179) = v207 & 7;
      }

      v208 = v178 == v202 && v203 == v200;
      if (v208)
      {
        v178 = v202;
        v172 = v205;
      }

      if (!v208)
      {
        break;
      }

      *v173 = v406 + (v410 * v170);
      v173[1] = v407 + (v415 * v171);
      v173[2] = v421 + (v413 * v172);
      v173 += 3;
      if (v173 == v174)
      {
        goto LABEL_217;
      }
    }

    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

LABEL_217:
  if ((*v121 & 2) != 0)
  {
    std::vector<gm::Matrix<float,3,1>,geo::allocator_adapter<gm::Matrix<float,3,1>,geo::codec::zone_mallocator>>::resize((a3 + 32), v11);
    v212 = *(a3 + 32);
    v213 = *(a3 + 40);
    if (v212 != v213)
    {
      v214 = *(v121 + 5);
      v216 = *a1;
      v215 = a1[1];
      v217 = a1[2];
      LOBYTE(v218) = *(a1 + 24);
      while (1)
      {
        v219 = v218;
        v220 = v218 + v214;
        v221 = v217 + (v220 >> 3);
        if (v221 > v215)
        {
          goto LABEL_437;
        }

        v222 = v220 & 7;
        v223 = v222 != 0;
        if (v221 != v215)
        {
          v223 = 0;
        }

        if (v214 > 0x20 || v223)
        {
          goto LABEL_437;
        }

        v224 = 0;
        if (v214)
        {
          v225 = v214;
          do
          {
            v226 = v225;
            if (8 - v218 < v225)
            {
              v226 = 8 - v218;
            }

            v224 = (*(v216 + v217) >> (8 - v218 - v226)) & ~(-1 << v226) | (v224 << v226);
            v225 -= v226;
            v217 += (v226 + v218) >> 3;
            a1[2] = v217;
            v218 = (v218 + v226) & 7;
            *(a1 + 24) = v218;
          }

          while (v225);
          v219 = v218;
        }

        v227 = v217 == v221 && v222 == v219;
        if (v227)
        {
          v217 = v221;
          v209 = v224;
        }

        if (!v227)
        {
LABEL_437:
          v10 = *MEMORY[0x1E69E9848];
          goto LABEL_5;
        }

        v228 = v218;
        v229 = v218 + v214;
        v230 = v217 + (v229 >> 3);
        if (v230 > v215)
        {
          goto LABEL_439;
        }

        v231 = v229 & 7;
        v232 = v231 != 0;
        if (v230 != v215)
        {
          v232 = 0;
        }

        if (v232)
        {
          goto LABEL_439;
        }

        v233 = 0;
        if (v214)
        {
          LOBYTE(v228) = v218;
          v234 = v214;
          do
          {
            v235 = v234;
            if (8 - v228 < v234)
            {
              v235 = 8 - v228;
            }

            v233 = (*(v216 + v217) >> (8 - v228 - v235)) & ~(-1 << v235) | (v233 << v235);
            v234 -= v235;
            v217 += (v235 + v228) >> 3;
            a1[2] = v217;
            v228 = (v228 + v235) & 7;
            *(a1 + 24) = v228;
          }

          while (v234);
          LOBYTE(v218) = v228;
        }

        v236 = v217 == v230 && v231 == v228;
        if (v236)
        {
          v217 = v230;
          v210 = v233;
        }

        if (!v236)
        {
LABEL_439:
          v10 = *MEMORY[0x1E69E9848];
          goto LABEL_5;
        }

        v237 = v218;
        v238 = v218 + v214;
        v239 = v217 + (v238 >> 3);
        if (v239 > v215)
        {
          break;
        }

        v240 = v238 & 7;
        v241 = v240 != 0;
        if (v239 != v215)
        {
          v241 = 0;
        }

        if (v241)
        {
          break;
        }

        v242 = 0;
        if (v214)
        {
          LOBYTE(v237) = v218;
          v243 = v214;
          do
          {
            v244 = v243;
            if (8 - v237 < v243)
            {
              v244 = 8 - v237;
            }

            v242 = (*(v216 + v217) >> (8 - v237 - v244)) & ~(-1 << v244) | (v242 << v244);
            v243 -= v244;
            v217 += (v244 + v237) >> 3;
            a1[2] = v217;
            v237 = (v237 + v244) & 7;
            *(a1 + 24) = v237;
          }

          while (v243);
          LOBYTE(v218) = v237;
        }

        v245 = v217 == v239 && v240 == v237;
        if (v245)
        {
          v217 = v239;
          v211 = v242;
        }

        if (!v245)
        {
          break;
        }

        *v212 = v408 + (v412 * v209);
        v212[1] = v408 + (v412 * v210);
        v212[2] = v408 + (v412 * v211);
        v212 += 3;
        if (v212 == v213)
        {
          goto LABEL_261;
        }
      }

      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }
  }

LABEL_261:
  if ((*v121 & 4) != 0)
  {
    std::vector<gm::Matrix<float,2,1>,geo::allocator_adapter<gm::Matrix<float,2,1>,geo::codec::zone_mallocator>>::resize((a3 + 64), v11);
    v319 = *(a3 + 64);
    v320 = *(a3 + 72);
    LOBYTE(v246) = *(a1 + 24);
    v247 = a1[1];
    v248 = a1[2];
    if (v319 != v320)
    {
      v321 = *(v121 + 6);
      v322 = *a1;
      v323 = a1[2];
      while (1)
      {
        v324 = v246;
        v325 = v246 + v321;
        v326 = v323 + (v325 >> 3);
        if (v326 > v247)
        {
          goto LABEL_438;
        }

        v327 = v325 & 7;
        v328 = v327 != 0;
        if (v326 != v247)
        {
          v328 = 0;
        }

        if (v321 > 0x20 || v328)
        {
          goto LABEL_438;
        }

        v329 = 0;
        if (v321)
        {
          v330 = v321;
          do
          {
            v331 = v330;
            if (8 - v246 < v330)
            {
              v331 = 8 - v246;
            }

            v329 = (*(v322 + v323) >> (8 - v246 - v331)) & ~(-1 << v331) | (v329 << v331);
            v330 -= v331;
            v323 += (v331 + v246) >> 3;
            a1[2] = v323;
            v246 = (v246 + v331) & 7;
            *(a1 + 24) = v246;
          }

          while (v330);
          v324 = v246;
          v248 = v323;
        }

        v332 = v323 == v326 && v327 == v324;
        if (v332)
        {
          v323 = v326;
          v317 = v329;
        }

        if (!v332)
        {
LABEL_438:
          v10 = *MEMORY[0x1E69E9848];
          goto LABEL_5;
        }

        v333 = *(v121 + 7);
        v334 = v246;
        v335 = v246 + v333;
        v336 = v323 + (v335 >> 3);
        if (v336 > v247)
        {
          break;
        }

        v337 = v335 & 7;
        v338 = v337 != 0;
        if (v336 != v247)
        {
          v338 = 0;
        }

        if (v333 > 0x20 || v338)
        {
          break;
        }

        v339 = 0;
        if (*(v121 + 7))
        {
          LOBYTE(v334) = v246;
          do
          {
            v340 = v333;
            if (8 - v334 < v333)
            {
              v340 = 8 - v334;
            }

            v339 = (*(v322 + v323) >> (8 - v334 - v340)) & ~(-1 << v340) | (v339 << v340);
            LOBYTE(v333) = v333 - v340;
            v323 += (v340 + v334) >> 3;
            a1[2] = v323;
            v341 = v334 + v340;
            v334 = v341 & 7;
            *(a1 + 24) = v341 & 7;
          }

          while (v333);
          v248 = v323;
          LOBYTE(v246) = v334;
        }

        v342 = v323 == v336 && v337 == v334;
        if (v342)
        {
          v323 = v336;
          v318 = v339;
        }

        if (!v342)
        {
          break;
        }

        *v319 = v405 + (v401 * v317);
        v319[1] = v403 + (v399 * v318);
        v319 += 2;
        if (v319 == v320)
        {
          goto LABEL_384;
        }
      }

      v10 = *MEMORY[0x1E69E9848];
      goto LABEL_5;
    }
  }

  else
  {
    LOBYTE(v246) = *(a1 + 24);
    v247 = a1[1];
    v248 = a1[2];
  }

LABEL_384:
  v343 = v248 + ((v246 + 8) >> 3);
  if (v343 > v247)
  {
    goto LABEL_428;
  }

  v344 = v246 & 7;
  if ((v246 & 7) != 0 && v343 == v247)
  {
    goto LABEL_428;
  }

  v345 = 0;
  v346 = *a1;
  v347 = 8;
  do
  {
    v348 = v347;
    if (8 - v246 < v347)
    {
      v348 = 8 - v246;
    }

    v345 = (*(v346 + v248) >> (8 - v246 - v348)) & ~(-1 << v348) | (v345 << v348);
    v347 -= v348;
    v248 += (v348 + v246) >> 3;
    a1[2] = v248;
    v349 = v246 + v348;
    v246 = v349 & 7;
    *(a1 + 24) = v349 & 7;
  }

  while (v347);
  v350 = v248 == v343 && v344 == v246;
  if (!v350)
  {
    v343 = v248;
  }

  if (!v350)
  {
LABEL_428:
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  v351 = v343 + 4;
  if (v343 + 4 > v247 || (v349 & 7) != 0 && v351 == v247)
  {
    goto LABEL_442;
  }

  LODWORD(v352) = 0;
  v353 = *a1;
  v354 = 32;
  LOBYTE(v355) = v349 & 7;
  do
  {
    v356 = v354;
    if (8 - v355 < v354)
    {
      v356 = 8 - v355;
    }

    v352 = (*(v353 + v343) >> (8 - v355 - v356)) & ~(-1 << v356) | (v352 << v356);
    v354 -= v356;
    v343 += (v356 + v355) >> 3;
    a1[2] = v343;
    v355 = (v355 + v356) & 7;
    *(a1 + 24) = v355;
  }

  while (v354);
  if (v246 != v355 || v343 != v351)
  {
LABEL_442:
    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

  if (!v352)
  {
    fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Mesh has 0 index\n");
    return 0;
  }

  std::vector<unsigned short,geo::allocator_adapter<unsigned short,geo::codec::zone_mallocator>>::resize((a3 + 96), v352);
  v359 = *(a3 + 96);
  v360 = *(a3 + 104);
  if (v359 != v360)
  {
    v362 = *a1;
    v361 = a1[1];
    v363 = a1[2];
    LOBYTE(v364) = *(a1 + 24);
    while (1)
    {
      v365 = v364;
      v366 = v363 + ((v345 + v364) >> 3);
      if (v366 > v361)
      {
        break;
      }

      v367 = (v345 + v364) & 7;
      v368 = v367 != 0;
      if (v366 != v361)
      {
        v368 = 0;
      }

      if (v345 > 0x20u || v368)
      {
        break;
      }

      if (v345)
      {
        v369 = 0;
        v370 = v345;
        do
        {
          v371 = v370;
          if (8 - v364 < v370)
          {
            v371 = 8 - v364;
          }

          v369 = (*(v362 + v363) >> (8 - v364 - v371)) & ~(-1 << v371) | (v369 << v371);
          v370 -= v371;
          v363 += (v371 + v364) >> 3;
          a1[2] = v363;
          v364 = (v364 + v371) & 7;
          *(a1 + 24) = v364;
        }

        while (v370);
        v365 = v364;
      }

      else
      {
        LOWORD(v369) = 0;
      }

      v372 = v363 == v366 && v367 == v365;
      if (v372)
      {
        v363 = v366;
        v358 = v369;
      }

      if (!v372)
      {
        break;
      }

      *v359++ = v358;
      if (v359 == v360)
      {
        goto LABEL_425;
      }
    }

    v10 = *MEMORY[0x1E69E9848];
    goto LABEL_5;
  }

LABEL_425:
  if (*(a1 + 24))
  {
    *(a1 + 24) = 0;
    ++a1[2];
  }

  return 1;
}

void sub_1B335F0BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41)
{
  if (!a2)
  {
    _Unwind_Resume(exception_object);
  }

  __clang_call_terminate(exception_object);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<VertexFormat>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335F2CC(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<geo::codec::AssetLodInstance>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FBE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<std::pair<unsigned long long,geo::codec::MaterialSheet>>(uint64_t a1, void *a2)
{
  v4 = pthread_rwlock_rdlock((a1 + 32));
  if (v4)
  {
    geo::read_write_lock::logFailure(v4, "read lock", v5);
  }

  atomic_fetch_add((a1 + 24), 0xFFFFFFFF);
  malloc_zone_free(*a1, a2);
  v6 = pthread_rwlock_unlock((a1 + 32));
  if (v6)
  {

    geo::read_write_lock::logFailure(v6, "unlock", v7);
  }
}

void sub_1B335F3FC(_Unwind_Exception *a1)
{
  v3 = pthread_rwlock_unlock((v1 + 32));
  if (v3)
  {
    geo::read_write_lock::logFailure(v3, "unlock", v4);
  }

  _Unwind_Resume(a1);
}

void std::vector<gm::Matrix<float,2,1>,geo::allocator_adapter<gm::Matrix<float,2,1>,geo::codec::zone_mallocator>>::resize(geo::codec::zone_mallocator *a1, unint64_t a2)
{
  v2 = *a1;
  v3 = *(a1 + 1);
  v4 = v3 - *a1;
  v5 = a2 - (v4 >> 3);
  if (a2 <= v4 >> 3)
  {
    if (a2 >= v4 >> 3)
    {
      return;
    }

    v22 = &v2[8 * a2];
LABEL_15:
    *(a1 + 1) = v22;
    return;
  }

  v6 = *(a1 + 2);
  if (v5 <= (v6 - v3) >> 3)
  {
    v22 = (v3 + 8 * v5);
    goto LABEL_15;
  }

  if (a2 >> 61)
  {
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v8 = v6 - v2;
  v9 = v8 >> 2;
  if (v8 >> 2 <= a2)
  {
    v9 = a2;
  }

  if (v8 >= 0x7FFFFFFFFFFFFFF8)
  {
    v10 = 0x1FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v10 = v9;
  }

  v11 = geo::codec::zone_mallocator::instance(a1);
  v12 = geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::allocate<gm::Matrix<float,2,1>>(v11, v10);
  v13 = a1;
  v16 = a1;
  v15 = *a1;
  v14 = *(v16 + 1);
  v17 = v12 + v4 - (v14 - v15);
  v18 = v12 + 8 * v10;
  v19 = v12 + 8 * v5 + v4;
  v20 = v14 - v15;
  if (v14 == v15)
  {
    goto LABEL_23;
  }

  if ((v20 - 8) >= 0x58)
  {
    v21 = v12 + v4 - (v14 - v15);
    if (((v12 + v4) - v14) >= 0x20)
    {
      v23 = ((v20 - 8) >> 3) + 1;
      v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = (v12 + v4 - 8 * (v20 >> 3) + 16);
      v12 = (v15 + 16);
      v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v27 = *v12;
        *(v25 - 1) = *(v12 - 1);
        *v25 = v27;
        v25 += 2;
        v12 = (v12 + 32);
        v26 -= 4;
      }

      while (v26);
      if (v23 == (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
        goto LABEL_22;
      }

      v21 = &v17[v24];
      v15 += v24;
    }
  }

  else
  {
    v21 = v12 + v4 - (v14 - v15);
  }

  do
  {
    v28 = *v15;
    v15 += 8;
    *v21 = v28;
    v21 += 8;
  }

  while (v15 != v14);
LABEL_22:
  v15 = *v13;
LABEL_23:
  *v13 = v17;
  *(v13 + 1) = v19;
  *(v13 + 2) = v18;
  if (v15)
  {
    v29 = geo::codec::zone_mallocator::instance(v12);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<gm::Matrix<float,2,1>>(v29, v15);
  }
}

uint64_t geo::codec::AssetDecoder::decodeAssetOcclusionMeshes(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  v111 = *MEMORY[0x1E69E9840];
  if (!a3)
  {
    return 0;
  }

  v108 = 0;
  v109 = 0;
  v110 = 0;
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  v5 = v4 + 4;
  v6 = *(a1 + 24);
  v7 = *(a1 + 24) != 0;
  v8 = v4 + 5;
  if (!*(a1 + 24))
  {
    v8 = v4 + 4;
  }

  if (v3 < v8)
  {
    v9 = 570;
LABEL_45:
    fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Read error\n", "/Library/Caches/com.apple.xbs/Sources/GeoServices/geo/GeoCodecs/GeoCodecs/VMP4/AssetDecoder.cpp", v9);
    return 0;
  }

  v10 = *a1;
  if (*(a1 + 24))
  {
    v11 = 8 - v6;
    v12 = *(v10 + v4);
    v13 = v4 + 1;
    if (v4 + 1 >= v3)
    {
      v14 = 0;
    }

    else
    {
      v14 = *(v10 + v13);
    }

    v16 = (1 << (8 - v6)) + 255;
    v17 = 0xFFFF << v11;
    *(a1 + 16) = v13;
    v18 = *(v10 + v13);
    v19 = v4 + 2;
    if (v4 + 2 >= v3)
    {
      v20 = 0;
    }

    else
    {
      v20 = *(v10 + v19);
    }

    v21 = v16 & v12;
    v22 = v14 & v17;
    v23 = v16 & v18;
    v24 = v20 & v17;
    *(a1 + 16) = v19;
    v25 = v4 + 3;
    if (v4 + 3 >= v3)
    {
      v26 = 0;
    }

    else
    {
      v26 = *(v10 + v25);
    }

    v27 = v21 << v6;
    v28 = v22 >> v11;
    v29 = v23 << v6;
    v30 = (((1 << (8 - v6)) - 1) & *(v10 + v19)) << v6;
    *(a1 + 16) = v25;
    v31 = *(v10 + v25);
    if (v5 >= v3)
    {
      v32 = 0;
    }

    else
    {
      v32 = *(v10 + v5);
    }

    *(a1 + 16) = v5;
    v33 = ((((v26 & v17) >> v11) | v30) << 16) | ((((v32 & v17) >> v11) | ((v16 & v31) << v6)) << 24) | (((v24 >> v11) | v29) << 8) | v28 | v27;
    *a2 = v33;
    if (!v33)
    {
      return 0;
    }
  }

  else
  {
    v15 = *(v10 + v4);
    *(a1 + 16) = v5;
    *a2 = v15;
    if (!v15)
    {
      return 0;
    }
  }

  v34 = v5 + 4;
  if (v3 < v34 + v7)
  {
    v9 = 575;
    goto LABEL_45;
  }

  if (v6)
  {
    *(a1 + 16) = v34;
    v35 = v34 + 4;
    if (v3 >= v35 + v7)
    {
      *(a1 + 16) = v35;
      v36 = v35 + 4;
      if (v3 >= v36 + v7)
      {
        *(a1 + 16) = v36;
        v37 = v36 + 4;
        if (v3 >= v37 + v7)
        {
          *(a1 + 16) = v37;
          v38 = v37 + 4;
          if (v3 >= v38 + v7)
          {
            *(a1 + 16) = v38;
            v39 = v38 + 4;
            if (v3 >= v38 + 4 + v7)
            {
              *(a1 + 16) = v39;
              v40 = v38 + 5;
              if (v3 >= v39 + 1 + v7)
              {
                v41 = *(*a1 + v39);
                if (v40 >= v3)
                {
                  v42 = 0;
                }

                else
                {
                  v42 = *(*a1 + v40);
                }

                *(a1 + 16) = v40;
                v48 = (((v42 & (0xFFFF << (8 - v6))) >> (8 - v6)) | ((((1 << (8 - v6)) + 255) & v41) << v6));
                goto LABEL_51;
              }

LABEL_44:
              v9 = 583;
              goto LABEL_45;
            }

LABEL_42:
            v9 = 581;
            goto LABEL_45;
          }

LABEL_40:
          v9 = 580;
          goto LABEL_45;
        }

LABEL_38:
        v9 = 579;
        goto LABEL_45;
      }

LABEL_36:
      v9 = 577;
      goto LABEL_45;
    }

LABEL_34:
    v9 = 576;
    goto LABEL_45;
  }

  *(a1 + 16) = v34;
  if (v3 < v34 + 4 + v7)
  {
    goto LABEL_34;
  }

  *(a1 + 16) = v34 + 4;
  if (v3 < v34 + 8 + v7)
  {
    goto LABEL_36;
  }

  *(a1 + 16) = v34 + 8;
  v43 = v34 + 12;
  if (v3 < v34 + 12 + v7)
  {
    goto LABEL_38;
  }

  *(a1 + 16) = v43;
  v44 = v34 + 16;
  if (v3 < v43 + 4 + v7)
  {
    goto LABEL_40;
  }

  *(a1 + 16) = v44;
  v45 = v43 + 8;
  if (v3 < v44 + 4 + v7)
  {
    goto LABEL_42;
  }

  *(a1 + 16) = v45;
  if (v3 < v44 + 5 + v7)
  {
    goto LABEL_44;
  }

  v48 = *(*a1 + v45);
  *(a1 + 16) = v44 + 5;
LABEL_51:
  v49 = a3;
  if (v48)
  {
    v50 = a1;
    std::vector<VertexFormat,geo::allocator_adapter<VertexFormat,geo::codec::zone_mallocator>>::resize(&v108, v48);
    v51 = v108;
    v52 = v109;
    a1 = v50;
    v53 = *(v50 + 24);
    v54 = v50[1];
    v55 = v50[2];
    a3 = v49;
    if (v108 != v109)
    {
      v56 = v53 != 0;
      v57 = *v50;
      v58 = 8 - v53;
      v59 = (1 << (8 - v53)) + 255;
      v60 = 0xFFFF << (8 - v53);
      v61 = v108 + 3;
      do
      {
        v65 = v55 + 2;
        if (v54 < v55 + 2 + v56)
        {
          v81 = *MEMORY[0x1E69E9848];
          goto LABEL_87;
        }

        if (v53)
        {
          v66 = v55 + 1;
          if (v55 + 1 >= v54)
          {
            v67 = 0;
          }

          else
          {
            v67 = *(v57 + v66);
          }

          v70 = *(v57 + v55);
          v50[2] = v66;
          if (v65 >= v54)
          {
            v71 = 0;
          }

          else
          {
            v71 = *(v57 + v65);
          }

          v69 = (((v67 & v60) >> v58) | ((v59 & v70) << v53));
          LOWORD(v67) = (((v71 & v60) >> v58) | ((((1 << (8 - v53)) - 1) & *(v57 + v66)) << v53));
        }

        else
        {
          v68 = *(v57 + v55);
          v69 = *(v57 + v55);
          v67 = v68 >> 8;
        }

        v72 = v61 - 3;
        v50[2] = v65;
        *(v61 - 3) = v69 | (v67 << 8);
        v73 = v65 + 1;
        if (v54 < v65 + 1 + v56)
        {
          v81 = *MEMORY[0x1E69E9848];
          goto LABEL_87;
        }

        v74 = *(v57 + v65);
        if (v53)
        {
          if (v73 >= v54)
          {
            v75 = 0;
          }

          else
          {
            v75 = *(v57 + v73);
          }

          v50[2] = v73;
          *(v61 - 1) = ((v75 & v60) >> v58) | ((v59 & v74) << v53);
          v64 = v73 + 1;
          if (v54 < v73 + 1 + v56)
          {
LABEL_115:
            v81 = *MEMORY[0x1E69E9848];
            goto LABEL_87;
          }

          if (v64 >= v54)
          {
            v77 = 0;
          }

          else
          {
            v77 = *(v57 + v64);
          }

          v78 = *(v57 + v73);
          v50[2] = v64;
          *v61 = ((v77 & v60) >> v58) | ((v59 & v78) << v53);
          v55 = v64 + 1;
          if (v54 < v64 + 1 + v56)
          {
LABEL_116:
            v81 = *MEMORY[0x1E69E9848];
LABEL_87:
            a1 = fprintf(v81, "%s:%d Asset Parse: Read error\n");
LABEL_88:
            v46 = 0;
            goto LABEL_121;
          }

          if (v55 < v54)
          {
            v62 = *(v57 + v55);
          }

          else
          {
            v62 = 0;
          }

          v63 = *(v57 + v64);
          v50[2] = v55;
          LODWORD(v64) = ((v62 & v60) >> v58) | ((v59 & v63) << v53);
        }

        else
        {
          v50[2] = v73;
          *(v61 - 1) = v74;
          v64 = v73 + 1;
          if (v54 < v73 + 1 + v56)
          {
            goto LABEL_115;
          }

          v76 = *(v57 + v73);
          v50[2] = v64;
          *v61 = v76;
          v55 = v64 + 1;
          if (v54 < v64 + 1 + v56)
          {
            goto LABEL_116;
          }

          LOBYTE(v64) = *(v57 + v64);
          v50[2] = v55;
        }

        v61[1] = v64;
        v61 += 8;
      }

      while (v72 + 8 != v52);
    }
  }

  else
  {
    v51 = 0;
    v52 = 0;
    v53 = *(a1 + 24);
    v54 = *(a1 + 8);
    v55 = *(a1 + 16);
  }

  v79 = v55 + 2;
  v80 = v55 + 3;
  if (!v53)
  {
    v80 = v55 + 2;
  }

  if (v54 < v80)
  {
    v81 = *MEMORY[0x1E69E9848];
    goto LABEL_87;
  }

  v82 = *a1;
  if (v53)
  {
    v83 = 8 - v53;
    v84 = (1 << (8 - v53)) + 255;
    v85 = 0xFFFF << (8 - v53);
    v86 = *(v82 + v55);
    v87 = v55 + 1;
    if (v87 >= v54)
    {
      v88 = 0;
    }

    else
    {
      v88 = *(v82 + v87);
    }

    v89 = ((v88 & v85) >> v83) | ((v84 & v86) << v53);
    *(a1 + 16) = v87;
    v91 = *(v82 + v87);
    if (v79 >= v54)
    {
      v92 = 0;
    }

    else
    {
      v92 = *(v82 + v79);
    }

    v90 = ((v92 & v85) >> v83) | ((v84 & v91) << v53);
  }

  else
  {
    v89 = *(v82 + v55);
    v90 = v89 >> 8;
  }

  *(a1 + 16) = v79;
  v93 = (v89 | (v90 << 8));
  v94 = *a3;
  v95 = a3[1];
  v96 = v95 - *a3;
  v97 = 0x86BCA1AF286BCA1BLL * (v96 >> 3);
  v98 = v97 + v93;
  if (v97 >= v97 + v93)
  {
    if (v97 > v97 + v93)
    {
      v102 = a1;
      v103 = (v94 + 152 * v98);
      while (v95 != v103)
      {
        v95 = (v95 - 152);
        geo::codec::Mesh::~Mesh(v95);
      }

      a3 = v49;
      v49[1] = v103;
      a1 = v102;
    }
  }

  else
  {
    v99 = a3[2];
    if (0x86BCA1AF286BCA1BLL * ((v99 - v95) >> 3) < v93)
    {
      if (v98 <= 0x1AF286BCA1AF286)
      {
        v100 = 0x86BCA1AF286BCA1BLL * ((v99 - v94) >> 3);
        if (2 * v100 > v98)
        {
          v98 = 2 * v100;
        }

        if (v100 >= 0xD79435E50D7943)
        {
          v101 = 0x1AF286BCA1AF286;
        }

        else
        {
          v101 = v98;
        }

        if (v101 <= 0x1AF286BCA1AF286)
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v104 = v95 - *a3;
    v105 = a1;
    bzero(a3[1], 152 * ((152 * v93 - 152) / 0x98) + 152);
    a1 = v105;
    a3 = v49;
    v96 = v104;
    v49[1] = v95 + 152 * ((152 * v93 - 152) / 0x98) + 152;
  }

  if (v93)
  {
    while (1)
    {
      v106 = a1;
      if ((buildAssetMesh(a1, 0, *a3 + v96, v51, v52) & 1) == 0)
      {
        break;
      }

      v96 += 152;
      --v93;
      a3 = v49;
      a1 = v106;
      if (!v93)
      {
        goto LABEL_120;
      }
    }

    a1 = fprintf(*MEMORY[0x1E69E9848], "%s:%d Asset Parse: Failed to decode asset mesh\n");
    goto LABEL_88;
  }

LABEL_120:
  v46 = 1;
LABEL_121:
  if (v51)
  {
    v109 = v51;
    v107 = geo::codec::zone_mallocator::instance(a1);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<VertexFormat>(v107, v51);
  }

  return v46;
}

void sub_1B3360004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (a14)
  {
    v16 = geo::codec::zone_mallocator::instance(exception_object);
    geo::tracked_allocator<geo::zone_mallocator,geo::allocation_counter>::deallocate<VertexFormat>(v16, a14);
  }

  _Unwind_Resume(exception_object);
}

os_log_t __GEOGetGeoCodecsDecodeLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit.GeoCodecs", "Decode");
  GEOGetGeoCodecsDecodeLog::log = result;
  return result;
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      v10 = 4 * __n;
      bzero(this->__end_, 4 * __n);
      end = (end + v10);
    }

    this->__end_ = end;
  }

  else
  {
    begin = this->__begin_;
    v6 = end - this->__begin_;
    v7 = (v6 >> 2) + __n;
    if (v7 >> 62)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v8 = value - begin;
    if (v8 >> 1 > v7)
    {
      v7 = v8 >> 1;
    }

    if (v8 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v9 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v9 = v7;
    }

    if (v9)
    {
      if (!(v9 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v11 = (4 * (v6 >> 2));
    v12 = 4 * __n;
    bzero(v11, 4 * __n);
    memcpy(0, begin, v6);
    this->__begin_ = 0;
    this->__end_ = &v11[v12];
    this->__end_cap_.__value_ = 0;
    if (begin)
    {

      operator delete(begin);
    }
  }
}

void mgcl::tmesh::Decoder::~Decoder(mgcl::tmesh::Decoder *this)
{
  v1 = *this;
  *this = 0;
  if (v1)
  {
    v2 = *v1;
    *v1 = 0;
    if (v2)
    {
      v3 = v2[333];
      if (v3)
      {
        v2[334] = v3;
        operator delete(v3);
      }

      v4 = v2[330];
      if (v4)
      {
        v2[331] = v4;
        operator delete(v4);
      }

      v5 = v2[327];
      if (v5)
      {
        v2[328] = v5;
        operator delete(v5);
      }

      v6 = v2[324];
      if (v6)
      {
        v2[325] = v6;
        operator delete(v6);
      }

      v7 = v2[321];
      if (v7)
      {
        v2[322] = v7;
        operator delete(v7);
      }

      v8 = v2[318];
      if (v8)
      {
        v2[319] = v8;
        operator delete(v8);
      }

      v9 = v2[315];
      if (v9)
      {
        v2[316] = v9;
        operator delete(v9);
      }

      v10 = v2[312];
      if (v10)
      {
        v2[313] = v10;
        operator delete(v10);
      }

      v11 = v2[309];
      if (v11)
      {
        v2[310] = v11;
        operator delete(v11);
      }

      v12 = v2[306];
      if (v12)
      {
        v2[307] = v12;
        operator delete(v12);
      }

      v13 = v2[303];
      if (v13)
      {
        v2[304] = v13;
        operator delete(v13);
      }

      v14 = 192;
      do
      {
        v15 = v2[v14 + 29];
        if (v15)
        {
          v2[v14 + 30] = v15;
          operator delete(v15);
        }

        v14 -= 3;
      }

      while (v14 * 8);
      v16 = v2[28];
      if (v16)
      {
        v2[29] = v16;
        operator delete(v16);
      }

      v17 = v2[25];
      if (v17)
      {
        v2[26] = v17;
        operator delete(v17);
      }

      v18 = v2[22];
      if (v18)
      {
        v2[23] = v18;
        operator delete(v18);
      }

      v19 = v2[19];
      if (v19)
      {
        v2[20] = v19;
        operator delete(v19);
      }

      v20 = v2[16];
      if (v20)
      {
        v2[17] = v20;
        operator delete(v20);
      }

      v21 = v2[13];
      if (v21)
      {
        v2[14] = v21;
        operator delete(v21);
      }

      v22 = v2[10];
      if (v22)
      {
        v2[11] = v22;
        operator delete(v22);
      }

      v23 = v2[7];
      if (v23)
      {
        v2[8] = v23;
        operator delete(v23);
      }

      v24 = v2[4];
      if (v24)
      {
        v2[5] = v24;
        operator delete(v24);
      }

      v25 = v2[1];
      if (v25)
      {
        v2[2] = v25;
        operator delete(v25);
      }

      MEMORY[0x1B8C62190](v2, 0x10F0C40F1726845);
    }

    MEMORY[0x1B8C62190](v1, 0x20C4093837F09);
  }
}

uint64_t gcl::tmesh::DecoderImpl::decompressPositionsAndConnectivity(uint64_t a1, unint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  v703 = *MEMORY[0x1E69E9840];
  *(a1 + 3872) = 0;
  if (!a5 || !a6)
  {
    goto LABEL_507;
  }

  v14 = gcl::tmesh::DecoderImpl::parsePositionsAndConnectivityInfo(a2, a3, a1 + 3776);
  if (!v14)
  {
    goto LABEL_16;
  }

  if (v15 < 0)
  {
    goto LABEL_16;
  }

  v16 = *(a1 + 3784);
  if (a3 - v16 < 0)
  {
    goto LABEL_16;
  }

  if (!a2)
  {
    goto LABEL_16;
  }

  if (v14 + v15 < a2)
  {
    goto LABEL_16;
  }

  v17 = a2 + v16;
  if (v17 < v14)
  {
    goto LABEL_16;
  }

  v18 = v17 - v14;
  if (v18 < 0)
  {
    goto LABEL_16;
  }

  if (*(a1 + 3780) || (v19 = *(a1 + 3781), (v19 & 0xFC) != 4) || (v20 = *(a1 + 3808), (v19 & 6) == 4) && (v20 | 4) != 4 && *(a1 + 3800) == 1)
  {
    result = 4;
    goto LABEL_508;
  }

  if ((*(a1 + 3812) - 3) < 2 || (v20 | 2) == 3)
  {
LABEL_16:
    result = 3;
LABEL_508:
    *(a1 + 3872) = result;
    return result;
  }

  if (v18 < 4)
  {
    v22 = 0;
    v23 = 0;
LABEL_24:
    v24 = 0;
    v25 = 0;
    v26 = 0;
    goto LABEL_25;
  }

  v23 = *v14;
  if ((v18 & 0x7FFFFFFFFFFFFFFCLL) == 4)
  {
    v22 = 0;
    goto LABEL_24;
  }

  v22 = v14[1];
  if ((v18 & 0x7FFFFFFFFFFFFFFCLL) == 8)
  {
    goto LABEL_24;
  }

  v25 = v18 - 12;
  v26 = v14 + 3;
  v24 = v14[2];
LABEL_25:
  if (*(a1 + 3820) == 1)
  {
    if (v25)
    {
      v27 = *v26;
      if (v25 == 1)
      {
        v28 = 0;
      }

      else
      {
        v28 = *(v26 + 1);
        if (v25 != 2)
        {
          v25 -= 3;
          v29 = *(v26 + 2);
          v26 = (v26 + 3);
          goto LABEL_35;
        }
      }

      v29 = 0;
      v25 = 0;
      v26 = 0;
    }

    else
    {
      v28 = 0;
      v27 = 0;
      v29 = 0;
      v26 = 0;
    }
  }

  else
  {
    v27 = 0;
    v28 = 0;
    v29 = 0;
  }

LABEL_35:
  if (!v26)
  {
    goto LABEL_16;
  }

  if (v27 <= v28)
  {
    v30 = v28;
  }

  else
  {
    v30 = v27;
  }

  if (v30 <= v29)
  {
    v30 = v29;
  }

  if (v30 >= 0x1D)
  {
    goto LABEL_16;
  }

  v31 = *(a1 + 104);
  *(a1 + 2688) = v27;
  *(a1 + 2692) = v28;
  *(a1 + 2696) = v29;
  v32 = *(a1 + 3788);
  v33 = *(a1 + 3792);
  v34 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 112) - v31) >> 2);
  v669 = v23;
  v666 = v24;
  v667 = v22;
  v685 = v26;
  __dst = v25;
  if (v32 <= v34)
  {
    if (v32 < v34)
    {
      *(a1 + 112) = v31 + 12 * v32;
    }
  }

  else
  {
    std::vector<gcl::Vector3<int>>::__append(a1 + 104, v32 - v34);
  }

  *a1 = 0;
  v35 = *(a1 + 56);
  v668 = (a1 + 56);
  if (*(a1 + 64) != v35)
  {
    *(a1 + 64) = v35;
  }

  v36 = *(a1 + 128);
  *(a1 + 3836) = 0;
  *(a1 + 3788) = v32;
  *(a1 + 3792) = v33;
  v37 = 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 136) - v36) >> 2);
  v696 = v32;
  v689 = v32;
  if (v33 <= v37)
  {
    if (v33 < v37)
    {
      *(a1 + 136) = v36 + 12 * v33;
    }
  }

  else
  {
    std::vector<gcl::Vector3<int>>::__append(a1 + 128, v33 - v37);
  }

  v39 = *(a1 + 32);
  v38 = *(a1 + 40);
  v40 = &v38[-v39];
  if (&v38[-v39] > 0x3F)
  {
    if (v40 != 64)
    {
      *(a1 + 40) = v39 + 64;
    }
  }

  else
  {
    v41 = *(a1 + 48);
    if (v41 - v38 < (64 - v40))
    {
      operator new();
    }

    v42 = v39 + 64;
    bzero(v38, 64 - v40);
    *(a1 + 40) = v42;
  }

  v43 = *(a1 + 8);
  v44 = *(a1 + 16) - v43;
  v671 = (a1 + 8);
  if ((v44 >> 2) > 0x3F)
  {
    if (v44 != 256)
    {
      *(a1 + 16) = v43 + 256;
    }
  }

  else
  {
    std::vector<int>::__append((a1 + 8), 64 - (v44 >> 2));
  }

  v46 = *(a1 + 152);
  v45 = *(a1 + 160);
  v47 = v45 - v46;
  v48 = (v45 - v46) >> 4;
  v49 = v696 - v48;
  if (v696 <= v48)
  {
    if (v696 >= v48)
    {
      v54 = v696;
    }

    else
    {
      v54 = v696;
      v45 = &v46[16 * v696];
      *(a1 + 160) = v45;
    }
  }

  else
  {
    v50 = *(a1 + 168);
    if (v49 <= (v50 - v45) >> 4)
    {
      v55 = 16 * v49;
      bzero(*(a1 + 160), v55);
      v45 += v55;
      *(a1 + 160) = v45;
    }

    else
    {
      if (v689 < 0)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v51 = v50 - v46;
      v52 = v51 >> 3;
      if (v51 >> 3 <= v696)
      {
        v52 = v696;
      }

      v123 = v51 >= 0x7FFFFFFFFFFFFFF0;
      v53 = 0xFFFFFFFFFFFFFFFLL;
      if (!v123)
      {
        v53 = v52;
      }

      if (v53)
      {
        if (!(v53 >> 60))
        {
          operator new();
        }

        goto LABEL_967;
      }

      __nc = (v45 - v46) >> 4;
      v56 = (16 * v48);
      bzero(v56, 16 * v49);
      v45 = &v56[16 * v49];
      v57 = &v56[-16 * __nc];
      memcpy(v57, v46, v47);
      *(a1 + 152) = v57;
      *(a1 + 160) = v45;
      *(a1 + 168) = 0;
      if (v46)
      {
        operator delete(v46);
        v45 = *(a1 + 160);
      }
    }

    v54 = v696;
    v46 = *(a1 + 152);
  }

  if (v46 != v45)
  {
    memset(v46, 255, ((v45 - v46 - 16) & 0xFFFFFFFFFFFFFFF0) + 16);
  }

  v58 = *(a1 + 176);
  v59 = *(a1 + 184);
  v60 = 0xAAAAAAAAAAAAAAABLL * ((v59 - v58) >> 2);
  if (v54 <= v60)
  {
    if (v54 < v60)
    {
      v59 = &v58[12 * v54];
      *(a1 + 184) = v59;
    }
  }

  else
  {
    std::vector<gcl::Vector3<int>>::__append(a1 + 176, v54 - v60);
    v58 = *(a1 + 176);
    v59 = *(a1 + 184);
  }

  if (v59 - v58 >= 1)
  {
    memset(v58, 255, 12 * ((v59 - v58) / 0xCuLL - ((v59 - v58) > 0xB)) + 12);
  }

  v61 = *(a1 + 200);
  v62 = *(a1 + 208);
  v63 = 0xAAAAAAAAAAAAAAABLL * ((v62 - v61) >> 2);
  if (v54 <= v63)
  {
    if (v54 < v63)
    {
      v62 = &v61[12 * v54];
      *(a1 + 208) = v62;
    }
  }

  else
  {
    std::vector<gcl::Vector3<int>>::__append(a1 + 200, v54 - v63);
    v61 = *(a1 + 200);
    v62 = *(a1 + 208);
  }

  if (v62 - v61 >= 1)
  {
    memset(v61, 255, 12 * ((v62 - v61) / 0xCuLL - ((v62 - v61) > 0xB)) + 12);
  }

  if (*(a1 + 3817) != 1 || (*(a1 + 3816) & 1) == 0)
  {
    v64 = *(a1 + 80);
    v65 = *(a1 + 88);
    v66 = (v65 - v64) >> 2;
    if (v54 <= v66)
    {
      if (v54 < v66)
      {
        v65 = &v64[4 * v54];
        *(a1 + 88) = v65;
      }
    }

    else
    {
      std::vector<int>::__append((a1 + 80), v54 - v66);
      v64 = *(a1 + 80);
      v65 = *(a1 + 88);
    }

    if (v65 - v64 >= 1)
    {
      bzero(v64, v65 - v64);
    }
  }

  if (*(a1 + 3816) == 1)
  {
    v68 = *(a1 + 224);
    v67 = *(a1 + 232);
    v69 = 0xAAAAAAAAAAAAAAABLL * ((v67 - v68) >> 2);
    v70 = v54 - v69;
    if (v54 <= v69)
    {
      if (v54 < v69)
      {
        *(a1 + 232) = v68 + 12 * v54;
      }

      goto LABEL_121;
    }

    v71 = *(a1 + 240);
    if (0xAAAAAAAAAAAAAAABLL * ((v71 - v67) >> 2) < v70)
    {
      if (v689 < 0)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v72 = 0xAAAAAAAAAAAAAAABLL * ((v71 - v68) >> 2);
      v73 = 0x5555555555555556 * ((v71 - v68) >> 2);
      if (v73 <= v696)
      {
        v73 = v696;
      }

      if (v72 >= 0xAAAAAAAAAAAAAAALL)
      {
        v74 = 0x1555555555555555;
      }

      else
      {
        v74 = v73;
      }

      if (v74 <= 0x1555555555555555)
      {
        operator new();
      }

      goto LABEL_967;
    }

    v75 = v67 + 12 * v70;
    v76 = 12 * v70 - 12;
    if (v76 >= 0x54)
    {
      v77 = v76 / 0xC + 1;
      v78 = *(a1 + 232);
      v79 = v77 & 0x3FFFFFFFFFFFFFF8;
      do
      {
        *v78 = xmmword_1B33B2490;
        v78[1] = xmmword_1B33B2480;
        v78[4] = xmmword_1B33B2480;
        v78[5] = xmmword_1B33B2470;
        v78[2] = xmmword_1B33B2470;
        v78[3] = xmmword_1B33B2490;
        v78 += 6;
        v79 -= 8;
      }

      while (v79);
      if (v77 == (v77 & 0x3FFFFFFFFFFFFFF8))
      {
        goto LABEL_120;
      }

      v67 += 12 * (v77 & 0x3FFFFFFFFFFFFFF8);
    }

    do
    {
      *(v67 + 8) = -1;
      *v67 = 0xFFFFFFFF00000000;
      v67 += 12;
    }

    while (v67 != v75);
LABEL_120:
    *(a1 + 232) = v75;
LABEL_121:
    v80 = *(a1 + 256);
    if (*(a1 + 264) == v80)
    {
      operator new();
    }

    if (((*(a1 + 264) - v80) & 0x8000000000000000) == 0)
    {
      operator new();
    }

LABEL_966:
    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  v672 = a1 + 2048;
  memset_pattern16((a1 + 2048), &unk_1B33B25C0, 0xAuLL);
  *(a1 + 2058) = 0x8000;
  memset_pattern16((a1 + 2060), &unk_1B33B25C0, 0x10uLL);
  memset_pattern16((a1 + 2076), &unk_1B33B25C0, 0x10uLL);
  memset_pattern16((a1 + 2092), &unk_1B33B25C0, 0x10uLL);
  memset_pattern16((a1 + 2108), &unk_1B33B25C0, 0x10uLL);
  memset_pattern16((a1 + 2124), &unk_1B33B25C0, 0x10uLL);
  memset_pattern16((a1 + 2140), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2146), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2152), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2158), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2164), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2170), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2176), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2182), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2188), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2194), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2200), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2206), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2212), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2218), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2224), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2230), &unk_1B33B25C0, 6uLL);
  memset_pattern16((a1 + 2240), &unk_1B33B25C0, 0x20uLL);
  *(a1 + 2236) = -2147450880;
  *(a1 + 2272) = 0x8000800080008000;
  memset_pattern16((a1 + 2416), &unk_1B33B25C0, 6uLL);
  gcl::tmesh::ACContext::init((a1 + 2424), 3);
  gcl::tmesh::ACContext::init((a1 + 2544), 3);
  if (*(a1 + 3808) == 255)
  {
    return 3;
  }

  v81 = __dst - 4;
  if (__dst < 4)
  {
    v82 = 0;
    v81 = 0;
    v83 = 0;
LABEL_132:
    v84 = 0;
    goto LABEL_133;
  }

  v84 = (v685 + 1);
  v83 = *v685;
  if (v685 == -4)
  {
    v82 = MEMORY[0xFFFFFFFFFFFFFFFC];
    goto LABEL_132;
  }

  v82 = &v84[v83];
LABEL_133:
  if (!v82)
  {
    goto LABEL_16;
  }

  v85 = v81 - v83;
  if (v85 < 0)
  {
    goto LABEL_16;
  }

  v661 = v82;
  v662 = v85;
  *(a1 + 2704) = v83;
  *(a1 + 2712) = v84;
  *&v86 = 0xFFFF000000000000;
  *(&v86 + 1) = 0xFFFF000000000000;
  *(a1 + 2728) = v86;
  *(a1 + 2744) = 16;
  if (!v83)
  {
    v87 = -16777216;
    goto LABEL_141;
  }

  v87 = *v84 << 24;
  *(a1 + 2736) = v87;
  if (v83 == 1)
  {
LABEL_141:
    v88 = v87 | 0xFF0000;
    goto LABEL_142;
  }

  v88 = v87 | (v84[1] << 16);
  *(a1 + 2736) = v88;
  if (v83 <= 2)
  {
LABEL_142:
    v89 = v88 | 0xFF00;
    goto LABEL_143;
  }

  v89 = v88 | (v84[2] << 8);
  *(a1 + 2736) = v89;
  if (v83 == 3)
  {
LABEL_143:
    v90 = 255;
    goto LABEL_144;
  }

  v90 = v84[3];
LABEL_144:
  *(a1 + 2736) = v90 | v89;
  *(a1 + 2720) = 3;
  __dsta = (a1 + 2752);
  memcpy((a1 + 2752), &gcl::ArithmeticDecoder::probUpdateLutInterleaved, 0x400uLL);
  v674 = a6;
  if (*(a1 + 3800))
  {
    v674 = *(a1 + 128);
  }

  v697 = *(a1 + 104);
  if (*(a1 + 3816) == 1)
  {
    v95 = *(a1 + 3792);
    v701 = 0;
    *__b = 0;
    v96 = *(a1 + 3788);
    if (v96 < 1)
    {
      goto LABEL_503;
    }

    v97 = 0;
    v663 = v95 + 1;
    v680 = a1 + 256;
    v690 = a1 + 1792;
    v664 = a1 + 264;
    LODWORD(v670) = -1;
    while (1)
    {
      if (v97 != *__b)
      {
        goto LABEL_232;
      }

      ++*__b;
      if (*(a1 + 3820))
      {
        v153 = -1;
      }

      else
      {
        v153 = v670;
      }

      v154 = 12 * v97;
      *(*(a1 + 176) + 12 * v97) = v153;
      v660 = v97;
      v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, v97, v697, v91, v92, v93, v94);
      v155 = (*(a1 + 224) + v154);
      if (*v155 >= 63)
      {
        v156 = 63;
      }

      else
      {
        v156 = *v155;
      }

      v157 = *(a1 + 252);
      if (v156 > v157)
      {
        v157 = v156;
      }

      *(a1 + 252) = v157;
      v158 = v680 + 24 * v156;
      v160 = *v158;
      v159 = *(v158 + 8);
      v161 = v159 - *v158;
      v155[1] = v156;
      v155[2] = v161 >> 3;
      v162 = *(v158 + 16);
      if (v159 >= v162)
      {
        v164 = (v161 >> 3) + 1;
        if (v164 >> 61)
        {
          goto LABEL_966;
        }

        v165 = v162 - v160;
        if (v165 >> 2 > v164)
        {
          v164 = v165 >> 2;
        }

        v123 = v165 >= 0x7FFFFFFFFFFFFFF8;
        v166 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v123)
        {
          v166 = v164;
        }

        if (v166)
        {
          if (!(v166 >> 61))
          {
            operator new();
          }

LABEL_967:
          std::__throw_bad_array_new_length[abi:ne200100]();
        }

        v167 = (8 * (v161 >> 3));
        *v167 = v155;
        v163 = (v167 + 1);
        memcpy(0, v160, v161);
        *v158 = 0;
        *(v158 + 8) = v163;
        *(v158 + 16) = 0;
        if (v160)
        {
          operator delete(v160);
          v160 = *v158;
        }

        else
        {
          v160 = 0;
        }
      }

      else
      {
        *v159 = v155;
        v163 = (v159 + 1);
      }

      *(v158 + 8) = v163;
      ++*(a1 + 248);
      v168 = (v163 - v160) >> 3;
      if (*(v690 + 4 * v156) > v168)
      {
        LODWORD(v168) = *(v690 + 4 * v156);
      }

      *(v690 + 4 * v156) = v168;
      v169 = *(a1 + 248);
      if (v169)
      {
        break;
      }

LABEL_231:
      v96 = *(a1 + 3788);
      v97 = v660;
LABEL_232:
      if (++v97 >= v96)
      {
        goto LABEL_503;
      }
    }

    while (1)
    {
      v170 = *(a1 + 252);
      if ((v170 & 0x80000000) != 0)
      {
        v173 = 0;
      }

      else
      {
        v171 = v680 + 24 * v170;
        v172 = *(v171 + 8);
        v173 = *(v172 - 8);
        *(v171 + 8) = v172 - 8;
        *(v173 + 8) = -1;
        *(a1 + 248) = --v169;
        if (v169)
        {
          v174 = (v664 + 24 * v170);
          do
          {
            if (*(v174 - 1) != *v174)
            {
              break;
            }

            *(a1 + 252) = v170 - 1;
            v174 -= 3;
            v620 = v170-- <= 0;
          }

          while (!v620);
        }

        else
        {
          *(a1 + 252) = -1;
        }
      }

      v670 = 0xAAAAAAAAAAAAAAABLL * ((v173 - *(a1 + 224)) >> 2);
      v175 = *(*(a1 + 152) + 16 * v670);
      v176 = *(*(a1 + 152) + 16 * v670 + 4);
      v177 = v175 != -1;
      v178 = v176 == v175 && v175 != -1;
      v179 = (v177 | (2 * (v176 != -1))) + v178;
      v180 = *(v672 + 2 * v179);
      v181 = *(a1 + 2732);
      v182 = *(a1 + 2736);
      if (v181 >= 0x40000001)
      {
        v185 = *(a1 + 2732);
      }

      else
      {
        v183 = *(a1 + 2744);
        do
        {
          v182 *= 2;
          *(a1 + 2744) = --v183;
          if (!v183)
          {
            v186 = *(a1 + 2720);
            *(a1 + 2720) = v186 + 1;
            v187 = *(a1 + 2704);
            if (v186 + 1 >= v187)
            {
              v188 = 65280;
            }

            else
            {
              v188 = *(*(a1 + 2712) + v186 + 1) << 8;
            }

            v189 = v186 + 2;
            *(a1 + 2720) = v189;
            if (v189 < v187)
            {
              v184 = *(*(a1 + 2712) + v189);
            }

            else
            {
              v184 = 255;
            }

            v182 |= v188 | v184;
            v183 = 16;
            *(a1 + 2744) = 16;
          }

          v185 = 2 * v181;
          v123 = v181 >= 0x20000001;
          v181 *= 2;
        }

        while (!v123);
      }

      v190 = (HIWORD(v185) * v180) & 0xFFFF0000;
      v191 = v182 < v190 ? 0 : (HIWORD(v185) * v180) & 0xFFFF0000;
      *(a1 + 2736) = v182 - v191;
      v192 = v182 >= v190;
      v193 = v182 < v190 ? (v180 >> 7) & 0x1FE : ((v180 >> 7) & 0x1FE) + 1;
      v194 = v185 - v190;
      *(v672 + 2 * v179) = __dsta[v193] + v180;
      v195 = v192 ? v194 : v190;
      *(a1 + 2732) = v195;
      if (v192)
      {
        break;
      }

LABEL_259:
      if (!v169)
      {
        goto LABEL_231;
      }
    }

    v665 = (v697 + 12 * v670);
    v196 = a1 + 256;
    while (2)
    {
      v700 = 0;
      v204 = gcl::tmesh::DecoderImpl::decompressTFanConnectivity(a1, v670, v179, v674, &v700, __b, &v701);
      v205 = v204;
      if (v204 < 0 || v204 > v663)
      {
        goto LABEL_502;
      }

      if (v700 != 3 && v700 != 5)
      {
        if (v204)
        {
          v209 = 0;
          do
          {
            if (*(*(a1 + 32) + v209))
            {
              v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, *(*(a1 + 8) + 4 * v209), v697, v91, v92, v93, v94);
            }

            ++v209;
          }

          while (v205 != v209);
          goto LABEL_325;
        }

LABEL_487:
        if (*(a1 + 3872))
        {
          goto LABEL_503;
        }

        v310 = *(*(a1 + 152) + 16 * v670);
        v311 = *(*(a1 + 152) + 16 * v670 + 4);
        v312 = v311 != -1;
        v313 = v310 != -1;
        v314 = v311 == v310 && v310 != -1;
        v315 = *(a1 + 2732);
        v316 = *(a1 + 2736);
        if (v315 >= 0x40000001)
        {
          v197 = *(a1 + 2732);
        }

        else
        {
          v317 = *(a1 + 2744);
          do
          {
            v316 *= 2;
            *(a1 + 2744) = --v317;
            if (!v317)
            {
              v319 = *(a1 + 2720);
              *(a1 + 2720) = v319 + 1;
              v320 = *(a1 + 2704);
              if (v319 + 1 >= v320)
              {
                v321 = 65280;
              }

              else
              {
                v321 = *(*(a1 + 2712) + v319 + 1) << 8;
              }

              v322 = v319 + 2;
              *(a1 + 2720) = v322;
              if (v322 < v320)
              {
                v318 = *(*(a1 + 2712) + v322);
              }

              else
              {
                v318 = 255;
              }

              v316 |= v321 | v318;
              v317 = 16;
              *(a1 + 2744) = 16;
            }

            v197 = 2 * v315;
            v123 = v315 >= 0x20000001;
            v315 *= 2;
          }

          while (!v123);
        }

        v179 = (v313 | (2 * v312)) + v314;
        v198 = *(a1 + 2058);
        v199 = (HIWORD(v197) * v198) & 0xFFFF0000;
        if (v316 < v199)
        {
          v200 = 0;
        }

        else
        {
          v200 = (HIWORD(v197) * v198) & 0xFFFF0000;
        }

        *(a1 + 2736) = v316 - v200;
        v201 = v316 >= v199;
        if (v316 < v199)
        {
          v202 = (v198 >> 7) & 0x1FE;
        }

        else
        {
          v202 = ((v198 >> 7) & 0x1FE) + 1;
        }

        *(a1 + 2058) = __dsta[v202] + v198;
        if (v201)
        {
          v203 = v197 - v199;
        }

        else
        {
          v203 = (HIWORD(v197) * v198) & 0xFFFF0000;
        }

        *(a1 + 2732) = v203;
        if (!v201)
        {
          v169 = *(a1 + 248);
          goto LABEL_259;
        }

        continue;
      }

      break;
    }

    if (!v204)
    {
      goto LABEL_487;
    }

    v207 = v204 - 1;
    do
    {
      if (*(*(a1 + 32) + v207))
      {
        v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, *(*(a1 + 8) + 4 * v207), v697, v91, v92, v93, v94);
      }

      v208 = v207-- + 1;
    }

    while (v208 > 1);
LABEL_325:
    if (v205 > 1)
    {
      v210 = *(a1 + 224);
      if (*(a1 + 3818) == 1)
      {
        v211 = v205 - 1;
        v212 = (*v671 + 4);
        v196 = a1 + 256;
        while (1)
        {
          v214 = *(v212 - 1);
          v213 = *v212;
          v215 = v697 + 12 * v214;
          v216 = v697 + 12 * *v212;
          v217 = *v216;
          v218.i64[0] = *v215;
          v219 = *v216 - *v215;
          v220 = *(v216 + 4);
          v221 = *(v215 + 8);
          v222 = v665[1].i32[0];
          v223 = v222 - v221;
          if (v219 >= 0)
          {
            v224 = v219;
          }

          else
          {
            v224 = -v219;
          }

          *v225.i8 = *v665;
          v225.u64[1] = v220;
          v218.i64[1] = __PAIR64__(v221, v218.u32[1]);
          v93 = vsubq_s32(v225, v218);
          v226 = vabdq_s32(v225, v218);
          v225.i64[0] = 0x100000001000;
          v225.i64[1] = 0x100000001000;
          v94 = vcgtq_u32(v225, v226);
          *v94.i8 = vmovn_s32(v94);
          v227 = (v224 < 0x1000) & v94.i8[4] & v94.i8[6];
          if (v223 >= 0)
          {
            v228 = v222 - v221;
          }

          else
          {
            v228 = v221 - v222;
          }

          if (v227 == 1 && (v94.i8[0] & 1) != 0 && (v94.i8[2] & 1) != 0 && v228 <= 0xFFF)
          {
            v229 = v93.i32[2];
            v230 = v93.i32[3];
            v231 = v93.i32[0] * v219 + v93.i32[1] * v93.i32[2] + v223 * v93.i32[3];
            if (!v231)
            {
              goto LABEL_380;
            }

            v232 = v223 * v93.i32[2] - v93.i32[1] * v93.i32[3];
            if (v232 < 0)
            {
              v232 = v93.i32[1] * v93.i32[3] - v223 * v93.i32[2];
            }

            v233 = v93.i32[0] * v93.i32[3] - v223 * v219;
            if (v233 < 0)
            {
              v233 = -v233;
            }

            v234 = v93.i32[1] * v219 - v93.i32[0] * v93.i32[2];
            if (v234 < 0)
            {
              v234 = v93.i32[0] * v93.i32[2] - v93.i32[1] * v219;
            }

            v235 = v232 + v233;
            if (v233 < v234)
            {
              v236 = v234;
            }

            else
            {
              v235 = v232 + v234;
              v236 = v233;
            }

            v237 = v232 >= v233 && v232 >= v234;
            if (v237)
            {
              v238 = v233 + v234;
            }

            else
            {
              v238 = v235;
            }

            if (v237)
            {
              v239 = v232;
            }

            else
            {
              v239 = v236;
            }

            v240 = v239 + (v238 >> 2);
            if (v231 < 0)
            {
              LODWORD(v241) = -16 * v231 / (v240 - v231) + 16;
            }

            else
            {
              LODWORD(v241) = (16 * v240) / (v240 + v231);
            }
          }

          else
          {
            v229 = v93.i32[2];
            v230 = v93.i32[3];
            v242 = v93.i32[1] * v93.i32[2] + v93.i32[0] * v219 + v223 * v93.i32[3];
            if (!v242)
            {
LABEL_380:
              LODWORD(v241) = 16;
              goto LABEL_383;
            }

            v243 = v223 * v93.i32[2] - v93.i32[1] * v93.i32[3];
            if (v243 < 0)
            {
              v243 = v93.i32[1] * v93.i32[3] - v223 * v93.i32[2];
            }

            v244 = v93.i32[0] * v93.i32[3] - v223 * v219;
            if (v244 < 0)
            {
              v244 = -v244;
            }

            v245 = v93.i32[1] * v219 - v93.i32[0] * v93.i32[2];
            if (v245 < 0)
            {
              v245 = v93.i32[0] * v93.i32[2] - v93.i32[1] * v219;
            }

            v246 = v243 + v244;
            if (v244 < v245)
            {
              v247 = v245;
            }

            else
            {
              v246 = v243 + v245;
              v247 = v244;
            }

            v248 = v243 >= v244 && v243 >= v245;
            if (v248)
            {
              v249 = v244 + v245;
            }

            else
            {
              v249 = v246;
            }

            if (v248)
            {
              v250 = v243;
            }

            else
            {
              v250 = v247;
            }

            v241 = v250 + (v249 >> 2);
            if (v242 < 0)
            {
              LODWORD(v241) = -16 * v242 / (v241 - v242) + 16;
            }

            else
            {
              v241 = 16 * v241 / (v241 + v242);
            }
          }

LABEL_383:
          v251 = *v665 - v217;
          v92.i32[0] = vsub_s32(vdup_lane_s32(*v665, 1), v220).u32[0];
          v253 = v222 - v220.i32[1];
          v252 = v222 - v220.i32[1] < 0;
          v254 = -v219;
          v255 = -v229;
          v256 = -v230;
          v92.i32[1] = v251;
          *v91.i8 = vcgt_u32(0x100000001000, vabs_s32(*v92.i8));
          v257 = v227 & v91.i32[1];
          if (v252)
          {
            v258 = -v253;
          }

          else
          {
            v258 = v253;
          }

          if (v257 == 1 && (v91.i8[0] & 1) != 0 && v258 <= 0xFFF)
          {
            v259 = v251 * v254 + v92.i32[0] * v255 + v253 * v256;
            if (v259)
            {
              v260 = v92.i32[0] * v230 + v253 * v255;
              if (v260 < 0)
              {
                v260 = -v260;
              }

              v261 = v251 * v256 + v253 * v219;
              if (v261 < 0)
              {
                v261 = -v261;
              }

              v262 = v251 * v229 + v92.i32[0] * v254;
              if (v262 < 0)
              {
                v262 = -v262;
              }

              v263 = v260 + v261;
              if (v261 < v262)
              {
                v264 = v262;
              }

              else
              {
                v263 = v260 + v262;
                v264 = v261;
              }

              v265 = v260 >= v261 && v260 >= v262;
              if (v265)
              {
                v266 = v261 + v262;
              }

              else
              {
                v266 = v263;
              }

              if (v265)
              {
                v267 = v260;
              }

              else
              {
                v267 = v264;
              }

              v268 = v267 + (v266 >> 2);
              if (v259 < 0)
              {
                LODWORD(v269) = -16 * v259 / (v268 - v259) + 16;
              }

              else
              {
                LODWORD(v269) = (16 * v268) / (v268 + v259);
              }

              goto LABEL_434;
            }
          }

          else
          {
            v269 = v92.i32[0] * v255 + v251 * v254 + v253 * v256;
            if (v269)
            {
              v270 = v253 * v255 - v92.i32[0] * v256;
              if (v270 < 0)
              {
                v270 = v92.i32[0] * v256 - v253 * v255;
              }

              v271 = v251 * v256 - v253 * v254;
              if (v271 < 0)
              {
                v271 = v253 * v254 - v251 * v256;
              }

              v272 = v92.i32[0] * v254 - v251 * v255;
              if (v272 < 0)
              {
                v272 = -v272;
              }

              v273 = v270 + v271;
              if (v271 < v272)
              {
                v274 = v272;
              }

              else
              {
                v273 = v270 + v272;
                v274 = v271;
              }

              v275 = v270 >= v271 && v270 >= v272;
              if (v275)
              {
                v276 = v271 + v272;
              }

              else
              {
                v276 = v273;
              }

              if (v275)
              {
                v277 = v270;
              }

              else
              {
                v277 = v274;
              }

              v278 = v277 + (v276 >> 2);
              if (v269 < 0)
              {
                LODWORD(v269) = -16 * v269 / (v278 - v269) + 16;
              }

              else
              {
                v269 = (16 * v278) / (v278 + v269);
              }

              goto LABEL_434;
            }
          }

          LODWORD(v269) = 16;
LABEL_434:
          v279 = 12 * v214;
          *(v210 + v279) += v241;
          v280 = 12 * v213;
          v281 = *(v210 + v280) + v269;
          *(v210 + v280) = v281;
          if ((*(v210 + v279) & 0x80000000) != 0 || v281 < 0)
          {
            goto LABEL_502;
          }

          if (*(a1 + 3872))
          {
            goto LABEL_503;
          }

          ++v212;
          if (!--v211)
          {
            goto LABEL_441;
          }
        }
      }

      v282 = v205 - 1;
      v283 = (*v671 + 4);
      v196 = a1 + 256;
      do
      {
        v284 = *v283;
        *(v210 + 12 * *(v283 - 1)) += 8;
        *(v210 + 12 * v284) += 8;
        ++v283;
        --v282;
      }

      while (v282);
    }

LABEL_441:
    if (v205 < 1)
    {
      goto LABEL_487;
    }

    v285 = 0;
    v286 = v205;
    __n = v205;
    while (1)
    {
      v289 = (*(a1 + 224) + 12 * *(*(a1 + 8) + 4 * v285));
      if (*(*(a1 + 32) + v285))
      {
        if (*v289 >= 63)
        {
          v290 = 63;
        }

        else
        {
          v290 = *v289;
        }

        LODWORD(v291) = *(a1 + 252);
        if (v290 > v291)
        {
          LODWORD(v291) = v290;
        }
      }

      else
      {
        v292 = v289[2];
        if ((v292 & 0x80000000) != 0)
        {
          goto LABEL_447;
        }

        v293 = v289[1];
        v295 = *(v196 + 24 * v293);
        v294 = *(v196 + 24 * v293 + 8);
        v296 = ((v294 - v295) >> 3) - 1;
        if (v292 != v296)
        {
          v297 = *(v295 + 8 * v292);
          *(v295 + 8 * v292) = *(v295 + 8 * v296);
          *(v295 + 8 * v296) = v297;
          *(*(v295 + 8 * v292) + 8) = v292;
          *(v297 + 8) = v296;
        }

        v298 = *(v294 - 8);
        *(v196 + 24 * v293 + 8) = v294 - 8;
        *(v298 + 8) = -1;
        v299 = *(a1 + 248) - 1;
        *(a1 + 248) = v299;
        if (v299)
        {
          v291 = *(a1 + 252);
          if ((v291 & 0x80000000) == 0)
          {
            v300 = (v664 + 24 * v291);
            while (*(v300 - 1) == *v300)
            {
              *(a1 + 252) = v291 - 1;
              v300 -= 3;
              v620 = v291-- <= 0;
              if (v620)
              {
                LODWORD(v291) = -1;
                break;
              }
            }

            if (!v298)
            {
              goto LABEL_447;
            }
          }
        }

        else
        {
          LODWORD(v291) = -1;
          *(a1 + 252) = -1;
        }

        if (*v289 >= 63)
        {
          v290 = 63;
        }

        else
        {
          v290 = *v289;
        }

        if (v290 > v291)
        {
          LODWORD(v291) = v290;
        }
      }

      *(a1 + 252) = v291;
      v301 = v196 + 24 * v290;
      v303 = *v301;
      v302 = *(v301 + 8);
      v304 = v302 - *v301;
      v289[1] = v290;
      v289[2] = v304 >> 3;
      v305 = *(v301 + 16);
      if (v302 < v305)
      {
        *v302 = v289;
        v287 = (v302 + 1);
      }

      else
      {
        v306 = (v304 >> 3) + 1;
        if (v306 >> 61)
        {
          goto LABEL_966;
        }

        v307 = v305 - v303;
        if (v307 >> 2 > v306)
        {
          v306 = v307 >> 2;
        }

        if (v307 >= 0x7FFFFFFFFFFFFFF8)
        {
          v308 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v308 = v306;
        }

        v686 = v285;
        if (v308)
        {
          if (!(v308 >> 61))
          {
            operator new();
          }

          goto LABEL_967;
        }

        v309 = (8 * (v304 >> 3));
        *v309 = v289;
        v287 = (v309 + 1);
        memcpy(0, v303, v304);
        *v301 = 0;
        *(v301 + 8) = v287;
        *(v301 + 16) = 0;
        if (v303)
        {
          operator delete(v303);
          v303 = *v301;
        }

        else
        {
          v303 = 0;
        }

        v286 = __n;
        v196 = a1 + 256;
        v285 = v686;
      }

      *(v301 + 8) = v287;
      ++*(a1 + 248);
      v288 = (v287 - v303) >> 3;
      if (*(v690 + 4 * v290) > v288)
      {
        LODWORD(v288) = *(v690 + 4 * v290);
      }

      *(v690 + 4 * v290) = v288;
LABEL_447:
      if (++v285 == v286)
      {
        goto LABEL_487;
      }
    }
  }

  v701 = 0;
  if (*(a1 + 3788) < 1)
  {
    goto LABEL_503;
  }

  v98 = 0;
  v99 = 0;
  v691 = 0;
  LODWORD(v100) = -1;
  while (v99 != v98)
  {
    v101 = v98;
LABEL_229:
    ++v99;
    v98 = v101;
    if (v99 >= *(a1 + 3788))
    {
      goto LABEL_503;
    }
  }

  v101 = (v98 + 1);
  *__b = v98 + 1;
  if (*(a1 + 3820))
  {
    v102 = -1;
  }

  else
  {
    v102 = v100;
  }

  *(*(a1 + 176) + 12 * v99) = v102;
  v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, v99, v697, v91, v92, v93, v94);
  if (v691 > v98)
  {
    goto LABEL_229;
  }

  v103 = v691;
  v104 = *(a1 + 152);
  v105 = *(a1 + 2732);
  v106 = *(a1 + 2736);
  while (1)
  {
    v100 = v103;
    v109 = (v104 + 16 * v103);
    v107 = *v109;
    v108 = v109[1];
    v110 = *v109 != -1;
    v111 = v108 == *v109 && v107 != -1;
    v112 = (v110 | (2 * (v108 != -1))) + v111;
    if (v105 >= 0x40000001)
    {
      v115 = v105;
    }

    else
    {
      v113 = *(a1 + 2744);
      do
      {
        v106 *= 2;
        *(a1 + 2744) = --v113;
        if (!v113)
        {
          v116 = *(a1 + 2720);
          *(a1 + 2720) = v116 + 1;
          v117 = *(a1 + 2704);
          if (v116 + 1 >= v117)
          {
            v118 = 65280;
          }

          else
          {
            v118 = *(*(a1 + 2712) + v116 + 1) << 8;
          }

          v119 = v116 + 2;
          *(a1 + 2720) = v119;
          if (v119 < v117)
          {
            v114 = *(*(a1 + 2712) + v119);
          }

          else
          {
            v114 = 255;
          }

          v106 |= v118 | v114;
          v113 = 16;
          *(a1 + 2744) = 16;
        }

        v115 = 2 * v105;
        v123 = v105 >= 0x20000001;
        v105 *= 2;
      }

      while (!v123);
    }

    v120 = *(v672 + 2 * v112);
    v105 = (HIWORD(v115) * v120) & 0xFFFF0000;
    v121 = v106 < v105 ? 0 : (HIWORD(v115) * v120) & 0xFFFF0000;
    v122 = v106 - v121;
    *(a1 + 2736) = v122;
    v123 = v106 >= v105;
    v124 = v106 < v105 ? (v120 >> 7) & 0x1FE : ((v120 >> 7) & 0x1FE) + 1;
    v125 = v115 - v105;
    *(v672 + 2 * v112) = __dsta[v124] + v120;
    v126 = v123 ? v125 : v105;
    *(a1 + 2732) = v126;
    if (v123)
    {
      break;
    }

    v106 = v122;
LABEL_226:
    v103 = v100 + 1;
    if (v100 + 1 >= v101)
    {
      v691 = v100 + 1;
      goto LABEL_229;
    }
  }

  while (1)
  {
    v700 = 0;
    v132 = gcl::tmesh::DecoderImpl::decompressTFanConnectivity(a1, v100, v112, v674, &v700, __b, &v701);
    if ((v132 & 0x80000000) != 0 || v132 > *(a1 + 3792) + 1)
    {
      break;
    }

    if (v700 == 3 || v700 == 5)
    {
      if (v132)
      {
        v134 = v132 - 1;
        do
        {
          if (*(*(a1 + 32) + v134))
          {
            v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, *(*(a1 + 8) + 4 * v134), v697, v91, v92, v93, v94);
          }

          v135 = v134-- + 1;
        }

        while (v135 > 1);
      }
    }

    else if (v132)
    {
      v136 = 0;
      v137 = v132;
      do
      {
        if (*(*(a1 + 32) + v136))
        {
          v91 = gcl::tmesh::DecoderImpl::decompressGeometry(a1, *(*(a1 + 8) + 4 * v136), v697, v91, v92, v93, v94);
        }

        ++v136;
      }

      while (v137 != v136);
    }

    v104 = *(a1 + 152);
    v138 = (v104 + 16 * v100);
    v140 = *v138;
    v139 = v138[1];
    v141 = v139 != -1;
    v142 = v140 != -1;
    v143 = v139 == v140 && v140 != -1;
    v144 = *(a1 + 2058);
    v145 = *(a1 + 2732);
    v146 = *(a1 + 2736);
    if (v145 >= 0x40000001)
    {
      v127 = *(a1 + 2732);
    }

    else
    {
      v147 = *(a1 + 2744);
      do
      {
        v146 *= 2;
        *(a1 + 2744) = --v147;
        if (!v147)
        {
          v149 = *(a1 + 2720);
          *(a1 + 2720) = v149 + 1;
          v150 = *(a1 + 2704);
          if (v149 + 1 >= v150)
          {
            v151 = 65280;
          }

          else
          {
            v151 = *(*(a1 + 2712) + v149 + 1) << 8;
          }

          v152 = v149 + 2;
          *(a1 + 2720) = v152;
          if (v152 < v150)
          {
            v148 = *(*(a1 + 2712) + v152);
          }

          else
          {
            v148 = 255;
          }

          v146 |= v151 | v148;
          v147 = 16;
          *(a1 + 2744) = 16;
        }

        v127 = 2 * v145;
        v123 = v145 >= 0x20000001;
        v145 *= 2;
      }

      while (!v123);
    }

    v112 = (v142 | (2 * v141)) + v143;
    v105 = (HIWORD(v127) * v144) & 0xFFFF0000;
    if (v146 < v105)
    {
      v128 = 0;
    }

    else
    {
      v128 = (HIWORD(v127) * v144) & 0xFFFF0000;
    }

    v106 = v146 - v128;
    *(a1 + 2736) = v106;
    v129 = v146 >= v105;
    if (v146 < v105)
    {
      v130 = (v144 >> 7) & 0x1FE;
    }

    else
    {
      v130 = ((v144 >> 7) & 0x1FE) + 1;
    }

    *(a1 + 2058) = __dsta[v130] + v144;
    if (v129)
    {
      v131 = v127 - v105;
    }

    else
    {
      v131 = (HIWORD(v127) * v144) & 0xFFFF0000;
    }

    *(a1 + 2732) = v131;
    if (!v129)
    {
      v101 = *__b;
      goto LABEL_226;
    }
  }

LABEL_502:
  *(a1 + 3872) = 3;
LABEL_503:
  if (*(a1 + 3800) != 1)
  {
    begin = *(a1 + 56);
    v327 = *(a1 + 64) - begin;
    if ((v327 >> 2) > 1)
    {
      if (v327 != 8)
      {
        *(a1 + 64) = begin + 2;
      }
    }

    else
    {
      std::vector<int>::__append(v668, 2 - (v327 >> 2));
      begin = v668->__begin_;
    }

    *begin = 0;
    begin[1] = *(a1 + 3792);
    goto LABEL_515;
  }

  if (!a7)
  {
LABEL_507:
    result = 5;
    goto LABEL_508;
  }

  v323 = v662 - 4;
  if (v662 < 4)
  {
    v324 = 0;
    v323 = 0;
    v325 = 0;
    goto LABEL_533;
  }

  v325 = *v661;
  if (v661 == -4)
  {
    v324 = MEMORY[0xFFFFFFFFFFFFFFFC];
LABEL_533:
    v338 = 0;
  }

  else
  {
    v338 = (v661 + 1);
    v324 = v661 + v325 + 4;
  }

  if (!v324 || v323 < v325)
  {
    goto LABEL_16;
  }

  *(a1 + 2704) = v325;
  *(a1 + 2712) = v338;
  *&v345 = 0xFFFF000000000000;
  *(&v345 + 1) = 0xFFFF000000000000;
  *(a1 + 2728) = v345;
  *(a1 + 2744) = 16;
  if (!v325)
  {
    v346 = -16777216;
    goto LABEL_542;
  }

  v346 = *v338 << 24;
  *(a1 + 2736) = v346;
  if (v325 == 1)
  {
LABEL_542:
    v347 = v346 | 0xFF0000;
    goto LABEL_543;
  }

  v347 = v346 | (v338[1] << 16);
  *(a1 + 2736) = v347;
  if (v325 <= 2)
  {
LABEL_543:
    v348 = v347 | 0xFF00;
    goto LABEL_544;
  }

  v348 = v347 | (v338[2] << 8);
  *(a1 + 2736) = v348;
  if (v325 != 3)
  {
    v349 = v338[3];
    goto LABEL_545;
  }

LABEL_544:
  v349 = 255;
LABEL_545:
  *(a1 + 2736) = v349 | v348;
  *(a1 + 2720) = 3;
  memcpy(__dsta, &gcl::ArithmeticDecoder::probUpdateLutInterleaved, 0x400uLL);
  if (*(a1 + 3808))
  {
    memset_pattern16(__b, &unk_1B33B25C0, 0x80uLL);
    LOWORD(v701) = 0x8000;
    LODWORD(v350) = *(a1 + 3792);
    if (v350 >= 1)
    {
      v351 = 0;
      v352 = 0;
      v698 = 0x8000;
      v673 = 6;
      v692 = __b[0];
      v353 = 0x8000;
      v354 = a7;
      do
      {
        v356 = *(a1 + 2732);
        v357 = *(a1 + 2736);
        if (v356 >= 0x40000001)
        {
          v360 = *(a1 + 2732);
        }

        else
        {
          v358 = *(a1 + 2744);
          do
          {
            v357 *= 2;
            *(a1 + 2744) = --v358;
            if (!v358)
            {
              v361 = *(a1 + 2720);
              *(a1 + 2720) = v361 + 1;
              v362 = *(a1 + 2704);
              if (v361 + 1 >= v362)
              {
                v363 = 65280;
              }

              else
              {
                v363 = *(*(a1 + 2712) + v361 + 1) << 8;
              }

              v364 = v361 + 2;
              *(a1 + 2720) = v364;
              if (v364 < v362)
              {
                v359 = *(*(a1 + 2712) + v364);
              }

              else
              {
                v359 = 255;
              }

              v357 |= v363 | v359;
              v358 = 16;
              *(a1 + 2744) = 16;
            }

            v360 = 2 * v356;
            v123 = v356 >= 0x20000001;
            v356 *= 2;
          }

          while (!v123);
        }

        v365 = (HIWORD(v360) * v353) & 0xFFFF0000;
        v366 = v360 - v365;
        if (v357 < v365)
        {
          v367 = 0;
        }

        else
        {
          v367 = (HIWORD(v360) * v353) & 0xFFFF0000;
        }

        v368 = v357 - v367;
        *(a1 + 2736) = v357 - v367;
        v369 = v357 >= v365;
        if (v357 < v365)
        {
          v370 = v365;
        }

        else
        {
          v370 = v366;
        }

        *(a1 + 2732) = v370;
        v371 = (v353 >> 7) & 0x1FE;
        if (v369)
        {
          ++v371;
        }

        v372 = __dsta[v371];
        if (v369)
        {
          v683 = v372;
          v687 = v352;
          if (v366 >= 0x40000001)
          {
            v375 = v366;
          }

          else
          {
            v373 = *(a1 + 2744);
            do
            {
              v368 *= 2;
              *(a1 + 2744) = --v373;
              if (!v373)
              {
                v376 = *(a1 + 2720);
                *(a1 + 2720) = v376 + 1;
                v377 = *(a1 + 2704);
                if (v376 + 1 >= v377)
                {
                  v378 = 65280;
                }

                else
                {
                  v378 = *(*(a1 + 2712) + v376 + 1) << 8;
                }

                v379 = v376 + 2;
                *(a1 + 2720) = v379;
                if (v379 < v377)
                {
                  v374 = *(*(a1 + 2712) + v379);
                }

                else
                {
                  v374 = 255;
                }

                v368 |= v378 | v374;
                v373 = 16;
                *(a1 + 2744) = 16;
              }

              v375 = 2 * v366;
              v123 = v366 >= 0x20000001;
              v366 *= 2;
            }

            while (!v123);
          }

          v380 = (HIWORD(v375) * v698) & 0xFFFF0000;
          v381 = (v698 >> 7) & 0x1FE;
          v382 = v375 - v380;
          if (v368 >= v380)
          {
            ++v381;
          }

          __na = __dsta[v381];
          if (v368 < v380)
          {
            v382 = v380;
          }

          v681 = v380;
          if (v368 < v380)
          {
            v383 = 0;
          }

          else
          {
            v383 = v380;
          }

          v384 = v368 - v383;
          *(a1 + 2732) = v382;
          *(a1 + 2736) = v384;
          if (v382 >= 0x40000001)
          {
            v387 = v382;
          }

          else
          {
            v385 = *(a1 + 2744);
            do
            {
              v384 *= 2;
              *(a1 + 2744) = --v385;
              if (!v385)
              {
                v388 = *(a1 + 2720);
                *(a1 + 2720) = v388 + 1;
                v389 = *(a1 + 2704);
                if (v388 + 1 >= v389)
                {
                  v390 = 65280;
                }

                else
                {
                  v390 = *(*(a1 + 2712) + v388 + 1) << 8;
                }

                v391 = v388 + 2;
                *(a1 + 2720) = v391;
                if (v391 < v389)
                {
                  v386 = *(*(a1 + 2712) + v391);
                }

                else
                {
                  v386 = 255;
                }

                v384 |= v390 | v386;
                v385 = 16;
                *(a1 + 2744) = 16;
              }

              v387 = 2 * v382;
              v123 = v382 >= 0x20000001;
              v382 *= 2;
            }

            while (!v123);
          }

          v392 = (HIWORD(v387) * v692) & 0xFFFF0000;
          v393 = (v692 >> 7) & 0x1FE;
          v394 = v387 - v392;
          v395 = v384 >= v392;
          if (v384 >= v392)
          {
            ++v393;
          }

          v675 = __dsta[v393];
          if (v384 < v392)
          {
            v396 = v392;
          }

          else
          {
            v396 = v394;
          }

          if (v384 < v392)
          {
            v392 = 0;
          }

          v397 = v384 - v392;
          *(a1 + 2732) = v396;
          *(a1 + 2736) = v397;
          v398 = (v395 & 0x7FFFFFF) + 1;
          v399 = __b[v398];
          if (v396 >= 0x40000001)
          {
            v402 = v396;
          }

          else
          {
            v400 = *(a1 + 2744);
            do
            {
              v397 *= 2;
              *(a1 + 2744) = --v400;
              if (!v400)
              {
                v403 = *(a1 + 2720);
                *(a1 + 2720) = v403 + 1;
                v404 = *(a1 + 2704);
                if (v403 + 1 >= v404)
                {
                  v405 = 65280;
                }

                else
                {
                  v405 = *(*(a1 + 2712) + v403 + 1) << 8;
                }

                v406 = v403 + 2;
                *(a1 + 2720) = v406;
                if (v406 < v404)
                {
                  v401 = *(*(a1 + 2712) + v406);
                }

                else
                {
                  v401 = 255;
                }

                v397 |= v405 | v401;
                v400 = 16;
                *(a1 + 2744) = 16;
              }

              v402 = 2 * v396;
              v123 = v396 >= 0x20000001;
              v396 *= 2;
            }

            while (!v123);
          }

          v407 = 32 * v395;
          v408 = (HIWORD(v402) * v399) & 0xFFFF0000;
          v409 = (v399 >> 7) & 0x1FE;
          v410 = v402 - v408;
          if (v397 >= v408)
          {
            ++v409;
          }

          __b[v398] = __dsta[v409] + v399;
          v411 = v397 >= v408;
          if (v397 < v408)
          {
            v412 = v408;
          }

          else
          {
            v412 = v410;
          }

          if (v397 < v408)
          {
            v408 = 0;
          }

          v413 = v397 - v408;
          *(a1 + 2732) = v412;
          *(a1 + 2736) = v413;
          v414 = v407 | (16 * v411);
          v415 = (v414 >> 4) + 3;
          v416 = __b[v415];
          if (v412 >= 0x40000001)
          {
            v419 = v412;
          }

          else
          {
            v417 = *(a1 + 2744);
            do
            {
              v413 *= 2;
              *(a1 + 2744) = --v417;
              if (!v417)
              {
                v420 = *(a1 + 2720);
                *(a1 + 2720) = v420 + 1;
                v421 = *(a1 + 2704);
                if (v420 + 1 >= v421)
                {
                  v422 = 65280;
                }

                else
                {
                  v422 = *(*(a1 + 2712) + v420 + 1) << 8;
                }

                v423 = v420 + 2;
                *(a1 + 2720) = v423;
                if (v423 < v421)
                {
                  v418 = *(*(a1 + 2712) + v423);
                }

                else
                {
                  v418 = 255;
                }

                v413 |= v422 | v418;
                v417 = 16;
                *(a1 + 2744) = 16;
              }

              v419 = 2 * v412;
              v123 = v412 >= 0x20000001;
              v412 *= 2;
            }

            while (!v123);
          }

          v424 = (HIWORD(v419) * v416) & 0xFFFF0000;
          v425 = (v416 >> 7) & 0x1FE;
          v426 = v419 - v424;
          if (v413 >= v424)
          {
            ++v425;
          }

          __b[v415] = __dsta[v425] + v416;
          v427 = v413 >= v424;
          if (v413 < v424)
          {
            v428 = v424;
          }

          else
          {
            v428 = v426;
          }

          if (v413 < v424)
          {
            v429 = 0;
          }

          else
          {
            v429 = v424;
          }

          v430 = v413 - v429;
          *(a1 + 2732) = v428;
          *(a1 + 2736) = v430;
          v431 = v414 | (8 * v427);
          v432 = (v431 >> 3) + 7;
          v433 = __b[v432];
          if (v428 >= 0x40000001)
          {
            v436 = v428;
          }

          else
          {
            v434 = *(a1 + 2744);
            do
            {
              v430 *= 2;
              *(a1 + 2744) = --v434;
              if (!v434)
              {
                v437 = *(a1 + 2720);
                *(a1 + 2720) = v437 + 1;
                v438 = *(a1 + 2704);
                if (v437 + 1 >= v438)
                {
                  v439 = 65280;
                }

                else
                {
                  v439 = *(*(a1 + 2712) + v437 + 1) << 8;
                }

                v440 = v437 + 2;
                *(a1 + 2720) = v440;
                if (v440 < v438)
                {
                  v435 = *(*(a1 + 2712) + v440);
                }

                else
                {
                  v435 = 255;
                }

                v430 |= v439 | v435;
                v434 = 16;
                *(a1 + 2744) = 16;
              }

              v436 = 2 * v428;
              v123 = v428 >= 0x20000001;
              v428 *= 2;
            }

            while (!v123);
          }

          v441 = (HIWORD(v436) * v433) & 0xFFFF0000;
          v442 = (v433 >> 7) & 0x1FE;
          v443 = v436 - v441;
          if (v430 >= v441)
          {
            ++v442;
          }

          __b[v432] = __dsta[v442] + v433;
          v444 = v430 >= v441;
          if (v430 < v441)
          {
            v445 = v441;
          }

          else
          {
            v445 = v443;
          }

          if (v430 < v441)
          {
            v446 = 0;
          }

          else
          {
            v446 = v441;
          }

          v447 = v430 - v446;
          *(a1 + 2732) = v445;
          *(a1 + 2736) = v447;
          v448 = v431 | (4 * v444);
          v449 = (v448 >> 2) + 15;
          v450 = __b[v449];
          if (v445 >= 0x40000001)
          {
            v453 = v445;
          }

          else
          {
            v451 = *(a1 + 2744);
            do
            {
              v447 *= 2;
              *(a1 + 2744) = --v451;
              if (!v451)
              {
                v454 = *(a1 + 2720);
                *(a1 + 2720) = v454 + 1;
                v455 = *(a1 + 2704);
                if (v454 + 1 >= v455)
                {
                  v456 = 65280;
                }

                else
                {
                  v456 = *(*(a1 + 2712) + v454 + 1) << 8;
                }

                v457 = v454 + 2;
                *(a1 + 2720) = v457;
                if (v457 < v455)
                {
                  v452 = *(*(a1 + 2712) + v457);
                }

                else
                {
                  v452 = 255;
                }

                v447 |= v456 | v452;
                v451 = 16;
                *(a1 + 2744) = 16;
              }

              v453 = 2 * v445;
              v123 = v445 >= 0x20000001;
              v445 *= 2;
            }

            while (!v123);
          }

          v458 = (HIWORD(v453) * v450) & 0xFFFF0000;
          v459 = (v450 >> 7) & 0x1FE;
          v460 = v453 - v458;
          if (v447 >= v458)
          {
            ++v459;
          }

          __b[v449] = __dsta[v459] + v450;
          v461 = v447 >= v458;
          if (v447 < v458)
          {
            v462 = v458;
          }

          else
          {
            v462 = v460;
          }

          if (v447 < v458)
          {
            v463 = 0;
          }

          else
          {
            v463 = v458;
          }

          v464 = v447 - v463;
          *(a1 + 2732) = v462;
          *(a1 + 2736) = v464;
          v465 = v448 | (2 * v461);
          v466 = (v465 >> 1) + 31;
          v467 = __b[v466];
          if (v462 >= 0x40000001)
          {
            v470 = v462;
          }

          else
          {
            v468 = *(a1 + 2744);
            do
            {
              v464 *= 2;
              *(a1 + 2744) = --v468;
              if (!v468)
              {
                v471 = *(a1 + 2720);
                *(a1 + 2720) = v471 + 1;
                v472 = *(a1 + 2704);
                if (v471 + 1 >= v472)
                {
                  v473 = 65280;
                }

                else
                {
                  v473 = *(*(a1 + 2712) + v471 + 1) << 8;
                }

                v474 = v471 + 2;
                *(a1 + 2720) = v474;
                if (v474 < v472)
                {
                  v469 = *(*(a1 + 2712) + v474);
                }

                else
                {
                  v469 = 255;
                }

                v464 |= v473 | v469;
                v468 = 16;
                *(a1 + 2744) = 16;
              }

              v470 = 2 * v462;
              v123 = v462 >= 0x20000001;
              v462 *= 2;
            }

            while (!v123);
          }

          v475 = (HIWORD(v470) * v467) & 0xFFFF0000;
          v476 = (v467 >> 7) & 0x1FE;
          v477 = v470 - v475;
          if (v464 >= v475)
          {
            ++v476;
          }

          __b[v466] = __dsta[v476] + v467;
          if (v464 < v475)
          {
            v478 = v475;
          }

          else
          {
            v478 = v477;
          }

          if (v464 < v475)
          {
            v479 = 0;
          }

          else
          {
            v479 = v475;
          }

          if (v464 >= v475)
          {
            ++v465;
          }

          *(a1 + 2732) = v478;
          *(a1 + 2736) = v464 - v479;
          if (v465 == 63)
          {
            v480 = gcl::ArithmeticDecoder::decodeExpGolomb((a1 + 2704), v673, &v701);
            v465 = v480 + 63;
            v481 = -63 - v480;
            if (v480 + 63 >= 0)
            {
              v481 = v480 + 63;
            }

            v482 = v481 >> v673;
            if (!v673 || v482)
            {
              v620 = v482 > 1;
              v483 = v673;
              if (v620)
              {
                v483 = v673 + 1;
              }
            }

            else
            {
              v483 = v673 - 1;
            }

            v673 = v483;
          }

          v698 += __na;
          v692 += v675;
          if (v368 >= v681)
          {
            v355 = v465 + 1;
          }

          else
          {
            v355 = ~v465;
          }

          v354 = a7;
          v352 = v687;
          v372 = v683;
        }

        else
        {
          v355 = 0;
        }

        v353 += v372;
        v352 += v355;
        v354[v351++] = v352;
      }

      while (v351 < *(a1 + 3792));
      LODWORD(v350) = *(a1 + 3792);
    }
  }

  else
  {
    memset_pattern16(__b, &unk_1B33B25C0, 0x80uLL);
    LOWORD(v701) = 0x8000;
    LODWORD(v350) = *(a1 + 3792);
    if (v350 >= 1)
    {
      v484 = 0;
      v485 = 0;
      v699 = 0x8000;
      v693 = __b[0];
      v486 = 0x8000;
      v487 = a7;
      do
      {
        v490 = *(a1 + 2732);
        v491 = *(a1 + 2736);
        if (v490 >= 0x40000001)
        {
          v494 = *(a1 + 2732);
        }

        else
        {
          v492 = *(a1 + 2744);
          do
          {
            v491 *= 2;
            *(a1 + 2744) = --v492;
            if (!v492)
            {
              v495 = *(a1 + 2720);
              *(a1 + 2720) = v495 + 1;
              v496 = *(a1 + 2704);
              if (v495 + 1 >= v496)
              {
                v497 = 65280;
              }

              else
              {
                v497 = *(*(a1 + 2712) + v495 + 1) << 8;
              }

              v498 = v495 + 2;
              *(a1 + 2720) = v498;
              if (v498 < v496)
              {
                v493 = *(*(a1 + 2712) + v498);
              }

              else
              {
                v493 = 255;
              }

              v491 |= v497 | v493;
              v492 = 16;
              *(a1 + 2744) = 16;
            }

            v494 = 2 * v490;
            v123 = v490 >= 0x20000001;
            v490 *= 2;
          }

          while (!v123);
        }

        v499 = (HIWORD(v494) * v486) & 0xFFFF0000;
        v500 = v494 - v499;
        if (v491 < v499)
        {
          v501 = 0;
        }

        else
        {
          v501 = (HIWORD(v494) * v486) & 0xFFFF0000;
        }

        v502 = v491 - v501;
        *(a1 + 2736) = v491 - v501;
        v503 = v491 >= v499;
        if (v491 < v499)
        {
          v504 = v499;
        }

        else
        {
          v504 = v500;
        }

        *(a1 + 2732) = v504;
        v505 = (v486 >> 7) & 0x1FE;
        if (v503)
        {
          ++v505;
        }

        v489 = __dsta[v505];
        if (v503)
        {
          v688 = v489;
          if (v500 >= 0x40000001)
          {
            v508 = v500;
          }

          else
          {
            v506 = *(a1 + 2744);
            do
            {
              v502 *= 2;
              *(a1 + 2744) = --v506;
              if (!v506)
              {
                v509 = *(a1 + 2720);
                *(a1 + 2720) = v509 + 1;
                v510 = *(a1 + 2704);
                if (v509 + 1 >= v510)
                {
                  v511 = 65280;
                }

                else
                {
                  v511 = *(*(a1 + 2712) + v509 + 1) << 8;
                }

                v512 = v509 + 2;
                *(a1 + 2720) = v512;
                if (v512 < v510)
                {
                  v507 = *(*(a1 + 2712) + v512);
                }

                else
                {
                  v507 = 255;
                }

                v502 |= v511 | v507;
                v506 = 16;
                *(a1 + 2744) = 16;
              }

              v508 = 2 * v500;
              v123 = v500 >= 0x20000001;
              v500 *= 2;
            }

            while (!v123);
          }

          v513 = (HIWORD(v508) * v699) & 0xFFFF0000;
          v514 = (v699 >> 7) & 0x1FE;
          v515 = v508 - v513;
          if (v502 >= v513)
          {
            ++v514;
          }

          v682 = __dsta[v514];
          if (v502 < v513)
          {
            v516 = v513;
          }

          else
          {
            v516 = v515;
          }

          v684 = v513;
          if (v502 < v513)
          {
            v517 = 0;
          }

          else
          {
            v517 = v513;
          }

          v518 = v502 - v517;
          *(a1 + 2732) = v516;
          *(a1 + 2736) = v518;
          if (v516 >= 0x40000001)
          {
            v521 = v516;
          }

          else
          {
            v519 = *(a1 + 2744);
            do
            {
              v518 *= 2;
              *(a1 + 2744) = --v519;
              if (!v519)
              {
                v522 = *(a1 + 2720);
                *(a1 + 2720) = v522 + 1;
                v523 = *(a1 + 2704);
                if (v522 + 1 >= v523)
                {
                  v524 = 65280;
                }

                else
                {
                  v524 = *(*(a1 + 2712) + v522 + 1) << 8;
                }

                v525 = v522 + 2;
                *(a1 + 2720) = v525;
                if (v525 < v523)
                {
                  v520 = *(*(a1 + 2712) + v525);
                }

                else
                {
                  v520 = 255;
                }

                v518 |= v524 | v520;
                v519 = 16;
                *(a1 + 2744) = 16;
              }

              v521 = 2 * v516;
              v123 = v516 >= 0x20000001;
              v516 *= 2;
            }

            while (!v123);
          }

          v526 = (HIWORD(v521) * v693) & 0xFFFF0000;
          v527 = (v693 >> 7) & 0x1FE;
          v528 = v521 - v526;
          v529 = v518 >= v526;
          v530 = v518 >= v526;
          if (v518 >= v526)
          {
            ++v527;
          }

          __nb = __dsta[v527];
          if (v518 < v526)
          {
            v531 = v526;
          }

          else
          {
            v531 = v528;
          }

          if (v518 < v526)
          {
            v532 = 0;
          }

          else
          {
            v532 = v526;
          }

          v533 = 1;
          if (v529)
          {
            v533 = 2;
          }

          v534 = v518 - v532;
          *(a1 + 2732) = v531;
          *(a1 + 2736) = v534;
          v535 = __b[v533];
          if (v531 >= 0x40000001)
          {
            v538 = v531;
          }

          else
          {
            v536 = *(a1 + 2744);
            do
            {
              v534 *= 2;
              *(a1 + 2744) = --v536;
              if (!v536)
              {
                v539 = *(a1 + 2720);
                *(a1 + 2720) = v539 + 1;
                v540 = *(a1 + 2704);
                if (v539 + 1 >= v540)
                {
                  v541 = 65280;
                }

                else
                {
                  v541 = *(*(a1 + 2712) + v539 + 1) << 8;
                }

                v542 = v539 + 2;
                *(a1 + 2720) = v542;
                if (v542 < v540)
                {
                  v537 = *(*(a1 + 2712) + v542);
                }

                else
                {
                  v537 = 255;
                }

                v534 |= v541 | v537;
                v536 = 16;
                *(a1 + 2744) = 16;
              }

              v538 = 2 * v531;
              v123 = v531 >= 0x20000001;
              v531 *= 2;
            }

            while (!v123);
          }

          v543 = (HIWORD(v538) * v535) & 0xFFFF0000;
          v544 = (v535 >> 7) & 0x1FE;
          v545 = v538 - v543;
          v546 = v534 >= v543;
          if (v534 >= v543)
          {
            ++v544;
          }

          __b[v533] = __dsta[v544] + v535;
          if (v534 < v543)
          {
            v547 = v543;
          }

          else
          {
            v547 = v545;
          }

          if (v534 < v543)
          {
            v548 = 0;
          }

          else
          {
            v548 = v543;
          }

          v549 = v534 - v548;
          *(a1 + 2732) = v547;
          *(a1 + 2736) = v549;
          v550 = v530 | (2 * v546);
          v551 = __b[v550 + 3];
          if (v547 >= 0x40000001)
          {
            v554 = v547;
          }

          else
          {
            v552 = *(a1 + 2744);
            do
            {
              v549 *= 2;
              *(a1 + 2744) = --v552;
              if (!v552)
              {
                v555 = *(a1 + 2720);
                *(a1 + 2720) = v555 + 1;
                v556 = *(a1 + 2704);
                if (v555 + 1 >= v556)
                {
                  v557 = 65280;
                }

                else
                {
                  v557 = *(*(a1 + 2712) + v555 + 1) << 8;
                }

                v558 = v555 + 2;
                *(a1 + 2720) = v558;
                if (v558 < v556)
                {
                  v553 = *(*(a1 + 2712) + v558);
                }

                else
                {
                  v553 = 255;
                }

                v549 |= v557 | v553;
                v552 = 16;
                *(a1 + 2744) = 16;
              }

              v554 = 2 * v547;
              v123 = v547 >= 0x20000001;
              v547 *= 2;
            }

            while (!v123);
          }

          v559 = (HIWORD(v554) * v551) & 0xFFFF0000;
          v560 = (v551 >> 7) & 0x1FE;
          v561 = v554 - v559;
          v562 = v549 >= v559;
          if (v549 >= v559)
          {
            ++v560;
          }

          __b[v550 + 3] = __dsta[v560] + v551;
          if (v549 < v559)
          {
            v563 = v559;
          }

          else
          {
            v563 = v561;
          }

          if (v549 < v559)
          {
            v564 = 0;
          }

          else
          {
            v564 = v559;
          }

          v565 = v549 - v564;
          *(a1 + 2732) = v563;
          *(a1 + 2736) = v565;
          v566 = v550 | (4 * v562);
          v567 = __b[v566 + 7];
          if (v563 >= 0x40000001)
          {
            v570 = v563;
          }

          else
          {
            v568 = *(a1 + 2744);
            do
            {
              v565 *= 2;
              *(a1 + 2744) = --v568;
              if (!v568)
              {
                v571 = *(a1 + 2720);
                *(a1 + 2720) = v571 + 1;
                v572 = *(a1 + 2704);
                if (v571 + 1 >= v572)
                {
                  v573 = 65280;
                }

                else
                {
                  v573 = *(*(a1 + 2712) + v571 + 1) << 8;
                }

                v574 = v571 + 2;
                *(a1 + 2720) = v574;
                if (v574 < v572)
                {
                  v569 = *(*(a1 + 2712) + v574);
                }

                else
                {
                  v569 = 255;
                }

                v565 |= v573 | v569;
                v568 = 16;
                *(a1 + 2744) = 16;
              }

              v570 = 2 * v563;
              v123 = v563 >= 0x20000001;
              v563 *= 2;
            }

            while (!v123);
          }

          v575 = (HIWORD(v570) * v567) & 0xFFFF0000;
          v576 = (v567 >> 7) & 0x1FE;
          v577 = v570 - v575;
          v578 = v565 >= v575;
          if (v565 >= v575)
          {
            ++v576;
          }

          __b[v566 + 7] = __dsta[v576] + v567;
          if (v565 < v575)
          {
            v579 = v575;
          }

          else
          {
            v579 = v577;
          }

          if (v565 < v575)
          {
            v580 = 0;
          }

          else
          {
            v580 = v575;
          }

          v581 = v565 - v580;
          *(a1 + 2732) = v579;
          *(a1 + 2736) = v581;
          v582 = v566 | (8 * v578);
          v583 = __b[v582 + 15];
          if (v579 >= 0x40000001)
          {
            v586 = v579;
          }

          else
          {
            v584 = *(a1 + 2744);
            do
            {
              v581 *= 2;
              *(a1 + 2744) = --v584;
              if (!v584)
              {
                v587 = *(a1 + 2720);
                *(a1 + 2720) = v587 + 1;
                v588 = *(a1 + 2704);
                if (v587 + 1 >= v588)
                {
                  v589 = 65280;
                }

                else
                {
                  v589 = *(*(a1 + 2712) + v587 + 1) << 8;
                }

                v590 = v587 + 2;
                *(a1 + 2720) = v590;
                if (v590 < v588)
                {
                  v585 = *(*(a1 + 2712) + v590);
                }

                else
                {
                  v585 = 255;
                }

                v581 |= v589 | v585;
                v584 = 16;
                *(a1 + 2744) = 16;
              }

              v586 = 2 * v579;
              v123 = v579 >= 0x20000001;
              v579 *= 2;
            }

            while (!v123);
          }

          v591 = (HIWORD(v586) * v583) & 0xFFFF0000;
          v592 = (v583 >> 7) & 0x1FE;
          v593 = v586 - v591;
          v594 = v581 >= v591;
          if (v581 >= v591)
          {
            ++v592;
          }

          __b[v582 + 15] = __dsta[v592] + v583;
          if (v581 < v591)
          {
            v595 = v591;
          }

          else
          {
            v595 = v593;
          }

          if (v581 < v591)
          {
            v596 = 0;
          }

          else
          {
            v596 = v591;
          }

          v597 = v581 - v596;
          *(a1 + 2732) = v595;
          *(a1 + 2736) = v597;
          v598 = v582 | (16 * v594);
          v599 = __b[v598 + 31];
          if (v595 >= 0x40000001)
          {
            v602 = v595;
          }

          else
          {
            v600 = *(a1 + 2744);
            do
            {
              v597 *= 2;
              *(a1 + 2744) = --v600;
              if (!v600)
              {
                v603 = *(a1 + 2720);
                *(a1 + 2720) = v603 + 1;
                v604 = *(a1 + 2704);
                if (v603 + 1 >= v604)
                {
                  v605 = 65280;
                }

                else
                {
                  v605 = *(*(a1 + 2712) + v603 + 1) << 8;
                }

                v606 = v603 + 2;
                *(a1 + 2720) = v606;
                if (v606 < v604)
                {
                  v601 = *(*(a1 + 2712) + v606);
                }

                else
                {
                  v601 = 255;
                }

                v597 |= v605 | v601;
                v600 = 16;
                *(a1 + 2744) = 16;
              }

              v602 = 2 * v595;
              v123 = v595 >= 0x20000001;
              v595 *= 2;
            }

            while (!v123);
          }

          v607 = (HIWORD(v602) * v599) & 0xFFFF0000;
          v608 = (v599 >> 7) & 0x1FE;
          v609 = v602 - v607;
          if (v597 >= v607)
          {
            ++v608;
          }

          __b[v598 + 31] = __dsta[v608] + v599;
          if (v597 < v607)
          {
            v610 = v607;
          }

          else
          {
            v610 = v609;
          }

          if (v597 < v607)
          {
            v611 = 0;
          }

          else
          {
            v611 = v607;
          }

          *(a1 + 2732) = v610;
          *(a1 + 2736) = v597 - v611;
          v612 = v598 | (32 * (v597 >= v607));
          if (v612 == 63)
          {
            v612 = gcl::ArithmeticDecoder::decodeExpGolomb((a1 + 2704), 6, &v701) + 63;
          }

          v699 += v682;
          v693 += __nb;
          if (v502 >= v684)
          {
            v488 = v612 + 1;
          }

          else
          {
            v488 = ~v612;
          }

          v487 = a7;
          v489 = v688;
        }

        else
        {
          v488 = 0;
        }

        v486 += v489;
        v485 += v488;
        v487[v484++] = v485;
        v350 = *(a1 + 3792);
      }

      while (v484 < v350);
    }
  }

  if (v350)
  {
    v613 = a7;
    v614 = a7;
    if (v350 == 1)
    {
      goto LABEL_931;
    }

    v615 = a7[1];
    v616 = *a7;
    v614 = v615 >= *a7 ? a7 : a7 + 1;
    v613 = v615 >= v616 ? a7 + 1 : a7;
    if (v350 == 2)
    {
      goto LABEL_931;
    }

    if (v615 <= v616)
    {
      v617 = *a7;
    }

    else
    {
      v617 = a7[1];
    }

    if (v615 < v616)
    {
      v616 = a7[1];
    }

    v618 = a7 + 3;
    v619 = 4 * v350 - 12;
    while (1)
    {
      v621 = v618 - 1;
      if (!v619)
      {
        break;
      }

      v623 = *(v618 - 1);
      v622 = *v618;
      if (*v618 >= v623)
      {
        if (v623 < v616)
        {
          v616 = *(v618 - 1);
          v614 = v618 - 1;
        }

        v620 = v622 < v617;
        if (v622 > v617)
        {
          v617 = *v618;
        }

        if (!v620)
        {
          v613 = v618;
        }
      }

      else
      {
        v616 = *v614;
        if (v622 < *v614)
        {
          v616 = *v618;
          v614 = v618;
        }

        v617 = *v613;
        if (v623 > *v613)
        {
          v617 = *(v618 - 1);
        }

        if (v623 >= *v613)
        {
          v613 = v618 - 1;
        }
      }

      v618 += 2;
      v619 -= 8;
      if (v619 == -4)
      {
        goto LABEL_931;
      }
    }

    v624 = *v621;
    if (*v621 >= *v614)
    {
      if (v624 >= *v613)
      {
        v613 = v618 - 1;
      }

LABEL_931:
      v624 = *v614;
    }

    if (v624 < 0)
    {
      goto LABEL_16;
    }

    v625 = *v613;
    v626 = v625 - v624;
    if (v625 - v624 > v350)
    {
      goto LABEL_16;
    }

    v627 = v626 + 2;
    *a1 = v625;
    *(a1 + 4) = v624;
    v628 = *(a1 + 56);
    v629 = *(a1 + 64);
    if (v629 != v628)
    {
      *(a1 + 64) = v628;
      v629 = v628;
    }

    v630 = (v629 - v628) >> 2;
    if (v627 <= v630)
    {
      if (v627 < v630)
      {
        *(a1 + 64) = v628 + 4 * v627;
      }
    }

    else
    {
      std::vector<int>::__append(v668, v627 - v630);
      LODWORD(v350) = *(a1 + 3792);
    }

    if (v350 >= 1)
    {
      v631 = 0;
      v632 = (v668->__begin_ + 1);
      do
      {
        ++*(v632 + 4 * (a7[v631++] - v624));
      }

      while (v631 < *(a1 + 3792));
      LODWORD(v350) = *(a1 + 3792);
    }

    if ((v626 & 0x80000000) == 0)
    {
      v633 = v668->__begin_;
      if (v627 <= 2)
      {
        v634 = 2;
      }

      else
      {
        v634 = v627;
      }

      v637 = *v633;
      v635 = v633 + 1;
      v636 = v637;
      v638 = v634 - 1;
      do
      {
        v636 += *v635;
        *v635++ = v636;
        --v638;
      }

      while (v638);
      LODWORD(v350) = *(a1 + 3792);
    }

    if (v350 >= 1)
    {
      v639 = 0;
      v640 = 0;
      do
      {
        v641 = a7[v640] - v624;
        v642 = *(a1 + 56);
        v643 = *(v642 + 4 * v641);
        *(v642 + 4 * v641) = v643 + 1;
        v644 = (*(a1 + 128) + v639);
        v645 = a6 + 12 * v643;
        v646 = *v644;
        *(v645 + 8) = *(v644 + 2);
        *v645 = v646;
        ++v640;
        v639 += 12;
      }

      while (v640 < *(a1 + 3792));
    }

    if ((v626 & 0x80000000) == 0)
    {
      v647 = 0;
      v648 = 0;
      v649 = v668->__begin_;
      do
      {
        v650 = v649[v647];
        if (v648 < v650)
        {
          v651 = v648;
          v652 = v624 + v647;
          v653 = v650 - v648;
          if (v653 > 7)
          {
            v654 = v653 & 0xFFFFFFFFFFFFFFF8;
            v655 = vdupq_n_s32(v652);
            v656 = &a7[v648 + 4];
            v657 = v653 & 0xFFFFFFFFFFFFFFF8;
            do
            {
              v656[-1] = v655;
              *v656 = v655;
              v656 += 2;
              v657 -= 8;
            }

            while (v657);
            if (v653 == v654)
            {
              goto LABEL_956;
            }

            v651 = v654 + v648;
          }

          v658 = v650 - v651;
          v659 = &a7[v651];
          do
          {
            *v659++ = v652;
            --v658;
          }

          while (v658);
        }

LABEL_956:
        v649[v647++] = v648;
        v648 = v650;
      }

      while (v647 != v626 + 1);
    }
  }

LABEL_515:
  result = *(a1 + 3872);
  if (!result)
  {
    if (*(a1 + 3792) >= 1)
    {
      v328 = 0;
      v329 = 0;
      do
      {
        v330 = *(a1 + 128) + v328;
        v331 = *(a6 + v328);
        *(v330 + 8) = *(a6 + v328 + 8);
        *v330 = v331;
        ++v329;
        v328 += 12;
      }

      while (v329 < *(a1 + 3792));
    }

    v332 = *(a1 + 3788);
    if (v669 || v667 || v666)
    {
      if (v332 >= 1)
      {
        v339 = 0;
        v340 = 0;
        v341 = (a5 + 8);
        do
        {
          v342 = (*(a1 + 104) + v339);
          v343 = *v342 + v669;
          v344 = v342[1] + v667;
          LODWORD(v342) = v342[2] + v666;
          *(v341 - 2) = v343;
          *(v341 - 1) = v344;
          *v341 = v342;
          v341 += 3;
          ++v340;
          v339 += 12;
        }

        while (v340 < *(a1 + 3788));
      }
    }

    else if (v332 >= 1)
    {
      v333 = 0;
      v334 = 0;
      do
      {
        v335 = (*(a1 + 104) + v333);
        v336 = a5 + v333;
        v337 = *v335;
        *(v336 + 8) = *(v335 + 2);
        *v336 = v337;
        ++v334;
        v333 += 12;
      }

      while (v334 < *(a1 + 3788));
    }

    result = 0;
    *a4 = *(a1 + 3784);
  }

  return result;
}

void sub_1B33636AC(_Unwind_Exception *exception_object)
{
  if (!v1)
  {
    _Unwind_Resume(exception_object);
  }

  operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t gcl::tmesh::DecoderImpl::parsePositionsAndConnectivityInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 4)
  {
    return 0;
  }

  v3 = a2 & 0x7FFFFFFFFFFFFFFCLL;
  if ((a2 & 0x7FFFFFFFFFFFFFFCLL) == 4 || a2 == 8 || a2 == 9 || (a2 & 0x7FFFFFFFFFFFFFFELL) == 0xA || v3 == 12 || v3 == 16 || v3 == 20 || a2 == 24 || a2 == 25 || a2 == 26 || a2 == 27)
  {
    return 0;
  }

  if (a2 < 32)
  {
    return 0;
  }

  if (*a1 != -90009999)
  {
    return 0;
  }

  v5 = *(a1 + 4);
  v6 = *(a1 + 8);
  v7 = *(a1 + 9);
  v8 = *(a1 + 10);
  v9 = *(a1 + 12);
  v10 = *(a1 + 16) & 0x7FFFFFFF;
  v11 = *(a1 + 20) & 0x7FFFFFFF;
  v12 = *(a1 + 24);
  v13 = *(a1 + 25);
  v14 = *(a1 + 26);
  v15 = *(a1 + 27);
  *a3 = 0;
  *(a3 + 4) = v6;
  *(a3 + 5) = v7;
  *(a3 + 6) = v8;
  *(a3 + 8) = v9;
  *(a3 + 12) = v10;
  *(a3 + 16) = v11;
  *(a3 + 20) = v15;
  *(a3 + 24) = v14 & 1;
  *(a3 + 28) = v5;
  *(a3 + 32) = v12;
  *(a3 + 36) = v13;
  v16 = *&vshl_u16(vdup_n_s16(v14), 0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
  *(a3 + 40) = vuzp1_s8(v16, v16).u32[0];
  *(a3 + 44) = (v14 & 0x20) != 0;
  return a1 + 32;
}

uint64_t gcl::ArithmeticDecoder::decodeExpGolomb(unsigned int *a1, int a2, _WORD *a3)
{
  v3 = 0;
  v4 = *a3;
  v6 = a1[7];
  v5 = a1[8];
  if (v6 >= 0x40000001)
  {
    goto LABEL_12;
  }

LABEL_2:
  v7 = a1[10];
  do
  {
    v5 *= 2;
    a1[10] = --v7;
    if (!v7)
    {
      v10 = *(a1 + 2);
      *(a1 + 2) = v10 + 1;
      v11 = *a1;
      if (v10 + 1 >= v11)
      {
        v12 = 65280;
      }

      else
      {
        v12 = *(*(a1 + 1) + v10 + 1) << 8;
      }

      v13 = v10 + 2;
      *(a1 + 2) = v13;
      if (v13 < v11)
      {
        v8 = *(*(a1 + 1) + v13);
      }

      else
      {
        v8 = 255;
      }

      v5 |= v12 | v8;
      v7 = 16;
      a1[10] = 16;
    }

    v9 = 2 * v6;
    v16 = v6 >= 0x20000001;
    v6 *= 2;
  }

  while (!v16);
  while (1)
  {
    v6 = (HIWORD(v9) * v4) & 0xFFFF0000;
    v14 = v9 - v6;
    if (v5 < v6)
    {
      v15 = 0;
    }

    else
    {
      v15 = (HIWORD(v9) * v4) & 0xFFFF0000;
    }

    v16 = v5 >= v6;
    v5 -= v15;
    v17 = (v4 >> 7) & 0x1FE;
    if (v16)
    {
      ++v17;
    }

    v4 += *(a1 + v17 + 24);
    *a3 = v4;
    if (v16)
    {
      v6 = v14;
    }

    a1[7] = v6;
    a1[8] = v5;
    if (!v16 || a2 >= 31)
    {
      break;
    }

    v19 = 1 << a2++;
    v3 |= v19;
    if (v6 < 0x40000001)
    {
      goto LABEL_2;
    }

LABEL_12:
    v9 = v6;
  }

  for (i = 0; a2; i |= v24 << a2)
  {
    if (v6 >= 0x40000001)
    {
      v22 = v6;
    }

    else
    {
      v25 = a1[10];
      do
      {
        v5 *= 2;
        a1[10] = --v25;
        if (!v25)
        {
          v27 = *(a1 + 2);
          *(a1 + 2) = v27 + 1;
          v28 = *a1;
          if (v27 + 1 >= v28)
          {
            v29 = 65280;
          }

          else
          {
            v29 = *(*(a1 + 1) + v27 + 1) << 8;
          }

          v30 = v27 + 2;
          *(a1 + 2) = v30;
          if (v30 < v28)
          {
            v26 = *(*(a1 + 1) + v30);
          }

          else
          {
            v26 = 255;
          }

          v5 |= v29 | v26;
          v25 = 16;
          a1[10] = 16;
        }

        v22 = 2 * v6;
        v16 = v6 >= 0x20000001;
        v6 *= 2;
      }

      while (!v16);
    }

    v23 = (v22 >> 1) & 0x7FFF0000;
    v6 = v22 - v23;
    v24 = v5 >= v23;
    if (v5 < v23)
    {
      v6 = v23;
      v23 = 0;
    }

    v5 -= v23;
    a1[7] = v6;
    a1[8] = v5;
    --a2;
  }

  return (i + v3);
}

int32x4_t gcl::tmesh::DecoderImpl::decompressGeometry(uint64_t a1, int a2, uint64_t a3, int32x4_t a4, int32x4_t a5, int32x4_t a6, int32x4_t a7)
{
  v10 = (*(a1 + 176) + 12 * a2);
  v11 = *v10;
  v12 = v10[1];
  v13 = v10[2];
  v14 = *(a1 + 3812);
  if (v14 != 1)
  {
    if (v14 != 2)
    {
      goto LABEL_17;
    }

    v15 = (*(a1 + 200) + 12 * a2);
    v16 = v15[2];
    if (v16 != -1)
    {
      v18 = *v15;
      v17 = v15[1];
      v19 = a1 + 2416;
      v20 = *(a1 + 2416);
      v21 = *(a1 + 2732);
      v22 = *(a1 + 2736);
      if (v21 >= 0x40000001)
      {
        v25 = *(a1 + 2732);
      }

      else
      {
        v23 = *(a1 + 2744);
        do
        {
          v22 *= 2;
          *(a1 + 2744) = --v23;
          if (!v23)
          {
            v27 = *(a1 + 2720);
            *(a1 + 2720) = v27 + 1;
            v28 = *(a1 + 2704);
            if (v27 + 1 >= v28)
            {
              v29 = 65280;
            }

            else
            {
              v29 = *(*(a1 + 2712) + v27 + 1) << 8;
            }

            v30 = v27 + 2;
            *(a1 + 2720) = v30;
            if (v30 < v28)
            {
              v24 = *(*(a1 + 2712) + v30);
            }

            else
            {
              v24 = 255;
            }

            v22 |= v29 | v24;
            v23 = 16;
            *(a1 + 2744) = 16;
          }

          v25 = 2 * v21;
          v26 = v21 >= 0x20000001;
          v21 *= 2;
        }

        while (!v26);
      }

      v40 = (HIWORD(v25) * v20) & 0xFFFF0000;
      v41 = (v20 >> 7) & 0x1FE;
      v42 = v25 - v40;
      v43 = v22 >= v40;
      v44 = a1 + 2752;
      if (v22 >= v40)
      {
        ++v41;
      }

      *(a1 + 2416) = *(v44 + 2 * v41) + v20;
      if (v22 < v40)
      {
        v45 = v40;
      }

      else
      {
        v45 = v42;
      }

      if (v22 < v40)
      {
        v46 = 0;
      }

      else
      {
        v46 = v40;
      }

      v47 = 1;
      if (v22 >= v40)
      {
        v47 = 2;
      }

      v48 = v22 - v46;
      *(a1 + 2732) = v45;
      *(a1 + 2736) = v48;
      v49 = *(v19 + 2 * v47);
      if (v45 >= 0x40000001)
      {
        v52 = v45;
      }

      else
      {
        v50 = *(a1 + 2744);
        do
        {
          v48 *= 2;
          *(a1 + 2744) = --v50;
          if (!v50)
          {
            v53 = *(a1 + 2720);
            *(a1 + 2720) = v53 + 1;
            v54 = *(a1 + 2704);
            if (v53 + 1 >= v54)
            {
              v55 = 65280;
            }

            else
            {
              v55 = *(*(a1 + 2712) + v53 + 1) << 8;
            }

            v56 = v53 + 2;
            *(a1 + 2720) = v56;
            if (v56 < v54)
            {
              v51 = *(*(a1 + 2712) + v56);
            }

            else
            {
              v51 = 255;
            }

            v48 |= v55 | v51;
            v50 = 16;
            *(a1 + 2744) = 16;
          }

          v52 = 2 * v45;
          v26 = v45 >= 0x20000001;
          v45 *= 2;
        }

        while (!v26);
      }

      v57 = (HIWORD(v52) * v49) & 0xFFFF0000;
      v58 = (v49 >> 7) & 0x1FE;
      v59 = v52 - v57;
      v60 = v48 >= v57;
      if (v48 >= v57)
      {
        ++v58;
      }

      *(v19 + 2 * v47) = *(v44 + 2 * v58) + v49;
      if (v48 < v57)
      {
        v61 = v57;
      }

      else
      {
        v61 = v59;
      }

      if (v48 < v57)
      {
        v57 = 0;
      }

      *(a1 + 2732) = v61;
      *(a1 + 2736) = v48 - v57;
      v62 = v43 | (2 * v60);
      if (v62 > 1)
      {
        if (v62 != 2)
        {
          v79 = a3 + 12 * v11;
          v80 = a3 + 12 * v18;
          v81 = a3 + 12 * v12;
          v82 = a3 + 12 * v17;
          v83 = a3 + 12 * v13;
          v84 = a3 + 12 * v16;
          a4.i64[0] = *v79;
          a4.i32[2] = *(v79 + 8);
          a5.i64[0] = *v80;
          a5.i32[2] = *(v80 + 8);
          v85 = vaddq_s32(a5, a4);
          a5.i64[0] = *v81;
          a5.i32[2] = *(v81 + 8);
          a6.i64[0] = *v82;
          a6.i32[2] = *(v82 + 8);
          v86 = vaddq_s32(a6, a5);
          a6.i64[0] = *v83;
          a6.i32[2] = *(v83 + 8);
          a7.i64[0] = *v84;
          a7.i32[2] = *(v84 + 8);
          v87 = vsubq_s32(vsraq_n_s32(vaddq_s32(v86, v86), vsraq_n_u32(v85, v85, 0x1FuLL), 1uLL), vaddq_s32(a6, a7));
          LODWORD(v79) = v87.i32[2] / 3;
          v88 = vmull_s32(*v87.i8, vdup_n_s32(0x55555556u));
          *v86.i8 = vshrn_n_s64(v88, 0x20uLL);
          v78 = vshrq_n_u64(v88, 0x3FuLL);
          *v78.i8 = vadd_s32(*v86.i8, vmovn_s64(v78));
          v78.i32[2] = v79;
          goto LABEL_63;
        }

        v68 = a3 + 12 * v12;
        v69 = a3 + 12 * v17;
        v70 = a3 + 12 * v11;
        v71 = a3 + 12 * v18;
        a4.i64[0] = *v68;
        a4.i32[2] = *(v68 + 8);
        a5.i64[0] = *v69;
        a5.i32[2] = *(v69 + 8);
        a6.i64[0] = *v70;
        a6.i32[2] = *(v70 + 8);
        a7.i64[0] = *v71;
        a7.i32[2] = *(v71 + 8);
        v72 = vaddq_s32(a5, a4);
        v73 = vaddq_s32(a7, a6);
        a5 = vshrq_n_s32(vsraq_n_u32(v73, v73, 0x1FuLL), 1uLL);
      }

      else
      {
        if (v62)
        {
          v76 = a3 + 12 * v18;
          v77 = (a3 + 12 * v17);
          a4.i64[0] = *v76;
          a4.i32[2] = *(v76 + 8);
          v65 = a3 + 12 * v16;
          a5.i64[0] = *v77;
          v66 = (v77 + 1);
        }

        else
        {
          v63 = a3 + 12 * v11;
          v64 = (a3 + 12 * v12);
          a4.i64[0] = *v63;
          a4.i32[2] = *(v63 + 8);
          v65 = a3 + 12 * v13;
          v67 = *v64;
          v66 = (v64 + 1);
          a5.i64[0] = v67;
        }

        a5.i32[2] = *v66;
        v72 = vaddq_s32(a5, a4);
        a5.i64[0] = *v65;
        a5.i32[2] = *(v65 + 8);
      }

      v78 = vsubq_s32(v72, a5);
LABEL_63:
      v91 = v78;
      v31 = 1;
      goto LABEL_64;
    }
  }

  if (v13 != -1)
  {
    v31 = 0;
    v32 = a3 + 12 * v11;
    v33 = a3 + 12 * v12;
    v34 = a3 + 12 * v13;
    a4.i64[0] = *v32;
    a4.i32[2] = *(v32 + 8);
    a5.i64[0] = *v33;
    a5.i32[2] = *(v33 + 8);
    v35 = vaddq_s32(a5, a4);
    a5.i64[0] = *v34;
    a5.i32[2] = *(v34 + 8);
    a4 = vsubq_s32(v35, a5);
LABEL_21:
    v91 = a4;
LABEL_64:
    gcl::tmesh::DecoderImpl::decodeResidual(&v92, a1, *(a1 + 3808), (a1 + 120 * v31 + 2424));
    v75 = v91;
    v74 = v92;
    goto LABEL_65;
  }

LABEL_17:
  if (v12 != -1)
  {
    v31 = 0;
    v36 = a3 + 12 * v11;
    v37 = a3 + 12 * v12;
    a4.i64[0] = *v36;
    a4.i32[2] = *(v36 + 8);
    a5.i64[0] = *v37;
    a5.i32[2] = *(v37 + 8);
    v38 = vaddq_s32(a5, a4);
    a4 = vshrq_n_s32(vsraq_n_u32(v38, v38, 0x1FuLL), 1uLL);
    goto LABEL_21;
  }

  if (v11 != -1)
  {
    v31 = 0;
    v39 = a3 + 12 * v11;
    a4.i64[0] = *v39;
    a4.i32[2] = *(v39 + 8);
    goto LABEL_21;
  }

  if (!*(a1 + 3820))
  {
    v31 = 0;
    a4 = 0uLL;
    goto LABEL_21;
  }

  gcl::tmesh::DecoderImpl::decodeResidual(&v92, a1, 3u, 0);
  v74 = v92;
  v75 = 0uLL;
LABEL_65:
  v89 = a3 + 12 * a2;
  result = vaddq_s32(v74, v75);
  *v89 = result.i64[0];
  *(v89 + 8) = result.i32[2];
  return result;
}

uint64_t gcl::tmesh::DecoderImpl::decompressTFanConnectivity(uint64_t a1, int a2, unsigned int a3, uint64_t a4, int *a5, _DWORD *a6, _DWORD *a7)
{
  v12 = (a1 + 2060 + 16 * a3);
  v13 = *v12;
  v14 = *(a1 + 2732);
  v15 = *(a1 + 2736);
  if (v14 >= 0x40000001)
  {
    v18 = *(a1 + 2732);
  }

  else
  {
    v16 = *(a1 + 2744);
    do
    {
      v15 *= 2;
      *(a1 + 2744) = --v16;
      if (!v16)
      {
        v19 = *(a1 + 2720);
        *(a1 + 2720) = v19 + 1;
        v20 = *(a1 + 2704);
        if (v19 + 1 >= v20)
        {
          v21 = 65280;
        }

        else
        {
          v21 = *(*(a1 + 2712) + v19 + 1) << 8;
        }

        v22 = v19 + 2;
        *(a1 + 2720) = v22;
        if (v22 < v20)
        {
          v17 = *(*(a1 + 2712) + v22);
        }

        else
        {
          v17 = 255;
        }

        v15 |= v21 | v17;
        v16 = 16;
        *(a1 + 2744) = 16;
      }

      v18 = 2 * v14;
      v28 = v14 >= 0x20000001;
      v14 *= 2;
    }

    while (!v28);
  }

  v23 = (HIWORD(v18) * v13) & 0xFFFF0000;
  v24 = v18 - v23;
  if (v15 < v23)
  {
    v25 = 0;
  }

  else
  {
    v25 = v23;
  }

  v26 = v15 - v25;
  v27 = a1 + 2752;
  *(a1 + 2736) = v26;
  v28 = v15 >= v23;
  if (v15 < v23)
  {
    v29 = (v13 >> 7) & 0x1FE;
  }

  else
  {
    v29 = ((v13 >> 7) & 0x1FE) + 1;
  }

  *v12 = *(v27 + 2 * v29) + v13;
  if (v28)
  {
    v30 = v24;
  }

  else
  {
    v30 = v23;
  }

  *(a1 + 2732) = v30;
  if (v28)
  {
    v31 = 0;
    v32 = 0;
    v222 = 1;
    v223 = 0;
    goto LABEL_25;
  }

  v48 = v12[1];
  if (v23 >= 0x40000001)
  {
    v51 = v23;
  }

  else
  {
    v49 = *(a1 + 2744);
    do
    {
      v26 *= 2;
      *(a1 + 2744) = --v49;
      if (!v49)
      {
        v52 = *(a1 + 2720);
        *(a1 + 2720) = v52 + 1;
        v53 = *(a1 + 2704);
        if (v52 + 1 >= v53)
        {
          v54 = 65280;
        }

        else
        {
          v54 = *(*(a1 + 2712) + v52 + 1) << 8;
        }

        v55 = v52 + 2;
        *(a1 + 2720) = v55;
        if (v55 < v53)
        {
          v50 = *(*(a1 + 2712) + v55);
        }

        else
        {
          v50 = 255;
        }

        v26 |= v54 | v50;
        v49 = 16;
        *(a1 + 2744) = 16;
      }

      v51 = 2 * v23;
      v28 = v23 >= 0x20000001;
      v23 *= 2;
    }

    while (!v28);
  }

  v90 = (HIWORD(v51) * v48) & 0xFFFF0000;
  v91 = (v48 >> 7) & 0x1FE;
  v92 = v51 - v90;
  v93 = v26 >= v90;
  v94 = v26 >= v90;
  if (v26 >= v90)
  {
    ++v91;
  }

  v12[1] = *(v27 + 2 * v91) + v48;
  if (v26 < v90)
  {
    v95 = v90;
  }

  else
  {
    v95 = v92;
  }

  if (v26 < v90)
  {
    v96 = 0;
  }

  else
  {
    v96 = v90;
  }

  v97 = 4;
  if (v93)
  {
    v97 = 6;
  }

  v98 = v26 - v96;
  *(a1 + 2732) = v95;
  *(a1 + 2736) = v98;
  v99 = a1 + 2060 + 16 * a3;
  v100 = *(v99 + v97);
  if (v95 >= 0x40000001)
  {
    v103 = v95;
  }

  else
  {
    v101 = *(a1 + 2744);
    do
    {
      v98 *= 2;
      *(a1 + 2744) = --v101;
      if (!v101)
      {
        v104 = *(a1 + 2720);
        *(a1 + 2720) = v104 + 1;
        v105 = *(a1 + 2704);
        if (v104 + 1 >= v105)
        {
          v106 = 65280;
        }

        else
        {
          v106 = *(*(a1 + 2712) + v104 + 1) << 8;
        }

        v107 = v104 + 2;
        *(a1 + 2720) = v107;
        if (v107 < v105)
        {
          v102 = *(*(a1 + 2712) + v107);
        }

        else
        {
          v102 = 255;
        }

        v98 |= v106 | v102;
        v101 = 16;
        *(a1 + 2744) = 16;
      }

      v103 = 2 * v95;
      v28 = v95 >= 0x20000001;
      v95 *= 2;
    }

    while (!v28);
  }

  v108 = (HIWORD(v103) * v100) & 0xFFFF0000;
  v109 = (v100 >> 7) & 0x1FE;
  v110 = v103 - v108;
  v111 = v98 >= v108;
  if (v98 >= v108)
  {
    ++v109;
  }

  *(v99 + v97) = *(v27 + 2 * v109) + v100;
  if (v98 < v108)
  {
    v112 = v108;
  }

  else
  {
    v112 = v110;
  }

  if (v98 < v108)
  {
    v113 = 0;
  }

  else
  {
    v113 = v108;
  }

  v114 = v98 - v113;
  *(a1 + 2732) = v112;
  *(a1 + 2736) = v114;
  v115 = v94 | (2 * v111);
  v116 = *(v99 + 2 * (v115 | 4u));
  if (v112 >= 0x40000001)
  {
    v119 = v112;
  }

  else
  {
    v117 = *(a1 + 2744);
    do
    {
      v114 *= 2;
      *(a1 + 2744) = --v117;
      if (!v117)
      {
        v120 = *(a1 + 2720);
        *(a1 + 2720) = v120 + 1;
        v121 = *(a1 + 2704);
        if (v120 + 1 >= v121)
        {
          v122 = 65280;
        }

        else
        {
          v122 = *(*(a1 + 2712) + v120 + 1) << 8;
        }

        v123 = v120 + 2;
        *(a1 + 2720) = v123;
        if (v123 < v121)
        {
          v118 = *(*(a1 + 2712) + v123);
        }

        else
        {
          v118 = 255;
        }

        v114 |= v122 | v118;
        v117 = 16;
        *(a1 + 2744) = 16;
      }

      v119 = 2 * v112;
      v28 = v112 >= 0x20000001;
      v112 *= 2;
    }

    while (!v28);
  }

  v124 = (HIWORD(v119) * v116) & 0xFFFF0000;
  v125 = (v116 >> 7) & 0x1FE;
  if (v114 >= v124)
  {
    ++v125;
  }

  v126 = v119 - v124;
  *(v99 + 2 * (v115 | 4u)) = *(v27 + 2 * v125) + v116;
  if (v114 < v124)
  {
    v127 = v124;
  }

  else
  {
    v127 = v126;
  }

  if (v114 < v124)
  {
    v128 = 0;
  }

  else
  {
    v128 = v124;
  }

  v32 = v115 + 5;
  if (v114 < v124)
  {
    v32 = v115 + 1;
  }

  *(a1 + 2732) = v127;
  *(a1 + 2736) = v114 - v128;
  if (v32 > 3)
  {
    if (v32 <= 5)
    {
      if (v32 == 4)
      {
        v31 = 0;
        v220 = 0;
        v222 = 0;
        v223 = 1;
        goto LABEL_26;
      }

      v222 = 0;
      v223 = 0;
      v31 = 0;
      goto LABEL_25;
    }

    if (v32 == 6)
    {
      v222 = 0;
      v223 = 0;
      v220 = 0;
      v31 = 1;
      goto LABEL_26;
    }

    if (v32 == 7)
    {
      v220 = 0;
      v222 = 0;
      v223 = 1;
      v31 = 1;
      goto LABEL_26;
    }

LABEL_205:
    v222 = 0;
    v223 = 0;
    v31 = 0;
    v220 = 0;
    goto LABEL_26;
  }

  if (v32 == 1)
  {
    v223 = 0;
    v220 = 0;
    v31 = 1;
LABEL_209:
    v222 = 1;
    goto LABEL_26;
  }

  if (v32 == 2)
  {
    v223 = 0;
    v31 = 0;
    v220 = 0;
    goto LABEL_209;
  }

  if (v32 != 3)
  {
    goto LABEL_205;
  }

  v31 = 0;
  v222 = 0;
  v223 = 1;
LABEL_25:
  v220 = 1;
LABEL_26:
  *a5 = v32;
  if (*(a1 + 3817) == 1 && (*(a1 + 3816) & 1) != 0)
  {
    v33 = *(*(a1 + 224) + 12 * a2);
    if (v33 <= 19)
    {
      v33 = 19;
    }

    v34 = v33 - 19;
    v225 = v34 >> 1;
    v226 = 15;
    v28 = v34 >= 0x1E;
    v35 = &v226;
    if (!v28)
    {
      v35 = &v225;
    }
  }

  else
  {
    v227 = 7;
    v35 = (*(a1 + 80) + 4 * a2);
    if (*v35 >= 7)
    {
      v35 = &v227;
    }
  }

  v36 = *v35;
  v37 = (a1 + 2140 + 6 * v36);
  v38 = *v37;
  v39 = *(a1 + 2732);
  v40 = *(a1 + 2736);
  if (v39 >= 0x40000001)
  {
    v43 = *(a1 + 2732);
  }

  else
  {
    v41 = *(a1 + 2744);
    do
    {
      v40 *= 2;
      *(a1 + 2744) = --v41;
      if (!v41)
      {
        v44 = *(a1 + 2720);
        *(a1 + 2720) = v44 + 1;
        v45 = *(a1 + 2704);
        if (v44 + 1 >= v45)
        {
          v46 = 65280;
        }

        else
        {
          v46 = *(*(a1 + 2712) + v44 + 1) << 8;
        }

        v47 = v44 + 2;
        *(a1 + 2720) = v47;
        if (v47 < v45)
        {
          v42 = *(*(a1 + 2712) + v47);
        }

        else
        {
          v42 = 255;
        }

        v40 |= v46 | v42;
        v41 = 16;
        *(a1 + 2744) = 16;
      }

      v43 = 2 * v39;
      v28 = v39 >= 0x20000001;
      v39 *= 2;
    }

    while (!v28);
  }

  v56 = (HIWORD(v43) * v38) & 0xFFFF0000;
  v57 = (v38 >> 7) & 0x1FE;
  v58 = v43 - v56;
  v59 = v40 >= v56;
  v60 = v40 >= v56;
  if (v40 >= v56)
  {
    ++v57;
  }

  *v37 = *(v27 + 2 * v57) + v38;
  if (v40 < v56)
  {
    v61 = v56;
  }

  else
  {
    v61 = v58;
  }

  if (v40 < v56)
  {
    v56 = 0;
  }

  v62 = 2;
  if (v59)
  {
    v62 = 4;
  }

  v63 = v40 - v56;
  *(a1 + 2732) = v61;
  *(a1 + 2736) = v63;
  v64 = a1 + 2140 + 6 * v36;
  v65 = *(v64 + v62);
  if (v61 >= 0x40000001)
  {
    v68 = v61;
  }

  else
  {
    v66 = *(a1 + 2744);
    do
    {
      v63 *= 2;
      *(a1 + 2744) = --v66;
      if (!v66)
      {
        v69 = *(a1 + 2720);
        *(a1 + 2720) = v69 + 1;
        v70 = *(a1 + 2704);
        if (v69 + 1 >= v70)
        {
          v71 = 65280;
        }

        else
        {
          v71 = *(*(a1 + 2712) + v69 + 1) << 8;
        }

        v72 = v69 + 2;
        *(a1 + 2720) = v72;
        if (v72 < v70)
        {
          v67 = *(*(a1 + 2712) + v72);
        }

        else
        {
          v67 = 255;
        }

        v63 |= v71 | v67;
        v66 = 16;
        *(a1 + 2744) = 16;
      }

      v68 = 2 * v61;
      v28 = v61 >= 0x20000001;
      v61 *= 2;
    }

    while (!v28);
  }

  v73 = (HIWORD(v68) * v65) & 0xFFFF0000;
  v74 = (v65 >> 7) & 0x1FE;
  v75 = v68 - v73;
  if (v63 >= v73)
  {
    ++v74;
  }

  *(v64 + v62) = *(v27 + 2 * v74) + v65;
  if (v63 < v73)
  {
    v76 = v73;
  }

  else
  {
    v76 = v75;
  }

  if (v63 < v73)
  {
    v77 = 0;
  }

  else
  {
    v77 = v73;
  }

  *(a1 + 2732) = v76;
  *(a1 + 2736) = v63 - v77;
  v78 = v60 | (2 * (v63 >= v73));
  if (v78 == 3)
  {
    v79 = gcl::ArithmeticDecoder::decodeExpGolomb((a1 + 2704), 0, (a1 + 2236));
    if (v79 < -3)
    {
      goto LABEL_96;
    }

    v78 = v79 + 3;
    v80 = v79 + 4;
  }

  else
  {
    v80 = v78 + 1;
  }

  if (v78 < *(a1 + 3792) - *a7)
  {
    v218 = v31;
    v219 = v80;
    v216 = a7;
    v217 = a5;
    v215 = a4;
    v81 = v78 + 2;
    v82 = *(a1 + 8);
    v83 = a1 + 8;
    v84 = (*(a1 + 16) - v82) >> 2;
    if (v80 >= v84)
    {
      v129 = (2 * v81) | 1u;
      if (v129 <= v84)
      {
        if (v129 < v84)
        {
          *(a1 + 16) = v82 + 4 * v129;
        }
      }

      else
      {
        std::vector<int>::__append((a1 + 8), v129 - v84);
        v80 = v219;
      }

      v151 = *(a1 + 32);
      v150 = *(a1 + 40);
      if (v129 <= &v150[-v151])
      {
        if (v129 < &v150[-v151])
        {
          *(a1 + 40) = v151 + v129;
        }
      }

      else
      {
        if (*(a1 + 48) - v150 < v129 - &v150[-v151])
        {
          operator new();
        }

        v170 = v129 + v151;
        bzero(v150, v129 - &v150[-v151]);
        *(a1 + 40) = v170;
        v80 = v219;
      }
    }

    **(a1 + 32) = v223;
    v85 = v80;
    *(*(a1 + 32) + v80) = v218;
    v86 = *(a1 + 8);
    v87 = (*(a1 + 152) + 16 * a2);
    v214 = *v87;
    if (v222)
    {
      v88 = v87[1];
    }

    else
    {
      if (v223)
      {
LABEL_162:
        v224 = v86;
        v130 = a2;
        if (v78)
        {
          v131 = *(a1 + 2276);
          v132 = *(a1 + 2732);
          v133 = *(a1 + 2736);
          if (v132 >= 0x40000001)
          {
            v136 = *(a1 + 2732);
          }

          else
          {
            v134 = *(a1 + 2744);
            do
            {
              v133 *= 2;
              *(a1 + 2744) = --v134;
              if (!v134)
              {
                v137 = *(a1 + 2720);
                *(a1 + 2720) = v137 + 1;
                v138 = *(a1 + 2704);
                if (v137 + 1 >= v138)
                {
                  v139 = 65280;
                }

                else
                {
                  v139 = *(*(a1 + 2712) + v137 + 1) << 8;
                }

                v140 = v137 + 2;
                *(a1 + 2720) = v140;
                if (v140 < v138)
                {
                  v135 = *(*(a1 + 2712) + v140);
                }

                else
                {
                  v135 = 255;
                }

                v133 |= v139 | v135;
                v134 = 16;
                *(a1 + 2744) = 16;
              }

              v136 = 2 * v132;
              v28 = v132 >= 0x20000001;
              v132 *= 2;
            }

            while (!v28);
          }

          v141 = (HIWORD(v136) * v131) & 0xFFFF0000;
          v142 = v136 - v141;
          if (v133 < v141)
          {
            v143 = 0;
          }

          else
          {
            v143 = (HIWORD(v136) * v131) & 0xFFFF0000;
          }

          *(a1 + 2736) = v133 - v143;
          v144 = v133 >= v141;
          if (v133 < v141)
          {
            v145 = (v131 >> 7) & 0x1FE;
          }

          else
          {
            v145 = ((v131 >> 7) & 0x1FE) + 1;
          }

          *(a1 + 2276) = *(v27 + 2 * v145) + v131;
          if (v144)
          {
            v146 = v142;
          }

          else
          {
            v146 = v141;
          }

          *(a1 + 2732) = v146;
          if (v144)
          {
            v147 = 1;
            do
            {
              *(*(a1 + 32) + v147++) = 1;
            }

            while (v85 != v147);
          }

          else if (v219 == 2)
          {
            *(*(a1 + 32) + 1) = 0;
            if (*(a1 + 3816) == 1)
            {
              v149 = gcl::tmesh::DecoderImpl::decodeIndex(a1, *(a1 + 3788));
            }

            else
            {
              v148 = *(a1 + 3788);
              v149 = v148 - gcl::ArithmeticDecoder::decodeExpGolomb((a1 + 2704), 0, (a1 + 2274));
            }

            *(*v83 + 4) = v149;
          }

          else
          {
            v152 = 1;
            do
            {
              v154 = *(a1 + 2732);
              v155 = *(a1 + 2736);
              if (v154 >= 0x40000001)
              {
                v158 = *(a1 + 2732);
              }

              else
              {
                v156 = *(a1 + 2744);
                do
                {
                  v155 *= 2;
                  *(a1 + 2744) = --v156;
                  if (!v156)
                  {
                    v159 = *(a1 + 2720);
                    *(a1 + 2720) = v159 + 1;
                    v160 = *(a1 + 2704);
                    if (v159 + 1 >= v160)
                    {
                      v161 = 65280;
                    }

                    else
                    {
                      v161 = *(*(a1 + 2712) + v159 + 1) << 8;
                    }

                    v162 = v159 + 2;
                    *(a1 + 2720) = v162;
                    if (v162 < v160)
                    {
                      v157 = *(*(a1 + 2712) + v162);
                    }

                    else
                    {
                      v157 = 255;
                    }

                    v155 |= v161 | v157;
                    v156 = 16;
                    *(a1 + 2744) = 16;
                  }

                  v158 = 2 * v154;
                  v28 = v154 >= 0x20000001;
                  v154 *= 2;
                }

                while (!v28);
              }

              v163 = *(a1 + 2278);
              v164 = (HIWORD(v158) * v163) & 0xFFFF0000;
              v165 = (v163 >> 7) & 0x1FE;
              v166 = v158 - v164;
              v167 = v155 >= v164;
              if (v155 >= v164)
              {
                ++v165;
              }

              *(a1 + 2278) = *(v27 + 2 * v165) + v163;
              if (v155 < v164)
              {
                v168 = v164;
              }

              else
              {
                v168 = v166;
              }

              if (v155 < v164)
              {
                v164 = 0;
              }

              *(a1 + 2732) = v168;
              *(a1 + 2736) = v155 - v164;
              *(*(a1 + 32) + v152) = v167;
              if (!*(*(a1 + 32) + v152))
              {
                if (*(a1 + 3816) == 1)
                {
                  v153 = gcl::tmesh::DecoderImpl::decodeIndex(a1, *(a1 + 3788));
                }

                else
                {
                  v169 = *(a1 + 3788);
                  v153 = v169 - gcl::ArithmeticDecoder::decodeExpGolomb((a1 + 2704), 0, (a1 + 2274));
                }

                *(*v83 + 4 * v152) = v153;
              }

              ++v152;
            }

            while (v152 != v85);
          }
        }

        if (*(a1 + 3872))
        {
          return 0xFFFFFFFFLL;
        }

        if ((v220 & 1) == 0)
        {
          v172 = v219;
          if (v218)
          {
            goto LABEL_246;
          }

          if (*(a1 + 3816) == 1)
          {
            v214 = gcl::tmesh::DecoderImpl::decodeIndex(a1, v130 + 1);
          }

          else
          {
            v214 = v130 + 1 + gcl::ArithmeticDecoder::decodeSignedExpGolomb((a1 + 2704), 0, (a1 + 2272), (a1 + 2274));
          }
        }

        v224[v85] = v214;
        v172 = v219;
LABEL_246:
        v89 = (a1 + 3872);
        if (*v217 == 3 || *v217 == 5)
        {
          v173 = *(a1 + 32);
          v174 = v172 + 1;
          do
          {
            if (*(v173 + v85))
            {
              v175 = (*a6)++;
              *(*v83 + 4 * v85) = v175;
            }

            --v85;
            --v174;
          }

          while (v174 > 0);
          v176 = v216;
        }

        else
        {
          v187 = 0;
          v173 = *(a1 + 32);
          v176 = v216;
          do
          {
            if (*(v173 + v187))
            {
              v188 = (*a6)++;
              *(*v83 + 4 * v187) = v188;
            }

            ++v187;
          }

          while (v81 != v187);
        }

        v177 = 0;
        v178 = *(a1 + 152);
        while (1)
        {
          v179 = *(*(a1 + 8) + 4 * v177);
          if (v179 < 0 || v179 >= ((*(a1 + 160) - v178) >> 4))
          {
            goto LABEL_97;
          }

          if (v81 == ++v177)
          {
            v180 = *v217;
            if (*v217 > 2)
            {
              if (v180 == 3 || v180 == 5)
              {
                v189 = v219;
                if (v78 <= 0x7FFFFFFD)
                {
                  v190 = (v178 + 16 * v130);
                  v191 = v190[3];
                  v192 = *v190;
                  v193 = v78;
                  do
                  {
                    v195 = v192;
                    v192 = *(*(a1 + 8) + 4 * v193);
                    if (*(*(a1 + 32) + v193))
                    {
                      v196 = (*(a1 + 176) + 12 * v192);
                      *v196 = v130;
                      v196[1] = v195;
                      v196[2] = v191;
                    }

                    v191 = v195;
                  }

                  while (v193-- > 0);
                }
              }

              else
              {
                v189 = v219;
                if (v81 >= 1)
                {
                  v209 = 0;
                  v210 = -1;
                  v211 = -1;
                  do
                  {
                    v212 = v210;
                    v210 = *(*(a1 + 8) + 4 * v209);
                    if (*(*(a1 + 32) + v209))
                    {
                      v213 = (*(a1 + 176) + 12 * v210);
                      *v213 = v130;
                      v213[1] = v212;
                      v213[2] = v211;
                    }

                    ++v209;
                    v211 = v212;
                  }

                  while (v81 != v209);
                }
              }
            }

            else
            {
              v181 = (v178 + 16 * v130);
              if (v78 <= 0x7FFFFFFD)
              {
                v182 = v181[1];
                v183 = v181[2];
                v184 = 1;
                do
                {
                  v185 = *(*(a1 + 8) + 4 * v184);
                  if (*(*(a1 + 32) + v184))
                  {
                    v186 = (*(a1 + 176) + 12 * v185);
                    *v186 = v130;
                    v186[1] = v182;
                    v186[2] = v183;
                  }

                  ++v184;
                  v183 = v182;
                  v182 = v185;
                }

                while (v81 != v184);
                v173 = *(a1 + 32);
              }

              v189 = v219;
              if (!v180 && *(v173 + v78))
              {
                v197 = (*(a1 + 200) + 12 * *(*(a1 + 8) + 4 * v78));
                *v197 = v130;
                v197[1] = *v181;
                v197[2] = v181[3];
              }
            }

            if (*(a1 + 3816) == 1)
            {
              v198 = *(a1 + 3817) ^ 1;
            }

            else
            {
              v198 = 1;
            }

            if ((*v176 + v189) <= *(a1 + 3792))
            {
              v199 = *(a1 + 152);
              v200 = v81 - 1;
              v201 = (*(a1 + 8) + 4);
              do
              {
                v203 = *(v201 - 1);
                v202 = *v201;
                v204 = (*v176)++;
                v205 = (v215 + 12 * v204);
                *v205 = v130;
                v205[1] = v203;
                v205[2] = v202;
                v206 = (v199 + 16 * v203);
                v207 = v199 + 16 * v202;
                *(v207 + 4) = v203;
                *(v207 + 8) = v130;
                *v206 = v202;
                v206[3] = v130;
                if (v198)
                {
                  v208 = *(a1 + 80);
                  ++*(v208 + 4 * v203);
                  ++*(v208 + 4 * v202);
                }

                ++v201;
                --v200;
              }

              while (v200);
              return v81;
            }

            goto LABEL_97;
          }
        }
      }

      if (*(a1 + 3816) == 1)
      {
        v88 = gcl::tmesh::DecoderImpl::decodeIndex(a1, a2 - 1);
      }

      else
      {
        v88 = a2 - 1 + gcl::ArithmeticDecoder::decodeSignedExpGolomb((a1 + 2704), 0, (a1 + 2272), (a1 + 2274));
      }
    }

    *v86 = v88;
    goto LABEL_162;
  }

LABEL_96:
  v89 = (a1 + 3872);
LABEL_97:
  *v89 = 3;
  return 0xFFFFFFFFLL;
}

uint64_t gcl::tmesh::DecoderImpl::decodeIndex(gcl::tmesh::DecoderImpl *this, int a2)
{
  v3 = *(this + 1119);
  v4 = *(this + 683);
  v5 = *(this + 684);
  if (v4 >= 0x40000001)
  {
    v8 = *(this + 683);
  }

  else
  {
    v6 = *(this + 686);
    do
    {
      v5 *= 2;
      *(this + 686) = --v6;
      if (!v6)
      {
        v9 = *(this + 340);
        *(this + 340) = v9 + 1;
        v10 = *(this + 676);
        if (v9 + 1 >= v10)
        {
          v11 = 65280;
        }

        else
        {
          v11 = *(*(this + 339) + v9 + 1) << 8;
        }

        v12 = v9 + 2;
        *(this + 340) = v12;
        if (v12 < v10)
        {
          v7 = *(*(this + 339) + v12);
        }

        else
        {
          v7 = 255;
        }

        v5 |= v11 | v7;
        v6 = 16;
        *(this + 686) = 16;
      }

      v8 = 2 * v4;
      v18 = v4 >= 0x20000001;
      v4 *= 2;
    }

    while (!v18);
  }

  v13 = (HIWORD(v8) * v3) & 0xFFFF0000;
  v14 = v8 - v13;
  if (v5 < v13)
  {
    v15 = 0;
  }

  else
  {
    v15 = v13;
  }

  v16 = v5 - v15;
  v17 = this + 2752;
  *(this + 684) = v16;
  v18 = v5 >= v13;
  if (v5 < v13)
  {
    v19 = (v3 >> 7) & 0x1FE;
  }

  else
  {
    v19 = ((v3 >> 7) & 0x1FE) + 1;
  }

  *(this + 1119) = *&v17[2 * v19] + v3;
  if (v18)
  {
    v20 = v14;
  }

  else
  {
    v20 = v13;
  }

  *(this + 683) = v20;
  if (!v18)
  {
    return gcl::ArithmeticDecoder::decodeSignedExpGolomb(this + 676, 0, this + 1136, this + 1137) + a2;
  }

  v21 = this + 2280;
  v22 = *(this + 1140);
  if (v14 >= 0x40000001)
  {
    v25 = v14;
  }

  else
  {
    v23 = *(this + 686);
    do
    {
      v16 *= 2;
      *(this + 686) = --v23;
      if (!v23)
      {
        v26 = *(this + 340);
        *(this + 340) = v26 + 1;
        v27 = *(this + 676);
        if (v26 + 1 >= v27)
        {
          v28 = 65280;
        }

        else
        {
          v28 = *(*(this + 339) + v26 + 1) << 8;
        }

        v29 = v26 + 2;
        *(this + 340) = v29;
        if (v29 < v27)
        {
          v24 = *(*(this + 339) + v29);
        }

        else
        {
          v24 = 255;
        }

        v16 |= v28 | v24;
        v23 = 16;
        *(this + 686) = 16;
      }

      v25 = 2 * v14;
      v18 = v14 >= 0x20000001;
      v14 *= 2;
    }

    while (!v18);
  }

  v31 = (HIWORD(v25) * v22) & 0xFFFF0000;
  v32 = (v22 >> 7) & 0x1FE;
  v33 = v25 - v31;
  v34 = v16 >= v31;
  v35 = v16 >= v31;
  if (v16 >= v31)
  {
    ++v32;
  }

  *(this + 1140) = *&v17[2 * v32] + v22;
  if (v16 < v31)
  {
    v33 = v31;
    v31 = 0;
  }

  v36 = 1;
  if (v34)
  {
    v36 = 2;
  }

  v37 = v16 - v31;
  *(this + 683) = v33;
  *(this + 684) = v37;
  v38 = *&v21[2 * v36];
  if (v33 >= 0x40000001)
  {
    v41 = v33;
  }

  else
  {
    v39 = *(this + 686);
    do
    {
      v37 *= 2;
      *(this + 686) = --v39;
      if (!v39)
      {
        v42 = *(this + 340);
        *(this + 340) = v42 + 1;
        v43 = *(this + 676);
        if (v42 + 1 >= v43)
        {
          v44 = 65280;
        }

        else
        {
          v44 = *(*(this + 339) + v42 + 1) << 8;
        }

        v45 = v42 + 2;
        *(this + 340) = v45;
        if (v45 < v43)
        {
          v40 = *(*(this + 339) + v45);
        }

        else
        {
          v40 = 255;
        }

        v37 |= v44 | v40;
        v39 = 16;
        *(this + 686) = 16;
      }

      v41 = 2 * v33;
      v18 = v33 >= 0x20000001;
      v33 *= 2;
    }

    while (!v18);
  }

  v46 = (HIWORD(v41) * v38) & 0xFFFF0000;
  v47 = (v38 >> 7) & 0x1FE;
  v48 = v41 - v46;
  if (v37 >= v46)
  {
    ++v47;
  }

  *&v21[2 * v36] = *&v17[2 * v47] + v38;
  if (v37 < v46)
  {
    v49 = v46;
  }

  else
  {
    v49 = v48;
  }

  if (v37 < v46)
  {
    v50 = 0;
  }

  else
  {
    v50 = v46;
  }

  v51 = v37 - v50;
  *(this + 683) = v49;
  *(this + 684) = v51;
  v52 = v35 | (2 * (v37 >= v46));
  v53 = *&v21[2 * (v52 + 3)];
  if (v49 >= 0x40000001)
  {
    v56 = v49;
  }

  else
  {
    v54 = *(this + 686);
    do
    {
      v51 *= 2;
      *(this + 686) = --v54;
      if (!v54)
      {
        v57 = *(this + 340);
        *(this + 340) = v57 + 1;
        v58 = *(this + 676);
        if (v57 + 1 >= v58)
        {
          v59 = 65280;
        }

        else
        {
          v59 = *(*(this + 339) + v57 + 1) << 8;
        }

        v60 = v57 + 2;
        *(this + 340) = v60;
        if (v60 < v58)
        {
          v55 = *(*(this + 339) + v60);
        }

        else
        {
          v55 = 255;
        }

        v51 |= v59 | v55;
        v54 = 16;
        *(this + 686) = 16;
      }

      v56 = 2 * v49;
      v18 = v49 >= 0x20000001;
      v49 *= 2;
    }

    while (!v18);
  }

  v61 = (HIWORD(v56) * v53) & 0xFFFF0000;
  v62 = (v53 >> 7) & 0x1FE;
  v63 = v56 - v61;
  if (v51 >= v61)
  {
    ++v62;
  }

  *&v21[2 * (v52 + 3)] = *&v17[2 * v62] + v53;
  if (v51 < v61)
  {
    v64 = v61;
  }

  else
  {
    v64 = v63;
  }

  if (v51 < v61)
  {
    v65 = 0;
  }

  else
  {
    v65 = v61;
  }

  v66 = v51 - v65;
  *(this + 683) = v64;
  *(this + 684) = v66;
  v67 = v52 | (4 * (v51 >= v61));
  v68 = *&v21[2 * (v67 + 7)];
  if (v64 >= 0x40000001)
  {
    v71 = v64;
  }

  else
  {
    v69 = *(this + 686);
    do
    {
      v66 *= 2;
      *(this + 686) = --v69;
      if (!v69)
      {
        v72 = *(this + 340);
        *(this + 340) = v72 + 1;
        v73 = *(this + 676);
        if (v72 + 1 >= v73)
        {
          v74 = 65280;
        }

        else
        {
          v74 = *(*(this + 339) + v72 + 1) << 8;
        }

        v75 = v72 + 2;
        *(this + 340) = v75;
        if (v75 < v73)
        {
          v70 = *(*(this + 339) + v75);
        }

        else
        {
          v70 = 255;
        }

        v66 |= v74 | v70;
        v69 = 16;
        *(this + 686) = 16;
      }

      v71 = 2 * v64;
      v18 = v64 >= 0x20000001;
      v64 *= 2;
    }

    while (!v18);
  }

  v76 = (HIWORD(v71) * v68) & 0xFFFF0000;
  v77 = (v68 >> 7) & 0x1FE;
  v78 = v71 - v76;
  if (v66 >= v76)
  {
    ++v77;
  }

  *&v21[2 * (v67 + 7)] = *&v17[2 * v77] + v68;
  if (v66 < v76)
  {
    v79 = v76;
  }

  else
  {
    v79 = v78;
  }

  if (v66 < v76)
  {
    v80 = 0;
  }

  else
  {
    v80 = v76;
  }

  v81 = v66 - v80;
  *(this + 683) = v79;
  *(this + 684) = v81;
  v82 = v67 | (8 * (v66 >= v76));
  v83 = *&v21[2 * (v82 + 15)];
  if (v79 >= 0x40000001)
  {
    v86 = v79;
  }

  else
  {
    v84 = *(this + 686);
    do
    {
      v81 *= 2;
      *(this + 686) = --v84;
      if (!v84)
      {
        v87 = *(this + 340);
        *(this + 340) = v87 + 1;
        v88 = *(this + 676);
        if (v87 + 1 >= v88)
        {
          v89 = 65280;
        }

        else
        {
          v89 = *(*(this + 339) + v87 + 1) << 8;
        }

        v90 = v87 + 2;
        *(this + 340) = v90;
        if (v90 < v88)
        {
          v85 = *(*(this + 339) + v90);
        }

        else
        {
          v85 = 255;
        }

        v81 |= v89 | v85;
        v84 = 16;
        *(this + 686) = 16;
      }

      v86 = 2 * v79;
      v18 = v79 >= 0x20000001;
      v79 *= 2;
    }

    while (!v18);
  }

  v91 = (HIWORD(v86) * v83) & 0xFFFF0000;
  v92 = (v83 >> 7) & 0x1FE;
  v93 = v86 - v91;
  if (v81 >= v91)
  {
    ++v92;
  }

  *&v21[2 * (v82 + 15)] = *&v17[2 * v92] + v83;
  if (v81 < v91)
  {
    v94 = v91;
  }

  else
  {
    v94 = v93;
  }

  if (v81 < v91)
  {
    v95 = 0;
  }

  else
  {
    v95 = v91;
  }

  v96 = v81 - v95;
  *(this + 683) = v94;
  *(this + 684) = v96;
  v97 = v82 | (16 * (v81 >= v91));
  v98 = *&v21[2 * (v97 + 31)];
  if (v94 >= 0x40000001)
  {
    v101 = v94;
  }

  else
  {
    v99 = *(this + 686);
    do
    {
      v96 *= 2;
      *(this + 686) = --v99;
      if (!v99)
      {
        v102 = *(this + 340);
        *(this + 340) = v102 + 1;
        v103 = *(this + 676);
        if (v102 + 1 >= v103)
        {
          v104 = 65280;
        }

        else
        {
          v104 = *(*(this + 339) + v102 + 1) << 8;
        }

        v105 = v102 + 2;
        *(this + 340) = v105;
        if (v105 < v103)
        {
          v100 = *(*(this + 339) + v105);
        }

        else
        {
          v100 = 255;
        }

        v96 |= v104 | v100;
        v99 = 16;
        *(this + 686) = 16;
      }

      v101 = 2 * v94;
      v18 = v94 >= 0x20000001;
      v94 *= 2;
    }

    while (!v18);
  }

  v106 = (HIWORD(v101) * v98) & 0xFFFF0000;
  v107 = (v98 >> 7) & 0x1FE;
  v108 = v101 - v106;
  if (v96 >= v106)
  {
    ++v107;
  }

  v109 = v96 >= v106;
  *&v21[2 * (v97 + 31)] = *&v17[2 * v107] + v98;
  if (v96 < v106)
  {
    v110 = v106;
  }

  else
  {
    v110 = v108;
  }

  if (v96 < v106)
  {
    v111 = 0;
  }

  else
  {
    v111 = v106;
  }

  v112 = v96 - v111;
  *(this + 683) = v110;
  *(this + 684) = v96 - v111;
  v113 = this + 2408;
  v114 = *(this + 1204);
  if (v110 >= 0x40000001)
  {
    v117 = v110;
  }

  else
  {
    v115 = *(this + 686);
    do
    {
      v112 *= 2;
      *(this + 686) = --v115;
      if (!v115)
      {
        v118 = *(this + 340);
        *(this + 340) = v118 + 1;
        v119 = *(this + 676);
        if (v118 + 1 >= v119)
        {
          v120 = 65280;
        }

        else
        {
          v120 = *(*(this + 339) + v118 + 1) << 8;
        }

        v121 = v118 + 2;
        *(this + 340) = v121;
        if (v121 < v119)
        {
          v116 = *(*(this + 339) + v121);
        }

        else
        {
          v116 = 255;
        }

        v112 |= v120 | v116;
        v115 = 16;
        *(this + 686) = 16;
      }

      v117 = 2 * v110;
      v18 = v110 >= 0x20000001;
      v110 *= 2;
    }

    while (!v18);
  }

  v122 = (HIWORD(v117) * v114) & 0xFFFF0000;
  v123 = (v114 >> 7) & 0x1FE;
  v124 = v117 - v122;
  v125 = v112 >= v122;
  v126 = v112 >= v122;
  if (v112 >= v122)
  {
    ++v123;
  }

  *(this + 1204) = *&v17[2 * v123] + v114;
  if (v112 < v122)
  {
    v124 = v122;
    v122 = 0;
  }

  v127 = 1;
  if (v125)
  {
    v127 = 2;
  }

  v128 = v112 - v122;
  *(this + 683) = v124;
  *(this + 684) = v128;
  v129 = *&v113[2 * v127];
  if (v124 >= 0x40000001)
  {
    v132 = v124;
  }

  else
  {
    v130 = *(this + 686);
    do
    {
      v128 *= 2;
      *(this + 686) = --v130;
      if (!v130)
      {
        v133 = *(this + 340);
        *(this + 340) = v133 + 1;
        v134 = *(this + 676);
        if (v133 + 1 >= v134)
        {
          v135 = 65280;
        }

        else
        {
          v135 = *(*(this + 339) + v133 + 1) << 8;
        }

        v136 = v133 + 2;
        *(this + 340) = v136;
        if (v136 < v134)
        {
          v131 = *(*(this + 339) + v136);
        }

        else
        {
          v131 = 255;
        }

        v128 |= v135 | v131;
        v130 = 16;
        *(this + 686) = 16;
      }

      v132 = 2 * v124;
      v18 = v124 >= 0x20000001;
      v124 *= 2;
    }

    while (!v18);
  }

  v137 = (HIWORD(v132) * v129) & 0xFFFF0000;
  v138 = (v129 >> 7) & 0x1FE;
  v139 = v132 - v137;
  v140 = v128 >= v137;
  if (v128 >= v137)
  {
    ++v138;
  }

  *&v113[2 * v127] = *&v17[2 * v138] + v129;
  if (v128 < v137)
  {
    v141 = v137;
  }

  else
  {
    v141 = v139;
  }

  if (v128 < v137)
  {
    v137 = 0;
  }

  *(this + 683) = v141;
  *(this + 684) = v128 - v137;
  v142 = v126 | (2 * v140);
  if (v142 == 3)
  {
    v143 = gcl::ArithmeticDecoder::decodeExpGolomb(this + 676, 0, this + 1207);
    if (v143 < -3)
    {
      goto LABEL_185;
    }

    v142 = v143 + 3;
  }

  v144 = *(this + 3 * (v97 | (32 * v109)) + 32);
  if (v142 < ((*(this + 3 * (v97 | (32 * v109)) + 33) - v144) >> 3))
  {
    v145 = *(v144 + 8 * v142);
    if (v145)
    {
      return -1431655765 * ((v145 - *(this + 28)) >> 2);
    }
  }

LABEL_185:
  *(this + 968) = 3;
  return 0xFFFFFFFFLL;
}

uint64_t gcl::ArithmeticDecoder::decodeSignedExpGolomb(unsigned int *a1, int a2, _WORD *a3, _WORD *a4)
{
  result = gcl::ArithmeticDecoder::decodeExpGolomb(a1, a2, a4);
  if (result)
  {
    v7 = *a3;
    v9 = a1[7];
    v8 = a1[8];
    if (v9 > 0x40000000)
    {
      v12 = a1[7];
    }

    else
    {
      v10 = a1[10];
      do
      {
        v8 *= 2;
        a1[10] = --v10;
        if (!v10)
        {
          v13 = *(a1 + 2);
          *(a1 + 2) = v13 + 1;
          v14 = *a1;
          if (v13 + 1 >= v14)
          {
            v15 = 65280;
          }

          else
          {
            v15 = *(*(a1 + 1) + v13 + 1) << 8;
          }

          v16 = v13 + 2;
          *(a1 + 2) = v16;
          if (v16 < v14)
          {
            v11 = *(*(a1 + 1) + v16);
          }

          else
          {
            v11 = 255;
          }

          v8 |= v15 | v11;
          v10 = 16;
          a1[10] = 16;
        }

        v12 = 2 * v9;
        v19 = v9 >= 0x20000001;
        v9 *= 2;
      }

      while (!v19);
    }

    v17 = (HIWORD(v12) * v7) & 0xFFFF0000;
    v18 = (v7 >> 7) & 0x1FE;
    v19 = v8 >= v17;
    if (v8 >= v17)
    {
      ++v18;
    }

    *a3 = *(a1 + v18 + 24) + v7;
    if (v8 < v17)
    {
      v20 = (HIWORD(v12) * v7) & 0xFFFF0000;
    }

    else
    {
      v20 = v12 - v17;
    }

    if (v8 < v17)
    {
      v17 = 0;
    }

    if (v19)
    {
      result = result;
    }

    else
    {
      result = -result;
    }

    a1[7] = v20;
    a1[8] = v8 - v17;
  }

  return result;
}

uint64_t gcl::tmesh::DecoderImpl::decodeResidual(uint64_t result, uint64_t a2, unsigned __int8 a3, uint64_t *a4)
{
  v6 = result;
  if (a3 > 2u)
  {
    if (a3 == 3)
    {
      v285 = *(a2 + 2688);
      if (v285 <= 0)
      {
        v287 = 0;
      }

      else
      {
        v286 = 0;
        v287 = 0;
        v288 = *(a2 + 2732);
        v289 = *(a2 + 2736);
        do
        {
          if (v288 >= 0x40000001)
          {
            v290 = v288;
          }

          else
          {
            v293 = *(a2 + 2744);
            do
            {
              v289 *= 2;
              *(a2 + 2744) = --v293;
              if (!v293)
              {
                v295 = *(a2 + 2720);
                *(a2 + 2720) = v295 + 1;
                v296 = *(a2 + 2704);
                if (v295 + 1 >= v296)
                {
                  v297 = 65280;
                }

                else
                {
                  result = *(a2 + 2712);
                  v297 = *(result + v295 + 1) << 8;
                }

                v298 = v295 + 2;
                *(a2 + 2720) = v298;
                if (v298 < v296)
                {
                  v294 = *(*(a2 + 2712) + v298);
                }

                else
                {
                  v294 = 255;
                }

                v289 |= v297 | v294;
                v293 = 16;
                *(a2 + 2744) = 16;
              }

              v290 = 2 * v288;
              v31 = v288 >= 0x20000001;
              v288 *= 2;
            }

            while (!v31);
          }

          v291 = (v290 >> 1) & 0x7FFF0000;
          v288 = v290 - v291;
          v292 = v289 >= v291;
          if (v289 < v291)
          {
            v288 = v291;
            v291 = 0;
          }

          v289 -= v291;
          *(a2 + 2732) = v288;
          *(a2 + 2736) = v289;
          v287 += v292 << v286++;
        }

        while (v286 != v285);
      }

      *v6 = v287;
      v310 = *(a2 + 2692);
      if (v310 < 1)
      {
        v312 = 0;
      }

      else
      {
        v311 = 0;
        v312 = 0;
        v313 = *(a2 + 2732);
        v314 = *(a2 + 2736);
        do
        {
          if (v313 >= 0x40000001)
          {
            v315 = v313;
          }

          else
          {
            v318 = *(a2 + 2744);
            do
            {
              v314 *= 2;
              *(a2 + 2744) = --v318;
              if (!v318)
              {
                v320 = *(a2 + 2720);
                *(a2 + 2720) = v320 + 1;
                v321 = *(a2 + 2704);
                if (v320 + 1 >= v321)
                {
                  v322 = 65280;
                }

                else
                {
                  result = *(a2 + 2712);
                  v322 = *(result + v320 + 1) << 8;
                }

                v323 = v320 + 2;
                *(a2 + 2720) = v323;
                if (v323 < v321)
                {
                  v319 = *(*(a2 + 2712) + v323);
                }

                else
                {
                  v319 = 255;
                }

                v314 |= v322 | v319;
                v318 = 16;
                *(a2 + 2744) = 16;
              }

              v315 = 2 * v313;
              v31 = v313 >= 0x20000001;
              v313 *= 2;
            }

            while (!v31);
          }

          v316 = (v315 >> 1) & 0x7FFF0000;
          v313 = v315 - v316;
          v317 = v314 >= v316;
          if (v314 < v316)
          {
            v313 = v316;
            v316 = 0;
          }

          v314 -= v316;
          *(a2 + 2732) = v313;
          *(a2 + 2736) = v314;
          v312 += v317 << v311++;
        }

        while (v311 != v310);
      }

      v6[1] = v312;
      v324 = *(a2 + 2696);
      if (v324 < 1)
      {
        v6[2] = 0;
        return result;
      }

      v325 = 0;
      LODWORD(result) = 0;
      v326 = *(a2 + 2732);
      v327 = *(a2 + 2736);
      do
      {
        if (v326 >= 0x40000001)
        {
          v328 = v326;
        }

        else
        {
          v331 = *(a2 + 2744);
          do
          {
            v327 *= 2;
            *(a2 + 2744) = --v331;
            if (!v331)
            {
              v333 = *(a2 + 2720);
              *(a2 + 2720) = v333 + 1;
              v334 = *(a2 + 2704);
              if (v333 + 1 >= v334)
              {
                v335 = 65280;
              }

              else
              {
                v335 = *(*(a2 + 2712) + v333 + 1) << 8;
              }

              v336 = v333 + 2;
              *(a2 + 2720) = v336;
              if (v336 < v334)
              {
                v332 = *(*(a2 + 2712) + v336);
              }

              else
              {
                v332 = 255;
              }

              v327 |= v335 | v332;
              v331 = 16;
              *(a2 + 2744) = 16;
            }

            v328 = 2 * v326;
            v31 = v326 >= 0x20000001;
            v326 *= 2;
          }

          while (!v31);
        }

        v329 = (v328 >> 1) & 0x7FFF0000;
        v326 = v328 - v329;
        v330 = v327 >= v329;
        if (v327 < v329)
        {
          v326 = v329;
          v329 = 0;
        }

        v327 -= v329;
        *(a2 + 2732) = v326;
        *(a2 + 2736) = v327;
        result = ((v330 << v325++) + result);
      }

      while (v325 != v324);
      goto LABEL_392;
    }

    if (a3 != 4)
    {
      return result;
    }

    v13 = 0;
    v14 = a2 + 2752;
    v15 = *a4;
    while (1)
    {
      v18 = *(v15 + 2 * v13);
      v19 = *(a2 + 2732);
      v20 = *(a2 + 2736);
      if (v19 >= 0x40000001)
      {
        v23 = *(a2 + 2732);
      }

      else
      {
        v21 = *(a2 + 2744);
        do
        {
          v20 *= 2;
          *(a2 + 2744) = --v21;
          if (!v21)
          {
            v24 = *(a2 + 2720);
            *(a2 + 2720) = v24 + 1;
            v25 = *(a2 + 2704);
            if (v24 + 1 >= v25)
            {
              v26 = 65280;
            }

            else
            {
              v26 = *(*(a2 + 2712) + v24 + 1) << 8;
            }

            v27 = v24 + 2;
            *(a2 + 2720) = v27;
            if (v27 < v25)
            {
              v22 = *(*(a2 + 2712) + v27);
            }

            else
            {
              v22 = 255;
            }

            v20 |= v26 | v22;
            v21 = 16;
            *(a2 + 2744) = 16;
          }

          v23 = 2 * v19;
          v31 = v19 >= 0x20000001;
          v19 *= 2;
        }

        while (!v31);
      }

      v28 = (HIWORD(v23) * v18) & 0xFFFF0000;
      v29 = v20 < v28 ? 0 : (HIWORD(v23) * v18) & 0xFFFF0000;
      v30 = v20 - v29;
      *(a2 + 2736) = v20 - v29;
      v31 = v20 >= v28;
      v32 = v20 < v28 ? (v18 >> 7) & 0x1FE : ((v18 >> 7) & 0x1FE) + 1;
      v33 = v23 - v28;
      *(v15 + 2 * v13) = *(v14 + 2 * v32) + v18;
      v34 = v31 ? v23 - v28 : (HIWORD(v23) * v18) & 0xFFFF0000;
      *(a2 + 2732) = v34;
      if (v31)
      {
        break;
      }

      v17 = 0;
LABEL_21:
      v6[v13++] = v17;
      if (v13 == 3)
      {
        return result;
      }
    }

    v35 = a4[3];
    v36 = *(v35 + 2 * v13);
    if (v33 >= 0x40000001)
    {
      v39 = v23 - v28;
    }

    else
    {
      v37 = *(a2 + 2744);
      do
      {
        v30 *= 2;
        *(a2 + 2744) = --v37;
        if (!v37)
        {
          v40 = *(a2 + 2720);
          *(a2 + 2720) = v40 + 1;
          v41 = *(a2 + 2704);
          if (v40 + 1 >= v41)
          {
            v42 = 65280;
          }

          else
          {
            v42 = *(*(a2 + 2712) + v40 + 1) << 8;
          }

          v43 = v40 + 2;
          *(a2 + 2720) = v43;
          if (v43 < v41)
          {
            v38 = *(*(a2 + 2712) + v43);
          }

          else
          {
            v38 = 255;
          }

          v30 |= v42 | v38;
          v37 = 16;
          *(a2 + 2744) = 16;
        }

        v39 = 2 * v33;
        v31 = v33 >= 0x20000001;
        v33 *= 2;
      }

      while (!v31);
    }

    v44 = (HIWORD(v39) * v36) & 0xFFFF0000;
    v45 = (v36 >> 7) & 0x1FE;
    v46 = v39 - v44;
    if (v30 >= v44)
    {
      ++v45;
    }

    *(v35 + 2 * v13) = *(v14 + 2 * v45) + v36;
    if (v30 >= v44)
    {
      v47 = (HIWORD(v39) * v36) & 0xFFFF0000;
    }

    else
    {
      v46 = (HIWORD(v39) * v36) & 0xFFFF0000;
      v47 = 0;
    }

    v48 = v30 - v47;
    *(a2 + 2732) = v46;
    *(a2 + 2736) = v30 - v47;
    v49 = (a4[6] + (v13 << 7));
    v50 = *v49;
    if (v46 >= 0x40000001)
    {
      v53 = v46;
    }

    else
    {
      v51 = *(a2 + 2744);
      do
      {
        v48 *= 2;
        *(a2 + 2744) = --v51;
        if (!v51)
        {
          v54 = *(a2 + 2720);
          *(a2 + 2720) = v54 + 1;
          v55 = *(a2 + 2704);
          if (v54 + 1 >= v55)
          {
            v56 = 65280;
          }

          else
          {
            v56 = *(*(a2 + 2712) + v54 + 1) << 8;
          }

          v57 = v54 + 2;
          *(a2 + 2720) = v57;
          if (v57 < v55)
          {
            v52 = *(*(a2 + 2712) + v57);
          }

          else
          {
            v52 = 255;
          }

          v48 |= v56 | v52;
          v51 = 16;
          *(a2 + 2744) = 16;
        }

        v53 = 2 * v46;
        v31 = v46 >= 0x20000001;
        v46 *= 2;
      }

      while (!v31);
    }

    v58 = (HIWORD(v53) * v50) & 0xFFFF0000;
    v59 = (v50 >> 7) & 0x1FE;
    v60 = v53 - v58;
    if (v48 >= v58)
    {
      ++v59;
    }

    v61 = *(v14 + 2 * v59);
    v62 = v48 >= v58;
    *v49 = v61 + v50;
    if (v48 >= v58)
    {
      v63 = v58;
    }

    else
    {
      v60 = v58;
      v63 = 0;
    }

    v64 = v48 - v63;
    *(a2 + 2732) = v60;
    *(a2 + 2736) = v64;
    v65 = &v49[v62 & 0x7FFFFFF];
    v66 = v65[1];
    if (v60 >= 0x40000001)
    {
      v69 = v60;
    }

    else
    {
      v67 = *(a2 + 2744);
      do
      {
        v64 *= 2;
        *(a2 + 2744) = --v67;
        if (!v67)
        {
          v70 = *(a2 + 2720);
          *(a2 + 2720) = v70 + 1;
          v71 = *(a2 + 2704);
          if (v70 + 1 >= v71)
          {
            v72 = 65280;
          }

          else
          {
            result = *(a2 + 2712);
            v72 = *(result + v70 + 1) << 8;
          }

          v73 = v70 + 2;
          *(a2 + 2720) = v73;
          if (v73 < v71)
          {
            v68 = *(*(a2 + 2712) + v73);
          }

          else
          {
            v68 = 255;
          }

          v64 |= v72 | v68;
          v67 = 16;
          *(a2 + 2744) = 16;
        }

        v69 = 2 * v60;
        v31 = v60 >= 0x20000001;
        v60 *= 2;
      }

      while (!v31);
    }

    v74 = 32 * v62;
    v75 = (HIWORD(v69) * v66) & 0xFFFF0000;
    v76 = (v66 >> 7) & 0x1FE;
    v77 = v69 - v75;
    if (v64 >= v75)
    {
      ++v76;
    }

    v65[1] = *(v14 + 2 * v76) + v66;
    if (v64 < v75)
    {
      v78 = v75;
    }

    else
    {
      v78 = v77;
    }

    if (v64 < v75)
    {
      v79 = 0;
    }

    else
    {
      v79 = v75;
    }

    v80 = v64 - v79;
    *(a2 + 2732) = v78;
    *(a2 + 2736) = v80;
    v81 = v74 | (16 * (v64 >= v75));
    v82 = &v49[v81 >> 4];
    v83 = v82[3];
    if (v78 >= 0x40000001)
    {
      v86 = v78;
    }

    else
    {
      v84 = *(a2 + 2744);
      do
      {
        v80 *= 2;
        *(a2 + 2744) = --v84;
        if (!v84)
        {
          v87 = *(a2 + 2720);
          *(a2 + 2720) = v87 + 1;
          v88 = *(a2 + 2704);
          if (v87 + 1 >= v88)
          {
            v89 = 65280;
          }

          else
          {
            result = *(a2 + 2712);
            v89 = *(result + v87 + 1) << 8;
          }

          v90 = v87 + 2;
          *(a2 + 2720) = v90;
          if (v90 < v88)
          {
            v85 = *(*(a2 + 2712) + v90);
          }

          else
          {
            v85 = 255;
          }

          v80 |= v89 | v85;
          v84 = 16;
          *(a2 + 2744) = 16;
        }

        v86 = 2 * v78;
        v31 = v78 >= 0x20000001;
        v78 *= 2;
      }

      while (!v31);
    }

    v91 = (HIWORD(v86) * v83) & 0xFFFF0000;
    v92 = (v83 >> 7) & 0x1FE;
    v93 = v86 - v91;
    v94 = v80 >= v91;
    if (v80 >= v91)
    {
      ++v92;
    }

    v82[3] = *(v14 + 2 * v92) + v83;
    if (v80 < v91)
    {
      v95 = v91;
    }

    else
    {
      v95 = v93;
    }

    if (v80 < v91)
    {
      v96 = 0;
    }

    else
    {
      v96 = v91;
    }

    v97 = v80 - v96;
    *(a2 + 2732) = v95;
    *(a2 + 2736) = v97;
    v98 = v81 | (8 * v94);
    v99 = &v49[v98 >> 3];
    v100 = v99[7];
    if (v95 >= 0x40000001)
    {
      v103 = v95;
    }

    else
    {
      v101 = *(a2 + 2744);
      do
      {
        v97 *= 2;
        *(a2 + 2744) = --v101;
        if (!v101)
        {
          v104 = *(a2 + 2720);
          *(a2 + 2720) = v104 + 1;
          v105 = *(a2 + 2704);
          if (v104 + 1 >= v105)
          {
            v106 = 65280;
          }

          else
          {
            result = *(a2 + 2712);
            v106 = *(result + v104 + 1) << 8;
          }

          v107 = v104 + 2;
          *(a2 + 2720) = v107;
          if (v107 < v105)
          {
            v102 = *(*(a2 + 2712) + v107);
          }

          else
          {
            v102 = 255;
          }

          v97 |= v106 | v102;
          v101 = 16;
          *(a2 + 2744) = 16;
        }

        v103 = 2 * v95;
        v31 = v95 >= 0x20000001;
        v95 *= 2;
      }

      while (!v31);
    }

    v108 = (HIWORD(v103) * v100) & 0xFFFF0000;
    v109 = (v100 >> 7) & 0x1FE;
    v110 = v103 - v108;
    v111 = v97 >= v108;
    if (v97 >= v108)
    {
      ++v109;
    }

    v99[7] = *(v14 + 2 * v109) + v100;
    if (v97 < v108)
    {
      v112 = v108;
    }

    else
    {
      v112 = v110;
    }

    if (v97 < v108)
    {
      v113 = 0;
    }

    else
    {
      v113 = v108;
    }

    v114 = v97 - v113;
    *(a2 + 2732) = v112;
    *(a2 + 2736) = v114;
    v115 = v98 | (4 * v111);
    v116 = &v49[v115 >> 2];
    v117 = v116[15];
    if (v112 >= 0x40000001)
    {
      v120 = v112;
    }

    else
    {
      v118 = *(a2 + 2744);
      do
      {
        v114 *= 2;
        *(a2 + 2744) = --v118;
        if (!v118)
        {
          v121 = *(a2 + 2720);
          *(a2 + 2720) = v121 + 1;
          v122 = *(a2 + 2704);
          if (v121 + 1 >= v122)
          {
            v123 = 65280;
          }

          else
          {
            result = *(a2 + 2712);
            v123 = *(result + v121 + 1) << 8;
          }

          v124 = v121 + 2;
          *(a2 + 2720) = v124;
          if (v124 < v122)
          {
            v119 = *(*(a2 + 2712) + v124);
          }

          else
          {
            v119 = 255;
          }

          v114 |= v123 | v119;
          v118 = 16;
          *(a2 + 2744) = 16;
        }

        v120 = 2 * v112;
        v31 = v112 >= 0x20000001;
        v112 *= 2;
      }

      while (!v31);
    }

    v125 = (HIWORD(v120) * v117) & 0xFFFF0000;
    v126 = (v117 >> 7) & 0x1FE;
    v127 = v120 - v125;
    if (v114 >= v125)
    {
      ++v126;
    }

    v128 = v114 >= v125;
    v116[15] = *(v14 + 2 * v126) + v117;
    if (v114 < v125)
    {
      v129 = v125;
    }

    else
    {
      v129 = v127;
    }

    if (v114 < v125)
    {
      v130 = 0;
    }

    else
    {
      v130 = v125;
    }

    v131 = v114 - v130;
    *(a2 + 2732) = v129;
    *(a2 + 2736) = v131;
    v132 = v115 | (2 * v128);
    v133 = v49 + v132;
    v134 = *(v133 + 31);
    if (v129 >= 0x40000001)
    {
      v137 = v129;
    }

    else
    {
      v135 = *(a2 + 2744);
      do
      {
        v131 *= 2;
        *(a2 + 2744) = --v135;
        if (!v135)
        {
          v138 = *(a2 + 2720);
          *(a2 + 2720) = v138 + 1;
          v139 = *(a2 + 2704);
          if (v138 + 1 >= v139)
          {
            v140 = 65280;
          }

          else
          {
            v140 = *(*(a2 + 2712) + v138 + 1) << 8;
          }

          v141 = v138 + 2;
          *(a2 + 2720) = v141;
          if (v141 < v139)
          {
            v136 = *(*(a2 + 2712) + v141);
          }

          else
          {
            v136 = 255;
          }

          v131 |= v140 | v136;
          v135 = 16;
          *(a2 + 2744) = 16;
        }

        v137 = 2 * v129;
        v31 = v129 >= 0x20000001;
        v129 *= 2;
      }

      while (!v31);
    }

    v142 = (HIWORD(v137) * v134) & 0xFFFF0000;
    v143 = (v134 >> 7) & 0x1FE;
    v144 = v137 - v142;
    v145 = v131 >= v142;
    if (v131 >= v142)
    {
      ++v143;
    }

    *(v133 + 31) = *(v14 + 2 * v143) + v134;
    if (v131 < v142)
    {
      v146 = v142;
    }

    else
    {
      v146 = v144;
    }

    if (v131 < v142)
    {
      v142 = 0;
    }

    if (v145)
    {
      v147 = v132 + 1;
    }

    else
    {
      v147 = v132;
    }

    *(a2 + 2732) = v146;
    *(a2 + 2736) = v131 - v142;
    if (v147 == 63)
    {
      v148 = a4[12];
      result = gcl::ArithmeticDecoder::decodeExpGolomb((a2 + 2704), *(v148 + 4 * v13), (a4[9] + 2 * v13));
      v147 = result + 63;
      v149 = *(v148 + 4 * v13);
      v150 = (result + 63) >> v149;
      v15 = *a4;
      if (v149 && !v150)
      {
        v16 = -1;
LABEL_17:
        *(v148 + 4 * v13) = v149 + v16;
        goto LABEL_18;
      }

      if (v150 >= 2)
      {
        v16 = 1;
        goto LABEL_17;
      }
    }

LABEL_18:
    if (v30 >= v44)
    {
      v17 = v147 + 1;
    }

    else
    {
      v17 = ~v147;
    }

    goto LABEL_21;
  }

  if (a3)
  {
    if (a3 != 2)
    {
      return result;
    }

    v7 = a4[12];
    v8 = gcl::ArithmeticDecoder::decodeSignedExpGolomb((a2 + 2704), *v7, a4[3], a4[9]);
    if (v8 >= 0)
    {
      v9 = v8;
    }

    else
    {
      v9 = -v8;
    }

    v10 = v9 >> *v7;
    if (*v7)
    {
      v11 = v10 == 0;
    }

    else
    {
      v11 = 0;
    }

    if (v11)
    {
      v12 = -1;
    }

    else
    {
      if (v10 < 2)
      {
        goto LABEL_374;
      }

      v12 = 1;
    }

    *v7 += v12;
LABEL_374:
    *v6 = v8;
    v299 = a4[12];
    v300 = gcl::ArithmeticDecoder::decodeSignedExpGolomb((a2 + 2704), *(v299 + 4), (a4[3] + 2), (a4[9] + 2));
    if (v300 >= 0)
    {
      v301 = v300;
    }

    else
    {
      v301 = -v300;
    }

    v302 = *(v299 + 4);
    v303 = v301 >> v302;
    if (!v302 || v303)
    {
      if (v303 < 2)
      {
        goto LABEL_383;
      }

      v304 = 1;
    }

    else
    {
      v304 = -1;
    }

    *(v299 + 4) = v302 + v304;
LABEL_383:
    v6[1] = v300;
    v305 = a4[12];
    result = gcl::ArithmeticDecoder::decodeSignedExpGolomb((a2 + 2704), *(v305 + 8), (a4[3] + 4), (a4[9] + 4));
    if (result >= 0)
    {
      v306 = result;
    }

    else
    {
      v306 = -result;
    }

    v307 = *(v305 + 8);
    v308 = v306 >> v307;
    if (!v307 || v308)
    {
      if (v308 < 2)
      {
LABEL_392:
        v6[2] = result;
        return result;
      }

      v309 = 1;
    }

    else
    {
      v309 = -1;
    }

    *(v305 + 8) = v307 + v309;
    goto LABEL_392;
  }

  v151 = 0;
  v152 = a2 + 2752;
  v153 = *a4;
  do
  {
    v155 = *(v153 + 2 * v151);
    v156 = *(a2 + 2732);
    v157 = *(a2 + 2736);
    if (v156 >= 0x40000001)
    {
      v160 = *(a2 + 2732);
    }

    else
    {
      v158 = *(a2 + 2744);
      do
      {
        v157 *= 2;
        *(a2 + 2744) = --v158;
        if (!v158)
        {
          v161 = *(a2 + 2720);
          *(a2 + 2720) = v161 + 1;
          v162 = *(a2 + 2704);
          if (v161 + 1 >= v162)
          {
            v163 = 65280;
          }

          else
          {
            v163 = *(*(a2 + 2712) + v161 + 1) << 8;
          }

          v164 = v161 + 2;
          *(a2 + 2720) = v164;
          if (v164 < v162)
          {
            v159 = *(*(a2 + 2712) + v164);
          }

          else
          {
            v159 = 255;
          }

          v157 |= v163 | v159;
          v158 = 16;
          *(a2 + 2744) = 16;
        }

        v160 = 2 * v156;
        v31 = v156 >= 0x20000001;
        v156 *= 2;
      }

      while (!v31);
    }

    v165 = (HIWORD(v160) * v155) & 0xFFFF0000;
    if (v157 < v165)
    {
      v166 = 0;
    }

    else
    {
      v166 = (HIWORD(v160) * v155) & 0xFFFF0000;
    }

    v167 = v157 - v166;
    *(a2 + 2736) = v157 - v166;
    v168 = v157 >= v165;
    if (v157 < v165)
    {
      v169 = (v155 >> 7) & 0x1FE;
    }

    else
    {
      v169 = ((v155 >> 7) & 0x1FE) + 1;
    }

    v170 = v160 - v165;
    *(v153 + 2 * v151) = *(v152 + 2 * v169) + v155;
    if (v168)
    {
      v171 = v160 - v165;
    }

    else
    {
      v171 = (HIWORD(v160) * v155) & 0xFFFF0000;
    }

    *(a2 + 2732) = v171;
    if (v168)
    {
      v172 = a4[3];
      v173 = *(v172 + 2 * v151);
      if (v170 >= 0x40000001)
      {
        v176 = v160 - v165;
      }

      else
      {
        v174 = *(a2 + 2744);
        do
        {
          v167 *= 2;
          *(a2 + 2744) = --v174;
          if (!v174)
          {
            v177 = *(a2 + 2720);
            *(a2 + 2720) = v177 + 1;
            v178 = *(a2 + 2704);
            if (v177 + 1 >= v178)
            {
              v179 = 65280;
            }

            else
            {
              v179 = *(*(a2 + 2712) + v177 + 1) << 8;
            }

            v180 = v177 + 2;
            *(a2 + 2720) = v180;
            if (v180 < v178)
            {
              v175 = *(*(a2 + 2712) + v180);
            }

            else
            {
              v175 = 255;
            }

            v167 |= v179 | v175;
            v174 = 16;
            *(a2 + 2744) = 16;
          }

          v176 = 2 * v170;
          v31 = v170 >= 0x20000001;
          v170 *= 2;
        }

        while (!v31);
      }

      v181 = (HIWORD(v176) * v173) & 0xFFFF0000;
      v182 = (v173 >> 7) & 0x1FE;
      if (v167 >= v181)
      {
        ++v182;
      }

      *(v172 + 2 * v151) = *(v152 + 2 * v182) + v173;
      if (v167 < v181)
      {
        v183 = (HIWORD(v176) * v173) & 0xFFFF0000;
      }

      else
      {
        v183 = v176 - v181;
      }

      if (v167 < v181)
      {
        v184 = 0;
      }

      else
      {
        v184 = v181;
      }

      v185 = v167 - v184;
      *(a2 + 2732) = v183;
      *(a2 + 2736) = v167 - v184;
      v186 = (a4[6] + (v151 << 7));
      v187 = *v186;
      if (v183 >= 0x40000001)
      {
        v190 = v183;
      }

      else
      {
        v188 = *(a2 + 2744);
        do
        {
          v185 *= 2;
          *(a2 + 2744) = --v188;
          if (!v188)
          {
            v191 = *(a2 + 2720);
            *(a2 + 2720) = v191 + 1;
            v192 = *(a2 + 2704);
            if (v191 + 1 >= v192)
            {
              v193 = 65280;
            }

            else
            {
              v193 = *(*(a2 + 2712) + v191 + 1) << 8;
            }

            v194 = v191 + 2;
            *(a2 + 2720) = v194;
            if (v194 < v192)
            {
              v189 = *(*(a2 + 2712) + v194);
            }

            else
            {
              v189 = 255;
            }

            v185 |= v193 | v189;
            v188 = 16;
            *(a2 + 2744) = 16;
          }

          v190 = 2 * v183;
          v31 = v183 >= 0x20000001;
          v183 *= 2;
        }

        while (!v31);
      }

      v195 = (HIWORD(v190) * v187) & 0xFFFF0000;
      v196 = (v187 >> 7) & 0x1FE;
      v197 = v190 - v195;
      v198 = v185 >= v195;
      if (v185 >= v195)
      {
        ++v196;
      }

      v199 = *(v152 + 2 * v196);
      v200 = v185 >= v195;
      *v186 = v199 + v187;
      if (v185 < v195)
      {
        v197 = v195;
        v195 = 0;
      }

      if (v198)
      {
        v201 = 2;
      }

      else
      {
        v201 = 1;
      }

      v202 = v185 - v195;
      *(a2 + 2732) = v197;
      *(a2 + 2736) = v202;
      v203 = v186[v201];
      if (v197 >= 0x40000001)
      {
        v206 = v197;
      }

      else
      {
        v204 = *(a2 + 2744);
        do
        {
          v202 *= 2;
          *(a2 + 2744) = --v204;
          if (!v204)
          {
            v207 = *(a2 + 2720);
            *(a2 + 2720) = v207 + 1;
            v208 = *(a2 + 2704);
            if (v207 + 1 >= v208)
            {
              v209 = 65280;
            }

            else
            {
              result = *(a2 + 2712);
              v209 = *(result + v207 + 1) << 8;
            }

            v210 = v207 + 2;
            *(a2 + 2720) = v210;
            if (v210 < v208)
            {
              v205 = *(*(a2 + 2712) + v210);
            }

            else
            {
              v205 = 255;
            }

            v202 |= v209 | v205;
            v204 = 16;
            *(a2 + 2744) = 16;
          }

          v206 = 2 * v197;
          v31 = v197 >= 0x20000001;
          v197 *= 2;
        }

        while (!v31);
      }

      v211 = (HIWORD(v206) * v203) & 0xFFFF0000;
      v212 = (v203 >> 7) & 0x1FE;
      v213 = v206 - v211;
      v214 = v202 >= v211;
      if (v202 >= v211)
      {
        ++v212;
      }

      v186[v201] = *(v152 + 2 * v212) + v203;
      if (v202 < v211)
      {
        v215 = v211;
      }

      else
      {
        v215 = v213;
      }

      if (v202 < v211)
      {
        v216 = 0;
      }

      else
      {
        v216 = v211;
      }

      v217 = v202 - v216;
      *(a2 + 2732) = v215;
      *(a2 + 2736) = v217;
      v218 = v200 | (2 * v214);
      v219 = &v186[v218];
      v220 = v219[3];
      if (v215 >= 0x40000001)
      {
        v223 = v215;
      }

      else
      {
        v221 = *(a2 + 2744);
        do
        {
          v217 *= 2;
          *(a2 + 2744) = --v221;
          if (!v221)
          {
            v224 = *(a2 + 2720);
            *(a2 + 2720) = v224 + 1;
            v225 = *(a2 + 2704);
            if (v224 + 1 >= v225)
            {
              v226 = 65280;
            }

            else
            {
              result = *(a2 + 2712);
              v226 = *(result + v224 + 1) << 8;
            }

            v227 = v224 + 2;
            *(a2 + 2720) = v227;
            if (v227 < v225)
            {
              v222 = *(*(a2 + 2712) + v227);
            }

            else
            {
              v222 = 255;
            }

            v217 |= v226 | v222;
            v221 = 16;
            *(a2 + 2744) = 16;
          }

          v223 = 2 * v215;
          v31 = v215 >= 0x20000001;
          v215 *= 2;
        }

        while (!v31);
      }

      v228 = (HIWORD(v223) * v220) & 0xFFFF0000;
      v229 = (v220 >> 7) & 0x1FE;
      v230 = v223 - v228;
      if (v217 >= v228)
      {
        ++v229;
      }

      v231 = v217 >= v228;
      v219[3] = *(v152 + 2 * v229) + v220;
      if (v217 < v228)
      {
        v232 = v228;
      }

      else
      {
        v232 = v230;
      }

      if (v217 < v228)
      {
        v233 = 0;
      }

      else
      {
        v233 = v228;
      }

      v234 = v217 - v233;
      *(a2 + 2732) = v232;
      *(a2 + 2736) = v234;
      v235 = v218 | (4 * v231);
      v236 = &v186[v235];
      v237 = v236[7];
      if (v232 >= 0x40000001)
      {
        v240 = v232;
      }

      else
      {
        v238 = *(a2 + 2744);
        do
        {
          v234 *= 2;
          *(a2 + 2744) = --v238;
          if (!v238)
          {
            v241 = *(a2 + 2720);
            *(a2 + 2720) = v241 + 1;
            v242 = *(a2 + 2704);
            if (v241 + 1 >= v242)
            {
              v243 = 65280;
            }

            else
            {
              result = *(a2 + 2712);
              v243 = *(result + v241 + 1) << 8;
            }

            v244 = v241 + 2;
            *(a2 + 2720) = v244;
            if (v244 < v242)
            {
              v239 = *(*(a2 + 2712) + v244);
            }

            else
            {
              v239 = 255;
            }

            v234 |= v243 | v239;
            v238 = 16;
            *(a2 + 2744) = 16;
          }

          v240 = 2 * v232;
          v31 = v232 >= 0x20000001;
          v232 *= 2;
        }

        while (!v31);
      }

      v245 = (HIWORD(v240) * v237) & 0xFFFF0000;
      v246 = (v237 >> 7) & 0x1FE;
      v247 = v240 - v245;
      if (v234 >= v245)
      {
        ++v246;
      }

      v248 = v234 >= v245;
      v236[7] = *(v152 + 2 * v246) + v237;
      if (v234 < v245)
      {
        v249 = v245;
      }

      else
      {
        v249 = v247;
      }

      if (v234 < v245)
      {
        v250 = 0;
      }

      else
      {
        v250 = v245;
      }

      v251 = v234 - v250;
      *(a2 + 2732) = v249;
      *(a2 + 2736) = v251;
      v252 = v235 | (8 * v248);
      v253 = &v186[v252];
      v254 = v253[15];
      if (v249 >= 0x40000001)
      {
        v257 = v249;
      }

      else
      {
        v255 = *(a2 + 2744);
        do
        {
          v251 *= 2;
          *(a2 + 2744) = --v255;
          if (!v255)
          {
            v258 = *(a2 + 2720);
            *(a2 + 2720) = v258 + 1;
            v259 = *(a2 + 2704);
            if (v258 + 1 >= v259)
            {
              v260 = 65280;
            }

            else
            {
              result = *(a2 + 2712);
              v260 = *(result + v258 + 1) << 8;
            }

            v261 = v258 + 2;
            *(a2 + 2720) = v261;
            if (v261 < v259)
            {
              v256 = *(*(a2 + 2712) + v261);
            }

            else
            {
              v256 = 255;
            }

            v251 |= v260 | v256;
            v255 = 16;
            *(a2 + 2744) = 16;
          }

          v257 = 2 * v249;
          v31 = v249 >= 0x20000001;
          v249 *= 2;
        }

        while (!v31);
      }

      v262 = (HIWORD(v257) * v254) & 0xFFFF0000;
      v263 = (v254 >> 7) & 0x1FE;
      v264 = v257 - v262;
      if (v251 >= v262)
      {
        ++v263;
      }

      v265 = v251 >= v262;
      v253[15] = *(v152 + 2 * v263) + v254;
      if (v251 < v262)
      {
        v266 = v262;
      }

      else
      {
        v266 = v264;
      }

      if (v251 < v262)
      {
        v267 = 0;
      }

      else
      {
        v267 = v262;
      }

      v268 = v251 - v267;
      *(a2 + 2732) = v266;
      *(a2 + 2736) = v268;
      v269 = v252 | (16 * v265);
      v270 = &v186[v269];
      v271 = v270[31];
      if (v266 >= 0x40000001)
      {
        v274 = v266;
      }

      else
      {
        v272 = *(a2 + 2744);
        do
        {
          v268 *= 2;
          *(a2 + 2744) = --v272;
          if (!v272)
          {
            v275 = *(a2 + 2720);
            *(a2 + 2720) = v275 + 1;
            v276 = *(a2 + 2704);
            if (v275 + 1 >= v276)
            {
              v277 = 65280;
            }

            else
            {
              v277 = *(*(a2 + 2712) + v275 + 1) << 8;
            }

            v278 = v275 + 2;
            *(a2 + 2720) = v278;
            if (v278 < v276)
            {
              v273 = *(*(a2 + 2712) + v278);
            }

            else
            {
              v273 = 255;
            }

            v268 |= v277 | v273;
            v272 = 16;
            *(a2 + 2744) = 16;
          }

          v274 = 2 * v266;
          v31 = v266 >= 0x20000001;
          v266 *= 2;
        }

        while (!v31);
      }

      v279 = (HIWORD(v274) * v271) & 0xFFFF0000;
      v280 = (v271 >> 7) & 0x1FE;
      v281 = v274 - v279;
      if (v268 >= v279)
      {
        ++v280;
      }

      v270[31] = *(v152 + 2 * v280) + v271;
      if (v268 < v279)
      {
        v282 = v279;
      }

      else
      {
        v282 = v281;
      }

      if (v268 < v279)
      {
        v283 = 0;
      }

      else
      {
        v283 = v279;
      }

      *(a2 + 2732) = v282;
      *(a2 + 2736) = v268 - v283;
      v284 = v269 | (32 * (v268 >= v279));
      if (v284 == 63)
      {
        result = gcl::ArithmeticDecoder::decodeExpGolomb((a2 + 2704), *(a4[12] + 4 * v151), (a4[9] + 2 * v151));
        v284 = result + 63;
        v153 = *a4;
      }

      if (v167 >= v181)
      {
        v154 = v284 + 1;
      }

      else
      {
        v154 = ~v284;
      }
    }

    else
    {
      v154 = 0;
    }

    v6[v151++] = v154;
  }

  while (v151 != 3);
  return result;
}

void std::vector<gcl::Vector3<int>>::__append(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 2) < a2)
  {
    v5 = *a1;
    v6 = &v4[-*a1];
    v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 2) + a2;
    if (v7 > 0x1555555555555555)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v8 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v5) >> 2);
    if (2 * v8 > v7)
    {
      v7 = 2 * v8;
    }

    if (v8 >= 0xAAAAAAAAAAAAAAALL)
    {
      v9 = 0x1555555555555555;
    }

    else
    {
      v9 = v7;
    }

    if (v9)
    {
      if (v9 <= 0x1555555555555555)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v11 = (4 * (v6 >> 2));
    v12 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v11, v12);
    v13 = &v11[v12];
    v14 = &v11[-(v4 - v5)];
    if (v5 != v4)
    {
      v15 = v4 - v5 - 12;
      v16 = v5;
      v17 = &v11[-(v4 - v5)];
      if (v15 > 0xB3)
      {
        v18 = v15 / 0xC;
        v19 = 12 * (v15 / 0xC);
        v20 = v14 >= &v5[v19 + 12] || v5 >= v6 - 4 * ((v4 - v5) >> 2) + v19 + 12;
        v16 = v5;
        v17 = &v11[-(v4 - v5)];
        if (v20)
        {
          v21 = v18 + 1;
          v22 = (v18 + 1) & 0x3FFFFFFFFFFFFFF8;
          v16 = &v5[12 * v22];
          v23 = v5;
          v24 = &v11[-(v4 - v5)];
          v25 = v22;
          do
          {
            v26 = *(v23 + 1);
            v28 = *(v23 + 4);
            v27 = *(v23 + 5);
            v29 = *(v23 + 2);
            v30 = *(v23 + 3);
            *v24 = *v23;
            *(v24 + 1) = v26;
            *(v24 + 2) = v29;
            *(v24 + 3) = v30;
            *(v24 + 4) = v28;
            *(v24 + 5) = v27;
            v24 += 96;
            v23 += 96;
            v25 -= 8;
          }

          while (v25);
          if (v21 == v22)
          {
            *a1 = v14;
            *(a1 + 8) = v13;
            *(a1 + 16) = 0;
LABEL_28:

            operator delete(v5);
            return;
          }

          v17 = (v14 + 12 * v22);
        }
      }

      do
      {
        *v17 = *v16;
        *(v17 + 1) = *(v16 + 1);
        *(v17 + 2) = *(v16 + 2);
        v16 += 12;
        v17 += 12;
      }

      while (v16 != v4);
    }

    *a1 = v14;
    *(a1 + 8) = v13;
    *(a1 + 16) = 0;
    if (!v5)
    {
      return;
    }

    goto LABEL_28;
  }

  if (a2)
  {
    v10 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(*(a1 + 8), v10);
    v4 += v10;
  }

  *(a1 + 8) = v4;
}

void gcl::tmesh::ACContext::init(std::vector<int> *this, int a2)
{
  v3 = a2;
  v4 = (this->__end_ - this->__begin_) >> 1;
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<gcl::ArithmeticContext>::__append(this, v6);
  }

  else if (!v5)
  {
    this->__end_ = (this->__begin_ + 2 * v3);
  }

  begin = this[1].__begin_;
  v8 = (this[1].__end_ - begin) >> 1;
  if (v3 <= v8)
  {
    if (v3 < v8)
    {
      this[1].__end_ = (begin + 2 * v3);
    }
  }

  else
  {
    std::vector<gcl::ArithmeticContext>::__append(&this[1], v3 - v8);
  }

  v9 = this[2].__begin_;
  v10 = (this[2].__end_ - v9) >> 1;
  if (v3 << 6 <= v10)
  {
    if (v3 << 6 < v10)
    {
      this[2].__end_ = &v9[32 * v3];
    }
  }

  else
  {
    std::vector<gcl::ArithmeticContext>::__append(&this[2], (v3 << 6) - v10);
  }

  v11 = this[3].__begin_;
  v12 = (this[3].__end_ - v11) >> 1;
  if (v3 <= v12)
  {
    if (v3 < v12)
    {
      this[3].__end_ = (v11 + 2 * v3);
    }
  }

  else
  {
    std::vector<gcl::ArithmeticContext>::__append(&this[3], v3 - v12);
  }

  v13 = this[4].__begin_;
  end = this[4].__end_;
  v15 = end - v13;
  if (v3 <= v15)
  {
    if (v3 < v15)
    {
      end = &v13[v3];
      this[4].__end_ = end;
    }
  }

  else
  {
    std::vector<int>::__append(this + 4, v3 - v15);
    v13 = this[4].__begin_;
    end = this[4].__end_;
  }

  if (end - v13 >= 1)
  {
    memset_pattern16(v13, &unk_1B33B25B0, end - v13);
  }

  v16 = this->__end_;
  if (this->__begin_ != v16)
  {
    memset_pattern16(this->__begin_, &unk_1B33B25C0, v16 - this->__begin_);
  }

  v17 = this[1].__begin_;
  v18 = this[1].__end_;
  if (v17 != v18)
  {
    memset_pattern16(v17, &unk_1B33B25C0, v18 - v17);
  }

  v19 = this[2].__begin_;
  v20 = this[2].__end_;
  if (v19 != v20)
  {
    memset_pattern16(v19, &unk_1B33B25C0, v20 - v19);
  }

  v21 = this[3].__begin_;
  v22 = this[3].__end_;
  if (v21 != v22)
  {

    memset_pattern16(v21, &unk_1B33B25C0, v22 - v21);
  }
}

void std::vector<gcl::ArithmeticContext>::__append(uint64_t a1, unint64_t a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (a2 <= (v3 - v4) >> 1)
  {
    if (a2)
    {
      v10 = 2 * a2;
      memset_pattern16(*(a1 + 8), &unk_1B33B25C0, 2 * a2);
      v4 += v10;
    }

    *(a1 + 8) = v4;
  }

  else
  {
    v5 = *a1;
    v6 = v4 - *a1;
    v7 = (v6 >> 1) + a2;
    if (v7 < 0)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v8 = v3 - v5;
    if (v8 > v7)
    {
      v7 = v8;
    }

    if (v8 >= 0x7FFFFFFFFFFFFFFELL)
    {
      v9 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v9 = v7;
    }

    if (v9)
    {
      if ((v9 & 0x8000000000000000) == 0)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v11 = (2 * (v6 >> 1));
    v12 = 2 * a2;
    memset_pattern16(v11, &unk_1B33B25C0, 2 * a2);
    memcpy(0, v5, v6);
    *a1 = 0;
    *(a1 + 8) = &v11[v12];
    *(a1 + 16) = 0;
    if (v5)
    {

      operator delete(v5);
    }
  }
}

uint64_t gcl::tmesh::DecoderImpl::decompressVertexAttributes(uint64_t a1, unint64_t a2, uint64_t a3, void *a4, int *a5, BOOL *a6)
{
  if (*(a1 + 3872))
  {
    return 6;
  }

  if (!a2)
  {
    return 5;
  }

  result = 5;
  if (a3 < 0 || !a5)
  {
    return result;
  }

  if (a3 < 4)
  {
    return 3;
  }

  v8 = a3 & 0x7FFFFFFFFFFFFFFCLL;
  if ((a3 & 0x7FFFFFFFFFFFFFFCLL) == 4 || a3 == 8 || a3 == 9 || (a3 & 0x7FFFFFFFFFFFFFFELL) == 0xA || v8 == 12 || v8 == 16 || a3 == 20 || a3 == 21 || a3 == 22 || a3 < 32)
  {
    return 3;
  }

  result = 3;
  if (*a2 != -290009985)
  {
    return result;
  }

  v10 = *(a2 + 4);
  v11 = *(a2 + 8);
  v12 = *(a2 + 9);
  v13 = *(a2 + 10);
  v14 = *(a2 + 12);
  v15 = *(a2 + 16) & 0x7FFFFFFF;
  v16 = *(a2 + 20);
  v17 = *(a2 + 21);
  v18 = *(a2 + 22);
  v19 = *(a2 + 23);
  v20 = *(a2 + 24);
  v21 = *(a2 + 26);
  v22 = *(a2 + 27);
  *(a1 + 3824) = 0;
  *(a1 + 3828) = v11;
  *(a1 + 3829) = v12;
  *(a1 + 3830) = v13;
  *(a1 + 3832) = v14;
  *(a1 + 3836) = v15;
  *(a1 + 3840) = v18;
  *(a1 + 3844) = v17;
  *(a1 + 3848) = v22;
  *(a1 + 3852) = v16;
  *(a1 + 3856) = v21;
  *(a1 + 3860) = v10;
  *(a1 + 3864) = v19;
  *(a1 + 3868) = v20;
  v23 = (a2 + 32);
  if (a2 == -32 || a3 < v14 || a2 + a3 < a2)
  {
    return 3;
  }

  result = 3;
  if (a2 + v14 < v23 || v14 < 0x20)
  {
    return result;
  }

  if (v11)
  {
    return 4;
  }

  result = 4;
  if ((v12 - 5) > 2)
  {
    return result;
  }

  if (v15 != *(a1 + 3788) || !a6 && v21)
  {
    return 3;
  }

  v25 = v14 - 32;
  if ((v20 - 5) <= 1)
  {
    if (v18 == 2)
    {
      result = 3;
      if (v22 - 28 >= 0xFFFFFFE5)
      {
        operator new();
      }

      return result;
    }

    return 3;
  }

  if (v22 > 0x1B)
  {
    return 3;
  }

  if (v18)
  {
    operator new();
  }

  v26 = *(a1 + 2664);
  v27 = (*(a1 + 2672) - v26) >> 2;
  if (v18 <= v27)
  {
    if (v18 < v27)
    {
      *(a1 + 2672) = v26 + 4 * v18;
    }
  }

  else
  {
    std::vector<int>::__append((a1 + 2664), v18 - v27);
  }

  if (!v23 || *(a1 + 3864) == 255)
  {
    return 3;
  }

  v28 = v25 - 4;
  if (v25 < 4)
  {
    v29 = 0;
    v28 = 0;
    v30 = 0;
LABEL_54:
    v31 = 0;
    goto LABEL_55;
  }

  v32 = *v23;
  v31 = (v23 + 1);
  v30 = v32;
  if (!v31)
  {
    v29 = v30;
    goto LABEL_54;
  }

  v29 = &v31[v30];
LABEL_55:
  result = 3;
  if (v29 && v28 >= v30)
  {
    *(a1 + 2704) = v30;
    *(a1 + 2712) = v31;
    *&v33 = 0xFFFF000000000000;
    *(&v33 + 1) = 0xFFFF000000000000;
    *(a1 + 2728) = v33;
    *(a1 + 2744) = 16;
    if (v30)
    {
      v34 = *v31 << 24;
      *(a1 + 2736) = v34;
      if (v30 != 1)
      {
        v35 = v34 | (v31[1] << 16);
        *(a1 + 2736) = v35;
        if (v30 > 2)
        {
          v36 = v35 | (v31[2] << 8);
          *(a1 + 2736) = v36;
          if (v30 != 3)
          {
            v37 = v31[3];
LABEL_66:
            *(a1 + 2736) = v37 | v36;
            *(a1 + 2720) = 3;
            memcpy((a1 + 2752), &gcl::ArithmeticDecoder::probUpdateLutInterleaved, 0x400uLL);
            gcl::tmesh::DecoderImpl::decodeVertexAttributesAC(a1, a5, a6);
            result = 0;
            *a4 = *(a1 + 3832);
            return result;
          }

LABEL_65:
          v37 = 255;
          goto LABEL_66;
        }

LABEL_64:
        v36 = v35 | 0xFF00;
        goto LABEL_65;
      }
    }

    else
    {
      v34 = -16777216;
    }

    v35 = v34 | 0xFF0000;
    goto LABEL_64;
  }

  return result;
}

void sub_1B3367BA8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    operator delete(v1);
  }

  _Unwind_Resume(exception_object);
}

void gcl::tmesh::DecoderImpl::decodeVertexAttributesAC(gcl::tmesh::DecoderImpl *this, int *a2, BOOL *a3)
{
  v559 = *MEMORY[0x1E69E9840];
  v523 = *(this + 960);
  v6 = v523;
  *v525 = v523;
  if (*(this + 964) == 1)
  {
    memset_pattern16(&__b, &unk_1B33B25C0, 4uLL);
    v7 = *(this + 959);
    if (v7 >= 1)
    {
      v8 = 0;
      v9 = *(this + 22);
      v10 = *(this + 25);
      v11 = *(this + 683);
      v12 = *(this + 684);
      do
      {
        v20 = (v9 + 12 * v8);
        v21 = *v20;
        v22 = v20[1];
        v23 = v20[2];
        v24 = (v10 + 12 * v8);
        v25 = v24[2];
        if (v25 != -1)
        {
          v26 = a3[v22] + a3[v21] + a3[v23] + a3[*v24] + a3[v24[1]] + a3[v25] > 2;
          goto LABEL_18;
        }

        if (v23 != -1)
        {
          v26 = a3[v22] + a3[v21] + a3[v23] > 1;
LABEL_18:
          v27 = v26;
          goto LABEL_21;
        }

        if (v22 == -1)
        {
          if (v21 == -1)
          {
LABEL_37:
            v27 = 0;
            goto LABEL_21;
          }

          v27 = a3[v21];
        }

        else
        {
          if (!a3[v21])
          {
            goto LABEL_37;
          }

          v27 = a3[v22];
        }

LABEL_21:
        if (v11 >= 0x40000001)
        {
          v13 = v11;
        }

        else
        {
          v28 = *(this + 686);
          do
          {
            v12 *= 2;
            *(this + 686) = --v28;
            if (!v28)
            {
              v30 = *(this + 340);
              *(this + 340) = v30 + 1;
              v31 = *(this + 676);
              if (v30 + 1 >= v31)
              {
                v32 = 65280;
              }

              else
              {
                v32 = *(*(this + 339) + v30 + 1) << 8;
              }

              v33 = v30 + 2;
              *(this + 340) = v33;
              if (v33 < v31)
              {
                v29 = *(*(this + 339) + v33);
              }

              else
              {
                v29 = 255;
              }

              v12 |= v32 | v29;
              v28 = 16;
              *(this + 686) = 16;
            }

            v13 = 2 * v11;
            v139 = v11 >= 0x20000001;
            v11 *= 2;
          }

          while (!v139);
        }

        v14 = *(&v537[-2] + v27);
        v15 = (HIWORD(v13) * v14) & 0xFFFF0000;
        v16 = (v14 >> 7) & 0x1FE;
        v17 = v13 - v15;
        v18 = v12 >= v15;
        if (v12 >= v15)
        {
          ++v16;
        }

        *(&v537[-2] + v27) = *(this + v16 + 1376) + v14;
        if (v12 < v15)
        {
          v11 = v15;
        }

        else
        {
          v11 = v17;
        }

        if (v12 < v15)
        {
          v19 = 0;
        }

        else
        {
          v19 = v15;
        }

        v12 -= v19;
        *(this + 683) = v11;
        *(this + 684) = v12;
        a3[v8++] = v18;
      }

      while (v8 != v7);
    }

    v6 = v523;
  }

  v34 = *(this + 967);
  v522 = a2;
  if (v34 > 2)
  {
    if (v34 <= 4)
    {
      if (v34 != 3)
      {
        v558 = 0;
        v556 = 0u;
        v557 = 0u;
        v554 = 0u;
        v555 = 0u;
        v552 = 0u;
        v553 = 0u;
        v550 = 0u;
        v551 = 0u;
        v548 = 0u;
        v549 = 0u;
        v546 = 0u;
        v547 = 0u;
        v544 = 0u;
        v545 = 0u;
        __p = 0u;
        v543 = 0u;
        v540 = 0u;
        v541 = 0u;
        v538 = 0u;
        *v539 = 0u;
        __b = 0u;
        *v537 = 0u;
        gcl::tmesh::ACContext::init(&__b, v523);
        gcl::tmesh::ACContext::init((&v543 + 8), v523);
        gcl::tmesh::ACContext::init(&v551, v523);
        memset_pattern16(&v533, &unk_1B33B25C0, 6uLL);
        memset_pattern16(&v528, &unk_1B33B25C0, 6uLL);
        v35 = v523;
        if (v523)
        {
          if ((v523 & 0x80000000) == 0)
          {
            operator new();
          }

          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        if (*(this + 959) >= 1)
        {
          v362 = 0;
          v363 = *(this + 964);
          v514 = v533;
          v364 = v528;
          v520 = this + 2752;
          __na = v363;
          while (1)
          {
            if (v363 && !a3[v362])
            {
              goto LABEL_519;
            }

            v365 = (*(this + 22) + 12 * v362);
            v366 = *v365;
            v367 = v365[1];
            v368 = v365[2];
            v369 = (*(this + 25) + 12 * v362);
            v370 = v369[2];
            if (v370 != -1)
            {
              v372 = *v369;
              v371 = v369[1];
              if (!v363 || a3[v366] && a3[v367] && a3[v368] && a3[v372] && a3[v371] && a3[v370])
              {
                v373 = *(this + 683);
                v374 = *(this + 684);
                if (v373 >= 0x40000001)
                {
                  v380 = *(this + 683);
                }

                else
                {
                  v375 = *(this + 686);
                  do
                  {
                    v374 *= 2;
                    *(this + 686) = --v375;
                    if (!v375)
                    {
                      v381 = *(this + 340);
                      *(this + 340) = v381 + 1;
                      v382 = *(this + 676);
                      if (v381 + 1 >= v382)
                      {
                        v383 = 65280;
                      }

                      else
                      {
                        v383 = *(*(this + 339) + v381 + 1) << 8;
                      }

                      v384 = v381 + 2;
                      *(this + 340) = v384;
                      if (v384 < v382)
                      {
                        v379 = *(*(this + 339) + v384);
                      }

                      else
                      {
                        v379 = 255;
                      }

                      v374 |= v383 | v379;
                      v375 = 16;
                      *(this + 686) = 16;
                    }

                    v380 = 2 * v373;
                    v139 = v373 >= 0x20000001;
                    v373 *= 2;
                  }

                  while (!v139);
                }

                v391 = (HIWORD(v380) * v364) & 0xFFFF0000;
                v392 = v380 - v391;
                v393 = v374 >= v391;
                v394 = v374 >= v391;
                if (v374 < v391)
                {
                  v395 = (v364 >> 7) & 0x1FE;
                }

                else
                {
                  v395 = ((v364 >> 7) & 0x1FE) + 1;
                }

                v396 = *&v520[2 * v395];
                if (v374 < v391)
                {
                  v397 = v391;
                }

                else
                {
                  v397 = v392;
                }

                if (v374 < v391)
                {
                  v398 = 0;
                }

                else
                {
                  v398 = v391;
                }

                v399 = 2;
                if (v393)
                {
                  v399 = 4;
                }

                v400 = v374 - v398;
                *(this + 683) = v397;
                *(this + 684) = v400;
                if (v397 >= 0x40000001)
                {
                  v403 = v397;
                }

                else
                {
                  v401 = *(this + 686);
                  do
                  {
                    v400 *= 2;
                    *(this + 686) = --v401;
                    if (!v401)
                    {
                      v404 = *(this + 340);
                      *(this + 340) = v404 + 1;
                      v405 = *(this + 676);
                      if (v404 + 1 >= v405)
                      {
                        v406 = 65280;
                      }

                      else
                      {
                        v406 = *(*(this + 339) + v404 + 1) << 8;
                      }

                      v407 = v404 + 2;
                      *(this + 340) = v407;
                      if (v407 < v405)
                      {
                        v402 = *(*(this + 339) + v407);
                      }

                      else
                      {
                        v402 = 255;
                      }

                      v400 |= v406 | v402;
                      v401 = 16;
                      *(this + 686) = 16;
                    }

                    v403 = 2 * v397;
                    v139 = v397 >= 0x20000001;
                    v397 *= 2;
                  }

                  while (!v139);
                }

                v503 = v372;
                v505 = v371;
                v408 = v372 * v35;
                v409 = v371 * v523;
                v364 += v396;
                v410 = *(&v528 + v399);
                v411 = (HIWORD(v403) * v410) & 0xFFFF0000;
                v412 = (v410 >> 7) & 0x1FE;
                v413 = v403 - v411;
                if (v400 >= v411)
                {
                  ++v412;
                }

                *(&v528 + v399) = *&v520[2 * v412] + v410;
                if (v400 < v411)
                {
                  v414 = v411;
                }

                else
                {
                  v414 = v413;
                }

                if (v400 < v411)
                {
                  v415 = 0;
                }

                else
                {
                  v415 = v411;
                }

                *(this + 683) = v414;
                *(this + 684) = v400 - v415;
                v416 = v394 | (2 * (v400 >= v411));
                if (v416 <= 1)
                {
                  goto LABEL_518;
                }

                v511 = v364;
                v417 = &a2[v366 * v523];
                v418 = &a2[v367 * v35];
                v419 = &a2[v368 * v523];
                v420 = &a2[v408];
                v421 = &a2[v409];
                v422 = &a2[v370 * v35];
                if (v416 == 2)
                {
                  v423 = *(this + 13);
                  v501 = v422;
                  gcl::tmesh::ComputeGeneralizedParallelogramPrediction(v417, v418, v419, v35, (v423 + 12 * v366), (v423 + 12 * v367), (v423 + 12 * v368), (v423 + 12 * v362), 0);
                  gcl::tmesh::ComputeGeneralizedParallelogramPrediction(v420, v421, v501, 0, (v423 + 12 * v503), (v423 + 12 * v505), (v423 + 12 * v370), (v423 + 12 * v362), 0);
                  a2 = v522;
                }

                goto LABEL_642;
              }
            }

            if (v368 != -1 && (!v363 || a3[v366] && a3[v367] && a3[v368]))
            {
              v376 = *(this + 683);
              v377 = *(this + 684);
              if (v376 >= 0x40000001)
              {
                v386 = *(this + 683);
              }

              else
              {
                v378 = *(this + 686);
                do
                {
                  v377 *= 2;
                  *(this + 686) = --v378;
                  if (!v378)
                  {
                    v387 = *(this + 340);
                    *(this + 340) = v387 + 1;
                    v388 = *(this + 676);
                    if (v387 + 1 >= v388)
                    {
                      v389 = 65280;
                    }

                    else
                    {
                      v389 = *(*(this + 339) + v387 + 1) << 8;
                    }

                    v390 = v387 + 2;
                    *(this + 340) = v390;
                    if (v390 < v388)
                    {
                      v385 = *(*(this + 339) + v390);
                    }

                    else
                    {
                      v385 = 255;
                    }

                    v377 |= v389 | v385;
                    v378 = 16;
                    *(this + 686) = 16;
                  }

                  v386 = 2 * v376;
                  v139 = v376 >= 0x20000001;
                  v376 *= 2;
                }

                while (!v139);
              }

              v424 = (HIWORD(v386) * v514) & 0xFFFF0000;
              v425 = v386 - v424;
              v426 = v377 >= v424;
              v427 = v377 >= v424;
              if (v377 < v424)
              {
                v428 = (v514 >> 7) & 0x1FE;
              }

              else
              {
                v428 = ((v514 >> 7) & 0x1FE) + 1;
              }

              v429 = *&v520[2 * v428];
              if (v377 < v424)
              {
                v430 = v424;
              }

              else
              {
                v430 = v425;
              }

              if (v377 < v424)
              {
                v431 = 0;
              }

              else
              {
                v431 = v424;
              }

              v432 = 2;
              if (v426)
              {
                v432 = 4;
              }

              v433 = v377 - v431;
              *(this + 683) = v430;
              *(this + 684) = v433;
              if (v430 >= 0x40000001)
              {
                v436 = v430;
              }

              else
              {
                v434 = *(this + 686);
                do
                {
                  v433 *= 2;
                  *(this + 686) = --v434;
                  if (!v434)
                  {
                    v437 = *(this + 340);
                    *(this + 340) = v437 + 1;
                    v438 = *(this + 676);
                    if (v437 + 1 >= v438)
                    {
                      v439 = 65280;
                    }

                    else
                    {
                      v439 = *(*(this + 339) + v437 + 1) << 8;
                    }

                    v440 = v437 + 2;
                    *(this + 340) = v440;
                    if (v440 < v438)
                    {
                      v435 = *(*(this + 339) + v440);
                    }

                    else
                    {
                      v435 = 255;
                    }

                    v433 |= v439 | v435;
                    v434 = 16;
                    *(this + 686) = 16;
                  }

                  v436 = 2 * v430;
                  v139 = v430 >= 0x20000001;
                  v430 *= 2;
                }

                while (!v139);
              }

              v511 = v364;
              v441 = v366 * v35;
              v442 = v367 * v523;
              v443 = &a2[v442];
              v444 = v368 * v35;
              v445 = &a2[v444];
              v514 += v429;
              v446 = *(&v533 + v432);
              v447 = (HIWORD(v436) * v446) & 0xFFFF0000;
              v448 = (v446 >> 7) & 0x1FE;
              v449 = v436 - v447;
              if (v433 >= v447)
              {
                ++v448;
              }

              *(&v533 + v432) = *&v520[2 * v448] + v446;
              if (v433 < v447)
              {
                v450 = v447;
              }

              else
              {
                v450 = v449;
              }

              if (v433 < v447)
              {
                v451 = 0;
              }

              else
              {
                v451 = v447;
              }

              *(this + 683) = v450;
              *(this + 684) = v433 - v451;
              v452 = v427 | (2 * (v433 >= v447));
              if (v452 <= 1)
              {
                if (v452)
                {
                  gcl::tmesh::ComputeGeneralizedParallelogramPrediction(&a2[v441], v443, v445, v35, (*(this + 13) + 12 * v366), (*(this + 13) + 12 * v367), (*(this + 13) + 12 * v368), (*(this + 13) + 12 * v362), 0);
                }

                goto LABEL_642;
              }

              if (v452 == 2)
              {
                gcl::tmesh::ComputeGeneralizedParallelogramPrediction(&a2[v441], v443, v445, v523, (*(this + 13) + 12 * v366), (*(this + 13) + 12 * v367), (*(this + 13) + 12 * v368), (*(this + 13) + 12 * v362), 0);
LABEL_642:
                v363 = __na;
                v364 = v511;
                goto LABEL_518;
              }

              v363 = __na;
              v364 = v511;
            }

            else if ((v367 == -1 || v363 && (!a3[v366] || !a3[v367])) && (v366 == -1 || v363 && !a3[v366]))
            {
              v526[0].i8[0] = 3;
              gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v35);
              v35 = v523;
              goto LABEL_519;
            }

LABEL_518:
            gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v523);
            v35 = v523;
LABEL_519:
            if (++v362 >= *(this + 959))
            {
              goto LABEL_740;
            }
          }
        }

        goto LABEL_740;
      }

      v558 = 0;
      v556 = 0u;
      v557 = 0u;
      v554 = 0u;
      v555 = 0u;
      v552 = 0u;
      v553 = 0u;
      v550 = 0u;
      v551 = 0u;
      v548 = 0u;
      v549 = 0u;
      v546 = 0u;
      v547 = 0u;
      v544 = 0u;
      v545 = 0u;
      __p = 0u;
      v543 = 0u;
      v540 = 0u;
      v541 = 0u;
      v538 = 0u;
      *v539 = 0u;
      __b = 0u;
      *v537 = 0u;
      gcl::tmesh::ACContext::init(&__b, v523);
      gcl::tmesh::ACContext::init((&v543 + 8), v523);
      gcl::tmesh::ACContext::init(&v551, v523);
      v258 = v523;
      if (v523)
      {
        if ((v523 & 0x80000000) == 0)
        {
          operator new();
        }

        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      if (*(this + 959) >= 1)
      {
        v347 = 0;
        v348 = *(this + 964);
        v509 = v348;
        v517 = a3;
        do
        {
          if (v348 && !a3[v347])
          {
            goto LABEL_488;
          }

          v349 = (*(this + 22) + 12 * v347);
          v350 = *v349;
          v351 = v349[1];
          v352 = v349[2];
          v353 = (*(this + 25) + 12 * v347);
          v354 = v353[2];
          if (v354 != -1 && ((v355 = *v353, !v348) || v517[v350] && v517[v351] && v517[v352] && v517[v355] && v517[v353[1]] && v517[v354]))
          {
            v356 = *(this + 13);
            v357 = v258;
            v358 = v353[1];
            gcl::tmesh::ComputeGeneralizedParallelogramPrediction(&v522[v350 * v258], &v522[v351 * v258], &v522[v352 * v523], v258, (v356 + 12 * v350), (v356 + 12 * v351), (v356 + 12 * v352), (v356 + 12 * v347), 0);
            v359 = &v522[v355 * v357];
            v360 = (v356 + 12 * v355);
            v361 = v523;
            gcl::tmesh::ComputeGeneralizedParallelogramPrediction(v359, &v522[v358 * v523], &v522[v354 * v357], v357, v360, (v356 + 12 * v358), (v356 + 12 * v354), (v356 + 12 * v347), 0);
            a3 = v517;
            v348 = v509;
          }

          else
          {
            v361 = v523;
            a3 = v517;
            if (v352 != -1 && (!v348 || v517[v350] && v517[v351] && v517[v352]))
            {
              gcl::tmesh::ComputeGeneralizedParallelogramPrediction(&v522[v350 * v523], &v522[v351 * v258], &v522[v352 * v258], v258, (*(this + 13) + 12 * v350), (*(this + 13) + 12 * v351), (*(this + 13) + 12 * v352), (*(this + 13) + 12 * v347), 0);
            }

            else if ((v351 == -1 || v348 && (!v517[v350] || !v517[v351])) && (v350 == -1 || v348 && !v517[v350]))
            {
              LOBYTE(v533) = 3;
              gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v258);
              v258 = v523;
              goto LABEL_488;
            }
          }

          gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v361);
          v258 = v523;
LABEL_488:
          ++v347;
        }

        while (v347 < *(this + 959));
      }

LABEL_740:
      if (v557)
      {
        operator delete(v557);
      }

      if (*(&v555 + 1))
      {
        operator delete(*(&v555 + 1));
      }

      if (v554)
      {
        operator delete(v554);
      }

      if (*(&v552 + 1))
      {
        operator delete(*(&v552 + 1));
      }

      if (v551)
      {
        operator delete(v551);
      }

      goto LABEL_750;
    }

    if (v34 != 5)
    {
      if (v34 != 6)
      {
        return;
      }

      v37 = ~(-1 << (*(this + 962) - 1));
      v533 = 0;
      v534 = 0;
      v535 = 0;
      gcl::tmesh::EstimateQuantizedNormals(this + 13, this + 16, &v533, v37);
      v558 = 0;
      v556 = 0u;
      v557 = 0u;
      v554 = 0u;
      v555 = 0u;
      v552 = 0u;
      v553 = 0u;
      v550 = 0u;
      v551 = 0u;
      v548 = 0u;
      v549 = 0u;
      v546 = 0u;
      v547 = 0u;
      v544 = 0u;
      v545 = 0u;
      __p = 0u;
      v543 = 0u;
      v540 = 0u;
      v541 = 0u;
      v538 = 0u;
      *v539 = 0u;
      __b = 0u;
      *v537 = 0u;
      gcl::tmesh::ACContext::init(&__b, v523);
      gcl::tmesh::ACContext::init((&v543 + 8), v523);
      gcl::tmesh::ACContext::init(&v551, v523);
      memset_pattern16(v532, &unk_1B33B25C0, 6uLL);
      memset_pattern16(v531, &unk_1B33B25C0, 6uLL);
      v38 = *(this + 959);
      v39 = v523;
      if (v38 > 0)
      {
        v40 = 0;
        v41 = *(this + 964);
        v504 = v532[0];
        v508 = v531[0];
        v42 = vdup_n_s32(v37);
        __n = 0x8000;
        v43 = vdup_n_s32(2 * v37);
        v512 = v533;
        v515 = this + 2752;
        v502 = 0x8000;
        v510 = v41;
        while (v41 && !a3[v40])
        {
LABEL_73:
          if (++v40 >= v38)
          {
            goto LABEL_423;
          }
        }

        v55 = (v512 + 12 * v40);
        v56 = *v55;
        v57 = v55[1].i32[0];
        v58 = (*(this + 22) + 12 * v40);
        v59 = *v58;
        v60 = v58[1];
        v61 = v58[2];
        v62 = (*(this + 25) + 12 * v40);
        v63 = v62[2];
        if (v63 != -1)
        {
          v65 = *v62;
          v64 = v62[1];
          if (!v41 || a3[v59] && a3[v60] && a3[v61] && a3[v65] && a3[v64] && a3[v63])
          {
            v66 = *&a2[v59 * v523];
            v67 = vsub_s32(v66, v42);
            v68 = vabd_s32(v66, v42);
            v69 = v37 - v68.i32[0] - v68.i32[1];
            if (v69 < 0)
            {
              v67 = vbsl_s8(vcltz_s32(v67), vrev64_s32(vsub_s32(v68, v42)), __PAIR64__(v37 - v68.i32[0], v37 - v68.i32[1]));
            }

            v70 = *(this + 683);
            v71 = *(this + 684);
            if (v70 >= 0x40000001)
            {
              v89 = *(this + 683);
            }

            else
            {
              v72 = *(this + 686);
              do
              {
                v71 *= 2;
                *(this + 686) = --v72;
                if (!v72)
                {
                  v90 = *(this + 340);
                  *(this + 340) = v90 + 1;
                  v91 = *(this + 676);
                  if (v90 + 1 >= v91)
                  {
                    v92 = 65280;
                  }

                  else
                  {
                    v92 = *(*(this + 339) + v90 + 1) << 8;
                  }

                  v93 = v90 + 2;
                  *(this + 340) = v93;
                  if (v93 < v91)
                  {
                    v88 = *(*(this + 339) + v93);
                  }

                  else
                  {
                    v88 = 255;
                  }

                  v71 |= v92 | v88;
                  v72 = 16;
                  *(this + 686) = 16;
                }

                v89 = 2 * v70;
                v139 = v70 >= 0x20000001;
                v70 *= 2;
              }

              while (!v139);
            }

            v137 = (HIWORD(v89) * v508) & 0xFFFF0000;
            v138 = v89 - v137;
            v139 = v71 >= v137;
            v140 = v71 >= v137;
            if (v71 < v137)
            {
              v141 = (v508 >> 7) & 0x1FE;
            }

            else
            {
              v141 = ((v508 >> 7) & 0x1FE) + 1;
            }

            v142 = *&v515[2 * v141];
            if (v71 < v137)
            {
              v143 = v137;
            }

            else
            {
              v143 = v138;
            }

            if (v71 < v137)
            {
              v144 = 0;
            }

            else
            {
              v144 = v137;
            }

            v145 = 1;
            if (v139)
            {
              v145 = 2;
            }

            v146 = v71 - v144;
            *(this + 683) = v143;
            *(this + 684) = v146;
            if (v143 >= 0x40000001)
            {
              v149 = v143;
            }

            else
            {
              v147 = *(this + 686);
              do
              {
                v146 *= 2;
                *(this + 686) = --v147;
                if (!v147)
                {
                  v150 = *(this + 340);
                  *(this + 340) = v150 + 1;
                  v151 = *(this + 676);
                  if (v150 + 1 >= v151)
                  {
                    v152 = 65280;
                  }

                  else
                  {
                    v152 = *(*(this + 339) + v150 + 1) << 8;
                  }

                  v153 = v150 + 2;
                  *(this + 340) = v153;
                  if (v153 < v151)
                  {
                    v148 = *(*(this + 339) + v153);
                  }

                  else
                  {
                    v148 = 255;
                  }

                  v146 |= v152 | v148;
                  v147 = 16;
                  *(this + 686) = 16;
                }

                v149 = 2 * v143;
                v139 = v143 >= 0x20000001;
                v143 *= 2;
              }

              while (!v139);
            }

            v508 += v142;
            v154 = v531[v145];
            v155 = (HIWORD(v149) * v154) & 0xFFFF0000;
            v156 = (v154 >> 7) & 0x1FE;
            v157 = v149 - v155;
            if (v146 >= v155)
            {
              ++v156;
            }

            v531[v145] = *&v515[2 * v156] + v154;
            if (v146 < v155)
            {
              v158 = v155;
            }

            else
            {
              v158 = v157;
            }

            if (v146 < v155)
            {
              v159 = 0;
            }

            else
            {
              v159 = v155;
            }

            *(this + 683) = v158;
            *(this + 684) = v146 - v159;
            v160 = v140 | (2 * (v146 >= v155));
            if (v160 > 1)
            {
              if (v160 != 2)
              {
                v221 = *&a2[v60 * v523];
                v222 = vsub_s32(v221, v42);
                v223 = vabd_s32(v221, v42);
                v224 = v37 - v223.i32[0] - v223.i32[1];
                if (v224 < 0)
                {
                  v222 = vbsl_s8(vcltz_s32(v222), vrev64_s32(vsub_s32(v223, v42)), __PAIR64__(v37 - v223.i32[0], v37 - v223.i32[1]));
                }

                v225 = *&a2[v61 * v39];
                v226 = vsub_s32(v225, v42);
                v227 = vabd_s32(v225, v42);
                v228 = v37 - v227.i32[0] - v227.i32[1];
                if (v228 < 0)
                {
                  v226 = vbsl_s8(vcltz_s32(v226), vrev64_s32(vsub_s32(v227, v42)), __PAIR64__(v37 - v227.i32[0], v37 - v227.i32[1]));
                }

                v229 = *&a2[v65 * v523];
                v230 = vsub_s32(v229, v42);
                v231 = vabd_s32(v229, v42);
                v232 = v37 - v231.i32[0] - v231.i32[1];
                if (v232 < 0)
                {
                  v230 = vbsl_s8(vcltz_s32(v230), vrev64_s32(vsub_s32(v231, v42)), __PAIR64__(v37 - v231.i32[0], v37 - v231.i32[1]));
                }

                v233 = *&a2[v64 * v39];
                v234 = vsub_s32(v233, v42);
                v235 = vabd_s32(v233, v42);
                v236 = v37 - v235.i32[0] - v235.i32[1];
                if (v236 < 0)
                {
                  v234 = vbsl_s8(vcltz_s32(v234), vrev64_s32(vsub_s32(v235, v42)), __PAIR64__(v37 - v235.i32[0], v37 - v235.i32[1]));
                }

                v237 = *&a2[v63 * v523];
                v238 = vsub_s32(v237, v42);
                v239 = vabd_s32(v237, v42);
                if (v37 - v239.i32[0] - v239.i32[1] < 0)
                {
                  v238 = vbsl_s8(vcltz_s32(v238), vrev64_s32(vsub_s32(v239, v42)), __PAIR64__(v37 - v239.i32[0], v37 - v239.i32[1]));
                }

                v240 = vadd_s32(v230, v67);
                v241 = vadd_s32(v234, v222);
                v242 = vmull_s32(vsub_s32(vsra_n_s32(vadd_s32(v241, v241), vsra_n_u32(v240, v240, 0x1FuLL), 1uLL), vadd_s32(v226, v238)), vdup_n_s32(0x55555556u));
                v56 = vadd_s32(vshrn_n_s64(v242, 0x20uLL), vmovn_s64(vshrq_n_u64(v242, 0x3FuLL)));
                v243 = 1431655766 * ((v232 + v69) / 2 + 2 * (v236 + v224) - (v228 + v37 - v239.i32[0] - v239.i32[1]));
                v57 = HIDWORD(v243) + (v243 >> 63);
                goto LABEL_306;
              }

              v161 = *&a2[v65 * v39];
              v67 = vsub_s32(v161, v42);
              v162 = vabd_s32(v161, v42);
              v163 = v37 - v162.i32[0] - v162.i32[1];
              if (v163 < 0)
              {
                v67 = vbsl_s8(vcltz_s32(v67), vrev64_s32(vsub_s32(v162, v42)), __PAIR64__(v37 - v162.i32[0], v37 - v162.i32[1]));
              }

              v164 = *&a2[v64 * v39];
              v165 = vsub_s32(v164, v42);
              v166 = vabd_s32(v164, v42);
              v69 = v37 - v166.i32[0] - v166.i32[1];
              if (v69 < 0)
              {
                v165 = vbsl_s8(vcltz_s32(v165), vrev64_s32(vsub_s32(v166, v42)), __PAIR64__(v37 - v166.i32[0], v37 - v166.i32[1]));
              }

              v167 = *&a2[v63 * v39];
              v168 = vsub_s32(v167, v42);
              v169 = vabd_s32(v167, v42);
              v170 = v37 - v169.i32[0] - v169.i32[1];
              if (v170 < 0)
              {
                v168 = vbsl_s8(vcltz_s32(v168), vrev64_s32(vsub_s32(v169, v42)), __PAIR64__(v37 - v169.i32[0], v37 - v169.i32[1]));
              }
            }

            else
            {
              if (!v160)
              {
                if (v57 * v69 + v67.i32[0] * v56.i32[0] + v67.i32[1] * v56.i32[1] < 0)
                {
LABEL_200:
                  v56 = vneg_s32(v56);
                  v57 = -v57;
                }

LABEL_306:
                v245 = vabs_s32(v56);
                if (v57 >= 0)
                {
                  v246 = v57;
                }

                else
                {
                  v246 = -v57;
                }

                v247 = v245.u32[1];
                v248 = v245.i32[0];
                v250 = v245.i32[0] < v245.i32[1] || v245.i32[0] < v246;
                v251 = v56.i32[1];
                v518 = v56.i32[0];
                if (v250)
                {
                  v252 = v56.i32[0];
                  if (v245.i32[1] < v246)
                  {
                    v248 = v246;
                    v253 = v56.i32[1];
LABEL_321:
                    v528 = v252;
                    v529 = v253;
                    v530 = v248;
                    gcl::tmesh::DecoderImpl::decodeResidual(this, &v528, v39);
                    v255 = v526[0];
                    v256 = vabs_s32(v526[0]);
                    v48 = v37 - v256.i32[0] - v256.i32[1];
                    if (v48 < 0)
                    {
                      v255 = vbsl_s8(vcltz_s32(v526[0]), vrev64_s32(vsub_s32(v256, v42)), __PAIR64__(v37 - v256.i32[0], v37 - v256.i32[1]));
                    }

                    v39 = v523;
                    v44 = v256.i32[1] - (v37 - v256.i32[0]);
                    if (v57 >= 0)
                    {
                      v45 = v37 - v256.i32[0] - v256.i32[1];
                    }

                    else
                    {
                      v45 = v256.i32[1] - (v37 - v256.i32[0]);
                    }

                    if (v251 >= 0)
                    {
                      v44 = v37 - v256.i32[0] - v256.i32[1];
                    }

                    v46 = COERCE_DOUBLE(__PAIR64__(v44, v255.u32[0]));
                    if (v247 >= v246)
                    {
                      v47 = v255.i32[1];
                    }

                    else
                    {
                      v47 = v45;
                    }

                    if (v247 < v246)
                    {
                      v46 = *&v255;
                    }

                    if (v518 < 0)
                    {
                      v48 = -v48;
                    }

                    v49 = COERCE_DOUBLE(__PAIR64__(v255.u32[1], v48));
                    v50 = v255.i32[0];
                    if (v250)
                    {
                      v50 = v47;
                      *&v51 = v46;
                    }

                    else
                    {
                      *&v51 = v49;
                    }

                    a2 = v522;
                    v52 = vrev64_s32(vabs_s32(v51));
                    v53 = COERCE_DOUBLE(vbsl_s8(vcltz_s32(v51), v52, vsub_s32(v43, v52)));
                    v54 = COERCE_DOUBLE(vadd_s32(v51, v42));
                    if (v50 < 0)
                    {
                      v54 = v53;
                    }

                    *&v522[v40 * v523] = v54;
                    v38 = *(this + 959);
                    v41 = v510;
                    goto LABEL_73;
                  }

                  v254 = &v527;
                  v248 = v245.u32[1];
                  v253 = v57;
                }

                else
                {
                  v254 = v526;
                  v253 = v56.i32[1];
                  v252 = v57;
                }

                v254->i32[0] = v57;
                goto LABEL_321;
              }

              v217 = *&a2[v60 * v39];
              v165 = vsub_s32(v217, v42);
              v218 = vabd_s32(v217, v42);
              v163 = v37 - v218.i32[0] - v218.i32[1];
              if (v163 < 0)
              {
                v165 = vbsl_s8(vcltz_s32(v165), vrev64_s32(vsub_s32(v218, v42)), __PAIR64__(v37 - v218.i32[0], v37 - v218.i32[1]));
              }

              v219 = *&a2[v61 * v523];
              v168 = vsub_s32(v219, v42);
              v220 = vabd_s32(v219, v42);
              v170 = v37 - v220.i32[0] - v220.i32[1];
              if (v170 < 0)
              {
                v168 = vbsl_s8(vcltz_s32(v168), vrev64_s32(vsub_s32(v220, v42)), __PAIR64__(v37 - v220.i32[0], v37 - v220.i32[1]));
              }
            }

            v56 = vsub_s32(vadd_s32(v165, v67), v168);
            v57 = v163 + v69 - v170;
            goto LABEL_306;
          }
        }

        if (v61 != -1 && (!v41 || a3[v59] && a3[v60] && a3[v61]))
        {
          v73 = *&a2[v59 * v39];
          v74 = vsub_s32(v73, v42);
          v75 = vabd_s32(v73, v42);
          v76 = v37 - v75.i32[0] - v75.i32[1];
          if (v76 < 0)
          {
            v74 = vbsl_s8(vcltz_s32(v74), vrev64_s32(vsub_s32(v75, v42)), __PAIR64__(v37 - v75.i32[0], v37 - v75.i32[1]));
          }

          v77 = *&a2[v60 * v523];
          v78 = vsub_s32(v77, v42);
          v79 = vabd_s32(v77, v42);
          v80 = v37 - v79.i32[0] - v79.i32[1];
          if (v80 < 0)
          {
            v78 = vbsl_s8(vcltz_s32(v78), vrev64_s32(vsub_s32(v79, v42)), __PAIR64__(v37 - v79.i32[0], v37 - v79.i32[1]));
          }

          v81 = *&a2[v61 * v39];
          v82 = vsub_s32(v81, v42);
          v83 = vabd_s32(v81, v42);
          v84 = v37 - v83.i32[0] - v83.i32[1];
          if (v84 < 0)
          {
            v82 = vbsl_s8(vcltz_s32(v82), vrev64_s32(vsub_s32(v83, v42)), __PAIR64__(v37 - v83.i32[0], v37 - v83.i32[1]));
          }

          v85 = *(this + 683);
          v86 = *(this + 684);
          if (v85 >= 0x40000001)
          {
            v95 = *(this + 683);
          }

          else
          {
            v87 = *(this + 686);
            do
            {
              v86 *= 2;
              *(this + 686) = --v87;
              if (!v87)
              {
                v96 = *(this + 340);
                *(this + 340) = v96 + 1;
                v97 = *(this + 676);
                if (v96 + 1 >= v97)
                {
                  v98 = 65280;
                }

                else
                {
                  v98 = *(*(this + 339) + v96 + 1) << 8;
                }

                v99 = v96 + 2;
                *(this + 340) = v99;
                if (v99 < v97)
                {
                  v94 = *(*(this + 339) + v99);
                }

                else
                {
                  v94 = 255;
                }

                v86 |= v98 | v94;
                v87 = 16;
                *(this + 686) = 16;
              }

              v95 = 2 * v85;
              v139 = v85 >= 0x20000001;
              v85 *= 2;
            }

            while (!v139);
          }

          v171 = (HIWORD(v95) * v504) & 0xFFFF0000;
          v172 = (v504 >> 7) & 0x1FE;
          v173 = v95 - v171;
          v174 = v86 >= v171;
          v175 = v86 >= v171;
          if (v86 >= v171)
          {
            ++v172;
          }

          v176 = *&v515[2 * v172];
          if (v86 < v171)
          {
            v177 = v171;
          }

          else
          {
            v177 = v173;
          }

          if (v86 < v171)
          {
            v178 = 0;
          }

          else
          {
            v178 = v171;
          }

          v179 = 1;
          if (v174)
          {
            v179 = 2;
          }

          v180 = v86 - v178;
          *(this + 683) = v177;
          *(this + 684) = v180;
          v181 = v532[v179];
          if (v177 >= 0x40000001)
          {
            v184 = v177;
          }

          else
          {
            v182 = *(this + 686);
            do
            {
              v180 *= 2;
              *(this + 686) = --v182;
              if (!v182)
              {
                v185 = *(this + 340);
                *(this + 340) = v185 + 1;
                v186 = *(this + 676);
                if (v185 + 1 >= v186)
                {
                  v187 = 65280;
                }

                else
                {
                  v187 = *(*(this + 339) + v185 + 1) << 8;
                }

                v188 = v185 + 2;
                *(this + 340) = v188;
                if (v188 < v186)
                {
                  v183 = *(*(this + 339) + v188);
                }

                else
                {
                  v183 = 255;
                }

                v180 |= v187 | v183;
                v182 = 16;
                *(this + 686) = 16;
              }

              v184 = 2 * v177;
              v139 = v177 >= 0x20000001;
              v177 *= 2;
            }

            while (!v139);
          }

          v189 = v176 + v504;
          v190 = (HIWORD(v184) * v181) & 0xFFFF0000;
          v191 = (v181 >> 7) & 0x1FE;
          if (v180 >= v190)
          {
            ++v191;
          }

          v532[v179] = *&v515[2 * v191] + v181;
          if (v180 < v190)
          {
            v192 = (HIWORD(v184) * v181) & 0xFFFF0000;
          }

          else
          {
            v192 = v184 - v190;
          }

          if (v180 < v190)
          {
            v193 = 0;
          }

          else
          {
            v193 = (HIWORD(v184) * v181) & 0xFFFF0000;
          }

          *(this + 683) = v192;
          *(this + 684) = v180 - v193;
          v194 = v175 | (2 * (v180 >= v190));
          v504 = v189;
          if (v194 > 1)
          {
            v195 = vsub_s32(v78, vmvn_s8(v74));
            if (v194 == 2)
            {
              v56 = vshr_n_s32(vsra_n_u32(v195, v195, 0x1FuLL), 1uLL);
              v57 = (v76 + v80 + 1) / 2;
            }

            else
            {
              v244 = vmull_s32(vadd_s32(v195, v82), vdup_n_s32(0x55555556u));
              v56 = vadd_s32(vshrn_n_s64(v244, 0x20uLL), vmovn_s64(vshrq_n_u64(v244, 0x3FuLL)));
              v57 = (v76 + v80 + v84 + 1) / 3;
            }

            goto LABEL_306;
          }

          if (v194)
          {
            v56 = vsub_s32(vadd_s32(v78, v74), v82);
            v57 = v80 + v76 - v84;
          }

          else if (v57 * v76 + v74.i32[0] * v56.i32[0] + v74.i32[1] * v56.i32[1] < 0)
          {
            goto LABEL_200;
          }

          goto LABEL_306;
        }

        if (v60 == -1 || v41 && (!a3[v59] || !a3[v60]))
        {
          if (v59 == -1 || v41 && !a3[v59])
          {
            v127 = *(this + 683);
            v128 = *(this + 684);
            if (v127 >= 0x40000001)
            {
              v132 = *(this + 683);
              v130 = v502;
            }

            else
            {
              v129 = *(this + 686);
              v130 = v502;
              do
              {
                v128 *= 2;
                *(this + 686) = --v129;
                if (!v129)
                {
                  v133 = *(this + 340);
                  *(this + 340) = v133 + 1;
                  v134 = *(this + 676);
                  if (v133 + 1 >= v134)
                  {
                    v135 = 65280;
                  }

                  else
                  {
                    v135 = *(*(this + 339) + v133 + 1) << 8;
                  }

                  v136 = v133 + 2;
                  *(this + 340) = v136;
                  if (v136 < v134)
                  {
                    v131 = *(*(this + 339) + v136);
                  }

                  else
                  {
                    v131 = 255;
                  }

                  v128 |= v135 | v131;
                  v129 = 16;
                  *(this + 686) = 16;
                }

                v132 = 2 * v127;
                v139 = v127 >= 0x20000001;
                v127 *= 2;
              }

              while (!v139);
            }

            v196 = (HIWORD(v132) * v130) & 0xFFFF0000;
            v197 = v132 - v196;
            if (v128 < v196)
            {
              v198 = 0;
            }

            else
            {
              v198 = (HIWORD(v132) * v130) & 0xFFFF0000;
            }

            *(this + 684) = v128 - v198;
            v199 = v128 >= v196;
            if (v128 < v196)
            {
              v200 = (v130 >> 7) & 0x1FE;
            }

            else
            {
              v200 = ((v130 >> 7) & 0x1FE) + 1;
            }

            v502 = *&v515[2 * v200] + v130;
            if (v199)
            {
              v201 = v197;
            }

            else
            {
              v201 = v196;
            }

            *(this + 683) = v201;
            if (!v199)
            {
              goto LABEL_306;
            }

LABEL_285:
            v56 = vneg_s32(v56);
            v57 = -v57;
            goto LABEL_306;
          }

          v116 = *&a2[v59 * v39];
          v101 = vsub_s32(v116, v42);
          v117 = vabd_s32(v116, v42);
          v103 = v37 - v117.i32[0] - v117.i32[1];
          if (v103 < 0)
          {
            v101 = vbsl_s8(vcltz_s32(v101), vrev64_s32(vsub_s32(v117, v42)), __PAIR64__(v37 - v117.i32[0], v37 - v117.i32[1]));
          }

          v118 = *(this + 683);
          v119 = *(this + 684);
          if (v118 >= 0x40000001)
          {
            v122 = *(this + 683);
          }

          else
          {
            v120 = *(this + 686);
            do
            {
              v119 *= 2;
              *(this + 686) = --v120;
              if (!v120)
              {
                v123 = *(this + 340);
                *(this + 340) = v123 + 1;
                v124 = *(this + 676);
                if (v123 + 1 >= v124)
                {
                  v125 = 65280;
                }

                else
                {
                  v125 = *(*(this + 339) + v123 + 1) << 8;
                }

                v126 = v123 + 2;
                *(this + 340) = v126;
                if (v126 < v124)
                {
                  v121 = *(*(this + 339) + v126);
                }

                else
                {
                  v121 = 255;
                }

                v119 |= v125 | v121;
                v120 = 16;
                *(this + 686) = 16;
              }

              v122 = 2 * v118;
              v139 = v118 >= 0x20000001;
              v118 *= 2;
            }

            while (!v139);
          }

          v210 = (HIWORD(v122) * __n) & 0xFFFF0000;
          v211 = v122 - v210;
          if (v119 < v210)
          {
            v212 = 0;
          }

          else
          {
            v212 = (HIWORD(v122) * __n) & 0xFFFF0000;
          }

          *(this + 684) = v119 - v212;
          v213 = v119 >= v210;
          if (v119 < v210)
          {
            v214 = (__n >> 7) & 0x1FE;
          }

          else
          {
            v214 = ((__n >> 7) & 0x1FE) + 1;
          }

          v215 = *&v515[2 * v214] + __n;
          if (v213)
          {
            v216 = v211;
          }

          else
          {
            v216 = v210;
          }

          *(this + 683) = v216;
          __n = v215;
          if (v213)
          {
            v57 = v37 - v117.i32[0] - v117.i32[1];
            v56 = v101;
            goto LABEL_306;
          }
        }

        else
        {
          v100 = *&a2[v59 * v523];
          v101 = vsub_s32(v100, v42);
          v102 = vabd_s32(v100, v42);
          v103 = v37 - v102.i32[0] - v102.i32[1];
          if (v103 < 0)
          {
            v101 = vbsl_s8(vcltz_s32(v101), vrev64_s32(vsub_s32(v102, v42)), __PAIR64__(v37 - v102.i32[0], v37 - v102.i32[1]));
          }

          v104 = *&a2[v60 * v39];
          v105 = vsub_s32(v104, v42);
          v106 = vabd_s32(v104, v42);
          if (v37 - v106.i32[0] - v106.i32[1] < 0)
          {
            v105 = vbsl_s8(vcltz_s32(v105), vrev64_s32(vsub_s32(v106, v42)), __PAIR64__(v37 - v106.i32[0], v37 - v106.i32[1]));
          }

          v107 = *(this + 683);
          v108 = *(this + 684);
          if (v107 >= 0x40000001)
          {
            v111 = *(this + 683);
          }

          else
          {
            v109 = *(this + 686);
            do
            {
              v108 *= 2;
              *(this + 686) = --v109;
              if (!v109)
              {
                v112 = *(this + 340);
                *(this + 340) = v112 + 1;
                v113 = *(this + 676);
                if (v112 + 1 >= v113)
                {
                  v114 = 65280;
                }

                else
                {
                  v114 = *(*(this + 339) + v112 + 1) << 8;
                }

                v115 = v112 + 2;
                *(this + 340) = v115;
                if (v115 < v113)
                {
                  v110 = *(*(this + 339) + v115);
                }

                else
                {
                  v110 = 255;
                }

                v108 |= v114 | v110;
                v109 = 16;
                *(this + 686) = 16;
              }

              v111 = 2 * v107;
              v139 = v107 >= 0x20000001;
              v107 *= 2;
            }

            while (!v139);
          }

          v202 = (HIWORD(v111) * __n) & 0xFFFF0000;
          v203 = v111 - v202;
          if (v108 < v202)
          {
            v204 = 0;
          }

          else
          {
            v204 = (HIWORD(v111) * __n) & 0xFFFF0000;
          }

          *(this + 684) = v108 - v204;
          v205 = v108 >= v202;
          if (v108 < v202)
          {
            v206 = (__n >> 7) & 0x1FE;
          }

          else
          {
            v206 = ((__n >> 7) & 0x1FE) + 1;
          }

          v207 = *&v515[2 * v206] + __n;
          if (v205)
          {
            v208 = v203;
          }

          else
          {
            v208 = v202;
          }

          *(this + 683) = v208;
          __n = v207;
          if (v205)
          {
            v209 = vsub_s32(v105, vmvn_s8(v101));
            v56 = vshr_n_s32(vsra_n_u32(v209, v209, 0x1FuLL), 1uLL);
            v57 = (v103 + v37 - v106.i32[0] - v106.i32[1] + 1) / 2;
            goto LABEL_306;
          }
        }

        if (((v57 * v103 + v101.i32[0] * v56.i32[0] + v101.i32[1] * v56.i32[1]) & 0x8000000000000000) == 0)
        {
          goto LABEL_306;
        }

        goto LABEL_285;
      }

LABEL_423:
      if (v557)
      {
        *(&v557 + 1) = v557;
        operator delete(v557);
      }

      if (*(&v555 + 1))
      {
        *&v556 = *(&v555 + 1);
        operator delete(*(&v555 + 1));
      }

      if (v554)
      {
        *(&v554 + 1) = v554;
        operator delete(v554);
      }

      if (*(&v552 + 1))
      {
        *&v553 = *(&v552 + 1);
        operator delete(*(&v552 + 1));
      }

      if (v551)
      {
        *(&v551 + 1) = v551;
        operator delete(v551);
      }

      if (*(&v549 + 1))
      {
        *&v550 = *(&v549 + 1);
        operator delete(*(&v549 + 1));
      }

      if (v548)
      {
        *(&v548 + 1) = v548;
        operator delete(v548);
      }

      if (*(&v546 + 1))
      {
        *&v547 = *(&v546 + 1);
        operator delete(*(&v546 + 1));
      }

      if (v545)
      {
        *(&v545 + 1) = v545;
        operator delete(v545);
      }

      if (*(&v543 + 1))
      {
        *&v544 = *(&v543 + 1);
        operator delete(*(&v543 + 1));
      }

      if (__p)
      {
        *(&__p + 1) = __p;
        operator delete(__p);
      }

      if (*(&v540 + 1))
      {
        *&v541 = *(&v540 + 1);
        operator delete(*(&v540 + 1));
      }

      if (v539[0])
      {
        v539[1] = v539[0];
        operator delete(v539[0]);
      }

      if (v537[1])
      {
        *&v538 = v537[1];
        operator delete(v537[1]);
      }

      v317 = __b;
      if (__b)
      {
        *(&__b + 1) = __b;
LABEL_453:
        operator delete(v317);
      }

LABEL_454:
      v318 = v533;
      if (!v533)
      {
        return;
      }

      goto LABEL_769;
    }

    v259 = ~(-1 << (*(this + 962) - 1));
    v533 = 0;
    v534 = 0;
    v535 = 0;
    gcl::tmesh::EstimateQuantizedNormals(this + 13, this + 16, &v533, v259);
    *&v543 = 0;
    v541 = 0u;
    __p = 0u;
    v540 = 0u;
    v538 = 0u;
    *v539 = 0u;
    __b = 0u;
    *v537 = 0u;
    gcl::tmesh::ACContext::init(&__b, v523);
    v260 = *(this + 959);
    v261 = v523;
    if (v260 < 1)
    {
LABEL_413:
      if (__p)
      {
        operator delete(__p);
      }

      if (*(&v540 + 1))
      {
        operator delete(*(&v540 + 1));
      }

      if (v539[0])
      {
        operator delete(v539[0]);
      }

      if (v537[1])
      {
        operator delete(v537[1]);
      }

      v317 = __b;
      if (__b)
      {
        goto LABEL_453;
      }

      goto LABEL_454;
    }

    v262 = 0;
    v263 = *(this + 964);
    v264 = vdup_n_s32(v259);
    v265 = vdup_n_s32(2 * v259);
    v519 = 0x8000;
    v516 = v533;
    v513 = v263;
    while (v263 && !a3[v262])
    {
LABEL_349:
      if (++v262 >= v260)
      {
        goto LABEL_413;
      }
    }

    v277 = (v516 + 12 * v262);
    v278 = *v277;
    v279 = v277[1].i32[0];
    v280 = *(*(this + 22) + 12 * v262);
    if (v280 == -1 || v263 && !a3[v280])
    {
      v290 = *(this + 683);
      v291 = *(this + 684);
      if (v290 >= 0x40000001)
      {
        v294 = *(this + 683);
      }

      else
      {
        v292 = *(this + 686);
        do
        {
          v291 *= 2;
          *(this + 686) = --v292;
          if (!v292)
          {
            v295 = *(this + 340);
            *(this + 340) = v295 + 1;
            v296 = *(this + 676);
            if (v295 + 1 >= v296)
            {
              v297 = 65280;
            }

            else
            {
              v297 = *(*(this + 339) + v295 + 1) << 8;
            }

            v298 = v295 + 2;
            *(this + 340) = v298;
            if (v298 < v296)
            {
              v293 = *(*(this + 339) + v298);
            }

            else
            {
              v293 = 255;
            }

            v291 |= v297 | v293;
            v292 = 16;
            *(this + 686) = 16;
          }

          v294 = 2 * v290;
          v139 = v290 >= 0x20000001;
          v290 *= 2;
        }

        while (!v139);
      }

      v299 = (HIWORD(v294) * v519) & 0xFFFF0000;
      v300 = v294 - v299;
      if (v291 < v299)
      {
        v301 = 0;
      }

      else
      {
        v301 = (HIWORD(v294) * v519) & 0xFFFF0000;
      }

      *(this + 684) = v291 - v301;
      v302 = v291 >= v299;
      if (v291 < v299)
      {
        v303 = (v519 >> 7) & 0x1FE;
      }

      else
      {
        v303 = ((v519 >> 7) & 0x1FE) + 1;
      }

      v519 += *(this + v303 + 1376);
      if (v302)
      {
        v304 = v300;
      }

      else
      {
        v304 = v299;
      }

      *(this + 683) = v304;
      if (v302)
      {
        goto LABEL_392;
      }
    }

    else
    {
      v281 = &a2[v280 * v261];
      v282 = *v281 - v259;
      v283 = v281[1] - v259;
      if (v282 >= 0)
      {
        v284 = v282;
      }

      else
      {
        v284 = -v282;
      }

      if (v283 >= 0)
      {
        v285 = v283;
      }

      else
      {
        v285 = -v283;
      }

      v286 = v259 - v284;
      v287 = v285 - v259;
      if (v282 >= 0)
      {
        v287 = v259 - v285;
      }

      v288 = v284 - v259;
      if (v283 >= 0)
      {
        v288 = v286;
      }

      v289 = v286 - v285;
      if (v289 < 0)
      {
        v282 = v287;
        v283 = v288;
      }

      if (v279 * v289 + v282 * v278.i32[0] + v283 * v278.i32[1] < 0)
      {
LABEL_392:
        v278 = vneg_s32(v278);
        v279 = -v279;
      }
    }

    v305 = vabs_s32(v278);
    if (v279 >= 0)
    {
      v306 = v279;
    }

    else
    {
      v306 = -v279;
    }

    v307 = v305.u32[1];
    v308 = v305.i32[0];
    v310 = v305.i32[0] < v305.i32[1] || v305.i32[0] < v306;
    v311 = v278.i32[1];
    v524 = v278.i32[0];
    if (v310)
    {
      v312 = v278.i32[0];
      if (v305.i32[1] < v306)
      {
        v308 = v306;
        v313 = v278.i32[1];
LABEL_408:
        v528 = v312;
        v529 = v313;
        v530 = v308;
        gcl::tmesh::DecoderImpl::decodeResidual(this, &v528, v261);
        v315 = v526[0];
        v316 = vabs_s32(v526[0]);
        v270 = v259 - v316.i32[0] - v316.i32[1];
        if (v270 < 0)
        {
          v315 = vbsl_s8(vcltz_s32(v526[0]), vrev64_s32(vsub_s32(v316, v264)), __PAIR64__(v259 - v316.i32[0], v259 - v316.i32[1]));
        }

        v261 = v525[0];
        v266 = v316.i32[1] - (v259 - v316.i32[0]);
        if (v279 >= 0)
        {
          v267 = v259 - v316.i32[0] - v316.i32[1];
        }

        else
        {
          v267 = v316.i32[1] - (v259 - v316.i32[0]);
        }

        if (v311 >= 0)
        {
          v266 = v259 - v316.i32[0] - v316.i32[1];
        }

        v268 = COERCE_DOUBLE(__PAIR64__(v266, v315.u32[0]));
        if (v307 >= v306)
        {
          v269 = v315.i32[1];
        }

        else
        {
          v269 = v267;
        }

        if (v307 < v306)
        {
          v268 = *&v315;
        }

        if (v524 < 0)
        {
          v270 = -v270;
        }

        v271 = COERCE_DOUBLE(__PAIR64__(v315.u32[1], v270));
        v272 = v315.i32[0];
        if (v310)
        {
          v272 = v269;
          *&v273 = v268;
        }

        else
        {
          *&v273 = v271;
        }

        a2 = v522;
        v274 = vrev64_s32(vabs_s32(v273));
        v275 = COERCE_DOUBLE(vbsl_s8(vcltz_s32(v273), v274, vsub_s32(v265, v274)));
        v276 = COERCE_DOUBLE(vadd_s32(v273, v264));
        if (v272 < 0)
        {
          v276 = v275;
        }

        *&v522[v262 * *v525] = v276;
        v260 = *(this + 959);
        v263 = v513;
        goto LABEL_349;
      }

      v314 = v532;
      v308 = v305.u32[1];
      v313 = v279;
    }

    else
    {
      v314 = v526;
      v313 = v278.i32[1];
      v312 = v279;
    }

    v314->i32[0] = v279;
    goto LABEL_408;
  }

  if (v34)
  {
    if (v34 != 1)
    {
      if (v34 != 2)
      {
        return;
      }

      v558 = 0;
      v556 = 0u;
      v557 = 0u;
      v554 = 0u;
      v555 = 0u;
      v552 = 0u;
      v553 = 0u;
      v550 = 0u;
      v551 = 0u;
      v548 = 0u;
      v549 = 0u;
      v546 = 0u;
      v547 = 0u;
      v544 = 0u;
      v545 = 0u;
      __p = 0u;
      v543 = 0u;
      v540 = 0u;
      v541 = 0u;
      v538 = 0u;
      *v539 = 0u;
      __b = 0u;
      *v537 = 0u;
      gcl::tmesh::ACContext::init(&__b, v6);
      gcl::tmesh::ACContext::init((&v543 + 8), v523);
      gcl::tmesh::ACContext::init(&v551, v523);
      memset_pattern16(&v533, &unk_1B33B25C0, 6uLL);
      v36 = v523;
      if (v523)
      {
        if ((v523 & 0x80000000) == 0)
        {
          operator new();
        }

        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      if (*(this + 959) < 1)
      {
        goto LABEL_740;
      }

      v453 = 0;
      v454 = *(this + 964);
      v455 = v533;
      v521 = this + 2752;
      while (1)
      {
        if (v454 && !a3[v453])
        {
          goto LABEL_647;
        }

        v456 = (*(this + 22) + 12 * v453);
        v457 = *v456;
        v458 = v456[1];
        v459 = v456[2];
        v460 = (*(this + 25) + 12 * v453);
        v461 = v460[2];
        if (v461 != -1 && ((v463 = *v460, v462 = v460[1], !v454) || a3[v457] && a3[v458] && a3[v459] && a3[v463] && a3[v462] && a3[v461]))
        {
          v464 = *(this + 683);
          v465 = *(this + 684);
          if (v464 >= 0x40000001)
          {
            v468 = *(this + 683);
          }

          else
          {
            v466 = *(this + 686);
            do
            {
              v465 *= 2;
              *(this + 686) = --v466;
              if (!v466)
              {
                v469 = *(this + 340);
                *(this + 340) = v469 + 1;
                v470 = *(this + 676);
                if (v469 + 1 >= v470)
                {
                  v471 = 65280;
                }

                else
                {
                  v471 = *(*(this + 339) + v469 + 1) << 8;
                }

                v472 = v469 + 2;
                *(this + 340) = v472;
                if (v472 < v470)
                {
                  v467 = *(*(this + 339) + v472);
                }

                else
                {
                  v467 = 255;
                }

                v465 |= v471 | v467;
                v466 = 16;
                *(this + 686) = 16;
              }

              v468 = 2 * v464;
              v139 = v464 >= 0x20000001;
              v464 *= 2;
            }

            while (!v139);
          }

          v473 = (HIWORD(v468) * v455) & 0xFFFF0000;
          v474 = v468 - v473;
          v475 = v465 >= v473;
          if (v465 < v473)
          {
            v476 = (v455 >> 7) & 0x1FE;
          }

          else
          {
            v476 = ((v455 >> 7) & 0x1FE) + 1;
          }

          v477 = *&v521[2 * v476];
          if (v465 < v473)
          {
            v478 = v473;
          }

          else
          {
            v478 = v474;
          }

          if (v465 < v473)
          {
            v479 = 0;
          }

          else
          {
            v479 = v473;
          }

          v480 = 2;
          if (v475)
          {
            v480 = 4;
          }

          v481 = v465 - v479;
          *(this + 683) = v478;
          *(this + 684) = v481;
          if (v478 >= 0x40000001)
          {
            v484 = v478;
          }

          else
          {
            v482 = *(this + 686);
            do
            {
              v481 *= 2;
              *(this + 686) = --v482;
              if (!v482)
              {
                v485 = *(this + 340);
                *(this + 340) = v485 + 1;
                v486 = *(this + 676);
                if (v485 + 1 >= v486)
                {
                  v487 = 65280;
                }

                else
                {
                  v487 = *(*(this + 339) + v485 + 1) << 8;
                }

                *(this + 340) = v485 + 2;
                if (v485 + 2 < v486)
                {
                  v483 = *(*(this + 339) + v485 + 2);
                }

                else
                {
                  v483 = 255;
                }

                v481 |= v487 | v483;
                v482 = 16;
                *(this + 686) = 16;
              }

              v484 = 2 * v478;
              v139 = v478 >= 0x20000001;
              v478 *= 2;
            }

            while (!v139);
          }

          v455 += v477;
          v488 = *(&v533 + v480);
          v489 = (HIWORD(v484) * v488) & 0xFFFF0000;
          v490 = (v488 >> 7) & 0x1FE;
          if (v481 >= v489)
          {
            ++v490;
          }

          *(&v533 + v480) = *&v521[2 * v490] + v488;
          if (v481 < v489)
          {
            v491 = (HIWORD(v484) * v488) & 0xFFFF0000;
          }

          else
          {
            v491 = v484 - v489;
          }

          if (v481 < v489)
          {
            v492 = 0;
          }

          else
          {
            v492 = (HIWORD(v484) * v488) & 0xFFFF0000;
          }

          *(this + 683) = v491;
          *(this + 684) = v481 - v492;
        }

        else if ((v459 == -1 || v454 && (!a3[v457] || !a3[v458] || !a3[v459])) && (v458 == -1 || v454 && (!a3[v457] || !a3[v458])) && (v457 == -1 || v454 && !a3[v457]))
        {
          LOBYTE(v528) = 3;
          gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v36);
          v36 = v523;
          goto LABEL_647;
        }

        gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v36);
        v36 = v523;
LABEL_647:
        if (++v453 >= *(this + 959))
        {
          goto LABEL_740;
        }
      }
    }

    v558 = 0;
    v556 = 0u;
    v557 = 0u;
    v554 = 0u;
    v555 = 0u;
    v552 = 0u;
    v553 = 0u;
    v550 = 0u;
    v551 = 0u;
    v548 = 0u;
    v549 = 0u;
    v546 = 0u;
    v547 = 0u;
    v544 = 0u;
    v545 = 0u;
    __p = 0u;
    v543 = 0u;
    v540 = 0u;
    v541 = 0u;
    v538 = 0u;
    *v539 = 0u;
    __b = 0u;
    *v537 = 0u;
    gcl::tmesh::ACContext::init(&__b, v6);
    gcl::tmesh::ACContext::init((&v543 + 8), v523);
    gcl::tmesh::ACContext::init(&v551, v523);
    if (v523)
    {
      if ((v523 & 0x80000000) == 0)
      {
        operator new();
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v493 = 0;
    if (*(this + 959) < 1)
    {
      goto LABEL_740;
    }

    v494 = 0;
    v495 = *(this + 964);
    while (1)
    {
      if (v495)
      {
        if (!a3[v494])
        {
          goto LABEL_721;
        }

        v496 = (*(this + 22) + 12 * v494);
        v497 = *v496;
        v498 = v496[1];
        v499 = v496[2];
        if ((v499 == -1 || !a3[v497] || !a3[v498] || !a3[v499]) && (v498 == -1 || !a3[v497] || !a3[v498]) && (v497 == -1 || !a3[v497]))
        {
LABEL_733:
          LOBYTE(v533) = 3;
          gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v493);
          v493 = v523;
          goto LABEL_721;
        }
      }

      else
      {
        v500 = (*(this + 22) + 12 * v494);
        if (v500[2] == -1 && v500[1] == -1 && *v500 == -1)
        {
          goto LABEL_733;
        }
      }

      gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v523);
      v493 = v523;
LABEL_721:
      if (++v494 >= *(this + 959))
      {
        goto LABEL_740;
      }
    }
  }

  v549 = 0u;
  v550 = 0u;
  v547 = 0u;
  v548 = 0u;
  v545 = 0u;
  v546 = 0u;
  v543 = 0u;
  v544 = 0u;
  v541 = 0u;
  __p = 0u;
  v540 = 0u;
  v538 = 0u;
  *v539 = 0u;
  __b = 0u;
  *v537 = 0u;
  gcl::tmesh::ACContext::init(&__b, v6);
  gcl::tmesh::ACContext::init((&v543 + 8), v6);
  v257 = v6;
  if (v6)
  {
    if ((v523 & 0x80000000) == 0)
    {
      operator new();
    }

    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }

  if (*(this + 959) >= 1)
  {
    v319 = 0;
    v320 = *(this + 964);
    v321 = 4 * v523;
    do
    {
      if (v320)
      {
        if (!a3[v319])
        {
          goto LABEL_459;
        }

        v322 = (*(this + 22) + 12 * v319);
        v323 = *v322;
        v324 = v322[1];
        if (v324 == -1 || !a3[v323] || !a3[v324])
        {
          if (v323 == -1 || !a3[v323])
          {
LABEL_467:
            if (v257)
            {
              bzero(0, v321);
            }

            LOBYTE(v533) = 3;
            gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v523);
            v257 = v523;
            goto LABEL_459;
          }

          goto LABEL_475;
        }
      }

      else
      {
        v325 = (*(this + 22) + 12 * v319);
        v323 = *v325;
        v324 = v325[1];
        if (v324 == -1)
        {
          if (v323 == -1)
          {
            goto LABEL_467;
          }

LABEL_475:
          if (v523)
          {
            memcpy(0, &a2[v323 * v257], v321);
            v257 = v523;
          }

          goto LABEL_458;
        }
      }

      if (v523)
      {
        v326 = v323 * v523;
        v327 = v324 * v257;
        if (v257 >= 4)
        {
          v329 = &a2[v326];
          v330 = 0;
          v331 = v523 & 0x7FFFFFFC;
          v332 = &a2[v327];
          do
          {
            v333 = *v329;
            v329 += 4;
            v334 = v333;
            v335 = *v332;
            v332 += 4;
            v336 = vaddq_s32(v335, v334);
            *v330++ = vshrq_n_s32(vsraq_n_u32(v336, v336, 0x1FuLL), 1uLL);
            v331 -= 4;
          }

          while (v331);
          v328 = v523 & 0x7FFFFFFC;
          if (v328 == v523)
          {
            goto LABEL_458;
          }
        }

        else
        {
          v328 = 0;
        }

        v337 = v326;
        v338 = v327;
        v339 = v523 - v328;
        v340 = v328;
        v341 = (4 * v328);
        v342 = &a2[v328 + v338];
        v343 = &a2[v337 + v340];
        do
        {
          v345 = *v343++;
          v344 = v345;
          v346 = *v342++;
          *v341++ = (v346 + v344) / 2;
          --v339;
        }

        while (v339);
      }

LABEL_458:
      gcl::tmesh::DecoderImpl::decodeResidual(this, 0, v257);
      v257 = v523;
LABEL_459:
      ++v319;
    }

    while (v319 < *(this + 959));
  }

LABEL_750:
  if (*(&v549 + 1))
  {
    operator delete(*(&v549 + 1));
  }

  if (v548)
  {
    operator delete(v548);
  }

  if (*(&v546 + 1))
  {
    operator delete(*(&v546 + 1));
  }

  if (v545)
  {
    operator delete(v545);
  }

  if (*(&v543 + 1))
  {
    operator delete(*(&v543 + 1));
  }

  if (__p)
  {
    operator delete(__p);
  }

  if (*(&v540 + 1))
  {
    operator delete(*(&v540 + 1));
  }

  if (v539[0])
  {
    operator delete(v539[0]);
  }

  if (v537[1])
  {
    operator delete(v537[1]);
  }

  v318 = __b;
  if (__b)
  {
LABEL_769:
    operator delete(v318);
  }
}

void sub_1B336BCA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, void *a50, uint64_t a51, uint64_t a52, void *a53, uint64_t a54, uint64_t a55, void *a56, uint64_t a57, uint64_t a58, void *a59, uint64_t a60, uint64_t a61, void *a62, uint64_t a63)
{
  operator delete(v71);
  if (STACK[0x280])
  {
    operator delete(STACK[0x280]);
    v73 = STACK[0x268];
    if (STACK[0x268])
    {
LABEL_31:
      operator delete(v73);
      v74 = STACK[0x250];
      if (STACK[0x250])
      {
LABEL_32:
        operator delete(v74);
        v75 = STACK[0x238];
        if (STACK[0x238])
        {
LABEL_33:
          operator delete(v75);
          v76 = STACK[0x220];
          if (!STACK[0x220])
          {
LABEL_7:
            if (STACK[0x208])
            {
              operator delete(STACK[0x208]);
              v77 = a71;
              if (!a71)
              {
LABEL_9:
                v78 = a68;
                if (!a68)
                {
                  goto LABEL_10;
                }

                goto LABEL_22;
              }
            }

            else
            {
              v77 = a71;
              if (!a71)
              {
                goto LABEL_9;
              }
            }

            operator delete(v77);
            v78 = a68;
            if (!a68)
            {
LABEL_10:
              v79 = a65;
              if (!a65)
              {
                goto LABEL_11;
              }

              goto LABEL_23;
            }

LABEL_22:
            operator delete(v78);
            v79 = a65;
            if (!a65)
            {
LABEL_11:
              v80 = a62;
              if (!a62)
              {
                goto LABEL_12;
              }

              goto LABEL_24;
            }

LABEL_23:
            operator delete(v79);
            v80 = a62;
            if (!a62)
            {
LABEL_12:
              v81 = a59;
              if (!a59)
              {
                goto LABEL_13;
              }

              goto LABEL_25;
            }

LABEL_24:
            operator delete(v80);
            v81 = a59;
            if (!a59)
            {
LABEL_13:
              v82 = a56;
              if (!a56)
              {
                goto LABEL_14;
              }

              goto LABEL_26;
            }

LABEL_25:
            operator delete(v81);
            v82 = a56;
            if (!a56)
            {
LABEL_14:
              v83 = a53;
              if (!a53)
              {
                goto LABEL_15;
              }

              goto LABEL_27;
            }

LABEL_26:
            operator delete(v82);
            v83 = a53;
            if (!a53)
            {
LABEL_15:
              v84 = a50;
              if (!a50)
              {
                goto LABEL_17;
              }

              goto LABEL_16;
            }

LABEL_27:
            operator delete(v83);
            v84 = a50;
            if (!a50)
            {
LABEL_17:
              if (a47)
              {
                operator delete(a47);
              }

              _Unwind_Resume(a1);
            }

LABEL_16:
            operator delete(v84);
            goto LABEL_17;
          }

LABEL_6:
          operator delete(v76);
          goto LABEL_7;
        }

LABEL_5:
        v76 = STACK[0x220];
        if (!STACK[0x220])
        {
          goto LABEL_7;
        }

        goto LABEL_6;
      }

LABEL_4:
      v75 = STACK[0x238];
      if (STACK[0x238])
      {
        goto LABEL_33;
      }

      goto LABEL_5;
    }
  }

  else
  {
    v73 = STACK[0x268];
    if (STACK[0x268])
    {
      goto LABEL_31;
    }
  }

  v74 = STACK[0x250];
  if (STACK[0x250])
  {
    goto LABEL_32;
  }

  goto LABEL_4;
}

void gcl::tmesh::EstimateQuantizedNormals(uint64_t *a1, void *a2, unint64_t *a3, int a4)
{
  v6 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 2);
  v8 = *a2;
  v7 = a2[1];
  v9 = *a3;
  a3[1] = *a3;
  v106 = 0;
  v105 = 0;
  if (v6 << 32)
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * ((a3[2] - v9) >> 2);
    if (v10 < v6)
    {
      if (v6 <= 0x1555555555555555)
      {
        v11 = 0x5555555555555556 * ((a3[2] - v9) >> 2);
        if (v11 <= v6)
        {
          v11 = v6;
        }

        if (v10 >= 0xAAAAAAAAAAAAAAALL)
        {
          v12 = 0x1555555555555555;
        }

        else
        {
          v12 = v11;
        }

        if (v12 <= 0x1555555555555555)
        {
          operator new();
        }

        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v13 = v9 + 12 * v6;
    v14 = 12 * v6 - 12;
    if (v14 >= 0x84)
    {
      v15 = v14 / 0xC;
      if (v9 >= (&v105 | 0xC) || v9 + 12 * v15 + 12 <= &v105)
      {
        v16 = v15 + 1;
        v17 = v9;
        v18 = v16 & 0x3FFFFFFFFFFFFFF8;
        do
        {
          v17[4] = 0uLL;
          v17[5] = 0uLL;
          v17[2] = 0uLL;
          v17[3] = 0uLL;
          *v17 = 0uLL;
          v17[1] = 0uLL;
          v17 += 6;
          v18 -= 8;
        }

        while (v18);
        if (v16 == (v16 & 0x3FFFFFFFFFFFFFF8))
        {
LABEL_20:
          a3[1] = v13;
          if ((v6 & 0x8000000000000000) == 0)
          {
            operator new();
          }

          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v9 += 12 * (v16 & 0x3FFFFFFFFFFFFFF8);
      }
    }

    do
    {
      *v9 = 0;
      *(v9 + 8) = 0;
      v9 += 12;
    }

    while (v9 != v13);
    goto LABEL_20;
  }

  v19 = -1431655765 * ((v7 - v8) >> 2);
  if (v19 >= 1)
  {
    v20 = *a1;
    v21 = v19 & 0x7FFFFFFF;
    v22 = (*a2 + 8);
    v23 = *a3;
    do
    {
      v25 = *(v22 - 2);
      v26 = (v20 + 12 * v25);
      v27 = (v20 + 12 * *(v22 - 1));
      v28 = (v20 + 12 * *v22);
      v29 = *v26;
      v30 = v26[1];
      v31 = *v27 - v29;
      v32 = *v28 - v29;
      v33 = v27[1] - v30;
      v34 = v26[2];
      v35 = v27[2] - v34;
      v36 = v28[1] - v30;
      v37 = v28[2] - v34;
      v38 = v37 * v33 - v36 * v35;
      v39 = v32 * v35 - v37 * v31;
      v40 = v36 * v31 - v32 * v33;
      v41 = (v23 + 12 * v25);
      v42 = *v25;
      if (*v25)
      {
        v43 = 1 << (v42 - 1);
        v44 = (v43 + v38) >> v42;
        if (v38 < 0)
        {
          v44 = -((v43 - v38) >> v42);
        }

        if (v39 < 0)
        {
          v45 = -((v43 - v39) >> v42);
        }

        else
        {
          v45 = (v43 + v39) >> v42;
        }

        v46 = v45 + v41[1];
        v47 = (v43 - v40) >> v42;
        v48 = (v43 + v40) >> v42;
        if (v40 < 0)
        {
          v48 = -v47;
        }

        v49 = v48 + v41[2];
      }

      else
      {
        v46 = v39 + v41[1];
        v49 = v40 + v41[2];
        v44 = v38;
      }

      v50 = v44 + *v41;
      v51 = fmax(fmax(fabs(v50), fabs(v46)), fabs(v49)) + 1;
      if (v51 >> 30)
      {
        v52 = __clz(v51);
        v53 = 34 - v52;
        *v25 = v42 + 34 - v52;
        v54 = 1 << (33 - v52);
        v55 = (v54 - v50) >> (34 - v52);
        v56 = (v54 + v50) >> (34 - v52);
        if (v50 < 0)
        {
          v50 = -v55;
        }

        else
        {
          LODWORD(v50) = v56;
        }

        if (v46 < 0)
        {
          v46 = -((v54 - v46) >> v53);
        }

        else
        {
          v46 = (v54 + v46) >> v53;
        }

        v57 = (v54 - v49) >> v53;
        v58 = (v54 + v49) >> v53;
        if (v49 < 0)
        {
          v49 = -v57;
        }

        else
        {
          LODWORD(v49) = v58;
        }
      }

      *v41 = v50;
      v41[1] = v46;
      v41[2] = v49;
      v59 = *(v22 - 1);
      v60 = (v23 + 12 * v59);
      v61 = *v59;
      if (*v59)
      {
        v62 = 1 << (v61 - 1);
        if (v38 < 0)
        {
          v63 = -((v62 - v38) >> v61);
        }

        else
        {
          v63 = (v62 + v38) >> v61;
        }

        v64 = (v62 + v39) >> v61;
        if (v39 < 0)
        {
          v64 = -((v62 - v39) >> v61);
        }

        v65 = v64 + v60[1];
        v66 = (v62 + v40) >> v61;
        v67 = (v62 - v40) >> v61;
        if (v40 < 0)
        {
          v68 = -v67;
        }

        else
        {
          v68 = v66;
        }

        v69 = v68 + v60[2];
      }

      else
      {
        v65 = v39 + v60[1];
        v69 = v40 + v60[2];
        v63 = v38;
      }

      v70 = v63 + *v60;
      v71 = fmax(fmax(fabs(v70), fabs(v65)), fabs(v69)) + 1;
      if (v71 >> 30)
      {
        v72 = __clz(v71);
        v73 = 34 - v72;
        *v59 = v61 + 34 - v72;
        v74 = 1 << (33 - v72);
        v75 = (v74 + v70) >> (34 - v72);
        v76 = (v74 - v70) >> (34 - v72);
        if (v70 < 0)
        {
          v70 = -v76;
        }

        else
        {
          LODWORD(v70) = v75;
        }

        if (v65 < 0)
        {
          v65 = -((v74 - v65) >> v73);
        }

        else
        {
          v65 = (v74 + v65) >> v73;
        }

        v77 = (v74 + v69) >> v73;
        v78 = (v74 - v69) >> v73;
        if (v69 < 0)
        {
          v69 = -v78;
        }

        else
        {
          LODWORD(v69) = v77;
        }
      }

      *v60 = v70;
      v60[1] = v65;
      v60[2] = v69;
      v79 = *v22;
      v80 = (v23 + 12 * v79);
      v81 = *v79;
      if (*v79)
      {
        v82 = 1 << (v81 - 1);
        if (v38 < 0)
        {
          v38 = -((v82 - v38) >> v81);
        }

        else
        {
          v38 = (v82 + v38) >> v81;
        }

        if (v39 < 0)
        {
          v83 = -((v82 - v39) >> v81);
        }

        else
        {
          v83 = (v82 + v39) >> v81;
        }

        v84 = v83 + v80[1];
        v85 = (v82 + v40) >> v81;
        v86 = (v82 - v40) >> v81;
        if (v40 < 0)
        {
          v87 = -v86;
        }

        else
        {
          v87 = v85;
        }

        v24 = v87 + v80[2];
      }

      else
      {
        v84 = v39 + v80[1];
        v24 = v40 + v80[2];
      }

      v88 = v38 + *v80;
      v89 = fmax(fmax(fabs(v88), fabs(v84)), fabs(v24)) + 1;
      if (v89 >> 30)
      {
        v90 = __clz(v89);
        v91 = 34 - v90;
        *v79 = v81 + 34 - v90;
        v92 = 1 << (33 - v90);
        v93 = (v92 + v88) >> (34 - v90);
        v94 = (v92 - v88) >> (34 - v90);
        if (v88 < 0)
        {
          v88 = -v94;
        }

        else
        {
          LODWORD(v88) = v93;
        }

        if (v84 < 0)
        {
          v84 = -((v92 - v84) >> v91);
        }

        else
        {
          v84 = (v92 + v84) >> v91;
        }

        if (v24 < 0)
        {
          v24 = -((v92 - v24) >> v91);
        }

        else
        {
          v24 = (v92 + v24) >> v91;
        }
      }

      *v80 = v88;
      v80[1] = v84;
      v22 += 3;
      v80[2] = v24;
      --v21;
    }

    while (v21);
  }

  if (v6 >= 1)
  {
    v95 = v6 & 0x7FFFFFFF;
    v96 = (*a3 + 8);
    do
    {
      v100 = *v96;
      v101 = *(v96 - 2);
      v102 = vabs_s32(v101);
      if (v100 >= 0)
      {
        v103 = *v96;
      }

      else
      {
        v103 = -v100;
      }

      v104 = v102.u32[1] + v102.u32[0] + v103;
      if (v104)
      {
        v97 = a4 * v101.i32[0] / v104;
        v98 = a4 * v101.i32[1] / v104;
        v99 = v100 * a4 / v104;
      }

      else
      {
        LODWORD(v97) = 0;
        LODWORD(v98) = 0;
        LODWORD(v99) = a4;
      }

      *(v96 - 2) = v97;
      *(v96 - 1) = v98;
      *v96 = v99;
      v96 += 3;
      --v95;
    }

    while (v95);
  }
}

void gcl::tmesh::DecoderImpl::decodeResidual(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if ((a3 & 0x80000000) == 0)
    {
      operator new();
    }

    std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
  }
}

int32x4_t gcl::tmesh::ComputeGeneralizedParallelogramPrediction(int32x4_t *a1, int32x4_t *a2, int32x4_t *a3, int a4, int *a5, int *a6, int *a7, int *a8, int32x4_t *a9)
{
  v9 = a9;
  v10 = *a7;
  v11 = a7[1];
  v12 = *a5 - v10;
  v13 = a5[1] - v11;
  v14 = a7[2];
  v15 = a5[2] - v14;
  v16 = *a6 - v10;
  v17 = a6[1] - v11;
  v18 = a6[2] - v14;
  v19 = *a8 - v10;
  v20 = a8[1] - v11;
  v21 = a8[2] - v14;
  v22 = v12 * v12 + v13 * v13 + v15 * v15;
  v23 = v16 * v16 + v17 * v17 + v18 * v18;
  if (v22 >> 30)
  {
    v24 = 0;
  }

  else
  {
    v24 = v23 >> 30 == 0;
  }

  if (v24 && (v19 * v19 + v20 * v20 + v21 * v21) >> 30 == 0)
  {
    v38 = v16 * v12 + v17 * v13 + v18 * v15;
    v39 = v23 * v22 - v38 * v38;
    if (!v39)
    {
      if (a4 < 1)
      {
        return result;
      }

      if (a4 >= 8)
      {
        v44 = 0;
        if ((a9 - a1) >= 0x20 && (a9 - a2) >= 0x20 && (a9 - a3) >= 0x20)
        {
          v44 = a4 & 0x7FFFFFF8;
          v80 = a1 + 1;
          v81 = a9 + 1;
          v82 = a2 + 1;
          v83 = a3 + 1;
          v84 = v44;
          do
          {
            result = vsubq_s32(vaddq_s32(v82[-1], v80[-1]), v83[-1]);
            v85 = vsubq_s32(vaddq_s32(*v82, *v80), *v83);
            v80 += 2;
            v81[-1] = result;
            *v81 = v85;
            v81 += 2;
            v82 += 2;
            v83 += 2;
            v84 -= 8;
          }

          while (v84);
          if (v44 == a4)
          {
            return result;
          }
        }
      }

      else
      {
        v44 = 0;
      }

      v45 = a4 - v44;
      v46 = v44;
      v47 = &a9->i32[v44];
      v48 = &a3->i32[v44];
      v49 = &a2->i32[v46];
      v50 = &a1->i32[v46];
      do
      {
        v52 = *v50++;
        v51 = v52;
        v54 = *v49++;
        v53 = v54;
        v55 = *v48++;
        *v47++ = v53 + v51 - v55;
        --v45;
      }

      while (v45);
      return result;
    }

    v40 = v19 * v12 + v20 * v13 + v21 * v15;
    v41 = v19 * v16 + v20 * v17 + v21 * v18;
    if (v39 >= 0x80)
    {
      v63 = __clz(v39);
      v64 = 57 - v63;
      v65 = 1 << (56 - v63);
      v39 = (v65 + v39) >> v64;
      v66 = v40 * v23 - v41 * v38;
      if (v66 < 0)
      {
        v42 = -((v65 - v66) >> v64);
      }

      else
      {
        v42 = (v65 + v66) >> v64;
      }

      if (v42 >= 0x3FFFFFFFFFFFLL)
      {
        v42 = 0x3FFFFFFFFFFFLL;
      }

      if (v42 <= 0xFFFFC00000000001)
      {
        v42 = 0xFFFFC00000000001;
      }

      v67 = v41 * v22 - v40 * v38;
      if (v67 < 0)
      {
        v43 = -((v65 - v67) >> v64);
      }

      else
      {
        v43 = (v65 + v67) >> v64;
      }
    }

    else
    {
      v42 = v40 * v23 - v41 * v38;
      if (v42 >= 0x3FFFFFFFFFFFLL)
      {
        v42 = 0x3FFFFFFFFFFFLL;
      }

      if (v42 <= 0xFFFFC00000000001)
      {
        v42 = 0xFFFFC00000000001;
      }

      v43 = v41 * v22 - v40 * v38;
    }

    if (v43 >= 0x3FFFFFFFFFFFLL)
    {
      v43 = 0x3FFFFFFFFFFFLL;
    }

    v68 = 0xFFFFC00000000001;
    if (v43 > 0xFFFFC00000000001)
    {
      v68 = v43;
    }

    v69 = gcl::tmesh::approximateInverseLut[v39 - 1];
    if (v42 * v69 >= 0x3FFFFFFF)
    {
      v70 = 0x3FFFFFFFLL;
    }

    else
    {
      v70 = v42 * v69;
    }

    if (v70 <= -1073741823)
    {
      v70 = -1073741823;
    }

    v71 = v68 * v69;
    if (v71 >= 0x3FFFFFFF)
    {
      v71 = 0x3FFFFFFFLL;
    }

    if (v71 <= -1073741823)
    {
      v71 = -1073741823;
    }

    if (a4 >= 1)
    {
      v72 = a4;
      do
      {
        v74 = a1->i32[0];
        a1 = (a1 + 4);
        v75 = v70 * v74;
        v76 = a2->i32[0];
        a2 = (a2 + 4);
        v77 = v71 * v76 + v75;
        v78 = a3->i32[0];
        a3 = (a3 + 4);
        v79 = v77 + (0x10000 - (v71 + v70)) * v78;
        if (v79 < 0)
        {
          v73 = -((0x8000 - v79) >> 16);
        }

        else
        {
          v73 = (v79 + 0x8000) >> 16;
        }

        if (v73 >= 0x3FFFFFFF)
        {
          v73 = 0x3FFFFFFFLL;
        }

        if (v73 <= -1073741823)
        {
          LODWORD(v73) = -1073741823;
        }

        v9->i32[0] = v73;
        v9 = (v9 + 4);
        --v72;
      }

      while (v72);
    }
  }

  else
  {
    if (a4 < 1)
    {
      return result;
    }

    if (a4 < 8)
    {
      v26 = 0;
LABEL_11:
      v27 = a4 - v26;
      v28 = v26;
      v29 = &a9->i32[v26];
      v30 = &a3->i32[v26];
      v31 = &a2->i32[v28];
      v32 = &a1->i32[v28];
      do
      {
        v34 = *v32++;
        v33 = v34;
        v36 = *v31++;
        v35 = v36;
        v37 = *v30++;
        *v29++ = v35 + v33 - v37;
        --v27;
      }

      while (v27);
      return result;
    }

    v26 = 0;
    if ((a9 - a1) < 0x20)
    {
      goto LABEL_11;
    }

    if ((a9 - a2) < 0x20)
    {
      goto LABEL_11;
    }

    if ((a9 - a3) < 0x20)
    {
      goto LABEL_11;
    }

    v26 = a4 & 0x7FFFFFF8;
    v56 = a1 + 1;
    v57 = a9 + 1;
    v58 = a2 + 1;
    v59 = a3 + 1;
    v60 = v26;
    do
    {
      result = vsubq_s32(vaddq_s32(v58[-1], v56[-1]), v59[-1]);
      v62 = vsubq_s32(vaddq_s32(*v58, *v56), *v59);
      v56 += 2;
      v57[-1] = result;
      *v57 = v62;
      v57 += 2;
      v58 += 2;
      v59 += 2;
      v60 -= 8;
    }

    while (v60);
    if (v26 != a4)
    {
      goto LABEL_11;
    }
  }

  return result;
}

unint64_t gcl::tmesh::ComputeTexCoordinatesPrediction(unint64_t result, int *a2, _DWORD *a3, _DWORD *a4, int *a5, unsigned int a6, int *a7)
{
  v7 = a4[1];
  v8 = a3[1];
  v9 = a4[2];
  v10 = a3[2];
  v11 = (v7 - v8) * (v7 - v8) + (*a4 - *a3) * (*a4 - *a3) + (v9 - v10) * (v9 - v10);
  v12 = *a5;
  v13 = a5[1];
  v14 = a5[2];
  v15 = (v13 - v8) * (v13 - v8) + (v12 - *a3) * (v12 - *a3) + (v14 - v10) * (v14 - v10);
  v16 = (v13 - v7) * (v13 - v7) + (v12 - *a4) * (v12 - *a4) + (v14 - v9) * (v14 - v9);
  if (v11 >> 28)
  {
    v17 = 0;
  }

  else
  {
    v17 = v15 >> 28 == 0;
  }

  if (!v17 || v16 >> 28 != 0 || v11 == 0)
  {
    *a7 = (*a2 + *result) / 2;
    a7[1] = (a2[1] + *(result + 4)) / 2;
  }

  else
  {
    v20 = __clz(v11);
    v21 = 57 - v20;
    v22 = 1 << (56 - v20);
    v23 = (v22 + v11) >> v21;
    v24 = (v22 + v15) >> v21;
    v25 = (v22 + v16) >> v21;
    if (v11 >= 0x80)
    {
      v16 = v25;
      v15 = v24;
      v11 = v23;
    }

    v26 = gcl::tmesh::approximateInverseLut[v11 - 1];
    v27 = (v15 - v16) * v26;
    v28 = 1073676288;
    if (v27 < 1073676288)
    {
      v28 = v27;
    }

    v29 = v28 + 0x10000;
    v30 = v27 < -1073807360;
    v31 = -1073741824;
    if (!v30)
    {
      v31 = v29;
    }

    v32 = ((v15 * v26) << 18) - v31 * v31;
    v33 = 0xFFFFFFFFLL;
    if (v32 < 0xFFFFFFFFLL)
    {
      v33 = v32;
    }

    v34 = v33 & ~(v33 >> 63);
    v35 = *result;
    v36 = *(result + 4);
    v37 = *a2 - v35;
    v38 = a2[1] - v36;
    v39 = (32 - __clz(v34)) >> 1;
    result = v34 >> v39;
    if (v32 >= 2)
    {
      v40 = (result + (1 << v39)) >> 1;
    }

    else
    {
      v40 = v34;
    }

    v41 = v40 * *(&qword_1B33AECB0 + a6);
    v42 = v31 * v37 + v41 * v38;
    if (v42 >= 0)
    {
      v43 = (v42 + 0x10000) >> 17;
    }

    else
    {
      v43 = -((0x10000 - v42) >> 17);
    }

    v44 = v43 + v35;
    v45 = v31 * v38 - v41 * v37;
    if (v45 >= 0)
    {
      v46 = (v45 + 0x10000) >> 17;
    }

    else
    {
      v46 = -((0x10000 - v45) >> 17);
    }

    v47 = v46 + v36;
    if (v44 >= 0x3FFFFFFF)
    {
      v44 = 0x3FFFFFFFLL;
    }

    if (v44 <= -1073741823)
    {
      LODWORD(v44) = -1073741823;
    }

    if (v47 >= 0x3FFFFFFF)
    {
      v47 = 0x3FFFFFFFLL;
    }

    if (v47 <= -1073741823)
    {
      LODWORD(v47) = -1073741823;
    }

    *a7 = v44;
    a7[1] = v47;
  }

  return result;
}

int *gcl::tmesh::ComputeTexCoordinatesPrediction(int *result, int *a2, int *a3, _DWORD *a4, _DWORD *a5, int *a6, int *a7)
{
  v7 = a5[1];
  v8 = a4[1];
  v9 = a5[2];
  v10 = a4[2];
  v11 = (v7 - v8) * (v7 - v8) + (*a5 - *a4) * (*a5 - *a4) + (v9 - v10) * (v9 - v10);
  v12 = *a6;
  v13 = a6[1];
  v14 = a6[2];
  v15 = (v13 - v8) * (v13 - v8) + (v12 - *a4) * (v12 - *a4) + (v14 - v10) * (v14 - v10);
  v16 = (v13 - v7) * (v13 - v7) + (v12 - *a5) * (v12 - *a5) + (v14 - v9) * (v14 - v9);
  if (v11 >> 28)
  {
    v17 = 0;
  }

  else
  {
    v17 = v15 >> 28 == 0;
  }

  if (!v17 || v16 >> 28 != 0 || v11 == 0)
  {
    *a7 = (*a2 + *result) / 2;
    a7[1] = (a2[1] + result[1]) / 2;
  }

  else
  {
    v20 = __clz(v11);
    v21 = 57 - v20;
    v22 = 1 << (56 - v20);
    v23 = (v22 + v11) >> v21;
    v24 = (v22 + v15) >> v21;
    v25 = (v22 + v16) >> v21;
    if (v11 >= 0x80)
    {
      v16 = v25;
      v15 = v24;
      v11 = v23;
    }

    v26 = gcl::tmesh::approximateInverseLut[v11 - 1];
    v27 = (v15 - v16) * v26;
    v28 = 1073676288;
    if (v27 < 1073676288)
    {
      v28 = v27;
    }

    v29 = v28 + 0x10000;
    v30 = v27 < -1073807360;
    v31 = -1073741824;
    if (!v30)
    {
      v31 = v29;
    }

    v32 = ((v15 * v26) << 18) - v31 * v31;
    v33 = 0xFFFFFFFFLL;
    if (v32 < 0xFFFFFFFFLL)
    {
      v33 = v32;
    }

    v34 = v33 & ~(v33 >> 63);
    v35 = *result;
    v36 = result[1];
    v37 = *a2 - v35;
    v38 = a2[1] - v36;
    result = ((32 - __clz(v34)) >> 1);
    if (v32 >= 2)
    {
      v39 = ((v34 >> result) + (1 << result)) >> 1;
    }

    else
    {
      v39 = v34;
    }

    if ((v36 - a3[1]) * v37 < (v35 - *a3) * v38)
    {
      v39 = -v39;
    }

    v40 = v31 * v37 - v39 * v38;
    if (v40 >= 0)
    {
      v41 = (v40 + 0x10000) >> 17;
    }

    else
    {
      v41 = -((0x10000 - v40) >> 17);
    }

    v42 = v41 + v35;
    v43 = v31 * v38 + v39 * v37;
    if (v43 >= 0)
    {
      v44 = (v43 + 0x10000) >> 17;
    }

    else
    {
      v44 = -((0x10000 - v43) >> 17);
    }

    v45 = v44 + v36;
    if (v42 >= 0x3FFFFFFF)
    {
      v42 = 0x3FFFFFFFLL;
    }

    if (v42 <= -1073741823)
    {
      LODWORD(v42) = -1073741823;
    }

    if (v45 >= 0x3FFFFFFF)
    {
      v45 = 0x3FFFFFFFLL;
    }

    if (v45 <= -1073741823)
    {
      LODWORD(v45) = -1073741823;
    }

    *a7 = v42;
    a7[1] = v45;
  }

  return result;
}

double mc_io_r_mc_projection(uint64_t a1, uint64_t a2)
{
  if (!*a2)
  {
    goto LABEL_9;
  }

  v2 = *(a2 + 24);
  v3 = *(a2 + 32);
  v4 = v3 + 2;
  if (v3 + 2 > v2)
  {
    *a2 = 0;
    *a2 = 0;
    return result;
  }

  v5 = *(*(a2 + 8) + v3);
  *(a2 + 32) = v4;
  if (v5 || v4 > v2)
  {
LABEL_9:
    *a2 = 0;
    return result;
  }

  v7 = v4 + 2;
  if (v4 + 2 > v2)
  {
    *a2 = 0;
    a2 = a1;
LABEL_13:
    *a2 = 0;
    *(a1 + 8) = 0;
LABEL_14:
    *(a1 + 16) = 0;
    *(a1 + 24) = 0;
LABEL_15:
    result = 0.0;
    *(a1 + 32) = 0;
    return result;
  }

  v8 = *(a2 + 8);
  v9 = *(v8 + v4);
  *(a2 + 32) = v7;
  *a1 = v9;
  v10 = v4 + 10;
  if (v4 + 10 > v2)
  {
    goto LABEL_13;
  }

  v12 = *(v8 + v7);
  *(a2 + 32) = v10;
  *(a1 + 8) = v12;
  v13 = v4 + 18;
  if (v10 + 8 > v2)
  {
    *a2 = 0;
    goto LABEL_14;
  }

  v14 = *(*(a2 + 8) + v10);
  *(a2 + 32) = v13;
  *(a1 + 16) = v14;
  v15 = v10 + 16;
  if (v10 + 16 > v2)
  {
    *a2 = 0;
    *(a1 + 24) = 0;
    goto LABEL_15;
  }

  v16 = *(*(a2 + 8) + v13);
  *(a2 + 32) = v15;
  *(a1 + 24) = v16;
  if (v13 + 16 > v2)
  {
    *a2 = 0;
    goto LABEL_15;
  }

  result = *(*(a2 + 8) + v15);
  *(a2 + 32) = v13 + 16;
  *(a1 + 32) = result;
  return result;
}

double mc_io_r_uv_model(uint64_t a1, uint64_t a2)
{
  if (!*a2)
  {
    goto LABEL_5;
  }

  v3 = *(a2 + 32);
  v4 = v3 + 2;
  if ((v3 + 2) > *(a2 + 24))
  {
LABEL_3:
    *a2 = 0;
LABEL_5:
    *a2 = 0;
    return result;
  }

  v5 = *(*(a2 + 8) + v3);
  *(a2 + 32) = v4;
  if (v5)
  {
    goto LABEL_5;
  }

  result = 0.0;
  *(a1 + 144) = 0u;
  *(a1 + 160) = 0u;
  *(a1 + 112) = 0u;
  *(a1 + 128) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 96) = 0u;
  *(a1 + 48) = 0u;
  *(a1 + 64) = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 0u;
  *a1 = 0u;
  if (!*a2)
  {
LABEL_10:
    *a1 = 0;
    return result;
  }

  v8 = *(a2 + 24);
  v7 = *(a2 + 32);
  v9 = v7 + 2;
  if (v7 + 2 > v8)
  {
    *a2 = 0;
    goto LABEL_10;
  }

  v10 = *(a2 + 8);
  v11 = *(v10 + v7);
  *(a2 + 32) = v9;
  *a1 = v11;
  v12 = v7 + 4;
  if (v7 + 4 <= v8)
  {
    v14 = 0;
    v13 = *(v10 + v9);
    *(a2 + 32) = v12;
  }

  else
  {
    v13 = 0;
    *a2 = 0;
    v14 = 1;
  }

  *(a1 + 4) = v13;
  if (v11)
  {
    if (v11 != 1 || (v14 & 1) != 0)
    {
      goto LABEL_5;
    }

    v15 = *(a2 + 32);
    v16 = v15 + 2;
    if ((v15 + 2) > *(a2 + 24))
    {
      goto LABEL_3;
    }

    v17 = *(*(a2 + 8) + v15);
    *(a2 + 32) = v16;
    if (v17)
    {
      goto LABEL_5;
    }

    mc_read_mat4(a2, (a1 + 8));

    return mc_io_r_mc_projection(a1 + 136, a2);
  }

  return result;
}

char *mc_container_decode_la_data_chapter(uint64_t a1, unint64_t a2, void *a3)
{
  v33 = *MEMORY[0x1E69E9840];
  if (*(a1 + 16) <= a2)
  {
    return 0;
  }

  v3 = (*(a1 + 8) + 40 * a2);
  v4 = *v3;
  v5 = v3[4];
  if (v4 != 5 || v5 != 0)
  {
    return 0;
  }

  result = mc_container_get_chapter_data(a1, a2);
  if (result)
  {
    v9 = result;
    bzero(a3, 0x2F0uLL);
    if (*v9)
    {
      v11 = *(v9 + 3);
      v10 = *(v9 + 4);
      v12 = v10 + 1;
      if (v10 + 1 <= v11)
      {
        v17 = *(*(v9 + 1) + v10);
        *(v9 + 4) = v12;
        if (v17)
        {
          goto LABEL_34;
        }

        v18 = v12 + 8;
        if (v12 + 8 <= v11)
        {
          v19 = *(*(v9 + 1) + v12);
          *(v9 + 4) = v18;
          *a3 = v19;
          if ((v18 + 8) <= *(v9 + 3))
          {
            v13 = *(*(v9 + 1) + v18);
            *(v9 + 4) = v18 + 8;
LABEL_14:
            a3[1] = v13;
            v14 = 0;
            v15 = 0;
            if (*v9)
            {
              v16 = *(v9 + 4);
              if ((v16 + 8) <= *(v9 + 3))
              {
                v15 = *(*(v9 + 1) + v16);
                *(v9 + 4) = v16 + 8;
              }

              else
              {
                *v9 = 0;
              }
            }

            a3[2] = v15;
            if (*v9)
            {
              v20 = *(v9 + 4);
              if ((v20 + 8) <= *(v9 + 3))
              {
                v14 = *(*(v9 + 1) + v20);
                *(v9 + 4) = v20 + 8;
              }

              else
              {
                *v9 = 0;
              }
            }

            a3[3] = v14;
            if (*v9)
            {
              v22 = *(v9 + 3);
              v21 = *(v9 + 4);
              v23 = v21 + 4;
              if (v21 + 4 <= v22)
              {
                v24 = *(v9 + 1);
                v25 = *(v24 + v21);
                *(v9 + 4) = v23;
                v26 = v21 + 6;
                if (v26 <= v22)
                {
                  v27 = *(v24 + v23);
                  *(v9 + 4) = v26;
                  if (v27 == 180)
                  {
                    mc_read_tiny_big(v9, 180, v32);
                    v28 = 0;
                    v29 = v32[0];
                    *(a3 + 8) = v25 * v32[0];
                    do
                    {
                      v29 += v32[v28 + 1];
                      v32[v28 + 1] = v29;
                      *(a3 + v28 * 4 + 36) = v25 * v29;
                      ++v28;
                    }

                    while (v28 != 179);
                    v30 = *v9;
LABEL_35:
                    v31 = *(v9 + 2);
                    if (v31)
                    {
                      free(v31);
                    }

                    free(v9);
                    return v30;
                  }
                }

                else
                {
                  *v9 = 0;
                }
              }
            }

LABEL_34:
            v30 = 0;
            *v9 = 0;
            goto LABEL_35;
          }

          *v9 = 0;
LABEL_13:
          v13 = 0;
          goto LABEL_14;
        }
      }

      *v9 = 0;
    }

    *a3 = 0;
    goto LABEL_13;
  }

  return result;
}

void mc_scene_free(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = a1[1];
      if (v3)
      {
        v4 = v2 + 23;
        do
        {
          free(*(v4 - 5));
          free(*(v4 - 4));
          free(*(v4 - 2));
          v5 = *v4;
          v4 += 24;
          free(v5);
          --v3;
        }

        while (v3);
      }

      free(v2);
    }

    v6 = a1[2];
    if (v6)
    {
      v7 = a1[3];
      if (v7)
      {
        v8 = v6 + 23;
        do
        {
          free(*(v8 - 5));
          free(*(v8 - 4));
          free(*(v8 - 2));
          v9 = *v8;
          v8 += 24;
          free(v9);
          --v7;
        }

        while (v7);
      }

      free(v6);
    }

    v10 = a1[4];
    if (v10)
    {
      v11 = a1[5];
      if (v11)
      {
        v12 = v10 + 2;
        do
        {
          v13 = *v12;
          if (*v12)
          {
            v14 = v13[1];
            if (v14)
            {
              free(v14);
            }

            v15 = v13[3];
            if (v15)
            {
              free(v15);
            }

            free(v13);
          }

          v12 += 3;
          --v11;
        }

        while (v11);
      }

      free(v10);
    }
  }

  free(a1);
}

uint64_t mc_create_corner_table(int a1, int a2, char *a3, char *a4, int a5)
{
  v10 = malloc_type_calloc(1uLL, 0x18uLL, 0x100402FEFCB83uLL);
  v11 = a2;
  v12 = 4 * a2;
  v13 = (3 * a1);
  v14 = malloc_type_malloc(4 * (v11 + v13), 0x100004052888210uLL);
  *v10 = v14;
  v10[1] = &v14[v12];
  v10[2] = a3;
  memset(v14, 255, v12);
  if (a1)
  {
    if (v13 <= 1)
    {
      v15 = 1;
    }

    else
    {
      v15 = (3 * a1);
    }

    memset(a4, 255, 4 * v15);
    v16 = 0;
    v17 = *v10;
    v18 = v10[1];
    while (1)
    {
      v19 = 3 * v16;
      v20 = &a3[12 * v16];
      v21 = *v20;
      v22 = &v17[*(v20 + 1)];
      v23 = *v22;
      if (*v22 == -1)
      {
        goto LABEL_25;
      }

      v24 = v10[2];
      v25 = v23 % 3;
      v26 = v23 % 3 == 2 ? -2 : 1;
      if (v24[v26 + v23] != v21)
      {
        break;
      }

LABEL_19:
      *v22 = v18[v23];
      if (v25)
      {
        v29 = -1;
      }

      else
      {
        v29 = 2;
      }

      v30 = v29 + v23;
      if (!a5 && *&a4[4 * v30] != -1)
      {
LABEL_63:
        v56 = 0;
        goto LABEL_64;
      }

      v31 = v19 + 2;
      *&a4[4 * v19 + 8] = v30;
      v32 = &a4[4 * v30];
LABEL_26:
      *v32 = v31;
      v33 = *(v20 + 1);
      v34 = v19 + 1;
      v35 = &v17[*(v20 + 2)];
      v36 = *v35;
      if (*v35 == -1)
      {
        goto LABEL_43;
      }

      v37 = v10[2];
      v38 = v36 % 3;
      if (v36 % 3 == 2)
      {
        v39 = -2;
      }

      else
      {
        v39 = 1;
      }

      if (v37[v39 + v36] != v33)
      {
        while (1)
        {
          v40 = v36;
          v36 = v18[v36];
          if (v36 == -1)
          {
            break;
          }

          v38 = v36 % 3;
          if (v36 % 3 == 2)
          {
            v41 = -2;
          }

          else
          {
            v41 = 1;
          }

          if (v37[v41 + v36] == v33)
          {
            v35 = &v18[v40];
            goto LABEL_37;
          }
        }

LABEL_43:
        v18[v34] = v17[v33];
        v17[v33] = v34;
        goto LABEL_44;
      }

LABEL_37:
      *v35 = v18[v36];
      if (v38)
      {
        v42 = -1;
      }

      else
      {
        v42 = 2;
      }

      v43 = v42 + v36;
      if (!a5 && *&a4[4 * v43] != -1)
      {
        goto LABEL_63;
      }

      *&a4[4 * v19] = v43;
      *&a4[4 * v43] = v19;
LABEL_44:
      v44 = *(v20 + 2);
      v45 = v19 + 2;
      v46 = &v17[*v20];
      v47 = *v46;
      if (*v46 == -1)
      {
        goto LABEL_6;
      }

      v48 = v10[2];
      v49 = v47 % 3;
      if (v47 % 3 == 2)
      {
        v50 = -2;
      }

      else
      {
        v50 = 1;
      }

      if (v48[v50 + v47] != v44)
      {
        while (1)
        {
          v51 = v47;
          v47 = v18[v47];
          if (v47 == -1)
          {
            break;
          }

          v49 = v47 % 3;
          if (v47 % 3 == 2)
          {
            v52 = -2;
          }

          else
          {
            v52 = 1;
          }

          if (v48[v52 + v47] == v44)
          {
            v46 = &v18[v51];
            goto LABEL_55;
          }
        }

LABEL_6:
        v18[v45] = v17[v44];
        v17[v44] = v45;
        goto LABEL_7;
      }

LABEL_55:
      *v46 = v18[v47];
      if (v49)
      {
        v53 = -1;
      }

      else
      {
        v53 = 2;
      }

      v54 = v53 + v47;
      if (!a5 && *&a4[4 * v54] != -1)
      {
        goto LABEL_63;
      }

      v55 = v45 - 1;
      *&a4[4 * v55] = v54;
      *&a4[4 * v54] = v55;
LABEL_7:
      if (++v16 == a1)
      {
        goto LABEL_62;
      }
    }

    while (1)
    {
      v27 = v23;
      v23 = v18[v23];
      if (v23 == -1)
      {
        break;
      }

      v25 = v23 % 3;
      if (v23 % 3 == 2)
      {
        v28 = -2;
      }

      else
      {
        v28 = 1;
      }

      if (v24[v28 + v23] == v21)
      {
        v22 = &v18[v27];
        goto LABEL_19;
      }
    }

LABEL_25:
    v32 = &v17[v21];
    v18[3 * v16] = *v32;
    v31 = 3 * v16;
    goto LABEL_26;
  }

  v17 = *v10;
LABEL_62:
  v56 = 1;
LABEL_64:
  free(v17);
  free(v10);
  return v56;
}

uint64_t mc_encode_decode_predictive(unsigned int a1, unsigned int a2, char *a3, _DWORD *a4, unsigned int a5, _DWORD *a6)
{
  v84 = *MEMORY[0x1E69E9840];
  if (a1)
  {
    v11 = malloc_type_calloc(1uLL, 0x38uLL, 0x1010040D707D299uLL);
    *(v11 + 4) = malloc_type_malloc(12 * a1, 0x100004052888210uLL);
    *(v11 + 5) = malloc_type_malloc(12 * a1, 0x100004052888210uLL);
    v12 = malloc_type_malloc(a1, 0x100004077774924uLL);
    *(v11 + 3) = v12;
    v13 = *(v11 + 5);
    v11[4] = a1;
    *(v11 + 6) = v13;
    bzero(v12, a1);
    v11[5] = 0;
    if (!mc_create_corner_table(a1, a2, a3, *(v11 + 4), 1))
    {
      free(*(v11 + 3));
      free(*(v11 + 4));
      free(*(v11 + 5));
      free(v11);
      return 0;
    }

    if (a4 == a6)
    {
      v15 = malloc_type_malloc(4 * a5 * a2, 0x100004052888210uLL);
      memcpy(v15, a6, 4 * a5 * a2);
      v80 = v15;
      a6 = v15;
    }

    else
    {
      v80 = 0;
    }

    v16 = a2;
    v17 = malloc_type_calloc(a2, 1uLL, 0x100004077774924uLL);
    __n = 4 * a5;
LABEL_9:
    v18 = a6;
    while (1)
    {
      v20 = *(v11 + 5);
      v19 = *(v11 + 6);
      if (v19 == v20)
      {
        v21 = v11[4];
        v22 = v11[5];
        if (v22 < v21)
        {
          v23 = *(v11 + 3);
          while (*(v23 + v22))
          {
            v11[5] = ++v22;
            if (v21 <= v22)
            {
              goto LABEL_17;
            }
          }

          *(v23 + v22) = 1;
          v20 = *(v11 + 5);
          v24 = *(v11 + 6);
          *v24 = 3 * v11[5];
          v19 = v24 + 1;
          *(v11 + 6) = v19;
        }
      }

LABEL_17:
      if (v19 == v20)
      {
        break;
      }

      v25 = *(v19 - 1);
      *(v11 + 6) = v19 - 1;
      v11[2] = v25;
      v26 = v25 / 3;
      *v11 = v25 / 3;
      v27 = *(v11 + 4);
      v28 = *(v27 + 4 * v25);
      v11[3] = v28;
      if ((v28 & 0x80000000) == 0 && !*(*(v11 + 3) + v28 / 3uLL))
      {
        v11[3] = -1;
      }

      v11[1] = -1;
      v29 = 3 * v26;
      v30 = *(v27 + 4 * v29);
      if ((v30 & 0x80000000) == 0)
      {
        v31 = *(v11 + 3);
        v32 = v30 / 3uLL;
        if (!*(v31 + v32))
        {
          *(v31 + v32) = 1;
          v33 = *(v11 + 6);
          *v33 = v30;
          *(v11 + 6) = v33 + 1;
          v27 = *(v11 + 4);
          v29 = 3 * *v11;
        }
      }

      v34 = *(v27 + 4 * v29 + 4);
      if ((v34 & 0x80000000) == 0)
      {
        v35 = *(v11 + 3);
        v36 = v34 / 3uLL;
        if (!*(v35 + v36))
        {
          *(v35 + v36) = 1;
          v37 = *(v11 + 6);
          *v37 = v34;
          *(v11 + 6) = v37 + 1;
          v27 = *(v11 + 4);
          v29 = 3 * *v11;
        }
      }

      v38 = *(v27 + 4 * v29 + 8);
      if ((v38 & 0x80000000) == 0)
      {
        v39 = *(v11 + 3);
        v40 = v38 / 3uLL;
        if (!*(v39 + v40))
        {
          *(v39 + v40) = 1;
          v41 = *(v11 + 6);
          *v41 = v38;
          *(v11 + 6) = v41 + 1;
        }
      }

      v42 = v11[2];
      v43 = *&a3[4 * v42];
      if (!v17[v43])
      {
        v17[v43] = 1;
        v44 = v11[3];
        if (v44 == -1)
        {
          memcpy(&a4[(v43 * a5)], &v18[4 * (v43 * a5)], __n);
          v18 = a6;
        }

        else
        {
          v45 = 0;
          v46 = *&a3[4 * v44];
          v47 = 3 * (v44 / 3);
          v48 = *&a3[4 * v47 + 4 * ((v44 + 1) % 3)];
          v49 = *&a3[4 * v47 + 4 * ((v44 + 2) % 3)];
          do
          {
            v83[v45] = a4[(v49 * a5) + v45] + a4[(v48 * a5) + v45] - a4[(v46 * a5) + v45];
            ++v45;
          }

          while (a5 != v45);
          v50 = 0;
          v51 = (v43 * a5);
          v52 = &a4[v51];
          v53 = &v18[v51 * 4];
          do
          {
            *&v52[4 * v50] = v83[v50] + *&v53[4 * v50];
            ++v50;
          }

          while (a5 != v50);
        }
      }

      v54 = 3 * (v42 / 3) + (v42 + 1) % 3;
      v55 = *&a3[4 * v54];
      if (!v17[v55])
      {
        v17[v55] = 1;
        v56 = v11[3];
        if (v56 == -1)
        {
          memcpy(&a4[(v55 * a5)], &v18[4 * (v55 * a5)], __n);
          v18 = a6;
        }

        else
        {
          v57 = 0;
          v58 = *&a3[4 * v56];
          v59 = 3 * (v56 / 3);
          v60 = *&a3[4 * v59 + 4 * ((v56 + 1) % 3)];
          v61 = *&a3[4 * v59 + 4 * ((v56 + 2) % 3)];
          do
          {
            v83[v57] = a4[(v61 * a5) + v57] + a4[(v60 * a5) + v57] - a4[(v58 * a5) + v57];
            ++v57;
          }

          while (a5 != v57);
          v62 = 0;
          v63 = (v55 * a5);
          v64 = &a4[v63];
          v65 = &v18[v63 * 4];
          do
          {
            *&v64[4 * v62] = v83[v62] + *&v65[4 * v62];
            ++v62;
          }

          while (a5 != v62);
        }
      }

      v66 = *&a3[12 * (v54 / 3) + 4 * ((v54 + 1) % 3)];
      if (!v17[v66])
      {
        v17[v66] = 1;
        v67 = v11[3];
        if (v67 == -1)
        {
          memcpy(&a4[(v66 * a5)], &v18[4 * (v66 * a5)], __n);
          goto LABEL_9;
        }

        v68 = 0;
        v69 = *&a3[4 * v67];
        v70 = 3 * (v67 / 3);
        v71 = *&a3[4 * v70 + 4 * ((v67 + 1) % 3)];
        v72 = *&a3[4 * v70 + 4 * ((v67 + 2) % 3)];
        do
        {
          v83[v68] = a4[(v72 * a5) + v68] + a4[(v71 * a5) + v68] - a4[(v69 * a5) + v68];
          ++v68;
        }

        while (a5 != v68);
        v73 = 0;
        v74 = (v66 * a5);
        v75 = &a4[v74];
        v76 = &v18[v74 * 4];
        do
        {
          *&v75[4 * v73] = v83[v73] + *&v76[4 * v73];
          ++v73;
        }

        while (a5 != v73);
      }
    }

    if (a2)
    {
      v77 = 0;
      v78 = v17;
      do
      {
        if (!*v78++)
        {
          memcpy(&a4[v77], &v18[v77 * 4], __n);
          v18 = a6;
        }

        v77 += a5;
        --v16;
      }

      while (v16);
    }

    free(*(v11 + 3));
    free(*(v11 + 4));
    free(*(v11 + 5));
    free(v11);
    free(v17);
    free(v80);
  }

  return 1;
}

uint64_t mc_read_chunk_header(uint64_t result, uint64_t a2)
{
  *(a2 + 8) = 0;
  if (!*result)
  {
    goto LABEL_10;
  }

  v3 = *(result + 24);
  v2 = *(result + 32);
  v4 = v2 + 4;
  if (v2 + 4 > v3)
  {
    *result = 0;
    *result = 0;
    return result;
  }

  v5 = *(result + 8);
  v6 = *(v5 + v2);
  *(result + 32) = v4;
  v7 = v2 + 6;
  if (v7 > v3 || ((v8 = *(v5 + v4), *(result + 32) = v7, v6 == 1263421507) ? (v9 = v8 >= 2) : (v9 = 1), v9))
  {
LABEL_10:
    *result = 0;
    return result;
  }

  v11 = *(result + 24);
  v10 = *(result + 32);
  v12 = v10 + 4;
  if (v10 + 4 > v11)
  {
    *result = 0;
    result = a2;
LABEL_14:
    *result = 0;
    *(a2 + 4) = 0;
    *(a2 + 8) = 0;
    return result;
  }

  v13 = *(result + 8);
  v14 = *(v13 + v10);
  *(result + 32) = v12;
  *a2 = v14;
  v15 = v10 + 6;
  if (v10 + 6 > v11)
  {
    goto LABEL_14;
  }

  v16 = *(v13 + v12);
  *(result + 32) = v15;
  *(a2 + 4) = v16;
  v17 = v10 + 8;
  if ((v10 + 8) <= *(result + 24))
  {
    v18 = *(*(result + 8) + v15);
    *(result + 32) = v17;
    *(a2 + 6) = v18;
    v19 = v10 + 16;
    if ((v10 + 16) <= *(result + 24))
    {
      v20 = *(*(result + 8) + v17);
      *(result + 32) = v19;
      *(a2 + 8) = v20;
    }

    else
    {
      *result = 0;
      *(a2 + 8) = 0;
    }
  }

  else
  {
    *result = 0;
    *(a2 + 6) = 0;
    *(a2 + 8) = 0;
  }

  return result;
}

uint64_t mc_mesh_decode(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v1043 = *MEMORY[0x1E69E9840];
  if (a3)
  {
    v3 = a3;
    v6 = 1;
    v7 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
    v8 = v7;
    *v7 = 1;
    *(v7 + 1) = a1;
    *(v7 + 3) = a2;
    if (a2)
    {
      v6 = a1 != 0;
      *v7 = v6;
    }

    v1032 = 0u;
    v1033 = 0u;
    v1033.f64[0] = *(v7 + 4);
    if (*&v1033.f64[0] == a2)
    {
      LODWORD(v1032.f64[0]) = -1;
      v9 = *&a2;
      if (!v6)
      {
        goto LABEL_17;
      }
    }

    else
    {
      mc_read_chunk_header(v7, &v1032);
      a2 = *(v8 + 4);
      v9 = v1033.f64[0];
      v6 = *v8;
      if (!*v8)
      {
        goto LABEL_17;
      }
    }

    if (*(v8 + 3) >= *&v9)
    {
      *(v8 + 4) = v9;
      a2 = *&v9;
    }

    if (!v6 || LODWORD(v1032.f64[0]))
    {
LABEL_17:
      v10 = 0;
      *v8 = 0;
      v16 = *(v8 + 2);
      if (!v16)
      {
        goto LABEL_19;
      }

      goto LABEL_18;
    }

    v1032 = 0u;
    v1033 = a2;
    if (a2 == *(v8 + 3))
    {
      LODWORD(v1032.f64[0]) = -1;
    }

    else
    {
      mc_read_chunk_header(v8, &v1032);
      if (!LODWORD(v1032.f64[0]) && !WORD2(v1032.f64[0]))
      {
        if (!*v8)
        {
          goto LABEL_16;
        }

        v18 = *(v8 + 4);
        if ((v18 + 8) <= *(v8 + 3))
        {
          v19 = *(*(v8 + 1) + v18);
          *(v8 + 4) = v18 + 8;
        }

        else
        {
          v19 = 0;
          *v8 = 0;
        }

        *v3 = v19;
        mc_read_mat4(v8, (v3 + 8));
        if (!*v8)
        {
          goto LABEL_16;
        }

        v746 = *(v8 + 3);
        v745 = *(v8 + 4);
        v747 = v745 + 4;
        if (v745 + 4 <= v746)
        {
          v748 = *(v8 + 1);
          v749 = *(v748 + v745);
          *(v8 + 4) = v747;
          v750 = v745 + 8;
          if (v750 <= v746)
          {
            v751 = *(v748 + v747);
            v752 = *&v1032.f64[1] + v18;
            if (*(v8 + 3) < (*&v1032.f64[1] + v18))
            {
              v752 = v750;
            }

            *(v8 + 4) = v752;
            if (!*(v3 + 144) && !*(v3 + 136))
            {
              *(v3 + 136) = v749;
              v753 = malloc_type_malloc(12 * v749, 0x10000403E1C8BA9uLL);
              *(v3 + 144) = v753;
              if (v753)
              {
                if (!*(v3 + 152))
                {
                  v754 = *(v3 + 136);
                  if (v754)
                  {
                    v755 = malloc_type_malloc(12 * v754, 0x10000403E1C8BA9uLL);
                    *(v3 + 152) = v755;
                    if (v755)
                    {
                      if (!*(v3 + 168) && !*(v3 + 160))
                      {
                        if (!v751)
                        {
                          goto LABEL_16;
                        }

                        v756 = malloc_type_realloc(0, 16 * v751, 0xC823ECAuLL);
                        if (v756)
                        {
                          v757 = v756;
                          bzero(v756, 16 * v751);
                          *(v3 + 168) = v757;
                          *(v3 + 160) = v751;
                          goto LABEL_16;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    *v8 = 0;
LABEL_16:
    v986 = 0;
    v988 = 0;
    v1020 = 0;
    v987 = 0;
    v1024 = 0;
    v11 = 0.0;
    v12 = 0uLL;
    *&v13 = 0.01;
    v14 = 1.0;
    v15 = 1.0;
    v999 = v8;
    v1009 = v3;
    while (1)
    {
      v1032 = v12;
      v1033 = v12;
      v24 = *(v8 + 3);
      v23 = *(v8 + 4);
      v1033.f64[0] = v23;
      if (*&v23 == v24)
      {
        LODWORD(v1032.f64[0]) = -1;
        v25 = v23;
        v26 = *v8;
        if (!*v8)
        {
          goto LABEL_1030;
        }
      }

      else
      {
        mc_read_chunk_header(v8, &v1032);
        v12 = 0uLL;
        v23 = *(v8 + 4);
        v25 = v1033.f64[0];
        v26 = *v8;
        if (!*v8)
        {
          goto LABEL_1030;
        }
      }

      if (*(v8 + 3) >= *&v25)
      {
        *(v8 + 4) = v25;
        v23 = v25;
      }

      if (!v26 || (LODWORD(v1032.f64[0]) + 1) < 2)
      {
        break;
      }

      if (SLODWORD(v1032.f64[0]) <= 5)
      {
        if (SLODWORD(v1032.f64[0]) <= 2)
        {
          if (LODWORD(v1032.f64[0]) == 1)
          {
            v1032 = v12;
            v1033.f64[1] = v12.f64[1];
            v1033.f64[0] = v23;
            if (*&v23 == *(v8 + 3) || (mc_read_chunk_header(v8, &v1032), v12 = 0uLL, LODWORD(v1032.f64[0]) != 1) || WORD2(v1032.f64[0]))
            {
              *v8 = 0;
            }

            else if (*v8)
            {
              v53 = *(v8 + 4);
              if ((v53 + 4) <= *(v8 + 3))
              {
                v155 = *(*(v8 + 1) + v53);
                *(v8 + 4) = v53 + 4;
                if (v155 != *(v3 + 160))
                {
                  goto LABEL_280;
                }

                if (v155)
                {
                  v156 = 0;
                  v157 = 0;
                  do
                  {
                    v159 = *(v3 + 168) + v156;
                    v158 = *v8;
                    if (*v8)
                    {
                      v160 = *(v8 + 4);
                      if ((v160 + 12) > *(v8 + 3))
                      {
                        goto LABEL_256;
                      }

                      v161 = (*(v8 + 1) + v160);
                      v162 = *v161;
                      *(v159 + 8) = *(v161 + 2);
                      *v159 = v162;
                      v163 = *(v8 + 4);
                      v164 = v163 + 12;
                      *(v8 + 4) = v163 + 12;
                      if (*v8)
                      {
                        v165 = v163 + 14;
                        if (v165 > *(v8 + 3))
                        {
LABEL_256:
                          v158 = 0;
                          *v8 = 0;
                          goto LABEL_257;
                        }

                        v158 = *(*(v8 + 1) + v164);
                        *(v8 + 4) = v165;
                      }

                      else
                      {
                        v158 = 0;
                      }
                    }

LABEL_257:
                    *(v159 + 12) = v158;
                    ++v157;
                    v156 += 16;
                  }

                  while (v157 < *(v3 + 160));
                  if (*v8)
                  {
                    goto LABEL_357;
                  }
                }

                else
                {
LABEL_357:
                  v264 = *&v1032.f64[1] + v53;
                  if (*(v8 + 3) >= v264)
                  {
                    *(v8 + 4) = v264;
                  }
                }
              }

              else
              {
                *v8 = 0;
              }
            }
          }

          else
          {
            if (LODWORD(v1032.f64[0]) != 2)
            {
              goto LABEL_96;
            }

            v1032 = v12;
            v1033 = v12;
            if (*&v23 == *(v8 + 3) || (mc_read_chunk_header(v8, &v1032), v12 = 0uLL, LODWORD(v1032.f64[0]) != 2) || WORD2(v1032.f64[0]))
            {
              *v8 = 0;
            }

            else if (*v8)
            {
              v54 = *(v8 + 4);
              v55 = v54 + 4;
              if ((v54 + 4) <= *(v8 + 3))
              {
                v166 = *(*(v8 + 1) + v54);
                *(v8 + 4) = v55;
                if (*(v3 + 136) != v166)
                {
                  goto LABEL_280;
                }

                if (!v166)
                {
                  goto LABEL_360;
                }

                v167 = 0;
                for (i = 0; i < v166; ++i)
                {
                  if (*v8)
                  {
                    if ((v55 + 12) <= *(v8 + 3))
                    {
                      v169 = *(v3 + 144) + v167;
                      v170 = *(v8 + 1) + v55;
                      v171 = *v170;
                      *(v169 + 8) = *(v170 + 8);
                      *v169 = v171;
                      v55 = *(v8 + 4) + 12;
                      *(v8 + 4) = v55;
                      v166 = *(v3 + 136);
                    }

                    else
                    {
                      *v8 = 0;
                    }
                  }

                  v167 += 12;
                }

                if (*v8)
                {
LABEL_360:
                  v265 = *&v1032.f64[1] + v54;
                  if (*(v8 + 3) >= v265)
                  {
                    *(v8 + 4) = v265;
                  }
                }
              }

              else
              {
                *v8 = 0;
              }
            }
          }
        }

        else if (LODWORD(v1032.f64[0]) == 3)
        {
          v1032 = v12;
          v1033 = v12;
          if (*&v23 == *(v8 + 3) || (mc_read_chunk_header(v8, &v1032), v12 = 0uLL, LODWORD(v1032.f64[0]) != 3) || WORD2(v1032.f64[0]))
          {
            *v8 = 0;
          }

          else if (*v8)
          {
            v71 = *(v8 + 4);
            v72 = v71 + 4;
            if ((v71 + 4) <= *(v8 + 3))
            {
              v172 = *(*(v8 + 1) + v71);
              *(v8 + 4) = v72;
              if (*(v3 + 136) == v172)
              {
                if (!v172)
                {
                  goto LABEL_379;
                }

                v173 = 0;
                for (j = 0; j < v172; ++j)
                {
                  if (*v8)
                  {
                    if ((v72 + 12) <= *(v8 + 3))
                    {
                      v175 = *(v3 + 152) + v173;
                      v176 = *(v8 + 1) + v72;
                      v177 = *v176;
                      *(v175 + 8) = *(v176 + 8);
                      *v175 = v177;
                      v72 = *(v8 + 4) + 12;
                      *(v8 + 4) = v72;
                      v172 = *(v3 + 136);
                    }

                    else
                    {
                      *v8 = 0;
                    }
                  }

                  v173 += 12;
                }

                if (*v8)
                {
LABEL_379:
                  v275 = *&v1032.f64[1] + v71;
                  if (*(v8 + 3) >= v275)
                  {
                    *(v8 + 4) = v275;
                  }
                }
              }

              else
              {
LABEL_280:
                *v8 = 0;
              }
            }

            else
            {
              *v8 = 0;
            }
          }
        }

        else
        {
          if (LODWORD(v1032.f64[0]) == 4)
          {
            v1032 = v12;
            v1033.f64[1] = v12.f64[1];
            v1033.f64[0] = v23;
            if (*&v23 == *(v8 + 3))
            {
              v27 = 0;
              v28 = 0;
              LODWORD(v1032.f64[0]) = -1;
              goto LABEL_215;
            }

            mc_read_chunk_header(v8, &v1032);
            v27 = 0;
            v56 = *(v8 + 4);
            v1033.f64[1] = v56;
            if (LODWORD(v1032.f64[0]) != 4)
            {
              v28 = 0;
              goto LABEL_215;
            }

            v28 = 0;
            if (WORD2(v1032.f64[0]) > 1u)
            {
              goto LABEL_215;
            }

            if (!*v8)
            {
              v27 = 0;
              v28 = 0;
              goto LABEL_216;
            }

            v57 = *&v56 + 4;
            v58 = *(v8 + 3);
            if (*&v56 + 4 > v58 || (v59 = *(v8 + 1), v60 = *(v59 + *&v56), *(v8 + 4) = v57, v61 = *&v56 + 8, *&v56 + 8 > v58) || (v62 = *(v59 + v57), *(v8 + 4) = v61, v63 = *&v56 + 16, (*&v56 + 16) > *(v8 + 3)) || (v64 = *(*(v8 + 1) + v61), *(v8 + 4) = v63, (*&v56 + 24) > *(v8 + 3)))
            {
              v27 = 0;
              v28 = 0;
              goto LABEL_215;
            }

            v305 = v8;
            v306 = *(*(v8 + 1) + v63);
            *(v305 + 4) = *&v56 + 24;
            v27 = malloc_type_malloc(v64, 0x34909A3BuLL);
            v28 = malloc_type_malloc(v306, 0x99268BCuLL);
            v307 = *v305;
            if (*v305)
            {
              v308 = *(v305 + 4);
              if (v308 + v64 > *(v305 + 3))
              {
                goto LABEL_421;
              }

              memcpy(v27, (*(v305 + 1) + v308), v64);
              v309 = *(v305 + 4) + v64;
              *(v305 + 4) = v309;
              if (*v305)
              {
                if (v309 + v306 <= *(v305 + 3))
                {
                  memcpy(v28, (*(v305 + 1) + v309), v306);
                  *(v305 + 4) += v306;
                  v307 = *v305;
                  if (*v305 && *(v305 + 3) >= *&v1032.f64[1] + *&v56)
                  {
                    *(v999 + 32) = *&v1032.f64[1] + *&v56;
                  }
                }

                else
                {
LABEL_421:
                  v307 = 0;
                  *v305 = 0;
                }
              }

              else
              {
                v307 = 0;
              }
            }

            v414 = *(v3 + 160);
            if (v414 && v414 != v60)
            {
              v8 = v999;
              *v999 = 0;
              v415 = *(v3 + 136);
              if (!v415 || v415 == v62)
              {
                goto LABEL_216;
              }

LABEL_215:
              *v8 = 0;
LABEL_216:
              free(v27);
              v22 = v28;
              goto LABEL_29;
            }

            v416 = *(v3 + 136);
            if (v416 && v416 != v62)
            {
              goto LABEL_534;
            }

            if (!v307)
            {
              v8 = v999;
              goto LABEL_216;
            }

            if (v414 != v60 || v416 != v62)
            {
LABEL_534:
              v8 = v999;
              goto LABEL_215;
            }

            v997 = malloc_type_calloc(3 * v60, 4uLL, 0x100004052888210uLL);
            v417 = malloc_type_malloc(4 * v60, 0x100004052888210uLL);
            v1006 = malloc_type_malloc(4 * v62, 0x100004052888210uLL);
            memset(v1006, 255, 4 * v62);
            v418 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
            v419 = v418;
            *v418 = 1;
            *(v418 + 1) = v28;
            *(v418 + 3) = v306;
            if (v306)
            {
              *v418 = v28 != 0;
            }

            v420 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
            *v420 = 1;
            v420[1] = v27;
            v420[3] = v64;
            if (v64)
            {
              *v420 = v27 != 0;
            }

            v1015 = v420;
            v991 = v417;
            if (!*v419)
            {
              v422 = 0;
              goto LABEL_613;
            }

            v421 = v419[4];
            if ((v421 + 4) > v419[3])
            {
              v422 = 0;
              *v419 = 0;
              goto LABEL_613;
            }

            v422 = *(v419[1] + v421);
            v419[4] = v421 + 4;
            if ((v422 & 0x80000000) == 0)
            {
LABEL_613:
              v493 = malloc_type_malloc(4 * (3 * v422), 0x100004052888210uLL);
              v494 = malloc_type_malloc(4 * (3 * v422), 0x100004052888210uLL);
              memset(v494, 255, 12 * v422);
              memset(v493, 255, 12 * v422);
              v495 = v419[3];
              v496 = v419[4];
              v497 = v495 - v496;
              if (v495 - v496 >= 0x10)
              {
                while (*v419)
                {
                  v501 = v496 + 4;
                  if (v496 + 4 > v495)
                  {
                    goto LABEL_616;
                  }

                  v502 = *(v419[1] + v496);
                  v419[4] = v501;
                  v503 = v496 + 8;
                  if (v496 + 8 > v495)
                  {
                    goto LABEL_616;
                  }

                  v504 = *(v419[1] + v496 + 4);
                  v419[4] = v503;
                  if ((v502 & 0x80000000) == 0)
                  {
                    *&v494[4 * v502] = v504;
                  }

                  if ((v504 & 0x80000000) == 0)
                  {
                    *&v494[4 * v504] = v502;
                  }

                  v496 = v501 + 4;
                  v497 -= 8;
                  if (v497 <= 0xF)
                  {
                    goto LABEL_614;
                  }
                }
              }

              else
              {
LABEL_614:
                if (*v419)
                {
                  v498 = v496 + 4;
                  if (v496 + 4 <= v495)
                  {
                    v499 = *(v419[1] + v496);
                    v419[4] = v498;
                    if (v496 + 8 <= v495)
                    {
                      v500 = *(v419[1] + v498);
                      v419[4] = v496 + 8;
                    }

                    else
                    {
                      v500 = 0;
                      *v419 = 0;
                    }
                  }

                  else
                  {
LABEL_616:
                    v499 = 0;
                    v500 = 0;
                    *v419 = 0;
                  }

LABEL_656:
                  v629 = 1;
                  if ((v499 & 0x80000000) == 0)
                  {
                    v985 = v500;
                    if ((v500 & 0x80000000) == 0)
                    {
                      v977 = v419;
                      v981 = malloc_type_calloc(v422, 4uLL, 0x100004052888210uLL);
                      v669 = malloc_type_malloc(3 * v422, 0x100004077774924uLL);
                      v670 = v669;
                      LODWORD(v671) = 0;
                      if (v422 && !v985)
                      {
                        *v669 = 80;
                        LODWORD(v671) = 1;
                      }

                      if (v671 < v422)
                      {
                        v672 = 0;
                        v673 = 0;
                        v674 = v671;
                        v675 = v1015;
                        v676 = v669;
                        while (1)
                        {
                          if (!*v675)
                          {
                            goto LABEL_664;
                          }

                          v677 = v675[4];
                          if ((v677 + 1) > v675[3])
                          {
                            break;
                          }

                          v678 = *(v675[1] + v677);
                          v675[4] = v677 + 1;
                          v671 = v674 + 1;
                          v676[v674] = v678;
                          if (v678 != 69)
                          {
                            if (v678 == 83 && *&v494[12 * v674 + 4 * ((3 * v674 + 2) % 3)] == -1)
                            {
                              ++v672;
                            }

                            goto LABEL_665;
                          }

                          if (v672 < 1)
                          {
                            ++v673;
                            if (v671 < v422)
                            {
                              if (v673 >= v985)
                              {
                                v676 = v669;
                                v669[v671] = 80;
                                LODWORD(v671) = v674 + 2;
                                v675 = v1015;
                                goto LABEL_665;
                              }

                              v981[v673] = v671;
                            }

                            v675 = v1015;
                            v676 = v669;
                          }

                          else
                          {
                            --v672;
                          }

LABEL_665:
                          v674 = v671;
                          if (v671 >= v422)
                          {
                            goto LABEL_682;
                          }
                        }

                        *v675 = 0;
LABEL_664:
                        LODWORD(v671) = v674 + 1;
                        v676[v674] = 0;
                        goto LABEL_665;
                      }

                      v673 = 0;
LABEL_682:
                      LODWORD(v682) = v671 - 1;
                      if (v671 < 1)
                      {
                        v683 = 0;
                      }

                      else
                      {
                        v683 = malloc_type_calloc((3 * v671), 4uLL, 0x100004052888210uLL);
                      }

                      v684 = v499 - 1;
                      if (v673 >= 1)
                      {
                        LODWORD(v685) = 0;
                        v686 = v985;
                        v687 = v981;
                        v688 = v670;
                        while (1)
                        {
                          --v673;
                          v682 = v682;
                          v689 = -1;
                          while (v673 >= v686 || (v673 & 0x80000000) == 0 && v682 >= v981[v673])
                          {
                            v690 = v670[v682];
                            if (v690 > 0x4F)
                            {
                              switch(v690)
                              {
                                case 'P':
                                  v705 = 3 * v682;
                                  if ((v689 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v689] = v705;
                                  }

                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[12 * v682] = v689;
                                  }

                                  v706 = v705 + 1;
                                  v707 = v684 - 2;
                                  v708 = 3 * ((v705 + 1) / 3);
                                  v709 = v708 + (v705 + 3) % 3;
                                  v710 = &v494[4 * v709];
                                  if ((*v710 & 0x80000000) != 0 || *v710 == v706)
                                  {
                                    v711 = v705 + 1;
                                  }

                                  else
                                  {
                                    v711 = v705 + 1;
                                    do
                                    {
                                      v493[(v711 + 1) % 3 + v708] = v707;
                                      v711 = *v710;
                                      v708 = 3 * (*v710 / 3);
                                      v709 = v708 + (*v710 + 2) % 3;
                                      v710 = &v494[4 * v709];
                                    }

                                    while ((*v710 & 0x80000000) == 0 && *v710 != v706);
                                  }

                                  v493[(v711 + 1) % 3 + v708] = v707;
                                  if ((v709 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v709] = v706;
                                  }

                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[4 * v706] = v709;
                                  }

                                  v712 = v705 + 2;
                                  v713 = v684 - 1;
                                  v714 = 3 * ((v705 + 2) / 3);
                                  v715 = v714 + (v705 + 4) % 3;
                                  v716 = &v494[4 * v715];
                                  if ((*v716 & 0x80000000) != 0 || *v716 == v712)
                                  {
                                    v718 = v705 + 2;
                                    v717 = 3 * ((v705 + 2) / 3);
                                  }

                                  else
                                  {
                                    v717 = 3 * ((v705 + 2) / 3);
                                    v718 = v705 + 2;
                                    do
                                    {
                                      v493[(v718 + 1) % 3 + v717] = v713;
                                      v718 = *v716;
                                      v717 = 3 * (*v716 / 3);
                                      v715 = v717 + (*v716 + 2) % 3;
                                      v716 = &v494[4 * v715];
                                    }

                                    while ((*v716 & 0x80000000) == 0 && *v716 != v712);
                                  }

                                  v493[(v718 + 1) % 3 + v717] = v713;
                                  if ((v715 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v715] = v712;
                                  }

                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[4 * v712] = v715;
                                  }

                                  v719 = v712 - v714 + v705;
                                  v720 = &v494[4 * v719];
                                  if ((*v720 & 0x80000000) != 0)
                                  {
                                    v721 = 3 * v682;
                                    v722 = 3 * v682;
                                  }

                                  else
                                  {
                                    v721 = 3 * v682;
                                    v722 = 3 * v682;
                                    if (*v720 != v705)
                                    {
                                      v722 = 3 * v682;
                                      v721 = 3 * v682;
                                      do
                                      {
                                        v493[(v721 + 1) % 3 + v722] = v684;
                                        v721 = *v720;
                                        v722 = 3 * (*v720 / 3);
                                        v719 = v722 + (*v720 + 2) % 3;
                                        v720 = &v494[4 * v719];
                                      }

                                      while ((*v720 & 0x80000000) == 0 && *v720 != v705);
                                    }
                                  }

                                  v493[(v721 + 1) % 3 + v722] = v684;
                                  if ((v719 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v719] = v705;
                                  }

                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[12 * v682] = v719;
                                  }

                                  v684 -= 3;
                                  --v673;
                                  break;
                                case 'R':
                                  v691 = 3 * v682 + 2;
                                  if ((v689 & 0x80000000) != 0)
                                  {
LABEL_701:
                                    if ((v682 & 0x8000000000000000) == 0)
                                    {
                                      *&v494[4 * v691] = v689;
                                    }

                                    break;
                                  }

LABEL_700:
                                  *&v494[4 * v689] = v691;
                                  goto LABEL_701;
                                case 'S':
                                  v692 = 3 * v682;
                                  v693 = 3 * v682 + 1;
                                  if ((v689 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v689] = v693;
                                  }

                                  if (v682 < 0)
                                  {
                                    v694 = v692 + 2;
                                    v723 = *&v494[4 * v694];
                                    if (v723 == -1 && v683 != 0)
                                    {
                                      v685 = v685 - 1;
                                      v731 = v683[v685];
LABEL_789:
                                      if ((v731 & 0x80000000) == 0)
                                      {
                                        *&v494[4 * v731] = v694;
                                      }

                                      break;
                                    }

                                    if (v723 > -2)
                                    {
                                      break;
                                    }

                                    v697 = -v723;
                                  }

                                  else
                                  {
                                    *&v494[4 * v693] = v689;
                                    v694 = v692 + 2;
                                    v695 = *&v494[4 * v694];
                                    if (v695 == -1 && v683 != 0)
                                    {
                                      v685 = v685 - 1;
                                      v731 = v683[v685];
                                      *&v494[4 * v694] = v731;
                                      goto LABEL_789;
                                    }

                                    if (v695 >= -1)
                                    {
                                      break;
                                    }

                                    v697 = -v695;
                                    *&v494[4 * v694] = v697;
                                  }

                                  *&v494[4 * v697] = v694;
                                  do
                                  {
                                    v725 = 3 * (v694 / 3) + (v694 + 1) % 3;
                                    LODWORD(v694) = *&v494[4 * v725];
                                  }

                                  while ((v694 & 0x80000000) == 0);
                                  v726 = 3 * (v725 / 3) + (v725 + 1) % 3;
                                  do
                                  {
                                    v727 = 3 * (v726 / 3) + (v726 + 1) % 3;
                                    v726 = *&v494[4 * v727];
                                  }

                                  while ((v726 & 0x80000000) == 0);
                                  do
                                  {
                                    v728 = 3 * (v727 / 3);
                                    v493[v728 + (v727 + 1) % 3] = v684;
                                    v727 = v728 + (v727 + 2) % 3;
                                    for (k = *&v494[4 * v727]; (k & 0x80000000) == 0; k = *&v494[4 * v727])
                                    {
                                      v730 = 3 * (k / 3);
                                      v493[v730 + (k + 1) % 3] = v684;
                                      v727 = v730 + (k + 2) % 3;
                                    }

                                    --v684;
                                  }

                                  while (v493[3 * (v727 / 3) + (v727 + 1) % 3] == -1);
                                  break;
                                default:
                                  break;
                              }
                            }

                            else
                            {
                              switch(v690)
                              {
                                case 'C':
                                  v698 = 3 * v682;
                                  v699 = 3 * v682 + 1;
                                  if ((v689 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v689] = v699;
                                  }

                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[4 * v699] = v689;
                                  }

                                  v700 = v698 + 2;
                                  v701 = 3 * ((v698 + 2) / 3);
                                  v702 = v701 + (v698 + 4) % 3;
                                  v703 = &v494[4 * v702];
                                  if ((*v703 & 0x80000000) != 0 || *v703 == v700)
                                  {
                                    v704 = v700;
                                  }

                                  else
                                  {
                                    v704 = v700;
                                    do
                                    {
                                      v493[(v704 + 1) % 3 + v701] = v684;
                                      v704 = *v703;
                                      v701 = 3 * (*v703 / 3);
                                      v702 = v701 + (*v703 + 2) % 3;
                                      v703 = &v494[4 * v702];
                                    }

                                    while ((*v703 & 0x80000000) == 0 && *v703 != v700);
                                  }

                                  v493[(v704 + 1) % 3 + v701] = v684;
                                  if ((v702 & 0x80000000) == 0)
                                  {
                                    *&v494[4 * v702] = v700;
                                  }

                                  --v684;
                                  if ((v682 & 0x8000000000000000) == 0)
                                  {
                                    *&v494[4 * v700] = v702;
                                  }

                                  break;
                                case 'E':
                                  if (v689 >= 1 && v683)
                                  {
                                    v683[v685] = v689;
                                    LODWORD(v685) = v685 + 1;
                                  }

                                  break;
                                case 'L':
                                  v691 = 3 * v682 + 1;
                                  if ((v689 & 0x80000000) != 0)
                                  {
                                    goto LABEL_701;
                                  }

                                  goto LABEL_700;
                                default:
                                  break;
                              }
                            }

                            v689 = 3 * v682--;
                          }

                          if (v686)
                          {
                            v732 = 3 * v981[v673];
                            v733 = 3 * ((v732 + 1) / 3) + (v732 + 2) % 3;
                            do
                            {
                              v734 = 3 * (v733 / 3) + (v733 + 1) % 3;
                              v733 = *&v494[4 * v734];
                            }

                            while ((v733 & 0x80000000) == 0);
                            do
                            {
                              v735 = 3 * (v734 / 3);
                              v493[v735 + (v734 + 1) % 3] = v684;
                              v734 = v735 + (v734 + 2) % 3;
                              for (m = *&v494[4 * v734]; (m & 0x80000000) == 0; m = *&v494[4 * v734])
                              {
                                v737 = 3 * (m / 3);
                                v493[v737 + (m + 1) % 3] = v684;
                                v734 = v737 + (m + 2) % 3;
                              }

                              --v684;
                            }

                            while (v493[3 * (v734 / 3) + (v734 + 1) % 3] == -1);
                            --v686;
                          }

                          if (v673 <= 0)
                          {
                            goto LABEL_800;
                          }
                        }
                      }

                      v687 = v981;
                      v688 = v670;
LABEL_800:
                      free(v683);
                      free(v687);
                      free(v688);
                      if (v684 == -1)
                      {
                        if (*(v1009 + 160))
                        {
                          v738 = 0;
                          v739 = v493 + 2;
                          v740 = (*(v1009 + 168) + 8);
                          do
                          {
                            *(v740 - 2) = *(v739 - 2);
                            *(v740 - 1) = *(v739 - 1);
                            v741 = *v739;
                            v739 += 3;
                            *v740 = v741;
                            v740 += 4;
                            ++v738;
                          }

                          while (v738 < *(v1009 + 160));
                        }

                        v629 = 0;
                      }

                      else
                      {
                        v629 = 1;
                      }

                      v8 = v999;
                      v679 = v1006;
                      v14 = 1.0;
                      v15 = 1.0;
                      v680 = v991;
                      v681 = v997;
                      v419 = v977;
LABEL_807:
                      v742 = v1015;
                      v743 = v1015[2];
                      if (v743)
                      {
                        free(v743);
                        v742 = v1015;
                      }

                      free(v742);
                      v744 = v419[2];
                      if (v744)
                      {
                        free(v744);
                      }

                      free(v419);
                      free(v681);
                      free(v494);
                      free(v493);
                      free(v680);
                      free(v679);
                      v3 = v1009;
                      if (!v629)
                      {
                        goto LABEL_216;
                      }

                      goto LABEL_215;
                    }
                  }

LABEL_680:
                  v8 = v999;
                  v679 = v1006;
                  v14 = 1.0;
                  v15 = 1.0;
                  v680 = v991;
                  v681 = v997;
                  goto LABEL_807;
                }
              }

              v499 = 0;
              v500 = 0;
              goto LABEL_656;
            }

            v493 = 0;
            v494 = 0;
            v629 = 1;
            goto LABEL_680;
          }

          v1032 = v12;
          v1033.f64[1] = v12.f64[1];
          v1033.f64[0] = v23;
          if (*&v23 == *(v8 + 3))
          {
            LODWORD(v1032.f64[0]) = -1;
          }

          else
          {
            mc_read_chunk_header(v8, &v1032);
            v12 = 0uLL;
            if (LODWORD(v1032.f64[0]) == 5 && WORD2(v1032.f64[0]) <= 1u)
            {
              if (*v999)
              {
                v65 = *(v999 + 32);
                if ((v65 + 4) <= *(v999 + 24))
                {
                  v66 = *(*(v999 + 8) + v65);
                  *(v999 + 32) = v65 + 4;
                  if (v66 == *(v3 + 160))
                  {
                    v67 = malloc_type_malloc(4 * v66, 0x100004052888210uLL);
                    mc_read_tiny_big(v999, v66, v67);
                    if (v66 >= 1)
                    {
                      v68 = (*(v3 + 168) + 12);
                      v69 = v67;
                      do
                      {
                        v70 = v69->i32[0];
                        v69 = (v69 + 4);
                        *v68 = v70;
                        v68 += 4;
                        --v66;
                      }

                      while (v66);
                    }

                    v8 = v999;
                    if (*v999 && *(v999 + 24) >= (*&v1032.f64[1] + v65))
                    {
                      *(v999 + 32) = *&v1032.f64[1] + v65;
                    }

                    v22 = v67;
                    goto LABEL_29;
                  }
                }
              }
            }
          }

          v8 = v999;
          *v999 = 0;
        }
      }

      else if (SLODWORD(v1032.f64[0]) > 8)
      {
        switch(LODWORD(v1032.f64[0]))
        {
          case 9:
            v1042.f64[0] = 0.0;
            v1040 = v12;
            v1041 = v12;
            v1038 = v12;
            v1039 = v12;
            v1036 = v12;
            v1037 = v12;
            v1034 = v12;
            v1035 = v12;
            v1032 = v12;
            v1033 = v12;
            v1028 = v12;
            v1030 = v12.f64[1];
            v1029 = v23;
            if (*&v23 == *(v8 + 3))
            {
              v33 = 0;
              v34 = 0.0;
              LODWORD(v1028.f64[0]) = -1;
              v35 = 0.0;
              goto LABEL_79;
            }

            mc_read_chunk_header(v8, &v1028);
            v33 = 0;
            v34 = *(v8 + 4);
            v1030 = v34;
            v35 = 0.0;
            if (LODWORD(v1028.f64[0]) == 9 && WORD2(v1028.f64[0]) <= 1u)
            {
              if (!*v8)
              {
                v33 = 0;
                v35 = 0.0;
                v36 = 0.0;
                v37 = 0.0;
                goto LABEL_81;
              }

              v102 = *&v34 + 4;
              v103 = *(v8 + 3);
              v37 = 0.0;
              if (*&v34 + 4 > v103)
              {
                v33 = 0;
                goto LABEL_282;
              }

              v178 = *(v8 + 1);
              v33 = *(v178 + *&v34);
              *(v8 + 4) = v102;
              v179 = *&v34 + 8;
              if (*&v34 + 8 > v103)
              {
LABEL_282:
                v35 = 0.0;
                goto LABEL_283;
              }

              v35 = *(v178 + v102);
              *(v8 + 4) = v179;
              v261 = *&v34 + 12;
              if ((*&v34 + 12) > *(v8 + 3))
              {
LABEL_283:
                v36 = 0.0;
              }

              else
              {
                v36 = *(*(v8 + 1) + v179);
                *(v8 + 4) = v261;
                v262 = *&v34 + 16;
                if ((*&v34 + 16) <= *(v8 + 3))
                {
                  v37 = *(*(v8 + 1) + v261);
                  *(v8 + 4) = v262;
                  if ((*&v34 + 18) <= *(v8 + 3))
                  {
                    v263 = *(*(v8 + 1) + v262);
                    *(v8 + 4) = *&v34 + 18;
                    if (!v263)
                    {
                      v1013 = v35;
                      v1003 = v36;
                      mc_read_mat4(v8, v1032.f64);
                      mc_io_r_mc_projection(&v1040, v8);
                      v36 = v1003;
                      v35 = v1013;
LABEL_82:
                      if (v33 == *(v3 + 136))
                      {
                        if (!*v8)
                        {
LABEL_175:
                          v22 = 0;
                          goto LABEL_29;
                        }

                        v1000 = v36;
                        v1010 = v35;
                        v38 = malloc_type_malloc(4 * (3 * v33), 0x100004052888210uLL);
                        mc_read_tiny_big(v999, 3 * v33, v38);
                        if (*v999 && *(v999 + 24) >= *&v1028.f64[1] + *&v34)
                        {
                          *(v999 + 32) = *&v1028.f64[1] + *&v34;
                        }

                        v39 = malloc_type_malloc(4 * (3 * v33), 0x100004052888210uLL);
                        v40 = v39;
                        if (v33 >= 1)
                        {
                          v41 = 8 * v33;
                          if (v33 < 8)
                          {
                            v42 = 0;
                            goto LABEL_90;
                          }

                          v42 = 0;
                          v143 = &v39[3 * v33];
                          v144 = &v38->i32[v33];
                          _CF = v39 >= (v38 + v41) || v144 >= v143;
                          v146 = !_CF;
                          v148 = v39 < v144 && v38 < v143;
                          if ((v38 + v41) < v143 && v39 < v38 + 3 * v33)
                          {
                            goto LABEL_90;
                          }

                          if (v146)
                          {
                            goto LABEL_90;
                          }

                          if (v148)
                          {
                            goto LABEL_90;
                          }

                          v42 = v33 & 0x7FFFFFF8;
                          v150 = v38 + 1;
                          v151 = v39;
                          v152 = v42;
                          do
                          {
                            v1047.val[0] = v150[-1];
                            v1052.val[0] = *v150;
                            v1047.val[1] = *(v150 + 4 * v33 - 16);
                            v1052.val[1] = *(v150 + 4 * v33);
                            v1047.val[2] = *(v150 + v41 - 16);
                            v1052.val[2] = *(v150 + 8 * v33);
                            v153 = v151 + 24;
                            vst3q_f32(v151, v1047);
                            v154 = v151 + 12;
                            vst3q_f32(v154, v1052);
                            v150 += 2;
                            v151 = v153;
                            v152 -= 8;
                          }

                          while (v152);
                          if (v42 != v33)
                          {
LABEL_90:
                            v43 = &v38->i32[v42];
                            v44 = &v39[3 * v42 + 2];
                            v45 = v33 - v42;
                            do
                            {
                              *(v44 - 2) = *v43;
                              *(v44 - 1) = v43[v33];
                              *v44 = v43[2 * v33];
                              v44 += 3;
                              ++v43;
                              --v45;
                            }

                            while (v45);
                          }
                        }

                        memcpy(v38, v39, 4 * (3 * v33));
                        free(v40);
                        v46 = malloc_type_malloc(4 * (3 * *(v3 + 160)), 0x100004052888210uLL);
                        v47 = v46;
                        if (*(v3 + 160))
                        {
                          v48 = 0;
                          v49 = v46 + 8;
                          v50 = (*(v3 + 168) + 8);
                          do
                          {
                            *(v49 - 2) = *(v50 - 2);
                            *(v49 - 1) = *(v50 - 1);
                            v51 = *v50;
                            v50 += 4;
                            *v49 = v51;
                            v49 += 3;
                            ++v48;
                            v52 = *(v3 + 160);
                          }

                          while (v48 < v52);
                        }

                        else
                        {
                          LODWORD(v52) = 0;
                        }

                        v138 = mc_encode_decode_predictive(v52, *(v3 + 136), v47, v38, 3u, v38);
                        free(v47);
                        if (v138)
                        {
                          v969 = v13;
                          v971 = v11;
                          v140 = *(v3 + 136);
                          v141 = *(v3 + 144);
                          if (v140)
                          {
                            *v139.i32 = v14 / v37;
                            if (v140 < 4)
                            {
                              v142 = 0;
                              goto LABEL_287;
                            }

                            v142 = v140 & 0xFFFFFFFC;
                            v180 = vdupq_lane_s32(v139, 0);
                            v181 = v38;
                            v182 = *(v3 + 144);
                            v183 = v142;
                            do
                            {
                              v184 = *v181;
                              v185.i32[1] = HIDWORD(v181[1].i64[0]);
                              v185.i32[0] = v181->i64[1];
                              v186 = vrev64q_s32(v181[1]);
                              v186.i32[0] = HIDWORD(v181->i64[0]);
                              v185.i32[2] = v181[2];
                              v186.i32[3] = v181[2].i64[1];
                              v184.i32[1] = HIDWORD(*v181);
                              v185.i32[3] = HIDWORD(*&v181[2]);
                              v184.i32[2] = v181[1].i64[1];
                              v184.i32[3] = HIDWORD(v181[2].i64[0]);
                              v1053.val[2] = vmaxnmq_f32(vmulq_n_f32(vcvtq_f32_s32(v185), v1000), v180);
                              v1053.val[1] = vmulq_n_f32(vcvtq_f32_s32(v186), v1010);
                              v1053.val[0] = vmulq_n_f32(vcvtq_f32_s32(v184), v1010);
                              vst3q_f32(v182, v1053);
                              v182 += 12;
                              v181 += 3;
                              v183 -= 4;
                            }

                            while (v183);
                            if (v142 != v140)
                            {
LABEL_287:
                              v187 = v140 - v142;
                              v188 = 3 * v142;
                              v189 = (v141 + 12 * v142 + 8);
                              v190 = &v38->i32[v188 + 2];
                              do
                              {
                                *(v189 - 1) = vmul_n_f32(vcvt_f32_s32(*(v190 - 2)), v1010);
                                v191 = *v190;
                                v190 += 3;
                                *v189 = fmaxf(v1000 * v191, *v139.i32);
                                v189 += 3;
                                --v187;
                              }

                              while (v187);
                            }
                          }

                          v8 = v999;
                          if (!v140)
                          {
                            v22 = v38;
                            goto LABEL_29;
                          }

                          v192 = LODWORD(v1040.f64[0]);
                          v1011 = v1041.f64[1];
                          v1002 = v1042.f64[0];
                          v193 = *(v3 + 8);
                          v194 = *(v3 + 40);
                          v195 = *(v3 + 72);
                          v196 = *(v3 + 104);
                          v197 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v193, v1032.f64[0]), v194, v1032.f64[1]), v195, v1033.f64[0]), v196, v1033.f64[1]);
                          v198 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v193, v1034.f64[0]), v194, v1034.f64[1]), v195, v1035.f64[0]), v196, v1035.f64[1]);
                          v199 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v193, v1036.f64[0]), v194, v1036.f64[1]), v195, v1037.f64[0]), v196, v1037.f64[1]);
                          v200 = *(v3 + 120);
                          v201 = *(v3 + 88);
                          v202 = *(v3 + 56);
                          v203 = *(v3 + 24);
                          v204 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_n_f64(v203, v1036.f64[0]), vdupq_lane_s64(*&v1036.f64[1], 0), v202), vdupq_lane_s64(*&v1037.f64[0], 0), v201), vdupq_lane_s64(*&v1037.f64[1], 0), v200);
                          v205 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_n_f64(v203, v1034.f64[0]), vdupq_lane_s64(*&v1034.f64[1], 0), v202), vdupq_lane_s64(*&v1035.f64[0], 0), v201), vdupq_lane_s64(*&v1035.f64[1], 0), v200);
                          v206 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_n_f64(v203, v1032.f64[0]), vdupq_lane_s64(*&v1032.f64[1], 0), v202), vdupq_lane_s64(*&v1033.f64[0], 0), v201), vdupq_lane_s64(*&v1033.f64[1], 0), v200);
                          v207 = v15 / v1040.f64[1];
                          v208 = v15 / v1041.f64[0];
                          v209 = v206.f64[1];
                          v210 = v205.f64[1];
                          v211 = v204.f64[1];
                          v212 = (v141 + 8);
                          v989 = v198;
                          *v994 = v197;
                          v978 = v204.f64[0];
                          v982 = v199;
                          v973 = v206.f64[0];
                          v974 = v205.f64[0];
                          while (2)
                          {
                            v222 = *(v212 - 2);
                            v223 = *(v212 - 1);
                            v224 = *v212;
                            v225 = *v212;
                            v1026.f64[0] = 0.0;
                            v1031 = 0.0;
                            if (v192 == 3)
                            {
                              v219 = v207 * v222;
                              v1026.f64[0] = v208 * v223;
                              v227 = &v1031;
                              v226 = v15 / v225;
LABEL_298:
                              v227->f64[0] = v226;
                              if (v224 <= 0.0)
                              {
LABEL_301:
                                v11 = v971;
                                v13 = v969;
                                v14 = 1.0;
                                goto LABEL_168;
                              }

                              v216 = v1026.f64[0];
                              v220 = v1031;
                            }

                            else
                            {
                              if (v192 != 1)
                              {
                                if (v192)
                                {
                                  goto LABEL_301;
                                }

                                v1031 = v15 / v225;
                                v219 = v15 / v225 * (v222 * v207);
                                v226 = v15 / v225 * (v223 * v208);
                                v227 = &v1026;
                                goto LABEL_298;
                              }

                              v213 = (v222 - v1011) * v207;
                              v214 = 1.0 / v225;
                              v215 = __sincos_stret((v223 - v1002) * v208);
                              v216 = v215.__sinval * v214;
                              v217 = v215.__cosval * v214;
                              v218 = __sincos_stret(v213);
                              v206.f64[0] = v973;
                              v205.f64[0] = v974;
                              v204.f64[0] = v978;
                              v199 = v982;
                              v198 = v989;
                              v197 = *v994;
                              v219 = v217 * v218.__sinval;
                              v220 = v217 * v218.__cosval;
                              v15 = 1.0;
                            }

                            v221 = v220 - v211;
                            *(v212 - 1) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v197, v219 - v209), v198, v216 - v210), v199, v221));
                            *&v221 = (v219 - v209) * v206.f64[0] + (v216 - v210) * v205.f64[0] + v221 * v204.f64[0];
                            *v212 = *&v221;
                            v212 += 3;
                            if (!--v140)
                            {
                              v11 = v971;
                              v13 = v969;
                              v14 = 1.0;
                              v22 = v38;
                              goto LABEL_29;
                            }

                            continue;
                          }
                        }

                        v8 = v999;
                      }

                      else
                      {
                        v38 = 0;
                      }

LABEL_168:
                      *v8 = 0;
                      v22 = v38;
                      goto LABEL_29;
                    }

LABEL_81:
                    *v8 = 0;
                    goto LABEL_82;
                  }
                }
              }
            }

            else
            {
LABEL_79:
              v36 = 0.0;
              v37 = 0.0;
            }

            *v8 = 0;
            goto LABEL_81;
          case 0xA:
            if (v988)
            {
              *v8 = 0;
            }

            else
            {
              v1032 = v12;
              v1033.f64[1] = v12.f64[1];
              v1033.f64[0] = v23;
              if (*&v23 == *(v8 + 3))
              {
                LODWORD(v1032.f64[0]) = -1;
                goto LABEL_174;
              }

              mc_read_chunk_header(v8, &v1032);
              v12 = 0uLL;
              if (LODWORD(v1032.f64[0]) == 10 && WORD2(v1032.f64[0]) < 2u)
              {
                if (*v8)
                {
                  v133 = *(v8 + 4);
                  if ((v133 + 2) > *(v8 + 3))
                  {
                    goto LABEL_174;
                  }

                  v134 = *(*(v8 + 1) + v133);
                  *(v8 + 4) = v133 + 2;
                  v988 = malloc_type_calloc(v134, 0xB0uLL, 0x1000040D737CE88uLL);
                  v986 = v134;
                  if (v134)
                  {
                    v135 = v988;
                    do
                    {
                      mc_io_r_uv_model(v135, v8);
                      v135 += 176;
                      --v134;
                    }

                    while (v134);
                  }

                  v12 = 0uLL;
                  if (*v8 && *(v8 + 3) >= (*&v1032.f64[1] + v133))
                  {
                    *(v8 + 4) = *&v1032.f64[1] + v133;
                  }
                }

                else
                {
                  v988 = 0;
                }
              }

              else
              {
LABEL_174:
                v988 = 0;
                *v8 = 0;
              }
            }

            break;
          case 0xB:
            v1032 = v12;
            v1033.f64[1] = v12.f64[1];
            v1033.f64[0] = v23;
            if (*&v23 == *(v8 + 3))
            {
              LODWORD(v1032.f64[0]) = -1;
LABEL_55:
              v987 = 0;
              v1020 = 0;
LABEL_56:
              *v8 = 0;
              goto LABEL_57;
            }

            mc_read_chunk_header(v8, &v1032);
            v12 = 0uLL;
            if (LODWORD(v1032.f64[0]) != 11 || WORD2(v1032.f64[0]) >= 2u)
            {
              goto LABEL_55;
            }

            if (*v8)
            {
              v91 = *(v8 + 3);
              v90 = *(v8 + 4);
              v92 = v90 + 1;
              if (v90 + 1 > v91)
              {
                goto LABEL_55;
              }

              v93 = *(*(v8 + 1) + v90);
              *(v8 + 4) = v92;
              v1020 = v93;
              if (v93)
              {
                if (v90 + 5 > v91)
                {
                  v987 = 0;
                  *v8 = 0;
                  v11 = 0.0;
                  goto LABEL_57;
                }

                v11 = *(*(v8 + 1) + v92);
                *(v8 + 4) = v90 + 5;
                v92 = v90 + 5;
              }

              else
              {
                v1020 = 0;
              }

              if ((v92 + 1) > *(v8 + 3))
              {
                v987 = 0;
                goto LABEL_56;
              }

              v987 = *(*(v8 + 1) + v92);
              v276 = *&v1032.f64[1] + v90;
              if (*(v8 + 3) < v276)
              {
                v276 = v92 + 1;
              }

              *(v8 + 4) = v276;
            }

            else
            {
              v987 = 0;
              v1020 = 0;
            }

LABEL_57:
            v1024 = 1;
            break;
          default:
LABEL_96:
            if (*&v23 == *(v8 + 3))
            {
              *v8 = 0;
            }

            else
            {
              v1032 = v12;
              v1033 = v12;
              mc_read_chunk_header(v8, &v1032);
              v12 = 0uLL;
              if (*v8)
              {
                v104 = *(v8 + 4) + *&v1032.f64[1];
                if (*(v8 + 3) >= v104)
                {
                  *(v8 + 4) = v104;
                }
              }
            }

            break;
        }
      }

      else
      {
        if (LODWORD(v1032.f64[0]) == 6)
        {
          v1032 = v12;
          v1033.f64[1] = v12.f64[1];
          v1033.f64[0] = v23;
          if (*&v23 == *(v8 + 3))
          {
            LODWORD(v1032.f64[0]) = -1;
LABEL_74:
            *v8 = 0;
LABEL_75:
            v22 = 0;
LABEL_76:
            *v8 = 0;
            goto LABEL_29;
          }

          mc_read_chunk_header(v8, &v1032);
          v94 = *(v8 + 4);
          v1033.f64[1] = v94;
          if (LODWORD(v1032.f64[0]) != 6 || WORD2(v1032.f64[0]) > 1u)
          {
            goto LABEL_74;
          }

          if (!*v8)
          {
            goto LABEL_75;
          }

          v95 = *&v94 + 4;
          v96 = *(v8 + 3);
          if (*&v94 + 4 > v96)
          {
            goto LABEL_74;
          }

          v97 = *(v8 + 1);
          v98 = *(v97 + *&v94);
          *(v8 + 4) = v95;
          v99 = *&v94 + 12;
          if (*&v94 + 12 > v96)
          {
            goto LABEL_74;
          }

          v100 = *(v97 + v95);
          *(v8 + 4) = v99;
          v101 = *&v94 + 20;
          if ((*&v94 + 20) > *(v8 + 3))
          {
            *v8 = 0;
            goto LABEL_75;
          }

          *&v286 = v100;
          *(&v286 + 1) = *(*(v8 + 1) + v99);
          *(v8 + 4) = v101;
          *v1014 = v286;
          if ((*&v94 + 28) > *(v8 + 3) || (v287 = *(*(v8 + 1) + v101), *(v8 + 4) = *&v94 + 28, v98 != *(v3 + 136)))
          {
            v22 = 0;
            goto LABEL_76;
          }

          v1004 = v287;
          v1018 = v100;
          v288 = 3 * v98;
          v289 = v8;
          v290 = malloc_type_malloc(12 * v98, 0x100004052888210uLL);
          mc_read_tiny_big(v289, v288, v290);
          if (!*v289)
          {
            v22 = v290;
            v8 = v289;
            goto LABEL_76;
          }

          if (*(v289 + 24) >= *&v1032.f64[1] + *&v94)
          {
            *(v999 + 32) = *&v1032.f64[1] + *&v94;
          }

          v291 = malloc_type_malloc(4 * v288, 0x100004052888210uLL);
          v292 = v291;
          if (*(v3 + 136))
          {
            v293 = 0;
            v294 = &v291->i32[2];
            do
            {
              *(v294 - 2) = v290->i32[v293];
              *(v294 - 1) = v290->i32[(v293 + *(v3 + 136))];
              v295 = v293++ + 2 * *(v3 + 136);
              *v294 = v290->i32[v295];
              v294 += 3;
            }

            while (v293 < *(v3 + 136));
          }

          free(v290);
          v296 = malloc_type_malloc(12 * *(v3 + 136), 0x100004052888210uLL);
          v297 = malloc_type_malloc(4 * (3 * *(v3 + 160)), 0x100004052888210uLL);
          v298 = v297;
          if (*(v3 + 160))
          {
            v299 = 0;
            v300 = v297 + 2;
            v301 = (*(v3 + 168) + 8);
            do
            {
              *(v300 - 2) = *(v301 - 2);
              *(v300 - 1) = *(v301 - 1);
              v302 = *v301;
              v301 += 4;
              *v300 = v302;
              v300 += 3;
              ++v299;
              v303 = *(v3 + 160);
            }

            while (v299 < v303);
          }

          else
          {
            LODWORD(v303) = 0;
          }

          if (!mc_encode_decode_predictive(v303, *(v3 + 136), v298, v296, 3u, v292))
          {
            free(v298);
            free(v296);
            v22 = v292;
            v8 = v999;
            goto LABEL_76;
          }

          v411 = *(v3 + 136);
          if (v411 < 1)
          {
            goto LABEL_551;
          }

          v412 = *(v3 + 144);
          if (v411 >= 4)
          {
            v413 = v411 & 0x7FFFFFFC;
            v423 = v296;
            v424 = *(v3 + 144);
            v425 = v413;
            do
            {
              v1051 = vld3q_f32(v423);
              v423 += 12;
              v426.i64[0] = v1051.val[0].i32[0];
              v426.i64[1] = v1051.val[0].i32[1];
              v427 = vcvtq_f64_s64(v426);
              v426.i64[0] = v1051.val[0].i32[2];
              v426.i64[1] = v1051.val[0].i32[3];
              v428 = vmulq_n_f64(vcvtq_f64_s64(v426), v1018);
              v426.i64[0] = v1051.val[1].i32[0];
              v426.i64[1] = v1051.val[1].i32[1];
              v429 = vcvtq_f64_s64(v426);
              v426.i64[0] = v1051.val[1].i32[2];
              v426.i64[1] = v1051.val[1].i32[3];
              v430 = vmulq_laneq_f64(vcvtq_f64_s64(v426), *v1014, 1);
              v426.i64[0] = v1051.val[2].i32[0];
              v426.i64[1] = v1051.val[2].i32[1];
              v431 = vcvtq_f64_s64(v426);
              v426.i64[0] = v1051.val[2].i32[2];
              v426.i64[1] = v1051.val[2].i32[3];
              v1057.val[2] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v431, v1004)), vmulq_n_f64(vcvtq_f64_s64(v426), v1004));
              v1057.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_laneq_f64(v429, *v1014, 1)), v430);
              v1057.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v427, v1018)), v428);
              vst3q_f32(v424, v1057);
              v424 += 12;
              v425 -= 4;
            }

            while (v425);
            if (v413 == v411)
            {
              goto LABEL_551;
            }
          }

          else
          {
            v413 = 0;
          }

          v432 = v411 - v413;
          v433 = 12 * v413;
          v434 = &v296[12 * v413 + 8];
          v435 = (v412 + v433 + 8);
          do
          {
            v436 = *(v434 - 1);
            v437.i64[0] = v436;
            v437.i64[1] = SHIDWORD(v436);
            v435[-1] = vcvt_f32_f64(vmulq_f64(*v1014, vcvtq_f64_s64(v437)));
            v438 = *v434;
            v434 += 12;
            *&v436 = v1004 * v438;
            v435->i32[0] = v436;
            v435 = (v435 + 12);
            --v432;
          }

          while (v432);
LABEL_551:
          free(v298);
          free(v296);
          v22 = v292;
          v8 = v999;
          goto LABEL_29;
        }

        if (LODWORD(v1032.f64[0]) == 7)
        {
          v1028 = v12;
          v1030 = v12.f64[1];
          v1029 = v23;
          if (*&v23 == *(v8 + 3))
          {
            v29 = 0.0;
            v30 = 0;
            v31 = 0;
            v32 = 0;
            LODWORD(v1028.f64[0]) = -1;
            goto LABEL_177;
          }

          mc_read_chunk_header(v8, &v1028);
          v29 = *(v8 + 4);
          v1030 = v29;
          if (LODWORD(v1028.f64[0]) != 7)
          {
            v30 = 0;
            v31 = 0;
            v32 = 0;
            goto LABEL_177;
          }

          v30 = WORD2(v1028.f64[0]);
          if (WORD2(v1028.f64[0]) > 2u)
          {
            v30 = 0;
            v31 = 0;
            v32 = 0;
            goto LABEL_177;
          }

          v105 = *v8;
          if (*v8)
          {
            v136 = *&v29 + 4;
            v137 = *(v8 + 3);
            if (*&v29 + 4 <= v137)
            {
              v260 = *(v8 + 1);
              v32 = *(v260 + *&v29);
              *(v8 + 4) = v136;
              if (*&v29 + 8 <= v137)
              {
                v31 = *(v260 + v136);
                *(v8 + 4) = *&v29 + 8;
                v136 = *&v29 + 8;
              }

              else
              {
                v105 = 0;
                v31 = 0;
                *v8 = 0;
              }
            }

            else
            {
              v105 = 0;
              v31 = 0;
              v32 = 0;
              *v8 = 0;
              v136 = *&v29;
            }
          }

          else
          {
            v31 = 0;
            v32 = 0;
            v136 = *&v29;
          }

          if (v30 < 2)
          {
            if (!v105)
            {
              goto LABEL_178;
            }

            v280 = v136 + 8;
            v281 = *(v8 + 3);
            if (v136 + 8 <= v281)
            {
              v282 = *(v8 + 1);
              v106.f64[0] = *(v282 + v136);
              *(v8 + 4) = v280;
              v283 = v136 + 16;
              if (v283 <= v281)
              {
                v107 = *(v282 + v280);
                *(v8 + 4) = v283;
                goto LABEL_180;
              }

              v105 = 0;
              *v8 = 0;
LABEL_179:
              v107 = 0.0;
LABEL_180:
              v106.f64[1] = v107;
              v108 = 1;
              v109 = *&v13;
              goto LABEL_181;
            }

LABEL_177:
            *v8 = 0;
LABEL_178:
            v105 = 0;
            v106.f64[0] = 0.0;
            goto LABEL_179;
          }

          if (v105)
          {
            v277 = v136 + 1;
            v278 = *(v8 + 3);
            if (v136 + 1 <= v278)
            {
              v284 = *(v8 + 1);
              v279 = *(v284 + v136);
              *(v8 + 4) = v277;
              v285 = v136 + 9;
              if (v136 + 9 <= v278)
              {
                v106.f64[0] = *(v284 + v277);
                *(v8 + 4) = v285;
                v310 = v136 + 17;
                if ((v285 + 8) <= *(v8 + 3))
                {
                  v106.f64[1] = *(*(v8 + 1) + v285);
                  *(v8 + 4) = v310;
                  if ((v285 + 16) <= *(v8 + 3))
                  {
                    v109 = *(*(v8 + 1) + v310);
                    *(v8 + 4) = v285 + 16;
                    goto LABEL_396;
                  }

                  v105 = 0;
                  *v8 = 0;
LABEL_395:
                  v109 = 0.0;
LABEL_396:
                  v108 = v279 == 0;
LABEL_181:
                  v110 = *(v3 + 136);
                  v1022 = v106;
                  if (v110 != v31)
                  {
                    v20 = 0;
                    v21 = 0;
                    *v8 = 0;
                    if (v32 == *(v3 + 160))
                    {
                      goto LABEL_28;
                    }

                    goto LABEL_27;
                  }

                  if (v32 != *(v3 + 160))
                  {
                    v20 = 0;
                    v21 = 0;
LABEL_27:
                    *v8 = 0;
                    goto LABEL_28;
                  }

                  if (!v105)
                  {
                    v20 = 0;
                    v21 = 0;
                    goto LABEL_28;
                  }

                  v1001 = v109;
                  v21 = malloc_type_calloc(v110, 0xCuLL, 0x100004052888210uLL);
                  v111 = *(v3 + 136);
                  v112 = 2 * v111;
                  v113 = 3 * v111;
                  if (v108)
                  {
                    v114 = v112;
                  }

                  else
                  {
                    v114 = v113;
                  }

                  mc_read_tiny_big(v8, v114, v21);
                  if (v30 > 1)
                  {
LABEL_194:
                    v124 = *(v3 + 136);
                    v125 = malloc_type_malloc(12 * v124, 0x100004052888210uLL);
                    v126 = v125;
                    if (v124 < 1)
                    {
                      goto LABEL_199;
                    }

                    v127 = 8 * v124;
                    if (v124 >= 8)
                    {
                      v128 = 0;
                      v228 = &v125[3 * v124];
                      v229 = &v21->i32[v124];
                      v231 = v125 < (v21 + v127) && v229 < v228;
                      v233 = v125 < v229 && v21 < v228;
                      if (((v21 + v127) >= v228 || v125 >= v21 + 3 * v124) && !v231 && !v233)
                      {
                        v128 = v124 & 0x7FFFFFF8;
                        v235 = v21 + 1;
                        v236 = v125;
                        v237 = v128;
                        do
                        {
                          v1048.val[0] = v235[-1];
                          v1054.val[0] = *v235;
                          v1048.val[1] = *(v235 + 4 * v124 - 16);
                          v1054.val[1] = *(v235 + 4 * v124);
                          v1048.val[2] = *(v235 + v127 - 16);
                          v1054.val[2] = *(v235 + 8 * v124);
                          v238 = v236 + 24;
                          vst3q_f32(v236, v1048);
                          v239 = v236 + 12;
                          vst3q_f32(v239, v1054);
                          v235 += 2;
                          v236 = v238;
                          v237 -= 8;
                        }

                        while (v237);
                        if (v128 == v124)
                        {
LABEL_199:
                          memcpy(v21, v125, 12 * v124);
                          free(v126);
                          v8 = v999;
                          if (!*v999)
                          {
                            v20 = 0;
                            goto LABEL_28;
                          }

                          v132 = *(v999 + 32);
                          if ((v132 + 2) > *(v999 + 24))
                          {
                            v20 = 0;
                            goto LABEL_27;
                          }

                          v983 = v108;
                          v240 = *(*(v999 + 8) + v132);
                          *(v999 + 32) = v132 + 2;
                          v241 = malloc_type_calloc(v240, 0xB0uLL, 0x1000040D737CE88uLL);
                          v20 = v241;
                          if (v240)
                          {
                            v242 = v241;
                            v243 = v240;
                            do
                            {
                              mc_io_r_uv_model(v242, v999);
                              v242 += 176;
                              --v243;
                            }

                            while (v243);
                          }

                          if (!*v999)
                          {
                            goto LABEL_28;
                          }

                          v990 = v240;
                          v244 = *&v1028.f64[1] + *&v29;
                          _CF = *(v999 + 24) >= *&v1028.f64[1] + *&v29;
                          v245 = &xmmword_1B33B2000;
                          if (_CF)
                          {
                            *(v999 + 32) = v244;
                          }

                          v246 = malloc_type_malloc(12 * *(v3 + 136), 0x100004052888210uLL);
                          v247 = malloc_type_malloc(4 * (3 * *(v3 + 160)), 0x100004052888210uLL);
                          v248 = v247;
                          if (v240)
                          {
                            v975 = v247;
                            v979 = v246;
                            v995 = malloc_type_malloc(12 * *(v3 + 136), 0x10000403E1C8BA9uLL);
                            v249 = 0;
                            v1041 = 0u;
                            v1042 = 0u;
                            v1039 = 0u;
                            v1040 = 0u;
                            v1037 = 0u;
                            v1038 = 0u;
                            v1035 = 0u;
                            v1036 = 0u;
                            v1033 = 0u;
                            v1034 = 0u;
                            v250 = v20 + 1;
                            v251 = v240;
                            v1032 = 0u;
                            do
                            {
                              v253 = *v250;
                              v250 += 44;
                              v252 = v253;
                              if (v253 >= v249)
                              {
                                v249 = v252 + 1;
                              }

                              --v251;
                            }

                            while (v251);
                            v1012 = malloc_type_calloc(v249, 8uLL, 0x2004093837F09uLL);
                            v254 = malloc_type_calloc(*(v3 + 136), 1uLL, 0x100004077774924uLL);
                            v256 = v995;
                            if (!v995)
                            {
                              v256 = *(v3 + 152);
                            }

                            v257 = v20;
                            v258 = v240;
                            if (v20[1] == -1)
                            {
                              v311 = v20;
                              do
                              {
                                v1039 = v311[7];
                                v1040 = v311[8];
                                v1041 = v311[9];
                                v1042 = v311[10];
                                v1035 = v311[3];
                                v1036 = v311[4];
                                v1037 = v311[5];
                                v1038 = v311[6];
                                v1032 = *v311;
                                v1033 = v311[1];
                                v255 = v311[2];
                                v1034 = v255;
                                v311 += 11;
                                --v240;
                              }

                              while (v240);
LABEL_427:
                              if (*(v3 + 160))
                              {
                                v312 = 0;
                                v313 = 0;
                                do
                                {
                                  v314 = *(v3 + 168);
                                  v315 = *(v314 + v312 + 12);
                                  v316 = &v1032;
                                  if ((v315 & 0x80000000) == 0 && v315 < v249)
                                  {
                                    v316 = v1012[v315];
                                  }

                                  v317 = *(v314 + v312);
                                  v1026 = 0uLL;
                                  v1027 = 0.0;
                                  if (!v254[v317])
                                  {
                                    v254[v317] = 1;
                                    v318 = *(v1009 + 144) + 12 * v317;
                                    v319 = *v318;
                                    v320 = vcvtq_f64_f32(*(v318 + 4));
                                    v321 = vmulq_f64(*(v1009 + 16), v320);
                                    v255.f64[0] = v321.f64[0] + *(v1009 + 8) * v319 + v321.f64[1] + *(v1009 + 32);
                                    v322 = vmulq_f64(*(v1009 + 48), v320);
                                    v323 = vmulq_f64(*(v1009 + 80), v320);
                                    v255 = mc_uv_model_apply(v316, &v1026, v255, v322.f64[0] + *(v1009 + 40) * v319 + v322.f64[1] + *(v1009 + 64), v323.f64[0] + *(v1009 + 72) * v319 + v323.f64[1] + *(v1009 + 96));
                                    if (v324)
                                    {
                                      v325 = (v256 + 12 * v317);
                                      v255.f64[1] = v1026.f64[1];
                                      *v325 = vcvt_f32_f64(v1026);
                                      *v255.f64 = v1027;
                                      v325[1].i32[0] = LODWORD(v255.f64[0]);
                                    }
                                  }

                                  v326 = v314 + v312;
                                  v327 = *(v326 + 4);
                                  v1026 = 0uLL;
                                  v1027 = 0.0;
                                  if (!v254[v327])
                                  {
                                    v254[v327] = 1;
                                    v328 = *(v1009 + 144) + 12 * v327;
                                    v329 = *v328;
                                    v330 = vcvtq_f64_f32(*(v328 + 4));
                                    v331 = vmulq_f64(*(v1009 + 16), v330);
                                    v255.f64[0] = v331.f64[0] + *(v1009 + 8) * v329 + v331.f64[1] + *(v1009 + 32);
                                    v332 = vmulq_f64(*(v1009 + 48), v330);
                                    v333 = vmulq_f64(*(v1009 + 80), v330);
                                    v255 = mc_uv_model_apply(v316, &v1026, v255, v332.f64[0] + *(v1009 + 40) * v329 + v332.f64[1] + *(v1009 + 64), v333.f64[0] + *(v1009 + 72) * v329 + v333.f64[1] + *(v1009 + 96));
                                    if (v334)
                                    {
                                      v335 = (v256 + 12 * v327);
                                      v255.f64[1] = v1026.f64[1];
                                      *v335 = vcvt_f32_f64(v1026);
                                      *v255.f64 = v1027;
                                      v335[1].i32[0] = LODWORD(v255.f64[0]);
                                    }
                                  }

                                  v336 = *(v326 + 8);
                                  v1026 = 0uLL;
                                  v1027 = 0.0;
                                  v3 = v1009;
                                  if (!v254[v336])
                                  {
                                    v254[v336] = 1;
                                    v337 = *(v1009 + 144) + 12 * v336;
                                    v338 = *v337;
                                    v339 = vcvtq_f64_f32(*(v337 + 4));
                                    v340 = vmulq_f64(*(v1009 + 16), v339);
                                    v255.f64[0] = v340.f64[0] + *(v1009 + 8) * v338 + v340.f64[1] + *(v1009 + 32);
                                    v341 = vmulq_f64(*(v1009 + 48), v339);
                                    v342 = vmulq_f64(*(v1009 + 80), v339);
                                    v255 = mc_uv_model_apply(v316, &v1026, v255, v341.f64[0] + *(v1009 + 40) * v338 + v341.f64[1] + *(v1009 + 64), v342.f64[0] + *(v1009 + 72) * v338 + v342.f64[1] + *(v1009 + 96));
                                    if (v343)
                                    {
                                      v344 = (v256 + 12 * v336);
                                      v255.f64[1] = v1026.f64[1];
                                      *v344 = vcvt_f32_f64(v1026);
                                      *v255.f64 = v1027;
                                      v344[1].i32[0] = LODWORD(v255.f64[0]);
                                    }
                                  }

                                  ++v313;
                                  v312 += 16;
                                }

                                while (v313 < *(v1009 + 160));
                              }

                              v345 = *(v3 + 136);
                              v8 = v999;
                              if (v345)
                              {
                                for (n = 0; n < v345; ++n)
                                {
                                  if (!v254[n])
                                  {
                                    v254[n] = 1;
                                    v256->i32[2] = 1065353216;
                                    v256->i64[0] = 0;
                                    v345 = *(v3 + 136);
                                  }

                                  v256 = (v256 + 12);
                                }
                              }
                            }

                            else
                            {
                              while (1)
                              {
                                v259 = v257[1];
                                if (v259 < 0 || v259 >= v249)
                                {
                                  break;
                                }

                                v1012[v259] = v257;
                                v257 += 44;
                                if (!--v258)
                                {
                                  goto LABEL_427;
                                }
                              }
                            }

                            free(v254);
                            free(v1012);
                            v245 = &xmmword_1B33B2000;
                            v304 = v979;
                            v248 = v975;
                          }

                          else
                          {
                            v995 = 0;
                            v304 = v246;
                          }

                          if (*(v3 + 160))
                          {
                            v347 = 0;
                            v348 = v248 + 2;
                            v349 = (*(v3 + 168) + 8);
                            do
                            {
                              *(v348 - 2) = *(v349 - 2);
                              *(v348 - 1) = *(v349 - 1);
                              v350 = *v349;
                              v349 += 4;
                              *v348 = v350;
                              v348 += 3;
                              ++v347;
                              v351 = *(v3 + 160);
                            }

                            while (v347 < v351);
                          }

                          else
                          {
                            LODWORD(v351) = 0;
                          }

                          if (!mc_encode_decode_predictive(v351, *(v3 + 136), v248, v304, 3u, v21))
                          {
                            free(v995);
                            free(v248);
                            free(v304);
                            goto LABEL_27;
                          }

                          v354 = *(v3 + 136);
                          v355 = *(v3 + 152);
                          if (v354 >= 1)
                          {
                            if (v354 < 4)
                            {
                              v356 = 0;
LABEL_461:
                              v366 = v354 - v356;
                              v367 = 3 * v356;
                              v368 = &v304[12 * v356 + 8];
                              v369 = &v355->i32[v367 + 2];
                              do
                              {
                                v370 = *(v368 - 1);
                                v371.i64[0] = v370;
                                v371.i64[1] = SHIDWORD(v370);
                                *&v352.f64[0] = vcvt_f32_f64(vmulq_f64(v1022, vcvtq_f64_s64(v371)));
                                *(v369 - 1) = *&v352.f64[0];
                                v372 = *v368;
                                v368 += 12;
                                *&v352.f64[1] = SHIDWORD(v352.f64[0]);
                                *v352.f64 = v1001 * v372;
                                *v369 = LODWORD(v352.f64[0]);
                                v369 += 3;
                                --v366;
                              }

                              while (v366);
                              goto LABEL_463;
                            }

                            v356 = v354 & 0x7FFFFFFC;
                            v357 = v304;
                            v358 = *(v3 + 152);
                            v359 = v356;
                            do
                            {
                              v1049 = vld3q_f32(v357);
                              v357 += 12;
                              v360.i64[0] = v1049.val[0].i32[0];
                              v360.i64[1] = v1049.val[0].i32[1];
                              v361 = vcvtq_f64_s64(v360);
                              v360.i64[0] = v1049.val[0].i32[2];
                              v360.i64[1] = v1049.val[0].i32[3];
                              v362 = vmulq_n_f64(vcvtq_f64_s64(v360), v1022.f64[0]);
                              v360.i64[0] = v1049.val[1].i32[0];
                              v360.i64[1] = v1049.val[1].i32[1];
                              v363 = vcvtq_f64_s64(v360);
                              v360.i64[0] = v1049.val[1].i32[2];
                              v360.i64[1] = v1049.val[1].i32[3];
                              v364 = vmulq_laneq_f64(vcvtq_f64_s64(v360), v1022, 1);
                              v360.i64[0] = v1049.val[2].i32[0];
                              v360.i64[1] = v1049.val[2].i32[1];
                              v365 = vcvtq_f64_s64(v360);
                              v360.i64[0] = v1049.val[2].i32[2];
                              v360.i64[1] = v1049.val[2].i32[3];
                              v352 = vmulq_n_f64(vcvtq_f64_s64(v360), v1001);
                              v353 = vmulq_n_f64(v365, v1001);
                              v1056.val[2] = vcvt_hight_f32_f64(vcvt_f32_f64(v353), v352);
                              v1056.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_laneq_f64(v363, v1022, 1)), v364);
                              v1056.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v361, v1022.f64[0])), v362);
                              vst3q_f32(v358, v1056);
                              v358 += 12;
                              v359 -= 4;
                            }

                            while (v359);
                            if (v356 != v354)
                            {
                              goto LABEL_461;
                            }
                          }

LABEL_463:
                          if (!v990)
                          {
                            goto LABEL_469;
                          }

                          if (!v354)
                          {
                            goto LABEL_479;
                          }

                          if (v354 >= 8)
                          {
                            v373 = 0;
                            v389 = 12 * v354 - 8;
                            v390 = v355 + v389;
                            v391 = (v995 + v389);
                            v392 = 12 * v354 - 4;
                            v394 = &v355->i32[1] < (v995 + v392) && &v995->i32[1] < (v355 + v392);
                            v396 = &v355->u32[2] < (v995 + 12 * v354) && &v995->u32[2] < (v355 + 12 * v354);
                            if ((v995 >= v390 || v355 >= v391) && !v394 && !v396)
                            {
                              v373 = v354 & 0xFFFFFFFC;
                              v398 = v355;
                              v399 = v995;
                              v400 = v373;
                              do
                              {
                                v401 = vaddq_f32(v399[2], v398[2]);
                                v353 = vaddq_f32(v399[1], v398[1]);
                                v352 = vaddq_f32(*v399, *v398);
                                *v398 = v352;
                                v398[1] = v353;
                                v398[2] = v401;
                                v399 += 3;
                                v398 += 3;
                                v400 -= 4;
                              }

                              while (v400);
                              if (v373 == v354)
                              {
LABEL_469:
                                if (v354)
                                {
                                  if (v354 >= 4)
                                  {
                                    v378 = v354 & 0xFFFFFFFC;
                                    v379 = v355;
                                    v380 = v378;
                                    do
                                    {
                                      v1050 = vld3q_f32(v379);
                                      __asm { FMOV            V3.4S, #1.0 }

                                      v1055.val[0] = vmaxnmq_f32(vminnmq_f32(v1050.val[0], _Q3), 0);
                                      v1055.val[1] = vmaxnmq_f32(vminnmq_f32(v1050.val[1], _Q3), 0);
                                      v352 = vminnmq_f32(v1050.val[2], vdupq_n_s32(0x461C4000u));
                                      v1055.val[2] = vmaxnmq_f32(v352, 0);
                                      vst3q_f32(v379, v1055);
                                      v379 += 12;
                                      v380 -= 4;
                                    }

                                    while (v380);
                                    if (v378 == v354)
                                    {
                                      goto LABEL_479;
                                    }
                                  }

                                  else
                                  {
                                    v378 = 0;
                                  }

                                  v384 = v354 - v378;
                                  v385 = v355 + 12 * v378;
                                  do
                                  {
                                    v352.f64[0] = *v385;
                                    LODWORD(v352.f64[1]) = *(v385 + 2);
                                    v352 = vmaxnmq_f32(vminnmq_f32(v352, v245[74]), 0);
                                    *(v385 + 2) = LODWORD(v352.f64[1]);
                                    *v385 = v352.f64[0];
                                    v385 += 12;
                                    --v384;
                                  }

                                  while (v384);
                                }

LABEL_479:
                                free(v995);
                                free(v248);
                                free(v304);
                                if (!v983)
                                {
                                  goto LABEL_28;
                                }

                                v386 = *(v3 + 136);
                                if (!v386)
                                {
                                  goto LABEL_28;
                                }

                                v387 = *(v3 + 152);
                                if (v386 == 1)
                                {
                                  v388 = 0;
                                }

                                else
                                {
                                  v388 = v386 & 0xFFFFFFFE;
                                  v402 = (v387 + 20);
                                  v403 = v388;
                                  do
                                  {
                                    *(v402 - 3) = 1065353216;
                                    *v402 = 1065353216;
                                    v402 += 6;
                                    v403 -= 2;
                                  }

                                  while (v403);
                                  if (v388 == v386)
                                  {
                                    goto LABEL_28;
                                  }
                                }

                                v404 = v386 - v388;
                                v405 = (v387 + 12 * v388 + 8);
                                do
                                {
                                  *v405 = 1065353216;
                                  v405 += 3;
                                  --v404;
                                }

                                while (v404);
LABEL_28:
                                free(v20);
                                v22 = v21;
                                goto LABEL_29;
                              }
                            }
                          }

                          else
                          {
                            v373 = 0;
                          }

                          v374 = v354 - v373;
                          v375 = 12 * v373;
                          v376 = v995 + 12 * v373;
                          v377 = v355 + v375;
                          do
                          {
                            v352.f64[0] = *v377;
                            LODWORD(v352.f64[1]) = *(v377 + 2);
                            v353.f64[0] = *v376;
                            LODWORD(v353.f64[1]) = *(v376 + 2);
                            v352 = vaddq_f32(v353, v352);
                            *(v377 + 2) = LODWORD(v352.f64[1]);
                            *v377 = v352.f64[0];
                            v377 += 12;
                            v376 += 12;
                            --v374;
                          }

                          while (v374);
                          goto LABEL_469;
                        }
                      }
                    }

                    else
                    {
                      v128 = 0;
                    }

                    v129 = &v21->i32[v128];
                    v130 = &v125[3 * v128 + 2];
                    v131 = v124 - v128;
                    do
                    {
                      *(v130 - 2) = *v129;
                      *(v130 - 1) = v129[v124];
                      *v130 = v129[2 * v124];
                      v130 += 3;
                      ++v129;
                      --v131;
                    }

                    while (v131);
                    goto LABEL_199;
                  }

                  v115 = *(v3 + 136);
                  v116 = 8 * v115;
                  v117 = malloc_type_malloc(8 * v115, 0x100004052888210uLL);
                  v118 = v117;
                  if (v115 >= 1)
                  {
                    if (v115 >= 8)
                    {
                      v119 = 0;
                      v266 = (v117 + 4 * v115);
                      v268 = v117 < (v21 + v116) && v21 < v266;
                      if ((v21 >= (v117 + v116) || v266 >= (v21 + v116)) && !v268)
                      {
                        v119 = v115 & 0x7FFFFFF8;
                        f32 = v21[2].f32;
                        v271 = v119;
                        v272 = v117;
                        do
                        {
                          v273 = f32 - 8;
                          v1044 = vld2q_f32(v273);
                          v1045 = vld2q_f32(f32);
                          *v272 = v1044.val[0];
                          v272[1] = v1045.val[0];
                          v274 = (v272 + 4 * v115);
                          *v274 = v1044.val[1];
                          v274[1] = v1045.val[1];
                          f32 += 16;
                          v272 += 2;
                          v271 -= 8;
                        }

                        while (v271);
                        if (v119 == v115)
                        {
                          goto LABEL_193;
                        }
                      }
                    }

                    else
                    {
                      v119 = 0;
                    }

                    v120 = v115 - v119;
                    v121 = &v117->i32[v119];
                    v122 = &v21->i32[2 * v119 + 1];
                    do
                    {
                      *v121 = *(v122 - 1);
                      v123 = *v122;
                      v122 += 2;
                      v121[v115] = v123;
                      ++v121;
                      --v120;
                    }

                    while (v120);
                  }

LABEL_193:
                  memcpy(v21, v117, 8 * v115);
                  free(v118);
                  goto LABEL_194;
                }

                *v8 = 0;
LABEL_394:
                v105 = 0;
                v106.f64[1] = 0.0;
                goto LABEL_395;
              }

              *v8 = 0;
LABEL_393:
              v106.f64[0] = 0.0;
              goto LABEL_394;
            }

            *v8 = 0;
          }

          v279 = 0;
          goto LABEL_393;
        }

        v1032 = v12;
        v1033.f64[1] = v12.f64[1];
        v1033.f64[0] = v23;
        if (*&v23 == *(v8 + 3))
        {
          v22 = 0;
          LODWORD(v1032.f64[0]) = -1;
LABEL_147:
          *v8 = 0;
          goto LABEL_29;
        }

        mc_read_chunk_header(v8, &v1032);
        v22 = 0;
        v74 = *(v8 + 4);
        v1033.f64[1] = v74;
        if (LODWORD(v1032.f64[0]) != 8 || WORD2(v1032.f64[0]) > 1u)
        {
          goto LABEL_147;
        }

        if (!*v8)
        {
          goto LABEL_175;
        }

        v75 = *&v74 + 4;
        v76 = *(v8 + 3);
        if (*&v74 + 4 > v76 || (v77 = *(v8 + 1), v78 = *(v77 + *&v74), *(v8 + 4) = v75, v79 = *&v74 + 8, *&v74 + 8 > v76) || (LODWORD(v73) = *(v77 + v75), *(v8 + 4) = v79, v80 = *&v74 + 12, (*&v74 + 12) > *(v8 + 3)) || (v81 = *(*(v8 + 1) + v79), *(v8 + 4) = v80, v82 = *&v74 + 16, (*&v74 + 16) > *(v8 + 3)) || (v83 = *(*(v8 + 1) + v80), *(v8 + 4) = v82, v84 = *&v74 + 24, v85 = *(v8 + 3), *&v74 + 24 > v85) || (v86 = *(v8 + 1), v87 = *(v86 + v82), *(v8 + 4) = v84, v88 = *&v74 + 32, *&v74 + 32 > v85) || (v89 = *(v86 + v84), *(v8 + 4) = v88, (*&v74 + 40) > *(v8 + 3)))
        {
          v22 = 0;
          goto LABEL_147;
        }

        v1005 = v81;
        v980 = v89;
        v984 = v87;
        v996 = *&v73;
        *&v73 = *(*(v8 + 1) + v88);
        v976 = v73;
        *(v8 + 4) = *&v74 + 40;
        v406 = 16 * v78;
        v407 = malloc_type_malloc(16 * v78, 0x100004052888210uLL);
        mc_read_tiny_big(v999, 4 * v78, v407);
        v408 = 0.0;
        if (*v999)
        {
          v409 = *(v999 + 32);
          v410 = v409 + 4;
          if ((v409 + 4) <= *(v999 + 24))
          {
            v408 = *(*(v999 + 8) + v409);
            if (*(v999 + 24) >= *&v1032.f64[1] + *&v74)
            {
              v410 = *&v1032.f64[1] + *&v74;
            }

            *(v999 + 32) = v410;
          }

          else
          {
            *v999 = 0;
          }
        }

        v439 = malloc_type_malloc(16 * v78, 0x100004052888210uLL);
        v440 = v407;
        if (v78 >= 1)
        {
          v441 = 3 * v78;
          if (v78 >= 8)
          {
            v442 = 0;
            v464 = &v439[v406 / 4];
            v465 = &v407->f32[2 * v78];
            v466 = &v407->f32[v78];
            v468 = v439 < &v407->f32[v441] && v465 < v464;
            v470 = v439 < v465 && v466 < v464;
            v472 = v439 < v466 && v407 < v464;
            v473 = (v407 + v441 * 4) >= v464 || v439 >= v407[v406 / 0x10].f32;
            if (!v473 || v468 || v470)
            {
              v440 = v407;
              v14 = 1.0;
              v15 = 1.0;
            }

            else
            {
              v440 = v407;
              v14 = 1.0;
              v15 = 1.0;
              if (!v472)
              {
                v442 = v78 & 0x7FFFFFFC;
                v474 = v442;
                v475 = v439;
                v476 = v407;
                do
                {
                  v1060.val[0] = *v476;
                  v1060.val[1] = *(v476 + 4 * v78);
                  v1060.val[2] = *(v476 + 8 * v78);
                  v1060.val[3] = *(v476 + 12 * v78);
                  vst4q_f32(v475, v1060);
                  v475 += 16;
                  ++v476;
                  v474 -= 4;
                }

                while (v474);
                v440 = v407;
                v14 = 1.0;
                v15 = 1.0;
                if (v442 == v78)
                {
                  goto LABEL_560;
                }
              }
            }
          }

          else
          {
            v442 = 0;
          }

          v443 = &v440->i8[4 * v442];
          v444 = &v439[4 * v442 + 2];
          v445 = v78 - v442;
          do
          {
            *(v444 - 2) = *v443;
            *(v444 - 1) = *&v443[4 * v78];
            *v444 = *&v443[8 * v78];
            v444[1] = *&v443[12 * v78];
            v443 += 4;
            v444 += 4;
            --v445;
          }

          while (v445);
        }

LABEL_560:
        memcpy(v440, v439, 16 * v78);
        free(v439);
        v446 = malloc_type_malloc(4 * (3 * *(v1009 + 160)), 0x100004052888210uLL);
        v447 = v446;
        if (*(v1009 + 160))
        {
          v448 = 0;
          v449 = v446 + 8;
          v450 = (*(v1009 + 168) + 8);
          v8 = v999;
          do
          {
            *(v449 - 2) = *(v450 - 2);
            *(v449 - 1) = *(v450 - 1);
            v451 = *v450;
            v450 += 4;
            *v449 = v451;
            v449 += 3;
            ++v448;
            v452 = *(v1009 + 160);
          }

          while (v448 < v452);
        }

        else
        {
          LODWORD(v452) = 0;
          v8 = v999;
        }

        v453 = mc_encode_decode_predictive(v452, *(v1009 + 136), v447, v407, 4u, v407);
        free(v447);
        v454 = malloc_type_malloc(4 * *(v1009 + 136), 0x100004052888210uLL);
        *&v455 = v408;
        v992 = v455;
        v1016 = v15 / v1005;
        v456 = cbrt(v1016 * (*&v455 + *&v455));
        v458.i32[3] = HIDWORD(v992);
        v459 = v996;
        v460 = v1005;
        v461 = *(v1009 + 136);
        if (v461)
        {
          v462 = *(v1009 + 144);
          if (v408 == 0.0)
          {
            *&v456 = v14 / (v83 * v83);
            if (v461 < 4)
            {
              v463 = 0;
              goto LABEL_634;
            }

            if (v462 < v454->u64 + 4 * v461 && v454 < v462 + 12 * v461)
            {
              v463 = 0;
              v8 = v999;
              v14 = 1.0;
              v15 = 1.0;
              v459 = v996;
              v460 = v1005;
LABEL_634:
              v520 = v461 - v463;
              v521 = &v454->f32[v463];
              v522 = v462 + 12 * v463;
              v523 = &v407[v463];
              do
              {
                v458.i64[0] = v523->i64[0];
                v458.i32[2] = v523->i32[2];
                v458 = vmulq_n_f32(vcvtq_f32_s32(v458), v459);
                *(v522 + 8) = v458.i32[2];
                *v522 = v458.i64[0];
                v522 += 12;
                *v521++ = v14 / fmaxf(v460 * v523->i32[3], *&v456);
                ++v523;
                --v520;
              }

              while (v520);
              goto LABEL_636;
            }

            v463 = v461 & 0xFFFFFFFC;
            v458 = vdupq_lane_s32(*&v456, 0);
            v505 = v407;
            v506 = *(v1009 + 144);
            v507 = v454;
            v508 = v463;
            v459 = v996;
            v460 = v1005;
            do
            {
              v510 = v505[2];
              v509 = v505[3];
              v511 = vzip2q_s32(v510, v509);
              v512 = vzip1q_s32(v510, v509);
              v513 = vextq_s8(v510, v512, 8uLL);
              v510.i32[3] = v505[3].i64[1];
              v515 = *v505;
              v514 = v505[1];
              v505 += 4;
              v516.i64[0] = vzip2q_s32(v515, v514).u64[0];
              v516.i64[1] = v510.i64[1];
              v517 = vuzp2q_s32(v515, v514);
              v518.i64[0] = vtrn2q_s32(v515, v514).u64[0];
              v518.i64[1] = v512.i64[1];
              v514.i64[0] = vzip1q_s32(v515, v514).u64[0];
              v514.i64[1] = v513.i64[1];
              v1059.val[2] = vmulq_n_f32(vcvtq_f32_s32(v516), v996);
              v1059.val[1] = vmulq_n_f32(vcvtq_f32_s32(v518), v996);
              v1059.val[0] = vmulq_n_f32(vcvtq_f32_s32(v514), v996);
              vst3q_f32(v506, v1059);
              v506 += 12;
              v514.i64[0] = vuzp2q_s32(v517, v515).u64[0];
              v514.i64[1] = v511.i64[1];
              __asm { FMOV            V3.4S, #1.0 }

              *v507++ = vdivq_f32(_Q3, vmaxnmq_f32(vmulq_n_f32(vcvtq_f32_s32(v514), v1005), v458));
              v508 -= 4;
            }

            while (v508);
            v8 = v999;
            v14 = 1.0;
            v15 = 1.0;
            if (v463 != v461)
            {
              goto LABEL_634;
            }
          }

          else
          {
            v477 = v1016 / (v456 * v456) + v456 / *&v992;
            v478 = -v456;
            *&v479 = v83;
            if (v461 <= 3 || v462 < v454->u64 + 4 * v461 && v454 < v462 + 12 * v461)
            {
              v480 = 0;
              v8 = v999;
              v14 = 1.0;
              v15 = 1.0;
              v481 = v996;
LABEL_604:
              v482 = v461 - v480;
              v483 = &v454->i32[v480];
              v484 = v462 + 12 * v480;
              v485 = &v407[v480];
              while (2)
              {
                *&v457.f64[0] = v485->i64[0];
                LODWORD(v457.f64[1]) = v485->i32[2];
                v457 = vmulq_n_f32(vcvtq_f32_s32(v457), v481);
                *(v484 + 8) = LODWORD(v457.f64[1]);
                *v484 = v457.f64[0];
                v491 = v485->i32[3];
                v457.f64[0] = v491 * *&v992;
                if (v491 * *&v992 < v478)
                {
                  v486 = v1016 / (v477 + v491);
                  v487 = -sqrt(v486);
                  v488 = v486 <= 0.0;
                  v489 = 0xFFF0000000000000;
LABEL_606:
                  *&v457.f64[0] = v489;
                  if (!v488)
                  {
                    v457.f64[0] = v487;
                  }
                }

                else if (v457.f64[0] > v456)
                {
                  v492 = v1016 / (v477 - v491);
                  v487 = sqrt(v492);
                  v488 = v492 <= 0.0;
                  v489 = 0x7FF0000000000000;
                  goto LABEL_606;
                }

                ++v485;
                v490 = fmin(v457.f64[0], *&v479);
                *&v490 = v490 * v490;
                *v483++ = LODWORD(v490);
                v484 += 12;
                if (!--v482)
                {
                  goto LABEL_636;
                }

                continue;
              }
            }

            v480 = v461 & 0xFFFFFFFC;
            v457 = vdupq_lane_s64(*&v478, 0);
            v630 = vdupq_lane_s64(*&v456, 0);
            v631 = vdupq_lane_s64(*&v477, 0);
            v632 = vdupq_lane_s64(*&v1016, 0);
            v633 = v407;
            v634 = *(v1009 + 144);
            v635 = v454;
            v636 = vdupq_lane_s64(v479, 0);
            v637 = v480;
            v481 = v996;
            do
            {
              v639 = v633[2];
              v638 = v633[3];
              v640 = vzip2q_s32(v639, v638);
              v641 = vzip1q_s32(v639, v638);
              v642 = vextq_s8(v639, v641, 8uLL);
              v639.i32[3] = v633[3].i64[1];
              v643 = *v633;
              v644 = v633[1];
              v633 += 4;
              v645.i64[0] = vzip2q_s32(v643, v644).u64[0];
              v646.i64[0] = vuzp2q_s32(vuzp2q_s32(v643, v644), v643).u64[0];
              v645.i64[1] = v639.i64[1];
              v646.i64[1] = v640.i64[1];
              v639.i64[0] = vtrn2q_s32(v643, v644).u64[0];
              v639.i64[1] = v641.i64[1];
              v643.i64[0] = vzip1q_s32(v643, v644).u64[0];
              v643.i64[1] = v642.i64[1];
              v1058.val[2] = vmulq_n_f32(vcvtq_f32_s32(v645), v996);
              v1058.val[1] = vmulq_n_f32(vcvtq_f32_s32(v639), v996);
              v647 = vcvtq_f32_s32(v646);
              v648 = vcvt_hight_f64_f32(v647);
              v649 = vcvtq_f64_f32(*v647.f32);
              v650 = vmulq_n_f64(v649, *&v992);
              v1058.val[0] = vmulq_n_f32(vcvtq_f32_s32(v643), v996);
              v651 = vmulq_n_f64(v648, *&v992);
              *v646.i8 = vmovn_s32(vuzp1q_s32(vcgeq_f64(v650, v457), vcgeq_f64(v651, v457)));
              v652 = vdivq_f64(v632, vsubq_f64(v631, v648));
              v653 = vmovn_s32(vuzp1q_s32(vcgtq_f64(v650, v630), vcgtq_f64(v651, v630)));
              v654 = vdivq_f64(v632, vsubq_f64(v631, v649));
              v655 = vand_s8(*v646.i8, v653);
              v656 = vdupq_n_s64(0x7FF0000000000000uLL);
              v657 = vdivq_f64(v632, vaddq_f64(v631, v648));
              v658 = vdivq_f64(v632, vaddq_f64(v631, v649));
              v659 = vdupq_n_s64(0xFFF0000000000000);
              *v646.i8 = vbic_s8(*v646.i8, v653);
              v660 = vmovl_u16(v655);
              v661.i64[0] = v660.u32[0];
              v661.i64[1] = v660.u32[1];
              v662 = vbslq_s8(vcltzq_s64(vshlq_n_s64(v661, 0x3FuLL)), vbslq_s8(vcgtzq_f64(v654), vsqrtq_f64(v654), v656), vbslq_s8(vcgtzq_f64(v658), vnegq_f64(vsqrtq_f64(v658)), v659));
              v661.i64[0] = v660.u32[2];
              v661.i64[1] = v660.u32[3];
              v663 = vcltzq_s64(vshlq_n_s64(v661, 0x3FuLL));
              v664 = vmovl_u16(*v646.i8);
              v661.i64[0] = v664.u32[2];
              v661.i64[1] = v664.u32[3];
              v665 = vbslq_s8(v663, vbslq_s8(vcgtzq_f64(v652), vsqrtq_f64(v652), v656), vbslq_s8(vcgtzq_f64(v657), vnegq_f64(vsqrtq_f64(v657)), v659));
              v666 = vcltzq_s64(vshlq_n_s64(v661, 0x3FuLL));
              v661.i64[0] = v664.u32[0];
              v661.i64[1] = v664.u32[1];
              v667 = vminnmq_f64(vbslq_s8(vcltzq_s64(vshlq_n_s64(v661, 0x3FuLL)), v650, v662), v636);
              v668 = vminnmq_f64(vbslq_s8(v666, v651, v665), v636);
              vst3q_f32(v634, v1058);
              v634 += 12;
              *v635++ = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_f64(v667, v667)), vmulq_f64(v668, v668));
              v637 -= 4;
            }

            while (v637);
            v8 = v999;
            v14 = 1.0;
            v15 = 1.0;
            if (v480 != v461)
            {
              goto LABEL_604;
            }
          }
        }

LABEL_636:
        v524 = *(v1009 + 136);
        if (!v524)
        {
          goto LABEL_643;
        }

        v970 = v13;
        v972 = v11;
        _Q3 = *(v1009 + 104);
        _Q6 = *(v1009 + 120);
        _Q4 = vmlsq_lane_f64(*(v1009 + 8), _Q3, v984, 0);
        _Q16 = vmlsq_lane_f64(*(v1009 + 24), _Q6, v984, 0);
        _Q7 = vmlsq_lane_f64(*(v1009 + 40), _Q3, v980, 0);
        v530 = vmlsq_lane_f64(*(v1009 + 56), _Q6, v980, 0);
        v531.f64[1] = *(&v976 + 1);
        _Q2 = vmlsq_lane_f64(*(v1009 + 72), _Q3, *&v976, 0);
        _Q5 = vmlsq_lane_f64(*(v1009 + 88), _Q6, *&v976, 0);
        v534 = vextq_s8(_Q6, _Q6, 8uLL);
        _D1 = *(v1009 + 128);
        v536.f64[0] = vmuld_lane_f64(v530.f64[0], _Q5, 1);
        v537 = vmuld_lane_f64(_Q5.f64[0], _Q3, 1);
        _D17 = vmuld_lane_f64(_Q2.f64[0], _Q7, 1);
        __asm
        {
          FMLA            D24, D17, V6.D[1]
          FMLS            D10, D1, V4.D[1]
        }

        _Q22 = vmulq_n_f64(vextq_s8(_Q3, _Q7, 8uLL), _Q16.f64[0]);
        _Q27 = vmulq_laneq_f64(vextq_s8(_Q2, _Q7, 8uLL), _Q16, 1);
        _Q13 = vmulq_f64(v534, _Q5);
        v544 = vzip2q_s64(v530, _Q6);
        v545.f64[0] = v530.f64[0];
        v545.f64[1] = _Q5.f64[1];
        v546 = vmulq_f64(vzip1q_s64(_Q3, _Q4), v545);
        v1007 = v537 * _Q7.f64[0] + v546.f64[0] * _Q2.f64[1] + (_D17 - _Q2.f64[1] * _Q7.f64[0]) * _Q6.f64[0];
        v547.f64[0] = *(v1009 + 120);
        v547.f64[1] = _Q2.f64[1];
        v536.f64[1] = _D10;
        v548 = vmulq_f64(vextq_s8(_Q2, _Q16, 8uLL), v547);
        v549 = vmlaq_f64(vmlaq_f64(vmulq_f64(_Q13, vzip2q_s64(_Q7, _Q4)), v544, v548), vextq_s8(_Q3, _Q5, 8uLL), v536);
        v550 = vdupq_lane_s64(*&_Q22.f64[0], 0);
        v550.f64[0] = v537;
        _Q10 = vmulq_f64(vextq_s8(_Q4, _Q16, 8uLL), vextq_s8(v530, _Q2, 8uLL));
        _Q15 = vmulq_f64(vzip1q_s64(v530, _Q16), vextq_s8(_Q6, _Q3, 8uLL));
        _Q9 = vmulq_f64(vextq_s8(_Q16, _Q4, 8uLL), vzip2q_s64(_Q7, v530));
        v554 = vmulq_f64(_Q22, v544);
        _D30 = _Q9.f64[1] - _Q27.f64[1];
        v556 = vmulq_f64(_Q15, vzip2q_s64(_Q4, v530));
        *&v536.f64[0] = *&vaddq_f64(v554, v556);
        v557 = vsubq_f64(v554, v556);
        _Q14 = vmulq_f64(_Q10, _Q6);
        v536.f64[1] = v557.f64[1];
        v557.f64[0] = _Q9.f64[0];
        v557.f64[1] = _Q9.f64[1] - _Q27.f64[1];
        v559 = vmlaq_n_f64(v536, v557, _Q6.f64[0]);
        _D1 = vmuld_lane_f64(_Q3.f64[0], v530, 1);
        v561 = vmulq_f64(_Q13, _Q7);
        *v561.i64 = *&v561.i64[1] + vmuld_lane_f64(_Q2.f64[1], _Q6, 1) * v530.f64[0];
        v562 = vzip1q_s64(v561, vmulq_f64(_Q27, _Q6));
        v563 = vzip2q_s64(v530, _Q5);
        v564 = vmlaq_f64(v562, v563, v550);
        v563.f64[0] = _D1 - *(v1009 + 128) * _Q7.f64[0];
        _Q12 = vzip1q_s64(v563, vmulq_f64(_Q4, _Q5));
        v563.f64[0] = _Q2.f64[0];
        v563.f64[1] = _Q16.f64[1];
        _Q15.f64[0] = vmuld_lane_f64(_Q7.f64[0], _Q5, 1);
        _Q25 = vmulq_f64(v563, vzip1q_s64(v530, _Q2));
        v563.f64[0] = *(v1009 + 120);
        v563.f64[1] = _Q5.f64[1];
        _Q13.f64[0] = _Q5.f64[0];
        _Q13.f64[1] = *(v1009 + 128);
        v567 = vmlaq_f64(vmulq_f64(_Q15, v563), v534, _Q25);
        _Q15.f64[0] = *(v1009 + 112);
        v568 = vmlaq_f64(v567, _Q13, _Q12);
        _Q12.f64[0] = vmuld_lane_f64(_Q2.f64[0], v530, 1);
        __asm { FMLA            D24, D1, V2.D[1] }

        _D1 = vmuld_lane_f64(_Q3.f64[0], _Q7, 1);
        __asm
        {
          FMLA            D20, D12, V3.D[1]
          FMLA            D20, D1, V5.D[1]
        }

        v573.f64[0] = _D20 - _D24;
        v534.f64[0] = _Q5.f64[0];
        v534.f64[1] = v530.f64[1];
        v574 = vmlaq_f64(vmulq_f64(_Q10, v534), vzip1q_s64(v530, _Q5), _Q27);
        __asm { FMLA            D24, D15, V27.D[1] }

        _Q27.f64[0] = vmuld_lane_f64(_Q4.f64[0], _Q7, 1);
        __asm { FMLA            D24, D27, V6.D[1] }

        _D23 = vmuld_lane_f64(_Q7.f64[0], _Q4, 1) - _Q27.f64[0];
        _Q27.f64[0] = vmuld_lane_f64(_Q3.f64[0], _Q16, 1);
        __asm
        {
          FMLA            D18, D27, V7.D[1]
          FMLA            D18, D15, V9.D[1]
        }

        _Q13.f64[0] = vmuld_lane_f64(_Q16.f64[0], _Q7, 1);
        __asm { FMLA            D14, D13, V6.D[1] }

        _Q13.f64[0] = _Q13.f64[0] - v530.f64[0] * _Q4.f64[1];
        *&v548.f64[0] = vdupq_laneq_s64(vmulq_f64(v548, v530), 1).u64[0];
        v548.f64[1] = COERCE_DOUBLE(*&vmulq_f64(_Q22, _Q5).f64[1]) + _Q25.f64[1] * v530.f64[0];
        v580 = vmlaq_n_f64(v548, _Q9, _Q5.f64[0]);
        v581 = vmlaq_laneq_f64(v574, vzip1q_s64(_Q13, vmulq_f64(_Q4, v530)), _Q5, 1);
        _Q22.f64[0] = vmuld_lane_f64(_Q2.f64[0], _Q4, 1);
        __asm { FMLA            D10, D22, V6.D[1] }

        _Q7.f64[0] = _Q7.f64[1];
        __asm
        {
          FMLA            D22, D7, V25.D[1]
          FMLA            D22, D23, V5.D[1]
        }

        _Q7.f64[0] = _Q12.f64[0] * _Q6.f64[0];
        _D23 = _Q27.f64[0] - _Q13.f64[1] * _Q4.f64[0];
        _Q7.f64[1] = _Q14.f64[1] + _Q27.f64[0] * _Q5.f64[0];
        v583 = vsubq_f64(v568, vmlaq_f64(_Q7, vextq_s8(_Q5, _Q6, 8uLL), v546));
        _Q5.f64[0] = v1007 - (vmuld_lane_f64(_Q25.f64[0], _Q3, 1) + _D1 * _Q5.f64[0]);
        __asm { FMLA            D4, D5, V16.D[1] }

        v531.f64[0] = _Q14.f64[0] + vmuld_lane_f64(_Q16.f64[1], _Q3, 1) * v530.f64[0];
        __asm
        {
          FMLA            D22, D30, V2.D[1]
          FMLA            D3, D23, V2.D[1]
        }

        v573.f64[1] = _Q3.f64[0];
        *&_Q2.f64[0] = *&vsubq_f64(v559, v531);
        v531.f64[1] = _D23 * v530.f64[0];
        _Q2.f64[1] = vaddq_f64(v559, v531).f64[1];
        __asm { FMOV            V5.2D, #1.0 }

        v585 = vdivq_f64(_Q5, vdupq_lane_s64(*&_Q4.f64[0], 0));
        v586 = vmulq_f64(vsubq_f64(v549, v564), v585);
        v587 = vmulq_f64(v583, v585);
        v588 = vmulq_f64(_Q2, v585);
        v589 = vmulq_f64(vsubq_f64(v581, v580), v585);
        v590 = vmulq_f64(v573, v585);
        v591 = (_D24 - _D18) / _Q4.f64[0];
        v592 = _Q22.f64[0] / _Q4.f64[0];
        v593 = *(v1009 + 144);
        if (v524 == 1 || v593 < v454->u64 + 4 * v524 && v454 < v593 + 12 * v524)
        {
          v594 = 0;
          v11 = v972;
          v13 = v970;
          v14 = 1.0;
          v15 = 1.0;
LABEL_641:
          v595 = vzip1q_s64(v586, v587);
          v596 = vzip2q_s64(v586, v587);
          v597 = v524 - v594;
          v598 = &v454->f32[v594];
          v599 = (v593 + 12 * v594 + 8);
          do
          {
            v600 = *(v599 - 2);
            v601 = *(v599 - 1);
            v602 = *v599;
            v603 = *v598++;
            v604 = sqrt(v603 / (v601 * v601 + v600 * v600 + v602 * v602));
            v605 = v604 * v600;
            v606 = v604 * v601;
            v607 = v604 * v602;
            *(v599 - 1) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v589, v595, v605), v596, v606), v588, v607));
            *&v605 = v592 + v605 * *v590.i64 + v606 * *&v590.i64[1] + v607 * v591;
            *v599 = *&v605;
            v599 += 3;
            --v597;
          }

          while (v597);
          goto LABEL_643;
        }

        v608 = vdupq_lane_s64(v586.i64[0], 0);
        v609 = vdupq_laneq_s64(v586, 1);
        v610 = vdupq_lane_s64(*&v588.f64[0], 0);
        v611 = vdupq_lane_s64(*&v589.f64[0], 0);
        v612 = vdupq_lane_s64(v587.i64[0], 0);
        v613 = vdupq_laneq_s64(v587, 1);
        v614 = vdupq_laneq_s64(v588, 1);
        v615 = vdupq_laneq_s64(v589, 1);
        v616 = vdupq_lane_s64(v590.i64[0], 0);
        v617 = vdupq_laneq_s64(v590, 1);
        v618 = vdupq_lane_s64(*&v591, 0);
        v594 = v524 & 0xFFFFFFFE;
        v619 = v594;
        v620 = v454;
        v621 = *(v1009 + 144);
        v622 = vdupq_lane_s64(*&v592, 0);
        do
        {
          v1046 = vld3_f32(v621);
          v623 = vcvtq_f64_f32(v1046.val[0]);
          v624 = vcvtq_f64_f32(v1046.val[1]);
          *v1046.val[0].f32 = vcvtq_f64_f32(v1046.val[2]);
          v625 = *v620++;
          *v1046.val[1].f32 = vsqrtq_f64(vdivq_f64(vcvtq_f64_f32(v625), vmlaq_f64(vmlaq_f64(vmulq_f64(v624, v624), v623, v623), *v1046.val[0].f32, *v1046.val[0].f32)));
          *v1046.val[2].f32 = vmulq_f64(*v1046.val[1].f32, v623);
          v626 = vmulq_f64(*v1046.val[1].f32, v624);
          *v1046.val[0].f32 = vmulq_f64(*v1046.val[1].f32, *v1046.val[0].f32);
          v627 = vmlaq_f64(vmlaq_f64(vmlaq_f64(v615, v612, *v1046.val[2].f32), v613, v626), v614, *v1046.val[0].f32);
          v628 = vmlaq_f64(vmlaq_f64(vmlaq_f64(v622, v616, *v1046.val[2].f32), v617, v626), v618, *v1046.val[0].f32);
          v1046.val[0] = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(v611, v608, *v1046.val[2].f32), v609, v626), v610, *v1046.val[0].f32));
          v1046.val[1] = vcvt_f32_f64(v627);
          v1046.val[2] = vcvt_f32_f64(v628);
          vst3_f32(v621, v1046);
          v621 += 6;
          v619 -= 2;
        }

        while (v619);
        v8 = v999;
        v11 = v972;
        v13 = v970;
        v14 = 1.0;
        v15 = 1.0;
        if (v594 != v524)
        {
          goto LABEL_641;
        }

LABEL_643:
        free(v454);
        v22 = v407;
        v3 = v1009;
        if (!v453)
        {
          goto LABEL_147;
        }

LABEL_29:
        free(v22);
        v12 = 0uLL;
      }
    }

    if (!v1024 || !v26)
    {
      goto LABEL_1030;
    }

    switch(v1020)
    {
      case 0:
        goto LABEL_1001;
      case 1:
        v1025 = 1;
        break;
      case 2:
        v1025 = 0;
        break;
      default:
        goto LABEL_1029;
    }

    v758 = *(v3 + 160);
    v759 = *(v3 + 136);
    v760 = malloc_type_malloc(12 * v758, 0x100004052888210uLL);
    v761 = malloc_type_malloc(4 * (3 * *(v3 + 160)), 0x100004052888210uLL);
    v762 = v761;
    if (*(v3 + 160))
    {
      v763 = 0;
      v764 = v761 + 8;
      v765 = (*(v3 + 168) + 8);
      do
      {
        *(v764 - 2) = *(v765 - 2);
        *(v764 - 1) = *(v765 - 1);
        v766 = *v765;
        v765 += 4;
        *v764 = v766;
        v764 += 3;
        ++v763;
        v767 = *(v3 + 160);
      }

      while (v763 < v767);
    }

    else
    {
      LODWORD(v767) = 0;
    }

    v768 = v11 * v11;
    mc_create_corner_table(v767, *(v3 + 136), v762, v760, 0);
    free(v762);
    v769 = 0;
    v770 = 10;
LABEL_843:
    v771 = *(v3 + 160);
    if (v769 >= v771)
    {
      goto LABEL_983;
    }

    v772 = 0;
    v998 = v770;
    v993 = v770 - 1;
    v773 = v769;
    v774 = *(v3 + 168);
    v1008 = *(v3 + 160);
    while (1)
    {
      v775 = &v774[4 * v773];
      v776 = *v775;
      if (*v775 != -1)
      {
        v777 = v775[1];
        if (v777 != -1)
        {
          v778 = v775[2];
          v779 = v777 == v778 || v776 == v778;
          v780 = v779 || v776 == v777;
          if (!v780 && v778 != -1)
          {
            v782 = *(v3 + 144);
            if (v1025)
            {
              v783 = &v782[12 * v777];
              v784 = &v782[12 * v778];
              v785 = *v783;
              v786 = v783[1];
              v787 = v784[1];
              v788 = v783[2];
              v789 = v784[2];
              v790 = (((*v783 - *v784) * (*v783 - *v784)) + ((v786 - v787) * (v786 - v787))) + ((v788 - v789) * (v788 - v789));
              v791 = (v790 <= v768 || v790 <= 0.0) << 31 >> 31;
              if (v790 <= v768 || v790 <= 0.0)
              {
                v790 = 0.0;
              }

              v792 = &v782[12 * v776];
              v793 = *v792;
              v794 = v792[1];
              v795 = ((*v784 - *v792) * (*v784 - *v792)) + ((v787 - v794) * (v787 - v794));
              v796 = v792[2];
              v797 = v795 + ((v789 - v796) * (v789 - v796));
              LODWORD(v792) = v797 > v768;
              v798 = v797 > v790;
              v799 = (v792 & v798) == 0;
              if ((v792 & v798) != 0)
              {
                v800 = 1;
              }

              else
              {
                v800 = v791;
              }

              if (v799)
              {
                v797 = v790;
              }

              v801 = (((v793 - v785) * (v793 - v785)) + ((v794 - v786) * (v794 - v786))) + ((v796 - v788) * (v796 - v788));
              if (v801 > v768 && v801 > v797)
              {
                goto LABEL_878;
              }
            }

            else
            {
              v802 = &v782[12 * v776];
              v803 = v802[1];
              v804 = v802[2];
              v805 = sqrt((((*v802 * *v802) + (v803 * v803)) + (v804 * v804))) + 0.000001;
              v806 = 1.0 / v805;
              v807 = *v802 * (1.0 / v805);
              v808 = v803 * v806;
              v809 = v804 * v806;
              v810 = &v782[12 * v777];
              v811 = v810[1];
              v812 = v810[2];
              v813 = sqrt((((*v810 * *v810) + (v811 * v811)) + (v812 * v812))) + 0.000001;
              v814 = 1.0 / v813;
              v815 = *v810 * v814;
              v816 = v811 * v814;
              v817 = v812 * v814;
              v818 = &v782[12 * v778];
              v819 = v818[1];
              v820 = v818[2];
              v821 = sqrt((((*v818 * *v818) + (v819 * v819)) + (v820 * v820))) + 0.000001;
              v822 = 1.0 / v821;
              v823 = *v818 * v822;
              v824 = v819 * v822;
              v825 = v820 * v822;
              v826 = (((v815 - v823) * (v815 - v823)) + ((v816 - v824) * (v816 - v824))) + ((v817 - v825) * (v817 - v825));
              v827 = v826 <= v768 || v826 <= 0.0;
              if (v827)
              {
                v826 = 0.0;
              }

              v800 = v827 << 31 >> 31;
              v828 = (((v823 - v807) * (v823 - v807)) + ((v824 - v808) * (v824 - v808))) + ((v825 - v809) * (v825 - v809));
              if (v828 > v768 && v828 > v826)
              {
                v800 = 1;
              }

              else
              {
                v828 = v826;
              }

              v829 = (((v807 - v815) * (v807 - v815)) + ((v808 - v816) * (v808 - v816))) + ((v809 - v817) * (v809 - v817));
              if (v829 > v768 && v829 > v828)
              {
LABEL_878:
                v800 = 2;
LABEL_880:
                v830 = v800 + 3 * v773;
                v831 = *&v760[4 * v830];
                if (v831 < 0)
                {
                  v832 = 0xFFFFFFFFLL;
                }

                else
                {
                  v832 = (v831 / 3);
                }

                if (v831 < 0)
                {
                  v833 = -1;
                }

                else
                {
                  v833 = v831 % 3;
                }

                v1017 = v833;
                if (v832 >= 0)
                {
                  v834 = 4;
                }

                else
                {
                  v834 = 2;
                }

                if (v834 + *(v3 + 160) > v758)
                {
                  v758 = fmax(v758 * 1.5, 100000.0);
                  v760 = malloc_type_realloc(v760, 12 * v758, 0x100004052888210uLL);
                  v774 = malloc_type_realloc(*(v3 + 168), 16 * v758, 0x1000040451B5BE8uLL);
                  *(v3 + 168) = v774;
                  v782 = *(v3 + 144);
                }

                v835 = *(v3 + 136);
                v1023 = v758;
                if (v835 + 1 <= v759)
                {
                  v1021 = v759;
                }

                else
                {
                  v1021 = fmax(v759 * 1.5, 100000.0);
                  v782 = malloc_type_realloc(v782, 12 * v1021, 0x10000403E1C8BA9uLL);
                  *(v3 + 144) = v782;
                  v774 = *(v3 + 168);
                  v835 = *(v3 + 136);
                }

                v836 = v830 % 3;
                v1019 = v830 / 3;
                v837 = &v774[4 * (v830 / 3)];
                if (v832 < 0)
                {
                  v838 = 0;
                }

                else
                {
                  v838 = &v774[4 * v832];
                }

                v839 = (v836 + 1 - 3 * ((((86 * (v836 + 1)) & 0x8000) != 0) + ((86 * (v836 + 1)) >> 8)));
                v840 = v837[v839];
                v841 = &v782[12 * v840];
                if ((v836 + 2) >= 3)
                {
                  v842 = v836 - 1;
                }

                else
                {
                  v842 = v836 + 2;
                }

                v843 = &v782[12 * v837[v842]];
                v844 = &v782[12 * v835];
                if (v1025)
                {
                  v845 = *v837;
                  v846 = v837[1];
                  v847 = &v782[12 * *v837];
                  v848 = &v782[12 * v846];
                  v849 = v837[2];
                  v850 = &v782[12 * v849];
                  v851 = v847[1];
                  v852 = v848[1];
                  v853 = v847[2];
                  v854 = v848[2];
                  v855 = (((*v847 - *v848) * (*v847 - *v848)) + ((v851 - v852) * (v851 - v852))) + ((v853 - v854) * (v853 - v854));
                  v856 = v850[1];
                  v857 = ((*v847 - *v850) * (*v847 - *v850)) + ((v851 - v856) * (v851 - v856));
                  v858 = v850[2];
                  v859 = v857 + ((v853 - v858) * (v853 - v858));
                  v860 = fminf(fminf(v855, v859), (((*v848 - *v850) * (*v848 - *v850)) + ((v852 - v856) * (v852 - v856))) + ((v854 - v858) * (v854 - v858)));
                  v861 = *v841;
                  v862 = vsub_f32(*v841, *v843);
                  v863 = vaddv_f32(vmul_f32(v862, v862));
                  v864 = v841[1].f32[0];
                  v865 = v843[1].f32[0];
                  if ((v860 / (v863 + ((v864 - v865) * (v864 - v865)))) >= 0.01)
                  {
                    *v844 = vmul_f32(vadd_f32(*v843, v861), 0x3F0000003F000000);
                    v877 = (v865 + v864) * 0.5;
                  }

                  else
                  {
                    if (v855 == v860)
                    {
                      v866 = v845 == v840 || v846 == v840;
                    }

                    else
                    {
                      if (v859 == v860)
                      {
                        v878 = v845 == v840;
                      }

                      else
                      {
                        v878 = v846 == v840;
                      }

                      v866 = v878 || v849 == v840;
                    }

                    v879 = v866;
                    v880 = v879 == 0;
                    if (v879)
                    {
                      v881.i32[0] = *v841;
                    }

                    else
                    {
                      v881.i32[0] = *v843;
                    }

                    if (v879)
                    {
                      v882 = v841;
                    }

                    else
                    {
                      v882 = v843;
                    }

                    if (!v880)
                    {
                      v861.i32[0] = *v843;
                      v841 = v843;
                    }

                    v861.i32[1] = v841->i32[1];
                    v881.i32[1] = v882->i32[1];
                    __asm { FMOV            V1.2S, #0.25 }

                    *v844 = vmla_f32(v881, _D1, vsub_f32(v861, v881));
                    v877 = v882[1].f32[0] + ((v841[1].f32[0] - v882[1].f32[0]) * 0.25);
                  }
                }

                else
                {
                  v867 = v841[1].f32[0];
                  v868 = v843[1].f32[0];
                  v869 = vzip1_s32(*v843, *v841);
                  v870 = vzip2_s32(*v843, *v841);
                  v871 = vsqrt_f32(vmla_f32(vmla_f32(vmul_f32(v869, v869), v870, v870), __PAIR64__(LODWORD(v867), LODWORD(v868)), __PAIR64__(LODWORD(v867), LODWORD(v868))));
                  LODWORD(v872) = vsub_f32(vdup_lane_s32(v871, 1), v871).u32[0];
                  v873 = 0.5;
                  if (fabsf(v872) > 0.001)
                  {
                    __asm { FMOV            V7.2D, #1.0 }

                    v875 = 1.0 / fmax((vaddv_f32(vcvt_f32_f64(vdivq_f64(_Q7, vmaxnmq_f64(vcvtq_f64_f32(v871), vdupq_n_s64(0x3E112E0BE826D695uLL))))) * 0.5), 0.000000001);
                    v873 = (v875 - *v871.i32) / v872;
                  }

                  if (v873 < 0.1 || v873 > 0.9)
                  {
                    v876 = 0.5;
                  }

                  else
                  {
                    v876 = v873;
                  }

                  *v844 = vmla_n_f32(vmul_n_f32(*v841, v876), *v843, 1.0 - v876);
                  v877 = (v876 * v867) + ((1.0 - v876) * v868);
                }

                v844[1].f32[0] = v877;
                v3 = v1009;
                bzero(&v774[4 * *(v1009 + 160)], (16 * v834));
                v774 = *(v1009 + 168);
                v884 = &v774[4 * *(v1009 + 160)];
                *v884 = v837[v836];
                v884[1] = v837[v839];
                v884[2] = *(v1009 + 136);
                v884[3] = v837[3];
                v885 = &v774[4 * (*(v1009 + 160) + 1)];
                *v885 = v837[v842];
                v885[1] = v837[v836];
                v885[2] = *(v1009 + 136);
                v885[3] = v837[3];
                if (v838)
                {
                  v886 = &v774[4 * (*(v1009 + 160) + 2)];
                  *v886 = *&v838[4 * v1017];
                  v886[1] = *&v838[4 * (v1017 + 1 - 3 * ((((86 * (v1017 + 1)) & 0x8000) != 0) + ((86 * (v1017 + 1)) >> 8)))];
                  v886[2] = *(v1009 + 136);
                  v886[3] = *(v838 + 3);
                  v887 = &v774[4 * (*(v1009 + 160) + 3)];
                  v888 = v1017 + 2;
                  if ((v1017 + 2) >= 3)
                  {
                    v888 = v1017 - 1;
                  }

                  *v887 = *&v838[4 * v888];
                  v887[1] = *&v838[4 * v1017];
                  v887[2] = *(v1009 + 136);
                  v887[3] = *(v838 + 3);
                }

                v889 = *(v1009 + 160);
                v758 = v1023;
                v759 = v1021;
                v771 = v1008;
                if (v889 < v889 + v834)
                {
                  v890 = &v760[12 * v889];
                  do
                  {
                    *(v890 + 2) = -1;
                    *v890 = -1;
                    v890 += 12;
                    ++v889;
                  }

                  while (*(v1009 + 160) + v834 > v889);
                  v889 = *(v1009 + 160);
                }

                v891 = v774[4 * v889];
                v892 = &v774[4 * v1019];
                if (v891 == *v892)
                {
                  v893 = 0;
                  v894 = 3 * v889;
                  if ((v832 & 0x80000000) != 0)
                  {
                    goto LABEL_941;
                  }

LABEL_946:
                  v898 = v774[4 * v889 + 8];
                  v899 = &v774[4 * v832];
                  if (v898 == *v899)
                  {
                    v895 = 0;
                  }

                  else if (v898 == v899[1])
                  {
                    v895 = 1;
                  }

                  else
                  {
                    v895 = 2;
                  }

                  v896 = v894 + 10;
                  *&v760[4 * v894] = v894 + 10;
                  v897 = v894;
                }

                else
                {
                  if (v891 == v892[1])
                  {
                    v893 = 1;
                  }

                  else
                  {
                    v893 = 2;
                  }

                  v894 = 3 * v889;
                  if ((v832 & 0x80000000) == 0)
                  {
                    goto LABEL_946;
                  }

LABEL_941:
                  v895 = 0;
                  v896 = v894;
                  v894 = -1;
                  v897 = v896;
                }

                *&v760[4 * v896] = v894;
                v900 = v897 + 1;
                *&v760[4 * v900] = v897 + 3;
                *&v760[4 * v897 + 12] = v900;
                v901 = 3 * v1019;
                v902 = v893 - 1;
                if (!v893)
                {
                  v902 = 2;
                }

                v903 = *&v760[4 * v902 + 4 * v901];
                v904 = v897 + 2;
                *&v760[4 * v904] = v903;
                if ((v903 & 0x80000000) == 0)
                {
                  *&v760[4 * v903] = v904;
                }

                if (v832 < 0)
                {
                  v905 = -1;
                }

                else
                {
                  v905 = v897 + 6;
                }

                *&v760[4 * v897 + 16] = v905;
                if ((v832 & 0x80000000) == 0)
                {
                  *&v760[4 * v897 + 24] = v897 + 4;
                }

                if (v893 == 2)
                {
                  v906 = 0;
                }

                else
                {
                  v906 = v893 + 1;
                }

                v907 = *&v760[4 * v906 + 4 * v901];
                *&v760[4 * v897 + 20] = v907;
                if ((v907 & 0x80000000) == 0)
                {
                  *&v760[4 * v907] = v897 + 5;
                }

                if ((v832 & 0x80000000) != 0)
                {
                  v908 = v901;
                }

                else
                {
                  *&v760[4 * v897 + 28] = v897 + 9;
                  *&v760[4 * v897 + 36] = v897 + 7;
                  v908 = (3 * v832);
                  v909 = v895 - 1;
                  if (!v895)
                  {
                    v909 = 2;
                  }

                  v910 = *&v760[4 * (v909 + v908)];
                  *&v760[4 * v897 + 32] = v910;
                  if ((v910 & 0x80000000) == 0)
                  {
                    *&v760[4 * v910] = v897 + 8;
                  }

                  if (v895 == 2)
                  {
                    v911 = 0;
                  }

                  else
                  {
                    v911 = v895 + 1;
                  }

                  v912 = *&v760[4 * (v911 + v908)];
                  if ((v912 & 0x80000000) == 0)
                  {
                    v913 = v897 + 11;
                    *&v760[4 * v913] = v912;
                    *&v760[4 * v912] = v913;
                  }

                  v914 = &v760[12 * v1019];
                  *(v914 + 2) = -1;
                  *v914 = -1;
                }

                v915 = &v760[4 * v908];
                *(v915 + 2) = -1;
                *v915 = -1;
                *(v1009 + 160) += v834;
                ++*(v1009 + 136);
                v837[2] = -1;
                *v837 = -1;
                if (v838)
                {
                  *(v838 + 2) = -1;
                  *v838 = -1;
                }

                v772 = 1;
                goto LABEL_846;
              }
            }

            if ((v800 & 0x80000000) == 0)
            {
              goto LABEL_880;
            }
          }
        }
      }

LABEL_846:
      if (v771 == ++v773)
      {
        if (!v772 || (v769 = v771, v770 = v993, v998 < 2))
        {
          v771 = *(v3 + 160);
LABEL_983:
          if (v771)
          {
            v916 = 0;
            v917 = 0;
            v918 = 0;
            do
            {
              v919 = *(v3 + 168);
              v920 = v919 + v916;
              v921 = *(v919 + v916);
              if (v921 != -1)
              {
                v922 = *(v920 + 4);
                if (v922 != -1)
                {
                  v923 = *(v919 + v916 + 8);
                  v924 = v922 == v923 || v921 == v923;
                  v925 = v924 || v921 == v922;
                  if (!v925 && v923 != -1)
                  {
                    *(v919 + 16 * v918++) = *v920;
                    v771 = *(v3 + 160);
                  }
                }
              }

              ++v917;
              v916 += 16;
            }

            while (v917 < v771);
          }

          else
          {
            v918 = 0;
          }

          *(v3 + 160) = v918;
          *(v3 + 168) = malloc_type_realloc(*(v3 + 168), 16 * v918, 0x1000040451B5BE8uLL);
          *(v3 + 144) = malloc_type_realloc(*(v3 + 144), 12 * *(v3 + 136), 0x10000403E1C8BA9uLL);
          *(v3 + 152) = malloc_type_realloc(*(v3 + 152), 12 * *(v3 + 136), 0x10000403E1C8BA9uLL);
          free(v760);
          v8 = v999;
LABEL_1001:
          if (v987)
          {
            v927 = malloc_type_calloc(*(v3 + 136), 1uLL, 0x100004077774924uLL);
            bzero(&v1032, 0x800uLL);
            if (v986 < 1)
            {
LABEL_1006:
              if (!*(v1009 + 152))
              {
                v967 = *(v1009 + 136);
                if (!v967)
                {
                  goto LABEL_1028;
                }

                v968 = malloc_type_malloc(12 * v967, 0x10000403E1C8BA9uLL);
                *(v1009 + 152) = v968;
                if (!v968)
                {
                  goto LABEL_1028;
                }
              }

              v3 = v1009;
              v932 = *(v1009 + 160);
              if (v932)
              {
                v933 = 0;
                v934 = 0;
                __asm { FMOV            V8.2S, #1.0 }

                while (1)
                {
                  v936 = *(v1009 + 168);
                  v937 = *(v936 + v933 + 12);
                  if (v937 > 0xFF)
                  {
                    goto LABEL_1028;
                  }

                  v938 = *&v1032.f64[v937];
                  if (v938)
                  {
                    v939 = *(v936 + v933);
                    v1028 = 0uLL;
                    v1029 = 0.0;
                    if (!v927[v939])
                    {
                      v927[v939] = 1;
                      v940 = *(v1009 + 144) + 12 * v939;
                      v941 = *v940;
                      v942 = vcvtq_f64_f32(*(v940 + 4));
                      v943 = vmulq_f64(*(v1009 + 16), v942);
                      v928.f64[0] = v943.f64[0] + *(v1009 + 8) * v941 + v943.f64[1] + *(v1009 + 32);
                      v944 = vmulq_f64(*(v1009 + 48), v942);
                      v945 = vmulq_f64(*(v1009 + 80), v942);
                      mc_uv_model_apply(v938, &v1028, v928, v944.f64[0] + *(v1009 + 40) * v941 + v944.f64[1] + *(v1009 + 64), v945.f64[0] + *(v1009 + 72) * v941 + v945.f64[1] + *(v1009 + 96));
                      if (!v946)
                      {
                        goto LABEL_1027;
                      }

                      v947 = (*(v1009 + 152) + 12 * v939);
                      v928.f64[1] = v1028.f64[1];
                      *v947 = vmaxnm_f32(vminnm_f32(vcvt_f32_f64(v1028), _D8), 0);
                      *v928.f64 = v1029;
                      v947[1].f32[0] = fmaxf(fminf(*v928.f64, 10000.0), 0.0);
                    }

                    v948 = v936 + v933;
                    v949 = *(v948 + 4);
                    v1028 = 0uLL;
                    v1029 = 0.0;
                    if (!v927[v949])
                    {
                      v927[v949] = 1;
                      v950 = *(v1009 + 144) + 12 * v949;
                      v951 = *v950;
                      v952 = vcvtq_f64_f32(*(v950 + 4));
                      v953 = vmulq_f64(*(v1009 + 16), v952);
                      v928.f64[0] = v953.f64[0] + *(v1009 + 8) * v951 + v953.f64[1] + *(v1009 + 32);
                      v954 = vmulq_f64(*(v1009 + 48), v952);
                      v955 = vmulq_f64(*(v1009 + 80), v952);
                      mc_uv_model_apply(v938, &v1028, v928, v954.f64[0] + *(v1009 + 40) * v951 + v954.f64[1] + *(v1009 + 64), v955.f64[0] + *(v1009 + 72) * v951 + v955.f64[1] + *(v1009 + 96));
                      if (!v956)
                      {
                        goto LABEL_1027;
                      }

                      v957 = (*(v1009 + 152) + 12 * v949);
                      v928.f64[1] = v1028.f64[1];
                      *v957 = vmaxnm_f32(vminnm_f32(vcvt_f32_f64(v1028), _D8), 0);
                      *v928.f64 = v1029;
                      v957[1].f32[0] = fmaxf(fminf(*v928.f64, 10000.0), 0.0);
                    }

                    v958 = *(v948 + 8);
                    v1028 = 0uLL;
                    v1029 = 0.0;
                    if (!v927[v958])
                    {
                      v927[v958] = 1;
                      v959 = *(v1009 + 144) + 12 * v958;
                      v960 = *v959;
                      v961 = vcvtq_f64_f32(*(v959 + 4));
                      v962 = vmulq_f64(*(v1009 + 16), v961);
                      v928.f64[0] = v962.f64[0] + *(v1009 + 8) * v960 + v962.f64[1] + *(v1009 + 32);
                      v963 = vmulq_f64(*(v1009 + 48), v961);
                      v964 = vmulq_f64(*(v1009 + 80), v961);
                      mc_uv_model_apply(v938, &v1028, v928, v963.f64[0] + *(v1009 + 40) * v960 + v963.f64[1] + *(v1009 + 64), v964.f64[0] + *(v1009 + 72) * v960 + v964.f64[1] + *(v1009 + 96));
                      if (!v965)
                      {
LABEL_1027:
                        v8 = v999;
                        goto LABEL_1028;
                      }

                      v966 = (*(v1009 + 152) + 12 * v958);
                      v928.f64[1] = v1028.f64[1];
                      *v966 = vmaxnm_f32(vminnm_f32(vcvt_f32_f64(v1028), _D8), 0);
                      *v928.f64 = v1029;
                      v966[1].f32[0] = fmaxf(fminf(*v928.f64, 10000.0), 0.0);
                    }

                    v932 = *(v1009 + 160);
                  }

                  ++v934;
                  v933 += 16;
                  v8 = v999;
                  if (v934 >= v932)
                  {
                    free(v927);
                    v3 = v1009;
                    goto LABEL_1030;
                  }
                }
              }

              free(v927);
            }

            else
            {
              v929 = v986;
              v930 = v988;
              while (1)
              {
                v931 = v930[1];
                if (v931 > 0xFF)
                {
                  break;
                }

                *&v1032.f64[v931] = v930;
                v930 += 44;
                if (!--v929)
                {
                  goto LABEL_1006;
                }
              }

LABEL_1028:
              free(v927);
              v3 = v1009;
LABEL_1029:
              *v8 = 0;
            }
          }

LABEL_1030:
          *(v3 + 176) = v986;
          *(v3 + 184) = v988;
          v10 = *v8;
          v16 = *(v8 + 2);
          if (!v16)
          {
LABEL_19:
            free(v8);
            return v10;
          }

LABEL_18:
          free(v16);
          goto LABEL_19;
        }

        goto LABEL_843;
      }
    }
  }

  return 0;
}

void **mc_scene_decode(uint64_t a1, unint64_t a2)
{
  no_copy = mc_container_create_read_no_copy("MCP4", a1, a2);
  if (!no_copy)
  {
    return 0;
  }

  v3 = no_copy;
  v4 = *(no_copy + 2);
  if (!v4)
  {
    v14 = 0;
    v13 = 0;
    goto LABEL_138;
  }

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = *(no_copy + 1);
  v9 = *(no_copy + 2);
  do
  {
    v11 = *v8;
    v8 += 20;
    v10 = v11;
    if (v11 == 1)
    {
      ++v7;
    }

    if (v10 == 7)
    {
      v12 = v6 + 1;
    }

    else
    {
      v12 = v6;
    }

    if (v10 == 2)
    {
      ++v5;
    }

    else
    {
      v6 = v12;
    }

    --v9;
  }

  while (v9);
  if (!(v7 | v6))
  {
    v13 = 0;
    v14 = 0;
    if (!*(no_copy + 2))
    {
      goto LABEL_138;
    }

    goto LABEL_136;
  }

  v15 = malloc_type_calloc(1uLL, 0x30uLL, 0x1020040FA093B57uLL);
  v14 = v15;
  if (!*v15 && !v15[1])
  {
    v16 = malloc_type_calloc(v7, 0xC0uLL, 0x1020040D1D670B0uLL);
    if (v16 && v7)
    {
      v17 = v16 + 88;
      v18 = v7;
      do
      {
        *(v17 - 10) = 0x3FF0000000000000;
        *(v17 - 72) = 0uLL;
        *(v17 - 56) = 0uLL;
        *(v17 - 5) = 0x3FF0000000000000;
        *(v17 - 2) = 0uLL;
        *(v17 - 1) = 0uLL;
        *v17 = 0x3FF0000000000000;
        *(v17 + 8) = 0uLL;
        *(v17 + 24) = 0uLL;
        *(v17 + 5) = 0x3FF0000000000000;
        v17 += 192;
        --v18;
      }

      while (v18);
      *v14 = v16;
      goto LABEL_25;
    }

    *v14 = v16;
    if (v16)
    {
LABEL_25:
      v14[1] = v7;
    }
  }

  if (!v14[4] && !v14[5])
  {
    v19 = malloc_type_calloc(v5, 0x18uLL, 0x10200406E52F545uLL);
    v14[4] = v19;
    if (v19)
    {
      v14[5] = v5;
    }
  }

  if (v14[2] || v14[3])
  {
    goto LABEL_39;
  }

  v20 = malloc_type_calloc(v6, 0xC0uLL, 0x1020040D1D670B0uLL);
  if (v20 && v6)
  {
    v21 = v20 + 88;
    v22 = v6;
    do
    {
      *(v21 - 10) = 0x3FF0000000000000;
      *(v21 - 72) = 0uLL;
      *(v21 - 56) = 0uLL;
      *(v21 - 5) = 0x3FF0000000000000;
      *(v21 - 2) = 0uLL;
      *(v21 - 1) = 0uLL;
      *v21 = 0x3FF0000000000000;
      *(v21 + 8) = 0uLL;
      *(v21 + 24) = 0uLL;
      *(v21 + 5) = 0x3FF0000000000000;
      v21 += 192;
      --v22;
    }

    while (v22);
    v14[2] = v20;
    goto LABEL_38;
  }

  v14[2] = v20;
  if (v20)
  {
LABEL_38:
    v14[3] = v6;
  }

LABEL_39:
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  __src = 0;
  v27 = 1;
  while (*(v3 + 16) > v24)
  {
    v28 = *(*(v3 + 8) + v23);
    switch(v28)
    {
      case 7:
        v42 = v14[2];
        chapter_data = mc_container_get_chapter_data(v3, v24);
        if (chapter_data)
        {
          v44 = chapter_data;
          v27 = mc_mesh_decode(*(chapter_data + 1), *(chapter_data + 3), v42 + 192 * v26);
          v45 = *(v44 + 2);
          if (v45)
          {
            free(v45);
          }

          free(v44);
          ++v26;
        }

        else
        {
          v27 = 0;
          ++v26;
        }

        break;
      case 2:
        v33 = v14[4];
        v34 = mc_container_get_chapter_data(v3, v24);
        if (v34)
        {
          v35 = v34;
          v93 = v26;
          v94 = v25;
          v36 = v33 + 24 * v25;
          v37 = *(v34 + 1);
          v38 = *(v34 + 3);
          v27 = 1;
          v39 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
          *v39 = 1;
          *(v39 + 1) = v37;
          *(v39 + 3) = v38;
          if (v38)
          {
            v27 = v37 != 0;
            *v39 = v27;
            if (!v37)
            {
LABEL_57:
              v27 = 0;
              *v36 = 0;
              *(v36 + 8) = 0;
              goto LABEL_89;
            }
          }

          v40 = *(v39 + 4);
          v41 = v40 + 8;
          if (v40 + 8 > v38)
          {
            *v39 = 0;
            goto LABEL_57;
          }

          v46 = *(v37 + v40);
          *(v39 + 4) = v41;
          *v36 = v46;
          v47 = v41 + 1;
          if (v41 + 1 > v38)
          {
            v27 = 0;
            *v39 = 0;
            *(v36 + 8) = 0;
            goto LABEL_89;
          }

          v48 = *(v37 + v41);
          *(v39 + 4) = v47;
          *(v36 + 8) = v48;
          if (!v48)
          {
            goto LABEL_89;
          }

          v49 = *(v39 + 4);
          if (v49 + 1 > v38)
          {
            goto LABEL_79;
          }

          v50 = *(v37 + v49);
          *(v39 + 4) = v49 + 1;
          v51 = *(v36 + 16);
          if (v51)
          {
            goto LABEL_70;
          }

          v52 = v39;
          v51 = malloc_type_calloc(1uLL, 0x20uLL, 0x10800403AF1B36BuLL);
          *(v36 + 16) = v51;
          if (v51)
          {
            v39 = v52;
            if (!*(v36 + 8))
            {
LABEL_77:
              if (*v39)
              {
                v54 = *(v39 + 4);
                if ((v54 + 1) <= *(v39 + 3))
                {
                  v55 = *(*(v39 + 1) + v54);
                  *(v39 + 4) = v54 + 1;
                  if (!v51)
                  {
                    v56 = v39;
                    v51 = malloc_type_calloc(1uLL, 0x20uLL, 0x10800403AF1B36BuLL);
                    v39 = v56;
                    *(v36 + 16) = v51;
                  }

                  if (*(v36 + 8))
                  {
                    v57 = v39;
                    free(v51[1]);
                    v51 = *(v36 + 16);
                    v51[1] = 0;
                    *(v51 + 1) = 0;
                    if (v55)
                    {
                      v58 = malloc_type_malloc(0, 0x2E037A7DuLL);
                      v51 = *(v36 + 16);
                      v51[1] = v58;
                      if (v58)
                      {
                        *v51 = v55;
                        *(v51 + 1) = 0;
                      }
                    }

                    v39 = v57;
                  }

                  *(v51 + 4) = v55;
                  v27 = *v39;
                }

                else
                {
LABEL_79:
                  v27 = 0;
                  *v39 = 0;
                }
              }

              else
              {
                v27 = 0;
              }

LABEL_89:
              if (*(v39 + 2))
              {
                v59 = v39;
                free(*(v39 + 2));
                v39 = v59;
              }

              free(v39);
              v60 = *(v35 + 2);
              v26 = v93;
              v25 = v94;
              if (v60)
              {
                free(v60);
              }

              free(v35);
LABEL_41:
              ++v25;
              break;
            }

LABEL_70:
            v52 = v39;
            free(v51[1]);
            v51 = *(v36 + 16);
            v51[1] = 0;
            *(v51 + 1) = 0;
            if (v50)
            {
              v53 = malloc_type_malloc(0, 0x2E037A7DuLL);
              v51 = *(v36 + 16);
              v51[1] = v53;
              if (v53)
              {
                *v51 = v50;
                *(v51 + 1) = 0;
              }
            }
          }

          v39 = v52;
          goto LABEL_77;
        }

        v27 = 0;
        goto LABEL_41;
      case 1:
        v29 = *v14;
        v30 = mc_container_get_chapter_data(v3, v24);
        if (v30)
        {
          v31 = v30;
          v27 = mc_mesh_decode(*(v30 + 1), *(v30 + 3), v29 + 192 * __src);
          v32 = *(v31 + 2);
          if (v32)
          {
            free(v32);
          }

          free(v31);
        }

        else
        {
          v27 = 0;
        }

        __src = __src + 1;
        break;
      default:
        goto LABEL_43;
    }

    if (!v27)
    {
      v13 = 1;
      if (!*(v3 + 16))
      {
        goto LABEL_138;
      }

      goto LABEL_136;
    }

LABEL_43:
    ++v24;
    v23 += 40;
    if (v4 == v24)
    {
      goto LABEL_95;
    }
  }

  v27 = 0;
LABEL_95:
  v61 = 0;
  v62 = 0;
  while (2)
  {
    if (*(v3 + 16) > v62)
    {
      v63 = *(v3 + 8);
      v64 = *(v63 + v61);
      if ((v64 - 5) < 0xFFFFFFFE)
      {
        goto LABEL_97;
      }

      v65 = *(v63 + v61 + 4);
      if (v14[5] <= v65)
      {
        goto LABEL_97;
      }

      v66 = v14[4] + 24 * v65;
      if (!*(v66 + 16))
      {
        goto LABEL_97;
      }

      v67 = mc_container_get_chapter_data(v3, v62);
      v68 = v67;
      if (v64 == 3)
      {
        if (!v67)
        {
          break;
        }

        v69 = *(v66 + 16);
        if (v69)
        {
          v70 = *(v67 + 3);
          if (!HIDWORD(v70))
          {
            if (*(v66 + 8))
            {
              v71 = *(v67 + 1);
              v72 = *v69;
              free(v69[1]);
              v73 = *(v66 + 16);
              *(v73 + 8) = 0;
              *(v73 + 4) = 0;
              if (v72)
              {
                v74 = malloc_type_malloc(v70, 0x2E037A7DuLL);
                if (v74)
                {
                  __srca = v74;
                  memcpy(v74, v71, v70);
                  v75 = 0;
                  v76 = *(v66 + 16);
                  *(v76 + 8) = __srca;
                  *v76 = v72;
                  *(v76 + 4) = v70;
                  goto LABEL_128;
                }

                v27 = 0;
                *(*(v66 + 16) + 8) = 0;
LABEL_114:
                v75 = 1;
                v79 = *(v68 + 2);
                if (v79)
                {
LABEL_115:
                  free(v79);
                }

LABEL_96:
                free(v68);
                if (v75)
                {
                  break;
                }

LABEL_97:
                ++v62;
                v61 += 40;
                if (v4 == v62)
                {
                  goto LABEL_133;
                }

                continue;
              }

LABEL_127:
              v75 = 0;
LABEL_128:
              v27 = 1;
              v79 = *(v68 + 2);
              if (v79)
              {
                goto LABEL_115;
              }

              goto LABEL_96;
            }
          }
        }
      }

      else
      {
        if (!v67)
        {
          break;
        }

        v77 = *(v66 + 16);
        if (v77)
        {
          v78 = *(v67 + 3);
          if (!HIDWORD(v78))
          {
            v80 = *(v77 + 16);
            v81 = *(v66 + 8);
            v82 = v81 == 2 || v80 == 0;
            if (v82 || v81 == 4)
            {
              v84 = *(v67 + 1);
              free(*(v77 + 24));
              v85 = *(v66 + 16);
              *(v85 + 24) = 0;
              *(v85 + 20) = 0;
              if (v80)
              {
                v86 = malloc_type_malloc(v78, 0x2E037A7DuLL);
                if (!v86)
                {
                  v27 = 0;
                  *(*(v66 + 16) + 24) = 0;
                  goto LABEL_114;
                }

                v87 = v84;
                __srcb = v84;
                v88 = v86;
                memcpy(v86, v87, v78);
                v89 = *(v66 + 16);
                *(v89 + 24) = v88;
                *(v89 + 16) = v80;
                *(v89 + 20) = v78;
                memcpy(v88, __srcb, v78);
              }

              goto LABEL_127;
            }
          }
        }
      }

      v27 = 0;
      goto LABEL_114;
    }

    break;
  }

  v27 = 0;
LABEL_133:
  v13 = v27 == 0;
  if (*(v3 + 16))
  {
LABEL_136:
    v90 = 0;
    v91 = 24;
    do
    {
      free(*(*(v3 + 8) + v91));
      ++v90;
      v91 += 40;
    }

    while (*(v3 + 16) > v90);
  }

LABEL_138:
  free(*(v3 + 8));
  free(v3);
  if (v13)
  {
    mc_scene_free(v14);
    return 0;
  }

  return v14;
}

double mc_read_mat4(uint64_t a1, double *a2)
{
  if (!*a1)
  {
    goto LABEL_4;
  }

  v3 = *(a1 + 24);
  v2 = *(a1 + 32);
  v4 = v2 + 8;
  if (v2 + 8 > v3)
  {
    *a1 = 0;
LABEL_4:
    *a2 = 0.0;
    a2[1] = 0.0;
LABEL_5:
    a2[2] = 0.0;
    a2[3] = 0.0;
LABEL_6:
    a2[4] = 0.0;
    a2[5] = 0.0;
LABEL_7:
    a2[6] = 0.0;
    a2[7] = 0.0;
LABEL_8:
    a2[8] = 0.0;
    a2[9] = 0.0;
LABEL_9:
    a2[10] = 0.0;
    a2[11] = 0.0;
LABEL_10:
    a2[12] = 0.0;
    a2[13] = 0.0;
LABEL_11:
    a2[14] = 0.0;
LABEL_19:
    result = 0.0;
    a2[15] = 0.0;
    return result;
  }

  v5 = *(a1 + 8);
  v6 = *(v5 + v2);
  *(a1 + 32) = v4;
  *a2 = v6;
  v7 = v2 + 16;
  if (v2 + 16 > v3)
  {
    *a1 = 0;
    a2[1] = 0.0;
    a2[2] = 0.0;
LABEL_14:
    a2[3] = 0.0;
    a2[4] = 0.0;
LABEL_15:
    a2[5] = 0.0;
    a2[6] = 0.0;
LABEL_16:
    a2[7] = 0.0;
    a2[8] = 0.0;
LABEL_17:
    a2[9] = 0.0;
    a2[10] = 0.0;
LABEL_18:
    a2[11] = 0.0;
    a2[12] = 0.0;
    a2[13] = 0.0;
    a2[14] = 0.0;
    goto LABEL_19;
  }

  v9 = *(v5 + v4);
  *(a1 + 32) = v7;
  *(a2 + 1) = v9;
  v10 = v2 + 24;
  if (v2 + 24 > v3)
  {
    *a1 = 0;
    goto LABEL_5;
  }

  v11 = *(v5 + v7);
  *(a1 + 32) = v10;
  *(a2 + 2) = v11;
  v12 = v2 + 32;
  if (v2 + 32 > v3)
  {
    *a1 = 0;
    goto LABEL_14;
  }

  v13 = *(v5 + v10);
  *(a1 + 32) = v12;
  *(a2 + 3) = v13;
  v14 = v2 + 40;
  if (v2 + 40 > v3)
  {
    *a1 = 0;
    goto LABEL_6;
  }

  v15 = *(v5 + v12);
  *(a1 + 32) = v14;
  *(a2 + 4) = v15;
  v16 = v2 + 48;
  if (v2 + 48 > v3)
  {
    *a1 = 0;
    goto LABEL_15;
  }

  v17 = *(v5 + v14);
  *(a1 + 32) = v16;
  *(a2 + 5) = v17;
  v18 = v2 + 56;
  if (v2 + 56 > v3)
  {
    *a1 = 0;
    goto LABEL_7;
  }

  v19 = *(v5 + v16);
  *(a1 + 32) = v18;
  *(a2 + 6) = v19;
  v20 = v2 + 64;
  if (v2 + 64 > v3)
  {
    *a1 = 0;
    goto LABEL_16;
  }

  v21 = *(v5 + v18);
  *(a1 + 32) = v20;
  *(a2 + 7) = v21;
  v22 = v2 + 72;
  if (v2 + 72 > v3)
  {
    *a1 = 0;
    goto LABEL_8;
  }

  v23 = *(v5 + v20);
  *(a1 + 32) = v22;
  *(a2 + 8) = v23;
  v24 = v2 + 80;
  if (v2 + 80 > v3)
  {
    *a1 = 0;
    goto LABEL_17;
  }

  v25 = *(v5 + v22);
  *(a1 + 32) = v24;
  *(a2 + 9) = v25;
  v26 = v2 + 88;
  if (v2 + 88 > v3)
  {
    *a1 = 0;
    goto LABEL_9;
  }

  v27 = *(v5 + v24);
  *(a1 + 32) = v26;
  *(a2 + 10) = v27;
  v28 = v2 + 96;
  if (v2 + 96 > v3)
  {
    *a1 = 0;
    goto LABEL_18;
  }

  v29 = *(v5 + v26);
  *(a1 + 32) = v28;
  *(a2 + 11) = v29;
  v30 = v2 + 104;
  if (v2 + 104 > v3)
  {
    *a1 = 0;
    goto LABEL_10;
  }

  v31 = *(v5 + v28);
  *(a1 + 32) = v30;
  *(a2 + 12) = v31;
  v32 = v2 + 112;
  if (v2 + 112 > v3)
  {
    *a1 = 0;
    a2[13] = 0.0;
    a2[14] = 0.0;
    goto LABEL_19;
  }

  v33 = *(v5 + v30);
  *(a1 + 32) = v32;
  *(a2 + 13) = v33;
  v34 = v2 + 120;
  if (v2 + 120 > v3)
  {
    *a1 = 0;
    goto LABEL_11;
  }

  v35 = *(v5 + v32);
  *(a1 + 32) = v34;
  *(a2 + 14) = v35;
  v36 = v2 + 128;
  if (v36 > v3)
  {
    *a1 = 0;
    goto LABEL_19;
  }

  result = *(v5 + v34);
  *(a1 + 32) = v36;
  a2[15] = result;
  return result;
}

void mc_read_tiny_big(uint64_t a1, int a2, _DWORD *a3)
{
  v6 = a2;
  v7 = malloc_type_malloc(a2, 0x100004077774924uLL);
  if (!*a1)
  {
    v13 = 0;
    goto LABEL_6;
  }

  v8 = *(a1 + 24);
  v9 = *(a1 + 32);
  v10 = v9 + 4;
  if (v9 + 4 > v8 || (v11 = *(a1 + 8), v12 = *(v11 + v9), *(a1 + 32) = v10, v10 + v6 > v8))
  {
    v13 = 0;
    *a1 = 0;
    goto LABEL_6;
  }

  v14 = v7;
  memcpy(v7, (v11 + v10), v6);
  *(a1 + 32) += v6;
  if (!*a1)
  {
    v13 = 0;
    v7 = v14;
    goto LABEL_6;
  }

  if (a2 >= 1)
  {
    if (a2 < 4)
    {
      v16 = 0;
      v17 = 0;
      v18 = v14;
      goto LABEL_24;
    }

    v18 = v14;
    if (a2 >= 0x20)
    {
      v20 = 0uLL;
      v16 = a2 & 0x7FFFFFE0;
      v21.i64[0] = -1;
      v21.i64[1] = -1;
      v22 = v14 + 1;
      v23.i64[0] = 0x100000001;
      v23.i64[1] = 0x100000001;
      v24 = v16;
      v25 = 0uLL;
      v26 = 0uLL;
      v27 = 0uLL;
      v28 = 0uLL;
      v29 = 0uLL;
      v30 = 0uLL;
      v31 = 0uLL;
      do
      {
        v32 = vceqq_s8(v22[-1], v21);
        v33 = vmovl_u8(*v32.i8);
        v34 = vmovl_high_u8(v32);
        v35 = vceqq_s8(*v22, v21);
        v36 = vmovl_u8(*v35.i8);
        v37 = vmovl_high_u8(v35);
        v27 = vaddq_s32(v27, vandq_s8(vmovl_high_u16(v34), v23));
        v26 = vaddq_s32(v26, vandq_s8(vmovl_u16(*v34.i8), v23));
        v25 = vaddq_s32(v25, vandq_s8(vmovl_high_u16(v33), v23));
        v20 = vaddq_s32(v20, vandq_s8(vmovl_u16(*v33.i8), v23));
        v31 = vaddq_s32(v31, vandq_s8(vmovl_high_u16(v37), v23));
        v30 = vaddq_s32(v30, vandq_s8(vmovl_u16(*v37.i8), v23));
        v29 = vaddq_s32(v29, vandq_s8(vmovl_high_u16(v36), v23));
        v28 = vaddq_s32(v28, vandq_s8(vmovl_u16(*v36.i8), v23));
        v22 += 2;
        v24 -= 32;
      }

      while (v24);
      v15 = vaddq_s32(v30, v26);
      v17 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v28, v20), v15), vaddq_s32(vaddq_s32(v29, v25), vaddq_s32(v31, v27))));
      if (v16 == a2)
      {
        goto LABEL_28;
      }

      if ((a2 & 0x1C) == 0)
      {
        goto LABEL_24;
      }
    }

    else
    {
      v17 = 0;
      v16 = 0;
    }

    v38 = v16;
    v16 = a2 & 0x7FFFFFFC;
    v39 = v17;
    v40 = v38 - v16;
    v41 = (v14->i32 + v38);
    v42.i64[0] = 0x100000001;
    v42.i64[1] = 0x100000001;
    do
    {
      v43 = *v41++;
      v15.i32[0] = v43;
      v15 = vandq_s8(vmovl_u16(vceq_s16(*&vmovl_u8(*v15.i8), 0xFF00FF00FF00FFLL)), v42);
      v39 = vaddq_s32(v39, v15);
      v40 += 4;
    }

    while (v40);
    v17 = vaddvq_s32(v39);
    if (v16 != a2)
    {
LABEL_24:
      v44 = a2 - v16;
      v45 = &v18->u8[v16];
      do
      {
        v46 = *v45++;
        if (v46 == 255)
        {
          ++v17;
        }

        --v44;
      }

      while (v44);
    }

LABEL_28:
    v19 = 4 * v17;
    goto LABEL_29;
  }

  v19 = 0;
LABEL_29:
  v47 = malloc_type_malloc(v19, 0x100004052888210uLL);
  v13 = v47;
  if (!*a1)
  {
    goto LABEL_39;
  }

  v48 = *(a1 + 32);
  if (v48 + v19 > *(a1 + 24))
  {
    v7 = v14;
    *a1 = 0;
    goto LABEL_6;
  }

  memcpy(v47, (*(a1 + 8) + v48), v19);
  *(a1 + 32) += v19;
  if (*a1)
  {
    v7 = v14;
    if (a2 >= 1)
    {
      v49 = 0;
      v50 = a2;
      v51 = v14;
      do
      {
        v54 = v51->u8[0];
        v51 = (v51 + 1);
        v53 = v54;
        if (v54 == 255)
        {
          v52 = v13[v49++];
        }

        else
        {
          v52 = v53 - v12;
        }

        *a3++ = v52;
        --v50;
      }

      while (v50);
    }
  }

  else
  {
LABEL_39:
    v7 = v14;
  }

LABEL_6:
  free(v7);

  free(v13);
}

char *mc_container_get_chapter_data(uint64_t a1, unint64_t a2)
{
  if (*(a1 + 16) > a2)
  {
    v2 = *(a1 + 8) + 40 * a2;
    v3 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
    *v3 = 1;
    v4 = *(v2 + 16);
    v5 = *(v2 + 32);
    v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
    v7 = v6;
    *v6 = 1;
    v6[1] = v4;
    v6[3] = v5;
    if (v5)
    {
      *v6 = v4 != 0;
      if (!v4)
      {
        goto LABEL_6;
      }
    }

    v8 = v6[4];
    v9 = v8 + 1;
    if (v8 + 1 > v5)
    {
      *v6 = 0;
LABEL_6:
      v10 = *(v2 + 32);
LABEL_7:
      v11 = v10 - 1;
      v12 = *v3;
      if (!*v3)
      {
        goto LABEL_34;
      }

      *(v3 + 4) = 0;
      v13 = *(v3 + 3);
      if (v13 >= v11 || v12 == 0)
      {
        goto LABEL_34;
      }

      v15 = v13 + (v13 >> 1);
      if (v15 <= v11)
      {
        v15 = v11;
      }

      v16 = v15 + 1023;
      v17 = v16 & 0xFFFFFFFFFFFFFC00;
      v18 = *(v3 + 2);
      if (v18)
      {
        v19 = malloc_type_realloc(v18, v16 & 0xFFFFFFFFFFFFFC00, 0x4895613EuLL);
        if (v19)
        {
LABEL_16:
          *(v3 + 1) = v19;
          *(v3 + 2) = v19;
          *(v3 + 3) = v17;
LABEL_34:
          memcpy(*(v3 + 2), (v7[1] + v7[4]), v11);
          goto LABEL_35;
        }
      }

      else
      {
        v19 = malloc_type_malloc(v16 & 0xFFFFFFFFFFFFFC00, 0xEF10F5C1uLL);
        if (v19)
        {
          goto LABEL_16;
        }
      }

      *v3 = 0;
      goto LABEL_34;
    }

    v20 = *(v4 + v8);
    v6[4] = v9;
    v10 = *(v2 + 32);
    if (!v20)
    {
      goto LABEL_7;
    }

    v21 = v10 - 5;
    if (v9 + 4 <= v5)
    {
      v11 = *(v4 + v9);
      v6[4] = v9 + 4;
      if (v21 > v11)
      {
        goto LABEL_59;
      }
    }

    else
    {
      v11 = 0;
      *v6 = 0;
      if (v10 != 5)
      {
        goto LABEL_59;
      }
    }

    v22 = *v3;
    if (*v3)
    {
      *(v3 + 4) = 0;
      v23 = *(v3 + 3);
      if (v23 < v11 && v22 != 0)
      {
        v25 = v23 + (v23 >> 1);
        if (v25 <= v11)
        {
          v25 = v11;
        }

        v26 = v25 + 1023;
        v27 = v26 & 0xFFFFFFFFFFFFFC00;
        v28 = *(v3 + 2);
        if (v28)
        {
          v29 = malloc_type_realloc(v28, v26 & 0xFFFFFFFFFFFFFC00, 0x4895613EuLL);
        }

        else
        {
          v29 = malloc_type_malloc(v26 & 0xFFFFFFFFFFFFFC00, 0xEF10F5C1uLL);
        }

        if (v29)
        {
          *(v3 + 1) = v29;
          *(v3 + 2) = v29;
          *(v3 + 3) = v27;
        }

        else
        {
          *v3 = 0;
        }
      }
    }

    switch(v20)
    {
      case 3:
        v39 = *(v3 + 2);
        v40 = *(v3 + 3);
        v41 = (v7[1] + v7[4]);
        v42 = v21;
        v43 = COMPRESSION_LZFSE;
        break;
      case 2:
        v39 = *(v3 + 2);
        v40 = *(v3 + 3);
        v41 = (v7[1] + v7[4]);
        v42 = v21;
        v43 = COMPRESSION_LZMA;
        break;
      case 1:
        v35 = *(v3 + 2);
        v36 = v7[1];
        v37 = v7[4];
        destLen = *(v3 + 3);
        if (uncompress(v35, &destLen, (v36 + v37), v21))
        {
          v38 = 0;
        }

        else
        {
          v38 = destLen;
        }

        goto LABEL_58;
      default:
        goto LABEL_59;
    }

    v38 = compression_decode_buffer(v39, v40, v41, v42, 0, v43);
LABEL_58:
    if (v38 == v11)
    {
LABEL_35:
      if (*v3)
      {
        if (*(v3 + 3) >= v11)
        {
          *(v3 + 4) = v11;
        }

        else
        {
          v11 = *(v3 + 4);
        }

        v30 = 0;
        *(v3 + 3) = v11;
        v31 = 32;
      }

      else
      {
        v30 = *(v3 + 4);
        v31 = 24;
      }

      *&v3[v31] = v30;
      v32 = v7[2];
      v33 = v3;
      if (!v32)
      {
        goto LABEL_43;
      }

      goto LABEL_42;
    }

LABEL_59:
    v44 = v7[2];
    if (v44)
    {
      free(v44);
    }

    free(v7);
    v33 = 0;
    v32 = *(v3 + 2);
    v7 = v3;
    v3 = 0;
    if (!v32)
    {
      goto LABEL_43;
    }

LABEL_42:
    free(v32);
    v3 = v33;
LABEL_43:
    free(v7);
    return v3;
  }

  return 0;
}

char *mc_container_create_read_no_copy(const char *a1, uint64_t a2, unint64_t a3)
{
  v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x10E004059713692uLL);
  v7 = v6;
  if (a1)
  {
    strncpy(v6, a1, 4uLL);
  }

  v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x1050040E984C859uLL);
  *v8 = 1;
  v8[1] = a2;
  v8[3] = a3;
  if (a3 && (*v8 = a2 != 0, !a2) || (v9 = v8[4], v10 = v9 + 4, v9 + 4 > a3) || (v54 = *(a2 + v9), v8[4] = v10, v11 = v9 + 6, v9 + 6 > a3) || (v18 = *(a2 + v10), v8[4] = v11, v54 != *v7) || v18)
  {
    *v8 = 0;
    v12 = 1;
    v13 = v8[2];
    if (!v13)
    {
      goto LABEL_9;
    }

    goto LABEL_8;
  }

  v19 = v9 + 8;
  if (v19 <= a3)
  {
    v20 = *(a2 + v11);
    v21 = v8;
    v8[4] = v19;
  }

  else
  {
    v20 = 0;
    v21 = v8;
    *v8 = 0;
  }

  v22 = v20;
  v23 = malloc_type_calloc(v20, 0x28uLL, 0x10C00403928CA3CuLL);
  *(v7 + 1) = v23;
  *(v7 + 2) = v20;
  v8 = v21;
  if (v20)
  {
    v24 = *v21;
    v25 = v23 + 8;
    v26 = v20;
    while (v24)
    {
      v28 = v21[3];
      v27 = v21[4];
      v29 = v27 + 2;
      if (v27 + 2 > v28)
      {
        goto LABEL_34;
      }

      v30 = v21[1];
      v31 = *(v30 + v27);
      v21[4] = v29;
      v32 = v27 + 6;
      if (v32 > v28)
      {
        break;
      }

      v33 = *(v30 + v29);
      v21[4] = v32;
      v34 = v32 + 4;
      if (v32 + 4 > v21[3])
      {
LABEL_34:
        *v21 = 0;
        break;
      }

      v35 = *(v21[1] + v32);
      v21[4] = v34;
      if (!v35)
      {
        break;
      }

      *(v25 - 8) = v31;
      *(v25 + 4) = v35;
      *v25 = v21[1] + v33;
      *(v25 + 1) = 0;
      *(v25 - 3) = -404232217;
      *(v25 - 4) = 0;
      v25 += 20;
      if (!--v26)
      {
        v36 = 0;
        while (1)
        {
          v37 = *v23;
          v23 += 20;
          if (!v37)
          {
            break;
          }

          if (v22 == ++v36)
          {
            goto LABEL_59;
          }
        }

        chapter_data = mc_container_get_chapter_data(v7, v36);
        v8 = v21;
        if (chapter_data)
        {
          v39 = *chapter_data;
          if (*chapter_data)
          {
            v40 = *(chapter_data + 4) + 2;
            if (v40 <= *(chapter_data + 3))
            {
              *(chapter_data + 4) = v40;
            }

            else
            {
              v39 = 0;
              *chapter_data = 0;
            }
          }

          v41 = *(v7 + 2);
          if (v41)
          {
            v42 = 0;
            for (i = 0; i < v41; ++i)
            {
              if (v36 != i)
              {
                v44 = *(v7 + 1);
                if (v39)
                {
                  v46 = *(chapter_data + 3);
                  v45 = *(chapter_data + 4);
                  v47 = v45 + 4;
                  if (v45 + 4 > v46 || (v48 = *(chapter_data + 1), v49 = *(v48 + v45), *(chapter_data + 4) = v47, v50 = v45 + 6, v50 > v46))
                  {
                    *chapter_data = 0;
                    break;
                  }

                  v51 = *(v48 + v47);
                  *(chapter_data + 4) = v50;
                }

                else
                {
                  v51 = 0;
                  v49 = 0;
                }

                if (!v39)
                {
                  break;
                }

                v52 = v44 + v42;
                *(v52 + 4) = v49;
                *(v52 + 8) = v51;
              }

              v42 += 40;
            }
          }

          v53 = *(chapter_data + 2);
          if (v53)
          {
            free(v53);
          }

          free(chapter_data);
          v8 = v21;
        }

        goto LABEL_59;
      }
    }

    *v21 = 0;
    if (v21[2])
    {
      free(v21[2]);
      v8 = v21;
    }

    free(v8);
    if (*(v7 + 2))
    {
      goto LABEL_12;
    }

    goto LABEL_14;
  }

LABEL_59:
  v12 = *v8 == 0;
  v13 = v8[2];
  if (v13)
  {
LABEL_8:
    v14 = v8;
    free(v13);
    v8 = v14;
  }

LABEL_9:
  free(v8);
  if (!v12)
  {
    *(v7 + 3) = a2;
    *(v7 + 4) = a3;
    return v7;
  }

  if (v7)
  {
    if (*(v7 + 2))
    {
LABEL_12:
      v15 = 0;
      v16 = 24;
      do
      {
        free(*(*(v7 + 1) + v16));
        ++v15;
        v16 += 40;
      }

      while (*(v7 + 2) > v15);
    }

LABEL_14:
    free(*(v7 + 1));
    free(v7);
    return 0;
  }

  return v7;
}

void mc_container_free(uint64_t a1)
{
  if (a1)
  {
    if (*(a1 + 16))
    {
      v2 = 0;
      v3 = 24;
      do
      {
        free(*(*(a1 + 8) + v3));
        ++v2;
        v3 += 40;
      }

      while (*(a1 + 16) > v2);
    }

    free(*(a1 + 8));

    free(a1);
  }
}

uint64_t mc_container_get_chapter_info(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(a1 + 16) <= a2)
  {
    return 0;
  }

  v3 = *(a1 + 8) + 40 * a2;
  v4 = *v3;
  *(a3 + 8) = *(v3 + 8);
  *a3 = v4;
  return 1;
}

float64x2_t mc_uv_model_apply(uint64_t a1, float64x2_t *a2, float64x2_t result, double a4, double a5)
{
  if (*a1 == 1)
  {
    v5 = result.f64[0];
    v6 = *(a1 + 32) + *(a1 + 8) * result.f64[0] + *(a1 + 16) * a4 + *(a1 + 24) * a5;
    v7 = *(a1 + 64) + *(a1 + 40) * v5 + *(a1 + 48) * a4 + *(a1 + 56) * a5;
    v8 = *(a1 + 96) + *(a1 + 72) * v5 + *(a1 + 80) * a4 + *(a1 + 88) * a5;
    v9 = *(a1 + 136);
    if (v9 == 3)
    {
      a2->f64[0] = *(a1 + 144) * v6;
      v10 = *(a1 + 152) * v7;
    }

    else
    {
      if (v9 == 1)
      {
        v11 = v8 * v8 + v6 * v6;
        v12 = a2;
        v14 = *(a1 + 160) + *(a1 + 144) * atan2(v6, v8);
        *v12 = v14;
        *v12 = v14 - floor((v14 + *(a1 + 144) * 3.14159265) / (*(a1 + 144) * 6.28318531)) * (*(a1 + 144) * 6.28318531);
        v15 = atan2(v7, sqrt(v11));
        a2 = v12;
        v12[1] = *(a1 + 168) + *(a1 + 152) * v15;
        v8 = sqrt(v11 + v7 * v7);
LABEL_12:
        a2[1].f64[0] = 1.0 / v8;
        goto LABEL_13;
      }

      if (v9)
      {
LABEL_13:
        __asm { FMOV            V1.2D, #0.5 }

        v21 = vmulq_f64(*a2, _Q1);
        *&v22.f64[0] = *&vaddq_f64(v21, _Q1);
        result = vsubq_f64(_Q1, v21);
        v22.f64[1] = result.f64[1];
        *a2 = v22;
        return result;
      }

      a2->f64[0] = *(a1 + 144) * v6 / v8;
      v10 = *(a1 + 152) * v7 / v8;
    }

    a2->f64[1] = v10;
    goto LABEL_12;
  }

  if (!*a1)
  {
    a2->f64[0] = 0.0;
    a2->f64[1] = 0.0;
    a2[1].f64[0] = 1.0;
  }

  return result;
}

BOOL lzma_decompress_bytes()
{
  v0 = 0;
  if (!lzma_auto_decoder())
  {
    v0 = lzma_code() < 2;
    lzma_end();
  }

  return v0;
}

uint64_t ppred_decompress(float **a1, unsigned int *a2, float **a3, unsigned int *a4, uint64_t *a5, void *a6, unsigned int **a7, void *a8, void *a9, int *a10, uint64_t a11)
{
  *(a11 + 116) = 0u;
  *(a11 + 104) = 0u;
  *(a11 + 88) = 0u;
  v11 = *(a11 + 16);
  v12 = *(a11 + 40);
  v13 = *a11;
  v14 = **a11;
  *(a11 + 88) = 32;
  v15 = *(v13 + 5);
  v16 = *(v13 + 1);
  *(a11 + 88) = 224;
  v17 = *(v13 + 7);
  v18 = *(v13 + 9);
  *(a11 + 88) = 320;
  v19 = *(v13 + 40);
  *(a11 + 88) = 328;
  *a4 = *(v13 + 41);
  v20 = *(a11 + 88);
  v21 = v20 + 32;
  *(a11 + 88) = v20 + 32;
  v22 = *a11;
  if (v20 < -32)
  {
    v21 = v20 + 39;
  }

  v23 = *(v22 + (v21 >> 3));
  v24 = v20 + 64;
  *(a11 + 88) = v20 + 64;
  if (v20 < -64)
  {
    v24 = v20 + 71;
  }

  v25 = *(v22 + (v24 >> 3));
  v26 = v20 + 96;
  *(a11 + 88) = v20 + 96;
  if (v20 < -96)
  {
    v26 = v20 + 103;
  }

  v27 = *(v22 + (v26 >> 3));
  v28 = v20 + 104;
  *(a11 + 88) = v20 + 104;
  if (v20 < -104)
  {
    v28 = v20 + 111;
  }

  v29 = *(v22 + (v28 >> 3));
  v30 = v20 + 136;
  *(a11 + 88) = v20 + 136;
  if (v20 < -136)
  {
    v30 = v20 + 143;
  }

  v31 = *(v22 + (v30 >> 3));
  *(a11 + 88) = v20 + 168;
  v32 = 1;
  if ((v14 & 0x80000000) == 0 && v19 && (v23 & 0x80000000) == 0 && (v25 & 0x80000000) == 0 && v27 && (v31 & 0x80000000) == 0)
  {
    v33 = *v12;
    *a10 = v33;
    if ((v33 & 0x80000000) == 0)
    {
      v392 = v11;
      v389 = v27;
      v399 = v25;
      count = v31;
      v377 = v16;
      v378 = v15;
      v376 = v19;
      v36.i32[0] = 0;
      v36.i32[1] = v14;
      v407 = vadd_s32(v36, 0xFFFFFFE000000020);
      v37 = 3 * v33;
      v38 = 12 * v33;
      v39 = malloc_type_malloc(12 * v33, 0x100004052888210uLL);
      v40 = malloc_type_malloc(v38, 0x100004052888210uLL);
      memset(v39, 255, v38);
      memset(v40, 255, v38);
      v41.i32[0] = v407.i32[0];
      v42 = v407.i32[1];
      if (v407.i32[1] < 0x80u)
      {
        v43 = a2;
        v44 = a7;
      }

      else
      {
        v43 = a2;
        v44 = a7;
        do
        {
          v45 = *(v12 + v41.i32[0] / 8);
          v46 = v41.i32[0] + 39;
          if (v41.i32[0] + 32 >= 0)
          {
            v46 = v41.i32[0] + 32;
          }

          v47 = *(v12 + (v46 >> 3));
          if ((v45 & 0x80000000) == 0)
          {
            *&v39[4 * v45] = v47;
          }

          if ((v47 & 0x80000000) == 0)
          {
            *&v39[4 * v47] = v45;
          }

          v41.i32[1] = v42;
          v41 = vadd_s32(v41, 0xFFFFFFC000000040);
          v42 = v41.i32[1];
        }

        while (v41.i32[1] > 0x7Fu);
      }

      v382 = v43;
      v48 = 0;
      v49 = *(v12 + v41.i32[0] / 8);
      *v43 = v49;
      v50 = v41.i32[0] + 39;
      if (v41.i32[0] + 32 >= 0)
      {
        v50 = v41.i32[0] + 32;
      }

      v397 = v44;
      if ((v49 & 0x80000000) != 0 || (v51 = *(v12 + (v50 >> 3)), v51 < 0))
      {
        v393 = 0;
        v52 = v39;
        v54 = v40;
      }

      else
      {
        v52 = malloc_type_calloc(*a10, 4uLL, 0x100004052888210uLL);
        v53 = malloc_type_malloc(v37, 0x100004077774924uLL);
        v54 = v53;
        v55 = *a10;
        if (v51)
        {
          v56 = 1;
        }

        else
        {
          v56 = v55 < 1;
        }

        if (v56)
        {
          LODWORD(v53) = 0;
        }

        else
        {
          *v53 = 80;
          v55 = *a10;
          LODWORD(v53) = 1;
        }

        v57 = v392;
        if (v53 < v55)
        {
          v58 = 0;
          v59 = 0;
          v60 = 0;
          v61 = 0;
          v62 = v53;
          while (1)
          {
            if (v58 <= 0)
            {
              v64 = *v57++;
              v59 |= bswap32(v64) << (32 - v58);
              v58 += 32;
            }

            v65 = v59;
            v66 = v58 - 1;
            v59 *= 2;
            if ((v65 & 0x8000000000000000) != 0)
            {
              if (v58 <= 2)
              {
                v67 = *v57++;
                v59 |= bswap32(v67) << (33 - v58);
                v66 = v58 + 31;
              }

              v68 = v59 >> 62;
              v66 -= 2;
              v59 *= 4;
              if (v68 >= 2)
              {
                if (v68 != 2)
                {
                  v53 = v62 + 1;
                  v54[v62] = 69;
                  if (v60 < 1)
                  {
                    ++v61;
                    if (v53 < *a10)
                    {
                      if (v61 >= v51)
                      {
                        v54[v53] = 80;
                        LODWORD(v53) = v62 + 2;
                      }

                      else
                      {
                        v52[v61] = v53;
                      }
                    }
                  }

                  else
                  {
                    --v60;
                  }

                  goto LABEL_43;
                }

                v63 = 76;
              }

              else
              {
                if (!v68)
                {
                  LODWORD(v53) = v62 + 1;
                  v54[v62] = 83;
                  if (*&v39[12 * v62 + 4 * ((3 * v62 + 2) % 3)] == -1)
                  {
                    ++v60;
                  }

                  goto LABEL_43;
                }

                v63 = 82;
              }
            }

            else
            {
              v63 = 67;
            }

            LODWORD(v53) = v62 + 1;
            v54[v62] = v63;
LABEL_43:
            v58 = v66;
            v62 = v53;
            if (v53 >= *a10)
            {
              goto LABEL_64;
            }
          }
        }

        v61 = 0;
LABEL_64:
        v69 = *v382;
        LODWORD(v70) = v53 - 1;
        if (v53 < 1)
        {
          v71 = 0;
        }

        else
        {
          v71 = malloc_type_calloc((3 * v53), 4uLL, 0x100004052888210uLL);
        }

        v72 = v69 - 1;
        if (v61 >= 1)
        {
          LODWORD(v73) = 0;
          do
          {
            --v61;
            v70 = v70;
            v74 = -1;
            while (v61 >= v51 || (v61 & 0x80000000) == 0 && v70 >= v52[v61])
            {
              v75 = v54[v70];
              if (v75 > 0x4F)
              {
                switch(v75)
                {
                  case 'P':
                    v90 = 3 * v70;
                    if ((v74 & 0x80000000) == 0)
                    {
                      *&v39[4 * v74] = v90;
                    }

                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[12 * v70] = v74;
                    }

                    v91 = v90 + 1;
                    v92 = v72 - 2;
                    v93 = 3 * ((v90 + 1) / 3);
                    v94 = v93 + (v90 + 3) % 3;
                    v95 = &v39[4 * v94];
                    if ((*v95 & 0x80000000) != 0 || *v95 == v91)
                    {
                      v96 = v90 + 1;
                    }

                    else
                    {
                      v96 = v90 + 1;
                      do
                      {
                        *(v40 + (v96 + 1) % 3 + v93) = v92;
                        v96 = *v95;
                        v93 = 3 * (*v95 / 3);
                        v94 = v93 + (*v95 + 2) % 3;
                        v95 = &v39[4 * v94];
                      }

                      while ((*v95 & 0x80000000) == 0 && *v95 != v91);
                    }

                    *(v40 + (v96 + 1) % 3 + v93) = v92;
                    if ((v94 & 0x80000000) == 0)
                    {
                      *&v39[4 * v94] = v91;
                    }

                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[4 * v91] = v94;
                    }

                    v97 = v90 + 2;
                    v98 = v72 - 1;
                    v99 = 3 * ((v90 + 2) / 3);
                    v100 = v99 + (v90 + 4) % 3;
                    v101 = &v39[4 * v100];
                    if ((*v101 & 0x80000000) != 0 || *v101 == v97)
                    {
                      v103 = v90 + 2;
                      v102 = 3 * ((v90 + 2) / 3);
                    }

                    else
                    {
                      v102 = 3 * ((v90 + 2) / 3);
                      v103 = v90 + 2;
                      do
                      {
                        *(v40 + (v103 + 1) % 3 + v102) = v98;
                        v103 = *v101;
                        v102 = 3 * (*v101 / 3);
                        v100 = v102 + (*v101 + 2) % 3;
                        v101 = &v39[4 * v100];
                      }

                      while ((*v101 & 0x80000000) == 0 && *v101 != v97);
                    }

                    *(v40 + (v103 + 1) % 3 + v102) = v98;
                    if ((v100 & 0x80000000) == 0)
                    {
                      *&v39[4 * v100] = v97;
                    }

                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[4 * v97] = v100;
                    }

                    v104 = v97 - v99 + v90;
                    v105 = &v39[4 * v104];
                    if ((*v105 & 0x80000000) != 0)
                    {
                      v106 = 3 * v70;
                      v107 = 3 * v70;
                    }

                    else
                    {
                      v106 = 3 * v70;
                      v107 = 3 * v70;
                      if (*v105 != v90)
                      {
                        v107 = 3 * v70;
                        v106 = 3 * v70;
                        do
                        {
                          *(v40 + (v106 + 1) % 3 + v107) = v72;
                          v106 = *v105;
                          v107 = 3 * (*v105 / 3);
                          v104 = v107 + (*v105 + 2) % 3;
                          v105 = &v39[4 * v104];
                        }

                        while ((*v105 & 0x80000000) == 0 && *v105 != v90);
                      }
                    }

                    *(v40 + (v106 + 1) % 3 + v107) = v72;
                    if ((v104 & 0x80000000) == 0)
                    {
                      *&v39[4 * v104] = v90;
                    }

                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[12 * v70] = v104;
                    }

                    v72 -= 3;
                    --v61;
                    break;
                  case 'R':
                    v76 = 3 * v70 + 2;
                    if ((v74 & 0x80000000) != 0)
                    {
LABEL_83:
                      if ((v70 & 0x8000000000000000) == 0)
                      {
                        *&v39[4 * v76] = v74;
                      }

                      break;
                    }

LABEL_82:
                    *&v39[4 * v74] = v76;
                    goto LABEL_83;
                  case 'S':
                    v77 = 3 * v70;
                    v78 = 3 * v70 + 1;
                    if ((v74 & 0x80000000) == 0)
                    {
                      *&v39[4 * v74] = v78;
                    }

                    if (v70 < 0)
                    {
                      v79 = v77 + 2;
                      v108 = *&v39[4 * v79];
                      if (v108 == -1 && v71 != 0)
                      {
                        v73 = v73 - 1;
                        v116 = v71[v73];
                        if ((v116 & 0x80000000) != 0)
                        {
                          break;
                        }

LABEL_174:
                        *&v39[4 * v116] = v79;
                        break;
                      }

                      if (v108 > -2)
                      {
                        break;
                      }

                      v82 = -v108;
                      goto LABEL_157;
                    }

                    *&v39[4 * v78] = v74;
                    v79 = v77 + 2;
                    v80 = *&v39[4 * v79];
                    if (v80 != -1 || v71 == 0)
                    {
                      if (v80 >= -1)
                      {
                        break;
                      }

                      v82 = -v80;
                      *&v39[4 * v79] = v82;
LABEL_157:
                      *&v39[4 * v82] = v79;
                      do
                      {
                        v110 = 3 * (v79 / 3) + (v79 + 1) % 3;
                        LODWORD(v79) = *&v39[4 * v110];
                      }

                      while ((v79 & 0x80000000) == 0);
                      v111 = 3 * (v110 / 3) + (v110 + 1) % 3;
                      do
                      {
                        v112 = 3 * (v111 / 3) + (v111 + 1) % 3;
                        v111 = *&v39[4 * v112];
                      }

                      while ((v111 & 0x80000000) == 0);
                      do
                      {
                        v113 = 3 * (v112 / 3);
                        *(v40 + v113 + (v112 + 1) % 3) = v72;
                        v112 = v113 + (v112 + 2) % 3;
                        for (i = *&v39[4 * v112]; (i & 0x80000000) == 0; i = *&v39[4 * v112])
                        {
                          v115 = 3 * (i / 3);
                          *(v40 + v115 + (i + 1) % 3) = v72;
                          v112 = v115 + (i + 2) % 3;
                        }

                        --v72;
                      }

                      while (*(v40 + 3 * (v112 / 3) + (v112 + 1) % 3) == -1);
                      break;
                    }

                    v73 = v73 - 1;
                    v116 = v71[v73];
                    *&v39[4 * v79] = v116;
                    if ((v116 & 0x80000000) == 0)
                    {
                      goto LABEL_174;
                    }

                    break;
                  default:
                    break;
                }
              }

              else
              {
                switch(v75)
                {
                  case 'C':
                    v83 = 3 * v70;
                    v84 = 3 * v70 + 1;
                    if ((v74 & 0x80000000) == 0)
                    {
                      *&v39[4 * v74] = v84;
                    }

                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[4 * v84] = v74;
                    }

                    v85 = v83 + 2;
                    v86 = 3 * ((v83 + 2) / 3);
                    v87 = v86 + (v83 + 4) % 3;
                    v88 = &v39[4 * v87];
                    if ((*v88 & 0x80000000) != 0 || *v88 == v85)
                    {
                      v89 = v85;
                    }

                    else
                    {
                      v89 = v85;
                      do
                      {
                        *(v40 + (v89 + 1) % 3 + v86) = v72;
                        v89 = *v88;
                        v86 = 3 * (*v88 / 3);
                        v87 = v86 + (*v88 + 2) % 3;
                        v88 = &v39[4 * v87];
                      }

                      while ((*v88 & 0x80000000) == 0 && *v88 != v85);
                    }

                    *(v40 + (v89 + 1) % 3 + v86) = v72;
                    if ((v87 & 0x80000000) == 0)
                    {
                      *&v39[4 * v87] = v85;
                    }

                    --v72;
                    if ((v70 & 0x8000000000000000) == 0)
                    {
                      *&v39[4 * v85] = v87;
                    }

                    break;
                  case 'E':
                    if (v74 >= 1 && v71)
                    {
                      v71[v73] = v74;
                      LODWORD(v73) = v73 + 1;
                    }

                    break;
                  case 'L':
                    v76 = 3 * v70 + 1;
                    if ((v74 & 0x80000000) != 0)
                    {
                      goto LABEL_83;
                    }

                    goto LABEL_82;
                  default:
                    break;
                }
              }

              v74 = 3 * v70--;
            }

            if (v51)
            {
              v117 = 3 * v52[v61];
              v118 = 3 * ((v117 + 1) / 3) + (v117 + 2) % 3;
              do
              {
                v119 = 3 * (v118 / 3) + (v118 + 1) % 3;
                v118 = *&v39[4 * v119];
              }

              while ((v118 & 0x80000000) == 0);
              do
              {
                v120 = 3 * (v119 / 3);
                *(v40 + v120 + (v119 + 1) % 3) = v72;
                v119 = v120 + (v119 + 2) % 3;
                for (j = *&v39[4 * v119]; (j & 0x80000000) == 0; j = *&v39[4 * v119])
                {
                  v122 = 3 * (j / 3);
                  *(v40 + v122 + (j + 1) % 3) = v72;
                  v119 = v122 + (j + 2) % 3;
                }

                --v72;
              }

              while (*(v40 + 3 * (v119 / 3) + (v119 + 1) % 3) == -1);
              --v51;
            }
          }

          while (v61 > 0);
        }

        free(v71);
        if (v72 == -1)
        {
          *a5 = v40;
          v48 = 1;
          v393 = v39;
        }

        else
        {
          free(v39);
          free(v40);
          v393 = 0;
          v48 = 0;
        }
      }

      free(v52);
      free(v54);
      if (v48)
      {
        v123 = malloc_type_calloc(*a10, 4uLL, 0x100004052888210uLL);
        v124 = v123;
        *a8 = v123;
        v125 = *(a11 + 24);
        if (v23)
        {
          v126 = 0;
          v127 = 0;
          v128 = v123;
          v129 = *(a11 + 24);
          v130 = v382;
          v131 = v397;
          do
          {
            if (v127 <= 0)
            {
              v133 = *v129++;
              v126 |= bswap32(v133) << 32;
              v127 = 32;
            }

            v132 = v126 >> 63;
            --v127;
            v126 *= 2;
            *v128++ = v132;
            --v23;
          }

          while (v23);
        }

        else
        {
          v127 = 0;
          v129 = *(a11 + 24);
          v130 = v382;
          v131 = v397;
        }

        *(a11 + 100) = *(a11 + 100) - v127 + 8 * (v129 - v125);
        v134 = *a10;
        v135 = malloc_type_calloc(v134, 4uLL, 0x100004052888210uLL);
        v136 = v135;
        if (v134 >= 1)
        {
          v137 = 0;
          v138 = 0;
          v139 = v393 + 2;
          v140 = 1;
          v141 = v135;
          v142 = v134;
          while (1)
          {
            if (*v141)
            {
              goto LABEL_198;
            }

            if (*(v139 - 2) == -1)
            {
              break;
            }

            v143 = 3 * v137;
            if (*(v139 - 1) == -1)
            {
              v145 = v143 + 1;
              goto LABEL_207;
            }

            if (*v139 == -1)
            {
              v145 = v143 + 2;
              goto LABEL_207;
            }

            v144 = 0;
LABEL_197:
            *v141 = v144;
LABEL_198:
            ++v137;
            v140 += 3;
            v139 += 3;
            ++v141;
            if (!--v142)
            {
              goto LABEL_209;
            }
          }

          v145 = v140 - 1;
LABEL_207:
          v146 = v138 + 1;
          v144 = v124[v138];
          if (v144)
          {
            v147 = 1431655766 * v393[3 * (v145 / 3) + (v145 + 2) % 3];
            v136[(HIDWORD(v147) + (v147 >> 63))] = v144;
          }

          v138 = v146;
          goto LABEL_197;
        }

LABEL_209:
        memcpy(v124, v136, 4 * v134);
        free(v136);
        v148 = malloc_type_calloc(*a10, 4uLL, 0x100004052888210uLL);
        *v131 = v148;
        v149 = *(a11 + 32);
        if (v399 < 1)
        {
          v151 = 0;
          v154 = *(a11 + 32);
          v155 = a5;
        }

        else
        {
          v150 = 0;
          v151 = 0;
          v152 = v148;
          v153 = v399;
          v154 = *(a11 + 32);
          v155 = a5;
          do
          {
            if (v151 < v389)
            {
              v157 = *v154++;
              v150 |= bswap32(v157) << (32 - v151);
              v151 += 32;
            }

            v156 = v150 >> (64 - v389);
            v151 -= v389;
            v150 <<= v389;
            *v152++ = v156;
            --v153;
          }

          while (v153);
        }

        *(a11 + 104) = *(a11 + 104) - v151 + 8 * (v154 - v149);
        if (v399 == 1)
        {
          v158 = *a10;
          if (v158 > 1)
          {
            v159 = *v148;
            if (v158 < 9)
            {
              v160 = 1;
              goto LABEL_223;
            }

            v161 = (v158 - 1) & 0xFFFFFFFFFFFFFFF8;
            v162 = vdupq_n_s32(v159);
            v163 = (v148 + 5);
            v164 = v161;
            do
            {
              v163[-1] = v162;
              *v163 = v162;
              v163 += 2;
              v164 -= 8;
            }

            while (v164);
            if (v158 - 1 != v161)
            {
              v160 = v161 | 1;
LABEL_223:
              v165 = v158 - v160;
              v166 = &v148[v160];
              do
              {
                *v166++ = v159;
                --v165;
              }

              while (v165);
            }
          }
        }

        v167 = malloc_type_calloc(*v130, 4uLL, 0x100004052888210uLL);
        v168 = v167;
        *a9 = v167;
        v169 = *(a11 + 72);
        if (v29 < 1)
        {
          v171 = 0;
          v173 = *(a11 + 72);
        }

        else
        {
          v170 = 0;
          v171 = 0;
          v172 = v167;
          v173 = *(a11 + 72);
          do
          {
            if (v171 <= 0)
            {
              v175 = *v173++;
              v170 |= bswap32(v175) << 32;
              v171 = 32;
            }

            v174 = v170 >> 63;
            --v171;
            v170 *= 2;
            *v172++ = v174;
            --v29;
          }

          while (v29);
        }

        *(a11 + 124) = *(a11 + 124) - v171 + 8 * (v173 - v169);
        v176 = *v130;
        v177 = *a10;
        v178 = *v155;
        v179 = malloc_type_calloc(v176, 4uLL, 0x100004052888210uLL);
        v180 = malloc_type_calloc(v176, 4uLL, 0x100004052888210uLL);
        v181 = v180;
        if (v177 >= 1)
        {
          v182 = 0;
          LODWORD(v183) = 3 * v177;
          if (3 * v177 <= 1)
          {
            v183 = 1;
          }

          else
          {
            v183 = v183;
          }

          do
          {
            while (v393[v182] == -1)
            {
              v184 = 3 * (v182 / 3);
              *(v180 + *(v178 + 4 * (v184 + (v182++ + 2) % 3u))) = 1;
              *(v180 + *(v178 + 4 * (v184 + v182 % 3))) = 1;
              if (v182 == v183)
              {
                goto LABEL_238;
              }
            }

            ++v182;
          }

          while (v182 != v183);
        }

LABEL_238:
        if (v176 >= 1)
        {
          v185 = 0;
          v186 = v180;
          v187 = v179;
          v188 = v176;
          do
          {
            if (*v186++)
            {
              v190 = v168[v185++];
              *v187 = v190;
            }

            ++v187;
            --v188;
          }

          while (v188);
        }

        memcpy(v168, v179, 4 * v176);
        free(v179);
        free(v181);
        v191 = malloc_type_malloc(4 * *v130, 0x100004052888210uLL);
        v192 = *v130;
        v193 = *(a11 + 64);
        v400 = v191;
        if (v192 < 1)
        {
          v195 = 0;
          LODWORD(v197) = *(a11 + 64);
          v198 = count;
        }

        else
        {
          v194 = 0;
          v195 = 0;
          v196 = v191;
          v197 = *(a11 + 64);
          v198 = count;
          do
          {
            if (v195 <= 0)
            {
              v200 = *v197++;
              v194 |= bswap32(v200) << 32;
              v195 = 32;
            }

            v199 = v194 >> 63;
            --v195;
            v194 *= 2;
            *v196++ = v199;
            --v192;
          }

          while (v192);
        }

        *(a11 + 120) = *(a11 + 120) - v195 + 8 * (v197 - v193);
        v201 = malloc_type_calloc(v198, 4uLL, 0x100004052888210uLL);
        v202 = *(a11 + 8);
        counta = v201;
        v203 = v131;
        if (v198 < 1)
        {
          v205 = 0;
          LODWORD(v207) = *(a11 + 8);
        }

        else
        {
          v204 = 0;
          v205 = 0;
          v206 = v201;
          v207 = *(a11 + 8);
          do
          {
            if (v205 <= 0)
            {
              v209 = *v207++;
              v204 |= bswap32(v209) << 32;
              v205 = 32;
            }

            v208 = v204 >> 63;
            --v205;
            v204 *= 2;
            *v206++ = v208;
            --v198;
          }

          while (v198);
        }

        *(a11 + 92) = *(a11 + 92) - v205 + 8 * (v207 - v202);
        v388 = *(a11 + 56);
        v390 = *(a11 + 48);
        v391 = malloc_type_calloc(*a4, 4uLL, 0x100004052888210uLL);
        v210 = malloc_type_malloc(12 * *a10, 0x100004052888210uLL);
        *a6 = v210;
        v211 = *v155;
        v212 = *a10;
        v213 = *v130;
        v214 = *v203;
        v409 = malloc_type_calloc(v213, 4uLL, 0x100004052888210uLL);
        v398 = malloc_type_malloc(4 * v213, 0x100004052888210uLL);
        memset(v398, 255, 4 * v213);
        v215 = malloc_type_calloc(v212, 4uLL, 0x100004052888210uLL);
        v408 = malloc_type_malloc(12 * v212, 0x100004052888210uLL);
        v216 = malloc_type_malloc(12 * v212, 0x100004052888210uLL);
        v387 = malloc_type_calloc(v213, 6uLL, 0x1000040274DC3F3uLL);
        v381 = v212;
        __n = 4 * v212;
        v217 = malloc_type_malloc(4 * v212, 0x100004052888210uLL);
        v218 = v216;
        v404 = v217;
        v219 = 0;
        v385 = 0;
        v220 = 0;
        v383 = 0;
        *a4 = 0;
        __dst = v214;
        v402 = v214 - 4;
        v221 = v393;
        v222 = v400;
        v386 = v218;
LABEL_257:
        v223 = v383;
        if (v383 < v381)
        {
          v224 = v383;
          while (v215[v224])
          {
            if (v381 == ++v224)
            {
              goto LABEL_292;
            }
          }

          v223 = v224;
        }

        if (v223 != v381)
        {
          v225 = 3 * v223;
          *v408 = 3 * v223;
          v226 = (v225 + 2) % 3 + v225;
          v227 = *(v211 + 4 * v226);
          v228 = *(v211 + 12 * v223);
          v229 = (v225 + 1) % 3 + v225;
          v230 = *(v211 + 4 * v229);
          v231 = &v387[6 * v227];
          v232 = &v388[6 * v227];
          v233 = *v232;
          *(v231 + 2) = *(v232 + 2);
          *v231 = v233;
          v234 = &v387[6 * v228];
          v235 = &v388[6 * v228];
          v236 = *v235;
          *(v234 + 2) = *(v235 + 2);
          *v234 = v236;
          v237 = &v387[6 * v230];
          v238 = &v388[6 * v230];
          v239 = *v238;
          *(v237 + 2) = *(v238 + 2);
          *v237 = v239;
          v240 = 1;
          v409[v230] = 1;
          v409[v228] = 1;
          v409[v227] = 1;
          *&v391[2 * *a4] = *(v390 + 4 * *a4);
          LODWORD(v227) = (*a4)++;
          v210[v226] = v227;
          *&v391[2 * *a4] = *(v390 + 4 * *a4);
          LODWORD(v227) = (*a4)++;
          v210[3 * v223] = v227;
          *&v391[2 * *a4] = *(v390 + 4 * *a4);
          LODWORD(v227) = (*a4)++;
          v210[v229] = v227;
          *(v398 + *(v211 + 4 * v226)) = v210[v226];
          *(v398 + *(v211 + 12 * v223)) = v210[3 * v223];
          *(v398 + *(v211 + 4 * v229)) = v210[v229];
          v215[v223] = 1;
          ++v385;
          v383 = v223;
          v404[v223] = *&v402[4 * v385];
          while (1)
          {
            if (v240)
            {
              v241 = v408[--v240];
              v406 = v385;
              v242 = v398;
            }

            else
            {
              v243 = v220 - 1;
              v218 = v386;
              do
              {
                v241 = *(v386 + v243);
                v244 = v215[v241 / 3];
                --v220;
                v245 = v243-- != 0;
              }

              while (v245 && v244);
              if (v244)
              {
                goto LABEL_257;
              }

              v384 = v241 / 3;
              memset(v398, 255, 4 * v213);
              v221 = v393;
              v246 = *(v211 + 4 * v241);
              if (!v409[v246])
              {
                v247 = v393[v241];
                v248 = *(v211 + 4 * v247);
                v249 = 3 * (v247 / 3);
                v250 = *(v211 + 4 * (v249 + (v247 + 2) % 3));
                v251 = &v387[6 * *(v211 + 4 * (v249 + (v247 + 1) % 3))];
                LOWORD(v249) = *v251;
                v252 = &v387[6 * v250];
                v253 = *v252;
                v254 = &v387[6 * v248];
                v255 = *v254;
                v256 = *(v251 + 1);
                v257 = *(v252 + 1);
                v258 = *(v254 + 1);
                LOWORD(v251) = *(v251 + 2);
                LOWORD(v252) = *(v252 + 2);
                LOWORD(v254) = *(v254 + 2);
                v259 = &v388[6 * v246];
                LOWORD(v249) = v253 + v249 - (v255 + *v259);
                v260 = &v387[6 * v246];
                *v260 = v249;
                *(v260 + 1) = v257 + v256 - (v258 + *(v259 + 1));
                *(v260 + 2) = v252 + v251 - (v254 + *(v259 + 2));
                v409[v246] = 1;
              }

              v240 = 0;
              *&v391[2 * *a4] = *(v390 + 4 * *a4);
              v261 = (*a4)++;
              v262 = 3 * v384 + (v241 + 2) % 3;
              v210[v262] = v261;
              *&v391[2 * *a4] = *(v390 + 4 * *a4);
              v263 = (*a4)++;
              v210[v241] = v263;
              *&v391[2 * *a4] = *(v390 + 4 * *a4);
              v264 = (*a4)++;
              v265 = 3 * v384 + (v241 + 1) % 3;
              v210[v265] = v264;
              *(v398 + *(v211 + 4 * v262)) = v210[v262];
              *(v398 + *(v211 + 4 * v241)) = v210[v241];
              *(v398 + *(v211 + 4 * v265)) = v210[v265];
              v215[v384] = 1;
              v406 = ++v385;
              v404[v384] = *&v402[4 * v385];
              *v408 = v241;
              v242 = v398;
            }

            v266 = v241;
            do
            {
              v270 = v221[v266];
              if ((v270 & 0x80000000) == 0)
              {
                v271 = v270 / 3uLL;
                if (!v215[v271])
                {
                  v272 = *(v211 + 4 * v270);
                  v273 = 3 * (v266 / 3);
                  v274 = v273 + (v266 + 2) % 3;
                  v275 = v273 + (v266 + 1) % 3;
                  if (v222[*(v211 + 4 * v274)] && v222[*(v211 + 4 * v275)])
                  {
                    v276 = (v219 + 1);
                    if (counta[v219])
                    {
                      v268 = v220;
                      v269 = v386;
                      ++v220;
LABEL_279:
                      v269[v268] = v270;
                      v219 = v276;
                      goto LABEL_280;
                    }
                  }

                  else
                  {
                    v276 = v219;
                  }

                  if (!v409[v272])
                  {
                    v277 = v221[v270];
                    v278 = *(v211 + 4 * v277);
                    v279 = 3 * (v277 / 3);
                    v280 = *(v211 + 4 * (v279 + (v277 + 2) % 3));
                    v281 = &v387[6 * *(v211 + 4 * (v279 + (v277 + 1) % 3))];
                    LOWORD(v279) = *v281;
                    v282 = &v387[6 * v280];
                    v283 = *v282;
                    v284 = &v387[6 * v278];
                    v285 = *v284;
                    v286 = *(v281 + 1);
                    v287 = *(v282 + 1);
                    v288 = *(v284 + 1);
                    LOWORD(v281) = *(v281 + 2);
                    LOWORD(v282) = *(v282 + 2);
                    LOWORD(v284) = *(v284 + 2);
                    v289 = &v388[6 * v272];
                    v222 = v400;
                    LOWORD(v279) = v283 + v279 - (v285 + *v289);
                    v290 = &v387[6 * v272];
                    *v290 = v279;
                    *(v290 + 1) = v287 + v286 - (v288 + *(v289 + 1));
                    LOWORD(v279) = *(v289 + 2);
                    v221 = v393;
                    *(v290 + 2) = v282 + v281 - (v284 + v279);
                    v409[v272] = 1;
                  }

                  v291 = v242[v272];
                  if (v291 == -1)
                  {
                    v292 = v221[v270];
                    v293 = 3 * (v292 / 3);
                    v294 = *(v211 + 4 * v270);
                    v295 = &v391[2 * v210[v293 + (v292 + 1) % 3]];
                    v296 = *v295;
                    v297 = &v391[2 * v210[v293 + (v292 + 2) % 3]];
                    v298 = *v297;
                    v299 = &v391[2 * v210[v292]];
                    v300 = *v299;
                    LOWORD(v295) = v295[1];
                    LOWORD(v297) = v297[1];
                    LOWORD(v299) = v299[1];
                    v301 = *a4;
                    v302 = (v390 + 4 * v301);
                    v242 = v398;
                    v222 = v400;
                    v303 = v298 + v296 - (v300 + *v302);
                    v304 = &v391[2 * v301];
                    *v304 = v303;
                    v304[1] = v297 + v295 - (v299 + v302[1]);
                    v210[v270] = v301;
                    *a4 = v301 + 1;
                    *(v398 + v294) = v210[v270];
                  }

                  else
                  {
                    v210[v270] = v291;
                  }

                  v267 = 3 * v271;
                  v210[v267 + (v270 + 2) % 3] = v210[v275];
                  v210[v267 + (v270 + 1) % 3] = v210[v274];
                  v215[v271] = 1;
                  v404[v271] = *&v402[4 * v406];
                  v268 = v240++;
                  v269 = v408;
                  goto LABEL_279;
                }
              }

LABEL_280:
              v266 = 3 * (v266 / 3) + (v266 + 1) % 3;
            }

            while (v266 != v241);
            if (!(v240 | v220))
            {
              v220 = 0;
              v218 = v386;
              goto LABEL_257;
            }
          }
        }

LABEL_292:
        v305 = v218;
        memcpy(v388, v387, 6 * v213);
        memcpy(__dst, v404, __n);
        free(v409);
        free(v398);
        free(v215);
        free(v408);
        free(v305);
        free(v387);
        free(v404);
        v306 = malloc_type_malloc(12 * *v382, 0x10000403E1C8BA9uLL);
        *a1 = v306;
        v307 = *v382;
        if (v307 >= 1)
        {
          v308 = vcvtq_f64_f32(v17);
          *&v309 = v18;
          if (v307 < 8)
          {
            v310 = 0;
LABEL_298:
            v344 = v307 - v310;
            v345 = &v306[3 * v310 + 2];
            v346 = &v388[6 * v310 + 4];
            do
            {
              v347.i64[0] = *(v346 - 2);
              v347.i64[1] = *(v346 - 1);
              v348 = vcvt_f32_f64(vmlaq_f64(v308, vcvtq_f64_s64(v347), v377));
              v345[-1] = v348;
              v348.i16[0] = *v346;
              *v348.i32 = *&v309 + *&v378 * vmovl_s16(v348).i32[0];
              v345->i32[0] = v348.i32[0];
              v345 = (v345 + 12);
              v346 += 3;
              --v344;
            }

            while (v344);
            goto LABEL_300;
          }

          v311 = vdupq_lane_s64(*&v377.f64[0], 0);
          v312 = vdupq_lane_s64(*&v308.f64[0], 0);
          v313 = vdupq_laneq_s64(v377, 1);
          v314 = vdupq_laneq_s64(v308, 1);
          v315 = vdupq_lane_s64(v378, 0);
          v310 = v307 & 0x7FFFFFF8;
          v316 = v388;
          v317 = v306;
          v318 = v310;
          v319 = vdupq_lane_s64(v309, 0);
          do
          {
            v414 = vld3q_s16(v316);
            v316 += 24;
            v320 = vmovl_high_s16(v414.val[0]);
            v321.i64[0] = v320.i32[0];
            v321.i64[1] = v320.i32[1];
            v322 = vcvtq_f64_s64(v321);
            v321.i64[0] = v320.i32[2];
            v321.i64[1] = v320.i32[3];
            v323 = vcvtq_f64_s64(v321);
            v324 = vmovl_s16(*v414.val[0].i8);
            v321.i64[0] = v324.i32[0];
            v321.i64[1] = v324.i32[1];
            v325 = vcvtq_f64_s64(v321);
            v321.i64[0] = v324.i32[2];
            v321.i64[1] = v324.i32[3];
            v326 = vmlaq_f64(v312, vcvtq_f64_s64(v321), v311);
            v327 = vmlaq_f64(v312, v325, v311);
            v328 = vmlaq_f64(v312, v323, v311);
            v329 = vmlaq_f64(v312, v322, v311);
            v330 = vmovl_high_s16(v414.val[1]);
            v321.i64[0] = v330.i32[0];
            v321.i64[1] = v330.i32[1];
            v331 = vcvtq_f64_s64(v321);
            v321.i64[0] = v330.i32[2];
            v321.i64[1] = v330.i32[3];
            v332 = vcvtq_f64_s64(v321);
            v333 = vmovl_s16(*v414.val[1].i8);
            v321.i64[0] = v333.i32[0];
            v321.i64[1] = v333.i32[1];
            v334 = vcvtq_f64_s64(v321);
            v321.i64[0] = v333.i32[2];
            v321.i64[1] = v333.i32[3];
            v335 = vmlaq_f64(v314, vcvtq_f64_s64(v321), v313);
            v336 = vmlaq_f64(v314, v334, v313);
            v337 = vmlaq_f64(v314, v332, v313);
            v338 = vmlaq_f64(v314, v331, v313);
            v339 = vmovl_s16(*v414.val[2].i8);
            v321.i64[0] = v339.i32[0];
            v321.i64[1] = v339.i32[1];
            v340 = vcvtq_f64_s64(v321);
            v321.i64[0] = v339.i32[2];
            v321.i64[1] = v339.i32[3];
            v341 = vcvtq_f64_s64(v321);
            v414.val[0] = vmovl_high_s16(v414.val[2]);
            v321.i64[0] = v414.val[0].i32[0];
            v321.i64[1] = v414.val[0].i32[1];
            v414.val[1] = vcvtq_f64_s64(v321);
            v321.i64[0] = v414.val[0].i32[2];
            v321.i64[1] = v414.val[0].i32[3];
            v415.val[2] = vcvt_hight_f32_f64(vcvt_f32_f64(vmlaq_f64(v319, v340, v315)), vmlaq_f64(v319, v341, v315));
            v413.val[2] = vcvt_hight_f32_f64(vcvt_f32_f64(vmlaq_f64(v319, v414.val[1], v315)), vmlaq_f64(v319, vcvtq_f64_s64(v321), v315));
            v413.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(v338), v337);
            v413.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(v329), v328);
            v415.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(v336), v335);
            v415.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(v327), v326);
            v342 = v317 + 24;
            vst3q_f32(v317, v415);
            v343 = v317 + 12;
            vst3q_f32(v343, v413);
            v317 = v342;
            v318 -= 8;
          }

          while (v318);
          if (v310 != v307)
          {
            goto LABEL_298;
          }
        }

LABEL_300:
        v349 = malloc_type_malloc(8 * *a4, 0x100004000313F17uLL);
        *a3 = v349;
        v350 = *a4;
        if (v350 >= 1)
        {
          v351 = ~(-1 << v376);
          if (v350 >= 8)
          {
            v352 = v350 & 0x7FFFFFF8;
            v353 = v391;
            v354 = v349;
            v355 = v352;
            v356 = 1.0 / v351;
            do
            {
              v410 = vld2q_s16(v353);
              v353 += 16;
              v357 = vmovl_high_s16(v410.val[0]);
              v358.i64[0] = v357.i32[0];
              v358.i64[1] = v357.i32[1];
              v359 = vcvtq_f64_s64(v358);
              v358.i64[0] = v357.i32[2];
              v358.i64[1] = v357.i32[3];
              v360 = vcvtq_f64_s64(v358);
              v361 = vmovl_s16(*v410.val[0].i8);
              v358.i64[0] = v361.i32[0];
              v358.i64[1] = v361.i32[1];
              v362 = vcvtq_f64_s64(v358);
              v358.i64[0] = v361.i32[2];
              v358.i64[1] = v361.i32[3];
              v363 = vmulq_n_f64(vcvtq_f64_s64(v358), v356);
              v412.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v359, v356)), vmulq_n_f64(v360, v356));
              v364 = vmovl_high_s16(v410.val[1]);
              v358.i64[0] = v364.i32[0];
              v358.i64[1] = v364.i32[1];
              v365 = vcvtq_f64_s64(v358);
              v358.i64[0] = v364.i32[2];
              v358.i64[1] = v364.i32[3];
              v412.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v365, v356)), vmulq_n_f64(vcvtq_f64_s64(v358), v356));
              v411.val[0] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v362, v356)), v363);
              v410.val[0] = vmovl_s16(*v410.val[1].i8);
              v358.i64[0] = v410.val[0].i32[0];
              v358.i64[1] = v410.val[0].i32[1];
              v410.val[1] = vcvtq_f64_s64(v358);
              v358.i64[0] = v410.val[0].i32[2];
              v358.i64[1] = v410.val[0].i32[3];
              v411.val[1] = vcvt_hight_f32_f64(vcvt_f32_f64(vmulq_n_f64(v410.val[1], v356)), vmulq_n_f64(vcvtq_f64_s64(v358), v356));
              v366 = v354 + 16;
              vst2q_f32(v354, v411);
              v367 = v354 + 8;
              vst2q_f32(v367, v412);
              v354 = v366;
              v355 -= 8;
            }

            while (v355);
            if (v352 == v350)
            {
              goto LABEL_308;
            }
          }

          else
          {
            v352 = 0;
          }

          v368 = v350 - v352;
          v369 = &v349[2 * v352];
          v370 = &v391[2 * v352];
          v371 = 1.0 / v351;
          do
          {
            v372.i64[0] = *v370;
            v372.i64[1] = v370[1];
            *v369++ = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_s64(v372), v371));
            v370 += 2;
            --v368;
          }

          while (v368);
        }

LABEL_308:
        free(v222);
        free(counta);
        free(v391);
        free(v393);
        return 0;
      }
    }

    return 1;
  }

  return v32;
}

void freeHuffmanTreeInt(void *a1)
{
  if (a1)
  {
    freeHuffmanTreeInt(a1[2]);
    freeHuffmanTreeInt(a1[3]);

    free(a1);
  }
}

uint64_t m3d_eb_decompress_ppred_buf_portable(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t a5, int a6)
{
  v7 = 0;
  if (a6 == 3)
  {
    v8 = 11;
  }

  else
  {
    v8 = 10;
  }

  v9 = a1 + a2;
  v10 = 12 * v8;
  do
  {
    v11 = (v9 + 12 * v7);
    v12 = *v11;
    v13 = v11[1];
    v14 = *(v11 + 8);
    v15 = malloc_type_malloc((v12 + 3), 0xE764CDD2uLL);
    *(a5 + 8 * v7) = v15;
    if (v14 == 3)
    {
      v17 = a5;
      if (v7 == 7)
      {
        v18 = a4;
      }

      else
      {
        v18 = a3;
      }

      if (!v18)
      {
        return 0;
      }

      v19 = malloc_type_malloc((v13 + 3), 0xBC3EFC16uLL);
      memcpy(v19, (v9 + v10), v13);
      if (v12 >= 2)
      {
        v20 = 0;
        v21 = 0;
        v22 = *(v17 + 8 * v7);
        v23 = v12 >> 1;
        v24 = *v18;
        v25 = v19;
        do
        {
          if (v21 <= 0)
          {
            v28 = *v25++;
            v20 |= bswap32(v28) << (32 - v21);
            v21 += 32;
          }

          v29 = v21 - 1;
          v30 = 2 * v20;
          v31 = v21 - 1 + 8 * (v13 + v19 - v25);
          if (v31 > 0xF)
          {
            if (v21 <= 16)
            {
              v34 = *v25++;
              v30 |= bswap32(v34) << (33 - v21);
              v29 = v21 + 31;
            }

            v33 = HIWORD(v30);
          }

          else
          {
            if (v21 <= v31)
            {
              v32 = *v25++;
              v30 |= bswap32(v32) << (33 - v21);
              v29 = v21 + 31;
            }

            LODWORD(v33) = (v30 >> -v31) << (16 - v31);
          }

          v35 = (v24 + 8 * v33);
          v36 = *(v35 + 4);
          if (v36 < 1)
          {
            if (v29 <= 15)
            {
              v38 = *v25++;
              v30 |= bswap32(v38) << (32 - v29);
              v29 += 32;
            }

            v39 = v29 - 16;
            v40 = v30 << 16;
            v41 = -v36;
            if (v29 - 16 < v41)
            {
              v42 = *v25++;
              v40 |= bswap32(v42) << (48 - v29);
              v39 = v29 + 16;
            }

            v43 = v40 >> -v41;
            v44 = v18[*v35];
            v45 = *(v44 + 8 * v43 + 4) - 16;
            if (v39 < v45)
            {
              v46 = *v25++;
              v40 |= bswap32(v46) << (32 - v39);
              v39 += 32;
            }

            v21 = v39 - v45;
            v26 = v40 << v45;
            v35 = (v44 + 8 * v43);
          }

          else
          {
            if (v29 < v36)
            {
              v37 = *v25++;
              v30 |= bswap32(v37) << (32 - v29);
              v29 += 32;
            }

            v21 = v29 - v36;
            v26 = v30 << v36;
          }

          if (v20 >= 0)
          {
            LOWORD(v27) = *v35;
          }

          else
          {
            v27 = -*v35;
          }

          *v22++ = v27;
          v20 = v26;
          --v23;
        }

        while (v23);
      }

      free(v19);
      a5 = v17;
    }

    else if (v14 == 1)
    {
      if (lzma_auto_decoder())
      {
        return 0;
      }

      v16 = lzma_code();
      lzma_end();
      if (v16 >= 2)
      {
        return 0;
      }
    }

    else
    {
      if (v14)
      {
        return 0;
      }

      memcpy(v15, (v9 + v10), v13);
    }

    v10 += v13;
    ++v7;
  }

  while (v7 != v8);
  return 1;
}

void geo::c3m::EdgebreakerDecodeTable::~EdgebreakerDecodeTable(void ***this)
{
  v1 = *this;
  if (*this)
  {
    v3 = *v1;
    if (*v1)
    {
      v4 = v1 + 1;
      do
      {
        free(v3);
        v5 = *v4++;
        v3 = v5;
      }

      while (v5);
    }

    free(v1);
    *this = 0;
  }
}

uint64_t geo::c3m::EdgebreakerDecodeCache::getOrCreateTable(uint64_t a1, int *a2)
{
  v3 = a1;
  std::mutex::lock((a1 + 40));
  v4 = *a2;
  v5 = a2[1];
  v6 = a2[2];
  v7 = *(a2 + 6);
  v8 = *(v3 + 8);
  if (v8)
  {
    v9 = ((v4 << 6) + (v4 >> 2) + v5 - 0x61C8864680B583EBLL) ^ v4;
    v10 = (v6 + (v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9;
    v11 = (v7 + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583EBLL) ^ v10;
    v12 = vcnt_s8(v8);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v13 = v11;
      if (v11 >= *&v8)
      {
        v13 = v11 % *&v8;
      }
    }

    else
    {
      v13 = v11 & (*&v8 - 1);
    }

    v14 = *(*v3 + 8 * v13);
    if (v14)
    {
      v15 = *v14;
      if (*v14)
      {
        if (v12.u32[0] >= 2uLL)
        {
          while (1)
          {
            v17 = v15[1];
            if (v17 == v11)
            {
              if (v15[2] == __PAIR64__(v5, v4) && __PAIR64__(*(v15 + 14), *(v15 + 6)) == __PAIR64__(v7, v6))
              {
                goto LABEL_116;
              }
            }

            else
            {
              if (v17 >= *&v8)
              {
                v17 %= *&v8;
              }

              if (v17 != v13)
              {
                goto LABEL_24;
              }
            }

            v15 = *v15;
            if (!v15)
            {
              goto LABEL_24;
            }
          }
        }

        v16 = *&v8 - 1;
        do
        {
          v18 = v15[1];
          if (v18 == v11)
          {
            if (v15[2] == __PAIR64__(v5, v4) && __PAIR64__(*(v15 + 14), *(v15 + 6)) == __PAIR64__(v7, v6))
            {
              goto LABEL_116;
            }
          }

          else if ((v18 & v16) != v13)
          {
            break;
          }

          v15 = *v15;
        }

        while (v15);
      }
    }
  }

LABEL_24:
  v19 = 8 * v7;
  v20 = malloc_type_malloc(8 * v7, 0x2004093837F09uLL);
  v21 = v20;
  if (!v7)
  {
    free(v20);
    v36 = 0;
    goto LABEL_82;
  }

  v94 = v3;
  v95 = a2;
  v22 = 0;
  do
  {
    v23 = 0xFFFFFFFF / (v6 + v5 * v22);
    v24 = malloc_type_malloc(0x30uLL, 0x102004089A409D2uLL);
    v24[3] = 0;
    v24[4] = 0;
    v24[2] = 0;
    *(v24 + 40) = 0;
    v21[v22] = v24;
    *v24 = v22++;
    LODWORD(v5) = v5 + v4;
    *(v24 + 1) = v23;
    *(v24 + 2) = 0;
  }

  while (v7 != v22);
  if (v7 != 1)
  {
    v37 = v7 - 1;
    v38 = &v21[v7 - 1];
    do
    {
      v39 = v21[v37];
      v40 = v21[v7 - 2];
      v41 = malloc_type_malloc(0x30uLL, 0x102004089A409D2uLL);
      v41[4] = 0;
      *v41 = -1;
      v42 = *(v40 + 4) + *(v39 + 4);
      *(v39 + 32) = v41;
      v41[2] = v39;
      v41[3] = v40;
      *(v40 + 32) = v41;
      *(v41 + 4) = v42;
      *(v41 + 40) = 0;
      v43 = v38;
      v44 = v37;
      do
      {
        v45 = *(v43 - 1);
        if (v42 <= *(v45 + 4))
        {
          break;
        }

        *v43-- = v45;
        --v44;
      }

      while (v44);
      v21[v44] = v41;
      --v7;
      v38 -= 8;
      --v37;
    }

    while (v37);
  }

  v25 = *v21;
  free(v21);
  v3 = v94;
  if (!v25)
  {
    goto LABEL_56;
  }

  v26 = malloc_type_malloc(v19, 0x100004090D0E795uLL);
  bzero(v26, v19);
  v27 = malloc_type_malloc(0xA0uLL, 0x2004093837F09uLL);
  v28 = v27;
  *v27 = v25;
  LODWORD(v29) = 1;
  while (1)
  {
    v30 = v29;
    v29 = v29 - 1;
    v31 = v27[v29];
    if (!v31)
    {
      break;
    }

    v32 = *v31;
    if (v32 < 0)
    {
      v27[v29] = *(v31 + 2);
      LODWORD(v29) = v30 + 1;
      v27[v30] = *(v31 + 3);
      v34 = *(v31 + 2);
      if (!v34)
      {
        goto LABEL_35;
      }

LABEL_34:
      *(v34 + 8) = 2 * *(v31 + 2);
      *(v34 + 40) = *(v31 + 40) + 1;
      goto LABEL_35;
    }

    v33 = &v26[8 * v32];
    *v33 = *(v31 + 2);
    v33[4] = *(v31 + 40);
    v34 = *(v31 + 2);
    if (v34)
    {
      goto LABEL_34;
    }

LABEL_35:
    v35 = *(v31 + 3);
    if (v35)
    {
      *(v35 + 8) = (2 * *(v31 + 2)) | 1;
      *(v35 + 40) = *(v31 + 40) + 1;
    }

    if (!v29)
    {
      goto LABEL_47;
    }
  }

  free(v26);
  v26 = 0;
LABEL_47:
  freeHuffmanTreeInt(v25);
  free(v28);
  if (!v26)
  {
LABEL_56:
    v36 = 0;
    goto LABEL_81;
  }

  v46 = *(v95 + 6);
  v47 = malloc_type_malloc(0x10001uLL, 0xC5F872F0uLL);
  v48 = malloc_type_malloc(0x20000uLL, 0x1000040BDFB0063uLL);
  bzero(v47, 0x10001uLL);
  bzero(v48, 0x20000uLL);
  if (v46)
  {
    v49 = v26 + 4;
    v50 = 1;
    v51 = v46;
    do
    {
      v52 = *v49;
      if (v52 >= 17)
      {
        v53 = v52 - 16;
        v54 = v48[(*(v49 - 1) >> v53)];
        if (!v54)
        {
          v48[(*(v49 - 1) >> v53)] = v50;
          v54 = v50++;
        }

        if (v47[v54] < v53)
        {
          v47[v54] = v53;
        }
      }

      v49 += 8;
      --v51;
    }

    while (v51);
  }

  else
  {
    v50 = 1;
  }

  *v47 = 16;
  v55 = malloc_type_malloc(8 * (v50 + 1), 0x2004093837F09uLL);
  v36 = v55;
  if (v50)
  {
    v56 = 0;
    v57 = v50;
    do
    {
      v58 = 1;
      v59 = malloc_type_malloc(8 * (1 << v47[v56]), 0x100004090D0E795uLL);
      v36[v56] = v59;
      do
      {
        v59[2 * v58 - 2] = 0xFFFF;
      }

      while (!(v58++ >> v47[v56]));
      ++v56;
    }

    while (v56 != v50);
    v3 = v94;
    v36[v50] = 0;
    if (!v46)
    {
      goto LABEL_71;
    }
  }

  else
  {
    v57 = 0;
    *v55 = 0;
    if (!v46)
    {
      goto LABEL_71;
    }
  }

  v61 = 0;
  v62 = v26 + 4;
  do
  {
    LODWORD(v66) = *v62;
    v67 = *(v62 - 1);
    v68 = v66 - 16;
    if (v66 > 16)
    {
      v63 = v67 >> v68;
      v64 = v48[v67 >> v68];
      v66 = *v36 + 8 * v63;
      *v66 = v64;
      *(v66 + 4) = -v47[v64];
      v65 = v36[v64] + 8 * ((*(v62 - 1) & ~(-1 << v68)) << (v47[v64] - v68));
      *v65 = v61;
      LOBYTE(v66) = *v62;
    }

    else
    {
      v65 = *v36 + 8 * (v67 << (16 - v66));
      *v65 = v61;
    }

    *(v65 + 4) = v66;
    ++v61;
    v62 += 8;
  }

  while (v46 != v61);
LABEL_71:
  if (v50)
  {
    v69 = 0;
    do
    {
      v70 = v47[v69];
      if (v70)
      {
        v71 = *v36[v69];
        v72 = 2;
        do
        {
          v74 = (v36[v69] + 8 * v72 - 8);
          if (*v74 == 0xFFFF)
          {
            *v74 = v71;
            v70 = v47[v69];
          }

          else
          {
            v71 = *v74;
          }
        }

        while (!(v72++ >> v70));
      }

      ++v69;
    }

    while (v69 != v57);
  }

  free(v47);
  free(v48);
  free(v26);
LABEL_81:
  a2 = v95;
LABEL_82:
  v75 = *a2;
  v76 = a2[1];
  v77 = a2[2];
  v78 = *(a2 + 6);
  v79 = ((v75 << 6) - 0x61C8864680B583EBLL + (v75 >> 2) + v76) ^ v75;
  v80 = (v77 - 0x61C8864680B583EBLL + (v79 << 6) + (v79 >> 2)) ^ v79;
  v81 = (v78 - 0x61C8864680B583EBLL + (v80 << 6) + (v80 >> 2)) ^ v80;
  v82 = *(v3 + 8);
  if (!*&v82)
  {
    goto LABEL_115;
  }

  v83 = vcnt_s8(v82);
  v83.i16[0] = vaddlv_u8(v83);
  if (v83.u32[0] > 1uLL)
  {
    v84 = (v78 - 0x61C8864680B583EBLL + (v80 << 6) + (v80 >> 2)) ^ v80;
    if (v81 >= *&v82)
    {
      v84 = v81 % *&v82;
    }
  }

  else
  {
    v84 = v81 & (*&v82 - 1);
  }

  v85 = *(*v3 + 8 * v84);
  if (!v85 || (v15 = *v85) == 0)
  {
LABEL_115:
    operator new();
  }

  if (v83.u32[0] < 2uLL)
  {
    while (1)
    {
      v87 = v15[1];
      if (v87 == v81)
      {
        if (*(v15 + 4) == v75 && *(v15 + 5) == v76 && *(v15 + 6) == v77 && *(v15 + 14) == v78)
        {
          goto LABEL_109;
        }
      }

      else if ((v87 & (*&v82 - 1)) != v84)
      {
        goto LABEL_115;
      }

      v15 = *v15;
      if (!v15)
      {
        goto LABEL_115;
      }
    }
  }

  while (2)
  {
    v86 = v15[1];
    if (v86 != v81)
    {
      if (v86 >= *&v82)
      {
        v86 %= *&v82;
      }

      if (v86 != v84)
      {
        goto LABEL_115;
      }

      goto LABEL_93;
    }

    if (*(v15 + 4) != v75 || *(v15 + 5) != v76 || *(v15 + 6) != v77 || *(v15 + 14) != v78)
    {
LABEL_93:
      v15 = *v15;
      if (!v15)
      {
        goto LABEL_115;
      }

      continue;
    }

    break;
  }

LABEL_109:
  v88 = v3;
  if (v36)
  {
    v89 = *v36;
    if (*v36)
    {
      v90 = v36 + 1;
      do
      {
        free(v89);
        v91 = *v90++;
        v89 = v91;
      }

      while (v91);
    }

    free(v36);
  }

  v3 = v88;
LABEL_116:
  v92 = v15[4];
  std::mutex::unlock((v3 + 40));
  return v92;
}

void sub_1B3378DB0(_Unwind_Exception *a1)
{
  v3 = v1;
  v5 = v2[4];
  if (v5)
  {
    v6 = *v5;
    if (*v5)
    {
      v7 = v5 + 1;
      do
      {
        free(v6);
        v8 = *v7++;
        v6 = v8;
      }

      while (v8);
    }

    free(v5);
  }

  operator delete(v2);
  std::mutex::unlock((v3 + 40));
  _Unwind_Resume(a1);
}

void geo::c3m::loadFromChunk(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4, double a5, float64_t a6, double a7)
{
  v114 = a3;
  v115 = a4;
  if (a4 < 5 || *a3 != 67 || a3[1] != 51 || a3[2] != 77)
  {
    *a1 = 0;
    return;
  }

  *&v8 = 0;
  memset(v103, 0, sizeof(v103));
  v9 = v110;
  v104 = 0x3FF0000000000000;
  *&v108 = v110;
  *(&v108 + 1) = v110;
  *&v109 = v110;
  *(&v109 + 1) = 1;
  *&v111 = v113;
  *(&v111 + 1) = v113;
  *&v112 = v113;
  *(&v112 + 1) = 3;
  if (a3[3] != 3 || a3[4] <= 2u)
  {
    goto LABEL_11;
  }

  if (a4 == 5)
  {
    goto LABEL_10;
  }

  v116 = 6;
  v15 = a3[5];
  if (!a3[5])
  {
    v20 = 1.0;
    v21 = v110;
    v22 = 1;
LABEL_32:
    *a1 = 1;
    *(a1 + 8) = v103[0];
    *(a1 + 24) = *&v103[1];
    *(a1 + 32) = *(&v103[1] + 8);
    *(a1 + 48) = *(&v103[2] + 1);
    *(a1 + 56) = v20;
    v23 = v106;
    *(a1 + 64) = v105;
    *(a1 + 80) = v23;
    *(a1 + 96) = v107;
    v24 = (a1 + 144);
    *(a1 + 112) = a1 + 144;
    *(a1 + 128) = a1 + 144;
    *(a1 + 136) = v22;
    if (v21 == v9)
    {
      v31 = *(&v108 + 1);
      v32 = *(&v108 + 1) - v9;
      *(a1 + 120) = v24 + v32;
      if (v32)
      {
        do
        {
          v33 = v24 + 4;
          *v24 = (v24 + 4);
          v24[1] = (v24 + 4);
          v24[2] = (v24 + 4);
          v24[3] = *(v21 + 3);
          v34 = *v21;
          if (*v21 == *(v21 + 2))
          {
            v24[1] = (v33 + *(v21 + 1) - v34);
            for (i = *(v21 + 1); v34 != i; v34 = (v34 + 24))
            {
              v36 = *v34;
              v33[2] = *(v34 + 2);
              *v33 = v36;
              v33 += 3;
            }
          }

          else
          {
            *v24 = v34;
            v24[1] = *(v21 + 1);
            *v21 = 0uLL;
            *(v21 + 1) = 0uLL;
          }

          v24[10] = 0;
          v24[11] = 0;
          v24[12] = 0;
          *(v24 + 5) = *(v21 + 5);
          v24[12] = *(v21 + 12);
          *(v21 + 10) = 0;
          *(v21 + 11) = 0;
          *(v21 + 12) = 0;
          v24[13] = 0;
          v24[14] = 0;
          v24[15] = 0;
          *(v24 + 13) = *(v21 + 104);
          v24[15] = *(v21 + 15);
          *(v21 + 13) = 0;
          *(v21 + 14) = 0;
          *(v21 + 15) = 0;
          v24[16] = 0;
          v24[17] = 0;
          v24[18] = 0;
          *(v24 + 8) = *(v21 + 8);
          v24[18] = *(v21 + 18);
          *(v21 + 16) = 0;
          *(v21 + 17) = 0;
          *(v21 + 18) = 0;
          v24[19] = 0;
          v24[20] = 0;
          v24[21] = 0;
          *(v24 + 19) = *(v21 + 152);
          v24[21] = *(v21 + 21);
          *(v21 + 19) = 0;
          *(v21 + 20) = 0;
          *(v21 + 21) = 0;
          v24[22] = *(v21 + 22);
          v24 += 23;
          v21 += 184;
        }

        while (v21 != v31);
      }
    }

    else
    {
      v25 = *(&v108 + 1);
      *(a1 + 112) = v21;
      *(a1 + 120) = v25;
      v109 = 0u;
      v108 = 0u;
    }

    v26 = a1 + 360;
    *(a1 + 328) = a1 + 360;
    v27 = *(&v112 + 1);
    v28 = v112;
    *(a1 + 344) = a1 + 360;
    *(a1 + 352) = v27;
    v29 = v111;
    if (v111 == v28)
    {
      v37 = *(&v111 + 1);
      v38 = *(&v111 + 1) == v111;
      *(a1 + 336) = v26 + *(&v111 + 1) - v111;
      if (!v38)
      {
        do
        {
          *v26 = *v29;
          v39 = v26 + 40;
          *(v26 + 8) = v26 + 40;
          v40 = *(v29 + 8);
          *(v26 + 16) = v26 + 40;
          *(v26 + 24) = v26 + 40;
          *(v26 + 32) = *(v29 + 32);
          if (v40 == *(v29 + 24))
          {
            *(v26 + 16) = v39 + *(v29 + 16) - v40;
            for (j = *(v29 + 16); v40 != j; v40 += 32)
            {
              *v39 = *v40;
              *v40 = 0;
              *(v40 + 8) = 0;
              v42 = *(v40 + 16);
              *(v39 + 24) = *(v40 + 24);
              *(v39 + 16) = v42;
              v39 += 32;
            }
          }

          else
          {
            *(v26 + 8) = v40;
            *(v26 + 16) = *(v29 + 16);
            *(v29 + 8) = 0uLL;
            *(v29 + 24) = 0uLL;
          }

          v26 += 104;
          v29 += 104;
        }

        while (v29 != v37);
      }
    }

    else
    {
      v30 = *(&v111 + 1);
      *(a1 + 328) = v111;
      *(a1 + 336) = v30;
      v111 = 0u;
      v112 = 0u;
    }

    goto LABEL_12;
  }

  v17 = 0;
  v18 = &v119;
  v19 = &v120;
  while (1)
  {
    v44 = v115;
    v43 = v116;
    if (v116 + 1 > v115)
    {
      goto LABEL_10;
    }

    v45 = v116 + 5;
    v46 = v115 - (v116 + 5);
    if (v115 < v116 + 5)
    {
      goto LABEL_10;
    }

    v47 = v114[v116];
    v116 += 5;
    v48 = *&v114[v45 - 4];
    if (v46 < v48)
    {
      printf("C3m Block size too large");
      goto LABEL_11;
    }

    if (v47 > 1)
    {
      if (v47 == 2)
      {
        {
          goto LABEL_10;
        }
      }

      else
      {
        if (v47 != 3)
        {
          printf("C3m invalid block type");
          goto LABEL_11;
        }

        v81 = (v48 - 5);
        printf("This decoder does not currently support scene graphs.");
        v82 = v45 + v81;
        if (v45 + v81 >= v44)
        {
          v82 = v44;
        }

        v116 = v82;
      }

      goto LABEL_53;
    }

    if (!v47)
    {
      if (v43 + 6 > v115)
      {
        v98 = "Header type";
      }

      else
      {
        v116 = v43 + 6;
        if (v114[v45])
        {
          v98 = "C3m - Invalid header type";
        }

        else
        {
          v83 = v43 + 7;
          if (v83 >= v115)
          {
            v83 = v115;
          }

          if (v83 + 1 < v115)
          {
            v84 = v83 + 1;
          }

          else
          {
            v84 = v115;
          }

          if (v84 + 1 < v115)
          {
            v85 = v84 + 1;
          }

          else
          {
            v85 = v115;
          }

          v116 = v85;
          if (v85 + 8 > v115 || (*&v8 = *&v114[v85], v116 = v85 + 8, v85 + 16 > v115) || (a6 = *&v114[v85 + 8], v116 = v85 + 16, v85 + 24 > v115) || (a7 = *&v114[v85 + 16], v116 = v85 + 24, v85 + 32 > v115))
          {
            v98 = "Rotation quaternion value";
          }

          else
          {
            v86 = *&v114[v85 + 24];
            v116 = v85 + 32;
            if (v85 + 40 > v115 || (v87 = *&v114[v85 + 32], v116 = v85 + 40, v85 + 48 > v115) || (v88 = *&v114[v85 + 40], v116 = v85 + 48, v85 + 56 > v115))
            {
              v98 = "Translation vector value";
            }

            else
            {
              v89 = *&v114[v85 + 48];
              v116 = v85 + 56;
              if (v85 + 64 <= v115)
              {
                v90 = *&v114[v85 + 56];
                v116 = v85 + 64;
                if (v85 + 72 <= v115)
                {
                  v91 = *&v114[v85 + 64];
                  v116 = v85 + 72;
                  if (v85 + 80 <= v115)
                  {
                    v92 = *&v114[v85 + 72];
                    v116 = v85 + 80;
                    if (v85 + 88 <= v115)
                    {
                      v93 = *&v114[v85 + 80];
                      v116 = v85 + 88;
                      v94 = v85 + 96;
                      if (v85 + 96 <= v115)
                      {
                        v95 = *&v114[v85 + 88];
                        v116 = v85 + 96;
                        v96 = v85 + 104;
                        if (v96 <= v115)
                        {
                          v97 = *&v114[v94];
                          v116 = v96;
                          *&v103[2] = a6;
                          *(&v103[2] + 1) = a7;
                          *&v103[0] = v87;
                          *(&v103[0] + 1) = v88;
                          *&v103[1] = v89;
                          *(&v103[1] + 1) = v8;
                          v104 = v86;
                          *&v105 = v90;
                          *(&v105 + 1) = v91;
                          *&v106 = v92;
                          *(&v106 + 1) = v93;
                          *&v107 = v95;
                          *(&v107 + 1) = v97;
                          goto LABEL_53;
                        }
                      }
                    }
                  }
                }
              }

              v98 = "Bounding box value";
            }
          }
        }
      }

      printf("Failed to read C3m file - %s", v98);
      goto LABEL_10;
    }

    v49 = v43 + 9;
    if (v49 > v115)
    {
      goto LABEL_161;
    }

    v116 = v49;
    v102 = *&v114[v49 - 4];
    if (v102)
    {
      break;
    }

LABEL_53:
    if (v15 <= ++v17)
    {
      v20 = *&v104;
      v22 = *(&v109 + 1);
      v9 = v109;
      v21 = v108;
      goto LABEL_32;
    }
  }

  v50 = 0;
  v100 = 1;
  v101 = v17;
  while (1)
  {
    v51 = v116;
    if (v116 + 1 > v115)
    {
      break;
    }

    ++v116;
    v52 = v51 + 3;
    if (v51 + 3 > v115)
    {
      break;
    }

    v53 = v114[v51];
    v116 = v51 + 3;
    if (v53 >= 0xE)
    {
      break;
    }

    if (v53 >= 8)
    {
      if (v53 - 11 >= 2)
      {
        if (v53 - 8 >= 3)
        {
          printf("C3m - unsupported material type");
        }

        else
        {
          printf("C3m - reserved material type");
        }

        goto LABEL_10;
      }

      v60 = v51 + 4;
      if (v60 > v115)
      {
        break;
      }

      v116 = v60;
      if (v114[v52] != 2)
      {
        break;
      }

      *&v118 = v18;
      *(&v118 + 1) = 2;
      *v18 = 0u;
      *(v18 + 1) = 0u;
      *(v18 + 2) = 0u;
      *(v18 + 3) = 0u;
      *&v117 = v18;
      *(&v117 + 1) = &v121;
      {
        v61 = *(&v111 + 1);
        v62 = 0x4EC4EC4EC4EC4EC5 * ((*(&v111 + 1) - v111) >> 3) + 1;
        if (*(&v112 + 1) < v62)
        {
          geo::small_vector_base<std::pair<geo::c3m::MaterialType,geo::small_vector<geo::c3m::TextureData,2ul>>>::grow(&v111, v62);
          v61 = *(&v111 + 1);
        }

        *v61 = v53;
        v63 = v61 + 40;
        *(v61 + 8) = v61 + 40;
        *(v61 + 16) = v61 + 40;
        *(v61 + 24) = v61 + 40;
        v64 = v118;
        *(v61 + 32) = *(&v118 + 1);
        v65 = v117;
        if (v117 == v64)
        {
          v76 = *(&v117 + 1);
          *(v61 + 16) = v63 + *(&v117 + 1) - v117;
          if (v76 != v65)
          {
            do
            {
              v8 = *v65;
              *v63 = *v65;
              *v65 = 0;
              *(v65 + 1) = 0;
              v77 = *(v65 + 2);
              *(v63 + 24) = *(v65 + 24);
              *(v63 + 16) = v77;
              v63 += 32;
              v65 += 2;
            }

            while (v65 != v76);
            v61 = *(&v111 + 1);
          }
        }

        else
        {
          *(v61 + 8) = v117;
          *&v8 = 0;
          v117 = 0u;
          v118 = 0u;
        }

        v74 = v15;
        *(&v111 + 1) = v61 + 104;
        v75 = 1;
      }

      else
      {
        v74 = v15;
        printf("Failed to read C3m file - %s", "Failed to read texture data");
        v75 = 0;
        v100 = 0;
      }

      v79 = *(&v117 + 1);
      v78 = v117;
      if (v117 != *(&v117 + 1))
      {
        v99 = v75;
        do
        {
          v80 = v78[1];
          if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            (v80->__on_zero_shared)(v80);
            std::__shared_weak_count::__release_weak(v80);
          }

          v78 += 4;
        }

        while (v78 != v79);
        v78 = v117;
        v75 = v99;
      }

      v15 = v74;
      if (v78 != v118)
      {
        free(v78);
      }

      if ((v75 & 1) == 0)
      {
LABEL_52:
        if ((v100 & 1) == 0)
        {
          goto LABEL_10;
        }

        goto LABEL_53;
      }
    }

    else
    {
      *&v118 = v18;
      *(&v118 + 1) = 2;
      *v18 = 0u;
      *(v18 + 1) = 0u;
      *&v117 = v18;
      *(&v117 + 1) = v19;
      if (TextureData)
      {
        v55 = *(&v111 + 1);
        v56 = 0x4EC4EC4EC4EC4EC5 * ((*(&v111 + 1) - v111) >> 3) + 1;
        if (*(&v112 + 1) < v56)
        {
          geo::small_vector_base<std::pair<geo::c3m::MaterialType,geo::small_vector<geo::c3m::TextureData,2ul>>>::grow(&v111, v56);
          v55 = *(&v111 + 1);
        }

        *v55 = v53;
        v57 = v55 + 40;
        *(v55 + 8) = v55 + 40;
        *(v55 + 16) = v55 + 40;
        *(v55 + 24) = v55 + 40;
        v58 = v118;
        *(v55 + 32) = *(&v118 + 1);
        v59 = v117;
        if (v117 == v58)
        {
          v66 = *(&v117 + 1);
          *(v55 + 16) = v57 + *(&v117 + 1) - v117;
          if (v66 != v59)
          {
            do
            {
              v8 = *v59;
              *v57 = *v59;
              *v59 = 0;
              *(v59 + 1) = 0;
              v67 = *(v59 + 2);
              *(v57 + 24) = *(v59 + 24);
              *(v57 + 16) = v67;
              v57 += 32;
              v59 += 2;
            }

            while (v59 != v66);
            v55 = *(&v111 + 1);
          }
        }

        else
        {
          *(v55 + 8) = v117;
          *&v8 = 0;
          v117 = 0u;
          v118 = 0u;
        }

        *(&v111 + 1) = v55 + 104;
      }

      else
      {
        printf("Failed to read C3m file - %s", "Failed to read texture data");
        v100 = 0;
      }

      v69 = *(&v117 + 1);
      v68 = v117;
      if (v117 != *(&v117 + 1))
      {
        v70 = v19;
        v71 = v18;
        v72 = v15;
        do
        {
          v73 = v68[1];
          if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            (v73->__on_zero_shared)(v73);
            std::__shared_weak_count::__release_weak(v73);
          }

          v68 += 4;
        }

        while (v68 != v69);
        v68 = v117;
        v15 = v72;
        v18 = v71;
        v19 = v70;
      }

      v17 = v101;
      if (v68 != v118)
      {
        free(v68);
      }

      if ((TextureData & 1) == 0)
      {
        goto LABEL_52;
      }
    }

    if (++v50 == v102)
    {
      goto LABEL_52;
    }
  }

LABEL_161:
  printf("Failed to read C3m file - %s");
LABEL_10:
  printf("Failed to read C3m file - %s");
LABEL_11:
  *a1 = 0;
LABEL_12:
  v11 = *(&v111 + 1);
  v10 = v111;
  if (v111 != *(&v111 + 1))
  {
    do
    {
      v12 = v10[1];
      v13 = v10[2];
      if (v12 != v13)
      {
        do
        {
          v14 = v12[1];
          if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            (v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }

          v12 += 4;
        }

        while (v12 != v13);
        v12 = v10[1];
      }

      if (v12 != v10[3])
      {
        free(v12);
      }

      v10 += 13;
    }

    while (v10 != v11);
    v10 = v111;
  }

  if (v10 != v112)
  {
    free(v10);
  }

  geo::small_vector_base<geo::c3m::Mesh>::runDestructors(v108, *(&v108 + 1));
  if (v108 != v109)
  {
    free(v108);
  }
}

void sub_1B33799F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50, uint64_t a51, uint64_t a52, uint64_t a53, uint64_t a54, void *a55, void *a56, void *a57)
{
  v59 = *(v57 - 192);
  v60 = *(v57 - 184);
  if (v59 != v60)
  {
    do
    {
      v61 = v59[1];
      if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        (v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }

      v59 += 4;
    }

    while (v59 != v60);
    v59 = *(v57 - 192);
  }

  if (v59 != *(v57 - 176))
  {
    free(v59);
  }

  v62 = a55;
  if (a55 != a56)
  {
    do
    {
      v63 = v62[1];
      v64 = v62[2];
      if (v63 != v64)
      {
        do
        {
          v65 = v63[1];
          if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            (v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }

          v63 += 4;
        }

        while (v63 != v64);
        v63 = v62[1];
      }

      if (v63 != v62[3])
      {
        free(v63);
      }

      v62 += 13;
    }

    while (v62 != a56);
    v62 = a55;
  }

  if (v62 != a57)
  {
    free(v62);
  }

  geo::small_vector_base<geo::c3m::Mesh>::runDestructors(a28, a29);
  if (a28 != a30)
  {
    free(a28);
  }

  _Unwind_Resume(a1);
}

uint64_t anonymous namespace::readMeshes(uint64_t a1, uint64_t *a2, void *a3, double a4, float64_t a5, double a6)
{
  v6 = a2[2] + 4;
  if (v6 > a2[1])
  {
    v7 = "Num submeshes";
    goto LABEL_3;
  }

  a2[2] = v6;
  v10 = *(*a2 + v6 - 4);
  if (!v10)
  {
    v8 = 1;
    return v8 & 1;
  }

  v11 = 0;
  v8 = 1;
  while (1)
  {
    v13 = a2[1];
    v14 = a2[2];
    if (v14 + 1 > v13)
    {
      v7 = "Mesh type";
      goto LABEL_3;
    }

    a2[2] = v14 + 1;
    v15 = v14 + 3;
    if (v14 + 3 > v13)
    {
      v7 = "Mesh length";
      goto LABEL_3;
    }

    v16 = *a2;
    v17 = *(*a2 + v14);
    a2[2] = v15;
    if (v17 >= 4)
    {
      break;
    }

    v164[0] = v166;
    v164[1] = v166;
    *&v165 = v166;
    *(&v165 + 1) = 2;
    v18.f64[1] = 0.0;
    *v167 = 0u;
    memset(v168, 0, sizeof(v168));
    *v169 = 0u;
    memset(v170, 0, sizeof(v170));
    HIDWORD(v171) = -1;
    v19 = v14 + 4;
    LOBYTE(v171) = v11;
    if (v17 == 1)
    {
      v20 = "Feature classification";
      if (v19 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v19;
      v45 = v14 + 6;
      v20 = "Index of first drape face";
      if (v14 + 6 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v45;
      v20 = "Layer classification";
      if (v14 + 7 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v14 + 7;
      v46 = *(v16 + v45);
      v20 = "Invalid layer class";
      if (v46 > 8)
      {
        goto LABEL_47;
      }

      v47 = v14 + 11;
      v20 = "Material index";
      if (v14 + 11 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v47;
      v48 = v14 + 12;
      v20 = "Mesh type";
      if (v14 + 12 > v13)
      {
        goto LABEL_47;
      }

      v49 = *(v16 + v47 - 4);
      a2[2] = v48;
      v50 = *(v16 + v47);
      v20 = "Invalid mesh chunk type";
      if (v50 > 2)
      {
        goto LABEL_47;
      }

      v51 = v14 + 20;
      if (v14 + 20 > v13 || (v52 = *(v16 + v48), a2[2] = v51, v53 = v14 + 28, v14 + 28 > v13) || (v54 = *(v16 + v51), a2[2] = v53, v55 = v14 + 36, v14 + 36 > v13))
      {
LABEL_46:
        v20 = "Scale factor value";
LABEL_47:
        printf("Failed to read C3m file - %s", v20);
        goto LABEL_64;
      }

      v83 = *(v16 + v53);
      a2[2] = v55;
      v84 = v14 + 44;
      if (v14 + 44 > v13 || (v85 = *(v16 + v55), a2[2] = v84, v86 = v14 + 52, v14 + 52 > v13) || (v87 = *(v16 + v84), a2[2] = v86, v14 + 60 > v13))
      {
LABEL_77:
        v20 = "Translation factor value";
        goto LABEL_47;
      }

      __nb = v87;
      v88 = *(v16 + v86);
      a2[2] = v14 + 60;
      v89 = v14 + 64;
      v20 = "Mesh chunk offset";
      if (v14 + 64 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v89;
      v90 = v14 + 68;
      v20 = "Compressed mesh chunk size";
      if (v14 + 68 > v13)
      {
        goto LABEL_47;
      }

      v91 = *(v16 + v89 - 4);
      a2[2] = v90;
      v92 = v14 + 72;
      v20 = "Uncompressed mesh chunk size";
      if (v92 > v13)
      {
        goto LABEL_47;
      }

      v93 = *(v16 + v90 - 4);
      a2[2] = v92;
      v152 = v93;
      v94 = (v93 + v91);
      v20 = "Invalid mesh chunk data";
      if (v13 < v94)
      {
        goto LABEL_47;
      }

      v95 = *(v16 + v92 - 4);
      BYTE1(v171) = v46;
      v149 = (v16 + v91);
      if (v152 != v95)
      {
        v104 = v95;
        if (v95)
        {
          operator new();
        }

        v191 = 0;
        v189 = 0u;
        v190 = 0u;
        *v187 = 0u;
        *v188 = 0u;
        *v185 = 0u;
        *v186 = 0u;
        *v183 = 0u;
        *v184 = 0u;
        if (lzma_auto_decoder() || (v183[0] = v149, v183[1] = v152, v184[1] = 0, v185[0] = v104, v114 = lzma_code(), lzma_end(), v114 >= 2))
        {
          v44 = "Failed to decompress mesh chunk";
          goto LABEL_120;
        }

        v149 = 0;
        v152 = 0;
      }

      v183[0] = v52;
      v183[1] = v54;
      v184[0] = v83;
      *&v18.f64[0] = __nb;
      v172.f64[0] = v85;
      *&v172.f64[1] = __nb;
      v173 = v88;
      if (v50 == 1)
      {
        v182.__begin_ = v149;
        v182.__end_ = v152;
        v182.__end_cap_.__value_ = 0;
        {
          v44 = "Couldn't read mesh chunk type 1";
          goto LABEL_120;
        }
      }

      else if (v50)
      {
        v182.__begin_ = v149;
        v182.__end_ = v152;
        v182.__end_cap_.__value_ = 0;
        {
          v44 = "Couldn't read mesh chunk type 2";
          goto LABEL_120;
        }
      }

      else
      {
        v182.__begin_ = v149;
        v182.__end_ = v152;
        v182.__end_cap_.__value_ = 0;
        {
          v44 = "Couldn't read mesh chunk type 0";
          goto LABEL_120;
        }
      }

      v112 = v164[0];
      v111 = v164[1];
      __nd = v164[1] - v164[0];
      if (0xAAAAAAAAAAAAAAABLL * ((v164[1] - v164[0]) >> 3) >= 2)
      {
        v113 = v164[0] + 24;
        goto LABEL_128;
      }

      if (v164[1] == v164[0])
      {
        if (!*(&v165 + 1))
        {
          v155 = v165;
          v141 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
          v112 = v141;
          v142 = v164[0];
          v143 = v164[1];
          if (v164[0] != v164[1])
          {
            v144 = v141;
            do
            {
              v145 = *v142;
              *(v144 + 2) = v142[2];
              *v144 = v145;
              v144 += 24;
              v142 += 3;
            }

            while (v142 != v143);
          }

          if (v111 != v155)
          {
            free(v164[0]);
          }

          v111 = &v112[__nd];
          v164[0] = v112;
          *(&v165 + 1) = 2;
        }

        v113 = v112 + 24;
        if (v111 != v112 + 24)
        {
          do
          {
            *(v111 + 1) = 0;
            *(v111 + 2) = 0;
            *v111 = 0;
            *(v111 + 5) = -1;
            v140 = v111 == v112;
            v111 += 24;
          }

          while (!v140);
        }

LABEL_128:
        v164[1] = v113;
        v111 = v113;
      }

      *(v111 - 2) = v49;
      v115 = (v169[1] - v169[0]) >> 1;
      *(v111 - 3) = 0;
      *(v111 - 2) = v115;
      v109 = 1;
      goto LABEL_136;
    }

    if (!v17)
    {
      v20 = "Feature classification";
      if (v19 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v19;
      v20 = "Layer classification";
      if (v14 + 5 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v14 + 5;
      v21 = *(v16 + v19);
      v20 = "Invalid layer class";
      if (v21 > 8)
      {
        goto LABEL_47;
      }

      v22 = v14 + 9;
      v20 = "Material index";
      if (v14 + 9 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v22;
      v23 = v14 + 10;
      v20 = "Mesh type";
      if (v14 + 10 > v13)
      {
        goto LABEL_47;
      }

      v24 = *(v16 + v22 - 4);
      a2[2] = v23;
      v25 = *(v16 + v22);
      v20 = "Invalid mesh chunk type";
      if (v25 > 2)
      {
        goto LABEL_47;
      }

      v26 = v14 + 18;
      if (v14 + 18 > v13)
      {
        goto LABEL_46;
      }

      v27 = *(v16 + v23);
      a2[2] = v26;
      v28 = v14 + 26;
      if (v14 + 26 > v13)
      {
        goto LABEL_46;
      }

      v29 = *(v16 + v26);
      a2[2] = v28;
      v30 = v14 + 34;
      if (v14 + 34 > v13)
      {
        goto LABEL_46;
      }

      v31 = *(v16 + v28);
      a2[2] = v30;
      v32 = v14 + 42;
      if (v14 + 42 > v13)
      {
        goto LABEL_77;
      }

      v33 = *(v16 + v30);
      a2[2] = v32;
      v34 = v14 + 50;
      if (v14 + 50 > v13)
      {
        goto LABEL_77;
      }

      v35 = *(v16 + v32);
      a2[2] = v34;
      if (v14 + 58 > v13)
      {
        goto LABEL_77;
      }

      v36 = *(v16 + v34);
      a2[2] = v14 + 58;
      v37 = v14 + 62;
      v20 = "Mesh chunk offset";
      if (v14 + 62 > v13)
      {
        goto LABEL_47;
      }

      a2[2] = v37;
      v38 = v14 + 66;
      v20 = "Compressed mesh chunk size";
      if (v14 + 66 > v13)
      {
        goto LABEL_47;
      }

      v39 = *(v16 + v37 - 4);
      a2[2] = v38;
      v40 = v14 + 70;
      v20 = "Uncompressed mesh chunk size";
      if (v40 > v13)
      {
        goto LABEL_47;
      }

      v41 = *(v16 + v38 - 4);
      a2[2] = v40;
      __n = v41;
      v42 = (v41 + v39);
      v20 = "Invalid mesh chunk data";
      if (v13 < v42)
      {
        goto LABEL_47;
      }

      v148 = v36;
      v43 = *(v16 + v40 - 4);
      BYTE1(v171) = v21;
      v150 = (v16 + v39);
      if (__n == v43)
      {
LABEL_32:
        v183[0] = v27;
        v183[1] = v29;
        v184[0] = v31;
        v172.f64[0] = v33;
        v172.f64[1] = v35;
        *&v18.f64[0] = v148;
        v173 = v148;
        if (v25 == 1)
        {
          v182.__begin_ = v150;
          v182.__end_ = __n;
          v182.__end_cap_.__value_ = 0;
          {
            goto LABEL_113;
          }

          v44 = "Couldn't read mesh chunk type 1";
        }

        else
        {
          if (!v25)
          {
            v182.__begin_ = v150;
            v182.__end_ = __n;
            v182.__end_cap_.__value_ = 0;
            {
              v44 = "Couldn't read mesh chunk type 0";
              goto LABEL_120;
            }

LABEL_113:
            v106 = v164[0];
            v105 = v164[1];
            __nc = v164[1] - v164[0];
            if (0xAAAAAAAAAAAAAAABLL * ((v164[1] - v164[0]) >> 3) >= 2)
            {
              v107 = v164[0] + 24;
              goto LABEL_115;
            }

            if (v164[1] == v164[0])
            {
              if (!*(&v165 + 1))
              {
                v151 = v165;
                v135 = malloc_type_malloc(0x30uLL, 0x1000040504FFAC1uLL);
                v106 = v135;
                v136 = v164[0];
                v137 = v164[1];
                if (v164[0] != v164[1])
                {
                  v138 = v135;
                  do
                  {
                    v139 = *v136;
                    *(v138 + 2) = v136[2];
                    *v138 = v139;
                    v138 += 24;
                    v136 += 3;
                  }

                  while (v136 != v137);
                }

                if (v105 != v151)
                {
                  free(v164[0]);
                }

                v105 = &v106[__nc];
                v164[0] = v106;
                *(&v165 + 1) = 2;
              }

              v107 = v106 + 24;
              if (v105 != v106 + 24)
              {
                do
                {
                  *(v105 + 1) = 0;
                  *(v105 + 2) = 0;
                  *v105 = 0;
                  *(v105 + 5) = -1;
                  v140 = v105 == v106;
                  v105 += 24;
                }

                while (!v140);
              }

LABEL_115:
              v164[1] = v107;
              v105 = v107;
            }

            *(v105 - 2) = v24;
            v110 = (v169[1] - v169[0]) >> 1;
            *(v105 - 3) = 0;
            *(v105 - 2) = v110;
            v109 = 1;
LABEL_136:
            if (v109)
            {
              goto LABEL_137;
            }

            goto LABEL_64;
          }

          v182.__begin_ = v150;
          v182.__end_ = __n;
          v182.__end_cap_.__value_ = 0;
          {
            goto LABEL_113;
          }

          v44 = "Couldn't read mesh chunk type 2";
        }
      }

      else
      {
        v101 = v43;
        if (v43)
        {
          operator new();
        }

        v191 = 0;
        v189 = 0u;
        v190 = 0u;
        *v187 = 0u;
        *v188 = 0u;
        *v185 = 0u;
        *v186 = 0u;
        *v183 = 0u;
        *v184 = 0u;
        if (!lzma_auto_decoder())
        {
          v183[0] = v150;
          v183[1] = __n;
          v184[1] = 0;
          v185[0] = v101;
          v108 = lzma_code();
          lzma_end();
          if (v108 < 2)
          {
            v150 = 0;
            __n = 0;
            goto LABEL_32;
          }
        }

        v44 = "Failed to decompress mesh chunk";
      }

LABEL_120:
      printf("Failed to read C3m file - %s", v44);
      v109 = 0;
      goto LABEL_136;
    }

    v56 = "Layer classification";
    if (v19 <= v13)
    {
      a2[2] = v19;
      v57 = *(v16 + v15);
      v56 = "Invalid feature class";
      if (v57 <= 8)
      {
        v58 = v14 + 8;
        v56 = "Huffman parameter c1 for texture coordinates";
        if (v14 + 8 <= v13)
        {
          a2[2] = v58;
          v59 = v14 + 12;
          v56 = "Huffman parameter c2 for texture coordinates";
          if (v14 + 12 <= v13)
          {
            v60 = *(v16 + v58 - 4);
            a2[2] = v59;
            v61 = v14 + 16;
            v56 = "Huffman parameter c3 for texture coordinates";
            if (v14 + 16 <= v13)
            {
              v62 = *(v16 + v59 - 4);
              a2[2] = v61;
              v63 = v14 + 18;
              v56 = "Huffman parameter range for texture coordinates";
              if (v14 + 18 <= v13)
              {
                v64 = *(v16 + v61 - 4);
                a2[2] = v63;
                v65 = v14 + 22;
                v56 = "Huffman parameter c1 for vertex coordinates";
                if (v14 + 22 <= v13)
                {
                  v66 = *(v16 + v63 - 2);
                  a2[2] = v65;
                  v67 = v14 + 26;
                  v56 = "Huffman parameter c2 for vertex coordinates";
                  if (v14 + 26 <= v13)
                  {
                    v68 = *(v16 + v65 - 4);
                    a2[2] = v67;
                    v69 = v14 + 30;
                    v56 = "Huffman parameter c3 for vertex coordinates";
                    if (v14 + 30 <= v13)
                    {
                      v70 = *(v16 + v67 - 4);
                      a2[2] = v69;
                      v71 = v14 + 32;
                      v56 = "Huffman parameter range for vertex coordinates";
                      if (v14 + 32 <= v13)
                      {
                        v72 = *(v16 + v69 - 4);
                        a2[2] = v71;
                        v73 = v14 + 36;
                        v56 = "Number of texture coordinates";
                        if (v14 + 36 <= v13)
                        {
                          v74 = *(v16 + v71 - 2);
                          a2[2] = v73;
                          v75 = v14 + 40;
                          v56 = "Number of faces";
                          if (v14 + 40 <= v13)
                          {
                            v76 = *(v16 + v73 - 4);
                            a2[2] = v75;
                            v77 = v14 + 44;
                            v56 = "Number of material indices";
                            if (v14 + 44 <= v13)
                            {
                              v78 = *(v16 + v75 - 4);
                              a2[2] = v77;
                              v79 = v14 + 48;
                              v56 = "Mesh chunk offset";
                              if (v14 + 48 <= v13)
                              {
                                __na = *(v16 + v77 - 4);
                                a2[2] = v79;
                                v80 = v14 + 52;
                                v56 = "Compressed mesh chunk size";
                                if (v14 + 52 <= v13)
                                {
                                  v96 = *(v16 + v79 - 4);
                                  a2[2] = v80;
                                  v97 = *(v16 + v80 - 4);
                                  BYTE1(v171) = v57;
                                  if (v57 == 6 || __na)
                                  {
                                    memset(&v182, 0, sizeof(v182));
                                    memset(&v181, 0, sizeof(v181));
                                    *&v172.f64[0] = __PAIR64__(v62, v60);
                                    LODWORD(v172.f64[1]) = v64;
                                    WORD2(v172.f64[1]) = v66;
                                    v173 = __PAIR64__(v70, v68);
                                    v174 = v72;
                                    v175 = v74;
                                    v176 = v76;
                                    v177 = v78;
                                    v178 = __na;
                                    v179 = v96;
                                    v153 = (3 * v78);
                                    if (v57 == 8)
                                    {
                                      v98 = (3 * v78);
                                    }

                                    else
                                    {
                                      v98 = v76;
                                    }

                                    v180 = v97;
                                    v147 = v98;
                                    if (v98)
                                    {
                                      std::vector<gm::Matrix<float,3,1>>::__append(v167, v98);
                                      v99 = v168[1];
                                      v100 = v168[2];
                                    }

                                    else
                                    {
                                      v99 = 0;
                                      v100 = 0;
                                    }

                                    v102 = (v100 - v99) >> 3;
                                    if (v147 <= v102)
                                    {
                                      if (v147 < v102)
                                      {
                                        v168[2] = v99 + 8 * v147;
                                      }
                                    }

                                    else
                                    {
                                      std::vector<gm::Matrix<float,2,1>>::__append(&v168[1], v147 - v102);
                                    }

                                    v103 = (v169[1] - v169[0]) >> 1;
                                    if (v153 <= v103)
                                    {
                                      if (v153 < v103)
                                      {
                                        v169[1] = v169[0] + 2 * v153;
                                      }
                                    }

                                    else
                                    {
                                      std::vector<unsigned short>::__append(v169, v153 - v103);
                                    }

                                    if (__na)
                                    {
                                      std::vector<int>::__append(&v182, __na);
                                      std::vector<int>::__append(&v181, __na);
                                      operator new();
                                    }

                                    geo::c3m::EdgebreakerDecodeCache::getOrCreateTable(a1, &v172);
                                    geo::c3m::EdgebreakerDecodeCache::getOrCreateTable(a1, &v173);
                                    operator new[]();
                                  }

LABEL_137:
                                  v117 = a3[13];
                                  v116 = a3[14];
                                  __ne = v116 - v117;
                                  v118 = 1 - 0x2C8590B21642C859 * ((v116 - v117) >> 3);
                                  v119 = a3[16];
                                  if (v119 < v118)
                                  {
                                    v154 = a3[15];
                                    v120 = (1 << -__clz(v119 + 1));
                                    if (v119 >= 0xFFFFFFFFFFFFFFFELL)
                                    {
                                      v120 = 1;
                                    }

                                    if (v120 <= v118)
                                    {
                                      v121 = v118;
                                    }

                                    else
                                    {
                                      v121 = v120;
                                    }

                                    v122 = malloc_type_malloc(184 * v121, 0x1030040E47C81F6uLL);
                                    v123 = a3[13];
                                    v124 = a3[14];
                                    if (v123 != v124)
                                    {
                                      v125 = v122;
                                      do
                                      {
                                        v126 = v125 + 4;
                                        *v125 = (v125 + 4);
                                        v125[1] = (v125 + 4);
                                        v125[2] = (v125 + 4);
                                        v125[3] = *(v123 + 24);
                                        v127 = *v123;
                                        if (*v123 == *(v123 + 16))
                                        {
                                          v125[1] = (v126 + *(v123 + 8) - v127);
                                          for (i = *(v123 + 8); v127 != i; v127 = (v127 + 24))
                                          {
                                            v129 = *v127;
                                            v126[2] = *(v127 + 2);
                                            *v126 = v129;
                                            v126 += 3;
                                          }
                                        }

                                        else
                                        {
                                          *v125 = v127;
                                          v125[1] = *(v123 + 8);
                                          *v123 = 0u;
                                          *(v123 + 16) = 0u;
                                        }

                                        v125[10] = 0;
                                        v125[11] = 0;
                                        v125[12] = 0;
                                        *(v125 + 5) = *(v123 + 80);
                                        v125[12] = *(v123 + 96);
                                        *(v123 + 80) = 0;
                                        *(v123 + 88) = 0;
                                        *(v123 + 96) = 0;
                                        v125[13] = 0;
                                        v125[14] = 0;
                                        v125[15] = 0;
                                        *(v125 + 13) = *(v123 + 104);
                                        v125[15] = *(v123 + 120);
                                        *(v123 + 104) = 0;
                                        *(v123 + 112) = 0;
                                        *(v123 + 120) = 0;
                                        v125[16] = 0;
                                        v125[17] = 0;
                                        v125[18] = 0;
                                        *(v125 + 8) = *(v123 + 128);
                                        v125[18] = *(v123 + 144);
                                        *(v123 + 128) = 0;
                                        *(v123 + 136) = 0;
                                        *(v123 + 144) = 0;
                                        v125[19] = 0;
                                        v125[20] = 0;
                                        v125[21] = 0;
                                        *(v125 + 19) = *(v123 + 152);
                                        v125[21] = *(v123 + 168);
                                        *(v123 + 152) = 0;
                                        *(v123 + 160) = 0;
                                        *(v123 + 168) = 0;
                                        v125[22] = *(v123 + 176);
                                        v125 += 23;
                                        v123 += 184;
                                      }

                                      while (v123 != v124);
                                      v123 = a3[13];
                                      v124 = a3[14];
                                    }

                                    geo::small_vector_base<geo::c3m::Mesh>::runDestructors(v123, v124);
                                    if (v117 != v154)
                                    {
                                      free(a3[13]);
                                    }

                                    v116 = (v122 + __ne);
                                    a3[13] = v122;
                                    a3[14] = v122 + __ne;
                                    a3[16] = v121;
                                  }

                                  v130 = v116 + 4;
                                  *v116 = v116 + 4;
                                  v116[1] = v116 + 4;
                                  v116[2] = v116 + 4;
                                  v131 = v165;
                                  v116[3] = *(&v165 + 1);
                                  v132 = v164[0];
                                  if (v164[0] == v131)
                                  {
                                    v116[1] = v130 + v164[1] - v164[0];
                                    for (j = v164[1]; v132 != j; v132 += 3)
                                    {
                                      v134 = *v132;
                                      v130[2] = v132[2];
                                      *v130 = v134;
                                      v130 += 3;
                                    }
                                  }

                                  else
                                  {
                                    *v116 = v164[0];
                                    v116[1] = v164[1];
                                    *v164 = 0u;
                                    v165 = 0u;
                                  }

                                  v81 = 0;
                                  v116[12] = 0;
                                  v116[13] = 0;
                                  v116[10] = 0;
                                  v116[11] = 0;
                                  *(v116 + 5) = *v167;
                                  v116[12] = v168[0];
                                  v116[14] = 0;
                                  v116[15] = 0;
                                  *(v116 + 13) = *&v168[1];
                                  v116[15] = v168[3];
                                  v116[16] = 0;
                                  v116[17] = 0;
                                  v116[18] = 0;
                                  *(v116 + 8) = *v169;
                                  v116[18] = v170[0];
                                  v116[19] = 0;
                                  v116[20] = 0;
                                  v116[21] = 0;
                                  *(v116 + 19) = *&v170[1];
                                  v116[21] = v170[3];
                                  v116[22] = v171;
                                  v167[0] = 0;
                                  v167[1] = 0;
                                  memset(v168, 0, sizeof(v168));
                                  v169[0] = 0;
                                  v169[1] = 0;
                                  memset(v170, 0, sizeof(v170));
                                  a3[14] += 184;
                                  v82 = v170[1];
                                  if (!v170[1])
                                  {
                                    goto LABEL_66;
                                  }

LABEL_65:
                                  v170[2] = v82;
                                  operator delete(v82);
                                  goto LABEL_66;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    printf("Failed to read C3m file - %s", v56);
LABEL_64:
    printf("Failed to read C3m file - %s", "Invalid mesh");
    v8 = 0;
    v81 = 1;
    v82 = v170[1];
    if (v170[1])
    {
      goto LABEL_65;
    }

LABEL_66:
    if (v169[0])
    {
      v169[1] = v169[0];
      operator delete(v169[0]);
    }

    if (v168[1])
    {
      v168[2] = v168[1];
      operator delete(v168[1]);
    }

    if (v167[0])
    {
      v167[1] = v167[0];
      operator delete(v167[0]);
    }

    if (v164[0] != v165)
    {
      free(v164[0]);
    }

    if (++v11 == v10)
    {
      v12 = 1;
    }

    else
    {
      v12 = v81;
    }

    if (v12 == 1)
    {
      return v8 & 1;
    }
  }

  v7 = "Invalid mesh type";
LABEL_3:
  printf("Failed to read C3m file - %s", v7);
  v8 = 0;
  return v8 & 1;
}

void sub_1B337C010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, uint64_t a45, void *a46, uint64_t a47, uint64_t a48, void *a49, uint64_t a50, uint64_t a51, void *a52)
{
  if (__p)
  {
    operator delete(__p);
  }

  if (a52)
  {
    operator delete(a52);
    v53 = a49;
    if (!a49)
    {
LABEL_5:
      v54 = a46;
      if (!a46)
      {
        goto LABEL_6;
      }

      goto LABEL_13;
    }
  }

  else
  {
    v53 = a49;
    if (!a49)
    {
      goto LABEL_5;
    }
  }

  operator delete(v53);
  v54 = a46;
  if (!a46)
  {
LABEL_6:
    v55 = a43;
    if (!a43)
    {
      goto LABEL_8;
    }

    goto LABEL_7;
  }

LABEL_13:
  operator delete(v54);
  v55 = a43;
  if (!a43)
  {
LABEL_8:
    if (a33 != a35)
    {
      free(a33);
    }

    _Unwind_Resume(a1);
  }

LABEL_7:
  operator delete(v55);
  goto LABEL_8;
}

uint64_t anonymous namespace::readMeshChunkType0(uint64_t *a1, float64x2_t *a2, float64x2_t *a3, void *a4, float64x2_t a5, float64_t a6, double a7)
{
  v8 = a1[1];
  v7 = a1[2];
  if (v7 + 2 > v8)
  {
    v9 = "Number of vertices";
    goto LABEL_5;
  }

  a1[2] = v7 + 2;
  v11 = v7 + 6;
  if (v7 + 6 > v8)
  {
    v9 = "Number of indices";
    goto LABEL_5;
  }

  v16 = *a1;
  v17 = *(*a1 + v7);
  a1[2] = v11;
  v18 = *(v16 + v11 - 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a4[12] - a4[10]) >> 2) < v17)
  {
    operator new();
  }

  if (v17)
  {
    v19 = 0;
    while (1)
    {
      v21 = a1[1];
      v22 = a1[2];
      if (v22 + 2 > v21)
      {
        v9 = "Vertex x value";
        goto LABEL_5;
      }

      a1[2] = v22 + 2;
      v23 = v22 + 4;
      if (v22 + 4 > v21)
      {
        v9 = "Vertex y value";
        goto LABEL_5;
      }

      v24 = *a1;
      LOWORD(a5.f64[0]) = *(*a1 + v22);
      a1[2] = v23;
      v25 = v22 + 6;
      if (v25 > v21)
      {
        break;
      }

      v26 = *&a5.f64[0];
      LOWORD(a6) = *(v24 + v23 - 2);
      a1[2] = v25;
      LOWORD(a7) = *(v24 + v25 - 2);
      a7 = *&a7;
      a5.f64[1] = *&a6;
      v27 = vcvt_f32_f64(vmlaq_f64(*a3, a5, *a2));
      a6 = a3[1].f64[0];
      a5.f64[0] = a6 + a2[1].f64[0] * a7;
      v28 = a5.f64[0];
      v30 = a4[11];
      v29 = a4[12];
      if (v30 < v29)
      {
        *v30 = v27;
        v30[1].f32[0] = v28;
        v20 = &v30[1] + 4;
      }

      else
      {
        v31 = a4[10];
        v32 = 0xAAAAAAAAAAAAAAABLL * ((v30 - v31) >> 2) + 1;
        if (v32 > 0x1555555555555555)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v33 = 0xAAAAAAAAAAAAAAABLL * ((v29 - v31) >> 2);
        if (2 * v33 > v32)
        {
          v32 = 2 * v33;
        }

        if (v33 >= 0xAAAAAAAAAAAAAAALL)
        {
          v34 = 0x1555555555555555;
        }

        else
        {
          v34 = v32;
        }

        if (v34)
        {
          if (v34 <= 0x1555555555555555)
          {
            operator new();
          }

          goto LABEL_89;
        }

        v35 = 4 * ((v30 - v31) >> 2);
        *v35 = v27;
        *(v35 + 8) = v28;
        if (v31 != v30)
        {
          v36 = v31;
          v37 = 4 * ((v30 - v31) >> 2) - (v30 - v31);
          do
          {
            v38 = *v36;
            *(v37 + 8) = v36[1].i32[0];
            *v37 = v38;
            v37 += 12;
            v36 = (v36 + 12);
          }

          while (v36 != v30);
        }

        v20 = v35 + 12;
        a4[10] = 4 * ((v30 - v31) >> 2) - (v30 - v31);
        a4[11] = v35 + 12;
        a4[12] = 0;
        if (v31)
        {
          operator delete(v31);
        }
      }

      a4[11] = v20;
      if (++v19 >= v17)
      {
        goto LABEL_32;
      }
    }

    v9 = "Vertex z value";
    goto LABEL_5;
  }

LABEL_32:
  if (v17 > (a4[15] - a4[13]) >> 3)
  {
    operator new();
  }

  if (v17)
  {
    v39 = 0;
    v9 = "Texture u value";
    do
    {
      v42 = a1[1];
      v41 = a1[2];
      if (v41 + 2 > v42)
      {
        goto LABEL_5;
      }

      a1[2] = v41 + 2;
      v43 = v41 + 4;
      if (v41 + 4 > v42)
      {
        v9 = "Texture v value";
        goto LABEL_5;
      }

      v44 = *a1;
      LOWORD(a5.f64[0]) = *(*a1 + v41);
      *&v45 = LODWORD(a5.f64[0]);
      v46 = *&v45 * 0.000015259;
      a1[2] = v43;
      LOWORD(v45) = *(v44 + v43 - 2);
      *a5.f64 = v45;
      v47 = *a5.f64 * 0.000015259;
      v49 = a4[14];
      v48 = a4[15];
      if (v49 < v48)
      {
        *v49 = v46;
        v49[1] = v47;
        v40 = (v49 + 2);
      }

      else
      {
        v50 = a4[13];
        v51 = (v49 - v50) >> 3;
        v52 = v51 + 1;
        if ((v51 + 1) >> 61)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v53 = v48 - v50;
        if (v53 >> 2 > v52)
        {
          v52 = v53 >> 2;
        }

        if (v53 >= 0x7FFFFFFFFFFFFFF8)
        {
          v54 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v54 = v52;
        }

        if (v54)
        {
          if (!(v54 >> 61))
          {
            operator new();
          }

          goto LABEL_89;
        }

        v55 = (v49 - v50) >> 3;
        v56 = (8 * v51);
        *v56 = v46;
        v56[1] = v47;
        v40 = 8 * v51 + 8;
        v57 = 8 * v51 - 8 * v55;
        if (v50 != v49)
        {
          v58 = v49 - v50 - 8;
          v59 = v50;
          v60 = (8 * v51 - 8 * v55);
          if (v58 > 0x27)
          {
            v61 = 8 * v55;
            v59 = v50;
            v60 = (8 * v51 - 8 * v55);
            if ((v49 - v50 - &v50[2 * v55]) >= 0x20)
            {
              v62 = (v58 >> 3) + 1;
              v63 = 2 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
              v59 = &v50[v63];
              v64 = (8 * v51 - v61 + 16);
              v65 = (v50 + 4);
              v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                a5 = v65[-1];
                v67 = *v65;
                v64[-1] = a5;
                *v64 = v67;
                v64 += 2;
                v65 += 2;
                v66 -= 4;
              }

              while (v66);
              if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL))
              {
                a4[13] = v57;
                a4[14] = v40;
                a4[15] = 0;
LABEL_63:
                operator delete(v50);
                goto LABEL_40;
              }

              v60 = (v57 + v63 * 4);
            }
          }

          do
          {
            v68 = *v59;
            v59 += 2;
            *v60++ = v68;
          }

          while (v59 != v49);
        }

        a4[13] = v57;
        a4[14] = v40;
        a4[15] = 0;
        if (v50)
        {
          goto LABEL_63;
        }
      }

LABEL_40:
      a4[14] = v40;
      ++v39;
    }

    while (v39 < v17);
  }

  if (v18 > (a4[18] - a4[16]) >> 1)
  {
    operator new();
  }

  if (!v18)
  {
    return 1;
  }

  while (1)
  {
    v70 = a1[2] + 2;
    if (v70 > a1[1])
    {
      v9 = "Index value";
      goto LABEL_5;
    }

    a1[2] = v70;
    v71 = *(*a1 + v70 - 2);
    if (v71 >= v17)
    {
      break;
    }

    v73 = a4[17];
    v72 = a4[18];
    if (v73 < v72)
    {
      *v73 = v71;
      v69 = v73 + 2;
    }

    else
    {
      v74 = a4[16];
      v75 = v73 - v74;
      v76 = (v73 - v74) >> 1;
      if (v76 <= -2)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v77 = v72 - v74;
      if (v77 <= v76 + 1)
      {
        v78 = v76 + 1;
      }

      else
      {
        v78 = v77;
      }

      if (v77 >= 0x7FFFFFFFFFFFFFFELL)
      {
        v79 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v79 = v78;
      }

      if (v79)
      {
        if ((v79 & 0x8000000000000000) == 0)
        {
          operator new();
        }

LABEL_89:
        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      v80 = (v73 - v74) >> 1;
      v81 = (2 * v76);
      v82 = (2 * v76 - 2 * v80);
      *v81 = v71;
      v69 = v81 + 1;
      memcpy(v82, v74, v75);
      a4[16] = v82;
      a4[17] = v69;
      a4[18] = 0;
      if (v74)
      {
        operator delete(v74);
      }
    }

    a4[17] = v69;
    result = 1;
    LODWORD(v18) = v18 - 1;
    if (!v18)
    {
      return result;
    }
  }

  v9 = "Invalid index";
LABEL_5:
  printf("Failed to read C3m file - %s", v9);
  return 0;
}

uint64_t anonymous namespace::readMeshChunkType1(uint64_t *a1, float64x2_t *a2, float64x2_t *a3, void *a4, float64x2_t a5, float64_t a6, double a7)
{
  v8 = a1[1];
  v7 = a1[2];
  if (v7 + 2 > v8)
  {
    v9 = "Number of vertices";
    goto LABEL_5;
  }

  a1[2] = v7 + 2;
  v11 = v7 + 6;
  if (v7 + 6 > v8)
  {
    v9 = "Number of indices";
    goto LABEL_5;
  }

  v16 = *a1;
  v17 = *(*a1 + v7);
  a1[2] = v11;
  v18 = *(v16 + v11 - 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a4[12] - a4[10]) >> 2) < v17)
  {
    operator new();
  }

  if (v17)
  {
    v19 = 0;
    while (1)
    {
      v21 = a1[1];
      v22 = a1[2];
      v23 = v22 + 1;
      if (v22 + 1 > v21)
      {
        v9 = "Vertex x value";
        goto LABEL_5;
      }

      a1[2] = v23;
      v24 = v22 + 2;
      if (v22 + 2 > v21)
      {
        v9 = "Vertex y value";
        goto LABEL_5;
      }

      v25 = *a1;
      LOBYTE(a5.f64[0]) = *(*a1 + v22);
      a1[2] = v24;
      v26 = v22 + 3;
      if (v26 > v21)
      {
        break;
      }

      v27 = *&a5.f64[0];
      LOBYTE(a6) = *(v25 + v23);
      a1[2] = v26;
      LOBYTE(a7) = *(v25 + v24);
      a7 = *&a7;
      a5.f64[1] = *&a6;
      v28 = vcvt_f32_f64(vmlaq_f64(*a3, a5, *a2));
      a6 = a3[1].f64[0];
      a5.f64[0] = a6 + a2[1].f64[0] * a7;
      v29 = a5.f64[0];
      v31 = a4[11];
      v30 = a4[12];
      if (v31 < v30)
      {
        *v31 = v28;
        v31[1].f32[0] = v29;
        v20 = &v31[1] + 4;
      }

      else
      {
        v32 = a4[10];
        v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v32) >> 2) + 1;
        if (v33 > 0x1555555555555555)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v34 = 0xAAAAAAAAAAAAAAABLL * ((v30 - v32) >> 2);
        if (2 * v34 > v33)
        {
          v33 = 2 * v34;
        }

        if (v34 >= 0xAAAAAAAAAAAAAAALL)
        {
          v35 = 0x1555555555555555;
        }

        else
        {
          v35 = v33;
        }

        if (v35)
        {
          if (v35 <= 0x1555555555555555)
          {
            operator new();
          }

          goto LABEL_89;
        }

        v36 = 4 * ((v31 - v32) >> 2);
        *v36 = v28;
        *(v36 + 8) = v29;
        if (v32 != v31)
        {
          v37 = v32;
          v38 = 4 * ((v31 - v32) >> 2) - (v31 - v32);
          do
          {
            v39 = *v37;
            *(v38 + 8) = v37[1].i32[0];
            *v38 = v39;
            v38 += 12;
            v37 = (v37 + 12);
          }

          while (v37 != v31);
        }

        v20 = v36 + 12;
        a4[10] = 4 * ((v31 - v32) >> 2) - (v31 - v32);
        a4[11] = v36 + 12;
        a4[12] = 0;
        if (v32)
        {
          operator delete(v32);
        }
      }

      a4[11] = v20;
      if (++v19 >= v17)
      {
        goto LABEL_32;
      }
    }

    v9 = "Vertex z value";
    goto LABEL_5;
  }

LABEL_32:
  if (v17 > (a4[15] - a4[13]) >> 3)
  {
    operator new();
  }

  if (v17)
  {
    v40 = 0;
    v9 = "Texture u value";
    do
    {
      v43 = a1[1];
      v42 = a1[2];
      v44 = v42 + 1;
      if (v42 + 1 > v43)
      {
        goto LABEL_5;
      }

      a1[2] = v44;
      if (v42 + 2 > v43)
      {
        v9 = "Texture v value";
        goto LABEL_5;
      }

      v45 = *a1;
      LOBYTE(a5.f64[0]) = *(*a1 + v42);
      a1[2] = v42 + 2;
      LOBYTE(a7) = *(v45 + v44);
      v46 = LODWORD(a5.f64[0]) * 0.0039216;
      *a5.f64 = LODWORD(a7);
      v47 = LODWORD(a7) * 0.0039216;
      v49 = a4[14];
      v48 = a4[15];
      if (v49 < v48)
      {
        *v49 = v46;
        v49[1] = v47;
        v41 = (v49 + 2);
      }

      else
      {
        v50 = a4[13];
        v51 = (v49 - v50) >> 3;
        v52 = v51 + 1;
        if ((v51 + 1) >> 61)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v53 = v48 - v50;
        if (v53 >> 2 > v52)
        {
          v52 = v53 >> 2;
        }

        if (v53 >= 0x7FFFFFFFFFFFFFF8)
        {
          v54 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v54 = v52;
        }

        if (v54)
        {
          if (!(v54 >> 61))
          {
            operator new();
          }

          goto LABEL_89;
        }

        v55 = (v49 - v50) >> 3;
        v56 = (8 * v51);
        *v56 = v46;
        v56[1] = v47;
        v41 = 8 * v51 + 8;
        v57 = 8 * v51 - 8 * v55;
        if (v50 != v49)
        {
          v58 = v49 - v50 - 8;
          v59 = v50;
          v60 = (8 * v51 - 8 * v55);
          if (v58 > 0x27)
          {
            v61 = 8 * v55;
            v59 = v50;
            v60 = (8 * v51 - 8 * v55);
            if ((v49 - v50 - &v50[2 * v55]) >= 0x20)
            {
              v62 = (v58 >> 3) + 1;
              v63 = 2 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
              v59 = &v50[v63];
              v64 = (8 * v51 - v61 + 16);
              v65 = (v50 + 4);
              v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                a5 = v65[-1];
                v67 = *v65;
                v64[-1] = a5;
                *v64 = v67;
                v64 += 2;
                v65 += 2;
                v66 -= 4;
              }

              while (v66);
              if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL))
              {
                a4[13] = v57;
                a4[14] = v41;
                a4[15] = 0;
LABEL_63:
                operator delete(v50);
                goto LABEL_40;
              }

              v60 = (v57 + v63 * 4);
            }
          }

          do
          {
            v68 = *v59;
            v59 += 2;
            *v60++ = v68;
          }

          while (v59 != v49);
        }

        a4[13] = v57;
        a4[14] = v41;
        a4[15] = 0;
        if (v50)
        {
          goto LABEL_63;
        }
      }

LABEL_40:
      a4[14] = v41;
      ++v40;
    }

    while (v40 < v17);
  }

  if (v18 > (a4[18] - a4[16]) >> 1)
  {
    operator new();
  }

  if (!v18)
  {
    return 1;
  }

  while (1)
  {
    v70 = a1[2] + 2;
    if (v70 > a1[1])
    {
      v9 = "Index value";
      goto LABEL_5;
    }

    a1[2] = v70;
    v71 = *(*a1 + v70 - 2);
    if (v71 >= v17)
    {
      break;
    }

    v73 = a4[17];
    v72 = a4[18];
    if (v73 < v72)
    {
      *v73 = v71;
      v69 = v73 + 2;
    }

    else
    {
      v74 = a4[16];
      v75 = v73 - v74;
      v76 = (v73 - v74) >> 1;
      if (v76 <= -2)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v77 = v72 - v74;
      if (v77 <= v76 + 1)
      {
        v78 = v76 + 1;
      }

      else
      {
        v78 = v77;
      }

      if (v77 >= 0x7FFFFFFFFFFFFFFELL)
      {
        v79 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v79 = v78;
      }

      if (v79)
      {
        if ((v79 & 0x8000000000000000) == 0)
        {
          operator new();
        }

LABEL_89:
        std::__throw_bad_array_new_length[abi:ne200100]();
      }

      v80 = (v73 - v74) >> 1;
      v81 = (2 * v76);
      v82 = (2 * v76 - 2 * v80);
      *v81 = v71;
      v69 = v81 + 1;
      memcpy(v82, v74, v75);
      a4[16] = v82;
      a4[17] = v69;
      a4[18] = 0;
      if (v74)
      {
        operator delete(v74);
      }
    }

    a4[17] = v69;
    result = 1;
    LODWORD(v18) = v18 - 1;
    if (!v18)
    {
      return result;
    }
  }

  v9 = "Invalid index";
LABEL_5:
  printf("Failed to read C3m file - %s", v9);
  return 0;
}

uint64_t anonymous namespace::readMeshChunkType2(uint64_t *a1, float64x2_t *a2, float64x2_t *a3, void *a4)
{
  v7 = *a1;
  v8 = a1[1];
  v73[0] = *a1;
  v73[1] = v8;
  v74 = 0;
  if (v8 <= 1)
  {
    v9 = "Number of vertices";
    goto LABEL_5;
  }

  if (v8 <= 5)
  {
    v9 = "Number of indices";
    goto LABEL_5;
  }

  v15 = *v7;
  v16 = *(v7 + 1);
  v73[2] = 6;
  if (0xAAAAAAAAAAAAAAABLL * ((a4[12] - a4[10]) >> 2) < v15)
  {
    operator new();
  }

  if (v15 > (a4[15] - a4[13]) >> 3)
  {
    operator new();
  }

  if (v15)
  {
    for (i = 0; i < v15; ++i)
    {
      geo::ibitstream::readUIntBits(v71, v73, 0xAu);
      if (v71[0] != 1)
      {
        v9 = "Vertex x value";
        goto LABEL_5;
      }

      LODWORD(v4) = v72;
      geo::ibitstream::readUIntBits(v71, v73, 0xAu);
      if ((v71[0] & 1) == 0)
      {
        v9 = "Vertex y value";
        goto LABEL_5;
      }

      LODWORD(v5) = v72;
      geo::ibitstream::readUIntBits(v71, v73, 0xAu);
      if ((v71[0] & 1) == 0)
      {
        v9 = "Vertex z value";
        goto LABEL_5;
      }

      LODWORD(v6) = v72;
      geo::ibitstream::readUIntBits(v71, v73, 9u);
      if ((v71[0] & 1) == 0)
      {
        v9 = "Texture u value";
        goto LABEL_5;
      }

      v19 = v72;
      geo::ibitstream::readUIntBits(v71, v73, 9u);
      if ((v71[0] & 1) == 0)
      {
        v9 = "Texture v value";
        goto LABEL_5;
      }

      v20.f64[0] = v4;
      v21 = v72;
      v20.f64[1] = v5;
      v5 = vcvt_f32_f64(vmlaq_f64(*a3, v20, *a2));
      v22 = a3[1].f64[0] + a2[1].f64[0] * v6;
      v24 = a4[11];
      v23 = a4[12];
      if (v24 >= v23)
      {
        v26 = a4[10];
        v27 = 0xAAAAAAAAAAAAAAABLL * (v24 - v26) + 1;
        if (v27 > 0x1555555555555555)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v28 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v26) >> 2);
        if (2 * v28 > v27)
        {
          v27 = 2 * v28;
        }

        if (v28 >= 0xAAAAAAAAAAAAAAALL)
        {
          v29 = 0x1555555555555555;
        }

        else
        {
          v29 = v27;
        }

        if (v29)
        {
          if (v29 <= 0x1555555555555555)
          {
            operator new();
          }

LABEL_86:
          std::__throw_bad_array_new_length[abi:ne200100]();
        }

        v30 = 4 * (v24 - v26);
        *v30 = v5;
        *(v30 + 8) = v22;
        if (v26 != v24)
        {
          v31 = v26;
          v32 = 4 * (v24 - v26) - (v24 - v26);
          do
          {
            v33 = *v31;
            *(v32 + 8) = v31[2];
            *v32 = v33;
            v32 += 12;
            v31 += 3;
          }

          while (v31 != v24);
        }

        v25 = v30 + 12;
        a4[10] = 4 * (v24 - v26) - (v24 - v26);
        a4[11] = v30 + 12;
        a4[12] = 0;
        if (v26)
        {
          operator delete(v26);
        }
      }

      else
      {
        *v24 = v5;
        v24[2] = v22;
        v25 = (v24 + 3);
      }

      v34 = v19 * 0.0019569;
      v35 = v21 * 0.0019569;
      a4[11] = v25;
      v37 = a4[14];
      v36 = a4[15];
      if (v37 < v36)
      {
        *v37 = v34;
        v37[1] = v35;
        v18 = (v37 + 2);
      }

      else
      {
        v38 = a4[13];
        v39 = (v37 - v38) >> 3;
        v40 = v39 + 1;
        if ((v39 + 1) >> 61)
        {
          std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
        }

        v41 = v36 - v38;
        if (v41 >> 2 > v40)
        {
          v40 = v41 >> 2;
        }

        if (v41 >= 0x7FFFFFFFFFFFFFF8)
        {
          v42 = 0x1FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v42 = v40;
        }

        if (v42)
        {
          if (!(v42 >> 61))
          {
            operator new();
          }

          goto LABEL_86;
        }

        v43 = (v37 - v38) >> 3;
        v44 = (8 * v39);
        *v44 = v34;
        v44[1] = v35;
        v18 = 8 * v39 + 8;
        v45 = 8 * v39 - 8 * v43;
        if (v38 != v37)
        {
          v46 = v37 - v38 - 8;
          v47 = v38;
          v48 = (8 * v39 - 8 * v43);
          if (v46 > 0x27)
          {
            v49 = 8 * v43;
            v47 = v38;
            v48 = (8 * v39 - 8 * v43);
            if ((v37 - v38 - v38 - 8 * v43) >= 0x20)
            {
              v50 = (v46 >> 3) + 1;
              v51 = 2 * (v50 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v38[v51];
              v52 = (8 * v39 - v49 + 16);
              v53 = (v38 + 4);
              v54 = v50 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v55 = *v53;
                *(v52 - 1) = *(v53 - 1);
                *v52 = v55;
                v52 += 2;
                v53 += 2;
                v54 -= 4;
              }

              while (v54);
              if (v50 == (v50 & 0x3FFFFFFFFFFFFFFCLL))
              {
                a4[13] = v45;
                a4[14] = v18;
                a4[15] = 0;
LABEL_56:
                operator delete(v38);
                goto LABEL_14;
              }

              v48 = (v45 + v51 * 4);
            }
          }

          do
          {
            v56 = *v47;
            v47 += 2;
            *v48++ = v56;
          }

          while (v47 != v37);
        }

        a4[13] = v45;
        a4[14] = v18;
        a4[15] = 0;
        if (v38)
        {
          goto LABEL_56;
        }
      }

LABEL_14:
      a4[14] = v18;
    }
  }

  if (v16 > (a4[18] - a4[16]) >> 1)
  {
    operator new();
  }

  if (!v16)
  {
    return 1;
  }

  while (1)
  {
    v58 = a1[2] + 2;
    if (v58 > a1[1])
    {
      v9 = "Index value";
      goto LABEL_5;
    }

    a1[2] = v58;
    v59 = *(*a1 + v58 - 2);
    if (v59 >= v15)
    {
      break;
    }

    v61 = a4[17];
    v60 = a4[18];
    if (v61 < v60)
    {
      *v61 = v59;
      v57 = v61 + 2;
    }

    else
    {
      v62 = a4[16];
      v63 = v61 - v62;
      v64 = (v61 - v62) >> 1;
      if (v64 <= -2)
      {
        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }

      v65 = v60 - v62;
      if (v65 <= v64 + 1)
      {
        v66 = v64 + 1;
      }

      else
      {
        v66 = v65;
      }

      if (v65 >= 0x7FFFFFFFFFFFFFFELL)
      {
        v67 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v67 = v66;
      }

      if (v67)
      {
        if ((v67 & 0x8000000000000000) == 0)
        {
          operator new();
        }

        goto LABEL_86;
      }

      v68 = (v61 - v62) >> 1;
      v69 = (2 * v64);
      v70 = (2 * v64 - 2 * v68);
      *v69 = v59;
      v57 = v69 + 1;
      memcpy(v70, v62, v63);
      a4[16] = v70;
      a4[17] = v57;
      a4[18] = 0;
      if (v62)
      {
        operator delete(v62);
      }
    }

    a4[17] = v57;
    result = 1;
    LODWORD(v16) = v16 - 1;
    if (!v16)
    {
      return result;
    }
  }

  v9 = "Invalid index";
LABEL_5:
  printf("Failed to read C3m file - %s", v9);
  return 0;
}

uint64_t anonymous namespace::readTextureData(uint64_t *a1)
{
  v1 = a1[1];
  v2 = a1[2];
  if (v2 + 1 <= v1)
  {
    a1[2] = v2 + 1;
    v4 = v2 + 5;
    if (v2 + 5 <= v1)
    {
      v5 = *a1;
      v6 = *(*a1 + v2);
      a1[2] = v4;
      v7 = v2 + 9;
      if (v2 + 9 <= v1)
      {
        v8 = *(v5 + v4 - 4);
        a1[2] = v7;
        v9 = v2 + 13;
        if (v9 <= v1)
        {
          v10 = *(v5 + v7 - 4);
          a1[2] = v9;
          if (v1 >= (v10 + v8))
          {
            if (v6 < 0xE)
            {
              operator new();
            }

            v3 = "Invalid texture data type";
          }

          else
          {
            v3 = "Invalid file data offset";
          }
        }

        else
        {
          v3 = "Texture uncompressed data size";
        }
      }

      else
      {
        v3 = "Texture compressed data size";
      }
    }

    else
    {
      v3 = "Texture data offset";
    }
  }

  else
  {
    v3 = "Texture data type";
  }

  printf("Failed to read C3m file - %s", v3);
  return 0;
}

void sub_1B337D9FC(_Unwind_Exception *a1)
{
  v4 = *v2;
  if (*v2)
  {
    v1[1].__shared_owners_ = v4;
    operator delete(v4);
  }

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2)
  {
    *(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FC90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t geo::c3mm::C3mmArea::getMeshTypeForKeyOrParent(unsigned __int16 *a1, int *a2, int *a3, uint64_t *a4)
{
  *a3 = 3;
  *a4 = 0;
  a4[1] = 0;
  if ((*a1 | 2) != 2)
  {
    return 0xFFFFFFFFLL;
  }

  v5 = a1;
  v6 = *(a1 + 15);
  v74 = *(a1 + 16);
  if (v6 == v74)
  {
    return 0xFFFFFFFFLL;
  }

  v76 = a1 + 80;
  while (2)
  {
    v8 = v6[1];
    v9 = *a2 >= v8;
    v10 = *a2 - v8;
    if (!v9)
    {
      goto LABEL_145;
    }

    v73 = v4;
    if (*a2 >= v10)
    {
      v11 = v10;
    }

    else
    {
      v11 = *a2;
    }

    v12 = (*a2 - v11);
    v13 = a2[1] >> v11;
    v14 = a2[2] >> v11;
    v15 = *(v5 + 16);
    v16 = *(v5 + 15);
    if (v16 == v15)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
    }

    else
    {
      while (v12 > v16[2])
      {
        v16 += 3;
        if (v16 == v15)
        {
          v17 = 0;
          v18 = 0;
          v19 = -1;
          goto LABEL_15;
        }
      }

      v19 = *v16;
      v18 = v13 >> (*a2 - v11 - *v16);
      v17 = v14 >> (*a2 - v11 - *v16);
    }

LABEL_15:
    v20 = a2[3];
    std::recursive_mutex::lock((a1 + 88));
    v21 = *v76;
    if (!*v76)
    {
LABEL_30:
      v5 = a1;
      std::recursive_mutex::unlock((a1 + 88));
      v29 = 0;
LABEL_31:
      v30 = 0;
      v31 = 0;
      v4 = v19 | (v18 << 32);
      goto LABEL_32;
    }

    v22 = v20 >> v11;
    v23 = v76;
    do
    {
      v24 = *(v21 + 8);
      if (v24 < v19)
      {
LABEL_17:
        ++v21;
        goto LABEL_18;
      }

      if (v19 < v24)
      {
        goto LABEL_21;
      }

      v25 = *(v21 + 9);
      if (v25 < v18)
      {
        goto LABEL_17;
      }

      if (v18 < v25)
      {
LABEL_21:
        v23 = v21;
      }

      else
      {
        v26 = *(v21 + 10);
        v9 = v26 >= v17;
        v27 = v26 < v17;
        if (v9)
        {
          v23 = v21;
        }

        v21 += v27;
      }

LABEL_18:
      v21 = *v21;
    }

    while (v21);
    if (v23 == v76)
    {
      goto LABEL_30;
    }

    v28 = *(v23 + 8);
    if (v19 < v28)
    {
      goto LABEL_30;
    }

    if (v28 >= v19)
    {
      v43 = *(v23 + 9);
      if (v18 < v43 || v43 >= v18 && v17 < *(v23 + 10))
      {
        goto LABEL_30;
      }
    }

    v33 = v23[6];
    v32 = v23[7];
    if (v32)
    {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v72 = v32;
    v5 = a1;
    std::recursive_mutex::unlock((a1 + 88));
    if (!v33)
    {
      v29 = v72;
      goto LABEL_31;
    }

    v34 = v33;
    v36 = *v33;
    v35 = *(v33 + 8);
    if (*v33 != v35)
    {
      while (*v36 != v12 || v36[1] != v13 || v36[2] != v14 || v36[3] != v22)
      {
        v36 += 6;
        if (v36 == v35)
        {
          goto LABEL_65;
        }
      }
    }

    if (v36 == v35)
    {
LABEL_65:
      v30 = 0;
      v31 = 1;
      v29 = v72;
      v4 = v73;
      goto LABEL_32;
    }

    v37 = v36[4];
    *a3 = 0;
    *a4 = (v13 << 32) | v12;
    a4[1] = v14 | (v22 << 32);
    v38 = vdupq_n_s32(*(*(v33 + 32) + 16 * v36[4]));
    if (vmaxv_u8(vmovn_s16(vuzp1q_s16(vceqq_s32(vandq_s8(v38, xmmword_1B33B24B0), xmmword_1B33B24B0), vceqq_s32(vandq_s8(v38, xmmword_1B33B24C0), xmmword_1B33B24C0)))))
    {
      *a3 = 2;
    }

    if (v12 == *a2 && v13 == a2[1])
    {
      v39 = a2[2];
      if (v14 >= v39 && v39 >= v14 && a2[3] == v22)
      {
        v30 = 0;
        v31 = 0;
        v4 = 0xFFFFFFFFLL;
        v29 = v72;
        goto LABEL_32;
      }
    }

    v29 = v72;
    if (*a1 != 2 || *(a1 + 1) || *v6 == *(*(a1 + 16) - 12))
    {
      v40 = v6[2] + 1;
    }

    else
    {
      v40 = v6[2];
    }

    v4 = v73;
    v41 = v6[1];
    v42 = v41 + 1;
    if (v41 + 1 > v40)
    {
      v31 = 0;
      v30 = 1;
      goto LABEL_32;
    }

    v44 = ~v41;
    while (2)
    {
      v45 = (*(v34 + 32) + 16 * v37);
      if (*a2 >= (v44 + *a2))
      {
        v46 = v44 + *a2;
      }

      else
      {
        v46 = *a2;
      }

      v47 = a2[1] >> v46;
      v48 = a2[2] >> v46;
      v49 = a2[3] >> v46;
      v50 = (a2[2] >> v46) & 1;
      v51 = (*v45 >> (2 * (v48 & 1 | (2 * (v47 & 1)) & 0xFB | (4 * (v49 & 1))))) & 3;
      v52 = v51 == 1;
      if (v51 <= 1)
      {
        v53 = 0;
        if (!v52)
        {
          goto LABEL_141;
        }

        goto LABEL_82;
      }

      if (v51 == 3)
      {
        v53 = 2;
LABEL_82:
        v54 = (*a2 - v46);
        *a3 = v53;
        *a4 = (v47 << 32) | v54;
        a4[1] = v48 | (v49 << 32);
        if (__PAIR64__(v47, v54) == *a2)
        {
          v55 = a2[2];
          if (v48 >= v55 && v55 >= v48 && a2[3] == v49)
          {
LABEL_141:
            v30 = 0;
            v31 = 0;
            goto LABEL_143;
          }
        }

        v56 = *v45;
        if (v56)
        {
          v58 = *(v34 + 32);
          v59 = *(v34 + 40);
          v60 = v59 == v58;
          if (v59 == v58)
          {
            v57 = 0;
          }

          else
          {
            v57 = v37 + 1;
          }

          if (!v60)
          {
            ++v37;
          }
        }

        else
        {
          v57 = 0;
        }

        v61 = v50 + ((4 * (v49 & 1)) | (2 * (v47 & 1))) + 1;
        if (v61 != 1)
        {
          if ((v56 & 4) != 0)
          {
            v62 = *(v34 + 32);
            if (v57 < ((*(v34 + 40) - v62) >> 4))
            {
              if (v57)
              {
                v37 = *(v62 + 16 * v57 + 12);
              }

              else
              {
                ++v37;
              }

              v57 = v37;
            }
          }

          if (v61 != 2)
          {
            if ((v56 & 0x10) != 0)
            {
              v63 = *(v34 + 32);
              if (v57 < ((*(v34 + 40) - v63) >> 4))
              {
                if (v57)
                {
                  v37 = *(v63 + 16 * v57 + 12);
                }

                else
                {
                  ++v37;
                }

                v57 = v37;
              }
            }

            if (v61 != 3)
            {
              if ((v56 & 0x40) != 0)
              {
                v64 = *(v34 + 32);
                if (v57 < ((*(v34 + 40) - v64) >> 4))
                {
                  if (v57)
                  {
                    v37 = *(v64 + 16 * v57 + 12);
                  }

                  else
                  {
                    ++v37;
                  }

                  v57 = v37;
                }
              }

              if (v61 != 4)
              {
                if ((v56 & 0x100) != 0)
                {
                  v65 = *(v34 + 32);
                  if (v57 < ((*(v34 + 40) - v65) >> 4))
                  {
                    if (v57)
                    {
                      v37 = *(v65 + 16 * v57 + 12);
                    }

                    else
                    {
                      ++v37;
                    }

                    v57 = v37;
                  }
                }

                if (v61 != 5)
                {
                  if ((v56 & 0x400) != 0)
                  {
                    v66 = *(v34 + 32);
                    if (v57 < ((*(v34 + 40) - v66) >> 4))
                    {
                      if (v57)
                      {
                        v37 = *(v66 + 16 * v57 + 12);
                      }

                      else
                      {
                        ++v37;
                      }

                      v57 = v37;
                    }
                  }

                  if (v61 != 6)
                  {
                    if ((v56 & 0x1000) != 0)
                    {
                      v67 = *(v34 + 32);
                      if (v57 < ((*(v34 + 40) - v67) >> 4))
                      {
                        if (v57)
                        {
                          v37 = *(v67 + 16 * v57 + 12);
                        }

                        else
                        {
                          ++v37;
                        }

                        v57 = v37;
                      }
                    }

                    if (v61 != 7 && (v56 & 0x4000) != 0)
                    {
                      v68 = *(v34 + 32);
                      if (v57 < ((*(v34 + 40) - v68) >> 4))
                      {
                        if (v57)
                        {
                          v37 = *(v68 + 16 * v57 + 12);
                        }

                        else
                        {
                          ++v37;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        ++v42;
        --v44;
        v30 = 1;
        if (v42 > v40)
        {
          v31 = 0;
          goto LABEL_32;
        }

        continue;
      }

      break;
    }

    v30 = 0;
    v31 = 0;
    *a3 = 1;
    *a4 = *a2;
LABEL_143:
    v4 = 0xFFFFFFFFLL;
LABEL_32:
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      (v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }

    if (v30)
    {
      v6 += 3;
      if (v6 == v74)
      {
LABEL_145:
        *a3 = 1;
        *a4 = *a2;
        return 0xFFFFFFFFLL;
      }

      continue;
    }

    break;
  }

  if (v31)
  {
    goto LABEL_145;
  }

  return v4;
}

unint64_t geo::c3mm::C3mmArea::getFileIndexToLoadForKey(uint64_t a1, int *a2)
{
  v2 = *(a1 + 120);
  v29 = *(a1 + 128);
  if (v2 == v29)
  {
    goto LABEL_46;
  }

  v5 = (a1 + 160);
  while (2)
  {
    if (*a2 >= (*a2 - *(v2 + 4)))
    {
      v6 = *a2 - *(v2 + 4);
    }

    else
    {
      v6 = *a2;
    }

    v7 = *(a1 + 128);
    v8 = *(a1 + 120);
    if (v8 == v7)
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
    }

    else
    {
      v9 = HIDWORD(*a2) >> v6;
      v10 = a2[2] >> v6;
      v11 = *a2 - v6;
      while (v11 > v8[2])
      {
        v8 += 3;
        if (v8 == v7)
        {
          v12 = 0;
          v13 = 0;
          v14 = -1;
          goto LABEL_13;
        }
      }

      v14 = *v8;
      v13 = v9 >> (v11 - *v8);
      v12 = v10 >> (v11 - *v8);
    }

LABEL_13:
    std::recursive_mutex::lock((a1 + 176));
    v15 = *v5;
    if (!*v5)
    {
LABEL_44:
      std::recursive_mutex::unlock((a1 + 176));
      return v14 | (v13 << 32);
    }

    v16 = v5;
    do
    {
      v17 = *(v15 + 8);
      if (v17 < v14)
      {
LABEL_15:
        ++v15;
        goto LABEL_16;
      }

      if (v14 < v17)
      {
        goto LABEL_19;
      }

      v18 = *(v15 + 9);
      if (v18 < v13)
      {
        goto LABEL_15;
      }

      if (v13 < v18)
      {
LABEL_19:
        v16 = v15;
      }

      else
      {
        v19 = *(v15 + 10);
        v20 = v19 >= v12;
        v21 = v19 < v12;
        if (v20)
        {
          v16 = v15;
        }

        v15 += v21;
      }

LABEL_16:
      v15 = *v15;
    }

    while (v15);
    if (v16 == v5)
    {
      goto LABEL_44;
    }

    v22 = *(v16 + 8);
    if (v14 < v22)
    {
      goto LABEL_44;
    }

    if (v22 >= v14)
    {
      v23 = *(v16 + 9);
      if (v13 < v23 || v23 >= v13 && v12 < *(v16 + 10))
      {
        goto LABEL_44;
      }
    }

    v25 = v16[6];
    v24 = v16[7];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    std::recursive_mutex::unlock((a1 + 176));
    if (v25)
    {
      v26 = *(v2 + 8);
      LODWORD(v25) = v26 < *a2;
      v27 = v26 >= *a2;
      if (v24)
      {
        goto LABEL_38;
      }

LABEL_39:
      if (!v25)
      {
        goto LABEL_45;
      }

LABEL_42:
      v2 += 12;
      if (v2 == v29)
      {
        goto LABEL_46;
      }

      continue;
    }

    break;
  }

  v27 = 0;
  if (!v24)
  {
    goto LABEL_39;
  }

LABEL_38:
  if (atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    goto LABEL_39;
  }

  (v24->__on_zero_shared)(v24);
  std::__shared_weak_count::__release_weak(v24);
  if (v25)
  {
    goto LABEL_42;
  }

LABEL_45:
  if (v27)
  {
LABEL_46:
    v13 = 0;
    v14 = -1;
  }

  return v14 | (v13 << 32);
}

uint64_t geo::c3mm::C3mmArea::getEntry(_WORD *a1, _DWORD *a2, uint64_t a3)
{
  *a3 = 0;
  *(a3 + 8) = 0;
  *(a3 + 20) = 0;
  if (*a1 == 2)
  {
    return geo::c3mm::C3mmArea::getEntryV2(a1, a2, a3);
  }

  else
  {
    return 0;
  }
}

uint64_t geo::c3mm::C3mmArea::getEntryV2(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  v4 = *a2;
  v5 = *(a1 + 120);
  v6 = *(a1 + 128);
  if (v5 == v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    LODWORD(EntryV2) = 0;
    if (!v4)
    {
      goto LABEL_14;
    }

    return 0xFFFFFFFFLL;
  }

  v7 = *(a1 + 120);
  while (1)
  {
    v8 = v7[2];
    if (v8 >= v4)
    {
      break;
    }

    v7 += 3;
    if (v7 == v6)
    {
      v8 = 0;
      v9 = 0;
      goto LABEL_9;
    }
  }

  v9 = *v7;
  do
  {
LABEL_9:
    if (v4 <= v5[2])
    {
      LODWORD(EntryV2) = *v5;
      v11 = (a2[1] >> (v4 - *v5));
      v10 = a2[2] >> (v4 - *v5);
      if (v4 <= v8)
      {
        goto LABEL_14;
      }

      return 0xFFFFFFFFLL;
    }

    v5 += 3;
  }

  while (v5 != v6);
  v10 = 0;
  v11 = 0;
  LODWORD(EntryV2) = -1;
  if (v4 > v8)
  {
    return 0xFFFFFFFFLL;
  }

LABEL_14:
  std::recursive_mutex::lock((a1 + 176));
  v16 = *(a1 + 160);
  if (!v16)
  {
LABEL_29:
    std::recursive_mutex::unlock((a1 + 176));
    return EntryV2 | (v11 << 32);
  }

  v17 = (a1 + 160);
  while (2)
  {
    v18 = *(v16 + 8);
    if (v18 < EntryV2)
    {
      goto LABEL_16;
    }

    if (EntryV2 < v18)
    {
      goto LABEL_20;
    }

    v19 = *(v16 + 9);
    if (v19 < v11)
    {
LABEL_16:
      ++v16;
    }

    else if (v11 < v19)
    {
LABEL_20:
      v17 = v16;
    }

    else
    {
      v20 = *(v16 + 10);
      v21 = v20 >= v10;
      v22 = v20 < v10;
      if (v21)
      {
        v17 = v16;
      }

      v16 += v22;
    }

    v16 = *v16;
    if (v16)
    {
      continue;
    }

    break;
  }

  if (v17 == (a1 + 160))
  {
    goto LABEL_29;
  }

  v23 = *(v17 + 8);
  if (EntryV2 < v23)
  {
    goto LABEL_29;
  }

  if (v23 >= EntryV2)
  {
    v51 = *(v17 + 9);
    if (v11 < v51 || v51 >= v11 && v10 < *(v17 + 10))
    {
      goto LABEL_29;
    }
  }

  v25 = v17[6];
  v24 = v17[7];
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  std::recursive_mutex::unlock((a1 + 176));
  if (v25)
  {
    if (v25[4] == v25[5])
    {
      v11 = 0;
      LODWORD(EntryV2) = -1;
    }

    else
    {
      v90 = a1;
      v91 = v25;
      v86 = a3;
      v87 = a2;
      v88 = v9;
      v89 = v24;
      v26 = *a2;
      v27 = *(a2 + 1);
      v28 = HIDWORD(*a2);
      v29 = v103;
      v99 = v103;
      v100 = v103;
      v101 = v103;
      v102 = 4;
      v30 = HIDWORD(v9);
      if (v26 > HIDWORD(v9))
      {
        v31 = 4;
        v32 = v103;
        while (1)
        {
          v35 = v32 - v29;
          v36 = ((v32 - v29) >> 2) + 1;
          if (v31 < v36)
          {
            break;
          }

          v33 = v29;
LABEL_39:
          *v32 = v27 & 1 | (2 * (v28 & 1)) | (v27 >> 30) & 4;
          v32 += 4;
          v100 = v32;
          v34 = v26 - 1;
          v28 = v28 >> 1;
          v27 = (v27 >> 1) & 0x7FFFFFFF7FFFFFFFLL;
          v26 = (v26 + 0xFFFFFFFFLL) | (v28 << 32);
          if (v34 <= v30)
          {
            goto LABEL_63;
          }
        }

        v37 = v101;
        v38 = (1 << -__clz(v31 + 1));
        if (v31 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v38 = 1;
        }

        if (v38 <= v36)
        {
          v31 = ((v32 - v29) >> 2) + 1;
        }

        else
        {
          v31 = v38;
        }

        v33 = malloc_type_malloc(4 * v31, 0x100004052888210uLL);
        v39 = v99;
        v40 = v100;
        if (v99 != v100)
        {
          v41 = v100 - v99 - 4;
          v42 = v33;
          v43 = v99;
          if (v41 < 0x1C || (v42 = v33, v43 = v99, (v33 - v99) < 0x20))
          {
            do
            {
LABEL_53:
              v50 = *v43;
              v43 += 4;
              *v42 = v50;
              v42 += 4;
            }

            while (v43 != v40);
          }

          else
          {
            v44 = (v41 >> 2) + 1;
            v45 = 4 * (v44 & 0x7FFFFFFFFFFFFFF8);
            v42 = &v33[v45];
            v46 = (v99 + 16);
            v47 = v33 + 16;
            v48 = v44 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v49 = *v46;
              *(v47 - 1) = *(v46 - 1);
              *v47 = v49;
              v46 += 2;
              v47 += 2;
              v48 -= 8;
            }

            while (v48);
            if (v44 != (v44 & 0x7FFFFFFFFFFFFFF8))
            {
              v43 = &v39[v45];
              goto LABEL_53;
            }
          }
        }

        if (v29 != v37)
        {
          free(v39);
        }

        v32 = &v33[v35];
        v99 = v33;
        v102 = v31;
        v29 = v33;
        goto LABEL_39;
      }

      v33 = v103;
      v32 = v103;
      v34 = v26;
LABEL_63:
      v53 = *v91;
      v52 = v91[1];
      if (*v91 == v52)
      {
        v54 = v88;
        v55 = v90;
      }

      else
      {
        v54 = v88;
        v55 = v90;
        while (*v53 != v34 || *(v53 + 4) != v28 || *(v53 + 8) != v27)
        {
          v53 += 24;
          if (v53 == v52)
          {
            goto LABEL_149;
          }
        }
      }

      if (v53 == v52)
      {
        goto LABEL_149;
      }

      v56 = v91[4];
      v57 = *(v53 + 16);
      v58 = v32 - v33;
      if (v32 != v33)
      {
        v59 = 0;
        v60 = 0;
        v61 = 0;
        v62 = v58 >> 2;
        v63 = &v33[v58];
        v64 = v57;
        while (1)
        {
          v65 = *&v63[4 * ~v59];
          v66 = *(v56 + 16 * v64);
          if (((v66 >> (2 * v65)) & 1) == 0)
          {
            goto LABEL_149;
          }

          v67 = 0;
          v68 = 0;
          v69 = 0;
          do
          {
            if ((v66 >> v67))
            {
              if (v68)
              {
                v68 = *(v56 + 16 * v68 + 12);
              }

              else
              {
                v68 = v64 + 1;
              }

              if (((v66 >> v67) & 3) == 2)
              {
                v70 = 1;
              }

              else
              {
                v70 = 2;
              }

              if (((v66 >> v67) & 3) != 0)
              {
                v71 = 0;
              }

              else
              {
                v71 = 3;
              }

              if (((v66 >> v67) & 3) <= 1)
              {
                v60 = v71;
              }

              else
              {
                v60 = v70;
              }

              v64 = v68;
            }

            ++v69;
            v67 += 2;
          }

          while (v69 <= v65);
          v59 = ++v61;
          if (v62 <= v61)
          {
            goto LABEL_93;
          }
        }
      }

      v60 = 0;
      v64 = v57;
LABEL_93:
      if (*v87 == v34 && v87[1] == v28)
      {
        v73 = v87[2];
        if (v73 >= v27 && v73 <= v27 && v87[3] == HIDWORD(v27))
        {
          v74 = vdupq_n_s32(*(v56 + 16 * v57));
          v60 = 2 * (vmaxv_u8(vmovn_s16(vuzp1q_s16(vceqq_s32(vandq_s8(v74, xmmword_1B33B24B0), xmmword_1B33B24B0), vceqq_s32(vandq_s8(v74, xmmword_1B33B24C0), xmmword_1B33B24C0)))) & 1);
        }
      }

      v75 = (v56 + 16 * v64);
      *v86 = *(v75 + 2);
      v76 = *v75;
      v77 = *v75 == 0;
      *(v86 + 20) = v76;
      *(v86 + 12) = v77;
      *(v86 + 16) = v60;
      if (*v55 != 2)
      {
LABEL_149:
        v11 = 0;
        LODWORD(EntryV2) = -1;
        goto LABEL_150;
      }

      LODWORD(EntryV2) = -1;
      if (*(v55 + 1))
      {
        v11 = 0;
        goto LABEL_150;
      }

      v11 = 0;
      if (*v87 == v8)
      {
        LODWORD(EntryV2) = -1;
        v11 = 0;
        if (*(*(v55 + 16) - 12) != v54 && v60 == 2)
        {
          *(v86 + 20) = 0;
          if ((v76 & 3) == 0)
          {
            goto LABEL_112;
          }

          v78 = 2 * v87[3];
          v96 = *v87 + 1;
          v97 = vadd_s32(*(v87 + 1), *(v87 + 1));
          v98 = v78;
          v92 = 0;
          v93 = 0;
          v94 = 1;
          v95 = 0;
          EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v55, &v96, &v92);
          if (EntryV2 != -1)
          {
            goto LABEL_159;
          }

          if (v94 <= 2)
          {
            *(v86 + 20) |= v94 + 1;
          }

          v76 = *v75;
LABEL_112:
          if ((v76 & 0xC) != 0)
          {
            v79 = 2 * v87[3];
            v96 = *v87 + 1;
            v97 = vorr_s8(vadd_s32(*(v87 + 1), *(v87 + 1)), 0x100000000);
            v98 = v79;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v55 == 2)
            {
              EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v55, &v96, &v92);
              if (EntryV2 == -1)
              {
                if (v94 <= 2)
                {
                  *(v86 + 20) |= 4 * v94 + 4;
                }

                v76 = *v75;
                v55 = v90;
                goto LABEL_118;
              }

LABEL_159:
              v11 = HIDWORD(EntryV2);
              goto LABEL_150;
            }

LABEL_160:
            v11 = 0;
            LODWORD(EntryV2) = 0;
            goto LABEL_150;
          }

LABEL_118:
          if ((v76 & 0x30) != 0)
          {
            v80 = 2 * v87[3];
            v96 = *v87 + 1;
            v97 = vorr_s8(vadd_s32(*(v87 + 1), *(v87 + 1)), 1);
            v98 = v80;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v55 != 2)
            {
              goto LABEL_160;
            }

            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v55, &v96, &v92);
            if (EntryV2 != -1)
            {
              goto LABEL_159;
            }

            if (v94 <= 2)
            {
              *(v86 + 20) |= 16 * v94 + 16;
            }

            v76 = *v75;
            v55 = v90;
          }

          if ((v76 & 0xC0) != 0)
          {
            v81 = 2 * v87[3];
            v96 = *v87 + 1;
            v97 = *&vadd_s32(*(v87 + 1), *(v87 + 1)) | 0x100000001;
            v98 = v81;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v55 != 2)
            {
              goto LABEL_160;
            }

            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v90, &v96, &v92);
            if (EntryV2 != -1)
            {
              goto LABEL_159;
            }

            if (v94 <= 2)
            {
              *(v86 + 20) |= (v94 << 6) + 64;
            }

            v76 = *v75;
          }

          if ((v76 & 0x300) != 0)
          {
            v82 = (2 * v87[3]) | 1;
            v96 = *v87 + 1;
            v97 = vadd_s32(*(v87 + 1), *(v87 + 1));
            v98 = v82;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v90 != 2)
            {
              goto LABEL_160;
            }

            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v90, &v96, &v92);
            if (EntryV2 != -1)
            {
              goto LABEL_159;
            }

            if (v94 <= 2)
            {
              *(v86 + 20) |= (v94 << 8) + 256;
            }

            v76 = *v75;
          }

          if ((v76 & 0xC00) != 0)
          {
            v83 = (2 * v87[3]) | 1;
            v96 = *v87 + 1;
            v97 = vorr_s8(vadd_s32(*(v87 + 1), *(v87 + 1)), 0x100000000);
            v98 = v83;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v90 != 2)
            {
              goto LABEL_160;
            }

            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v90, &v96, &v92);
            if (EntryV2 != -1)
            {
              goto LABEL_159;
            }

            if (v94 <= 2)
            {
              *(v86 + 20) |= (v94 << 10) + 1024;
            }

            v76 = *v75;
          }

          if ((v76 & 0x3000) != 0)
          {
            v84 = (2 * v87[3]) | 1;
            v96 = *v87 + 1;
            v97 = vorr_s8(vadd_s32(*(v87 + 1), *(v87 + 1)), 1);
            v98 = v84;
            v92 = 0;
            v93 = 0;
            v94 = 1;
            v95 = 0;
            if (*v90 != 2)
            {
              goto LABEL_160;
            }

            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v90, &v96, &v92);
            if (EntryV2 != -1)
            {
              goto LABEL_159;
            }

            if (v94 <= 2)
            {
              *(v86 + 20) |= (v94 << 12) + 4096;
            }

            v76 = *v75;
          }

          if (v76 < 0x4000)
          {
            goto LABEL_149;
          }

          v85 = (2 * v87[3]) | 1;
          v96 = *v87 + 1;
          v97 = *&vadd_s32(*(v87 + 1), *(v87 + 1)) | 0x100000001;
          v98 = v85;
          v92 = 0;
          v93 = 0;
          v94 = 1;
          v95 = 0;
          if (*v90 == 2)
          {
            EntryV2 = geo::c3mm::C3mmArea::getEntryV2(v90, &v96, &v92);
            if (EntryV2 == -1)
            {
              if (v94 <= 2)
              {
                *(v86 + 20) |= (v94 << 14) + 0x4000;
              }

              goto LABEL_149;
            }

            goto LABEL_159;
          }

          goto LABEL_160;
        }
      }

LABEL_150:
      if (v99 != v101)
      {
        free(v99);
      }

      v24 = v89;
    }
  }

  if (v24)
  {
    if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      (v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  return EntryV2 | (v11 << 32);
}

void sub_1B337EFA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, void *a23)
{
  if (a21 != a23)
  {
    free(a21);
  }

  if (a13)
  {
    if (!atomic_fetch_add(&a13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      (a13->__on_zero_shared)(a13);
      std::__shared_weak_count::__release_weak(a13);
    }
  }

  _Unwind_Resume(exception_object);
}

void geo::c3mm::C3mmArea::getHeightIndices(uint64_t a1, unsigned int *a2)
{
  if (*a1 != 2)
  {
    return;
  }

  v2 = *a2;
  v3 = *(a1 + 120);
  v4 = *(a1 + 128);
  if (v3 == v4)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if (v2)
    {
      return;
    }
  }

  else
  {
    v5 = *(a1 + 120);
    do
    {
      v6 = v5[2];
      if (v6 >= v2)
      {
        goto LABEL_9;
      }

      v5 += 3;
    }

    while (v5 != v4);
    v6 = 0;
LABEL_9:
    while (v2 > v3[2])
    {
      v3 += 3;
      if (v3 == v4)
      {
        v7 = 0;
        v8 = 0;
        v9 = -1;
        if (v2 > v6)
        {
          return;
        }

        goto LABEL_15;
      }
    }

    v9 = *v3;
    v8 = a2[1] >> (v2 - *v3);
    v7 = a2[2] >> (v2 - *v3);
    if (v2 > v6)
    {
      return;
    }
  }

LABEL_15:
  std::recursive_mutex::lock((a1 + 176));
  v11 = *(a1 + 160);
  if (!v11)
  {
LABEL_30:

    std::recursive_mutex::unlock((a1 + 176));
    return;
  }

  v12 = (a1 + 160);
  do
  {
    v13 = *(v11 + 8);
    if (v13 < v9)
    {
LABEL_17:
      ++v11;
      goto LABEL_18;
    }

    if (v9 < v13)
    {
      goto LABEL_21;
    }

    v14 = *(v11 + 9);
    if (v14 < v8)
    {
      goto LABEL_17;
    }

    if (v8 < v14)
    {
LABEL_21:
      v12 = v11;
    }

    else
    {
      v15 = *(v11 + 10);
      v16 = v15 >= v7;
      v17 = v15 < v7;
      if (v16)
      {
        v12 = v11;
      }

      v11 += v17;
    }

LABEL_18:
    v11 = *v11;
  }

  while (v11);
  if (v12 == (a1 + 160))
  {
    goto LABEL_30;
  }

  v18 = *(v12 + 8);
  if (v9 < v18)
  {
    goto LABEL_30;
  }

  if (v18 >= v9)
  {
    v22 = *(v12 + 9);
    if (v8 < v22 || v22 >= v8 && v7 < *(v12 + 10))
    {
      goto LABEL_30;
    }
  }

  v20 = v12[6];
  v19 = v12[7];
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  std::recursive_mutex::unlock((a1 + 176));
  if (v20)
  {
    if (v20[4] != v20[5])
    {
      v21 = v20[1];
      if (v21 != *v20)
      {
        if (0xAAAAAAAAAAAAAAABLL * ((v21 - *v20) >> 3) < 0xAAAAAAAAAAAAAABLL)
        {
          operator new();
        }

        std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
      }
    }
  }

  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v19->__on_zero_shared)(v19);

    std::__shared_weak_count::__release_weak(v19);
  }
}

void sub_1B337F780(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  if (v20)
  {
    operator delete(v20);
    v22 = a20;
    if (!a20)
    {
LABEL_3:
      if (!a10)
      {
        goto LABEL_9;
      }

      goto LABEL_7;
    }
  }

  else
  {
    v22 = a20;
    if (!a20)
    {
      goto LABEL_3;
    }
  }

  operator delete(v22);
  if (!a10)
  {
    goto LABEL_9;
  }

LABEL_7:
  if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (a10->__on_zero_shared)(a10);
    std::__shared_weak_count::__release_weak(a10);
  }

LABEL_9:
  _Unwind_Resume(exception_object);
}

void std::vector<geo::c3mm::C3mmRoot>::__append(uint64_t a1, unint64_t a2)
{
  v3 = *(a1 + 8);
  v4 = *(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v3) >> 3) >= a2)
  {
    if (a2)
    {
      v9 = &v3[3 * a2];
      do
      {
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0x200000000;
        v3 += 3;
      }

      while (v3 != v9);
      v3 = v9;
    }

    *(a1 + 8) = v3;
  }

  else
  {
    v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
    v6 = v5 + a2;
    if (v5 + a2 > 0xAAAAAAAAAAAAAAALL)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v7 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
    if (2 * v7 > v6)
    {
      v6 = 2 * v7;
    }

    if (v7 >= 0x555555555555555)
    {
      v8 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v8 = v6;
    }

    if (v8)
    {
      if (v8 <= 0xAAAAAAAAAAAAAAALL)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v10 = 24 * v5;
    v11 = 24 * v5 + 24 * a2;
    v12 = 24 * v5;
    do
    {
      *v12 = 0;
      *(v12 + 8) = 0;
      *(v12 + 16) = 0x200000000;
      v12 += 24;
    }

    while (v12 != v11);
    v13 = *a1;
    v14 = *(a1 + 8) - *a1;
    v15 = v10 - v14;
    memcpy((v10 - v14), *a1, v14);
    *a1 = v15;
    *(a1 + 8) = v11;
    *(a1 + 16) = 0;
    if (v13)
    {

      operator delete(v13);
    }
  }
}

void std::vector<unsigned int>::push_back[abi:ne200100](uint64_t a1, _DWORD *a2)
{
  v4 = *(a1 + 8);
  v3 = *(a1 + 16);
  if (v4 >= v3)
  {
    v6 = *a1;
    v7 = v4 - *a1;
    v8 = v7 >> 2;
    v9 = (v7 >> 2) + 1;
    if (v9 >> 62)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v10 = v3 - v6;
    if (v10 >> 1 > v9)
    {
      v9 = v10 >> 1;
    }

    if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
    {
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v9;
    }

    if (v11)
    {
      if (!(v11 >> 62))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    *(4 * v8) = *a2;
    v5 = 4 * v8 + 4;
    memcpy(0, v6, v7);
    *a1 = 0;
    *(a1 + 8) = v5;
    *(a1 + 16) = 0;
    if (v6)
    {
      operator delete(v6);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = (v4 + 1);
  }

  *(a1 + 8) = v5;
}

void geo::c3mm::C3mmArea::insertFile(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  std::recursive_mutex::lock((a1 + 176));
  v6 = *a2;
  v7 = a2[1];
  v8 = a2[2];
  v9 = *(a3 + 8);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  v10 = *(a1 + 160);
  if (!v10)
  {
LABEL_17:
    operator new();
  }

  while (1)
  {
    while (1)
    {
      v11 = v10;
      v12 = *(v10 + 8);
      if (v6 < v12)
      {
        goto LABEL_5;
      }

      if (v12 >= v6)
      {
        break;
      }

LABEL_8:
      v10 = v11[1];
      if (!v10)
      {
        goto LABEL_17;
      }
    }

    v13 = *(v11 + 9);
    if (v7 >= v13)
    {
      if (v13 < v7)
      {
        goto LABEL_8;
      }

      v14 = *(v11 + 10);
      if (v8 >= v14)
      {
        break;
      }
    }

LABEL_5:
    v10 = *v11;
    if (!*v11)
    {
      goto LABEL_17;
    }
  }

  if (v14 < v8)
  {
    goto LABEL_8;
  }

  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

  std::recursive_mutex::unlock((a1 + 176));
}

void sub_1B337FCA0(_Unwind_Exception *a1)
{
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      (v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  std::recursive_mutex::unlock((v1 + 176));
  _Unwind_Resume(a1);
}

uint64_t geo::c3mm::loadFromChunk(uint64_t a1, unint64_t a2, uint64_t a3, int a4, int8x16_t a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10, double a11, int8x16_t a12)
{
  if (!a2)
  {
    operator new();
  }

  if (a2 < 6 || *a1 != 67 || *(a1 + 1) != 51 || *(a1 + 2) != 77 || *(a1 + 3) != 77)
  {
    v16 = "Invalid c3mm file!";
    goto LABEL_12;
  }

  if (*(a1 + 4) != 2)
  {
    return printf("Unsupported C3MM version: %i\n");
  }

  if (a2 <= 0xB)
  {
    return printf("Invalid c3mm file, size (%zu) is less than header size (%i)\n, ");
  }

  v17 = *(a1 + 6);
  *a3 = 2;
  *(a3 + 4) = v17;
  v19 = *(a3 + 120);
  v18 = *(a3 + 128);
  if (v19 != v18)
  {
    goto LABEL_17;
  }

  v69 = *(a1 + 8);
  if (!v69)
  {
LABEL_82:
    if (v18 != v19)
    {
LABEL_17:
      while (v19 != v18)
      {
        if (*v19 == a4)
        {
          goto LABEL_21;
        }

        v19 += 3;
      }

      puts("No meta level for file index");
LABEL_21:
      operator new();
    }

    goto LABEL_89;
  }

  v20 = 0;
  __dst = (a1 - 4);
  v21 = 0uLL;
  v22 = xmmword_1B33B24D0;
  v23 = xmmword_1B33B24E0;
  v24 = 12;
  v70 = a4;
  while (1)
  {
    if (v24 + 1 > a2)
    {
      v65 = "type";
      goto LABEL_88;
    }

    v25 = v24 + 5;
    if (v24 + 5 > a2)
    {
      v65 = "length";
      goto LABEL_88;
    }

    if (v24 + 6 > a2)
    {
      v65 = "compression";
      goto LABEL_88;
    }

    v26 = v24 + 10;
    if (v24 + 10 > a2)
    {
      break;
    }

    v27 = (a1 + v24);
    v28 = *&__dst[v25];
    v29 = *(a1 + v24);
    v30 = *&__dst[v26];
    if (*(a1 + v25) != 1)
    {
      goto LABEL_31;
    }

    v71 = a10;
    v73 = v21;
    v75 = a12;
    if (v30)
    {
      operator new();
    }

    if (lzma_auto_decoder())
    {
      v40 = 0;
      v24 = v26;
      a4 = v70;
    }

    else
    {
      v67 = lzma_code();
      lzma_end();
      v27 = 0;
      a4 = v70;
      a10 = v71;
      v21 = v73;
      a12 = v75;
      v23 = xmmword_1B33B24E0;
      v22 = xmmword_1B33B24D0;
      if (v67 <= 1)
      {
LABEL_31:
        if (v29 != 4)
        {
          goto LABEL_72;
        }

        if (v30)
        {
          v31 = *v27;
          v32 = *(a3 + 120);
          v33 = *(a3 + 128);
          v34 = 0xAAAAAAAAAAAAAAABLL * (&v33[-v32] >> 2);
          v35 = v31 - v34;
          if (v31 <= v34)
          {
            if (v31 < v34)
            {
              v42 = (v32 + 12 * *v27);
              goto LABEL_50;
            }
          }

          else
          {
            v36 = *(a3 + 136);
            v72 = a10;
            v74 = v21;
            v76 = a12;
            v66 = v27;
            if (0xAAAAAAAAAAAAAAABLL * ((v36 - v33) >> 2) < v35)
            {
              v37 = 0xAAAAAAAAAAAAAAABLL * ((v36 - v32) >> 2);
              v38 = 2 * v37;
              if (2 * v37 <= v31)
              {
                v38 = *v27;
              }

              if (v37 >= 0xAAAAAAAAAAAAAAALL)
              {
                v39 = 0x1555555555555555;
              }

              else
              {
                v39 = v38;
              }

              if (v39 <= 0x1555555555555555)
              {
                operator new();
              }

              std::__throw_bad_array_new_length[abi:ne200100]();
            }

            v43 = 12 * ((12 * v35 - 12) / 0xC) + 12;
            v44 = *v27;
            bzero(v33, v43);
            v31 = v44;
            v27 = v66;
            v23 = xmmword_1B33B24E0;
            v22 = xmmword_1B33B24D0;
            a10 = v72;
            v21 = v74;
            a12 = v76;
            a4 = v70;
            v42 = &v33[v43];
LABEL_50:
            *(a3 + 128) = v42;
          }

          if (!v31)
          {
LABEL_72:
            v71 = a10;
            v73 = v21;
            v75 = a12;
            if (v26 + v28 >= a2)
            {
              v24 = a2;
            }

            else
            {
              v24 = v26 + v28;
            }

            v40 = 1;
            goto LABEL_79;
          }

          v45 = *(a3 + 120);
          v46 = v30 >> 1;
          v47 = 2;
          if (v30 > 2)
          {
            v47 = v30;
          }

          v48 = (v47 - 1) >> 1;
          if (v48 >= v46)
          {
            v48 = v30 >> 1;
          }

          if (v48 >= v31 - 1)
          {
            v49 = v31 - 1;
          }

          else
          {
            v49 = v48;
          }

          if (v49 > 7 && ((v50 = (v27 + 1), v45 >= &v27[2 * v49 + 3]) || v50 >= v45 + 12 * v49 + 12))
          {
            v53 = 8;
            if (((v49 + 1) & 7) != 0)
            {
              v53 = (v49 + 1) & 7;
            }

            v51 = v49 + 1 - v53;
            v54 = ~v49 + v53;
            v55 = *(a3 + 120);
            do
            {
              a5 = vld2_s8(v50);
              v50 += 16;
              a10 = vqtbl1q_s8(a5, v23);
              a12 = vqtbl1q_s8(a6, v23);
              v56 = v55 + 24;
              vst3q_f32(v55, *a10.i8);
              v57 = v55 + 12;
              v78.val[0] = vqtbl1q_s8(a5, v22);
              v78.val[2] = vqtbl1q_s8(a6, v22);
              v78.val[1] = v21;
              vst3q_f32(v57, v78);
              v55 = v56;
              v54 += 8;
            }

            while (v54);
            v52 = (2 * v51) | 1;
          }

          else
          {
            v51 = 0;
            v52 = 1;
          }

          v58 = v31 - v51;
          v59 = v52 + 1;
          v60 = &v27[v59];
          v61 = (v45 + 12 * v51 + 8);
          v62 = v46 - v51;
          while (1)
          {
            if (!v62)
            {
              v71 = a10;
              v73 = v21;
              v75 = a12;
              v41 = "level";
              goto LABEL_78;
            }

            if (v59 + 1 > v30)
            {
              break;
            }

            v63 = *(v60 - 1);
            v64 = *v60;
            v60 += 2;
            v59 += 2;
            *(v61 - 1) = v63;
            *v61 = v64;
            v61 += 3;
            --v62;
            if (!--v58)
            {
              goto LABEL_72;
            }
          }

          v71 = a10;
          v73 = v21;
          v75 = a12;
          v41 = "maxLevel";
        }

        else
        {
          v71 = a10;
          v73 = v21;
          v75 = a12;
          v41 = "numLevels";
        }

LABEL_78:
        printf("Failed to read C3mm file - %s", v41);
        a4 = v70;
        v40 = 0;
        v24 = v26;
        goto LABEL_79;
      }

      v40 = 0;
      v24 = v26;
    }

LABEL_79:
    if ((v40 & 1) == 0)
    {
      goto LABEL_89;
    }

    ++v20;
    a10 = v71;
    v21 = v73;
    a12 = v75;
    v23 = xmmword_1B33B24E0;
    v22 = xmmword_1B33B24D0;
    if (v20 == v69)
    {
      v19 = *(a3 + 120);
      v18 = *(a3 + 128);
      goto LABEL_82;
    }
  }

  v65 = "uncomressedLength";
LABEL_88:
  printf("Failed to read C3mm file - %s", v65);
LABEL_89:
  v16 = "Meta levels are not defined";
LABEL_12:

  return puts(v16);
}

void sub_1B33821A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, std::__shared_weak_count *a20, uint64_t a21, atomic_ullong *a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, std::__shared_weak_count *a42, void *a43, void **a44, void **a45, uint64_t a46, unint64_t a47, uint64_t a48)
{
  operator delete(__p);
  operator delete(a18);
  if (!atomic_fetch_add(a22, 0xFFFFFFFFFFFFFFFFLL))
  {
    (a20->__on_zero_shared)(a20);
    std::__shared_weak_count::__release_weak(a20);
  }

  if (!atomic_fetch_add(a22, 0xFFFFFFFFFFFFFFFFLL))
  {
    (a20->__on_zero_shared)(a20);
    std::__shared_weak_count::__release_weak(a20);
  }

  v49 = a44;
  v50 = a45;
  if (a45 == a44)
  {
    v51 = a44;
  }

  else
  {
    v52 = &a44[a47 / 0xAA];
    v53 = *v52 + 24 * a47 + -4080 * (a47 / 0xAA);
    v54 = a44[(a48 + a47) / 0xAA] + 24 * a48 + 24 * a47 + -4080 * ((a48 + a47) / 0xAA);
    v51 = a45;
    if (v53 != v54)
    {
      do
      {
        v55 = *(v53 + 8);
        if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          (v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }

        v53 += 24;
        if (v53 - *v52 == 4080)
        {
          v56 = v52[1];
          ++v52;
          v53 = v56;
        }
      }

      while (v53 != v54);
      v49 = a44;
      v50 = a45;
      v51 = a45;
    }
  }

  v57 = (v51 - v49) >> 3;
  if (v57 >= 3)
  {
    do
    {
      operator delete(*v49);
      v50 = a45;
      v49 = a44 + 1;
      a44 = v49;
      v58 = a45 - v49;
    }

    while (v58 > 2);
  }

  while (v49 != v50)
  {
    v59 = *v49++;
    operator delete(v59);
  }

  if (a43)
  {
    operator delete(a43);
  }

  if (a27)
  {
    operator delete(a27);
  }

  if (a42)
  {
    if (!atomic_fetch_add(&a42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      (a42->__on_zero_shared)(a42);
      std::__shared_weak_count::__release_weak(a42);
      _Unwind_Resume(a1);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t anonymous namespace::propagateBounds(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, float a7, float a8)
{
  LODWORD(v10) = a4;
  v13 = a2 + 16 * a4;
  v15 = *(v13 + 4);
  v14 = *(v13 + 8);
  for (i = (a3 + 1); ; i = (i + 1))
  {
    v19 = (a2 + 16 * v10);
    v20 = v14 - v15;
    v10 = (v10 + 1);
    v21 = (v14 - v15) * a7;
    v22 = *v19;
    if (i >= a1)
    {
      break;
    }

    if (v22)
    {
      LOBYTE(v20) = *(a5 + a6);
      LOBYTE(a8) = *(a5 + (a6 + 1));
      v23 = a2 + 16 * v10;
      *(v23 + 4) = v15 + (v21 * LODWORD(v20));
      *(v23 + 8) = v14 - (v21 * LODWORD(a8));
      v24 = *v19;
      if ((*v19 & 4) != 0)
      {
        if (v10)
        {
          v25 = *(a2 + 16 * v10 + 12);
        }

        else
        {
          v25 = 0;
        }

LABEL_25:
        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v26 = a2 + 16 * v25;
        *(v26 + 4) = v15 + (v21 * LODWORD(v20));
        *(v26 + 8) = v14 - (v21 * LODWORD(a8));
        v24 = *v19;
        if ((*v19 & 0x10) != 0)
        {
          goto LABEL_26;
        }

LABEL_15:
        if ((v24 & 0x40) == 0)
        {
          goto LABEL_16;
        }

LABEL_30:
        if (v25)
        {
          v25 = *(a2 + 16 * v25 + 12);
        }

        else
        {
LABEL_32:
          v25 = v10;
        }

        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v28 = a2 + 16 * v25;
        *(v28 + 4) = v15 + (v21 * LODWORD(v20));
        *(v28 + 8) = v14 - (v21 * LODWORD(a8));
        v24 = *v19;
        if ((*v19 & 0x100) != 0)
        {
          goto LABEL_34;
        }

LABEL_17:
        if ((v24 & 0x400) == 0)
        {
          goto LABEL_18;
        }

LABEL_38:
        if (v25)
        {
          v25 = *(a2 + 16 * v25 + 12);
        }

        else
        {
LABEL_40:
          v25 = v10;
        }

        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v30 = a2 + 16 * v25;
        *(v30 + 4) = v15 + (v21 * LODWORD(v20));
        *(v30 + 8) = v14 - (v21 * LODWORD(a8));
        v24 = *v19;
        if ((*v19 & 0x1000) != 0)
        {
          goto LABEL_42;
        }

LABEL_19:
        if ((v24 & 0x4000) == 0)
        {
          return a6;
        }
      }

      else
      {
        LODWORD(v25) = v10;
        if ((v24 & 0x10) == 0)
        {
          goto LABEL_15;
        }

LABEL_26:
        if (v25)
        {
          v25 = *(a2 + 16 * v25 + 12);
        }

        else
        {
LABEL_28:
          v25 = v10;
        }

        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v27 = a2 + 16 * v25;
        *(v27 + 4) = v15 + (v21 * LODWORD(v20));
        *(v27 + 8) = v14 - (v21 * LODWORD(a8));
        v24 = *v19;
        if ((*v19 & 0x40) != 0)
        {
          goto LABEL_30;
        }

LABEL_16:
        if ((v24 & 0x100) == 0)
        {
          goto LABEL_17;
        }

LABEL_34:
        if (v25)
        {
          v25 = *(a2 + 16 * v25 + 12);
        }

        else
        {
LABEL_36:
          v25 = v10;
        }

        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v29 = a2 + 16 * v25;
        *(v29 + 4) = v15 + (v21 * LODWORD(v20));
        *(v29 + 8) = v14 - (v21 * LODWORD(a8));
        v24 = *v19;
        if ((*v19 & 0x400) != 0)
        {
          goto LABEL_38;
        }

LABEL_18:
        if ((v24 & 0x1000) == 0)
        {
          goto LABEL_19;
        }

LABEL_42:
        if (v25)
        {
          v25 = *(a2 + 16 * v25 + 12);
        }

        else
        {
LABEL_44:
          v25 = v10;
        }

        LOBYTE(v20) = *(a5 + a6);
        LOBYTE(a8) = *(a5 + (a6 + 1));
        v31 = a2 + 16 * v25;
        *(v31 + 4) = v15 + (v21 * LODWORD(v20));
        *(v31 + 8) = v14 - (v21 * LODWORD(a8));
        if ((*v19 & 0x4000) == 0)
        {
          return a6;
        }
      }

      if (v25)
      {
        LODWORD(v10) = *(a2 + 16 * v25 + 12);
      }

      goto LABEL_3;
    }

    if ((v22 & 4) != 0)
    {
      v25 = v10;
      goto LABEL_25;
    }

    if ((v22 & 0x10) != 0)
    {
      goto LABEL_28;
    }

    if ((v22 & 0x40) != 0)
    {
      goto LABEL_32;
    }

    if ((*v19 & 0x100) != 0)
    {
      goto LABEL_36;
    }

    if ((*v19 & 0x400) != 0)
    {
      goto LABEL_40;
    }

    if ((*v19 & 0x1000) != 0)
    {
      goto LABEL_44;
    }

    if ((*v19 & 0x4000) == 0)
    {
      return a6;
    }

LABEL_3:
    LOBYTE(v20) = *(a5 + a6);
    v17 = a6 + 1;
    a6 = (a6 + 2);
    LOBYTE(a8) = *(a5 + v17);
    a8 = LODWORD(a8);
    v15 = v15 + (v21 * LODWORD(v20));
    v14 = v14 - (v21 * a8);
    v18 = a2 + 16 * v10;
    *(v18 + 4) = v15;
    *(v18 + 8) = v14;
  }

  if (v22)
  {
    v32 = a6 + 1;
    LOBYTE(v20) = *(a5 + a6);
    a6 = (a6 + 2);
    LOBYTE(a8) = *(a5 + v32);
    v20 = v15 + (v21 * LODWORD(v20));
    a8 = v14 - (v21 * LODWORD(a8));
    v33 = a2 + 16 * v10;
    *(v33 + 4) = v20;
    *(v33 + 8) = a8;
    if ((v22 & 4) == 0)
    {
      v34 = v10;
      if ((v22 & 0x10) != 0)
      {
        goto LABEL_70;
      }

      goto LABEL_59;
    }

    if (v10)
    {
      v34 = *(a2 + 16 * v10 + 12);
    }

    else
    {
      v34 = 0;
    }

LABEL_69:
    v35 = a6 + 1;
    LOBYTE(v20) = *(a5 + a6);
    a6 = (a6 + 2);
    LOBYTE(a8) = *(a5 + v35);
    v20 = v15 + (v21 * LODWORD(v20));
    a8 = v14 - (v21 * LODWORD(a8));
    v36 = a2 + 16 * v34;
    *(v36 + 4) = v20;
    *(v36 + 8) = a8;
    if ((v22 & 0x10) != 0)
    {
LABEL_70:
      if (v34)
      {
        v34 = *(a2 + 16 * v34 + 12);
        goto LABEL_73;
      }

LABEL_72:
      v34 = v10;
LABEL_73:
      v37 = a6 + 1;
      LOBYTE(v20) = *(a5 + a6);
      a6 = (a6 + 2);
      LOBYTE(a8) = *(a5 + v37);
      v20 = v15 + (v21 * LODWORD(v20));
      a8 = v14 - (v21 * LODWORD(a8));
      v38 = a2 + 16 * v34;
      *(v38 + 4) = v20;
      *(v38 + 8) = a8;
      if ((v22 & 0x40) != 0)
      {
LABEL_74:
        if (v34)
        {
          v34 = *(a2 + 16 * v34 + 12);
          goto LABEL_77;
        }

LABEL_76:
        v34 = v10;
LABEL_77:
        v39 = a6 + 1;
        LOBYTE(v20) = *(a5 + a6);
        a6 = (a6 + 2);
        LOBYTE(a8) = *(a5 + v39);
        v20 = v15 + (v21 * LODWORD(v20));
        a8 = v14 - (v21 * LODWORD(a8));
        v40 = a2 + 16 * v34;
        *(v40 + 4) = v20;
        *(v40 + 8) = a8;
        if ((v22 & 0x100) != 0)
        {
LABEL_78:
          if (v34)
          {
            v34 = *(a2 + 16 * v34 + 12);
            goto LABEL_81;
          }

LABEL_80:
          v34 = v10;
LABEL_81:
          v41 = a6 + 1;
          LOBYTE(v20) = *(a5 + a6);
          a6 = (a6 + 2);
          LOBYTE(a8) = *(a5 + v41);
          v20 = v15 + (v21 * LODWORD(v20));
          a8 = v14 - (v21 * LODWORD(a8));
          v42 = a2 + 16 * v34;
          *(v42 + 4) = v20;
          *(v42 + 8) = a8;
          if ((v22 & 0x400) != 0)
          {
LABEL_82:
            if (v34)
            {
              v34 = *(a2 + 16 * v34 + 12);
              goto LABEL_85;
            }

LABEL_84:
            v34 = v10;
LABEL_85:
            v43 = a6 + 1;
            LOBYTE(v20) = *(a5 + a6);
            a6 = (a6 + 2);
            LOBYTE(a8) = *(a5 + v43);
            v20 = v15 + (v21 * LODWORD(v20));
            a8 = v14 - (v21 * LODWORD(a8));
            v44 = a2 + 16 * v34;
            *(v44 + 4) = v20;
            *(v44 + 8) = a8;
            if ((v22 & 0x1000) != 0)
            {
LABEL_86:
              if (v34)
              {
                v34 = *(a2 + 16 * v34 + 12);
                goto LABEL_89;
              }

LABEL_88:
              v34 = v10;
LABEL_89:
              v45 = a6 + 1;
              LOBYTE(v20) = *(a5 + a6);
              a6 = (a6 + 2);
              LOBYTE(a8) = *(a5 + v45);
              v20 = v15 + (v21 * LODWORD(v20));
              a8 = v14 - (v21 * LODWORD(a8));
              v46 = a2 + 16 * v34;
              *(v46 + 4) = v20;
              *(v46 + 8) = a8;
              if ((v22 & 0x4000) == 0)
              {
                return a6;
              }

LABEL_90:
              if (v34)
              {
                LODWORD(v10) = *(a2 + 16 * v34 + 12);
              }

              goto LABEL_92;
            }

LABEL_63:
            if ((v22 & 0x4000) == 0)
            {
              return a6;
            }

            goto LABEL_90;
          }

LABEL_62:
          if ((v22 & 0x1000) != 0)
          {
            goto LABEL_86;
          }

          goto LABEL_63;
        }

LABEL_61:
        if ((v22 & 0x400) != 0)
        {
          goto LABEL_82;
        }

        goto LABEL_62;
      }

LABEL_60:
      if ((v22 & 0x100) != 0)
      {
        goto LABEL_78;
      }

      goto LABEL_61;
    }

LABEL_59:
    if ((v22 & 0x40) != 0)
    {
      goto LABEL_74;
    }

    goto LABEL_60;
  }

  if ((v22 & 4) != 0)
  {
    v34 = v10;
    goto LABEL_69;
  }

  if ((v22 & 0x10) != 0)
  {
    goto LABEL_72;
  }

  if ((v22 & 0x40) != 0)
  {
    goto LABEL_76;
  }

  if ((*v19 & 0x100) != 0)
  {
    goto LABEL_80;
  }

  if ((*v19 & 0x400) != 0)
  {
    goto LABEL_84;
  }

  if ((*v19 & 0x1000) != 0)
  {
    goto LABEL_88;
  }

  if ((*v19 & 0x4000) == 0)
  {
    return a6;
  }

LABEL_92:
  v47 = a6 + 1;
  LOBYTE(v20) = *(a5 + a6);
  a6 = (a6 + 2);
  LOBYTE(a8) = *(a5 + v47);
  v48 = a2 + 16 * v10;
  *(v48 + 4) = v15 + (v21 * LODWORD(v20));
  *(v48 + 8) = v14 - (v21 * LODWORD(a8));
  return a6;
}

void std::vector<std::shared_ptr<geo::c3mm::C3mmObjectTree::Node>>::push_back[abi:ne200100](void **a1, __int128 *a2)
{
  v4 = a1[1];
  v3 = a1[2];
  if (v4 >= v3)
  {
    v6 = (v4 - *a1) >> 4;
    if ((v6 + 1) >> 60)
    {
      std::vector<unsigned char,geo::allocator_adapter<unsigned char,gss::zone_mallocator>>::__throw_length_error[abi:ne200100]();
    }

    v7 = v3 - *a1;
    v8 = v7 >> 3;
    if (v7 >> 3 <= (v6 + 1))
    {
      v8 = v6 + 1;
    }

    if (v7 >= 0x7FFFFFFFFFFFFFF0)
    {
      v9 = 0xFFFFFFFFFFFFFFFLL;
    }

    else
    {
      v9 = v8;
    }

    if (v9)
    {
      if (!(v9 >> 60))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v10 = (16 * v6);
    v11 = *a2;
    *a2 = 0;
    *(a2 + 1) = 0;
    v12 = *a1;
    v13 = a1[1] - *a1;
    v14 = v10 - v13;
    *v10 = v11;
    v5 = v10 + 1;
    memcpy(v14, v12, v13);
    *a1 = v14;
    a1[1] = v5;
    a1[2] = 0;
    if (v12)
    {
      operator delete(v12);
    }
  }

  else
  {
    *v4 = *a2;
    v5 = v4 + 1;
    *a2 = 0;
    *(a2 + 1) = 0;
  }

  a1[1] = v5;
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmObjectTree::Model>::__on_zero_shared(uint64_t a1)
{
  v2 = *(a1 + 64);
  if (v2)
  {
    *(a1 + 72) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmObjectTree::Model>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FD80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *std::__split_buffer<std::pair<std::shared_ptr<geo::c3mm::C3mmObjectTree::Group>,int> *,std::allocator<std::pair<std::shared_ptr<geo::c3mm::C3mmObjectTree::Group>,int> *>>::emplace_back<std::pair<std::shared_ptr<geo::c3mm::C3mmObjectTree::Group>,int> *&>(void *result, void *a2)
{
  v3 = result;
  v4 = result[2];
  if (v4 == result[3])
  {
    v5 = result[1];
    v6 = &v5[-*result];
    if (v5 <= *result)
    {
      v11 = &v4[-*result] >> 2;
      if (v4 == *result)
      {
        v11 = 1;
      }

      if (!(v11 >> 61))
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:ne200100]();
    }

    v7 = ((v6 >> 3) + 1) / 2;
    v8 = ((v6 >> 3) + 1) / -2;
    v9 = &v5[-8 * v7];
    v10 = v4 - v5;
    if (v4 != v5)
    {
      result = memmove(&v5[-8 * v7], v5, v4 - v5);
      v5 = v3[1];
    }

    v4 = &v9[v10];
    v3[1] = &v5[8 * v8];
  }

  *v4 = *a2;
  v3[2] = v4 + 8;
  return result;
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmObjectTree::Group>::__on_zero_shared(uint64_t a1)
{
  v1 = *(a1 + 64);
  if (v1)
  {
    v3 = *(a1 + 72);
    v4 = *(a1 + 64);
    if (v3 != v1)
    {
      do
      {
        v5 = *(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          (v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }

        v3 -= 16;
      }

      while (v3 != v1);
      v4 = *(a1 + 64);
    }

    *(a1 + 72) = v1;

    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmObjectTree::Group>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FD30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t std::__shared_ptr_pointer<geo::c3mm::C3mmObjectTree *,std::shared_ptr<geo::c3mm::C3mmObjectTree>::__shared_ptr_default_delete<geo::c3mm::C3mmObjectTree,geo::c3mm::C3mmObjectTree>,std::allocator<geo::c3mm::C3mmObjectTree>>::__get_deleter(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 8);
  if (v2 != "NSt3__110shared_ptrIN3geo4c3mm14C3mmObjectTreeEE27__shared_ptr_default_deleteIS3_S3_EE")
  {
    if (((v2 & "NSt3__110shared_ptrIN3geo4c3mm14C3mmObjectTreeEE27__shared_ptr_default_deleteIS3_S3_EE" & 0x8000000000000000) != 0) == __OFSUB__(v2, "NSt3__110shared_ptrIN3geo4c3mm14C3mmObjectTreeEE27__shared_ptr_default_deleteIS3_S3_EE"))
    {
      return 0;
    }

    v3 = result;
    v4 = strcmp((v2 & 0x7FFFFFFFFFFFFFFFLL), ("NSt3__110shared_ptrIN3geo4c3mm14C3mmObjectTreeEE27__shared_ptr_default_deleteIS3_S3_EE" & 0x7FFFFFFFFFFFFFFFLL));
    result = v3;
    if (v4)
    {
      return 0;
    }
  }

  return result;
}

uint64_t std::__shared_ptr_pointer<geo::c3mm::C3mmObjectTree *,std::shared_ptr<geo::c3mm::C3mmObjectTree>::__shared_ptr_default_delete<geo::c3mm::C3mmObjectTree,geo::c3mm::C3mmObjectTree>,std::allocator<geo::c3mm::C3mmObjectTree>>::__on_zero_shared(uint64_t result)
{
  v1 = *(result + 24);
  if (v1)
  {
    v2 = *v1;
    if (*v1)
    {
      v3 = v1[1];
      v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          v5 = *(v3 - 1);
          if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            (v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }

          v3 -= 16;
        }

        while (v3 != v2);
        v4 = *v1;
      }

      v1[1] = v2;
      operator delete(v4);
    }

    JUMPOUT(0x1B8C62190);
  }

  return result;
}

void std::__shared_ptr_pointer<geo::c3mm::C3mmObjectTree *,std::shared_ptr<geo::c3mm::C3mmObjectTree>::__shared_ptr_default_delete<geo::c3mm::C3mmObjectTree,geo::c3mm::C3mmObjectTree>,std::allocator<geo::c3mm::C3mmObjectTree>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t anonymous namespace::buildSubTree(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  for (i = (a3 + 1); ; i = (i + 1))
  {
    v7 = a4 + 1;
    v8 = (a2 + 16 * a4);
    v9 = *v8;
    if (a1 == i)
    {
      break;
    }

    v10 = a2 + 16 * v7;
    v11 = (a4 + 1);
    if (v9)
    {
      *(v10 + 12) = 0;
      v9 = *v8;
    }

    if ((v9 & 4) != 0)
    {
      *(v10 + 12) = v11;
      *(a2 + 16 * v11 + 12) = 0;
      v9 = *v8;
      if ((*v8 & 0x10) != 0)
      {
LABEL_7:
        *(a2 + 16 * v11 + 12) = v12;
        *(a2 + 16 * v12 + 12) = 0;
        v9 = *v8;
        if ((*v8 & 0x40) != 0)
        {
          goto LABEL_8;
        }

        goto LABEL_15;
      }
    }

    else
    {
      v12 = v11;
      LODWORD(v11) = v7;
      if ((v9 & 0x10) != 0)
      {
        goto LABEL_7;
      }
    }

    v13 = v12;
    LODWORD(v12) = v11;
    if ((v9 & 0x40) != 0)
    {
LABEL_8:
      *(a2 + 16 * v12 + 12) = v13;
      *(a2 + 16 * v13 + 12) = 0;
      v9 = *v8;
      if ((*v8 & 0x100) != 0)
      {
        goto LABEL_9;
      }

      goto LABEL_16;
    }

LABEL_15:
    v14 = v13;
    LODWORD(v13) = v12;
    if ((v9 & 0x100) != 0)
    {
LABEL_9:
      *(a2 + 16 * v13 + 12) = v14;
      *(a2 + 16 * v14 + 12) = 0;
      v9 = *v8;
      if ((*v8 & 0x400) != 0)
      {
        goto LABEL_10;
      }

      goto LABEL_17;
    }

LABEL_16:
    v15 = v14;
    LODWORD(v14) = v13;
    if ((v9 & 0x400) != 0)
    {
LABEL_10:
      *(a2 + 16 * v14 + 12) = v15;
      *(a2 + 16 * v15 + 12) = 0;
      v9 = *v8;
      if ((*v8 & 0x1000) != 0)
      {
        goto LABEL_11;
      }

      goto LABEL_18;
    }

LABEL_17:
    v16 = v15;
    LODWORD(v15) = v14;
    if ((v9 & 0x1000) != 0)
    {
LABEL_11:
      *(a2 + 16 * v15 + 12) = v16;
      *(a2 + 16 * v16 + 12) = 0;
      if ((*v8 & 0x4000) == 0)
      {
        return a4;
      }

      goto LABEL_19;
    }

LABEL_18:
    a4 = v16;
    LODWORD(v16) = v15;
    if ((v9 & 0x4000) == 0)
    {
      return a4;
    }

LABEL_19:
    *(a2 + 16 * v16 + 12) = a4;
    *(a2 + 16 * a4 + 12) = 0;
  }

  v17 = (a4 + 1);
  if (v9)
  {
    *(a2 + 16 * v7 + 12) = 0;
    v17 = (a4 + 2);
  }

  if ((v9 & 4) != 0)
  {
    *(a2 + 16 * v7 + 12) = v17;
    *(a2 + 16 * v17 + 12) = 0;
    v18 = (v17 + 1);
    if ((v9 & 0x10) == 0)
    {
      goto LABEL_31;
    }

LABEL_24:
    *(a2 + 16 * v17 + 12) = v18;
    *(a2 + 16 * v18 + 12) = 0;
    v19 = (v18 + 1);
    if ((v9 & 0x40) != 0)
    {
      goto LABEL_25;
    }

LABEL_32:
    v20 = v19;
    LODWORD(v19) = v18;
    if ((v9 & 0x100) == 0)
    {
      goto LABEL_33;
    }

LABEL_26:
    *(a2 + 16 * v19 + 12) = v20;
    *(a2 + 16 * v20 + 12) = 0;
    v21 = (v20 + 1);
    if ((v9 & 0x400) != 0)
    {
      goto LABEL_27;
    }

LABEL_34:
    v22 = v21;
    LODWORD(v21) = v20;
    if ((v9 & 0x1000) == 0)
    {
      goto LABEL_35;
    }

LABEL_28:
    *(a2 + 16 * v21 + 12) = v22;
    *(a2 + 16 * v22 + 12) = 0;
    a4 = (v22 + 1);
    if ((v9 & 0x4000) != 0)
    {
LABEL_36:
      *(a2 + 16 * v22 + 12) = a4;
      *(a2 + 16 * a4 + 12) = 0;
      return (a4 + 1);
    }
  }

  else
  {
    v18 = v17;
    LODWORD(v17) = a4 + 1;
    if ((v9 & 0x10) != 0)
    {
      goto LABEL_24;
    }

LABEL_31:
    v19 = v18;
    LODWORD(v18) = v17;
    if ((v9 & 0x40) == 0)
    {
      goto LABEL_32;
    }

LABEL_25:
    *(a2 + 16 * v18 + 12) = v19;
    *(a2 + 16 * v19 + 12) = 0;
    v20 = (v19 + 1);
    if ((v9 & 0x100) != 0)
    {
      goto LABEL_26;
    }

LABEL_33:
    v21 = v20;
    LODWORD(v20) = v19;
    if ((v9 & 0x400) == 0)
    {
      goto LABEL_34;
    }

LABEL_27:
    *(a2 + 16 * v20 + 12) = v21;
    *(a2 + 16 * v21 + 12) = 0;
    v22 = (v21 + 1);
    if ((v9 & 0x1000) != 0)
    {
      goto LABEL_28;
    }

LABEL_35:
    a4 = v22;
    LODWORD(v22) = v21;
    if ((v9 & 0x4000) != 0)
    {
      goto LABEL_36;
    }
  }

  return a4;
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmFile>::__on_zero_shared(void *a1)
{
  v2 = a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }

  v3 = a1[3];
  if (v3)
  {
    a1[4] = v3;

    operator delete(v3);
  }
}

void std::__shared_ptr_emplace<geo::c3mm::C3mmFile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A5FDD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

void *geo::A3DFileCreate(geo *this, const unsigned __int8 *a2)
{
  if (!this)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "No A3D data provided\n";
    v4 = 21;
    goto LABEL_13;
  }

  if (a2 <= 0xD)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "A3D appears to be malformed, there's not enough room for a header\n";
    v4 = 66;
LABEL_13:
    fwrite(v3, v4, 1uLL, v2);
    return 0;
  }

  if (*this != 65 || *(this + 1) != 51 || *(this + 2) != 68)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "Data does not appear to be A3D format.\n";
    v4 = 39;
    goto LABEL_13;
  }

  if (*(this + 3) != 1)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "A3D contains incorrect version for parser.\n";
    v4 = 43;
    goto LABEL_13;
  }

  v5 = *(this + 1);
  v6 = *(this + 2);
  if (__CFADD__(v6, v5))
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "A3D appears to be malformed, it claims its vertices end after more than SIZE_MAX bytes.\n";
    v4 = 88;
    goto LABEL_13;
  }

  if (v6 + v5 > a2)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "A3D appears to be malformed, there aren't enough bytes for all its vertices.\n";
    v4 = 77;
    goto LABEL_13;
  }

  v8 = *(this + 6);
  if (145 * v8 + 14 > a2)
  {
    v2 = *MEMORY[0x1E69E9848];
    v3 = "A3D appears to be malformed, there aren't enough bytes for the sub-mesh headers.\n";
LABEL_20:
    v4 = 81;
    goto LABEL_13;
  }

  if (!v8)
  {
    v15 = v6 + 14;
    v16 = v6 + 14;
    goto LABEL_31;
  }

  v9 = (this + 27);
  v10 = *(this + 6);
  do
  {
    v11 = *(v9 - 13);
    v12 = *(v9 - 9);
    if (__CFADD__(v12, v11))
    {
      v2 = *MEMORY[0x1E69E9848];
      v3 = "A3D appears to be malformed, it claims one of its mesh index sets ends after more than SIZE_MAX bytes.\n";
      v4 = 103;
      goto LABEL_13;
    }

    if (v12 + v11 > a2)
    {
      v2 = *MEMORY[0x1E69E9848];
      v3 = "A3D appears to be malformed, there aren't enough bytes for all its sub mesh indices.\n";
      v4 = 85;
      goto LABEL_13;
    }

    v13 = *v9;
    if (v13)
    {
      v14 = *(v9 - 1);
      if (__CFADD__(v13, v14))
      {
        v2 = *MEMORY[0x1E69E9848];
        v3 = "A3D appears to be malformed, it claims one of its textures ends after more than SIZE_MAX bytes.\n";
        v4 = 96;
        goto LABEL_13;
      }

      if (v14 + v13 > a2)
      {
        v2 = *MEMORY[0x1E69E9848];
        v3 = "A3D appears to be malformed, there aren't enough bytes for one of its textures.\n";
        v4 = 80;
        goto LABEL_13;
      }
    }

    v9 = (v9 + 145);
    --v10;
  }

  while (v10);
  v16 = v6 + 14;
  if (v8 == 1)
  {
    v18 = 0;
    v15 = v16;
LABEL_45:
    v23 = v8 - v18;
    v24 = (this + 145 * v18 + 27);
    do
    {
      v25 = v15 + *(v24 - 9);
      v26 = *v24;
      v24 = (v24 + 145);
      v15 = v25 + v26 + 145;
      --v23;
    }

    while (v23);
    goto LABEL_47;
  }

  v19 = 0;
  v18 = v8 & 0xFFFE;
  v20 = (this + 172);
  v21 = v18;
  v22 = v16;
  do
  {
    v22 += *(v20 - 154) + *(v20 - 145) + 145;
    v19 += *(v20 - 9) + *v20 + 145;
    v20 = (v20 + 290);
    v21 -= 2;
  }

  while (v21);
  v15 = v19 + v22;
  if (v18 != v8)
  {
    goto LABEL_45;
  }

LABEL_47:
  if (v8 == 1)
  {
    v27 = 0;
LABEL_57:
    v34 = v8 - v27;
    v35 = (this + 145 * v27 + 27);
    do
    {
      v36 = v16 + *(v35 - 9);
      v37 = *v35;
      v35 = (v35 + 145);
      v16 = v36 + v37 + 145;
      --v34;
    }

    while (v34);
    goto LABEL_31;
  }

  v31 = 0;
  v27 = v8 & 0xFFFE;
  v32 = (this + 172);
  v33 = v27;
  do
  {
    v16 += *(v32 - 154) + *(v32 - 145) + 145;
    v31 += *(v32 - 9) + *v32 + 145;
    v32 = (v32 + 290);
    v33 -= 2;
  }

  while (v33);
  v16 += v31;
  if (v27 != v8)
  {
    goto LABEL_57;
  }

LABEL_31:
  if (v16 < a2)
  {
    v17 = *(this + v16);
    if (*(this + v16))
    {
      if (v17 > (-2 - v15) / 0x11uLL)
      {
        v2 = *MEMORY[0x1E69E9848];
        v3 = "A3D appears to be malformed, it claims its metadata headers end after more than SIZE_MAX bytes.\n";
        v4 = 96;
        goto LABEL_13;
      }

      if (v15 + 17 * v17 + 1 <= a2)
      {
        v28 = (this + v15 + 6);
        while (*v28 + *(v28 - 1) <= a2)
        {
          v28 = (v28 + 17);
          if (!--v17)
          {
            goto LABEL_52;
          }
        }

        v2 = *MEMORY[0x1E69E9848];
        v3 = "A3D appears to be malformed, there aren't enough bytes for its metadata.\n";
        v4 = 73;
        goto LABEL_13;
      }

      v2 = *MEMORY[0x1E69E9848];
      v3 = "A3D appears to be malformed, there aren't enough bytes for its metadata headers.\n";
      goto LABEL_20;
    }
  }

LABEL_52:
  result = malloc_type_malloc(0x20uLL, 0x1070040A47808ACuLL);
  if (result)
  {
    *result = this;
    result[1] = a2;
    result[2] = 0;
    result[3] = 0;
  }

  return result;
}

void geo::A3DFileDelete(void **this, void *a2)
{
  if (this)
  {
    if (this[3])
    {
      v3 = this;
      free(this[3]);
      this = v3;
      v2 = vars8;
    }

    free(this);
  }
}

unsigned int *geo::A3DGetShadows(unsigned int *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!result)
  {
    return result;
  }

  v5 = result;
  v6 = result[2] + 14;
  v7 = *(result + 6);
  v8 = v6;
  if (*(result + 6))
  {
    if (v7 == 1)
    {
      v9 = 0;
      v8 = result[2] + 14;
LABEL_8:
      v14 = v7 - v9;
      v15 = (result + 145 * v9 + 27);
      do
      {
        v16 = v8 + *(v15 - 9);
        v17 = *v15;
        v15 = (v15 + 145);
        v8 = v16 + v17 + 145;
        --v14;
      }

      while (v14);
      goto LABEL_10;
    }

    v10 = 0;
    v9 = v7 & 0xFFFE;
    v11 = result + 43;
    v12 = v9;
    v13 = result[2] + 14;
    do
    {
      v13 += *(v11 - 154) + *(v11 - 145) + 145;
      v10 += *(v11 - 9) + *v11 + 145;
      v11 = (v11 + 290);
      v12 -= 2;
    }

    while (v12);
    v8 = v10 + v13;
    if (v9 != v7)
    {
      goto LABEL_8;
    }
  }

LABEL_10:
  if (v8 >= a2)
  {
    return result;
  }

  v18 = *(result + v8);
  if (!*(result + v8))
  {
    return result;
  }

  if (!*(result + 6))
  {
    goto LABEL_20;
  }

  if (v7 == 1)
  {
    v19 = 0;
  }

  else
  {
    v20 = 0;
    v19 = v7 & 0xFFFE;
    v21 = result + 43;
    v22 = v19;
    do
    {
      v6 += *(v21 - 154) + *(v21 - 145) + 145;
      v20 += *(v21 - 9) + *v21 + 145;
      v21 = (v21 + 290);
      v22 -= 2;
    }

    while (v22);
    v6 += v20;
    if (v19 == v7)
    {
      goto LABEL_20;
    }
  }

  v23 = v7 - v19;
  v24 = (result + 145 * v19 + 27);
  do
  {
    v25 = v6 + *(v24 - 9);
    v26 = *v24;
    v24 = (v24 + 145);
    v6 = v25 + v26 + 145;
    --v23;
  }

  while (v23);
LABEL_20:
  v27 = v6 + 1;
  v28 = v27 >= a2;
  if (v27 >= a2)
  {
    v29 = 0;
  }

  else
  {
    v29 = result + v27;
  }

  if (!v28)
  {
    v30 = 0;
    v31 = (a4 + 8);
    v32 = (v29 + 5);
    do
    {
      if (!*(v32 - 5))
      {
        result = memcpy((a3 + 8 * v30), v5 + *(v32 - 1), *v32);
        v33 = *v32 >> 3;
        *(v31 - 1) = v30;
        *v31 = v33;
        v30 += v33;
      }

      v31 += 2;
      v32 = (v32 + 17);
      --v18;
    }

    while (v18);
  }

  return result;
}

uint64_t geo::prepareAlignedVertices(geo *this, void *a2)
{
  v2 = *this;
  v3 = *(*this + 8);
  *(this + 2) = v3 >> 5;
  if (v3 < 0x20)
  {
    return 0;
  }

  v6 = *(v2 + 4);
  result = malloc_type_malloc(32 * (v3 >> 5), 0x1000040E0EAB150uLL);
  *(this + 3) = result;
  if (result)
  {
    memcpy(result, (v2 + v6), 32 * *(this + 2));
    return 1;
  }

  return result;
}

uint64_t geo::A3DGetMetadataHeaderCount(geo *this, const unsigned __int8 *a2)
{
  v2 = *(this + 2) + 14;
  v3 = *(this + 6);
  if (!*(this + 6))
  {
    goto LABEL_9;
  }

  if (v3 == 1)
  {
    v4 = 0;
  }

  else
  {
    v5 = 0;
    v4 = v3 & 0xFFFE;
    v6 = (this + 172);
    v7 = v4;
    do
    {
      v2 += *(v6 - 154) + *(v6 - 145) + 145;
      v5 += *(v6 - 9) + *v6 + 145;
      v6 = (v6 + 290);
      v7 -= 2;
    }

    while (v7);
    v2 += v5;
    if (v4 == v3)
    {
      goto LABEL_9;
    }
  }

  v8 = v3 - v4;
  v9 = (this + 145 * v4 + 27);
  do
  {
    v10 = v2 + *(v9 - 9);
    v11 = *v9;
    v9 = (v9 + 145);
    v2 = v10 + v11 + 145;
    --v8;
  }

  while (v8);
LABEL_9:
  if (v2 >= a2)
  {
    return 0;
  }

  else
  {
    return *(this + v2);
  }
}

uint64_t geo::A3DGetMetadataHeaders(geo *this, const unsigned __int8 *a2)
{
  v2 = *(this + 2) + 14;
  v3 = *(this + 6);
  if (!*(this + 6))
  {
    goto LABEL_9;
  }

  if (v3 == 1)
  {
    v4 = 0;
  }

  else
  {
    v5 = 0;
    v4 = v3 & 0xFFFE;
    v6 = (this + 172);
    v7 = v4;
    do
    {
      v2 += *(v6 - 154) + *(v6 - 145) + 145;
      v5 += *(v6 - 9) + *v6 + 145;
      v6 = (v6 + 290);
      v7 -= 2;
    }

    while (v7);
    v2 += v5;
    if (v4 == v3)
    {
      goto LABEL_9;
    }
  }

  v8 = v3 - v4;
  v9 = (this + 145 * v4 + 27);
  do
  {
    v10 = v2 + *(v9 - 9);
    v11 = *v9;
    v9 = (v9 + 145);
    v2 = v10 + v11 + 145;
    --v8;
  }

  while (v8);
LABEL_9:
  v12 = v2 + 1;
  if (v12 >= a2)
  {
    return 0;
  }

  else
  {
    return this + v12;
  }
}

void gdc::component::DataRequestObserver::updateStatusCounts(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  if (a4 != a5)
  {
    v10 = gdc::Registry::storage<gdc::component::DataRequestObserver>(a1);
    v11 = gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::get(v10, a2);
    if (v11)
    {
LABEL_30:
      gdc::component::DataRequestObserver::updatePendingState(v11, a3, a4, a5);
      v38 = gdc::Registry::storage<gdc::component::DataRequestObserver::DidChange>(a1);
      gdc::ComponentStorageWrapper<md::components::QueuedForDestruction<>>::emplace(v38, a2);
      return;
    }

    if (!a5)
    {
      return;
    }

    v42 = 0;
    v40 = 0u;
    v41 = 0u;
    v39 = 0u;
    v12 = gdc::Registry::storage<gdc::component::DataRequestObserver>(a1);
    v43 = a2;
    v13 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v12 + 4, &v43);
    if (v14)
    {
      v16 = v12[11];
      v15 = v12[12];
      if (v16 >= v15)
      {
        v21 = v12[10];
        v22 = 0x4EC4EC4EC4EC4EC5 * ((v16 - v21) >> 3);
        if ((v22 + 1) > 0x276276276276276)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v23 = 0x4EC4EC4EC4EC4EC5 * ((v15 - v21) >> 3);
        v24 = 2 * v23;
        if (2 * v23 <= v22 + 1)
        {
          v24 = v22 + 1;
        }

        if (v23 >= 0x13B13B13B13B13BLL)
        {
          v25 = 0x276276276276276;
        }

        else
        {
          v25 = v24;
        }

        if (v25)
        {
          if (v25 <= 0x276276276276276)
          {
            operator new();
          }

          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v26 = 104 * v22;
        *v26 = 0u;
        *(v26 + 16) = 0u;
        *(v26 + 32) = 0u;
        *(v26 + 48) = v39;
        *(v26 + 56) = 0;
        *(v26 + 64) = 0;
        *(v26 + 72) = 0;
        *(104 * v22 + 0x50) = 0;
        *(v26 + 88) = 0;
        *(v26 + 96) = 0;
        std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__init_with_size[abi:nn200100]<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*,std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*>(104 * v22 + 80, 0, 0, 0);
        v17 = 104 * v22 + 104;
        v27 = v12[10];
        v28 = v12[11];
        v29 = v26 + v27 - v28;
        if (v28 != v27)
        {
          v30 = v12[10];
          v31 = v29;
          do
          {
            v32 = *v30;
            v33 = *(v30 + 16);
            v34 = *(v30 + 32);
            *(v31 + 48) = *(v30 + 48);
            *(v31 + 16) = v33;
            *(v31 + 32) = v34;
            *v31 = v32;
            *(v31 + 64) = 0;
            *(v31 + 72) = 0;
            *(v31 + 56) = 0;
            *(v31 + 56) = *(v30 + 56);
            *(v31 + 72) = *(v30 + 72);
            *(v30 + 56) = 0;
            *(v30 + 64) = 0;
            *(v30 + 72) = 0;
            *(v31 + 80) = 0;
            *(v31 + 88) = 0;
            *(v31 + 96) = 0;
            *(v31 + 80) = *(v30 + 80);
            *(v31 + 96) = *(v30 + 96);
            *(v30 + 80) = 0;
            *(v30 + 88) = 0;
            *(v30 + 96) = 0;
            v30 += 104;
            v31 += 104;
          }

          while (v30 != v28);
          do
          {
            v44 = (v27 + 80);
            std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__destroy_vector::operator()[abi:nn200100](&v44);
            v44 = (v27 + 56);
            std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__destroy_vector::operator()[abi:nn200100](&v44);
            v27 += 104;
          }

          while (v27 != v28);
        }

        v35 = v12[10];
        v12[10] = v29;
        v12[11] = v17;
        v12[12] = 0;
        if (v35)
        {
          operator delete(v35);
        }
      }

      else
      {
        *(v16 + 48) = v39;
        *(v16 + 16) = 0u;
        *(v16 + 32) = 0u;
        *v16 = 0u;
        *(v16 + 56) = 0;
        *(v16 + 64) = 0;
        *(v16 + 72) = 0;
        *(v16 + 80) = 0;
        *(v16 + 88) = 0;
        *(v16 + 96) = 0;
        std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__init_with_size[abi:nn200100]<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*,std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*>(v16 + 80, 0, 0, 0);
        v17 = v16 + 104;
      }

      v12[11] = v17;
      v19 = v12[31];
    }

    else
    {
      v18 = v12[10] + 104 * ((v13 - v12[7]) >> 3);
      *(v18 + 48) = v39;
      *(v18 + 16) = 0u;
      *(v18 + 32) = 0u;
      *v18 = 0u;
      std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__vdeallocate((v18 + 56));
      *(v18 + 56) = 0;
      *(v18 + 64) = 0;
      *(v18 + 72) = 0;
      *(&v39 + 1) = 0;
      v40 = 0uLL;
      std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vdeallocate((v18 + 80));
      *(v18 + 80) = 0;
      *(v18 + 88) = 0;
      *(v18 + 96) = 0;
      v41 = 0uLL;
      v42 = 0;
      v19 = v12[31];
      if (v18 != v12[11])
      {
        for (i = v12[16]; i; i = *i)
        {
          std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(i[6], v19, &v43, 1);
        }

        goto LABEL_29;
      }
    }

    for (j = v12[22]; j; j = *j)
    {
      std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(j[6], v19, &v43, 1);
    }

LABEL_29:
    v44 = &v41;
    std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__destroy_vector::operator()[abi:nn200100](&v44);
    v44 = &v39 + 1;
    std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__destroy_vector::operator()[abi:nn200100](&v44);
    v37 = gdc::Registry::storage<gdc::component::DataRequestObserver>(a1);
    v11 = gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::get(v37, a2);
    goto LABEL_30;
  }
}

uint64_t gdc::Registry::storage<gdc::component::DataRequestObserver>(uint64_t a1)
{
  v3 = 0xB345CED1EE447345;
  v1 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((a1 + 120), 0xB345CED1EE447345);
  if (!v1)
  {
    operator new();
  }

  return v1[3];
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::get(void *a1, unint64_t a2)
{
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  if (a1[8] == Index)
  {
    v4 = a1[11];
  }

  else
  {
    v4 = a1[10] + 104 * ((Index - a1[7]) >> 3);
  }

  if (v4 == a1[11])
  {
    return 0;
  }

  else
  {
    return v4;
  }
}

void std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::clear[abi:nn200100](v2);
    v3 = **a1;

    operator delete(v3);
  }
}

void std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v4 - 2));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void gdc::component::DataRequestObserver::updatePendingState(void *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  v7 = a1[10];
  v8 = a1[11];
  if (v7 == v8)
  {
    goto LABEL_6;
  }

  v9 = a1[10];
  while (__PAIR64__(*(v9 + 1), *v9) != __PAIR64__(WORD1(a2), a2) || *(v9 + 1) != HIDWORD(a2))
  {
    v9 += 32;
    if (v9 == v8)
    {
      goto LABEL_6;
    }
  }

  if (v8 == v9)
  {
LABEL_6:
    memset(v32, 0, sizeof(v32));
    if (v7 == v8)
    {
      goto LABEL_11;
    }

    v9 = v7;
    while (__PAIR64__(*(v9 + 1), *v9) != __PAIR64__(WORD1(a2), a2) || *(v9 + 1) != HIDWORD(a2))
    {
      v9 += 32;
      if (v9 == v8)
      {
        goto LABEL_11;
      }
    }

    if (v8 == v9)
    {
LABEL_11:
      v10 = a1[12];
      if (v8 >= v10)
      {
        v12 = (v8 - v7) >> 5;
        v13 = v12 + 1;
        if ((v12 + 1) >> 59)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v14 = v10 - v7;
        if (v14 >> 4 > v13)
        {
          v13 = v14 >> 4;
        }

        if (v14 >= 0x7FFFFFFFFFFFFFE0)
        {
          v15 = 0x7FFFFFFFFFFFFFFLL;
        }

        else
        {
          v15 = v13;
        }

        if (v15)
        {
          std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>>(v15);
        }

        v16 = (32 * v12);
        *v16 = a2;
        v11 = 32 * v12 + 32;
        std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>::vector[abi:nn200100](v16 + 1, v32);
        v17 = a1[10];
        v18 = a1[11] - v17;
        v19 = v16 - v18;
        memcpy(v16 - v18, v17, v18);
        v20 = a1[10];
        a1[10] = v19;
        a1[11] = v11;
        a1[12] = 0;
        if (v20)
        {
          operator delete(v20);
        }
      }

      else
      {
        *v8 = a2;
        v11 = (v8 + 32);
        std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>::vector[abi:nn200100](v8 + 1, v32);
      }

      a1[11] = v11;
      v9 = (v11 - 32);
    }
  }

  v22 = *(v9 + 2);
  v21 = *(v9 + 3);
  if (v22 >= v21)
  {
    v24 = *(v9 + 1);
    v25 = v22 - v24;
    v26 = (v22 - v24) >> 1;
    if (v26 <= -2)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v27 = v21 - v24;
    if (v27 <= v26 + 1)
    {
      v28 = v26 + 1;
    }

    else
    {
      v28 = v27;
    }

    if (v27 >= 0x7FFFFFFFFFFFFFFELL)
    {
      v29 = 0x7FFFFFFFFFFFFFFFLL;
    }

    else
    {
      v29 = v28;
    }

    if (v29)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<md::MapDataType>>(v29);
    }

    v30 = (2 * v26);
    *v30 = a3;
    v30[1] = a4;
    v23 = 2 * v26 + 2;
    memcpy(0, v24, v25);
    v31 = *(v9 + 1);
    *(v9 + 1) = 0;
    *(v9 + 2) = v23;
    *(v9 + 3) = 0;
    if (v31)
    {
      operator delete(v31);
    }
  }

  else
  {
    *v22 = a3;
    v22[1] = a4;
    v23 = (v22 + 2);
  }

  *(v9 + 2) = v23;
  if (a3)
  {
    --*(a1 + a3 + 8);
  }

  if (a4)
  {
    ++*(a1 + a4 + 8);
  }
}

uint64_t gdc::Registry::storage<gdc::component::DataRequestObserver::DidChange>(uint64_t a1)
{
  v3 = 0x56BA27B543634C5ALL;
  v1 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((a1 + 120), 0x56BA27B543634C5AuLL);
  if (!v1)
  {
    operator new();
  }

  return v1[3];
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::DidChange>::remove(void *a1, unint64_t a2)
{
  v8 = a2;
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  v4 = a1[8];
  if (v4 != Index)
  {
    geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase((a1 + 4), Index);
    --a1[11];
    v5 = a1[28];
    if (v5)
    {
      v6 = a1[31];
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v5[6], v6, &v8, 1);
        v5 = *v5;
      }

      while (v5);
    }
  }

  return v4 != Index;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::DidChange>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v4);

  JUMPOUT(0x1B8C62190);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::DidChange>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v5 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  return a1;
}

void *std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>::vector[abi:nn200100](void *result, void *a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  v2 = a2[1];
  if (v2 != *a2)
  {
    std::vector<md::MapDataType>::__vallocate[abi:nn200100](result, (v2 - *a2) >> 1);
  }

  return result;
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>>(unint64_t a1)
{
  if (!(a1 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::clear[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    v4 = *(i - 24);
    if (v4)
    {
      *(i - 16) = v4;
      operator delete(v4);
    }
  }

  a1[1] = v2;
}

void std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__vdeallocate(void **a1)
{
  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = v3 - 32;
        std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v3 - 2));
        v3 = v5;
      }

      while (v5 != v1);
      v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::clear[abi:nn200100](a1);
    operator delete(*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__init_with_size[abi:nn200100]<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*,std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vallocate[abi:nn200100](result, a4);
  }

  return result;
}

void std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vallocate[abi:nn200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>>(a2);
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__vallocate[abi:nn200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 59))
  {
    std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>(a2);
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__construct_at_end<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>*,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>*>(uint64_t a1, void *a2, void *a3)
{
  v4 = *(a1 + 8);
  if (a2 != a3)
  {
    v6 = a2;
    v7 = (a2 + 2);
    do
    {
      *v4 = *v6;
      v4[3] = 0;
      v4[2] = 0;
      v4[1] = v4 + 2;
      std::multiset<gdc::component::DataRequestStatus>::insert[abi:nn200100]<std::__tree_const_iterator<gdc::component::DataRequestStatus,std::__tree_node<gdc::component::DataRequestStatus,void *> *,long>>((v4 + 1), v6[1], v7);
      v6 += 4;
      v4 += 4;
      v7 += 32;
    }

    while (v6 != a3);
  }

  *(a1 + 8) = v4;
}

void std::multiset<gdc::component::DataRequestStatus>::insert[abi:nn200100]<std::__tree_const_iterator<gdc::component::DataRequestStatus,std::__tree_node<gdc::component::DataRequestStatus,void *> *,long>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    operator new();
  }
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>(unint64_t a1)
{
  if (!(a1 >> 59))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::remove(void *a1, unint64_t a2)
{
  v43 = a2;
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  v4 = Index;
  v5 = a1[8];
  if (v5 != Index)
  {
    v6 = a1[10] + 104 * ((Index - a1[7]) >> 3);
    geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase((a1 + 4), Index);
    v7 = a1[11];
    v8 = *(v7 - 56);
    v9 = *(v7 - 72);
    v10 = *(v7 - 88);
    *v6 = *(v7 - 104);
    *(v6 + 16) = v10;
    *(v6 + 32) = v9;
    *(v6 + 48) = v8;
    if (v6 != v7 - 104)
    {
      v11 = *(v6 + 56);
      v13 = *(v7 - 48);
      v12 = *(v7 - 40);
      v14 = v12 - v13;
      if (*(v6 + 72) - v11 < v12 - v13)
      {
        v15 = v14 >> 5;
        std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__vdeallocate((v6 + 56));
        if (!(v15 >> 59))
        {
          v16 = *(v6 + 72) - *(v6 + 56);
          v17 = v16 >> 4;
          if (v16 >> 4 <= v15)
          {
            v17 = v15;
          }

          if (v16 >= 0x7FFFFFFFFFFFFFE0)
          {
            v18 = 0x7FFFFFFFFFFFFFFLL;
          }

          else
          {
            v18 = v17;
          }

          std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__vallocate[abi:nn200100](v6 + 56, v18);
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v19 = *(v6 + 64) - v11;
      if (v19 >= v14)
      {
        v20 = std::__copy_impl::operator()[abi:nn200100]<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *>(*(v7 - 48), *(v7 - 40), v11);
        v21 = *(v6 + 64);
        if (v21 != v20)
        {
          do
          {
            v22 = v21 - 4;
            std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v21 - 2));
            v21 = v22;
          }

          while (v22 != v20);
        }

        *(v6 + 64) = v20;
      }

      else
      {
        std::__copy_impl::operator()[abi:nn200100]<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *>(*(v7 - 48), (v13 + v19), v11);
        std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__construct_at_end<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>*,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>*>(v6 + 56, (v13 + v19), v12);
      }

      v23 = *(v6 + 80);
      v24 = *(v7 - 24);
      v25 = *(v7 - 16);
      v26 = v25 - v24;
      if (*(v6 + 96) - v23 < (v25 - v24))
      {
        v27 = v26 >> 5;
        std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vdeallocate((v6 + 80));
        if (!(v27 >> 59))
        {
          v28 = *(v6 + 96) - *(v6 + 80);
          v29 = v28 >> 4;
          if (v28 >> 4 <= v27)
          {
            v29 = v27;
          }

          if (v28 >= 0x7FFFFFFFFFFFFFE0)
          {
            v30 = 0x7FFFFFFFFFFFFFFLL;
          }

          else
          {
            v30 = v29;
          }

          std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__vallocate[abi:nn200100](v6 + 80, v30);
        }

        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v31 = *(v6 + 88);
      v32 = v31 - v23;
      if (v31 - v23 >= v26)
      {
        if (v24 != v25)
        {
          do
          {
            std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>::operator=[abi:nn200100](v23, v24);
            v24 += 32;
            v23 += 32;
          }

          while (v24 != v25);
          v31 = *(v6 + 88);
        }

        while (v31 != v23)
        {
          v38 = *(v31 - 3);
          if (v38)
          {
            *(v31 - 2) = v38;
            operator delete(v38);
          }

          v31 -= 32;
        }

        *(v6 + 88) = v23;
      }

      else
      {
        v42 = v5;
        v33 = &v24[v32];
        if (v31 != v23)
        {
          do
          {
            std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>::operator=[abi:nn200100](v23, v24);
            v24 += 32;
            v23 += 32;
            v32 -= 32;
          }

          while (v32);
          v31 = *(v6 + 88);
        }

        v34 = v31;
        if (v33 != v25)
        {
          v34 = v31;
          v35 = v31;
          v36 = v33;
          do
          {
            v37 = *v36;
            v36 += 32;
            *v35 = v37;
            v35 += 32;
            std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>::vector[abi:nn200100](v34 + 1, v33 + 1);
            v34 = v35;
            v33 = v36;
          }

          while (v36 != v25);
        }

        *(v6 + 88) = v34;
        v5 = v42;
      }
    }

    std::vector<gdc::component::DataRequestObserver>::__base_destruct_at_end[abi:nn200100]((a1 + 10), a1[11] - 104);
    v39 = a1[28];
    if (v39)
    {
      v40 = a1[31];
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v39[6], v40, &v43, 1);
        v39 = *v39;
      }

      while (v39);
    }
  }

  return v5 != v4;
}

void std::vector<gdc::component::DataRequestObserver>::__base_destruct_at_end[abi:nn200100](uint64_t a1, uint64_t a2)
{
  for (i = *(a1 + 8); i != a2; i -= 104)
  {
    v5 = (i - 24);
    std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::__destroy_vector::operator()[abi:nn200100](&v5);
    v5 = (i - 48);
    std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  }

  *(a1 + 8) = a2;
}

void *std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>::operator=[abi:nn200100](void *a1, void *a2)
{
  *a1 = *a2;
  if (a1 != a2)
  {
    v3 = a1[1];
    v5 = a2[1];
    v4 = a2[2];
    v6 = v4 - v5;
    v7 = a1[3];
    if (v7 - v3 < v4 - v5)
    {
      v8 = v6 >> 1;
      if (v3)
      {
        a1[2] = v3;
        operator delete(v3);
        v7 = 0;
        a1[1] = 0;
        a1[2] = 0;
        a1[3] = 0;
      }

      if ((v8 & 0x8000000000000000) == 0)
      {
        if (v7 <= v8)
        {
          v9 = v8;
        }

        else
        {
          v9 = v7;
        }

        if (v7 >= 0x7FFFFFFFFFFFFFFELL)
        {
          v10 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v10 = v9;
        }

        std::vector<md::MapDataType>::__vallocate[abi:nn200100]((a1 + 1), v10);
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v11 = a1[2];
    if (v11 - v3 >= v6)
    {
      while (v5 != v4)
      {
        v14 = *v5;
        v5 += 2;
        *v3 = v14;
        v3 += 2;
      }

      a1[2] = v3;
    }

    else
    {
      v12 = &v5[v11 - v3];
      if (v11 != v3)
      {
        do
        {
          v13 = *v5;
          v5 += 2;
          *v3 = v13;
          v3 += 2;
        }

        while (v5 != v12);
      }

      while (v12 != v4)
      {
        v15 = *v12;
        v12 += 2;
        *v11 = v15;
        v11 += 2;
      }

      a1[2] = v11;
    }
  }

  return a1;
}

uint64_t **std::__copy_impl::operator()[abi:nn200100]<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *,std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>> *>(uint64_t **a1, uint64_t **a2, uint64_t **a3)
{
  if (a1 != a2)
  {
    v5 = a1;
    while (1)
    {
      *a3 = *v5;
      if (a3 != v5)
      {
        break;
      }

LABEL_37:
      v5 += 4;
      a3 += 4;
      if (v5 == a2)
      {
        return a3;
      }
    }

    v6 = v5[1];
    v7 = (v5 + 2);
    if (a3[3])
    {
      v9 = a3 + 2;
      v8 = a3[2];
      v10 = a3[1];
      a3[1] = (a3 + 2);
      v8[2] = 0;
      a3[2] = 0;
      a3[3] = 0;
      if (*(v10 + 8))
      {
        v11 = *(v10 + 8);
      }

      else
      {
        v11 = v10;
      }

      if (v11)
      {
        v12 = std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::_DetachedTreeCache::__detach_next(v11);
        if (v6 == v7)
        {
          v14 = v11;
        }

        else
        {
          v13 = v6;
          do
          {
            v14 = v12;
            v15 = *(v13 + 25);
            *(v11 + 25) = v15;
            v16 = *v9;
            v17 = a3 + 2;
            v18 = a3 + 2;
            if (*v9)
            {
              do
              {
                while (1)
                {
                  v17 = v16;
                  if (v15 >= *(v16 + 25))
                  {
                    break;
                  }

                  v16 = *v16;
                  v18 = v17;
                  if (!*v17)
                  {
                    goto LABEL_17;
                  }
                }

                v16 = v16[1];
              }

              while (v16);
              v18 = v17 + 1;
            }

LABEL_17:
            std::__tree<unsigned short>::__insert_node_at(a3 + 1, v17, v18, v11);
            if (v12)
            {
              v12 = std::__tree<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,std::less<unsigned long>,true>,geo::allocator_adapter<std::__value_type<unsigned long,std::shared_ptr<ggl::DeviceData>>,ggl::zone_mallocator>>::_DetachedTreeCache::__detach_next(v12);
            }

            else
            {
              v12 = 0;
            }

            v19 = v13[1];
            if (v19)
            {
              do
              {
                v6 = v19;
                v19 = *v19;
              }

              while (v19);
            }

            else
            {
              do
              {
                v6 = v13[2];
                v20 = *v6 == v13;
                v13 = v6;
              }

              while (!v20);
            }

            if (!v14)
            {
              break;
            }

            v13 = v6;
            v11 = v14;
          }

          while (v6 != v7);
        }

        std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v14);
        if (!v12)
        {
          goto LABEL_35;
        }

        for (i = v12[2]; i; i = i[2])
        {
          v12 = i;
        }

        v21 = v12;
      }

      else
      {
        v21 = 0;
      }

      std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v21);
    }

LABEL_35:
    if (v6 != v7)
    {
      std::__tree<gdc::component::DataRequestStatus>::__emplace_multi<gdc::component::DataRequestStatus const&>();
    }

    goto LABEL_37;
  }

  return a3;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v3 = (a1 + 80);
  std::vector<gdc::component::DataRequestObserver>::__destroy_vector::operator()[abi:nn200100](&v3);
  v2 = *(a1 + 56);
  if (v2)
  {
    *(a1 + 64) = v2;
    operator delete(v2);
  }

  v3 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v3);

  JUMPOUT(0x1B8C62190);
}

void std::vector<gdc::component::DataRequestObserver>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v2 = *a1;
  if (*v2)
  {
    std::vector<gdc::component::DataRequestObserver>::__base_destruct_at_end[abi:nn200100](v2, *v2);
    v3 = **a1;

    operator delete(v3);
  }
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v4 = (a1 + 80);
  std::vector<gdc::component::DataRequestObserver>::__destroy_vector::operator()[abi:nn200100](&v4);
  v2 = *(a1 + 56);
  if (v2)
  {
    *(a1 + 64) = v2;
    operator delete(v2);
  }

  v4 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v4);
  return a1;
}

void gdc::component::DataRequestObserver::processPendingState(gdc::component::DataRequestObserver *this, gdc::Registry *a2)
{
  v3 = gdc::Registry::storage<gdc::component::DataRequestObserver>(this);
  v4 = v3[7];
  v5 = v3[8];
  if (v4 != v5)
  {
    v6 = v3[10];
    do
    {
      v7 = *(v6 + 56);
      v8 = *(v6 + 64);
      if (v7 != v8)
      {
        v9 = *v4;
        do
        {
          isValid = gdc::Registry::isValid(this, v7);
          if (!isValid)
          {
            break;
          }

          v7 += 16;
        }

        while (v7 != v8);
        if (!isValid)
        {
          v11 = gdc::Registry::storage<gdc::component::DataRequestObserver::DidChange>(this);
          gdc::ComponentStorageWrapper<md::components::QueuedForDestruction<>>::emplace(v11, v9);
        }
      }

      v6 += 104;
      ++v4;
    }

    while (v4 != v5);
  }

  v37 = v41;
  v38 = v41;
  v39 = v41;
  v40 = 4;
  v12 = gdc::Registry::storage<gdc::component::DataRequestObserver>(this);
  v13 = gdc::Registry::storage<gdc::component::DataRequestObserver::DidChange>(this);
  v14 = v13;
  v15 = (v13 + 32);
  v17 = v12[7];
  v16 = v12[8];
  if (*(v13 + 64) - *(v13 + 56) >= (v16 - v17))
  {
    v18 = v12 + 4;
  }

  else
  {
    v18 = (v13 + 32);
  }

  if (v12 + 4 == v18)
  {
    v42 = this;
    v43 = &v37;
    if (v17 != v16)
    {
      v19 = v12[10];
      do
      {
        if (*(v14 + 64) != geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(v15, *(v17 + 4)))
        {
          gdc::component::DataRequestObserver::processPendingState(gdc::Registry &)::$_1::operator()(&v42, *v17, v19);
        }

        v19 += 104;
        v17 += 8;
      }

      while (v17 != v16);
    }
  }

  if (v15 == v18)
  {
    v42 = this;
    v43 = &v37;
    v20 = *(v14 + 56);
    for (i = *(v14 + 64); v20 != i; v20 += 8)
    {
      Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(v12 + 4, *(v20 + 4));
      v23 = v12[8];
      if (v23 != Index)
      {
        v24 = *v20;
        v25 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(v12 + 4, HIDWORD(*v20));
        if (v23 == v25)
        {
          v26 = v12[11];
        }

        else
        {
          v26 = (v12[10] + 104 * ((v25 - v12[7]) >> 3));
        }

        gdc::component::DataRequestObserver::processPendingState(gdc::Registry &)::$_1::operator()(&v42, v24, v26);
      }
    }
  }

  v27 = gdc::Registry::storage<gdc::component::DataRequestObserver::DidChange>(this);
  v28 = v27;
  if (v27[29])
  {
    v29 = v27[28];
    if (v29)
    {
      v30 = v27[31];
      v31 = v27[7];
      v32 = (v27[8] - v31) >> 3;
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v29[6], v30, v31, v32);
        v29 = *v29;
      }

      while (v29);
    }
  }

  v28[8] = v28[7];
  v28[11] = v28[10];
  v33 = v37;
  v34 = v38;
  if (v37 != v38)
  {
    do
    {
      v35 = gdc::Registry::storage<gdc::component::DataRequestObserver>(this);
      v36 = *v33++;
      gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver>::remove(v35, v36);
    }

    while (v33 != v34);
    v33 = v37;
  }

  if (v33 != v39)
  {
    free(v33);
  }
}

void gdc::component::DataRequestObserver::processPendingState(gdc::Registry &)::$_1::operator()(uint64_t *a1, unint64_t a2, unsigned __int8 *a3)
{
  v155 = a2;
  v5 = *a1;
  v7 = *(a3 + 7);
  v6 = *(a3 + 8);
  while (v7 != v6)
  {
    if (gdc::Registry::isValid(v5, v7))
    {
      v7 += 32;
    }

    else
    {
      v8 = *(v7 + 8);
      if (v8 != (v7 + 16))
      {
        v9 = *(a3 + 2);
        do
        {
          --*&a3[4 * *(v8 + 25) + 12];
          v10 = v8[1];
          if (v10)
          {
            do
            {
              v11 = v10;
              v10 = *v10;
            }

            while (v10);
          }

          else
          {
            do
            {
              v11 = v8[2];
              v12 = *v11 == v8;
              v8 = v11;
            }

            while (!v12);
          }

          --v9;
          v8 = v11;
        }

        while (v11 != (v7 + 16));
        *(a3 + 2) = v9;
      }

      if (v7 + 32 == v6)
      {
        v20 = v6;
        v6 = v7;
      }

      else
      {
        v13 = v7;
        do
        {
          *v13 = *(v13 + 32);
          v14 = v13 + 16;
          std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v13 + 16));
          v15 = (v13 + 48);
          v16 = *(v13 + 48);
          *(v13 + 8) = *(v13 + 40);
          *(v13 + 16) = v16;
          v17 = *(v13 + 56);
          *(v13 + 24) = v17;
          if (v17)
          {
            *(v16 + 16) = v14;
            *(v13 + 40) = v15;
            *v15 = 0;
            *(v13 + 56) = 0;
          }

          else
          {
            *(v13 + 8) = v14;
          }

          v18 = v13 + 32;
          v19 = v13 + 64;
          v13 += 32;
        }

        while (v19 != v6);
        v20 = *(a3 + 8);
        v6 = v18;
      }

      if (v20 != v6)
      {
        do
        {
          v21 = v20 - 32;
          std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v20 - 16));
          v20 = v21;
        }

        while (v21 != v6);
      }

      *(a3 + 8) = v6;
    }
  }

  v151 = a1;
  v22 = *(a3 + 10);
  *(a3 + 4) = 0;
  *(a3 + 5) = 0;
  *(a3 + 12) = 0;
  v153 = *(a3 + 11);
  if (v22 != v153)
  {
    v23 = a3 + 12;
    do
    {
      if (gdc::Registry::isValid(v5, v22))
      {
        v25 = *(a3 + 7);
        v24 = *(a3 + 8);
        v26 = geo::linear_map<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>,std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>::find(v25, v24, v22);
        if (v24 == v26 && (v26 = geo::linear_map<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>,std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>::find(v25, v24, v22), v24 == v26))
        {
          v157[0] = 0;
          v157[1] = 0;
          v156 = v157;
          v41 = *v22;
          v160[0] = 0;
          v160[1] = 0;
          v158 = v41;
          v159 = v160;
          if (v25 == v24)
          {
            goto LABEL_62;
          }

          v27 = v25;
          while (*v27 != v41 || v27[1] != WORD1(v41) || *(v27 + 1) != HIDWORD(v41))
          {
            v27 += 16;
            if (v27 == v24)
            {
              goto LABEL_62;
            }
          }

          if (v24 == v27)
          {
LABEL_62:
            v42 = *(a3 + 9);
            if (v42 <= v24)
            {
              v44 = (v24 - v25) >> 5;
              v45 = v44 + 1;
              if ((v44 + 1) >> 59)
              {
                std::__throw_bad_array_new_length[abi:nn200100]();
              }

              v46 = v42 - v25;
              if (v46 >> 4 > v45)
              {
                v45 = v46 >> 4;
              }

              if (v46 >= 0x7FFFFFFFFFFFFFE0)
              {
                v47 = 0x7FFFFFFFFFFFFFFLL;
              }

              else
              {
                v47 = v45;
              }

              if (v47)
              {
                std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>(v47);
              }

              v48 = (32 * v44);
              *v48 = v41;
              v48[3] = 0;
              v48[2] = 0;
              v48[1] = (v48 + 2);
              std::multiset<gdc::component::DataRequestStatus>::insert[abi:nn200100]<std::__tree_const_iterator<gdc::component::DataRequestStatus,std::__tree_node<gdc::component::DataRequestStatus,void *> *,long>>((v48 + 1), v159, v160);
              v49 = *(a3 + 7);
              v50 = *(a3 + 8);
              v51 = v48 + v49 - v50;
              if (v50 != v49)
              {
                v52 = 0;
                do
                {
                  v53 = &v51[v52];
                  *v53 = *(v49 + v52);
                  *(v53 + 1) = *(v49 + v52 + 8);
                  v54 = (v49 + v52 + 16);
                  v55 = *v54;
                  *&v51[v52 + 16] = *v54;
                  v56 = &v51[v52 + 16];
                  v57 = *(v49 + v52 + 24);
                  *(v53 + 3) = v57;
                  if (v57)
                  {
                    *(v55 + 16) = v56;
                    *(v49 + v52 + 8) = v54;
                    *v54 = 0;
                    *(v49 + v52 + 24) = 0;
                  }

                  else
                  {
                    *(v53 + 1) = v56;
                  }

                  v52 += 32;
                }

                while (v49 + v52 != v50);
                do
                {
                  std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(*(v49 + 16));
                  v49 += 32;
                }

                while (v49 != v50);
              }

              v58 = *(a3 + 7);
              v43 = v48 + 4;
              *(a3 + 7) = v51;
              *(a3 + 8) = v43;
              *(a3 + 9) = 0;
              if (v58)
              {
                operator delete(v58);
              }
            }

            else
            {
              *v24 = v41;
              *(v24 + 24) = 0;
              *(v24 + 16) = 0;
              *(v24 + 8) = v24 + 16;
              std::multiset<gdc::component::DataRequestStatus>::insert[abi:nn200100]<std::__tree_const_iterator<gdc::component::DataRequestStatus,std::__tree_node<gdc::component::DataRequestStatus,void *> *,long>>(v24 + 8, v159, v160);
              v43 = (v24 + 32);
            }

            *(a3 + 8) = v43;
            v27 = (v43 - 4);
            v59 = v160[0];
          }

          else
          {
            v59 = 0;
          }

          std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v59);
          std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::destroy(v157[0]);
        }

        else
        {
          v27 = v26;
        }

        v29 = *(v22 + 8);
        v28 = *(v22 + 16);
        if (v29 != v28)
        {
          v30 = (v27 + 8);
          do
          {
            LOWORD(v158) = *v29;
            v31 = BYTE1(v158);
            if (v158)
            {
              v32 = *v30;
              if (*v30)
              {
                v33 = v27 + 8;
                v34 = *v30;
                do
                {
                  v35 = *(v34 + 25);
                  v36 = v35 >= v158;
                  v37 = v35 < v158;
                  if (v36)
                  {
                    v33 = v34;
                  }

                  v34 = v34[v37];
                }

                while (v34);
                if (v33 != v30 && *(v33 + 25) <= v158)
                {
                  --*&v23[4 * v158];
                  v38 = *(v33 + 1);
                  v39 = v33;
                  if (v38)
                  {
                    do
                    {
                      v40 = v38;
                      v38 = *v38;
                    }

                    while (v38);
                  }

                  else
                  {
                    do
                    {
                      v40 = *(v39 + 2);
                      v12 = *v40 == v39;
                      v39 = v40;
                    }

                    while (!v12);
                  }

                  if (*(v27 + 1) == v33)
                  {
                    *(v27 + 1) = v40;
                  }

                  --*(v27 + 3);
                  std::__tree_remove[abi:nn200100]<std::__tree_node_base<void *> *>(v32, v33);
                  operator delete(v33);
                  v31 = BYTE1(v158);
                }
              }

              if (v31)
              {
LABEL_51:
                ++*&v23[4 * v31];
                std::__tree<gdc::component::DataRequestStatus>::__emplace_multi<gdc::component::DataRequestStatus const&>();
              }
            }

            else
            {
              ++*(a3 + 2);
              if (v31)
              {
                goto LABEL_51;
              }
            }

            --*(a3 + 2);
            ++v29;
          }

          while (v29 != v28);
        }
      }

      v22 += 32;
    }

    while (v22 != v153);
  }

  std::vector<std::pair<gdc::Entity,std::vector<std::pair<gdc::component::DataRequestStatus,gdc::component::DataRequestStatus>>>>::clear[abi:nn200100](a3 + 10);
  v60 = *(a3 + 5);
  v61 = v60 != 0;
  v62 = *(a3 + 6);
  v147 = v62;
  v148 = *(a3 + 7);
  v63 = v148 != 0;
  v146 = *(a3 + 4);
  v64 = v146 != 0;
  v65 = v62 != 0;
  v66 = *a3;
  v67 = (v61 | v64) ^ 1;
  if (v62)
  {
    v68 = 0;
  }

  else
  {
    v68 = v148 != 0;
  }

  v69 = a3[1];
  v70 = a3[2];
  v149 = a3[3];
  v150 = a3[4];
  *a3 = v61;
  a3[1] = v65;
  a3[2] = v63;
  v71 = v68 & v67;
  a3[3] = v68 & v67;
  a3[4] = v64;
  v72 = v151;
  v154 = v70;
  if (v66 != v61)
  {
    v73 = *v151;
    v156 = 0x5C79F612F310A1D0;
    v74 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((v73 + 120), 0x5C79F612F310A1D0uLL);
    if (!v74)
    {
      operator new();
    }

    v75 = v74[3];
    if (v60)
    {
      v158 = a2;
      v76 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v75 + 4, &v158);
      if (v77)
      {
        v78 = v75[11];
        v79 = v75[12];
        if (v78 >= v79)
        {
          v83 = v75[10];
          v84 = v78 - v83 + 1;
          if (v84 < 0)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          v85 = v79 - v83;
          if (2 * v85 > v84)
          {
            v84 = 2 * v85;
          }

          if (v85 >= 0x3FFFFFFFFFFFFFFFLL)
          {
            v86 = 0x7FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v86 = v84;
          }

          if (v86)
          {
            operator new();
          }

          v80 = v78 - v83 + 1;
          memcpy(0, v83, v78 - v83);
          v75[10] = 0;
          v75[11] = v80;
          v75[12] = 0;
          if (v83)
          {
            operator delete(v83);
          }

          v72 = v151;
        }

        else
        {
          v80 = v78 + 1;
        }

        v75[11] = v80;
        v81 = v75[31];
      }

      else
      {
        v81 = v75[31];
        if (v75[10] + ((v76 - v75[7]) >> 3) != v75[11])
        {
          for (i = v75[16]; i; i = *i)
          {
            std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(i[6], v81, &v158, 1);
          }

          goto LABEL_114;
        }
      }

      for (j = v75[22]; j; j = *j)
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(j[6], v81, &v158, 1);
      }
    }

    else
    {
      gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasInitiated>::remove(v75, a2);
    }

LABEL_114:
    v70 = v154;
  }

  if (v69 == v65)
  {
    goto LABEL_141;
  }

  v88 = *v72;
  v156 = 0x7B96EC200C42ECB2;
  v89 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((v88 + 120), 0x7B96EC200C42ECB2uLL);
  if (!v89)
  {
    operator new();
  }

  v90 = v89[3];
  if (v147)
  {
    v158 = a2;
    v91 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v90 + 4, &v158);
    if (v92)
    {
      v93 = v90[11];
      v94 = v90[12];
      if (v93 >= v94)
      {
        v98 = v90[10];
        v99 = v93 - v98 + 1;
        if (v99 < 0)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v100 = v94 - v98;
        if (2 * v100 > v99)
        {
          v99 = 2 * v100;
        }

        if (v100 >= 0x3FFFFFFFFFFFFFFFLL)
        {
          v101 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v101 = v99;
        }

        if (v101)
        {
          operator new();
        }

        v95 = v93 - v98 + 1;
        memcpy(0, v98, v93 - v98);
        v90[10] = 0;
        v90[11] = v95;
        v90[12] = 0;
        if (v98)
        {
          operator delete(v98);
        }
      }

      else
      {
        v95 = v93 + 1;
      }

      v90[11] = v95;
      v96 = v90[31];
    }

    else
    {
      v96 = v90[31];
      if (v90[10] + ((v91 - v90[7]) >> 3) != v90[11])
      {
        for (k = v90[16]; k; k = *k)
        {
          std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(k[6], v96, &v158, 1);
        }

        goto LABEL_140;
      }
    }

    for (m = v90[22]; m; m = *m)
    {
      std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(m[6], v96, &v158, 1);
    }
  }

  else
  {
    gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasPending>::remove(v90, a2);
  }

LABEL_140:
  v70 = v154;
LABEL_141:
  if (v70 == v63)
  {
    goto LABEL_167;
  }

  v103 = *v72;
  v156 = 0x1BC7FE1311A603CLL;
  v104 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((v103 + 120), 0x1BC7FE1311A603CuLL);
  if (!v104)
  {
    operator new();
  }

  v105 = v104[3];
  if (!v148)
  {
    gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasCompleted>::remove(v105, a2);
    goto LABEL_167;
  }

  v158 = a2;
  v106 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v105 + 4, &v158);
  if (v107)
  {
    v108 = v105[11];
    v109 = v105[12];
    if (v108 >= v109)
    {
      v113 = v105[10];
      v114 = v108 - v113 + 1;
      if (v114 < 0)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v115 = v109 - v113;
      if (2 * v115 > v114)
      {
        v114 = 2 * v115;
      }

      if (v115 >= 0x3FFFFFFFFFFFFFFFLL)
      {
        v116 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v116 = v114;
      }

      if (v116)
      {
        operator new();
      }

      v110 = v108 - v113 + 1;
      memcpy(0, v113, v108 - v113);
      v105[10] = 0;
      v105[11] = v110;
      v105[12] = 0;
      if (v113)
      {
        operator delete(v113);
      }
    }

    else
    {
      v110 = v108 + 1;
    }

    v105[11] = v110;
    v111 = v105[31];
    goto LABEL_165;
  }

  v111 = v105[31];
  if (v105[10] + ((v106 - v105[7]) >> 3) == v105[11])
  {
LABEL_165:
    for (n = v105[22]; n; n = *n)
    {
      std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(n[6], v111, &v158, 1);
    }

    goto LABEL_167;
  }

  for (ii = v105[16]; ii; ii = *ii)
  {
    std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(ii[6], v111, &v158, 1);
  }

LABEL_167:
  if (v149 == v71)
  {
    goto LABEL_190;
  }

  v118 = gdc::Registry::storage<gdc::component::DataRequestObserver::IsCompleted>(*v72);
  v119 = v118;
  if (!v71)
  {
    gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::IsCompleted>::remove(v118, a2);
    goto LABEL_190;
  }

  v158 = a2;
  v120 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v118 + 4, &v158);
  if (v121)
  {
    v122 = v119[11];
    v123 = v119[12];
    if (v122 >= v123)
    {
      v127 = v119[10];
      v128 = v122 - v127 + 1;
      if (v128 < 0)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v129 = v123 - v127;
      if (2 * v129 > v128)
      {
        v128 = 2 * v129;
      }

      if (v129 >= 0x3FFFFFFFFFFFFFFFLL)
      {
        v130 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v130 = v128;
      }

      if (v130)
      {
        operator new();
      }

      v124 = v122 - v127 + 1;
      memcpy(0, v127, v122 - v127);
      v119[10] = 0;
      v119[11] = v124;
      v119[12] = 0;
      if (v127)
      {
        operator delete(v127);
      }
    }

    else
    {
      v124 = v122 + 1;
    }

    v119[11] = v124;
    v125 = v119[31];
    goto LABEL_188;
  }

  v125 = v119[31];
  if (v119[10] + ((v120 - v119[7]) >> 3) == v119[11])
  {
LABEL_188:
    for (jj = v119[22]; jj; jj = *jj)
    {
      std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(jj[6], v125, &v158, 1);
    }

    goto LABEL_190;
  }

  for (kk = v119[16]; kk; kk = *kk)
  {
    std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(kk[6], v125, &v158, 1);
  }

LABEL_190:
  if (v150 == (v146 != 0))
  {
    goto LABEL_213;
  }

  v132 = gdc::Registry::storage<gdc::component::DataRequestObserver::IsFailed>(*v72);
  v133 = v132;
  if (!v146)
  {
    gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::IsFailed>::remove(v132, a2);
    goto LABEL_213;
  }

  v158 = a2;
  v134 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v132 + 4, &v158);
  if (v135)
  {
    v136 = v133[11];
    v137 = v133[12];
    if (v136 >= v137)
    {
      v141 = v133[10];
      v142 = v136 - v141 + 1;
      if (v142 < 0)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v143 = v137 - v141;
      if (2 * v143 > v142)
      {
        v142 = 2 * v143;
      }

      if (v143 >= 0x3FFFFFFFFFFFFFFFLL)
      {
        v144 = 0x7FFFFFFFFFFFFFFFLL;
      }

      else
      {
        v144 = v142;
      }

      if (v144)
      {
        operator new();
      }

      v138 = v136 - v141 + 1;
      memcpy(0, v141, v136 - v141);
      v133[10] = 0;
      v133[11] = v138;
      v133[12] = 0;
      if (v141)
      {
        operator delete(v141);
      }
    }

    else
    {
      v138 = v136 + 1;
    }

    v133[11] = v138;
    v139 = v133[31];
    goto LABEL_211;
  }

  v139 = v133[31];
  if (v133[10] + ((v134 - v133[7]) >> 3) == v133[11])
  {
LABEL_211:
    for (mm = v133[22]; mm; mm = *mm)
    {
      std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(mm[6], v139, &v158, 1);
    }

    goto LABEL_213;
  }

  for (nn = v133[16]; nn; nn = *nn)
  {
    std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(nn[6], v139, &v158, 1);
  }

LABEL_213:
  if (!*(a3 + 2))
  {
    geo::small_vector_base<gdc::Entity>::emplace_back<gdc::Entity&>(v72[1], &v155);
  }
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasInitiated>::remove(void *a1, unint64_t a2)
{
  v8 = a2;
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  v4 = a1[8];
  if (v4 != Index)
  {
    geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase((a1 + 4), Index);
    --a1[11];
    v5 = a1[28];
    if (v5)
    {
      v6 = a1[31];
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v5[6], v6, &v8, 1);
        v5 = *v5;
      }

      while (v5);
    }
  }

  return v4 != Index;
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasPending>::remove(void *a1, unint64_t a2)
{
  v8 = a2;
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  v4 = a1[8];
  if (v4 != Index)
  {
    geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase((a1 + 4), Index);
    --a1[11];
    v5 = a1[28];
    if (v5)
    {
      v6 = a1[31];
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v5[6], v6, &v8, 1);
        v5 = *v5;
      }

      while (v5);
    }
  }

  return v4 != Index;
}

BOOL gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasCompleted>::remove(void *a1, unint64_t a2)
{
  v8 = a2;
  Index = geo::sparse_set<gdc::Entity,unsigned short,256ul>::findIndex(a1 + 4, HIDWORD(a2));
  v4 = a1[8];
  if (v4 != Index)
  {
    geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase((a1 + 4), Index);
    --a1[11];
    v5 = a1[28];
    if (v5)
    {
      v6 = a1[31];
      do
      {
        std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(v5[6], v6, &v8, 1);
        v5 = *v5;
      }

      while (v5);
    }
  }

  return v4 != Index;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasCompleted>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v4);

  JUMPOUT(0x1B8C62190);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasCompleted>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v5 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  return a1;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasPending>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v4);

  JUMPOUT(0x1B8C62190);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasPending>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v5 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  return a1;
}

void gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasInitiated>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v4 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v4);

  JUMPOUT(0x1B8C62190);
}

uint64_t gdc::ComponentStorageWrapper<gdc::component::DataRequestObserver::HasInitiated>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((a1 + 104));
  v2 = *(a1 + 80);
  if (v2)
  {
    *(a1 + 88) = v2;
    operator delete(v2);
  }

  v3 = *(a1 + 56);
  if (v3)
  {
    *(a1 + 64) = v3;
    operator delete(v3);
  }

  v5 = (a1 + 32);
  std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__destroy_vector::operator()[abi:nn200100](&v5);
  return a1;
}

unsigned __int16 *geo::linear_map<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>,std::vector<std::pair<gdc::Entity,std::multiset<gdc::component::DataRequestStatus>>>>::find(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  if (a1 != a2)
  {
    while (*a3 != *a1 || a3[1] != a1[1] || *(a3 + 1) != *(a1 + 1))
    {
      a1 += 16;
      if (a1 == a2)
      {
        return a2;
      }
    }

    return a1;
  }

  return a2;
}

uint64_t gdc::ResourceKey::ResourceKey(uint64_t a1, char a2, __int16 a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  *a1 = a2;
  *(a1 + 2) = a3;
  *(a1 + 4) = 0x80000000;
  gdc::GenericKey::GenericKey((a1 + 8), a4, a5);
  *(a1 + 88) = a6;
  return a1;
}

uint64_t gdc::ResourceKey::ResourceKey(uint64_t a1, char a2, __int16 a3, uint64_t a4, uint64_t a5, int a6)
{
  *a1 = a2;
  *(a1 + 2) = a3;
  *(a1 + 4) = a6;
  *(a1 + 8) = a1 + 40;
  *(a1 + 16) = a1 + 40;
  *(a1 + 24) = a1 + 40;
  *(a1 + 32) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>((a1 + 8), *a4, *(a4 + 8));
  *(a1 + 72) = *(a4 + 64);
  *(a1 + 88) = a5;
  return a1;
}

void gdc::ResourceKey::keyData(gdc::ResourceKey *this, uint64_t a2)
{
  *this = this + 32;
  *(this + 1) = this + 32;
  *(this + 2) = this + 32;
  *(this + 3) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>(this, *(a2 + 8), *(a2 + 16));
  *(this + 8) = *(a2 + 72);
}

void gdc::ResourceKey::keysInt32Str(std::string *this, unsigned __int8 *a2)
{
  gdc::GenericKey::keysInt32Str(&v17, a2 + 1);
  v4 = std::string::append(&v17, " t:", 3uLL);
  v5 = v4->__r_.__value_.__r.__words[2];
  *&v18.__r_.__value_.__l.__data_ = *&v4->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v16, *(a2 + 1));
  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v6 = &v16;
  }

  else
  {
    v6 = v16.__r_.__value_.__r.__words[0];
  }

  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v16.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v16.__r_.__value_.__l.__size_;
  }

  v8 = std::string::append(&v18, v6, size);
  v9 = v8->__r_.__value_.__r.__words[2];
  *&v19.__r_.__value_.__l.__data_ = *&v8->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v19, " kt:", 4uLL);
  v11 = v10->__r_.__value_.__r.__words[2];
  *&v20.__r_.__value_.__l.__data_ = *&v10->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v15, *a2);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v12 = &v15;
  }

  else
  {
    v12 = v15.__r_.__value_.__r.__words[0];
  }

  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v13 = HIBYTE(v15.__r_.__value_.__r.__words[2]);
  }

  else
  {
    v13 = v15.__r_.__value_.__l.__size_;
  }

  v14 = std::string::append(&v20, v12, v13);
  *this = *v14;
  v14->__r_.__value_.__r.__words[0] = 0;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v15.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v19.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v16.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
}

void gdc::ResourceKey::createDebugNode(std::string *a1, unsigned __int8 *a2)
{
  std::string::basic_string[abi:nn200100]<0>(&v25, "Resource Key");
  gdc::DebugTreeNode::DebugTreeNode(a1, &v25);
  if (v26 < 0)
  {
    operator delete(v25);
  }

  std::string::basic_string[abi:nn200100]<0>(&v25, "Resource Type");
  v4 = *(a2 + 1);
  v22 = 0;
  v23 = 0;
  v24 = 1;
  v21 = 0;
  v20 = v4;
  gdc::DebugTreeNode::addProperty(a1, &v25, v19);
  if (v26 < 0)
  {
    operator delete(v25);
  }

  std::string::basic_string[abi:nn200100]<0>(&v25, "Key Type");
  v5 = *a2;
  v18 = 0;
  memset(&v17[4], 0, 24);
  v17[0] = v5;
  gdc::DebugTreeNode::addProperty(a1, &v25, v17);
  if (v26 < 0)
  {
    operator delete(v25);
  }

  std::string::basic_string[abi:nn200100]<0>(&v25, "Priority");
  v6 = *(a2 + 1);
  v14 = 0;
  v15 = 0;
  v16 = 1;
  v13 = 0;
  v12 = v6;
  gdc::DebugTreeNode::addProperty(a1, &v25, v11);
  if (v26 < 0)
  {
    operator delete(v25);
  }

  std::string::basic_string[abi:nn200100]<0>(&v25, "Value");
  gdc::GenericKey::keysInt32Str(&v7, a2 + 1);
  memset(&__p, 0, sizeof(__p));
  v10 = 4;
  std::string::operator=(&__p, &v7);
  gdc::DebugTreeNode::addProperty(a1, &v25, v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v7.__r_.__value_.__l.__data_);
  }

  if (v26 < 0)
  {
    operator delete(v25);
  }
}

__n128 gdc::Camera::setTarget(uint64_t a1, __n128 *a2)
{
  result = *a2;
  *(a1 + 24) = a2[1].n128_u64[0];
  *(a1 + 8) = result;
  return result;
}

void gdc::Camera::convertToMeters(gdc::Camera *this, double a2, double *a3)
{
  v5 = *a3;
  v6 = 0.0;
  if (v5 <= 1)
  {
    goto LABEL_4;
  }

  if (v5 == 2)
  {
    v6 = a2 / geo::WGS84::unitsPerMeterAtLatitude<geo::Radians,double>(fmin(fmax(a3[1], -1.48352986), 1.48352986));
    goto LABEL_6;
  }

  if (v5 == 3)
  {
LABEL_4:
    v6 = a2 * 40075017.0;
  }

LABEL_6:
  *this = v6;
}

double gdc::Camera::aspectRatio(gdc::Camera *this, double a2, double a3)
{
  v3 = a3 * a2;
  result = a2 / a3;
  if (v3 <= 0.0)
  {
    return 1.0;
  }

  return result;
}

uint64_t gdc::CameraView::ecefCameraView(gdc::CameraView *this, const gdc::Camera *a2)
{
  gdc::CameraFrame<geo::Radians,double>::toRigidTransformEcefNoOffset(v18, a2 + 1);
  v4 = *(a2 + 46);
  v5 = *(a2 + 47);
  v16[0] = v4;
  v16[1] = v5;
  v6 = *(a2 + 122);
  v7 = *(a2 + 123);
  if (v5 >= v4)
  {
    v13 = *(a2 + 57);
  }

  else
  {
    v8 = v5 * v4;
    v9 = v5 / v4;
    if (v8 <= 0.0)
    {
      v10 = 1.0;
    }

    else
    {
      v10 = v9;
    }

    v11 = tan(*(a2 + 57) * 0.5);
    v12 = atan(v11 * v10);
    v13 = v12 + v12;
  }

  v15 = v13;
  gdc::ScaledOffsetPerspectiveView<double>::ScaledOffsetPerspectiveView(v17, v18, v16, &v15, v6, v7, 1.0, *(a2 + 58), *(a2 + 59), *(a2 + 60));
  return gdc::CameraView::CameraView(this, a2, v17);
}

uint64_t gdc::CameraView::geocentricCameraViewWithTransform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v73[0] = *a2;
  v74 = *(a2 + 8);
  v75 = *(a2 + 24);
  v76 = *(a2 + 40);
  v77 = *(a2 + 56);
  v78 = *(a2 + 72);
  v5 = *(a2 + 96);
  v79 = *(a2 + 80);
  v80 = v5;
  v81 = *(a2 + 112);
  v6 = *(a2 + 128);
  v7 = *(a2 + 344);
  v8 = *(a2 + 264);
  v9 = *(a2 + 280);
  v11 = *(a2 + 296);
  v10 = *(a2 + 312);
  v95 = *(a2 + 328);
  v96 = v7;
  v91 = v8;
  v92 = v9;
  v93 = v11;
  v94 = v10;
  v12 = *(a2 + 360);
  v82 = v6;
  v97 = v12;
  v90 = *(a2 + 248);
  v86 = *(a2 + 184);
  v87 = *(a2 + 200);
  v88 = *(a2 + 216);
  v89 = *(a2 + 232);
  v83 = *(a2 + 136);
  v84 = *(a2 + 152);
  v85 = *(a2 + 168);
  v63 = *(a2 + 376);
  v64 = *(a2 + 368);
  v98 = v64;
  v99 = v63;
  v13 = *(a2 + 400);
  v100 = *(a2 + 384);
  v101 = v13;
  v14 = *(a2 + 432);
  v102 = *(a2 + 416);
  v103 = v14;
  v104 = *(a2 + 448);
  v15 = *(a2 + 464);
  v62 = *(a2 + 456);
  v105 = v62;
  v106 = v15;
  v16 = *(a2 + 472);
  v107 = v16;
  v108 = *(a2 + 480);
  v116 = *a3;
  v117 = *(a3 + 16);
  geo::Geocentric<double>::toCoordinate3D<geo::Radians,double>(&v116, &v114);
  v17 = v115;
  v18 = v114.f64[1] + 0.00001;
  v60 = v114.f64[0];
  v19 = __sincos_stret(v114.f64[0]);
  v20 = 6378137.0 / sqrt(v19.__sinval * v19.__sinval * -0.00669437999 + 1.0);
  v21 = (v20 + v17) * v19.__cosval;
  v22 = __sincos_stret(v18);
  v113[0] = v21 * v22.__cosval;
  v113[1] = v21 * v22.__sinval;
  v113[2] = (v17 + v20 * 0.99330562) * v19.__sinval;
  v23 = gm::Matrix<double,3,1>::normalized<int,void>(&v116);
  v25 = v24;
  v27 = v26;
  for (i = 0; i != 3; ++i)
  {
    *(&v65 + i * 8) = v113[i] - *(&v116 + i * 8);
  }

  v29 = gm::Matrix<double,3,1>::normalized<int,void>(&v65);
  v32 = -(v30 * v27 - v31 * v25);
  v33 = -(v31 * v23 - v29 * v27);
  v34 = -(v29 * v25 - v30 * v23);
  *&v65 = -(v34 * v25 - v33 * v27);
  *(&v65 + 1) = -(v32 * v27 - v34 * v23);
  v66 = -(v33 * v23 - v32 * v25);
  v67 = v32;
  v68 = v33;
  v69 = v34;
  v70 = v23;
  v71 = v25;
  v72 = v27;
  gm::quaternionFromRotationMatrix<double>(v112, &v65);
  for (j = 0; j != 3; ++j)
  {
    *(&v65 + j * 8) = -v112[j];
  }

  v109 = v65;
  v110 = v66;
  v111 = v112[3];
  gm::Quaternion<double>::operator*(&v65, &v109, a3 + 24);
  v36 = v66 * v66 - (*(&v65 + 1) * *(&v65 + 1) + *&v65 * *&v65) + v67 * v67;
  if (v36 >= 1.0)
  {
    v48 = acos((v66 * v66 + *(&v65 + 1) * *(&v65 + 1)) * -2.0 + 1.0);
    v46 = 0.0;
    v44 = 0.0;
  }

  else
  {
    v37 = v67 * *(&v65 + 1);
    v38 = v66 * *&v65;
    v39 = v67 * *&v65;
    v59 = v16;
    v40 = v15;
    v41 = v66 * *(&v65 + 1);
    v42 = v17;
    v43 = atan2(v66 * *&v65 - v67 * *(&v65 + 1), v67 * *&v65 + v66 * *(&v65 + 1));
    v44 = acos(v36);
    v45 = v37 + v38;
    v46 = v43;
    v17 = v42;
    v47 = v39 - v41;
    v15 = v40;
    v16 = v59;
    v48 = atan2(v45, v47);
  }

  if (v44 + -1.57079633 == 0.0)
  {
    v61 = 0.0;
  }

  else
  {
    v49 = v17 / cos(v44);
    v50 = v17 * tan(v44);
    v61 = v50 * geo::WGS84::unitsPerMeterAtLatitude<geo::Radians,double>(v60);
    v17 = v49;
  }

  v52 = __sincos_stret(v48);
  v51.f64[0] = v52.__cosval;
  v51.f64[1] = v52.__sinval;
  v114 = vmlaq_n_f64(v114, v51, v61);
  *&v75 = 0;
  v74 = v114;
  *(&v75 + 1) = v17;
  *&v76 = v44;
  *(&v76 + 1) = v48;
  *&v77 = -v46;
  LOWORD(v109) = v64;
  WORD1(v109) = v63;
  v53 = *(&v108 + 1);
  if (v63 >= v64)
  {
    v57 = v62;
  }

  else
  {
    if (v63 * v64 <= 0.0)
    {
      v54 = 1.0;
    }

    else
    {
      v54 = v63 / v64;
    }

    v55 = tan(v62 * 0.5);
    v56 = atan(v55 * v54);
    v57 = v56 + v56;
  }

  v112[0] = v57;
  gdc::ScaledOffsetPerspectiveView<double>::ScaledOffsetPerspectiveView(&v65, a3, &v109, v112, *&v53, *(&v53 + 1), 1.0, v15, v16, *&v108);
  return gdc::CameraView::CameraView(a1, v73, &v65);
}

void gdc::LayerDataManager::~LayerDataManager(gdc::LayerDataManager *this)
{
  gdc::LayerDataManager::~LayerDataManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A60048;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 104);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](this + 72);
  std::unique_ptr<gdc::LayerDataRequestTracker>::reset[abi:nn200100](this + 8, 0);
  std::unique_ptr<gdc::ResourceManager>::reset[abi:nn200100](this + 7, 0);
  v2 = *(this + 4);
  if (v2)
  {
    *(this + 5) = v2;
    operator delete(v2);
  }

  v3 = *(this + 1);
  if (v3)
  {
    *(this + 2) = v3;
    operator delete(v3);
  }
}

void *std::__list_imp<gdc::LayerDataRequestTracker::RequestStatus>::clear(void *result)
{
  if (result[2])
  {
    v1 = result;
    result = result[1];
    v2 = *(*v1 + 8);
    v3 = *result;
    *(v3 + 8) = v2;
    *v2 = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = result[1];
        std::__list_imp<gdc::LayerDataRequestTracker::RequestStatus>::__delete_node[abi:nn200100](result);
        result = v4;
      }

      while (v4 != v1);
    }
  }

  return result;
}

void std::__list_imp<gdc::LayerDataRequestTracker::RequestStatus>::__delete_node[abi:nn200100](void *a1)
{
  std::__function::__value_func<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::~__value_func[abi:nn200100](a1 + 104);
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>>>::~__hash_table(a1 + 56);
  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::~__hash_table(a1 + 16);

  operator delete(a1);
}

void std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *v1;
      std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,0>(v1 + 2);
      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

void std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,0>(void *a1)
{
  v2 = a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  v3 = a1[2];
  if (v3 != a1[4])
  {

    free(v3);
  }
}

uint64_t **gdc::LayerDataManager::cancelLayerDataRequests(uint64_t **result, uint64_t **a2)
{
  if (a2)
  {
    v2 = a2;
    v3 = result;
    do
    {
      v4 = v3[1];
      v5 = v3[2];
      if (v4 != v5)
      {
        while (*(v2 + 12) != *v4)
        {
          v4 += 3;
          if (v4 == v5)
          {
            goto LABEL_9;
          }
        }

        if (v4 != v5)
        {
          result = gdc::LayerDataSource::cancelLayerDataRequest(v4[1], (v2 + 2));
        }
      }

LABEL_9:
      v2 = *v2;
    }

    while (v2);
  }

  return result;
}

void gdc::LayerDataManager::cancelAllStandaloneRequests(gdc::LayerDataManager *this)
{
  v19 = 0;
  v20 = 0;
  v21 = 0;
  std::vector<gdc::LayerDataRequestKey>::reserve(&v19, *(this + 6));
  for (i = *(this + 5); i; i = *i)
  {
    gdc::LayerDataRequestKey::LayerDataRequestKey(&v10, (i + 2));
    std::vector<md::MuninJunction *>::vector[abi:nn200100](__p, i + 16);
    v3 = v20;
    if (v20 >= v21)
    {
      v5 = std::vector<gdc::LayerDataRequestKey>::__emplace_back_slow_path<gdc::LayerDataRequestKey&>(&v19, &v10);
    }

    else
    {
      *v20 = v10;
      v4 = v11;
      *(v3 + 2) = v3 + 48;
      *(v3 + 4) = v4;
      *(v3 + 3) = v3 + 48;
      *(v3 + 4) = v3 + 48;
      *(v3 + 5) = 32;
      geo::small_vector_base<unsigned char>::append<unsigned char const*>(v3 + 2, v12, v13);
      *(v3 + 5) = v15;
      *(v3 + 12) = v16;
      *(v3 + 13) = v17;
      v5 = (v3 + 112);
    }

    v20 = v5;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if (v12 != v14)
    {
      free(v12);
    }
  }

  v6 = v19;
  v7 = v20;
  while (v6 != v7)
  {
    v10 = 0;
    v11 = 0;
    gdc::LayerDataRequestTracker::_processKey(this, v6, &v10, 1);
    v6 += 112;
  }

  if (*(this + 6))
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>>>::__deallocate_node(*(this + 5));
    *(this + 5) = 0;
    v8 = *(this + 4);
    if (v8)
    {
      for (j = 0; j != v8; ++j)
      {
        *(*(this + 3) + 8 * j) = 0;
      }
    }

    *(this + 6) = 0;
  }

  std::__list_imp<gdc::LayerDataRequestTracker::RequestStatus>::clear(this);
  v10 = &v19;
  std::vector<gdc::LayerDataRequestKey>::__destroy_vector::operator()[abi:nn200100](&v10);
}

void gdc::LayerDataManager::requestLayerDataKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *MEMORY[0x1E69E9840];
  std::__function::__value_func<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::__value_func[abi:nn200100](v3, a3);
  operator new();
}

void gdc::LayerDataManager::createDebugNode(std::string *a1, void *a2, uint64_t a3)
{
  std::string::basic_string[abi:nn200100]<0>(&v66, "Resource Manager");
  gdc::DebugTreeNode::DebugTreeNode(a1, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "RequestsInProgress");
  ChildNode = gdc::DebugTreeNode::createChildNode(a1, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  v7 = a2[14];
  if (v7)
  {
    v8 = 0;
    do
    {
      gdc::ResourceKey::createDebugNode(&v66, v7 + 16);
      gdc::DebugTreeNode::addChildNode(ChildNode, &v66);
      v48.__r_.__value_.__r.__words[0] = v72;
      std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v48);
      v48.__r_.__value_.__r.__words[0] = &v70;
      std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v48);
      if (SHIBYTE(v69) < 0)
      {
        operator delete(v67);
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      v7 = *v7;
      ++v8;
    }

    while (v7);
  }

  else
  {
    v8 = 0;
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "Count");
  v56 = 0;
  v57 = 0;
  v58 = 1;
  v55 = 0;
  v54 = v8;
  gdc::DebugTreeNode::addProperty(ChildNode, &v66, v53);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "FailedRequests");
  v9 = gdc::DebugTreeNode::createChildNode(a1, &v66);
  gdc::DebugTreeNode::DebugTreeNode(&v48, v9);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  v10 = a2[19];
  if (v10)
  {
    v11 = 0;
    do
    {
      gdc::ResourceKey::createDebugNode(&v66, v10 + 16);
      gdc::DebugTreeNode::addChildNode(&v48, &v66);
      __p.__r_.__value_.__r.__words[0] = v72;
      std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&__p);
      __p.__r_.__value_.__r.__words[0] = &v70;
      std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&__p);
      if (SHIBYTE(v69) < 0)
      {
        operator delete(v67);
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      ++v11;
      v10 = *v10;
    }

    while (v10);
  }

  else
  {
    v11 = 0;
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "Count");
  v45 = 0;
  v46 = 0;
  v47 = 1;
  v44 = 0;
  v43 = v11;
  gdc::DebugTreeNode::addProperty(&v48, &v66, v42);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  memset(v41, 0, sizeof(v41));
  for (i = a2[24]; i; i = *i)
  {
    v13 = i[2];
    v69 = 0;
    v70 = 0;
    v68 = 0;
    v71 = 1;
    v66.__r_.__value_.__l.__size_ = v13;
    std::vector<gdc::DebugTreeValue>::push_back[abi:nn200100](v41, &v66);
    if (SHIBYTE(v70) < 0)
    {
      operator delete(v68);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "Cancelled Requests");
  gdc::DebugTreeNode::addProperty(a1, &v66, v41);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "Fetchers");
  v14 = gdc::DebugTreeNode::createChildNode(a1, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  v15 = a2[4];
  for (j = a2[5]; v15 != j; v15 += 16)
  {
    v17 = *(v15 + 8);
    std::function<std::string ()(unsigned short)>::operator()(&v61, a2[47], *v15);
    v18 = std::string::insert(&v61, 0, "Fetcher ", 8uLL);
    v19 = *&v18->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *&__p.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    (*(*v17 + 112))(&v66, v17, &__p, a3);
    gdc::DebugTreeNode::addChildNode(v14, &v66);
    v59[0] = v72;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v59);
    v59[0] = &v70;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v59);
    if (SHIBYTE(v69) < 0)
    {
      operator delete(v67);
    }

    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v66.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v61.__r_.__value_.__l.__data_);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "ResourceStores");
  v20 = gdc::DebugTreeNode::createChildNode(a1, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  v21 = a2[7];
  for (k = a2[8]; v21 != k; v21 += 24)
  {
    v23 = *(v21 + 8);
    std::function<std::string ()(unsigned short)>::operator()(&v61, a2[47], *v21);
    v24 = std::string::insert(&v61, 0, "Store ", 6uLL);
    __p = *v24;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    gdc::ResourceStore::createDebugNode(&v66, v23, &__p);
    gdc::DebugTreeNode::addChildNode(v20, &v66);
    v59[0] = v72;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v59);
    v59[0] = &v70;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v59);
    if (SHIBYTE(v69) < 0)
    {
      operator delete(v67);
    }

    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v66.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v61.__r_.__value_.__l.__data_);
    }
  }

  v25 = a2[39];
  std::string::basic_string[abi:nn200100]<0>(&v66, "Resource Status Container");
  gdc::DebugTreeNode::DebugTreeNode(&__p, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "ActiveResourceKeys");
  v26 = gdc::DebugTreeNode::createChildNode(&__p, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  v27 = v25[6];
  if (v27 != (v25 + 7))
  {
    do
    {
      gdc::ResourceKey::createDebugNode(&v66, v27 + 32);
      gdc::DebugTreeNode::addChildNode(v26, &v66);
      v61.__r_.__value_.__r.__words[0] = v72;
      std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v61);
      v61.__r_.__value_.__r.__words[0] = &v70;
      std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v61);
      if (SHIBYTE(v69) < 0)
      {
        operator delete(v67);
      }

      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v66.__r_.__value_.__l.__data_);
      }

      v28 = *(v27 + 1);
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = *v28;
        }

        while (v28);
      }

      else
      {
        do
        {
          v29 = *(v27 + 2);
          v30 = *v29 == v27;
          v27 = v29;
        }

        while (!v30);
      }

      v27 = v29;
    }

    while (v29 != (v25 + 7));
  }

  std::string::basic_string[abi:nn200100]<0>(&v66, "Status");
  v31 = gdc::DebugTreeNode::createChildNode(&__p, &v66);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v66.__r_.__value_.__l.__data_);
  }

  for (m = v25[3]; m; m = *m)
  {
    gdc::ResourceKey::createDebugNode(&v66, m + 16);
    std::string::basic_string[abi:nn200100]<0>(&v64, "Status");
    v33 = *(m + 28);
    v34 = "<Invalid>";
    if (v33 <= 4)
    {
      v34 = off_1E7B58750[v33];
    }

    memset(&v62, 0, sizeof(v62));
    v63 = 4;
    std::string::__assign_external(&v62, v34);
    gdc::DebugTreeNode::addProperty(&v66, &v64, &v61);
    if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v62.__r_.__value_.__l.__data_);
    }

    if (v65 < 0)
    {
      operator delete(v64);
    }

    std::string::basic_string[abi:nn200100]<0>(&v64, "RefCount");
    v35 = *(m + 15);
    memset(&v59[4], 0, 24);
    v60 = 0;
    v59[0] = v35;
    gdc::DebugTreeNode::addProperty(&v66, &v64, v59);
    if (v65 < 0)
    {
      operator delete(v64);
    }

    gdc::DebugTreeNode::addChildNode(v31, &v66);
    *&v64 = v72;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v64);
    *&v64 = &v70;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v64);
    if (SHIBYTE(v69) < 0)
    {
      operator delete(v67);
    }

    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v66.__r_.__value_.__l.__data_);
    }
  }

  gdc::DebugTreeNode::addChildNode(a1, &__p);
  v66.__r_.__value_.__r.__words[0] = &v40;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v66);
  v66.__r_.__value_.__r.__words[0] = &v39;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v66);
  if (v38 < 0)
  {
    operator delete(v37);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v66.__r_.__value_.__r.__words[0] = v41;
  std::vector<gdc::DebugTreeValue>::__destroy_vector::operator()[abi:nn200100](&v66);
  v66.__r_.__value_.__r.__words[0] = &v52;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v66);
  v66.__r_.__value_.__r.__words[0] = &v51;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v66);
  if (v50 < 0)
  {
    operator delete(v49);
  }

  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
}

void sub_1B3388B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46, void *a47, uint64_t a48, int a49, __int16 a50, char a51, char a52, uint64_t a53, uint64_t a54, uint64_t a55, uint64_t a56)
{
  *(v56 - 184) = &a26;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100]((v56 - 184));
  *(v56 - 184) = &a23;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100]((v56 - 184));
  if (a22 < 0)
  {
    operator delete(__p);
  }

  if (a16 < 0)
  {
    operator delete(a11);
  }

  a11 = &a30;
  std::vector<gdc::DebugTreeValue>::__destroy_vector::operator()[abi:nn200100](&a11);
  a11 = &a56;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&a11);
  a11 = &a53;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&a11);
  if (a52 < 0)
  {
    operator delete(a47);
  }

  if (a46 < 0)
  {
    operator delete(a41);
  }

  a41 = (a10 + 72);
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&a41);
  a41 = (a10 + 48);
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&a41);
  if (*(a10 + 47) < 0)
  {
    operator delete(*(a10 + 24));
  }

  if (*(a10 + 23) < 0)
  {
    operator delete(*a10);
  }

  _Unwind_Resume(a1);
}

uint64_t gdc::LayerDataSource::descriptionForKey@<X0>(const gdc::LayerDataRequestKey *a1@<X1>, _BYTE *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v13);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v13, "LayerDataRequestKey<Type:", 25);
  v5 = MEMORY[0x1B8C61CD0](&v13, *(a1 + 4));
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v5, ", Data: ", 8);
  gdc::LayerDataRequestKey::keysInt32Str(&__p, a1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v5, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if ((v20 & 0x10) != 0)
  {
    v9 = v19;
    if (v19 < v16)
    {
      v19 = v16;
      v9 = v16;
    }

    locale = v15[4].__locale_;
  }

  else
  {
    if ((v20 & 8) == 0)
    {
      v8 = 0;
      a2[23] = 0;
      goto LABEL_22;
    }

    locale = v15[1].__locale_;
    v9 = v15[3].__locale_;
  }

  v8 = v9 - locale;
  if ((v9 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v8 >= 0x17)
  {
    operator new();
  }

  a2[23] = v8;
  if (v8)
  {
    memmove(a2, locale, v8);
  }

LABEL_22:
  a2[v8] = 0;
  v13 = *MEMORY[0x1E69E54E8];
  *(&v13 + *(v13 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v14 = MEMORY[0x1E69E5548] + 16;
  if (v18 < 0)
  {
    operator delete(v17);
  }

  v14 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v15);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v21);
}

void gdc::LayerDataSource::createDebugNode(void *a1@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:nn200100]<0>(&__p, "Layer Data Source");
  gdc::DebugTreeNode::DebugTreeNode(a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Requests");
  ChildNode = gdc::DebugTreeNode::createChildNode(a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  v30 = a2;
  std::string::basic_string[abi:nn200100]<0>(&__p, "Count");
  v5 = a1[8];
  v66 = 0;
  v67 = 0;
  v68 = 1;
  v65 = 0;
  v64 = v5;
  gdc::DebugTreeNode::addProperty(ChildNode, &__p, v63);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  for (i = a1[7]; i; i = *i)
  {
    (*(*a1 + 136))(&__p, a1, i + 2);
    v7 = gdc::DebugTreeNode::createChildNode(ChildNode, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "Pending Creation");
    v8 = *(i[16] + 209);
    memset(&v61[4], 0, 24);
    v62 = 0;
    v61[0] = v8;
    gdc::DebugTreeNode::addProperty(v7, &__p, v61);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "Has All Resources");
    v9 = *(i[16] + 208);
    memset(&v59[4], 0, 24);
    v60 = 0;
    v59[0] = v9;
    gdc::DebugTreeNode::addProperty(v7, &__p, v59);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "Last Requested");
    v10 = *(i[16] + 200);
    memset(&v57[4], 0, 24);
    v58 = 0;
    v57[0] = v10;
    gdc::DebugTreeNode::addProperty(v7, &__p, v57);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "Tracking Id");
    v11 = *(i[16] + 112);
    v54 = 0;
    v55 = 0;
    v53 = 0;
    v56 = 1;
    v52 = v11;
    gdc::DebugTreeNode::addProperty(v7, &__p, v51);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "RequiredResources");
    v12 = gdc::DebugTreeNode::createChildNode(v7, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    v13 = i[16];
    v15 = *(v13 + 120);
    v14 = *(v13 + 128);
    while (v15 != v14)
    {
      for (j = *(v15 + 24); j; j = *j)
      {
        gdc::ResourceKey::createDebugNode(&__p, j + 16);
        gdc::DebugTreeNode::addChildNode(v12, &__p);
        v31[0] = v50;
        std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v31);
        v31[0] = &v48;
        std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v31);
        if (SHIBYTE(v47) < 0)
        {
          operator delete(v45);
        }

        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      v15 += 48;
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "OptionalResources");
    v17 = gdc::DebugTreeNode::createChildNode(v7, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    v18 = i[16];
    v20 = *(v18 + 144);
    v19 = *(v18 + 152);
    while (v20 != v19)
    {
      for (k = *(v20 + 24); k; k = *k)
      {
        gdc::ResourceKey::createDebugNode(&__p, k + 16);
        gdc::DebugTreeNode::addChildNode(v17, &__p);
        v31[0] = v50;
        std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v31);
        v31[0] = &v48;
        std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v31);
        if (SHIBYTE(v47) < 0)
        {
          operator delete(v45);
        }

        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      v20 += 48;
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Requests with Failed Resources");
  v22 = gdc::DebugTreeNode::createChildNode(v30, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Count");
  v23 = a1[13];
  v41 = 0;
  v42 = 0;
  v43 = 1;
  v40 = 0;
  v39 = v23;
  gdc::DebugTreeNode::addProperty(v22, &__p, v38);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  for (m = a1[12]; m; m = *m)
  {
    gdc::LayerDataRequestKey::createDebugNode(&__p, m + 8);
    gdc::DebugTreeNode::addChildNode(v22, &__p);
    v31[0] = v50;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v31);
    v31[0] = &v48;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v31);
    if (SHIBYTE(v47) < 0)
    {
      operator delete(v45);
    }

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Requests that Failed to Decode");
  v25 = gdc::DebugTreeNode::createChildNode(v30, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Count");
  v26 = a1[18];
  v35 = 0;
  v36 = 0;
  v37 = 1;
  v34 = 0;
  v33 = v26;
  gdc::DebugTreeNode::addProperty(v25, &__p, v32);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  for (n = a1[17]; n; n = *n)
  {
    gdc::LayerDataRequestKey::createDebugNode(&__p, n + 8);
    gdc::DebugTreeNode::addChildNode(v25, &__p);
    v31[0] = v50;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v31);
    v31[0] = &v48;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v31);
    if (SHIBYTE(v47) < 0)
    {
      operator delete(v45);
    }

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  memset(v31, 0, sizeof(v31));
  std::vector<gdc::DebugTreeValue>::reserve(v31, a1[23]);
  for (ii = a1[22]; ii; ii = *ii)
  {
    v29 = ii[2];
    v47 = 0;
    v48 = 0;
    v46 = 0;
    v49 = 1;
    __p.__r_.__value_.__l.__size_ = v29;
    std::vector<gdc::DebugTreeValue>::push_back[abi:nn200100](v31, &__p);
    if (SHIBYTE(v48) < 0)
    {
      operator delete(v46);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Pending Cancelled Requests");
  gdc::DebugTreeNode::addProperty(v30, &__p, v31);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  __p.__r_.__value_.__r.__words[0] = v31;
  std::vector<gdc::DebugTreeValue>::__destroy_vector::operator()[abi:nn200100](&__p);
}

double gdc::LayerDataRequest::LayerDataRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8 = gdc::LayerDataRequestKey::LayerDataRequestKey(a1, a3);
  *(v8 + 112) = a2;
  result = 0.0;
  *(v8 + 120) = 0u;
  *(v8 + 136) = 0u;
  *(v8 + 152) = 0u;
  *(v8 + 168) = 0u;
  *(v8 + 184) = 0;
  *(v8 + 192) = a4;
  *(v8 + 200) = a5;
  *(v8 + 208) = 0;
  *(v8 + 210) = 0;
  return result;
}

void gdc::LayerDataSource::decodeTimeSampler(gdc::LayerDataSource *this, uint64_t a2)
{
  std::mutex::lock((a2 + 480));
  v4 = *(a2 + 560);
  *this = *(a2 + 544);
  *(this + 1) = v4;
  *(this + 4) = *(a2 + 576);

  std::mutex::unlock((a2 + 480));
}

void gdc::LayerDataSource::resetDecodeTimeSampler(gdc::LayerDataSource *this)
{
  std::mutex::lock((this + 480));
  *(this + 72) = 0;
  *(this + 34) = 0u;
  *(this + 35) = 0u;

  std::mutex::unlock((this + 480));
}

void std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4, uint64_t *a5)
{
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(a1, a2, a3);
  if (gdc::ResourceKeyLessThan::operator()(a4, a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a3, a4);
    if (gdc::ResourceKeyLessThan::operator()(a3, a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a2, a3);
      if (gdc::ResourceKeyLessThan::operator()(a2, a1))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a1, a2);
      }
    }
  }

  if (gdc::ResourceKeyLessThan::operator()(a5, a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a4, a5);
    if (gdc::ResourceKeyLessThan::operator()(a4, a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a3, a4);
      if (gdc::ResourceKeyLessThan::operator()(a3, a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a2, a3);
        if (gdc::ResourceKeyLessThan::operator()(a2, a1))
        {

          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(a1, a2);
        }
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *>(uint64_t a1, uint64_t a2)
{
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 5);
  if (v4 > 2)
  {
    switch(v4)
    {
      case 3:
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(a1, (a1 + 96), (a2 - 96));
        return 1;
      case 4:
        v18 = (a2 - 96);
        std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(a1, (a1 + 96), (a1 + 192));
        if (!gdc::ResourceKeyLessThan::operator()(v18, (a1 + 192)))
        {
          return 1;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>((a1 + 192), v18);
        if (!gdc::ResourceKeyLessThan::operator()((a1 + 192), (a1 + 96)))
        {
          return 1;
        }

        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>((a1 + 96), (a1 + 192));
        if (!gdc::ResourceKeyLessThan::operator()((a1 + 96), a1))
        {
          return 1;
        }

        v7 = (a1 + 96);
        v6 = a1;
        goto LABEL_6;
      case 5:
        std::__sort5[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(a1, (a1 + 96), (a1 + 192), (a1 + 288), (a2 - 96));
        return 1;
    }
  }

  else
  {
    if (v4 < 2)
    {
      return 1;
    }

    if (v4 == 2)
    {
      v5 = (a2 - 96);
      if (gdc::ResourceKeyLessThan::operator()((a2 - 96), a1))
      {
        v6 = a1;
        v7 = v5;
LABEL_6:
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<gdc::ResourceKey *&,gdc::ResourceKey *&>(v6, v7);
      }

      return 1;
    }
  }

  v8 = (a1 + 192);
  std::__sort3[abi:nn200100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,0>(a1, (a1 + 96), (a1 + 192));
  v9 = a1 + 288;
  if (a1 + 288 == a2)
  {
    return 1;
  }

  v10 = 0;
  v11 = 0;
  while (1)
  {
    if (gdc::ResourceKeyLessThan::operator()(v9, v8))
    {
      v20 = *v9;
      geo::small_vector_base<unsigned char>::small_vector_base(v21, v9 + 8, v22);
      v23 = *(v9 + 72);
      v24 = *(v9 + 80);
      v12 = v10;
      while (1)
      {
        v13 = v12;
        v14 = a1 + v12;
        *(a1 + v12 + 288) = *(a1 + v12 + 192);
        geo::small_vector_base<unsigned char>::move(a1 + v12 + 296, a1 + v12 + 200, (a1 + v12 + 328));
        *(v14 + 360) = *(v14 + 264);
        *(v14 + 368) = *(v14 + 272);
        if (v13 == -192)
        {
          break;
        }

        v15 = gdc::ResourceKeyLessThan::operator()(&v20, (v14 + 96));
        v12 = v13 - 96;
        if ((v15 & 1) == 0)
        {
          v16 = a1 + v12 + 288;
          v17 = (a1 + v13 + 272);
          goto LABEL_20;
        }
      }

      v17 = (v14 + 272);
      v16 = a1;
LABEL_20:
      *v16 = v20;
      if (v16 != &v20)
      {
        geo::small_vector_base<unsigned char>::move(v16 + 8, v21, (v16 + 40));
      }

      *(v16 + 72) = v23;
      *v17 = v24;
      if (v21[0] != v21[2])
      {
        free(v21[0]);
      }

      if (++v11 == 8)
      {
        return v9 + 96 == a2;
      }
    }

    v8 = v9;
    v10 += 96;
    v9 += 96;
    if (v9 == a2)
    {
      return 1;
    }
  }
}

void *std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>(void *result, unint64_t a2)
{
  v2 = result[1];
  if (!*&v2)
  {
    goto LABEL_18;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*&v2 <= a2)
    {
      v4 = a2 % *&v2;
    }
  }

  else
  {
    v4 = (*&v2 - 1) & a2;
  }

  v5 = *(*result + 8 * v4);
  if (!v5 || (v6 = *v5) == 0)
  {
LABEL_18:
    operator new();
  }

  while (1)
  {
    v7 = v6[1];
    if (v7 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= *&v2)
      {
        v7 %= *&v2;
      }
    }

    else
    {
      v7 &= *&v2 - 1;
    }

    if (v7 != v4)
    {
      goto LABEL_18;
    }

LABEL_17:
    v6 = *v6;
    if (!v6)
    {
      goto LABEL_18;
    }
  }

  if (v6[2] != a2)
  {
    goto LABEL_17;
  }

  return result;
}

__n128 std::__function::__func<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0,std::allocator<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  v2 = a2;
  *a2 = &unk_1F2A60280;
  *(a2 + 8) = *(a1 + 8);
  gdc::LayerDataRequestKey::LayerDataRequestKey(a2 + 24, a1 + 24);
  *(v2 + 136) = 0;
  *(v2 + 144) = 0;
  v2 += 136;
  *(v2 + 16) = 0;
  std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>::__init_with_size[abi:nn200100]<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>*,std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>*>(v2, *(a1 + 136), *(a1 + 144), 0xAAAAAAAAAAAAAAABLL * ((*(a1 + 144) - *(a1 + 136)) >> 4));
  result = *(a1 + 160);
  *(v2 + 40) = *(a1 + 176);
  *(v2 + 24) = result;
  *(v2 + 41) = 0;
  *(v2 + 44) = 0;
  return result;
}

void std::__function::__func<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0,std::allocator<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *a1 = &unk_1F2A60280;
  v3 = (a1 + 136);
  std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>::__destroy_vector::operator()[abi:nn200100](&v3);
  v2 = *(a1 + 40);
  if (v2 != *(a1 + 56))
  {
    free(v2);
  }

  JUMPOUT(0x1B8C62190);
}

uint64_t std::__function::__func<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0,std::allocator<gdc::LayerDataSource::processLayerDataRequests(gdc::ResourceManager *,geo::TaskGroup *,long long)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *a1 = &unk_1F2A60280;
  v4 = (a1 + 136);
  std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>::__destroy_vector::operator()[abi:nn200100](&v4);
  v2 = *(a1 + 40);
  if (v2 != *(a1 + 56))
  {
    free(v2);
  }

  return a1;
}

uint64_t **gdc::LayerDataSource::cancelLayerDataRequest(gdc::LayerDataSource *this, const gdc::LayerDataRequestKey *a2)
{
  v20 = *MEMORY[0x1E69E9840];
  if (GEOGetGeoDisplayCoreResourceLoadingLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoDisplayCoreResourceLoadingLog::onceToken, &__block_literal_global_5_56382);
  }

  v4 = GEOGetGeoDisplayCoreResourceLoadingLog::log;
  if (os_log_type_enabled(GEOGetGeoDisplayCoreResourceLoadingLog::log, OS_LOG_TYPE_DEBUG))
  {
    v5 = (*(**(this + 73) + 16))(*(this + 73));
    gdc::LayerDataRequestKey::keysInt32Str(&__p, a2);
    v6 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &__p : __p.__r_.__value_.__r.__words[0];
    LODWORD(v17.__r_.__value_.__l.__data_) = 136315394;
    *(v17.__r_.__value_.__r.__words + 4) = v5;
    WORD2(v17.__r_.__value_.__r.__words[1]) = 2080;
    *(&v17.__r_.__value_.__r.__words[1] + 6) = v6;
    _os_log_impl(&dword_1B2754000, v4, OS_LOG_TYPE_DEBUG, "%s cancelLayerDataRequest: %s", &v17, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  result = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>(this + 5, a2);
  if (result)
  {
    v8 = result;
    v9 = result[16];
    if (*(v9 + 209) == 1)
    {
      __p.__r_.__value_.__r.__words[0] = v9[14];
      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>(this + 20, __p.__r_.__value_.__r.__words[0]);
    }

    if (GEOGetGeoDisplayCoreResourceLoadingLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoDisplayCoreResourceLoadingLog::onceToken, &__block_literal_global_5_56382);
    }

    v10 = GEOGetGeoDisplayCoreResourceLoadingLog::log;
    if (os_log_type_enabled(GEOGetGeoDisplayCoreResourceLoadingLog::log, OS_LOG_TYPE_DEBUG))
    {
      v11 = (*(**(this + 73) + 16))(*(this + 73));
      gdc::LayerDataRequestKey::keysInt32Str(&v17, *(v8 + 128));
      if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v12 = &v17;
      }

      else
      {
        v12 = v17.__r_.__value_.__r.__words[0];
      }

      if (*(*(v8 + 128) + 209))
      {
        v13 = "y";
      }

      else
      {
        v13 = "n";
      }

      LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
      *(__p.__r_.__value_.__r.__words + 4) = v11;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(&__p.__r_.__value_.__r.__words[1] + 6) = v12;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      v19 = v13;
      _os_log_impl(&dword_1B2754000, v10, OS_LOG_TYPE_DEBUG, "%s Cancelling layer data request: %s, pendingCreation: %s", &__p, 0x20u);
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v17.__r_.__value_.__l.__data_);
      }

      if (GEOGetGeoDisplayCoreResourceLoadingLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoDisplayCoreResourceLoadingLog::onceToken, &__block_literal_global_5_56382);
      }
    }

    v14 = *(*(v8 + 128) + 112);
    if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15 = GEOGetGeoDisplayCoreResourceLoadingLog::log;
      if (os_signpost_enabled(GEOGetGeoDisplayCoreResourceLoadingLog::log))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_signpost_emit_with_name_impl(&dword_1B2754000, v15, OS_SIGNPOST_INTERVAL_END, v14, "LayerDataRequest", "status=cancelled", &__p, 2u);
      }
    }

    v16 = *(this + 59);
    *&__p.__r_.__value_.__l.__data_ = 0uLL;
    gdc::LayerDataRequestTracker::_processKey(v16, a2, &__p, 1);
    std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::remove(&__p, this + 5, v8);
    return std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,void *>>>>::~unique_ptr[abi:nn200100](&__p);
  }

  return result;
}

void gdc::LayerDataSource::extendLifeTimeOfResourceToKeyUsage(uint64_t a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  v45 = *MEMORY[0x1E69E9840];
  if (GEOGetGeoDisplayCoreResourceLoadingLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoDisplayCoreResourceLoadingLog::onceToken, &__block_literal_global_5_56382);
  }

  v6 = GEOGetGeoDisplayCoreResourceLoadingLog::log;
  if (os_log_type_enabled(GEOGetGeoDisplayCoreResourceLoadingLog::log, OS_LOG_TYPE_DEBUG))
  {
    v7 = (*(**(a1 + 584) + 16))(*(a1 + 584));
    v8 = &v29;
    gdc::LayerDataRequestKey::keysInt32Str(&v29, a2);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      v8 = v29.__r_.__value_.__r.__words[0];
    }

    gdc::ResourceKey::keysInt32Str(&__p, a3);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      p_p = &__p;
    }

    else
    {
      p_p = __p.__r_.__value_.__r.__words[0];
    }

    *buf = 136315650;
    v31 = v7;
    v32 = 2080;
    *v33 = v8;
    *&v33[8] = 2080;
    v34 = p_p;
    _os_log_impl(&dword_1B2754000, v6, OS_LOG_TYPE_DEBUG, "%s extending key: %s (resource:%s) ", buf, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
  }

  gdc::ResourceStatusContainer::incrementResourceReference(*(a1 + 272), a3);
  gdc::LayerDataRequestKey::LayerDataRequestKey(buf, a2);
  v10 = *(a3 + 1);
  v38 = *a3;
  v39[0] = v42;
  v39[1] = v42;
  v40 = v42;
  v41 = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>(v39, v10, *(a3 + 2));
  v43 = *(a3 + 9);
  v44 = *(a3 + 5);
  v12 = *(a1 + 256);
  v11 = *(a1 + 264);
  if (v12 >= v11)
  {
    v14 = *(a1 + 248);
    v15 = 0x4EC4EC4EC4EC4EC5 * ((v12 - v14) >> 4);
    if ((v15 + 1) > 0x13B13B13B13B13BLL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v16 = 0x4EC4EC4EC4EC4EC5 * ((v11 - v14) >> 4);
    v17 = 2 * v16;
    if (2 * v16 <= v15 + 1)
    {
      v17 = v15 + 1;
    }

    if (v16 >= 0x9D89D89D89D89DLL)
    {
      v18 = 0x13B13B13B13B13BLL;
    }

    else
    {
      v18 = v17;
    }

    if (v18)
    {
      if (v18 <= 0x13B13B13B13B13BLL)
      {
        operator new();
      }

      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v19 = 208 * v15;
    *v19 = buf[0];
    *(v19 + 8) = WORD2(v31);
    *(208 * v15 + 0x10) = 208 * v15 + 48;
    *(v19 + 24) = v19 + 48;
    *(v19 + 32) = v19 + 48;
    *(v19 + 40) = 32;
    geo::small_vector_base<unsigned char>::append<unsigned char const*>((208 * v15 + 16), *&v33[2], v34);
    v20 = v37;
    *(v19 + 80) = v36;
    *(v19 + 96) = v20;
    *(v19 + 112) = v38;
    geo::small_vector_base<unsigned char>::small_vector_base((v19 + 120), v39, (v19 + 152));
    v21 = *(a1 + 248);
    v22 = *(a1 + 256);
    v23 = 208 * v15 - (v22 - v21);
    *(v19 + 184) = v43;
    *(v19 + 192) = v44;
    v13 = 208 * v15 + 208;
    if (v22 != v21)
    {
      v24 = 0;
      v25 = -16 * ((v22 - v21) >> 4) + 208 * v15;
      do
      {
        v26 = v25 + v24;
        gdc::LayerDataRequestKey::LayerDataRequestKey(v25 + v24, &v21[v24]);
        *(v26 + 112) = *&v21[v24 + 112];
        geo::small_vector_base<unsigned char>::small_vector_base((v26 + 120), &v21[v24 + 120], (v26 + 152));
        *(v26 + 184) = *&v21[v24 + 184];
        *(v26 + 192) = *&v21[v24 + 192];
        v24 += 208;
      }

      while (&v21[v24] != v22);
      do
      {
        std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey,gdc::ResourceKey>,0>(v21);
        v21 += 208;
      }

      while (v21 != v22);
    }

    v27 = *(a1 + 248);
    *(a1 + 248) = v23;
    *(a1 + 256) = v13;
    *(a1 + 264) = 0;
    if (v27)
    {
      operator delete(v27);
    }
  }

  else
  {
    *v12 = buf[0];
    *(v12 + 8) = WORD2(v31);
    *(v12 + 16) = v12 + 48;
    *(v12 + 24) = v12 + 48;
    *(v12 + 32) = v12 + 48;
    *(v12 + 40) = 32;
    geo::small_vector_base<unsigned char>::append<unsigned char const*>((v12 + 16), *&v33[2], v34);
    *(v12 + 80) = v36;
    *(v12 + 96) = v37;
    *(v12 + 112) = v38;
    geo::small_vector_base<unsigned char>::small_vector_base((v12 + 120), v39, (v12 + 152));
    *(v12 + 184) = v43;
    *(v12 + 192) = v44;
    v13 = v12 + 208;
  }

  *(a1 + 256) = v13;
  if (v39[0] != v40)
  {
    free(v39[0]);
  }

  if (*&v33[2] != v35)
  {
    free(*&v33[2]);
  }
}

uint64_t *gdc::DataIterator::operator++(uint64_t *result)
{
  v1 = result[1];
  v2 = *result + 144;
  if (v2 != v1)
  {
    while (!*(v2 + 112))
    {
      v2 += 144;
      if (v2 == v1)
      {
        v2 = result[1];
        break;
      }
    }
  }

  *result = v2;
  return result;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this)
{
  *this = 0;
  *(this + 40) = 0;
  *(this + 48) = 0;
  *(this + 32) = 0;
  *(this + 56) = 0;
  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this, uint64_t a2)
{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 56) = 0;
  *(this + 48) = 0;
  *this = a2;
  return this;
}

{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 48) = 0;
  *(this + 56) = 1;
  *(this + 8) = a2;
  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this, int a2)
{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 56) = 0;
  *(this + 48) = 0;
  *this = a2;
  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this, unsigned int a2)
{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 48) = 0;
  *(this + 56) = 1;
  *(this + 8) = a2;
  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this, char a2)
{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 48) = 0;
  *(this + 56) = 3;
  *(this + 24) = a2;
  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t a1, const std::string *a2)
{
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  *(a1 + 32) = 0;
  *(a1 + 56) = 4;
  std::string::operator=((a1 + 32), a2);
  return a1;
}

gdc::DebugTreeValue *gdc::DebugTreeValue::DebugTreeValue(gdc::DebugTreeValue *this, const char *a2)
{
  *(this + 4) = 0;
  *(this + 5) = 0;
  v3 = (this + 32);
  v3->__r_.__value_.__r.__words[2] = 0;
  LODWORD(v3[1].__r_.__value_.__l.__data_) = 4;
  if (a2)
  {
    std::string::__assign_external(v3, a2);
  }

  else
  {
    *(this + 55) = 6;
    LODWORD(v3->__r_.__value_.__l.__data_) = 1819635260;
    WORD2(v3->__r_.__value_.__r.__words[0]) = 15980;
    *(this + 38) = 0;
  }

  return this;
}

uint64_t gdc::DebugTreeValue::DebugTreeValue(uint64_t this, double a2)
{
  *(this + 32) = 0;
  *(this + 40) = 0;
  *(this + 48) = 0;
  *(this + 56) = 2;
  *(this + 16) = a2;
  return this;
}

double gdc::DebugTreeValue::DebugTreeValue(gdc::DebugTreeValue *this, float a2)
{
  *(this + 4) = 0;
  *(this + 5) = 0;
  *(this + 6) = 0;
  *(this + 14) = 2;
  result = a2;
  *(this + 2) = result;
  return result;
}

void gdc::DebugTreeValue::string(std::string *this, uint64_t a2)
{
  if (*(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(a2 + 32), *(a2 + 40));
  }

  else
  {
    *&this->__r_.__value_.__l.__data_ = *(a2 + 32);
    this->__r_.__value_.__r.__words[2] = *(a2 + 48);
  }
}

uint64_t gdc::TriangularDCEL::TriangularDCEL(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  *(a1 + 64) = 0u;
  *(a1 + 80) = 0u;
  *(a1 + 32) = 0u;
  *(a1 + 48) = 0u;
  *a1 = 0u;
  *(a1 + 16) = 0u;
  std::__function::__value_func<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::__value_func[abi:nn200100](a1 + 96, a4);
  *(a1 + 128) = 0u;
  *(a1 + 144) = 0u;
  *(a1 + 160) = 1065353216;
  *(a1 + 168) = 0;
  __x = 0x3FFFFFFF;
  std::vector<unsigned int>::resize((a1 + 24), a2, &__x);
  v7 = (3 * a3);
  std::vector<unsigned int>::reserve((a1 + 72), v7);
  v9 = 0x3FFFFFFF;
  std::vector<unsigned int>::resize(a1, v7, &v9);
  return a1;
}

uint64_t *gdc::TriangularDCEL::addFace(gdc::TriangularDCEL *a1, int a2, int a3, int a4, void *a5)
{
  v36 = *MEMORY[0x1E69E9840];
  v32 = a3;
  v33 = a2;
  v31 = a4;
  v10 = a1 + 72;
  v11 = (*(a1 + 10) - *(a1 + 9)) >> 2;
  std::vector<unsigned int>::push_back[abi:nn200100](a1 + 72, &v33);
  std::vector<unsigned int>::push_back[abi:nn200100](v10, &v32);
  std::vector<unsigned int>::push_back[abi:nn200100](v10, &v31);
  v12 = 0;
  v13 = 0;
  v30[0] = a2;
  v30[1] = a3;
  v14 = (((v11 / 3) & 0x3FFFFFFF) << 32) | 0x3FFFFFFF;
  v30[2] = a4;
  v15 = (v11 / 3) & 0x3FFFFFFF | 0x3FFFFFFF00000000;
  do
  {
    v16 = v30[v12];
    if (v16 >= (*(a1 + 4) - *(a1 + 3)) >> 2)
    {
      if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
      }

      v22 = v11 / 3;
      v27 = GEOGetGeoDisplayCoreDCELLog::log;
      if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
      {
        *buf = 67109376;
        *&buf[4] = v11 / 3;
        LOWORD(v35) = 1024;
        *(&v35 + 2) = v16;
        _os_log_impl(&dword_1B2754000, v27, OS_LOG_TYPE_INFO, "Face %d references non-existent vertex %d.  It will be ignored.", buf, 0xEu);
      }

      v24 = *(a1 + 15);
      v25 = a1;
      v26 = 0;
      goto LABEL_38;
    }

    if (v12 == 2)
    {
      v17 = 0;
    }

    else
    {
      v17 = v12 + 1;
    }

    v18 = v30[v17];
    if (v16 == v18)
    {
      if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
      {
        dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
      }

      v22 = v11 / 3;
      v28 = GEOGetGeoDisplayCoreDCELLog::log;
      if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
      {
        *buf = 67109376;
        *&buf[4] = v11 / 3;
        LOWORD(v35) = 1024;
        *(&v35 + 2) = v16;
        _os_log_impl(&dword_1B2754000, v28, OS_LOG_TYPE_INFO, "Face %d is degenerate at vertex %d.  It will be ignored.", buf, 0xEu);
      }

      v24 = *(a1 + 15);
      v25 = a1;
      v26 = 1;
      goto LABEL_38;
    }

    if (v16 >= v18)
    {
      *buf = v18 | (v16 << 32);
      v35 = v14;
      result = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,gdc::TriangularDCEL::VertexPairHash,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::equal_to<std::pair<unsigned int,unsigned int>>,gdc::TriangularDCEL::VertexPairHash,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int> const,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>(a5, v18, v16);
      if (v21)
      {
        goto LABEL_15;
      }

      if ((~*(result + 7) & 0x3FFFFFFF) == 0)
      {
        *(result + 7) = v15;
        goto LABEL_15;
      }
    }

    else
    {
      *buf = v16 | (v18 << 32);
      v35 = v15;
      result = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,gdc::TriangularDCEL::VertexPairHash,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::equal_to<std::pair<unsigned int,unsigned int>>,gdc::TriangularDCEL::VertexPairHash,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int> const,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>(a5, v16, v18);
      if (v20)
      {
        goto LABEL_15;
      }

      if ((~*(result + 6) & 0x3FFFFFFF) == 0)
      {
        *(result + 6) = v15;
        goto LABEL_15;
      }
    }

    ++v13;
LABEL_15:
    ++v12;
    v15 += 0x40000000;
    v14 += 0x4000000000000000;
  }

  while (v12 != 3);
  if (!v13)
  {
    return result;
  }

  if (v13 == 3)
  {
    v22 = v11 / 3;
    if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
    }

    v23 = GEOGetGeoDisplayCoreDCELLog::log;
    if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
    {
      *buf = 67109120;
      *&buf[4] = v11 / 3;
      _os_log_impl(&dword_1B2754000, v23, OS_LOG_TYPE_INFO, "Face %d is duplicate.  It will be ignored.", buf, 8u);
    }

    v24 = *(a1 + 15);
    v25 = a1;
    v26 = 4;
  }

  else
  {
    v22 = v11 / 3;
    if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
    {
      dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
    }

    v29 = GEOGetGeoDisplayCoreDCELLog::log;
    if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
    {
      *buf = 67109376;
      *&buf[4] = v11 / 3;
      LOWORD(v35) = 1024;
      *(&v35 + 2) = v13;
      _os_log_impl(&dword_1B2754000, v29, OS_LOG_TYPE_INFO, "Face %d has %d complex edges.  It will be ignored.", buf, 0xEu);
    }

    v24 = *(a1 + 15);
    v25 = a1;
    v26 = 2;
  }

LABEL_38:
  std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(v24, v25, v26, v22);
  return gdc::TriangularDCEL::_setBadFace(a1, v22);
}

uint64_t std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v8 = a2;
  v6 = a4;
  v7 = a3;
  if (a1)
  {
    return (*(*a1 + 48))(a1, &v8, &v7, &v6);
  }

  v5 = std::__throw_bad_function_call[abi:nn200100]();
  return std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,gdc::TriangularDCEL::VertexPairHash,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::equal_to<std::pair<unsigned int,unsigned int>>,gdc::TriangularDCEL::VertexPairHash,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int> const,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>(v5);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,gdc::TriangularDCEL::VertexPairHash,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>,std::equal_to<std::pair<unsigned int,unsigned int>>,gdc::TriangularDCEL::VertexPairHash,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int> const,std::pair<gdc::TriangularDCEL::HalfEdge,gdc::TriangularDCEL::HalfEdge>>>(void *a1, unsigned int a2, unsigned int a3)
{
  v3 = (((a2 - 0x61C8864680B583EBLL) << 6) + a3 + ((a2 - 0x61C8864680B583EBLL) >> 2) - 0x61C8864680B583EBLL) ^ (a2 - 0x61C8864680B583EBLL);
  v4 = a1[1];
  if (!*&v4)
  {
    goto LABEL_22;
  }

  v5 = vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    v6 = (((a2 - 0x61C8864680B583EBLL) << 6) + a3 + ((a2 - 0x61C8864680B583EBLL) >> 2) - 0x61C8864680B583EBLL) ^ (a2 - 0x61C8864680B583EBLL);
    if (v3 >= *&v4)
    {
      v6 = v3 % *&v4;
    }
  }

  else
  {
    v6 = v3 & (*&v4 - 1);
  }

  v7 = *(*a1 + 8 * v6);
  if (!v7 || (v8 = *v7) == 0)
  {
LABEL_22:
    operator new();
  }

  while (1)
  {
    v9 = v8[1];
    if (v9 == v3)
    {
      break;
    }

    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *&v4)
      {
        v9 %= *&v4;
      }
    }

    else
    {
      v9 &= *&v4 - 1;
    }

    if (v9 != v6)
    {
      goto LABEL_22;
    }

LABEL_21:
    v8 = *v8;
    if (!v8)
    {
      goto LABEL_22;
    }
  }

  if (*(v8 + 4) != a2 || *(v8 + 5) != a3)
  {
    goto LABEL_21;
  }

  return v8;
}

uint64_t gdc::TriangularDCEL::_setBadFace(gdc::TriangularDCEL *this, unsigned int a2)
{
  if ((((*(this + 10) - *(this + 9)) >> 2) / 3uLL) <= a2)
  {
    return 0;
  }

  v2 = *(this + 17);
  if (!v2)
  {
    goto LABEL_20;
  }

  v3 = vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
    {
      v4 = a2 % v2;
    }
  }

  else
  {
    v4 = (v2 - 1) & a2;
  }

  v6 = *(*(this + 16) + 8 * v4);
  if (!v6 || (v7 = *v6) == 0)
  {
LABEL_20:
    operator new();
  }

  while (1)
  {
    v8 = v7[1];
    if (v8 == a2)
    {
      break;
    }

    if (v3.u32[0] > 1uLL)
    {
      if (v8 >= v2)
      {
        v8 %= v2;
      }
    }

    else
    {
      v8 &= v2 - 1;
    }

    if (v8 != v4)
    {
      goto LABEL_20;
    }

LABEL_19:
    v7 = *v7;
    if (!v7)
    {
      goto LABEL_20;
    }
  }

  if (*(v7 + 4) != a2)
  {
    goto LABEL_19;
  }

  return 0;
}

void gdc::TriangularDCEL::build(uint64_t a1, void *a2)
{
  v93 = *MEMORY[0x1E69E9840];
  *(a1 + 168) = 1;
  v4 = (a1 + 24);
  v5 = *(a1 + 32) - *(a1 + 24);
  memset(__p, 0, sizeof(__p));
  if ((v5 >> 2))
  {
    std::vector<md::MapDataType>::__vallocate[abi:nn200100](__p, (v5 >> 2));
  }

  if (!(((*(a1 + 80) - *(a1 + 72)) >> 2) / 3uLL))
  {
    goto LABEL_96;
  }

  v6 = 0;
  v77 = a2;
  v78 = (a1 + 24);
  do
  {
    v82 = v6;
    isBadFace = gdc::TriangularDCEL::_isBadFace(a1, v6);
    v8 = v82;
    if (isBadFace)
    {
      goto LABEL_95;
    }

    v9 = 0;
    v81 = v82 & 0x3FFFFFFF;
    v10 = 0x3FFFFFFF;
    v11 = 1;
    v80 = 3 * v82;
    do
    {
      v12 = v9 + 1;
      v13 = (v80 + v9);
      v14 = *(a1 + 72);
      v15 = *(v14 + 4 * v13);
      if (v9 == 2)
      {
        v16 = 0;
      }

      else
      {
        v16 = v9 + 1;
      }

      v17 = *(v14 + 4 * (v16 + v80));
      ++*(2 * v15);
      if (v17 >= v15)
      {
        v18 = v15;
      }

      else
      {
        v18 = v17;
      }

      if (v15 <= v17)
      {
        v19 = v17;
      }

      else
      {
        v19 = v15;
      }

      v20 = (v19 - 0x61C8864680B583EBLL + ((v18 - 0x61C8864680B583EBLL) << 6) + ((v18 - 0x61C8864680B583EBLL) >> 2)) ^ (v18 - 0x61C8864680B583EBLL);
      v21 = a2[1];
      v22 = vcnt_s8(v21);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.u32[0] > 1uLL)
      {
        v23 = (v19 - 0x61C8864680B583EBLL + ((v18 - 0x61C8864680B583EBLL) << 6) + ((v18 - 0x61C8864680B583EBLL) >> 2)) ^ (v18 - 0x61C8864680B583EBLL);
        if (v20 >= *&v21)
        {
          v23 = v20 % *&v21;
        }
      }

      else
      {
        v23 = v20 & (*&v21 - 1);
      }

      v24 = *(*a2 + 8 * v23);
      do
      {
        do
        {
          v24 = *v24;
        }

        while (v20 != v24[1]);
      }

      while (*(v24 + 4) != v18 || *(v24 + 5) != v19);
      v26 = *(v24 + 6);
      v27 = v26 & 0x3FFFFFFF;
      if ((v26 & 0x3FFFFFFF) == v8)
      {
        v27 = *(v24 + 7) & 0x3FFFFFFF;
        v26 = *(v24 + 7);
      }

      v28 = v9 == 0;
      if (v9)
      {
        v29 = v10;
      }

      else
      {
        v29 = v27;
      }

      v85 = v29;
      v79 = v10;
      v30 = v10 != 0x3FFFFFFF && v10 == v27;
      v31 = *(*v4 + 4 * v15);
      if (v30)
      {
        v28 = 1;
      }

      v84 = v28;
      v32 = *(*v4 + 4 * v17);
      v34 = (~v31 & 0x3FFFFFFF) != 0 && v31 >> 30 == 3;
      v83 = v34;
      if (v32 >> 30 == 3 && (v32 & 0x3FFFFFFF) != 0x3FFFFFFF && v27 == 0x3FFFFFFF)
      {
        if (gdc::TriangularDCEL::_setBadFace(a1, v8))
        {
          if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
          }

          v39 = GEOGetGeoDisplayCoreDCELLog::log;
          if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
          {
            *buf = 67109376;
            *&buf[4] = v82;
            v88 = 1024;
            v89 = v17;
            _os_log_impl(&dword_1B2754000, v39, OS_LOG_TYPE_INFO, "Adding Face %d would yield complex vertex with multiple outgoing boundaries @ %d", buf, 0xEu);
          }

          std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(*(a1 + 120), a1, 3, v82);
        }

        v40 = *(*(a1 + 48) + 4 * (*(*(a1 + 24) + 4 * v17) & 0x3FFFFFFF)) & 0x3FFFFFFF;
        v41 = gdc::TriangularDCEL::_setBadFace(a1, v40);
        v8 = v82;
        if (v41)
        {
          if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
          {
            dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
          }

          v42 = GEOGetGeoDisplayCoreDCELLog::log;
          if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
          {
            *buf = 67109376;
            *&buf[4] = v40;
            v88 = 1024;
            v89 = v17;
            _os_log_impl(&dword_1B2754000, v42, OS_LOG_TYPE_INFO, "Adding Face %d would yield complex vertex with multiple outgoing boundaries @ %d", buf, 0xEu);
          }

          std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(*(a1 + 120), a1, 3, v40);
          v8 = v82;
        }
      }

      else if (v27 != 0x3FFFFFFF)
      {
        v37 = v26 & 0xC0000000 | v27;
        v38 = a1;
        v17 = (v80 + v9);
        v4 = v78;
        goto LABEL_79;
      }

      *(*a1 + 4 * v13) = ((*(a1 + 56) - *(a1 + 48)) >> 2) | 0xC0000000;
      v43 = v81 | (v9 << 30);
      v45 = *(a1 + 56);
      v44 = *(a1 + 64);
      if (v45 >= v44)
      {
        v47 = *(a1 + 48);
        v48 = (v45 - v47) >> 2;
        if ((v48 + 1) >> 62)
        {
          std::__throw_bad_array_new_length[abi:nn200100]();
        }

        v49 = v44 - v47;
        v50 = v49 >> 1;
        if (v49 >> 1 <= (v48 + 1))
        {
          v50 = v48 + 1;
        }

        if (v49 >= 0x7FFFFFFFFFFFFFFCLL)
        {
          v51 = 0x3FFFFFFFFFFFFFFFLL;
        }

        else
        {
          v51 = v50;
        }

        if (v51)
        {
          std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(v51);
        }

        *(4 * v48) = v43;
        v46 = 4 * v48 + 4;
        v52 = *(a1 + 48);
        v53 = *(a1 + 56) - v52;
        v54 = (4 * v48 - v53);
        memcpy(v54, v52, v53);
        v55 = *(a1 + 48);
        *(a1 + 48) = v54;
        *(a1 + 56) = v46;
        *(a1 + 64) = 0;
        if (v55)
        {
          operator delete(v55);
        }

        v4 = v78;
        v8 = v82;
      }

      else
      {
        *v45 = v43;
        v46 = (v45 + 1);
        v4 = v78;
      }

      *(a1 + 56) = v46;
      v37 = (((v46 - *(a1 + 48)) >> 2) - 1) | 0xC0000000;
      v38 = v4;
      a2 = v77;
LABEL_79:
      *(*v38 + 4 * v17) = v37;
      if (!v83)
      {
        *(*v4 + 4 * v15) = v81 | (v9 << 30);
      }

      v11 &= v84;
      ++v9;
      v10 = v85;
    }

    while (v12 != 3);
    if (v11)
    {
      if (gdc::TriangularDCEL::_setBadFace(a1, v8))
      {
        if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
        }

        v56 = GEOGetGeoDisplayCoreDCELLog::log;
        if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
        {
          *buf = 67109376;
          *&buf[4] = v82;
          v88 = 1024;
          v89 = v79;
          _os_log_impl(&dword_1B2754000, v56, OS_LOG_TYPE_INFO, "Opposite Winding Face detected. Faces %d and %d will be ignored.", buf, 0xEu);
        }

        std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(*(a1 + 120), a1, 5, v82);
        v4 = v78;
      }

      v57 = gdc::TriangularDCEL::_setBadFace(a1, v79);
      v8 = v82;
      if (v57)
      {
        if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
        }

        v58 = GEOGetGeoDisplayCoreDCELLog::log;
        if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
        {
          *buf = 67109376;
          *&buf[4] = v82;
          v88 = 1024;
          v89 = v79;
          _os_log_impl(&dword_1B2754000, v58, OS_LOG_TYPE_INFO, "Opposite Winding Face detected. Faces %d and %d will be ignored.", buf, 0xEu);
        }

        std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(*(a1 + 120), a1, 5, v79);
        v4 = v78;
        v8 = v82;
      }
    }

LABEL_95:
    v6 = v8 + 1;
  }

  while (v6 < (((*(a1 + 80) - *(a1 + 72)) >> 2) / 3uLL));
LABEL_96:
  v60 = *(a1 + 24);
  v59 = *(a1 + 32);
  if (((v59 - v60) & 0x3FFFFFFFCLL) != 0)
  {
    v61 = 0;
    do
    {
      v62 = *(v60 + 4 * v61);
      if ((~v62 & 0x3FFFFFFF) != 0)
      {
        v63 = 0;
        v64 = 0;
        v65 = *(v60 + 4 * v61);
        while (1)
        {
          if (gdc::TriangularDCEL::incidentFace(a1, v65) != 0x3FFFFFFF)
          {
            ++v63;
          }

          if (v64 >= 0x64)
          {
            break;
          }

          v66 = gdc::TriangularDCEL::CWHalfEdgeAroundOrigin(a1, v65);
          if (v66 != v62)
          {
            v65 = v66;
            ++v64;
            if ((v66 & 0x3FFFFFFF) != 0x3FFFFFFF)
            {
              continue;
            }
          }

          goto LABEL_115;
        }

        if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
        {
          dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
        }

        v67 = GEOGetGeoDisplayCoreDCELLog::log;
        if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_ERROR))
        {
          gdc::TriangularDCEL::HalfEdge::to_string(buf, v62);
          v68 = v90 >= 0 ? buf : *buf;
          *v91 = 136315138;
          v92 = v68;
          _os_log_impl(&dword_1B2754000, v67, OS_LOG_TYPE_ERROR, "iterating over too many half edges in walkCWEdgesIncidentToVertex incident to half edge %s", v91, 0xCu);
          if (v90 < 0)
          {
            operator delete(*buf);
          }
        }

LABEL_115:
        v60 = *(a1 + 24);
        v59 = *(a1 + 32);
      }

      else
      {
        v63 = 0;
      }

      *(2 * v61++) -= v63;
    }

    while (v61 < ((v59 - v60) >> 2));
    if (((v59 - v60) & 0x3FFFFFFFCLL) != 0)
    {
      v69 = 0;
      do
      {
        if (*(2 * v69))
        {
          v70 = *(v60 + 4 * v69);
          if ((~v70 & 0x3FFFFFFF) != 0)
          {
            v71 = 0;
            v72 = *(v60 + 4 * v69);
            while (1)
            {
              if (v72 >> 30 != 3 && (v72 & 0x3FFFFFFF) != 0x3FFFFFFF && !gdc::TriangularDCEL::_isBadFace(a1, v72 & 0x3FFFFFFF))
              {
                if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
                {
                  dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
                }

                v73 = GEOGetGeoDisplayCoreDCELLog::log;
                if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_INFO))
                {
                  *buf = 67109120;
                  *&buf[4] = v72 & 0x3FFFFFFF;
                  _os_log_impl(&dword_1B2754000, v73, OS_LOG_TYPE_INFO, "Adding Face %d would yield complex vertex", buf, 8u);
                }

                std::function<void ()(gdc::DCELBase const*,gdc::DCELBase::Warning,unsigned int)>::operator()(*(a1 + 120), a1, 3, v72 & 0x3FFFFFFF);
                gdc::TriangularDCEL::_setBadFace(a1, v72 & 0x3FFFFFFF);
              }

              if (v71 >= 0x64)
              {
                break;
              }

              v74 = gdc::TriangularDCEL::CWHalfEdgeAroundOrigin(a1, v72);
              if (v74 != v70)
              {
                v72 = v74;
                ++v71;
                if ((v74 & 0x3FFFFFFF) != 0x3FFFFFFF)
                {
                  continue;
                }
              }

              goto LABEL_141;
            }

            if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
            {
              dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
            }

            v75 = GEOGetGeoDisplayCoreDCELLog::log;
            if (os_log_type_enabled(GEOGetGeoDisplayCoreDCELLog::log, OS_LOG_TYPE_ERROR))
            {
              gdc::TriangularDCEL::HalfEdge::to_string(buf, v70);
              v76 = buf;
              if (v90 < 0)
              {
                v76 = *buf;
              }

              *v91 = 136315138;
              v92 = v76;
              _os_log_impl(&dword_1B2754000, v75, OS_LOG_TYPE_ERROR, "iterating over too many half edges in walkCWEdgesIncidentToVertex incident to half edge %s", v91, 0xCu);
              if (v90 < 0)
              {
                operator delete(*buf);
              }
            }

LABEL_141:
            v60 = *(a1 + 24);
            v59 = *(a1 + 32);
          }
        }

        ++v69;
      }

      while (v69 < ((v59 - v60) >> 2));
    }

    else
    {
      operator delete(0);
    }
  }
}

uint64_t gdc::TriangularDCEL::incidentFace(gdc::TriangularDCEL *this, unsigned int a2)
{
  v3 = a2 & 0x3FFFFFFF;
  result = 0x3FFFFFFFLL;
  if ((a2 >> 30 != 3 || v3 == 0x3FFFFFFF) && v3 != 0x3FFFFFFF && v3 <= (((*(this + 10) - *(this + 9)) >> 2) / 3uLL))
  {
    if (gdc::TriangularDCEL::_isBadFace(this, a2 & 0x3FFFFFFF))
    {
      return 0x3FFFFFFFLL;
    }

    else
    {
      return v3;
    }
  }

  return result;
}

uint64_t gdc::TriangularDCEL::CWHalfEdgeAroundOrigin(gdc::TriangularDCEL *this, const gdc::TriangularDCEL::HalfEdge *a2)
{
  v2 = 0x3FFFFFFFLL;
  if ((a2 & 0x3FFFFFFF) != 0x3FFFFFFF)
  {
    v3 = 3 * (a2 & 0x3FFFFFFF) + (a2 >> 30);
    if (a2 >> 30 == 3)
    {
      v3 = a2 & 0x3FFFFFFF;
    }

    v4 = 48;
    if (a2 >> 30 != 3)
    {
      v4 = 0;
    }

    v2 = *(*(this + v4) + 4 * v3);
  }

  return gdc::TriangularDCEL::next(this, v2);
}

uint64_t gdc::TriangularDCEL::next(gdc::TriangularDCEL *this, const gdc::TriangularDCEL::HalfEdge *a2)
{
  result = 0x3FFFFFFFLL;
  if ((a2 & 0x3FFFFFFF) != 0x3FFFFFFF)
  {
    if (a2 >> 30 == 3)
    {
      return *(*(this + 3) + 4 * gdc::TriangularDCEL::originVertex(this, *(*(this + 6) + 4 * (a2 & 0x3FFFFFFF))));
    }

    else
    {
      if (a2 >= 0)
      {
        v4 = 0x40000000;
      }

      else
      {
        v4 = 0x80000000;
      }

      return v4 + a2;
    }
  }

  return result;
}

uint64_t gdc::TriangularDCEL::originVertex(gdc::TriangularDCEL *this, const gdc::TriangularDCEL::HalfEdge *a2)
{
  v3 = a2 & 0x3FFFFFFF;
  if (a2 >> 30 != 3 || v3 == 0x3FFFFFFF)
  {
    v5 = 3 * v3 + (a2 >> 30);
  }

  else
  {
    v4 = gdc::TriangularDCEL::next(this, *(*(this + 6) + 4 * v3));
    v5 = v4 & 0x3FFFFFFF;
    if ((v4 & 0x3FFFFFFF) == 0x3FFFFFFF || v4 >> 30 != 3)
    {
      v5 = 3 * v5 + (v4 >> 30);
    }
  }

  return *(*(this + 9) + 4 * v5);
}

uint64_t gdc::TriangularDCEL::twin(uint64_t a1, unsigned int a2)
{
  v2 = 0x3FFFFFFFLL;
  if ((a2 & 0x3FFFFFFF) != 0x3FFFFFFF)
  {
    v3 = 3 * (a2 & 0x3FFFFFFF) + (a2 >> 30);
    if (a2 >> 30 == 3)
    {
      v3 = a2 & 0x3FFFFFFF;
    }

    v4 = 48;
    if (a2 >> 30 != 3)
    {
      v4 = 0;
    }

    return *(*(a1 + v4) + 4 * v3);
  }

  return v2;
}

uint64_t gdc::TriangularDCEL::outerComponent(gdc::TriangularDCEL *this, unsigned int a2)
{
  result = 0x3FFFFFFFLL;
  if (a2 != 0x3FFFFFFF && (((*(this + 10) - *(this + 9)) >> 2) / 3uLL) >= a2)
  {
    if (gdc::TriangularDCEL::_isBadFace(this, a2))
    {
      return 0x3FFFFFFFLL;
    }

    else
    {
      return a2 & 0x3FFFFFFF;
    }
  }

  return result;
}

void dumpGraph(void *a1, const std::string ***a2, uint64_t a3)
{
  if (a3)
  {
    v6 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "subgraph n_", 11);
    v7 = 0x9DDFEA08EB382D69 * ((8 * (*a3 & 0x1FFFFFFFLL) + 8) ^ HIDWORD(*a3));
    MEMORY[0x1B8C61CB0](v6, 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (HIDWORD(*a3) ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (HIDWORD(*a3) ^ (v7 >> 47) ^ v7)) >> 47)));
    v8 = *(*a3 + 95);
    if (v8 < 0)
    {
      v8 = *(*a3 + 80);
    }

    if (v8)
    {
      v9 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "[", 1);
      v10 = *(*a3 + 95);
      if (v10 >= 0)
      {
        v11 = *a3 + 72;
      }

      else
      {
        v11 = *(*a3 + 72);
      }

      if (v10 >= 0)
      {
        v12 = *(*a3 + 95);
      }

      else
      {
        v12 = *(*a3 + 80);
      }

      v13 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v9, v11, v12);
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v13, "]", 1);
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "\ndirection LR\n", 14);
  }

  v44 = a3;
  v14 = *a2;
  v15 = a2[1];
  if (*a2 != v15)
  {
    while (1)
    {
      v16 = 0x9DDFEA08EB382D69 * ((8 * (*v14 & 0x1FFFFFFF) + 8) ^ (*v14 >> 32));
      std::to_string(&v45, 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v16 >> 47) ^ v16)) ^ ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v16 >> 47) ^ v16)) >> 47)));
      v17 = std::string::insert(&v45, 0, "n_", 2uLL);
      v18 = v17->__r_.__value_.__r.__words[2];
      *&v46.__r_.__value_.__l.__data_ = *&v17->__r_.__value_.__l.__data_;
      v46.__r_.__value_.__r.__words[2] = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v45.__r_.__value_.__l.__data_);
      }

      v19 = *v14;
      if ((SHIBYTE((*v14)[3].__r_.__value_.__r.__words[2]) & 0x8000000000000000) == 0)
      {
        break;
      }

      if (v19[3].__r_.__value_.__l.__size_)
      {
        goto LABEL_18;
      }

LABEL_19:
      v20 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "n_", 2);
      v21 = 0x9DDFEA08EB382D69 * ((8 * (*v14 & 0x1FFFFFFF) + 8) ^ (*v14 >> 32));
      MEMORY[0x1B8C61CB0](v20, 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v21 >> 47) ^ v21)) ^ ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v21 >> 47) ^ v21)) >> 47)));
      v22 = *v14;
      if ((SHIBYTE((*v14)[3].__r_.__value_.__r.__words[2]) & 0x8000000000000000) != 0)
      {
        if (v22[3].__r_.__value_.__l.__size_)
        {
LABEL_25:
          if (LODWORD(v22[2].__r_.__value_.__r.__words[2]))
          {
            v23 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "([", 2);
            v24 = SHIBYTE((*v14)[3].__r_.__value_.__r.__words[2]);
            if (v24 >= 0)
            {
              data = &(*v14)[3];
            }

            else
            {
              data = (*v14)[3].__r_.__value_.__l.__data_;
            }

            if (v24 >= 0)
            {
              size = HIBYTE((*v14)[3].__r_.__value_.__r.__words[2]);
            }

            else
            {
              size = (*v14)[3].__r_.__value_.__l.__size_;
            }

            v27 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v23, data, size);
            v28 = "])";
            v29 = 2;
          }

          else
          {
            v30 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "[", 1);
            v31 = SHIBYTE((*v14)[3].__r_.__value_.__r.__words[2]);
            if (v31 >= 0)
            {
              v32 = &(*v14)[3];
            }

            else
            {
              v32 = (*v14)[3].__r_.__value_.__l.__data_;
            }

            if (v31 >= 0)
            {
              v33 = HIBYTE((*v14)[3].__r_.__value_.__r.__words[2]);
            }

            else
            {
              v33 = (*v14)[3].__r_.__value_.__l.__size_;
            }

            v27 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v30, v32, v33);
            v28 = "]";
            v29 = 1;
          }

          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v27, v28, v29);
        }
      }

      else if (*(&(*v14)[3].__r_.__value_.__s + 23))
      {
        goto LABEL_25;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "\n", 1);
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v46.__r_.__value_.__l.__data_);
      }

      if (++v14 == v15)
      {
        v14 = *a2;
        v15 = a2[1];
        goto LABEL_45;
      }
    }

    if (!*(&(*v14)[3].__r_.__value_.__s + 23))
    {
      goto LABEL_19;
    }

LABEL_18:
    std::string::operator=(&v46, v19 + 3);
    goto LABEL_19;
  }

LABEL_45:
  while (v14 != v15)
  {
    v34 = *v14;
    if ((*v14)[4].__r_.__value_.__l.__size_ != (*v14)[4].__r_.__value_.__r.__words[2])
    {
      v35 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "n_", 2);
      v36 = 0x9DDFEA08EB382D69 * ((8 * (*v14 & 0x1FFFFFFF) + 8) ^ (*v14 >> 32));
      v37 = MEMORY[0x1B8C61CB0](v35, 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v36 >> 47) ^ v36)) ^ ((0x9DDFEA08EB382D69 * ((*v14 >> 32) ^ (v36 >> 47) ^ v36)) >> 47)));
      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v37, "--> ", 4);
      v38 = (*v14)[4].__r_.__value_.__l.__size_;
      v39 = (*v14)[4].__r_.__value_.__r.__words[2];
      while (v38 != v39)
      {
        v40 = *v38;
        v41 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "n_", 2);
        v42 = 0x9DDFEA08EB382D69 * ((8 * (v40 & 0x1FFFFFFF) + 8) ^ HIDWORD(v40));
        v43 = 0x9DDFEA08EB382D69 * (HIDWORD(v40) ^ (v42 >> 47) ^ v42);
        MEMORY[0x1B8C61CB0](v41, 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47)));
        if (*((*v14)[4].__r_.__value_.__r.__words[2] - 8) != v40)
        {
          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, " & ", 3);
        }

        ++v38;
      }

      std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "\n", 1);
      v34 = *v14;
    }

    if (LODWORD(v34[2].__r_.__value_.__r.__words[2]) == 3)
    {
      dumpGraph(a1, v34->__r_.__value_.__r.__words[0], v14);
    }

    ++v14;
  }

  if (v44)
  {
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(a1, "end\n", 4);
  }
}

void *std::vector<gdc::FlowExecutionNode>::vector[abi:nn200100](void *result, void *a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  v2 = a2[1];
  if (v2 != *a2)
  {
    std::vector<gdc::FlowExecutionNode>::__vallocate[abi:nn200100](result, (v2 - *a2) >> 4);
  }

  return result;
}

void std::vector<gdc::FlowExecutionNode>::__vallocate[abi:nn200100](uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 60))
  {
    std::__allocate_at_least[abi:nn200100]<std::allocator<mre::TextureHandle>>(a2);
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn200100]<std::__wrap_iter<gdc::LogicExecutionNode *> &,std::__wrap_iter<gdc::LogicExecutionNode *> &>(uint64_t a1, __int128 *a2)
{
  *v15 = *a1;
  *&v15[9] = *(a1 + 9);
  v4 = *(a1 + 32);
  v5 = *(a1 + 48);
  *(a1 + 32) = 0;
  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  v6 = (a1 + 56);
  v13 = v4;
  v14 = *(a1 + 56);
  v7 = *(a1 + 72);
  *(a1 + 56) = 0;
  *(a1 + 64) = 0;
  *(a1 + 72) = 0;
  v8 = *a2;
  *(a1 + 9) = *(a2 + 9);
  *a1 = v8;
  *(a1 + 32) = a2[2];
  *(a1 + 48) = *(a2 + 6);
  *(a2 + 4) = 0;
  *(a2 + 5) = 0;
  *(a2 + 6) = 0;
  v9 = *(a1 + 56);
  if (v9)
  {
    *(a1 + 64) = v9;
    operator delete(v9);
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
  }

  *(a1 + 56) = *(a2 + 56);
  *(a1 + 72) = *(a2 + 9);
  *(a2 + 7) = 0;
  *(a2 + 8) = 0;
  *(a2 + 9) = 0;
  *a2 = *v15;
  *(a2 + 9) = *&v15[9];
  v10 = *(a2 + 4);
  if (v10)
  {
    *(a2 + 5) = v10;
    operator delete(v10);
    v11 = *(a2 + 7);
    a2[2] = v13;
    *(a2 + 6) = v5;
    if (v11)
    {
      *(a2 + 8) = v11;
      operator delete(v11);
    }
  }

  else
  {
    a2[2] = v13;
    *(a2 + 6) = v5;
  }

  result = v14;
  *(a2 + 56) = v14;
  *(a2 + 9) = v7;
  return result;
}

std::string *gdc::NonFlatTileSelector::createDebugNode@<X0>(std::string *a1@<X8>)
{
  strcpy(v2, "Non Flat Tile Selector");
  BYTE7(v2[1]) = 22;
  return gdc::DebugTreeNode::DebugTreeNode(a1, v2);
}

void gdc::NonFlatTileSelector::~NonFlatTileSelector(gdc::NonFlatTileSelector *this)
{
  gdc::NonFlatTileSelector::~NonFlatTileSelector(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A602C8;
  v2 = this + 48;
  std::__function::__value_func<float ()(void)>::~__value_func[abi:nn200100](this + 224);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 25);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 160);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 16);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 88);
  std::__function::__value_func<std::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__value_func[abi:nn200100](v2);
}

void gdc::LayerDataCollector::addFallbackData(uint64_t a1, uint64_t a2, __int16 *a3, void *a4)
{
  v8 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>((a1 + 48), a2);
  if (v8)
  {
    v38 = v8[16];
  }

  else
  {
    v9 = *(a2 + 8);
    v10 = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[]((a1 + 24), v9);
    v38 = 0x8E38E38E38E38E39 * ((*(v10 + 1) - *v10) >> 4);
    v11 = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[]((a1 + 24), v9);
    v12 = v11;
    if (*a4)
    {
      v13 = 3;
    }

    else
    {
      v13 = 0;
    }

    v37 = v13;
    v36 = 1;
    v14 = *(v11 + 1);
    v15 = *(v12 + 2);
    if (v14 >= v15)
    {
      v17 = 0x8E38E38E38E38E39 * ((v14 - *v12) >> 4);
      v18 = v17 + 1;
      if (v17 + 1 > 0x1C71C71C71C71C7)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v19 = 0x8E38E38E38E38E39 * ((v15 - *v12) >> 4);
      if (2 * v19 > v18)
      {
        v18 = 2 * v19;
      }

      if (v19 >= 0xE38E38E38E38E3)
      {
        v20 = 0x1C71C71C71C71C7;
      }

      else
      {
        v20 = v18;
      }

      v31 = v12;
      if (v20)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::LayerDataHolder>>(v20);
      }

      v21 = 144 * v17;
      std::construct_at[abi:nn200100]<gdc::LayerDataHolder,gdc::LayerDataRequestKey const&,std::shared_ptr<gdc::LayerData> const&,gdc::LayerDataStatus,BOOL,gdc::LayerDataHolder*>(v21, a2, a4, &v37, &v36);
      v16 = v21 + 144;
      v22 = *(v12 + 1);
      v23 = v21 + *v12 - v22;
      std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::LayerDataHolder>,gdc::LayerDataHolder*>(*v12, v22, v23);
      v24 = *v12;
      *v12 = v23;
      v28[0] = v24;
      v28[1] = v24;
      *(v12 + 1) = v21 + 144;
      v29 = v24;
      v25 = *(v12 + 2);
      *(v12 + 2) = 0;
      v30 = v25;
      std::__split_buffer<gdc::LayerDataHolder>::~__split_buffer(v28);
    }

    else
    {
      v16 = std::construct_at[abi:nn200100]<gdc::LayerDataHolder,gdc::LayerDataRequestKey const&,std::shared_ptr<gdc::LayerData> const&,gdc::LayerDataStatus,BOOL,gdc::LayerDataHolder*>(v14, a2, a4, &v37, &v36) + 144;
    }

    *(v12 + 1) = v16;
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,unsigned long>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,unsigned long>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,unsigned long>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,unsigned long>>>::__emplace_unique_key_args<gdc::LayerDataRequestKey,gdc::LayerDataRequestKey const&,unsigned long &>((a1 + 48), a2);
  }

  gdc::LayerDataRequestKey::LayerDataRequestKey(v28, a2);
  v33 = *(a3 + 2);
  v32 = *a3;
  v34 = *(a3 + 2);
  v35 = *(a3 + 24);
  v26 = *(a1 + 8);
  if (v26 >= *(a1 + 16))
  {
    v27 = std::vector<gdc::LayerDataIndex>::__emplace_back_slow_path<gdc::LayerKeyPair &,unsigned long &>(a1, v28, &v38);
  }

  else
  {
    v27 = std::construct_at[abi:nn200100]<gdc::LayerDataIndex,gdc::LayerKeyPair &,unsigned long &,gdc::LayerDataIndex*>(v26, v28, &v38) + 152;
  }

  *(a1 + 8) = v27;
  if (v29 != v31)
  {
    free(v29);
  }
}

uint64_t std::construct_at[abi:nn200100]<gdc::LayerDataHolder,gdc::LayerDataRequestKey const&,std::shared_ptr<gdc::LayerData> const&,gdc::LayerDataStatus,BOOL,gdc::LayerDataHolder*>(uint64_t a1, uint64_t a2, void *a3, int *a4, char *a5)
{
  gdc::LayerDataRequestKey::LayerDataRequestKey(v14, a2);
  v9 = *a4;
  v10 = *a5;
  *a1 = v14[0];
  *(a1 + 8) = v15;
  *(a1 + 16) = a1 + 48;
  *(a1 + 24) = a1 + 48;
  *(a1 + 32) = a1 + 48;
  *(a1 + 40) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>((a1 + 16), v16, v17);
  v11 = v20;
  *(a1 + 80) = v19;
  *(a1 + 96) = v11;
  v12 = a3[1];
  *(a1 + 112) = *a3;
  *(a1 + 120) = v12;
  if (v12)
  {
    atomic_fetch_add_explicit((v12 + 8), 1uLL, memory_order_relaxed);
  }

  *(a1 + 128) = v9;
  *(a1 + 132) = v10;
  *(a1 + 136) = 0;
  if (v16 != v18)
  {
    free(v16);
  }

  return a1;
}

BOOL gdc::LayerDataCollector::hasData(unsigned __int16 **this, unsigned __int16 a2, unint64_t a3)
{
  v4 = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[](this + 3, a2);
  if (0x8E38E38E38E38E39 * ((*(v4 + 1) - *v4) >> 4) <= a3)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  return *(*v4 + 144 * a3 + 112) != 0;
}

uint64_t gdc::LayerDataCollector::isFallbackData(void *a1, uint64_t a2)
{
  v4 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>(a1 + 6, a2);
  if (v4)
  {
    v5 = v4[16];
    v7 = a1[3];
    v6 = a1[4];
    if (v7 != v6)
    {
      while (*v7 != *(a2 + 8))
      {
        v7 += 16;
        if (v7 == v6)
        {
          goto LABEL_8;
        }
      }

      v6 = v7;
    }

LABEL_8:
    v10 = v6 + 4;
    v9 = *(v6 + 1);
    if (0x8E38E38E38E38E39 * ((*(v10 + 1) - v9) >> 4) <= v5)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = *(v9 + 144 * v5 + 132);
  }

  else
  {
    v8 = 0;
  }

  return v8 & 1;
}

void *gdc::LayerDataCollector::setHasLayerDataDependency(gdc::LayerDataCollector *this, const gdc::LayerDataRequestKey *a2)
{
  result = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>(this + 6, a2);
  if (result)
  {
    v5 = result[16];
    result = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[](this + 3, *(a2 + 4));
    if (0x8E38E38E38E38E39 * ((result[1] - *result) >> 4) <= v5)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    *(*result + 144 * v5 + 136) |= 1uLL;
  }

  return result;
}

void *gdc::LayerDataCollector::setHasLayerDataDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>((a1 + 48), a2);
  if (result)
  {
    v7 = result[16];
    result = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[]((a1 + 24), *(a2 + 8));
    if (0x8E38E38E38E38E39 * ((result[1] - *result) >> 4) <= v7)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    *(*result + 144 * v7 + 136) |= a3;
  }

  return result;
}

unint64_t gdc::LayerDataCollector::getExternalDependencyBitfield(gdc::LayerDataCollector *this, gdc::LayerDataCollector *a2, int a3, unint64_t a4)
{
  while (this != a2)
  {
    if (*this == a3)
    {
      a2 = this;
      break;
    }

    this = (this + 32);
  }

  v4 = *(a2 + 1);
  if (0x8E38E38E38E38E39 * ((*(a2 + 2) - v4) >> 4) <= a4)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  return v4 + 144 * a4 + 136;
}

void gdc::LayerDataCollector::virtualTilesReferencingKey(uint64_t *a1, unsigned __int8 *a2, uint64_t *a3)
{
  a3[1] = *a3;
  v4 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    do
    {
      if (*v4 == *a2 && *(v4 + 4) == *(a2 + 4) && gdc::GenericKey::operator==((v4 + 16), (a2 + 16)))
      {
        v23 = *(v4 + 116);
        v22[0] = *(v4 + 56);
        v24 = *(v4 + 16);
        v25 = v4[136];
        for (i = *a1; i != v3; i += 152)
        {
          if (geo::QuadTile::operator==((i + 112), v22))
          {
            gdc::VirtualTileIterator::VirtualTileIterator(&v20, i, a1[1]);
            v10 = a3[1];
            v9 = a3[2];
            if (v10 >= v9)
            {
              v13 = *a3;
              v14 = v10 - *a3;
              v15 = 0xAAAAAAAAAAAAAAABLL * (v14 >> 3) + 1;
              if (v15 > 0xAAAAAAAAAAAAAAALL)
              {
                std::__throw_bad_array_new_length[abi:nn200100]();
              }

              v16 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v13) >> 3);
              if (2 * v16 > v15)
              {
                v15 = 2 * v16;
              }

              if (v16 >= 0x555555555555555)
              {
                v17 = 0xAAAAAAAAAAAAAAALL;
              }

              else
              {
                v17 = v15;
              }

              if (v17)
              {
                if (v17 <= 0xAAAAAAAAAAAAAAALL)
                {
                  operator new();
                }

                std::__throw_bad_array_new_length[abi:nn200100]();
              }

              v18 = 8 * (v14 >> 3);
              *v18 = v20;
              *(v18 + 16) = v21;
              v12 = v18 + 24;
              v19 = v18 - v14;
              memcpy((v18 - v14), v13, v14);
              *a3 = v19;
              a3[1] = v12;
              a3[2] = 0;
              if (v13)
              {
                operator delete(v13);
              }
            }

            else
            {
              v11 = v20;
              *(v10 + 16) = v21;
              *v10 = v11;
              v12 = v10 + 24;
            }

            a3[1] = v12;
            v3 = a1[1];
            break;
          }

          v3 = a1[1];
        }
      }

      v4 += 152;
    }

    while (v4 != v3);
  }
}

uint64_t gdc::LayerDataCollector::dataHolders(unsigned __int16 **this, unsigned __int16 a2)
{
  v4 = *geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[](this + 3, a2);
  geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[](this + 3, a2);
  return v4;
}

void gdc::FlatTileSelector::createDebugNode(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:nn200100]<0>(&v19, "Flat Tile Selector");
  gdc::DebugTreeNode::DebugTreeNode(a2, &v19);
  if (v20 < 0)
  {
    operator delete(v19);
  }

  std::string::basic_string[abi:nn200100]<0>(&v19, "Lod Bias");
  v4 = *(a1 + 16);
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v18 = 2;
  v14 = v4;
  gdc::DebugTreeNode::addProperty(a2, &v19, v13);
  if (v20 < 0)
  {
    operator delete(v19);
  }

  std::string::basic_string[abi:nn200100]<0>(&v19, "Desired Tile Area");
  v5 = (*(a1 + 8) * *(a1 + 8));
  v6 = exp2(*(a1 + 16) * -2.0 + 1.98);
  v10 = 0;
  v11 = 0;
  v9 = 0;
  v12 = 2;
  v8 = v6 * v5;
  gdc::DebugTreeNode::addProperty(a2, &v19, v7);
  if (v20 < 0)
  {
    operator delete(v19);
  }
}

void gdc::FlatTileSelector::~FlatTileSelector(gdc::FlatTileSelector *this)
{
  *this = &unk_1F2A602F8;
  v2 = *(this + 3);
  if (v2)
  {
    *(this + 4) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A602F8;
  v2 = *(this + 3);
  if (v2)
  {
    *(this + 4) = v2;
    operator delete(v2);
  }
}

const char *gdc::DCELBase::stringForWarning(int a1)
{
  if ((a1 - 1) > 5)
  {
    return "invalid vertex";
  }

  else
  {
    return off_1E7B58660[a1 - 1];
  }
}

void gdc::LayerDataStore::remove(void *a1, unsigned __int8 *a2)
{
  v3 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>(a1 + 3, a2);
  if (v3)
  {
    v4 = v3;
    v5 = v3[16];
    v6 = v5[18];
    v7 = a1[8];
    v8 = a1[9];
    v9 = v8 >= v6;
    v10 = v8 - v6;
    if (!v9)
    {
      v10 = 0;
    }

    a1[9] = v10;
    if (v7 == v5)
    {
      a1[8] = v7[1];
    }

    v11 = v3[16];
    v13 = *v11;
    v12 = v11[1];
    *(v13 + 8) = v12;
    *v12 = v13;
    --a1[2];
    std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>,0>(v11 + 2);
    operator delete(v11);

    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,ecs2::Entity>>>>::erase(a1 + 3, v4);
  }
}

void gdc::LayerDataStore::pending(gdc::LayerDataStore *this, uint64_t a2)
{
  std::mutex::lock((a2 + 80));
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  v4 = *(a2 + 168);
  if (v4)
  {
    if (!(v4 >> 57))
    {
      v27 = this;
      std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>(v4);
    }

LABEL_28:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  for (i = *(a2 + 160); i; i = *i)
  {
    gdc::LayerDataRequestKey::LayerDataRequestKey(&v23, (i + 2));
    v6 = i[17];
    v31 = i[16];
    v32 = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    v8 = *(this + 1);
    v7 = *(this + 2);
    if (v8 >= v7)
    {
      v12 = (v8 - *this) >> 7;
      if ((v12 + 1) >> 57)
      {
        goto LABEL_28;
      }

      v13 = v7 - *this;
      v14 = v13 >> 6;
      if (v13 >> 6 <= (v12 + 1))
      {
        v14 = v12 + 1;
      }

      if (v13 >= 0x7FFFFFFFFFFFFF80)
      {
        v15 = 0x1FFFFFFFFFFFFFFLL;
      }

      else
      {
        v15 = v14;
      }

      v33[4] = this;
      if (v15)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>(v15);
      }

      v16 = v12 << 7;
      *v16 = v23;
      v17 = v24;
      *(v16 + 16) = v16 + 48;
      *(v16 + 8) = v17;
      *(v16 + 24) = v16 + 48;
      *(v16 + 32) = v16 + 48;
      *(v16 + 40) = 32;
      geo::small_vector_base<unsigned char>::append<unsigned char const*>((v16 + 16), v25, v26);
      *(v16 + 80) = v28;
      *(v16 + 96) = v29;
      *(v16 + 104) = v30;
      *(v16 + 112) = v31;
      v18 = v32;
      *(v16 + 120) = v32;
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v11 = v16 + 128;
      v19 = *(this + 1);
      v20 = v16 + *this - v19;
      std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>,std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>*>(*this, v19, v20);
      v21 = *this;
      *this = v20;
      *(this + 1) = v16 + 128;
      v22 = *(this + 2);
      *(this + 2) = 0;
      v33[2] = v21;
      v33[3] = v22;
      v33[0] = v21;
      v33[1] = v21;
      std::__split_buffer<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>::~__split_buffer(v33);
    }

    else
    {
      *v8 = v23;
      v9 = v24;
      *(v8 + 16) = v8 + 48;
      *(v8 + 8) = v9;
      *(v8 + 24) = v8 + 48;
      *(v8 + 32) = v8 + 48;
      *(v8 + 40) = 32;
      geo::small_vector_base<unsigned char>::append<unsigned char const*>((v8 + 16), v25, v26);
      *(v8 + 80) = v28;
      *(v8 + 96) = v29;
      *(v8 + 104) = v30;
      *(v8 + 112) = v31;
      v10 = v32;
      *(v8 + 120) = v32;
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      v11 = v8 + 128;
    }

    *(this + 1) = v11;
    if (v32)
    {
      std::__shared_weak_count::__release_shared[abi:nn200100](v32);
    }

    if (v25 != v27)
    {
      free(v25);
    }
  }

  std::mutex::unlock((a2 + 80));
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>(unint64_t a1)
{
  if (!(a1 >> 57))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

void std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>,std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>*>(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v5 = a1;
    v6 = a1;
    do
    {
      gdc::LayerDataRequestKey::LayerDataRequestKey(a3, v6);
      *(a3 + 112) = *(v6 + 112);
      *(v6 + 112) = 0;
      *(v6 + 120) = 0;
      v6 += 128;
      a3 += 128;
    }

    while (v6 != a2);
    do
    {
      std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>,0>(v5);
      v5 += 16;
    }

    while (v5 != a2);
  }
}

uint64_t std::__split_buffer<std::pair<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 128;
    std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>,0>((i - 128));
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void gdc::LayerDataStore::createDebugNode(std::string *a1, uint64_t a2)
{
  std::string::basic_string[abi:nn200100]<0>(__p, "Layer Data Store");
  gdc::DebugTreeNode::DebugTreeNode(a1, __p);
  if (v8 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:nn200100]<0>(__p, "Size");
  v4 = *(a2 + 48);
  v16 = 0;
  v17 = 0;
  v18 = 1;
  v15 = 0;
  v14 = v4;
  gdc::DebugTreeNode::addProperty(a1, __p, v13);
  if (v8 < 0)
  {
    operator delete(__p[0]);
  }

  std::string::basic_string[abi:nn200100]<0>(__p, "Data");
  ChildNode = gdc::DebugTreeNode::createChildNode(a1, __p);
  if (v8 < 0)
  {
    operator delete(__p[0]);
  }

  for (i = *(a2 + 8); i != a2; i = *(i + 8))
  {
    (*(**(i + 128) + 24))(__p);
    gdc::DebugTreeNode::addChildNode(ChildNode, __p);
    v19 = &v12;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v19);
    v19 = &v11;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v19);
    if (v10 < 0)
    {
      operator delete(v9);
    }

    if (v8 < 0)
    {
      operator delete(__p[0]);
    }
  }
}

void gdc::ResourceStore::erase(int8x8_t *this, const gdc::ResourceKey *a2)
{
  v4 = this[34];
  if (v4)
  {
    v5 = *a2;
    v6 = *(a2 + 1);
    v7 = (v6 + ((v5 - 0x61C8864680B583EBLL) << 6) + ((v5 - 0x61C8864680B583EBLL) >> 2) - 0x61C8864680B583EBLL) ^ (v5 - 0x61C8864680B583EBLL);
    v8 = (*(a2 + 9) + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
    v9 = vcnt_s8(v4);
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      v11 = (*(a2 + 9) + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
      if (v8 >= *&v4)
      {
        v11 = v8 % *&v4;
      }
    }

    else
    {
      v11 = (*&v4 - 1) & v8;
    }

    v12 = *(*&this[33] + 8 * v11);
    if (v12)
    {
      for (i = *v12; i; i = *i)
      {
        v14 = i[1];
        if (v14 == v8)
        {
          if (*(i + 16) == v5 && *(i + 9) == v6 && gdc::GenericKey::operator==((i + 3), a2 + 8))
          {
            std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::remove(v26, &this[33], i);
            std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,void *>>>>::~unique_ptr[abi:nn200100](v26);
            break;
          }
        }

        else
        {
          if (v10 > 1)
          {
            if (v14 >= *&v4)
            {
              v14 %= *&v4;
            }
          }

          else
          {
            v14 &= *&v4 - 1;
          }

          if (v14 != v11)
          {
            break;
          }
        }
      }
    }
  }

  v15 = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(&this[46], a2);
  if (v15)
  {
    v16 = v15;
    v17 = v15[14];
    v18 = v17[16];
    v19 = this[51];
    v20 = this[52];
    v21 = *&v20 >= v18;
    v22 = (*&v20 - v18);
    if (!v21)
    {
      v22 = 0;
    }

    this[52] = v22;
    if (v19 == v17)
    {
      this[51] = *(*&v19 + 8);
    }

    v23 = v15[14];
    v25 = *v23;
    v24 = v23[1];
    *(v25 + 8) = v24;
    *v24 = v25;
    --*&this[45];
    std::__destroy_at[abi:nn200100]<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>,0>(v23 + 2);
    operator delete(v23);

    std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>>>::erase(&this[46], v16);
  }
}

uint64_t gdc::ResourceStore::clearFailedResources(gdc::ResourceStore *this)
{
  memset(v14, 0, sizeof(v14));
  v15 = 1065353216;
  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__rehash<true>(v12, *(this + 41));
  for (i = *(this + 40); i; i = *i)
  {
    std::pair<gdc::ResourceKey const,gdc::Error>::pair[abi:nn200100](v5, (i + 2));
    std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::__emplace_unique_key_args<gdc::ResourceKey,gdc::ResourceKey const&>(v12, v5);
    if (v11 < 0)
    {
      operator delete(__p);
    }

    if (v9 < 0)
    {
      operator delete(v8);
    }

    if (v6 != v7)
    {
      free(v6);
    }
  }

  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::clear(this + 304);
  v3 = *(this + 11);
  if (v3)
  {
    (*(*v3 + 48))(v3, v12);
  }

  std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(v12);
  return std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(v14);
}

void std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::clear(uint64_t a1)
{
  if (*(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::__deallocate_node(*(a1 + 16));
    *(a1 + 16) = 0;
    v2 = *(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        *(*a1 + 8 * i) = 0;
      }
    }

    *(a1 + 24) = 0;
  }
}

uint64_t std::pair<gdc::ResourceKey const,gdc::Error>::pair[abi:nn200100](uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = a1 + 40;
  *(a1 + 16) = a1 + 40;
  *(a1 + 24) = a1 + 40;
  *(a1 + 32) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>((a1 + 8), *(a2 + 8), *(a2 + 16));
  *(a1 + 72) = *(a2 + 72);
  *(a1 + 80) = *(a2 + 80);
  *(a1 + 96) = *(a2 + 96);
  if (*(a2 + 127) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 104), *(a2 + 104), *(a2 + 112));
  }

  else
  {
    v4 = *(a2 + 104);
    *(a1 + 120) = *(a2 + 120);
    *(a1 + 104) = v4;
  }

  if (*(a2 + 151) < 0)
  {
    std::string::__init_copy_ctor_external((a1 + 128), *(a2 + 128), *(a2 + 136));
  }

  else
  {
    v5 = *(a2 + 128);
    *(a1 + 144) = *(a2 + 144);
    *(a1 + 128) = v5;
  }

  return a1;
}

void std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::__deallocate_node(void **__p)
{
  if (__p)
  {
    v1 = __p;
    do
    {
      v2 = *v1;
      if (*(v1 + 167) < 0)
      {
        operator delete(v1[18]);
      }

      if (*(v1 + 143) < 0)
      {
        operator delete(v1[15]);
      }

      v3 = v1[3];
      if (v3 != v1[5])
      {
        free(v3);
      }

      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

uint64_t gdc::ResourceStore::clearAllResources(gdc::ResourceStore *this)
{
  memset(v18, 0, sizeof(v18));
  v19 = 1065353216;
  v2 = (this + 344);
  std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__rehash<true>(v18, (*(this + 41) + *(this + 49)));
  for (i = *(this + 40); i; i = *i)
  {
    std::pair<gdc::ResourceKey const,gdc::Error>::pair[abi:nn200100](v11, (i + 2));
    std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::__emplace_unique_key_args<gdc::ResourceKey,gdc::ResourceKey const&>(v18, v11);
    if (v17 < 0)
    {
      operator delete(__p);
    }

    if (v15 < 0)
    {
      operator delete(v14);
    }

    if (v12 != v13)
    {
      free(v12);
    }
  }

  for (j = *(this + 44); j != v2; j = *(j + 8))
  {
    std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::__emplace_unique_key_args<gdc::ResourceKey,gdc::ResourceKey const&>(v18, (j + 16));
  }

  if (*(this + 36))
  {
    std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>>>::__deallocate_node(*(this + 35));
    *(this + 35) = 0;
    v5 = *(this + 34);
    if (v5)
    {
      for (k = 0; k != v5; ++k)
      {
        *(*(this + 33) + 8 * k) = 0;
      }
    }

    *(this + 36) = 0;
  }

  std::__list_imp<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry>>::clear(v2);
  if (*(this + 49))
  {
    std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>>>::__deallocate_node(*(this + 48));
    *(this + 48) = 0;
    v7 = *(this + 47);
    if (v7)
    {
      for (m = 0; m != v7; ++m)
      {
        *(*(this + 46) + 8 * m) = 0;
      }
    }

    *(this + 49) = 0;
  }

  *(this + 51) = v2;
  *(this + 52) = 0;
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::clear(this + 304);
  v9 = *(this + 11);
  if (v9)
  {
    (*(*v9 + 48))(v9, v18);
  }

  return std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(v18);
}

void std::__list_imp<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    v2 = a1[1];
    v3 = *(*a1 + 8);
    v4 = *v2;
    *(v4 + 8) = v3;
    *v3 = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = v2[1];
        std::__destroy_at[abi:nn200100]<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>,0>(v2 + 2);
        operator delete(v2);
        v2 = v5;
      }

      while (v5 != a1);
    }
  }
}

void std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *v1;
      std::__destroy_at[abi:nn200100]<std::pair<gdc::ResourceKey const,std::weak_ptr<gdc::Resource>>,0>(v1 + 2);
      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

void gdc::ResourceStore::clearResources(void *a1, uint64_t a2)
{
  v4 = a1[35];
  while (1)
  {
    if (!v4)
    {
      v36 = 0u;
      v37 = 0u;
      v38 = 1065353216;
      v18 = a1[40];
      if (!v18)
      {
LABEL_54:
        std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(&v36);
        return;
      }

      while (1)
      {
        v19 = *(a2 + 24);
        if (!v19)
        {
          goto LABEL_55;
        }

        if ((*(*v19 + 48))(v19, v18 + 16))
        {
          break;
        }

        v23 = *v18;
LABEL_50:
        v18 = v23;
        if (!v23)
        {
          v32 = a1[11];
          if (v32 && *(&v37 + 1))
          {
            (*(*v32 + 48))(v32, &v36);
          }

          goto LABEL_54;
        }
      }

      std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::__emplace_unique_key_args<gdc::ResourceKey,gdc::ResourceKey const&>(&v36, v18 + 16);
      v20 = a1[39];
      v21 = *(v18 + 1);
      v22 = vcnt_s8(v20);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.u32[0] > 1uLL)
      {
        if (v21 >= *&v20)
        {
          v21 %= *&v20;
        }
      }

      else
      {
        v21 &= *&v20 - 1;
      }

      v23 = *v18;
      v24 = a1[38];
      v25 = *(v24 + 8 * v21);
      do
      {
        v26 = v25;
        v25 = *v25;
      }

      while (v25 != v18);
      if (v26 == (a1 + 40))
      {
        goto LABEL_58;
      }

      v27 = *(v26 + 1);
      if (v22.u32[0] > 1uLL)
      {
        if (v27 >= *&v20)
        {
          v27 %= *&v20;
        }
      }

      else
      {
        v27 &= *&v20 - 1;
      }

      v28 = *v18;
      if (v27 != v21)
      {
LABEL_58:
        if (v23)
        {
          v29 = *(v23 + 1);
          if (v22.u32[0] > 1uLL)
          {
            if (v29 >= *&v20)
            {
              v29 %= *&v20;
            }
          }

          else
          {
            v29 &= *&v20 - 1;
          }

          v28 = *v18;
          if (v29 == v21)
          {
            goto LABEL_37;
          }
        }

        *(v24 + 8 * v21) = 0;
        v28 = *v18;
      }

      if (!v28)
      {
LABEL_43:
        *v26 = v28;
        *v18 = 0;
        --a1[41];
        if (v18[167] < 0)
        {
          operator delete(*(v18 + 18));
        }

        if (v18[143] < 0)
        {
          operator delete(*(v18 + 15));
        }

        v31 = *(v18 + 3);
        if (v31 != *(v18 + 5))
        {
          free(v31);
        }

        operator delete(v18);
        goto LABEL_50;
      }

LABEL_37:
      v30 = *(v28 + 8);
      if (v22.u32[0] > 1uLL)
      {
        if (v30 >= *&v20)
        {
          v30 %= *&v20;
        }
      }

      else
      {
        v30 &= *&v20 - 1;
      }

      if (v30 != v21)
      {
        *(a1[38] + 8 * v30) = v26;
        v28 = *v18;
      }

      goto LABEL_43;
    }

    v5 = *(a2 + 24);
    if (!v5)
    {
      break;
    }

    if ((*(*v5 + 48))(v5, v4 + 2))
    {
      v6 = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(a1 + 46, v4 + 16);
      if (v6)
      {
        v7 = v6;
        v8 = v6[14];
        v9 = v8[16];
        v10 = a1[51];
        v11 = a1[52];
        v12 = v11 >= v9;
        v13 = v11 - v9;
        if (!v12)
        {
          v13 = 0;
        }

        a1[52] = v13;
        if (v10 == v8)
        {
          a1[51] = v10[1];
        }

        v14 = v6[14];
        v16 = *v14;
        v15 = v14[1];
        *(v16 + 8) = v15;
        *v15 = v16;
        --a1[45];
        std::__destroy_at[abi:nn200100]<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>,0>(v14 + 2);
        operator delete(v14);
        std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>>>::erase(a1 + 46, v7);
      }

      v17 = *v4;
      std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::remove(&v36, a1 + 33, v4);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,void *>>>>::~unique_ptr[abi:nn200100](&v36);
      v4 = v17;
    }

    else
    {
      v4 = *v4;
    }
  }

LABEL_55:
  v33 = std::__throw_bad_function_call[abi:nn200100]();
  gdc::ResourceStore::createDebugNode(v33, v34, v35);
}

void gdc::ResourceStore::createDebugNode(std::string *a1, uint64_t a2, __int128 *a3)
{
  gdc::DebugTreeNode::DebugTreeNode(a1, a3);
  std::string::basic_string[abi:nn200100]<0>(&v55, "Resources");
  ChildNode = gdc::DebugTreeNode::createChildNode(a1, &v55);
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v55.__r_.__value_.__l.__data_);
  }

  v22 = a2;
  for (i = *(a2 + 280); i; i = *i)
  {
    v7 = i[15];
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        v9 = v8;
        v10 = i[14];
        if (v10)
        {
          std::string::basic_string[abi:nn200100]<0>(&v55, "Resource");
          gdc::DebugTreeNode::DebugTreeNode(&v31, &v55);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          gdc::ResourceKey::createDebugNode(&v55, v10);
          gdc::DebugTreeNode::addChildNode(&v31, &v55);
          v60[0] = v59;
          std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v60);
          v60[0] = v58;
          std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v60);
          if (v57 < 0)
          {
            operator delete(v56);
          }

          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "OriginalLoadReason");
          v11 = *(v10 + 120);
          v12 = "<Invalid>";
          if (v11 <= 4)
          {
            v12 = off_1E7B58608[v11];
          }

          memset(&v53, 0, sizeof(v53));
          v54 = 4;
          std::string::__assign_external(&v53, v12);
          gdc::DebugTreeNode::addProperty(&v31, &v55, &v51);
          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v53.__r_.__value_.__l.__data_);
          }

          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "Source");
          v13 = *(v10 + 121);
          v14 = "<Invalid>";
          if (v13 <= 3)
          {
            v14 = off_1E7B58690[v13];
          }

          memset(&__p, 0, sizeof(__p));
          v50 = 4;
          std::string::__assign_external(&__p, v14);
          gdc::DebugTreeNode::addProperty(&v31, &v55, v48);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
          }

          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "CreatedTimestamp");
          v15 = *(v10 + 96);
          memset(&v46[4], 0, 24);
          v47 = 0;
          v46[0] = v15;
          gdc::DebugTreeNode::addProperty(&v31, &v55, v46);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "LastTimestamp");
          v16 = *(v10 + 104);
          memset(&v44[4], 0, 24);
          v45 = 0;
          v44[0] = v16;
          gdc::DebugTreeNode::addProperty(&v31, &v55, v44);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "TimeToLive");
          v17 = *(v10 + 112);
          memset(&v42[4], 0, 24);
          v43 = 0;
          v42[0] = v17;
          gdc::DebugTreeNode::addProperty(&v31, &v55, v42);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          std::string::basic_string[abi:nn200100]<0>(&v55, "RequestId");
          v18 = *(v10 + 128);
          v39 = 0;
          v40 = 0;
          v38 = 0;
          v41 = 1;
          v37 = v18;
          gdc::DebugTreeNode::addProperty(&v31, &v55, v36);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v55.__r_.__value_.__l.__data_);
          }

          gdc::DebugTreeNode::addChildNode(ChildNode, &v31);
          v55.__r_.__value_.__r.__words[0] = v35;
          std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v55);
          v55.__r_.__value_.__r.__words[0] = v34;
          std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v55);
          if (v33 < 0)
          {
            operator delete(v32);
          }

          if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v31.__r_.__value_.__l.__data_);
          }
        }

        std::__shared_weak_count::__release_shared[abi:nn200100](v9);
      }
    }
  }

  std::string::basic_string[abi:nn200100]<0>(&v55, "Failed Resources");
  v19 = gdc::DebugTreeNode::createChildNode(a1, &v55);
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v55.__r_.__value_.__l.__data_);
  }

  for (j = *(v22 + 320); j; j = j->__r_.__value_.__r.__words[0])
  {
    gdc::ResourceKey::createDebugNode(&v55, &j->__r_.__value_.__s.__data_[16]);
    std::string::basic_string[abi:nn200100]<0>(&v51, "Error");
    gdc::DebugTreeNode::DebugTreeNode(&v31, &v51);
    if (v52 < 0)
    {
      operator delete(v51);
    }

    std::string::basic_string[abi:nn200100]<0>(&v51, "Code");
    v21 = j[4].__r_.__value_.__r.__words[2];
    memset(&v29[4], 0, 24);
    v30 = 0;
    v29[0] = v21;
    gdc::DebugTreeNode::addProperty(&v31, &v51, v29);
    if (v52 < 0)
    {
      operator delete(v51);
    }

    std::string::basic_string[abi:nn200100]<0>(&v51, "Domain");
    memset(&v27, 0, sizeof(v27));
    v28 = 4;
    std::string::operator=(&v27, j + 5);
    gdc::DebugTreeNode::addProperty(&v31, &v51, v26);
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v27.__r_.__value_.__l.__data_);
    }

    if (v52 < 0)
    {
      operator delete(v51);
    }

    std::string::basic_string[abi:nn200100]<0>(&v51, "Description");
    memset(&v24, 0, sizeof(v24));
    v25 = 4;
    std::string::operator=(&v24, j + 6);
    gdc::DebugTreeNode::addProperty(&v31, &v51, v23);
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v24.__r_.__value_.__l.__data_);
    }

    if (v52 < 0)
    {
      operator delete(v51);
    }

    gdc::DebugTreeNode::addChildNode(&v55, &v31);
    gdc::DebugTreeNode::addChildNode(v19, &v55);
    *&v51 = v35;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v51);
    *&v51 = v34;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v51);
    if (v33 < 0)
    {
      operator delete(v32);
    }

    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v31.__r_.__value_.__l.__data_);
    }

    v31.__r_.__value_.__r.__words[0] = v59;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v31);
    v31.__r_.__value_.__r.__words[0] = v58;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v31);
    if (v57 < 0)
    {
      operator delete(v56);
    }

    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v55.__r_.__value_.__l.__data_);
    }
  }
}

void gdc::LayerData::createDebugNode(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:nn200100]<0>(&v23, "Layer Data");
  gdc::DebugTreeNode::DebugTreeNode(a2, &v23);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  gdc::LayerDataRequestKey::createDebugNode(&v23, (a1 + 16));
  gdc::DebugTreeNode::addChildNode(a2, &v23);
  v28 = &v27;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v28);
  v28 = &v26;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v28);
  if (v25 < 0)
  {
    operator delete(v24);
  }

  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v23, "CreatedTimestamp");
  v4 = *(a1 + 136);
  v22 = 0;
  memset(&v21[4], 0, 24);
  v21[0] = v4;
  gdc::DebugTreeNode::addProperty(a2, &v23, v21);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v23, "LastTimestamp");
  v5 = *(a1 + 144);
  v20 = 0;
  memset(&v19[4], 0, 24);
  v19[0] = v5;
  gdc::DebugTreeNode::addProperty(a2, &v23, v19);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v23, "TimeToLive");
  v6 = *(a1 + 152);
  v18 = 0;
  memset(&v17[4], 0, 24);
  v17[0] = v6;
  gdc::DebugTreeNode::addProperty(a2, &v23, v17);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v23, "EstimatedCost");
  v7 = (*(*a1 + 16))(a1);
  v14 = 0;
  v15 = 0;
  v16 = 1;
  v13 = 0;
  v12 = v7;
  gdc::DebugTreeNode::addProperty(a2, &v23, v11);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&v23, "Complete");
  v8 = *(a1 + 160);
  v10 = 0;
  memset(&v9[4], 0, 24);
  v9[0] = v8;
  gdc::DebugTreeNode::addProperty(a2, &v23, v9);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

void gdc::LayerData::~LayerData(gdc::LayerData *this)
{
  *this = &unk_1F2A60328;
  v2 = *(this + 4);
  if (v2 != *(this + 6))
  {
    free(v2);
  }

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A60328;
  v2 = *(this + 4);
  if (v2 != *(this + 6))
  {
    free(v2);
  }
}

__n128 std::__function::__func<gdc::ResourceFetcher::createResource(unsigned long long,gdc::ResourceKey const&,gdc::ResourceOriginalLoadReason,gdc::ResourceSource,long long,BOOL,gdc::RawResourceSourceData const&)::$_1,std::allocator<gdc::ResourceFetcher::createResource(unsigned long long,gdc::ResourceKey const&,gdc::ResourceOriginalLoadReason,gdc::ResourceSource,long long,BOOL,gdc::RawResourceSourceData const&)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A60470;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<gdc::ResourceFetcher::createResource(unsigned long long,gdc::ResourceKey const&,gdc::ResourceOriginalLoadReason,gdc::ResourceSource,long long,BOOL,gdc::RawResourceSourceData const&)::$_0,std::allocator<gdc::ResourceFetcher::createResource(unsigned long long,gdc::ResourceKey const&,gdc::ResourceOriginalLoadReason,gdc::ResourceSource,long long,BOOL,gdc::RawResourceSourceData const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A60428;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

void gdc::ResourceFetcher::cancelledLoad(unsigned __int16 **this, void *a2, const gdc::ResourceKey *a3)
{
  v22 = *MEMORY[0x1E69E9840];
  v5 = *geo::linear_map<unsigned short,std::shared_ptr<gdc::ResourceStore>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::shared_ptr<gdc::ResourceStore>>>,std::vector<std::pair<unsigned short,std::shared_ptr<gdc::ResourceStore>>>>::operator[](this + 3, *(a3 + 1));
  std::mutex::lock((v5 + 128));
  if (GEOGetGeoDisplayCoreResourceLoadingLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoDisplayCoreResourceLoadingLog::onceToken, &__block_literal_global_5_56382);
  }

  v6 = GEOGetGeoDisplayCoreResourceLoadingLog::log;
  if (os_log_type_enabled(GEOGetGeoDisplayCoreResourceLoadingLog::log, OS_LOG_TYPE_DEBUG))
  {
    v7 = (*(**(v5 + 424) + 16))(*(v5 + 424));
    gdc::ResourceKey::keysInt32Str(&__p, a3);
    v8 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &__p : __p.__r_.__value_.__r.__words[0];
    *buf = 136315650;
    *&buf[4] = v7;
    *&buf[12] = 2080;
    *&buf[14] = v8;
    *&buf[22] = 2048;
    v13 = a2;
    _os_log_impl(&dword_1B2754000, v6, OS_LOG_TYPE_DEBUG, "%s Resource Cancelled: %s, rid: %llu", buf, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  v10 = *a3;
  v9 = *(a3 + 1);
  *buf = a2;
  *&buf[8] = v10;
  *&buf[16] = v16;
  v13 = v16;
  v14 = v16;
  v15 = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>(&buf[16], v9, *(a3 + 2));
  v16[4] = *(a3 + 9);
  v17 = *(a3 + 5);
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0;
  std::vector<gdc::ResourceRequest>::push_back[abi:nn200100]((v5 + 240), buf);
  if (SHIBYTE(v21) < 0)
  {
    operator delete(v20);
  }

  if (SHIBYTE(v19) < 0)
  {
    operator delete(*(&v18 + 1));
  }

  if (*&buf[16] != v14)
  {
    free(*&buf[16]);
  }

  std::mutex::unlock((v5 + 128));
}

void gdc::ResourceFetcher::createDebugNode(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  v49 = *MEMORY[0x1E69E9840];
  gdc::DebugTreeNode::DebugTreeNode(a3, a2);
  v5 = (*(*a1 + 64))(a1);
  if (v6)
  {
    v7 = v5;
    std::string::basic_string[abi:nn200100]<0>(v39, "Download Zoom Range");
    v44 = 0;
    v45 = 0;
    v46 = 1;
    v43 = 0;
    v41[1] = v7;
    v48 = 1;
    memset(&v47[3], 0, 24);
    v47[0] = HIDWORD(v7);
    memset(&v38, 0, sizeof(v38));
    std::vector<gdc::DebugTreeValue>::__init_with_size[abi:nn200100]<gdc::DebugTreeValue const*,gdc::DebugTreeValue const*>(&v38, v41, &v49, 2uLL);
  }

  std::string::basic_string[abi:nn200100]<0>(v41, "Download Zoom Range");
  memset(&__p, 0, sizeof(__p));
  v37 = 4;
  std::string::__assign_external(&__p, "None");
  gdc::DebugTreeNode::addProperty(a3, v41, v35);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  std::string::basic_string[abi:nn200100]<0>(v41, "Tile Size");
  if (((*(*a1 + 72))(a1) & 0x100000000) != 0)
  {
    v9 = (*(*a1 + 72))(a1);
    if ((v9 & 0x100000000) == 0)
    {
      v26 = std::__throw_bad_optional_access[abi:nn200100]();
      if (SBYTE7(v42) < 0)
      {
        operator delete(v41[0]);
      }

      v41[0] = (a3 + 72);
      std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v41);
      v41[0] = (a3 + 48);
      std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v41);
      if (*(a3 + 47) < 0)
      {
        operator delete(*(a3 + 24));
      }

      if (*(a3 + 23) < 0)
      {
        operator delete(*a3);
      }

      _Unwind_Resume(v26);
    }

    v8 = v9;
  }

  else
  {
    v8 = 0;
  }

  v32 = 0;
  v33 = 0;
  v34 = 1;
  v31 = 0;
  v30 = v8;
  gdc::DebugTreeNode::addProperty(a3, v41, v29);
  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  memset(v39, 0, sizeof(v39));
  for (i = *(a1 + 88); i; i = *i)
  {
    v11 = *(i + 8);
    v43 = 0;
    v44 = 0;
    v46 = 0;
    v45 = 0;
    v41[0] = v11;
    std::vector<gdc::DebugTreeValue>::push_back[abi:nn200100](v39, v41);
    if (SHIBYTE(v45) < 0)
    {
      operator delete(v43);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(v41, "Resource Types");
  gdc::DebugTreeNode::addProperty(a3, v41, v39);
  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  std::string::basic_string[abi:nn200100]<0>(v41, "Stores");
  ChildNode = gdc::DebugTreeNode::createChildNode(a3, v41);
  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  v13 = *(a1 + 24);
  for (j = *(a1 + 32); v13 != j; v13 += 12)
  {
    v15 = *(v13 + 1);
    std::string::basic_string[abi:nn200100]<0>(&v28, "Store ");
    std::to_string(&v27, *v13);
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v16 = &v27;
    }

    else
    {
      v16 = v27.__r_.__value_.__r.__words[0];
    }

    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
    }

    else
    {
      size = v27.__r_.__value_.__l.__size_;
    }

    v18 = std::string::append(&v28, v16, size);
    v38 = *v18;
    v18->__r_.__value_.__r.__words[0] = 0;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    gdc::ResourceStore::createDebugNode(v41, v15, &v38);
    gdc::DebugTreeNode::addChildNode(ChildNode, v41);
    v40 = v47;
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v40);
    v40 = &v45;
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v40);
    if (SHIBYTE(v44) < 0)
    {
      operator delete(*(&v42 + 1));
    }

    if (SBYTE7(v42) < 0)
    {
      operator delete(v41[0]);
    }

    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v38.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v27.__r_.__value_.__l.__data_);
    }

    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
  }

  std::string::basic_string[abi:nn200100]<0>(v41, "DecodeTime");
  v19 = gdc::DebugTreeNode::createChildNode(a3, v41);
  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  std::mutex::lock((a1 + 344));
  for (k = 0; k != 4; ++k)
  {
    gdc::ResourceFetcher::createDebugNode(std::string const&,std::bitset<8ul> const&)const::$_0::operator()(v19, gdc::ResourceSourceList[k], a1 + 408, 1000.0);
  }

  std::mutex::unlock((a1 + 344));
  std::string::basic_string[abi:nn200100]<0>(v41, "Bytes");
  v21 = gdc::DebugTreeNode::createChildNode(a3, v41);
  if (SBYTE7(v42) < 0)
  {
    operator delete(v41[0]);
  }

  for (m = 0; m != 4; ++m)
  {
    v23 = gdc::ResourceSourceList[m];
    std::mutex::lock((a1 + 120));
    v24 = a1 + 184 + 40 * v23;
    v25 = *(v24 + 16);
    *v41 = *v24;
    v42 = v25;
    v43 = *(v24 + 32);
    std::mutex::unlock((a1 + 120));
    gdc::ResourceFetcher::createDebugNode(std::string const&,std::bitset<8ul> const&)const::$_0::operator()(v21, v23, v41, 1.0);
  }

  v41[0] = v39;
  std::vector<gdc::DebugTreeValue>::__destroy_vector::operator()[abi:nn200100](v41);
}

void gdc::ResourceFetcher::createDebugNode(std::string const&,std::bitset<8ul> const&)const::$_0::operator()(void *a1, unsigned int a2, uint64_t a3, double a4)
{
  if (a2 > 3)
  {
    v7 = "<Invalid>";
  }

  else
  {
    v7 = off_1E7B58690[a2];
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, v7);
  v8 = gdc::DebugTreeNode::createChildNode(a1, &v44);
  if (v45 < 0)
  {
    operator delete(v44);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "Avg");
  v9 = *(a3 + 16) * a4;
  v41 = 0;
  v42 = 0;
  v40 = 0;
  v43 = 2;
  v39 = v9;
  gdc::DebugTreeNode::addProperty(v8, &v44, v38);
  if (v45 < 0)
  {
    operator delete(v44);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "Count");
  v10 = *(a3 + 32);
  v35 = 0;
  v36 = 0;
  v37 = 1;
  v34 = 0;
  v33 = v10;
  gdc::DebugTreeNode::addProperty(v8, &v44, v32);
  if (v45 < 0)
  {
    operator delete(v44);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "Total");
  v11 = *(a3 + 24) * a4;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v31 = 2;
  v27 = v11;
  gdc::DebugTreeNode::addProperty(v8, &v44, v26);
  if (v45 < 0)
  {
    operator delete(v44);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "Min");
  v12 = *a3 * a4;
  v23 = 0;
  v24 = 0;
  v22 = 0;
  v25 = 2;
  v21 = v12;
  gdc::DebugTreeNode::addProperty(v8, &v44, v20);
  if (v45 < 0)
  {
    operator delete(v44);
  }

  std::string::basic_string[abi:nn200100]<0>(&v44, "Max");
  v13 = *(a3 + 8) * a4;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v19 = 2;
  v15 = v13;
  gdc::DebugTreeNode::addProperty(v8, &v44, v14);
  if (v45 < 0)
  {
    operator delete(v44);
  }
}

void gdc::ResourceFetcher::resourceSizeSampler(uint64_t a1, uint64_t a2, unsigned int a3)
{
  std::mutex::lock((a2 + 120));
  v6 = a2 + 40 * a3;
  v7 = *(v6 + 200);
  *a1 = *(v6 + 184);
  *(a1 + 16) = v7;
  *(a1 + 32) = *(v6 + 216);

  std::mutex::unlock((a2 + 120));
}

void gdc::ResourceFetcher::~ResourceFetcher(gdc::ResourceFetcher *this)
{
  *this = &unk_1F2A60388;
  v2 = (this + 24);
  std::mutex::~mutex((this + 344));
  std::mutex::~mutex((this + 120));
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 72);
  v3 = (this + 48);
  std::vector<md::components::Material>::__destroy_vector::operator()[abi:nn200100](&v3);
  v3 = v2;
  std::vector<md::components::Material>::__destroy_vector::operator()[abi:nn200100](&v3);
}

void gdc::ResourceFetcher::resourceDecodeTimeSampler(gdc::ResourceFetcher *this, uint64_t a2)
{
  v4 = (a2 + 408);
  std::mutex::lock((a2 + 344));
  v5 = v4[1];
  *this = *v4;
  *(this + 1) = v5;
  *(this + 4) = *(a2 + 440);

  std::mutex::unlock((a2 + 344));
}

void gdc::ResourceFetcher::resetResourceSamplers(gdc::ResourceFetcher *this)
{
  std::mutex::lock((this + 120));
  for (i = 0; i != 4; ++i)
  {
    v3 = this + 40 * gdc::ResourceSourceList[i] + 184;
    *(v3 + 4) = 0;
    *v3 = 0uLL;
    *(v3 + 1) = 0uLL;
  }

  *(this + 55) = 0;
  *(this + 408) = 0u;
  *(this + 424) = 0u;

  std::mutex::unlock((this + 120));
}

uint64_t GEOGetGeoDisplayCoreDefaultLog()
{
  if (GEOGetGeoDisplayCoreDefaultLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoDisplayCoreDefaultLog::onceToken, &__block_literal_global_56374);
  }

  return GEOGetGeoDisplayCoreDefaultLog::log;
}

uint64_t GEOGetGeoDisplayCoreDCELLog()
{
  if (GEOGetGeoDisplayCoreDCELLog::onceToken != -1)
  {
    dispatch_once(&GEOGetGeoDisplayCoreDCELLog::onceToken, &__block_literal_global_13_56392);
  }

  return GEOGetGeoDisplayCoreDCELLog::log;
}

os_log_t __GEOGetGeoDisplayCoreDCELLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit", "DCEL");
  GEOGetGeoDisplayCoreDCELLog::log = result;
  return result;
}

os_log_t __GEOGetGeoDisplayCoreTaskflowLog_block_invoke()
{
  result = os_log_create("com.apple.VectorKit", "Taskflow");
  GEOGetGeoDisplayCoreTaskflowLog::log = result;
  return result;
}

float gdc::DisplayZoomLevel::zoomLevelForDistance(double a1, double a2)
{
  v3 = tan(a2 * 0.5);
  v4 = log2(a1 * 0.0000000499064043 * v3);
  return fminf(fmaxf(-v4, 1.0), 25.0);
}

float gdc::StyleZoomLevel::StyleZoomLevel(gdc::StyleZoomLevel *this, const gdc::NormalizedZoomLevel *a2, float a3, double a4)
{
  v4 = a4;
  if (a4)
  {
    if (v4 < 513)
    {
      v5 = 0;
      i = 512;
    }

    else
    {
      v5 = 0;
      for (i = 512; i < v4; i *= 2)
      {
        ++v5;
      }
    }

    if (i > v4)
    {
      do
      {
        --v5;
        v7 = i <= 2 * v4;
        v4 *= 2;
      }

      while (!v7);
    }
  }

  else
  {
    v5 = 0;
  }

  result = fminf(fmaxf(v5 + a3, 1.0), 25.0);
  *this = result;
  return result;
}

void gdc::ResourceManager::~ResourceManager(gdc::ResourceManager *this)
{
  gdc::ResourceManager::~ResourceManager(this);

  JUMPOUT(0x1B8C62190);
}

{
  v19 = *MEMORY[0x1E69E9840];
  v3 = *(this + 7);
  v4 = *(this + 8);
  for (i = (this + 56); v3 != v4; v3 += 24)
  {
    v5 = *(v3 + 8);
    v6 = *(v3 + 16);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      v18 = 0;
      gdc::ResourceStore::setArrivedResourceNotification(v5, v17);
      std::__function::__value_func<void ()(std::shared_ptr<gdc::Resource> const&)>::~__value_func[abi:nn200100](v17);
      v16 = 0;
      gdc::ResourceStore::setNewResourceNotification(v5, v15);
      std::__function::__value_func<void ()(std::vector<std::shared_ptr<gdc::Resource>> const&,std::vector<gdc::ResourceRequest> const&,std::vector<gdc::ResourceRequest> const&)>::~__value_func[abi:nn200100](v15);
      v14 = 0;
      gdc::ResourceStore::setRetryResourceNotification(v5, v13);
      std::__function::__value_func<void ()(std::unordered_set<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>> const&)>::~__value_func[abi:nn200100](v13);
      std::__shared_weak_count::__release_shared[abi:nn200100](v6);
    }

    else
    {
      v18 = 0;
      gdc::ResourceStore::setArrivedResourceNotification(v5, v17);
      std::__function::__value_func<void ()(std::shared_ptr<gdc::Resource> const&)>::~__value_func[abi:nn200100](v17);
      v16 = 0;
      gdc::ResourceStore::setNewResourceNotification(v5, v15);
      std::__function::__value_func<void ()(std::vector<std::shared_ptr<gdc::Resource>> const&,std::vector<gdc::ResourceRequest> const&,std::vector<gdc::ResourceRequest> const&)>::~__value_func[abi:nn200100](v15);
      v14 = 0;
      gdc::ResourceStore::setRetryResourceNotification(v5, v13);
      std::__function::__value_func<void ()(std::unordered_set<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>> const&)>::~__value_func[abi:nn200100](v13);
    }
  }

  v7 = *(this + 4);
  v8 = *(this + 5);
  while (v7 != v8)
  {
    (*(**(v7 + 8) + 40))(*(v7 + 8));
    v7 += 16;
  }

  v9 = *(this + 35);
  if (v9)
  {
    v12[0] = &unk_1F2A60638;
    v12[3] = v12;
    geo::TaskQueue::barrierSync(v9, v12);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v12);
  }

  std::__function::__value_func<void ()(std::unordered_map<gdc::ResourceKey,gdc::Error,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,gdc::Error>>> const&)>::~__value_func[abi:nn200100](this + 416);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](this + 384);
  std::__function::__value_func<std::string ()(unsigned short)>::~__value_func[abi:nn200100](this + 352);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](this + 320);
  std::unique_ptr<gdc::ResourceStatusContainer>::~unique_ptr[abi:nn200100](this + 39);
  v11 = (this + 288);
  std::vector<std::shared_ptr<md::TrafficDynamicTileResource>>::__destroy_vector::operator()[abi:nn200100](&v11);
  v11 = (this + 256);
  std::vector<std::pair<gdc::ResourceFetcher *,std::unordered_map<gdc::ResourceKey,unsigned long long,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn200100](&v11);
  std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(this + 216);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 176);
  std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(this + 136);
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,unsigned long long>>>::~__hash_table(this + 96);
  v11 = i;
  std::vector<md::components::Material>::__destroy_vector::operator()[abi:nn200100](&v11);
  v10 = *(this + 4);
  if (v10)
  {
    *(this + 5) = v10;
    operator delete(v10);
  }

  v11 = (this + 8);
  std::vector<std::unique_ptr<gdc::ResourceFetcher>>::__destroy_vector::operator()[abi:nn200100](&v11);
}

void sub_1B338FBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, char a10)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](&a10);
  std::__function::__value_func<void ()(std::unordered_map<gdc::ResourceKey,gdc::Error,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,gdc::Error>>> const&)>::~__value_func[abi:nn200100](v10 + 416);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v10 + 384);
  std::__function::__value_func<std::string ()(unsigned short)>::~__value_func[abi:nn200100](v10 + 352);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v10 + 320);
  std::unique_ptr<gdc::ResourceStatusContainer>::~unique_ptr[abi:nn200100]((v10 + 312));
  a9 = (v10 + 288);
  std::vector<std::shared_ptr<md::TrafficDynamicTileResource>>::__destroy_vector::operator()[abi:nn200100](&a9);
  a9 = (v10 + 256);
  std::vector<std::pair<gdc::ResourceFetcher *,std::unordered_map<gdc::ResourceKey,unsigned long long,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn200100](&a9);
  std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(v10 + 216);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(v10 + 176);
  std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::~__hash_table(v10 + 136);
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,unsigned long long>>>::~__hash_table(v10 + 96);
  std::vector<md::components::Material>::__destroy_vector::operator()[abi:nn200100](&a9);
  v12 = *(v10 + 32);
  if (v12)
  {
    *(v10 + 40) = v12;
    operator delete(v12);
  }

  a9 = (v10 + 8);
  std::vector<std::unique_ptr<gdc::ResourceFetcher>>::__destroy_vector::operator()[abi:nn200100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<gdc::ResourceStatusContainer>::~unique_ptr[abi:nn200100](uint64_t *a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__tree<gdc::ResourceKey,gdc::ResourceKeyLessThan,std::allocator<gdc::ResourceKey>>::destroy(*(v2 + 56));
    std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>>>::~__hash_table(v2 + 8);
    MEMORY[0x1B8C62190](v2, 0x10A1C40CEBFBBFELL);
  }

  return a1;
}

void std::vector<std::pair<gdc::ResourceFetcher *,std::unordered_map<gdc::ResourceKey,unsigned long long,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 48;
        std::__hash_table<std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,unsigned long long>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,unsigned long long>>>::~__hash_table((v4 - 40));
        v4 = v6;
      }

      while (v6 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void std::vector<std::unique_ptr<gdc::ResourceFetcher>>::__destroy_vector::operator()[abi:nn200100](void ***a1)
{
  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
        {
          (*(*v6 + 8))(v6);
        }
      }

      while (v4 != v2);
      v5 = **a1;
    }

    v1[1] = v2;

    operator delete(v5);
  }
}

void gdc::ResourceStatusContainer::~ResourceStatusContainer(gdc::ResourceStatusContainer *this)
{
  std::__tree<gdc::ResourceKey,gdc::ResourceKeyLessThan,std::allocator<gdc::ResourceKey>>::destroy(*(this + 7));
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>>>::~__hash_table(this + 8);

  JUMPOUT(0x1B8C62190);
}

{
  std::__tree<gdc::ResourceKey,gdc::ResourceKeyLessThan,std::allocator<gdc::ResourceKey>>::destroy(*(this + 7));
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::ResourceStatusItem>>>::~__hash_table(this + 8);
}

uint64_t **gdc::ResourceStatusContainer::resourceCancelled(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 4;
  }

  return result;
}

uint64_t **gdc::ResourceStatusContainer::resourceFailed(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 3;
  }

  return result;
}

uint64_t **gdc::ResourceStatusContainer::resourceArrived(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 2;
  }

  return result;
}

uint64_t **gdc::ResourceStatusContainer::resourceLoading(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 1;
  }

  return result;
}

uint64_t **gdc::ResourceStatusContainer::resourceReset(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 0;
  }

  return result;
}

uint64_t **gdc::ResourceStatusContainer::resourceResetActive(gdc::ResourceStatusContainer *this, const gdc::ResourceKey *a2)
{
  result = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(this + 1, a2);
  if (result)
  {
    *(result + 28) = 0;
  }

  return result;
}

double gdc::ResourceStatusContainer::ResourceStatusContainer(uint64_t a1, uint64_t a2)
{
  *a1 = &unk_1F2A60570;
  result = 0.0;
  *(a1 + 8) = 0u;
  *(a1 + 24) = 0u;
  *(a1 + 40) = 1065353216;
  *(a1 + 56) = 0;
  *(a1 + 48) = a1 + 56;
  *(a1 + 64) = 0;
  *(a1 + 72) = a2;
  return result;
}

uint64_t std::__function::__func<gdc::ResourceManager::addResourceFetcher(std::unique_ptr<gdc::ResourceFetcher> &&)::$_1,std::allocator<std::unique_ptr<gdc::ResourceFetcher> &&>,void ()(std::unordered_set<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<std::unordered_set>,gdc::ResourceManager::addResourceFetcher(std::unique_ptr<gdc::ResourceFetcher> &&)::$_1<std::unordered_set>> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 8);
  for (i = *(a2 + 16); i; i = *i)
  {
    v4 = i[3];
    v18 = i[2];
    v19[0] = v22;
    v19[1] = v22;
    v20 = v22;
    v21 = 32;
    geo::small_vector_base<unsigned char>::append<unsigned char const*>(v19, v4, i[4]);
    v22[4] = i[11];
    v23 = *(i + 6);
    v5 = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>((v2[39] + 8), &v18);
    if (v5)
    {
      *(v5 + 28) = 0;
    }

    v6 = std::__hash_table<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>>::find<gdc::ResourceKey>(v2 + 17, &v18);
    if (v6)
    {
      v7 = v2[18];
      v8 = v6[1];
      v9 = vcnt_s8(v7);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= *&v7)
        {
          v8 = (v8 % *&v7);
        }
      }

      else
      {
        v8 = ((*&v7 - 1) & v8);
      }

      v10 = v2[17];
      v11 = *(v10 + 8 * v8);
      do
      {
        v12 = v11;
        v11 = *v11;
      }

      while (v11 != v6);
      if (v12 == v2 + 19)
      {
        goto LABEL_22;
      }

      v13 = v12[1];
      if (v9.u32[0] > 1uLL)
      {
        if (v13 >= *&v7)
        {
          v13 = (v13 % *&v7);
        }
      }

      else
      {
        v13 = (v13 & (*&v7 - 1));
      }

      if (v13 != v8)
      {
LABEL_22:
        if (!*v6)
        {
          goto LABEL_23;
        }

        v14 = (*v6)[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v14 >= *&v7)
          {
            v14 %= *&v7;
          }
        }

        else
        {
          v14 &= *&v7 - 1;
        }

        if (v14 != v8)
        {
LABEL_23:
          *(v10 + 8 * v8) = 0;
        }
      }

      v15 = *v6;
      if (*v6)
      {
        v16 = v15[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v16 >= *&v7)
          {
            v16 = (v16 % *&v7);
          }
        }

        else
        {
          v16 = (v16 & (*&v7 - 1));
        }

        if (v16 != v8)
        {
          *(v2[17] + 8 * v16) = v12;
          v15 = *v6;
        }
      }

      *v12 = v15;
      *v6 = 0;
      --v2[20];
      std::__hash_node_destructor<std::allocator<std::__hash_node<gdc::ResourceKey,void *>>>::operator()[abi:nn200100](1, v6);
    }

    if (v19[0] != v20)
    {
      free(v19[0]);
    }
  }

  result = v2[43];
  if (result)
  {
    return (*(*result + 48))(result);
  }

  return result;
}

uint64_t std::__shared_ptr_emplace<gdc::ResourceStore>::__on_zero_shared(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::__list_iterator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,void *>>>>::__deallocate_node(*(a1 + 408));
  v2 = *(a1 + 392);
  *(a1 + 392) = 0;
  if (v2)
  {
    operator delete(v2);
  }

  std::__list_imp<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>>::CacheEntry>>::clear((a1 + 368));
  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,gdc::Error>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,gdc::Error>>>::__deallocate_node(*(a1 + 344));
  v3 = *(a1 + 328);
  *(a1 + 328) = 0;
  if (v3)
  {
    operator delete(v3);
  }

  std::__hash_table<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::__unordered_map_hasher<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,true>,std::__unordered_map_equal<gdc::ResourceKey,std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>,std::equal_to<gdc::ResourceKey>,gdc::ResourceKeyHash,true>,std::allocator<std::__hash_value_type<gdc::ResourceKey,std::weak_ptr<gdc::Resource>>>>::__deallocate_node(*(a1 + 304));
  v4 = *(a1 + 288);
  *(a1 + 288) = 0;
  if (v4)
  {
    operator delete(v4);
  }

  v6 = (a1 + 264);
  std::vector<gdc::ResourceRequest>::__destroy_vector::operator()[abi:nn200100](&v6);
  v6 = (a1 + 240);
  std::vector<gdc::ResourceRequest>::__destroy_vector::operator()[abi:nn200100](&v6);
  v6 = (a1 + 216);
  std::vector<std::shared_ptr<md::TrafficDynamicTileResource>>::__destroy_vector::operator()[abi:nn200100](&v6);
  std::mutex::~mutex((a1 + 152));
  std::__function::__value_func<void ()(std::unordered_map<gdc::ResourceKey,gdc::Error,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,gdc::Error>>> const&)>::~__value_func[abi:nn200100](a1 + 120);
  std::__function::__value_func<void ()(std::unordered_set<gdc::ResourceKey,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<gdc::ResourceKey>> const&)>::~__value_func[abi:nn200100](a1 + 88);
  std::__function::__value_func<void ()(std::vector<std::shared_ptr<gdc::Resource>> const&,std::vector<gdc::ResourceRequest> const&,std::vector<gdc::ResourceRequest> const&)>::~__value_func[abi:nn200100](a1 + 56);

  return std::__function::__value_func<void ()(std::shared_ptr<gdc::Resource> const&)>::~__value_func[abi:nn200100](a1 + 24);
}

void std::__shared_ptr_emplace<gdc::ResourceStore>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = &unk_1F2A60680;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1B8C62190);
}

uint64_t gdc::ResourceManager::resourceFetcher(gdc::ResourceManager *this, gdc::ResourceManager *a2, int a3)
{
  while (this != a2)
  {
    if (*this == a3)
    {
      if (this != a2)
      {
        return *(this + 1);
      }

      return 0;
    }

    this = (this + 16);
  }

  return 0;
}

void *gdc::ResourceManager::resourceStore(void *this, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (a2 == a3)
    {
      goto LABEL_8;
    }

    if (*a2 == 35)
    {
      break;
    }

    a2 += 24;
  }

  if (a2 == a3)
  {
LABEL_8:
    *this = 0;
    this[1] = 0;
    return this;
  }

  v3 = *(a2 + 16);
  *this = *(a2 + 8);
  this[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit((v3 + 8), 1uLL, memory_order_relaxed);
  }

  return this;
}

__n128 std::__function::__func<gdc::ResourceManager::updateExpired(long long)::$_0,std::allocator<gdc::ResourceManager::updateExpired(long long)::$_0>,void ()(gdc::ResourceKey const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A607D8;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<gdc::ResourceManager::cleanupResourceRequests(void)::$_0,std::allocator<gdc::ResourceManager::cleanupResourceRequests(void)::$_0>,void ()(std::pair<gdc::ResourceKey,gdc::ResourceStatus> const&)>::__clone(uint64_t result, void *a2)
{
  v2 = *(result + 8);
  *a2 = &unk_1F2A60820;
  a2[1] = v2;
  return result;
}

uint64_t gdc::ResourceManager::clearFailedResources(uint64_t this, uint64_t a2)
{
  if (this != a2)
  {
    v3 = this;
    do
    {
      this = gdc::ResourceStore::clearFailedResources(*(v3 + 8));
      v3 += 24;
    }

    while (v3 != a2);
  }

  return this;
}

void *gdc::ResourceManager::setResourceFetcherConfig(void *result, int a2)
{
  v2 = 4;
  if (!a2)
  {
    v2 = 0;
  }

  v3 = result[10] & 0xFFFFFFFFFFFFFFFBLL | v2;
  result[10] = v3;
  v4 = result[4];
  v5 = result[5];
  while (v4 != v5)
  {
    *(*(v4 + 8) + 16) = v3;
    v4 += 16;
  }

  return result;
}

uint64_t std::function<std::string ()(unsigned short)>::operator()(uint64_t a1, uint64_t a2, __int16 a3)
{
  v5 = a3;
  if (a2)
  {
    return (*(*a2 + 48))(a2, &v5);
  }

  v4 = std::__throw_bad_function_call[abi:nn200100]();
  return gdc::ResourceManager::configurationDidChange(v4);
}

uint64_t gdc::ResourceManager::configurationDidChange(uint64_t this)
{
  v1 = this;
  v2 = *(this + 32);
  v3 = *(this + 40);
  while (v2 != v3)
  {
    this = (*(**(v2 + 8) + 96))(*(v2 + 8));
    v2 += 16;
  }

  v5 = *(v1 + 56);
  v4 = *(v1 + 64);
  while (v5 != v4)
  {
    this = gdc::ResourceStore::clearFailedResources(*(v5 + 8));
    v5 += 24;
  }

  return this;
}

void gdc::ConsistentZTileSelector::createDebugNode(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:nn200100]<0>(&v19, "Consistent Z Tile Selector");
  gdc::DebugTreeNode::DebugTreeNode(a2, &v19);
  if (v20 < 0)
  {
    operator delete(v19);
  }

  std::string::basic_string[abi:nn200100]<0>(&v19, "Lod Bias");
  v4 = *(a1 + 16);
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v18 = 2;
  v14 = v4;
  gdc::DebugTreeNode::addProperty(a2, &v19, v13);
  if (v20 < 0)
  {
    operator delete(v19);
  }

  std::string::basic_string[abi:nn200100]<0>(&v19, "Desired Tile Area");
  v5 = *(a1 + 8) * *(a1 + 8);
  v6 = exp2(1.98 - (*(a1 + 16) + *(a1 + 16)));
  v10 = 0;
  v11 = 0;
  v9 = 0;
  v12 = 2;
  v8 = vcvtd_n_f64_u32(v5, 8uLL) * v6;
  gdc::DebugTreeNode::addProperty(a2, &v19, v7);
  if (v20 < 0)
  {
    operator delete(v19);
  }
}

void gdc::ConsistentZTileSelector::tilesInView(gdc::ConsistentZTileSelector *this, const gdc::CameraView *a2, double a3)
{
  v47 = *MEMORY[0x1E69E9840];
  v5 = *(a2 + 2);
  v6 = tan(*(a2 + 1) * 0.5 + 0.785398163);
  v7 = log(v6);
  {
    v28 = 0;
    __p[0] = 0;
    __p[1] = 0;
    *&v40 = 0;
    v36 = 0uLL;
    *&v37 = 0x3FF0000000000000;
    qword_1EB846958 = 0x3FF0000000000000;
    gdc::ConsistentZTileSelector::minZ(gdc::CameraView const&)::groundPlane = 0uLL;
    v29 = 0.0;
    do
    {
      v29 = v29 + *(&v36 + v28 * 8) * *&__p[v28];
      ++v28;
    }

    while (v28 != 3);
    *&qword_1EB846960 = -v29;
  }

  v36 = *(a2 + 31);
  *&v37 = *(a2 + 64);
  __p[0] = 0;
  __p[1] = 0;
  *&v40 = 0xBFF0000000000000;
  *&v33 = gm::Quaternion<double>::operator*(a2 + 520, __p);
  *(&v33 + 1) = v8;
  *&v34 = v9;
  geo::Intersect::intersection<double>(v31, a2 + 984, &gdc::ConsistentZTileSelector::minZ(gdc::CameraView const&)::groundPlane);
  v10 = v31[0];
  if (*&v31[0] == *(&v31[0] + 1))
  {
    v16 = INFINITY;
  }

  else
  {
    v11 = 1.79769313e308;
    v12 = *&v31[0];
    do
    {
      for (i = 0; i != 3; ++i)
      {
        *&__p[i] = *(v12 + i * 8) - *(&v36 + i * 8);
      }

      v14 = 0;
      v15 = 0.0;
      do
      {
        v15 = v15 + *(&v33 + v14 * 8) * *&__p[v14];
        ++v14;
      }

      while (v14 != 3);
      v11 = fmin(v15, v11);
      v12 += 24;
    }

    while (v12 != *(&v10 + 1));
    v16 = v11 + v11;
  }

  v17 = v5 * 0.159154943 + 0.5;
  v18 = v7 * 0.159154943 + 0.5;
  v19 = *(a2 + 120);
  v20 = *(a2 + 118);
  v21 = *(a2 + 46);
  if (v10)
  {
    operator delete(v10);
  }

  v22 = log2(v21 * 0.001953125);
  v23 = tan(v19 * 0.5);
  v24 = v22 - log2(v16 * v20 * v23);
  v25 = fmax(floorf(v24), 0.0);
  v26 = (1 << v25);
  v27 = vcvtmd_s64_f64(v17 * v26);
  LODWORD(v26) = (1 << v25) + ~vcvtmd_s64_f64(v18 * v26);
  HIDWORD(v26) = v27;
  v30 = v26;
  exp2(1.98 - (*(this + 2) + *(this + 2)));
  v33 = 0u;
  v34 = 0u;
  v35 = 1065353216;
  memset(v31, 0, sizeof(v31));
  v32 = 1065353216;
  v43 = v25;
  v44 = v30;
  v42 = -1;
  v45 = 0;
  v46 = 1;
  *__p = 0uLL;
  v40 = 0uLL;
  v41 = 0uLL;
  v38 = __p;
  std::__allocate_at_least[abi:nn200100]<std::allocator<std::unique_ptr<std::array<unsigned short,128ul>>>>(1uLL);
}

unint64_t gdc::DataObject::getBytes(gdc::DataObject *this, void *a2, unint64_t a3)
{
  if (!a2)
  {
    return 0;
  }

  v4 = *(this + 2);
  if (!v4)
  {
    return 0;
  }

  [v4 getBytes:a2 length:a3];
  result = gdc::DataObject::length(this);
  if (result >= a3)
  {
    return a3;
  }

  return result;
}

uint64_t gdc::DataObject::bytes(id *this)
{
  v1 = this[2];

  return [v1 bytes];
}

{
  v1 = this[2];

  return [v1 bytes];
}

double gdc::GlobeTileSelector::createDebugNode@<D0>(_OWORD *a1@<X8>)
{
  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

void std::vector<gm::Matrix<double,3,1>>::__insert_with_size[abi:nn200100]<gm::Matrix<double,3,1> const*,gm::Matrix<double,3,1> const*>(uint64_t *a1, uint64_t a2, __int128 *a3)
{
  v3 = a2;
  v5 = 0;
  v6 = a1[1];
  v7 = a1[2];
  if (v7 - v6 >= 192)
  {
    if (v6 > 191)
    {
      v18 = v6 - 192;
      v19 = v6 - 192;
      v20 = a1[1];
      do
      {
        v21 = *v19;
        *(v20 + 16) = *(v19 + 16);
        *v20 = v21;
        v20 += 24;
        v19 += 24;
      }

      while (v19 < v6);
      a1[1] = v20;
      if (v6 != 192)
      {
        v22 = (v6 - 216);
        do
        {
          v18 -= 24;
          v23 = -24;
          v24 = v22;
          do
          {
            v25 = *v24++;
            *(v6 + v23) = v25;
            v23 += 8;
          }

          while (v23);
          v22 -= 3;
          v6 -= 24;
        }

        while (v18);
      }

      for (i = 0; i != 192; i += 24)
      {
        for (j = 0; j != 24; j += 8)
        {
          *(v5 + j) = *(v3 + j);
        }

        v5 = (v5 + 24);
        v3 += 24;
      }
    }

    else
    {
      v14 = a2 + v6;
      if ((a2 + v6) == a3)
      {
        v16 = a1[1];
      }

      else
      {
        v15 = (a2 + v6);
        v16 = a1[1];
        do
        {
          v17 = *v15;
          *(v16 + 16) = *(v15 + 2);
          *v16 = v17;
          v16 += 24;
          v15 = (v15 + 24);
        }

        while (v15 != a3);
      }

      a1[1] = v16;
      if (v6 >= 1)
      {
        v40 = v16 - 192;
        v41 = v16;
        if (v16 - 192 < v6)
        {
          v42 = v16 - 192;
          v41 = v16;
          do
          {
            v43 = *v42;
            *(v41 + 16) = *(v42 + 16);
            *v41 = v43;
            v41 += 24;
            v42 += 24;
          }

          while (v42 < v6);
        }

        a1[1] = v41;
        if (v16 != 192)
        {
          v44 = v16 - 216;
          do
          {
            v45 = 0;
            v40 -= 24;
            do
            {
              *(v16 + v45 - 24) = *(v44 + v45);
              v45 += 8;
            }

            while (v45 != 24);
            v44 -= 24;
            v16 -= 24;
          }

          while (v40);
        }

        do
        {
          for (k = 0; k != 24; k += 8)
          {
            *(v5 + k) = *(v3 + k);
          }

          v3 += 24;
          v5 = (v5 + 24);
        }

        while (v3 != v14);
      }
    }
  }

  else
  {
    v8 = *a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *a1) >> 3) + 8;
    if (v9 > 0xAAAAAAAAAAAAAAALL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v10 = -v8;
    v11 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v8) >> 3);
    v12 = 2 * v11;
    if (2 * v11 <= v9)
    {
      v12 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *a1) >> 3) + 8;
    }

    if (v11 >= 0x555555555555555)
    {
      v13 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v13 = v12;
    }

    if (v13)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gm::Matrix<double,3,1>>>(v13);
    }

    v28 = 0;
    v29 = 8 * (v10 >> 3);
    do
    {
      v30 = v29 + v28;
      v31 = *(a2 + v28);
      *(v30 + 16) = *(a2 + v28 + 16);
      *v30 = v31;
      v28 += 24;
    }

    while (v28 != 192);
    v32 = a1[1];
    if (v32)
    {
      v33 = v29 + 192;
      do
      {
        v34 = *v5;
        *(v33 + 16) = *(v5 + 2);
        *v33 = v34;
        v33 += 24;
        v5 = (v5 + 24);
      }

      while (v5 != v32);
      v32 = a1[1];
    }

    v35 = v29 + 192 + v32;
    a1[1] = 0;
    v36 = *a1;
    v37 = v29 + *a1;
    if (*a1)
    {
      v38 = v37;
      do
      {
        v39 = *v36;
        *(v38 + 16) = v36[2];
        *v38 = v39;
        v38 += 24;
        v36 += 3;
      }

      while (v36);
      v36 = *a1;
    }

    *a1 = v37;
    a1[1] = v35;
    a1[2] = 0;
    if (v36)
    {

      operator delete(v36);
    }
  }
}

double geo::OrientedBox<double,3u,double,double>::pointAt(uint64_t a1, uint64_t a2)
{
  v10[0] = gm::Box<double,3>::lerped((a1 + 56), a2);
  v10[1] = v3;
  v10[2] = v4;
  v11 = *(a1 + 24);
  v12 = *(a1 + 40);
  v13 = *(a1 + 48);
  v5 = gm::Quaternion<double>::operator*(&v11, v10);
  v6 = 0;
  *v14 = v5;
  v14[1] = v7;
  v14[2] = v8;
  do
  {
    *(&v15 + v6 * 8) = *&v14[v6] + *(a1 + v6 * 8);
    ++v6;
  }

  while (v6 != 3);
  return v15;
}

uint64_t gdc::fastFrustumBoxIntersection<double>(uint64_t a1, double *a2)
{
  v2 = 0;
  v3 = 0;
  for (i = 0; i != 6; ++i)
  {
    v5 = (a1 + 32 * gdc::fastFrustumBoxIntersection<double>(geo::Frustum<double> const&,gm::Box<double,3> const&)::planeOrder[i]);
    v6 = *v5;
    v7 = v5[1];
    v8 = v5[2];
    v9 = v5[3];
    if (v6 < 0.0)
    {
      v10 = *a2;
    }

    else
    {
      v10 = a2[3];
    }

    if (v7 < 0.0)
    {
      v11 = a2[1];
    }

    else
    {
      v11 = a2[4];
    }

    if (v8 < 0.0)
    {
      v12 = a2[2];
    }

    else
    {
      v12 = a2[5];
    }

    if ((((v9 + (v10 * v6)) + (v11 * v7)) + (v12 * v8)) < 0.0)
    {
      break;
    }

    if (v6 < 0.0)
    {
      v13 = a2[3];
    }

    else
    {
      v13 = *a2;
    }

    if (v7 < 0.0)
    {
      v14 = a2[4];
    }

    else
    {
      v14 = a2[1];
    }

    if (v8 < 0.0)
    {
      v15 = a2[5];
    }

    else
    {
      v15 = a2[2];
    }

    if ((((v9 + (v13 * v6)) + (v14 * v7)) + (v15 * v8)) >= 0.0)
    {
      ++v3;
    }

    v2 = i > 4;
  }

  if (v3 == 6)
  {
    v16 = 1;
  }

  else
  {
    v16 = 2;
  }

  if (v2)
  {
    return v16;
  }

  else
  {
    return 0;
  }
}

void gdc::GlobeTileSelector::~GlobeTileSelector(gdc::GlobeTileSelector *this)
{
  gdc::GlobeTileSelector::~GlobeTileSelector(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A60900;
  std::__function::__value_func<float ()(void)>::~__value_func[abi:nn200100](this + 432);
  std::__function::__value_func<std::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__value_func[abi:nn200100](this + 400);
  std::__function::__value_func<void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::~__value_func[abi:nn200100](this + 368);
  if (*(this + 352) == 1)
  {
    v2 = *(this + 43);
    if (v2 == (this + 320))
    {
      (*(*v2 + 32))(v2);
    }

    else if (v2)
    {
      (*(*v2 + 40))(v2);
    }
  }

  if (*(this + 312) == 1)
  {
    std::__function::__value_func<gdc::CameraFrame<geo::Radians,double> ()(void)>::~__value_func[abi:nn200100](this + 280);
  }

  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 31);
  v3 = *(this + 28);
  if (v3)
  {
    do
    {
      v4 = *v3;
      operator delete(v3);
      v3 = v4;
    }

    while (v4);
  }

  v5 = *(this + 26);
  *(this + 26) = 0;
  if (v5)
  {
    operator delete(v5);
  }

  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 22);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 136);
  std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(this + 13);
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 64);
  v6 = *(this + 3);
  if (v6)
  {
    *(this + 4) = v6;
    operator delete(v6);
  }
}

uint64_t gdc::LayerDataKey::operator<(unsigned __int16 *a1, unsigned __int16 *a2)
{
  v2 = *a1;
  v3 = *a2;
  if (v2 == v3)
  {
    return gdc::GenericKey::operator<(*(a1 + 1), *(a1 + 2), *(a2 + 1), *(a2 + 2));
  }

  else
  {
    return v2 < v3;
  }
}

void gdc::LayerDataKey::keysInt32Str(std::string *this, unsigned __int16 *a2)
{
  gdc::GenericKey::keysInt32Str(&v10, a2 + 1);
  v4 = std::string::append(&v10, " t:", 3uLL);
  v5 = v4->__r_.__value_.__r.__words[2];
  *&v11.__r_.__value_.__l.__data_ = *&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::append(&v11, p_p, size);
  *this = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void gdc::LayerDataKey::createDebugNode(std::string *a1, unsigned __int16 *a2)
{
  std::string::basic_string[abi:nn200100]<0>(&v15, "Layer Data Key");
  gdc::DebugTreeNode::DebugTreeNode(a1, &v15);
  if (v16 < 0)
  {
    operator delete(v15);
  }

  std::string::basic_string[abi:nn200100]<0>(&v15, "Data Type");
  v4 = *a2;
  v12 = 0;
  v13 = 0;
  v14 = 1;
  v11 = 0;
  v10 = v4;
  gdc::DebugTreeNode::addProperty(a1, &v15, v9);
  if (v16 < 0)
  {
    operator delete(v15);
  }

  std::string::basic_string[abi:nn200100]<0>(&v15, "Value");
  gdc::LayerDataKey::keysInt32Str(&v5, a2);
  memset(&__p, 0, sizeof(__p));
  v8 = 4;
  std::string::operator=(&__p, &v5);
  gdc::DebugTreeNode::addProperty(a1, &v15, v6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v5.__r_.__value_.__l.__data_);
  }

  if (v16 < 0)
  {
    operator delete(v15);
  }
}

void gdc::LayerDataKeyIdPair::keysInt32Str(std::string *this, uint64_t a2)
{
  gdc::LayerDataKey::keysInt32Str(&v10, (a2 + 8));
  v4 = std::string::append(&v10, " id:", 4uLL);
  v5 = v4->__r_.__value_.__r.__words[2];
  *&v11.__r_.__value_.__l.__data_ = *&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::append(&v11, p_p, size);
  *this = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void gdc::Registry::destroy(uint64_t a1, unint64_t a2)
{
  v26 = a2;
  if (*(a1 + 40) == a2)
  {
    v4 = HIDWORD(a2);
    v5 = *(a1 + 48);
    if (HIDWORD(a2) < ((*(a1 + 56) - v5) >> 3))
    {
      v6 = (v5 + 8 * v4);
      if (__PAIR64__(v6[1], *v6) == __PAIR64__(WORD1(a2), a2) && *(v6 + 1) == HIDWORD(a2))
      {
        v7 = *(a1 + 96);
        v8 = *(v7 + 8 * v4);
        *(v7 + 8 * v4) = 0;
        if (__PAIR64__(v6[1], *v6) == __PAIR64__(WORD1(a2), a2) && *(v6 + 1) == HIDWORD(a2))
        {
          v9 = *v8;
          v10 = v8[1];
          while (v9 != v10)
          {
            v11 = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((a1 + 120), *v9);
            if (v11)
            {
              (*(*v11[3] + 16))(v11[3], a2);
            }

            v9 += 3;
          }
        }

        v13 = *(a1 + 80);
        v12 = *(a1 + 88);
        if (v13 >= v12)
        {
          v15 = *(a1 + 72);
          v16 = v13 - v15;
          v17 = (v13 - v15) >> 2;
          v18 = v17 + 1;
          if ((v17 + 1) >> 62)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          v19 = v12 - v15;
          if (v19 >> 1 > v18)
          {
            v18 = v19 >> 1;
          }

          if (v19 >= 0x7FFFFFFFFFFFFFFCLL)
          {
            v20 = 0x3FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v20 = v18;
          }

          if (v20)
          {
            std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned int>>(v20);
          }

          v21 = (v13 - v15) >> 2;
          v22 = (4 * v17);
          v23 = (4 * v17 - 4 * v21);
          *v22 = v4;
          v14 = v22 + 1;
          memcpy(v23, v15, v16);
          v24 = *(a1 + 72);
          *(a1 + 72) = v23;
          *(a1 + 80) = v14;
          *(a1 + 88) = 0;
          if (v24)
          {
            operator delete(v24);
          }
        }

        else
        {
          *v13 = v4;
          v14 = v13 + 4;
        }

        *(a1 + 80) = v14;
        *(*(a1 + 48) + 8 * v4) = a2 | 0xFFFFFFFF00000000;
        for (i = *(a1 + 280); i; i = *i)
        {
          std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(i[6], a1, &v26, 1);
        }

        if (v8)
        {
          std::default_delete<std::vector<gm::Matrix<float,2,1>>>::operator()[abi:nn200100](v8);
        }
      }
    }
  }
}

std::string *gdc::Registry::stringForComponentTypeId(std::string *this, uint64_t a2, unint64_t a3)
{
  result = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::find<unsigned long>((a2 + 120), a3);
  if (result)
  {
    data = result[1].__r_.__value_.__l.__data_;
    v7 = *(data + 3);
    if (v7 >= 0x7FFFFFFFFFFFFFF8)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = *(data + 2);
    if (v7 >= 0x17)
    {
      operator new();
    }

    *(&this->__r_.__value_.__s + 23) = v7;
    if (v7)
    {
      result = memmove(this, v8, v7);
    }

    this->__r_.__value_.__s.__data_[v7] = 0;
  }

  else
  {

    return std::to_string(this, a3);
  }

  return result;
}

void gdc::Timer::start(gdc::Timer *this, double a2, double a3)
{
  std::mutex::lock((this + 16));
  if (*(this + 10))
  {
    *(this + 96) = 1;
    *(this + 1) = a3;
    *(this + 11) = CFAbsoluteTimeGetCurrent() + a2;
    v6 = *(this + 10);
    v7 = dispatch_time(0, (a2 * 1000000000.0));
    dispatch_source_set_timer(v6, v7, (a3 * 1000000000.0), 0xF4240uLL);
  }

  std::mutex::unlock((this + 16));
}

uint64_t ___ZN3gdc5Timer16setTimerCallbackENSt3__18functionIFvvEEE_block_invoke(uint64_t a1)
{
  v4 = *MEMORY[0x1E69E9840];
  v1 = *(a1 + 32);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn200100](v3, a1 + 40);
  gdc::Timer::handleEvent(v1, v3);
  return std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v3);
}

void gdc::Statistics::~Statistics(gdc::Statistics *this)
{
  gdc::Statistics::~Statistics(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A609B0;
  std::__hash_table<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::__unordered_map_hasher<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::hash<geo::StringLiteral>,std::equal_to<geo::StringLiteral>,true>,std::__unordered_map_equal<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::equal_to<geo::StringLiteral>,std::hash<geo::StringLiteral>,true>,std::allocator<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>>>::__deallocate_node(*(this + 16));
  v2 = *(this + 14);
  *(this + 14) = 0;
  if (v2)
  {
    operator delete(v2);
  }

  v3 = *(this + 11);
  if (v3)
  {
    do
    {
      v4 = *v3;
      operator delete(v3);
      v3 = v4;
    }

    while (v4);
  }

  v5 = *(this + 9);
  *(this + 9) = 0;
  if (v5)
  {
    operator delete(v5);
  }

  std::mutex::~mutex((this + 8));
}

void std::__hash_table<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::__unordered_map_hasher<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::hash<geo::StringLiteral>,std::equal_to<geo::StringLiteral>,true>,std::__unordered_map_equal<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::equal_to<geo::StringLiteral>,std::hash<geo::StringLiteral>,true>,std::allocator<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *v1;
      gdc::Histogram::~Histogram((v1 + 4));
      operator delete(v1);
      v1 = v2;
    }

    while (v2);
  }
}

void gdc::Statistics::reset(gdc::Statistics *this)
{
  std::mutex::lock((this + 8));
  if (*(this + 12))
  {
    v2 = *(this + 11);
    if (v2)
    {
      do
      {
        v3 = *v2;
        operator delete(v2);
        v2 = v3;
      }

      while (v3);
    }

    *(this + 11) = 0;
    v4 = *(this + 10);
    if (v4)
    {
      for (i = 0; i != v4; ++i)
      {
        *(*(this + 9) + 8 * i) = 0;
      }
    }

    *(this + 12) = 0;
  }

  if (*(this + 17))
  {
    std::__hash_table<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::__unordered_map_hasher<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::hash<geo::StringLiteral>,std::equal_to<geo::StringLiteral>,true>,std::__unordered_map_equal<geo::StringLiteral,std::__hash_value_type<geo::StringLiteral,gdc::Histogram>,std::equal_to<geo::StringLiteral>,std::hash<geo::StringLiteral>,true>,std::allocator<std::__hash_value_type<geo::StringLiteral,gdc::Histogram>>>::__deallocate_node(*(this + 16));
    *(this + 16) = 0;
    v6 = *(this + 15);
    if (v6)
    {
      for (j = 0; j != v6; ++j)
      {
        *(*(this + 14) + 8 * j) = 0;
      }
    }

    *(this + 17) = 0;
  }

  std::mutex::unlock((this + 8));
}

uint64_t gdc::Histogram::addSample(uint64_t a1, uint64_t a2, double a3)
{
  v28 = *MEMORY[0x1E69E9840];
  v5 = *(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      v27 = v26;
      (*(*v5 + 24))(v5, v26);
    }

    else
    {
      v27 = (*(*v5 + 16))(v5);
    }
  }

  else
  {
    v27 = 0;
  }

  v6 = vcvtmd_s64_f64(a3 / *(a1 + 8));
  v7 = *(a1 + 24);
  if (!*&v7)
  {
    goto LABEL_23;
  }

  v8 = vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    v9 = v6;
    if (*&v7 <= v6)
    {
      v9 = v6 % *&v7;
    }
  }

  else
  {
    v9 = (*&v7 - 1) & v6;
  }

  v10 = *(*(a1 + 16) + 8 * v9);
  if (!v10 || (v11 = *v10) == 0)
  {
LABEL_23:
    operator new();
  }

  while (1)
  {
    v12 = v11[1];
    if (v12 == v6)
    {
      break;
    }

    if (v8.u32[0] > 1uLL)
    {
      if (v12 >= *&v7)
      {
        v12 %= *&v7;
      }
    }

    else
    {
      v12 &= *&v7 - 1;
    }

    if (v12 != v9)
    {
      goto LABEL_23;
    }

LABEL_22:
    v11 = *v11;
    if (!v11)
    {
      goto LABEL_23;
    }
  }

  if (v11[2] != v6)
  {
    goto LABEL_22;
  }

  ++v11[3];
  if (*(a1 + 64) != 1)
  {
    v14 = (a1 + 72);
LABEL_30:
    v20 = *v14;
    v20->__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    goto LABEL_31;
  }

  v13 = *(a1 + 56);
  if (v13 == v6 || !v27)
  {
LABEL_31:
    *(a1 + 56) = v6;
    *(a1 + 64) = 1;
    return std::__function::__value_func<void ()(double,double,double)>::~__value_func[abi:nn200100](v26);
  }

  v14 = (a1 + 72);
  v15 = *(a1 + 72);
  v16 = *(a1 + 8);
  v17 = v16 * v6;
  v18 = v16 * v13;
  v19 = (std::chrono::steady_clock::now().__d_.__rep_ - *v15) * 0.000000001;
  v24 = v18;
  v25 = v17;
  v23 = v19;
  if (v27)
  {
    (*(*v27 + 48))(v27, &v25, &v24, &v23);
    goto LABEL_30;
  }

  v22 = std::__throw_bad_function_call[abi:nn200100]();
  return std::__function::__value_func<void ()(double,double,double)>::~__value_func[abi:nn200100](v22);
}

uint64_t std::__function::__value_func<void ()(double,double,double)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

void gdc::Statistics::getAllSamplers(gdc::Statistics *this, uint64_t a2)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  std::mutex::lock((a2 + 8));
  v4 = *(a2 + 96);
  if (v4)
  {
    if (v4 <= 0x555555555555555)
    {
      v15 = this;
      std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Sampler>>>(v4);
    }

LABEL_22:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v5 = *(a2 + 88);
  if (v5)
  {
    v6 = *(this + 1);
    do
    {
      v7 = v5[2];
      v8 = *(this + 2);
      if (v6 >= v8)
      {
        v9 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *this) >> 4);
        v10 = v9 + 1;
        if (v9 + 1 > 0x555555555555555)
        {
          goto LABEL_22;
        }

        v11 = 0xAAAAAAAAAAAAAAABLL * ((v8 - *this) >> 4);
        if (2 * v11 > v10)
        {
          v10 = 2 * v11;
        }

        if (v11 >= 0x2AAAAAAAAAAAAAALL)
        {
          v12 = 0x555555555555555;
        }

        else
        {
          v12 = v10;
        }

        v15 = this;
        if (v12)
        {
          std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Sampler>>>(v12);
        }

        v13 = 48 * v9;
        __p[0] = 0;
        __p[1] = v13;
        *v13 = v7;
        *(v13 + 8) = *(v5 + 2);
        *(v13 + 24) = *(v5 + 3);
        *(v13 + 40) = v5[8];
        __p[2] = (48 * v9 + 48);
        __p[3] = 0;
        std::vector<std::pair<char const*,gdc::Sampler>>::__swap_out_circular_buffer(this, __p);
        v6 = *(this + 1);
        if (__p[0])
        {
          operator delete(__p[0]);
        }
      }

      else
      {
        *v6 = v7;
        *(v6 + 8) = *(v5 + 2);
        *(v6 + 24) = *(v5 + 3);
        *(v6 + 40) = v5[8];
        v6 += 48;
      }

      *(this + 1) = v6;
      v5 = *v5;
    }

    while (v5);
  }

  std::mutex::unlock((a2 + 8));
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Sampler>>>(unint64_t a1)
{
  if (a1 < 0x555555555555556)
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t *std::vector<std::pair<char const*,gdc::Sampler>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  v2 = *result;
  v3 = result[1];
  v4 = a2[1] + *result - v3;
  if (v3 != *result)
  {
    v5 = *result;
    v6 = a2[1] + *result - v3;
    do
    {
      *v6 = *v5;
      *(v6 + 8) = *(v5 + 8);
      *(v6 + 24) = *(v5 + 24);
      *(v6 + 40) = *(v5 + 40);
      v5 += 48;
      v6 += 48;
    }

    while (v5 != v3);
  }

  a2[1] = v4;
  *result = v4;
  result[1] = v2;
  a2[1] = v2;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void gdc::Statistics::dumpSamplerValues(uint64_t a1, uint64_t *a2)
{
  *a1 = 0u;
  *(a1 + 16) = 0u;
  *(a1 + 32) = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__rehash<true>(a1, (0x5555555555555557 * ((a2[1] - *a2) >> 4)));
  v4 = *a2;
  v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      v6 = *v4;
      v7 = strlen(*v4);
      if (v7 >= 0x7FFFFFFFFFFFFFF8)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v8 = v7;
      if (v7 >= 0x17)
      {
        operator new();
      }

      v29 = v7;
      if (v7)
      {
        memmove(__dst, v6, v7);
      }

      *(__dst + v8) = 0;
      v9 = *(v4 + 8);
      v10 = v29;
      if ((v29 & 0x80u) == 0)
      {
        v11 = v29;
      }

      else
      {
        v11 = __dst[1];
      }

      std::string::basic_string[abi:nn200100](__p, v11 + 5);
      if (v27 >= 0)
      {
        v12 = __p;
      }

      else
      {
        v12 = __p[0];
      }

      if (v11)
      {
        if (v10 >= 0)
        {
          v13 = __dst;
        }

        else
        {
          v13 = __dst[0];
        }

        memmove(v12, v13, v11);
      }

      strcpy(v12 + v11, "->min");
      v30 = __p;
      std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p)[5] = v9;
      if (v27 < 0)
      {
        operator delete(__p[0]);
      }

      v14 = *(v4 + 16);
      std::string::basic_string[abi:nn200100](__p, v11 + 5);
      if (v27 >= 0)
      {
        v15 = __p;
      }

      else
      {
        v15 = __p[0];
      }

      if (v11)
      {
        if (v10 >= 0)
        {
          v16 = __dst;
        }

        else
        {
          v16 = __dst[0];
        }

        memmove(v15, v16, v11);
      }

      strcpy(v15 + v11, "->max");
      v30 = __p;
      std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p)[5] = v14;
      if (v27 < 0)
      {
        operator delete(__p[0]);
      }

      v17 = *(v4 + 24);
      std::string::basic_string[abi:nn200100](__p, v11 + 5);
      if (v27 >= 0)
      {
        v18 = __p;
      }

      else
      {
        v18 = __p[0];
      }

      if (v11)
      {
        if (v10 >= 0)
        {
          v19 = __dst;
        }

        else
        {
          v19 = __dst[0];
        }

        memmove(v18, v19, v11);
      }

      strcpy(v18 + v11, "->avg");
      v30 = __p;
      std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p)[5] = v17;
      if (v27 < 0)
      {
        operator delete(__p[0]);
      }

      v20 = *(v4 + 32);
      std::string::basic_string[abi:nn200100](__p, v11 + 5);
      if (v27 >= 0)
      {
        v21 = __p;
      }

      else
      {
        v21 = __p[0];
      }

      if (v11)
      {
        if (v10 >= 0)
        {
          v22 = __dst;
        }

        else
        {
          v22 = __dst[0];
        }

        memmove(v21, v22, v11);
      }

      strcpy(v21 + v11, "->sum");
      v30 = __p;
      std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p)[5] = v20;
      if (v27 < 0)
      {
        operator delete(__p[0]);
      }

      v23 = *(v4 + 40);
      std::string::basic_string[abi:nn200100](__p, v11 + 7);
      if (v27 >= 0)
      {
        v24 = __p;
      }

      else
      {
        v24 = __p[0];
      }

      if (v11)
      {
        if (v10 >= 0)
        {
          v25 = __dst;
        }

        else
        {
          v25 = __dst[0];
        }

        memmove(v24, v25, v11);
      }

      strcpy(v24 + v11, "->count");
      v30 = __p;
      *(std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p) + 5) = v23;
      if (v27 < 0)
      {
        operator delete(__p[0]);
        if (v10 < 0)
        {
LABEL_64:
          operator delete(__dst[0]);
        }
      }

      else if (v10 < 0)
      {
        goto LABEL_64;
      }

      v4 += 48;
    }

    while (v4 != v5);
  }
}

void *std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(void *a1, uint64_t a2)
{
  v4 = *(a2 + 23);
  if (v4 >= 0)
  {
    v5 = a2;
  }

  else
  {
    v5 = *a2;
  }

  if (v4 >= 0)
  {
    v6 = *(a2 + 23);
  }

  else
  {
    v6 = *(a2 + 8);
  }

  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn200100](v5, v6);
  v8 = v7;
  v9 = a1[1];
  if (!*&v9)
  {
    goto LABEL_24;
  }

  v10 = vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    v12 = v7;
    if (v7 >= *&v9)
    {
      v12 = v7 % *&v9;
    }
  }

  else
  {
    v12 = (*&v9 - 1) & v7;
  }

  v13 = *(*a1 + 8 * v12);
  if (!v13 || (v14 = *v13) == 0)
  {
LABEL_24:
    operator new();
  }

  while (1)
  {
    v15 = v14[1];
    if (v15 == v8)
    {
      break;
    }

    if (v11 > 1)
    {
      if (v15 >= *&v9)
      {
        v15 %= *&v9;
      }
    }

    else
    {
      v15 &= *&v9 - 1;
    }

    if (v15 != v12)
    {
      goto LABEL_24;
    }

LABEL_23:
    v14 = *v14;
    if (!v14)
    {
      goto LABEL_24;
    }
  }

  if (!std::equal_to<std::string>::operator()[abi:nn200100](v14 + 2, a2))
  {
    goto LABEL_23;
  }

  return v14;
}

void gdc::Statistics::getAllHistograms(gdc::Statistics *this, uint64_t a2)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  std::mutex::lock((a2 + 8));
  v4 = *(a2 + 136);
  if (v4)
  {
    if (!(v4 >> 60))
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Histogram const&>>>(v4);
    }

LABEL_21:
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  v5 = 0;
  v16 = a2;
  for (i = *(a2 + 128); i; i = *i)
  {
    v7 = i[2];
    v8 = i + 4;
    v9 = *(this + 2);
    if (v5 >= v9)
    {
      v10 = *this;
      v11 = v5 - *this;
      v12 = (v11 >> 4) + 1;
      if (v12 >> 60)
      {
        goto LABEL_21;
      }

      v13 = v9 - v10;
      if (v13 >> 3 > v12)
      {
        v12 = v13 >> 3;
      }

      if (v13 >= 0x7FFFFFFFFFFFFFF0)
      {
        v14 = 0xFFFFFFFFFFFFFFFLL;
      }

      else
      {
        v14 = v12;
      }

      if (v14)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Histogram const&>>>(v14);
      }

      v15 = (16 * (v11 >> 4));
      *v15 = v7;
      v15[1] = v8;
      v5 = v15 + 2;
      memcpy(0, v10, v11);
      *this = 0;
      *(this + 2) = 0;
      if (v10)
      {
        operator delete(v10);
      }
    }

    else
    {
      *v5 = v7;
      v5[1] = v8;
      v5 += 2;
    }

    *(this + 1) = v5;
  }

  std::mutex::unlock((v16 + 8));
}

void std::__allocate_at_least[abi:nn200100]<std::allocator<std::pair<char const*,gdc::Histogram const&>>>(unint64_t a1)
{
  if (!(a1 >> 60))
  {
    operator new();
  }

  std::__throw_bad_array_new_length[abi:nn200100]();
}

uint64_t gdc::Tiled::stringFromLayerDataKey(_BYTE *a1, uint64_t a2)
{
  std::ostringstream::basic_ostringstream[abi:nn200100](&v14);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(&v14, "Tile ", 5);
  v4 = MEMORY[0x1B8C61C80](&v14, **(a2 + 16));
  v5 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v4, ".", 1);
  v6 = MEMORY[0x1B8C61C80](v5, *(*(a2 + 16) + 4));
  v7 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v6, ".", 1);
  v8 = MEMORY[0x1B8C61C90](v7, *(*(a2 + 16) + 8));
  v9 = std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>(v8, " t:", 3);
  MEMORY[0x1B8C61C80](v9, *(*(a2 + 16) + 12));
  if ((v21 & 0x10) != 0)
  {
    v11 = v20;
    if (v20 < v17)
    {
      v20 = v17;
      v11 = v17;
    }

    locale = v16[4].__locale_;
  }

  else
  {
    if ((v21 & 8) == 0)
    {
      v10 = 0;
      a1[23] = 0;
      goto LABEL_14;
    }

    locale = v16[1].__locale_;
    v11 = v16[3].__locale_;
  }

  v10 = v11 - locale;
  if ((v11 - locale) >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (v10 >= 0x17)
  {
    operator new();
  }

  a1[23] = v10;
  if (v10)
  {
    memmove(a1, locale, v10);
  }

LABEL_14:
  a1[v10] = 0;
  v14 = *MEMORY[0x1E69E54E8];
  *(&v14 + *(v14 - 24)) = *(MEMORY[0x1E69E54E8] + 24);
  v15 = MEMORY[0x1E69E5548] + 16;
  if (v19 < 0)
  {
    operator delete(__p);
  }

  v15 = MEMORY[0x1E69E5538] + 16;
  std::locale::~locale(v16);
  std::ostream::~ostream();
  return MEMORY[0x1B8C620C0](&v22);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_9TaskStateEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskState>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskState>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::TaskState>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v14 & 0x3F;
        v16 = v10[7];
        v17 = *(v16 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8));
        v18 = v13 & 0x3F;
        v19 = *(v16 + ((v13 >> 3) & 0x1FF8));
        LOBYTE(v16) = *(v19 + v18);
        *(v19 + v18) = *(v17 + v15);
        *(v17 + v15) = v16;
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskState>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskState>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60F90;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60FB0;
    ;
  }

  v3 = a1[7];
  v4 = a1[8];
  while (v3 != v4)
  {
    if (*v3)
    {
      operator delete(*v3);
    }

    ++v3;
  }

  v5 = a1[10];
  if (v5)
  {
    a1[11] = v5;
    operator delete(v5);
  }

  v6 = a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60F90;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::TaskState,64ul>::~storage(a1);
}

void std::__function::__func<ecs2::Runtime::execute(ecs2::Entity)::$_1,std::allocator<ecs2::Runtime::execute(ecs2::Entity)::$_1>,void ()(std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&)>::operator()(uint64_t a1)
{
  v8[1] = *(*(a1 + 8) + 8);
  v9 = 4;
  ecs2::Runtime::_localState();
  v1 = ecs2::Runtime::_stackIndex();
  v3 = v2 + 104 * *v1;
  v4 = v3 + 28;
  v5 = *(v3 + 92);
  v10 = v4;
  v11 = v5;
  v8[0] = v6;
  std::invoke[abi:nn200100]<std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&,ecs2::ExecutionDebugTaskContext&>(*(v7 + 24), v8);
}

void std::invoke[abi:nn200100]<std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&,ecs2::ExecutionDebugTaskContext&>(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 16);
  v4[0] = *a2;
  v4[1] = v2;
  v5 = *(a2 + 32);
  if (a1)
  {
    (*(*a1 + 48))(a1, v4);
  }

  else
  {
    v3 = std::__throw_bad_function_call[abi:nn200100]();
    std::__function::__func<ecs2::Runtime::execute(ecs2::Entity)::$_1,std::allocator<ecs2::Runtime::execute(ecs2::Entity)::$_1>,void ()(std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&)>::destroy_deallocate(v3);
  }
}

__n128 std::__function::__func<ecs2::Runtime::execute(ecs2::Entity)::$_1,std::allocator<ecs2::Runtime::execute(ecs2::Entity)::$_1>,void ()(std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A60AB0;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::Runtime::execute(ecs2::Entity)::$_0,std::allocator<ecs2::Runtime::execute(ecs2::Entity)::$_0>,void ()(std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  v2 = *(a1 + 16);
  v3 = *(*(a1 + 8) + 8);
  v5 = 2;
  v6 = 0;
  v7 = 0;
  v4[0] = v2;
  v4[1] = v3;
  std::invoke[abi:nn200100]<std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&,ecs2::ExecutionDebugTaskContext&>(*(a2 + 24), v4);
}

__n128 std::__function::__func<ecs2::Runtime::execute(ecs2::Entity)::$_0,std::allocator<ecs2::Runtime::execute(ecs2::Entity)::$_0>,void ()(std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A60A68;
  result = *(a1 + 8);
  *(a2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_12TaskMetadataEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskMetadata>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskMetadata>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::TaskMetadata>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v10[7];
        v16 = *(v15 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 40 * (v14 & 0x3F);
        v17 = *(v15 + ((v13 >> 3) & 0x1FF8)) + 40 * (v13 & 0x3F);
        v22 = *v17;
        v23 = *(v17 + 4);
        v18 = *(v17 + 8);
        *v24 = *(v17 + 16);
        *&v24[7] = *(v17 + 23);
        v19 = *(v17 + 31);
        *(v17 + 16) = 0;
        *(v17 + 24) = 0;
        *(v17 + 8) = 0;
        v20 = *(v17 + 32);
        LOWORD(v14) = *(v16 + 4);
        *v17 = *v16;
        *(v17 + 4) = v14;
        v21 = *(v16 + 24);
        *(v17 + 8) = *(v16 + 8);
        *(v17 + 24) = v21;
        *(v16 + 31) = 0;
        *(v16 + 8) = 0;
        *(v17 + 32) = *(v16 + 32);
        *(v16 + 4) = v23;
        *v16 = v22;
        if (*(v16 + 31) < 0)
        {
          operator delete(*(v16 + 8));
        }

        *(v16 + 8) = v18;
        *(v16 + 16) = *v24;
        *(v16 + 23) = *&v24[7];
        *(v16 + 31) = v19;
        *(v16 + 32) = v20;
        if (v19 < 0)
        {
          operator delete(v18);
        }

        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskMetadata>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskMetadata>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60F08;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60F28;
  v2 = a1[4];
  v3 = a1[5];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      v5 = *(a1[7] + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 40 * (v4 & 0x3F);
      if (*(v5 + 31) < 0)
      {
        operator delete(*(v5 + 8));
        v2 = a1[4];
        v3 = a1[5];
      }

      ++v4;
    }

    while (v4 < (v3 - v2) >> 2);
  }

  if (v3 != v2)
  {
    do
    {
      v2 = ecs2::sparse_set<ecs2::Entity,64ul>::erase(a1, v2);
    }

    while (a1[5] != v2);
  }

  v6 = a1[7];
  v7 = a1[8];
  while (v6 != v7)
  {
    if (*v6)
    {
      operator delete(*v6);
    }

    ++v6;
  }

  v8 = a1[10];
  if (v8)
  {
    a1[11] = v8;
    operator delete(v8);
  }

  v9 = a1[7];
  if (v9)
  {
    a1[8] = v9;
    operator delete(v9);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60F08;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::TaskMetadata,64ul>::~storage(a1);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_14FunctionHandleEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v19 = *MEMORY[0x1E69E9840];
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::FunctionHandle>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::FunctionHandle>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::FunctionHandle>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v10[7];
        v16 = *(v15 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 32 * (v14 & 0x3F);
        v17 = *(v15 + ((v13 >> 3) & 0x1FF8)) + 32 * (v13 & 0x3F);
        std::__function::__value_func<void ()(ecs2::Runtime &)>::__value_func[abi:nn200100](v18, v17);
        std::__function::__value_func<void ()(ecs2::Runtime &)>::operator=[abi:nn200100](v17, v16);
        std::__function::__value_func<void ()(ecs2::Runtime &)>::operator=[abi:nn200100](v16, v18);
        std::__function::__value_func<void ()(ecs2::Runtime &)>::~__value_func[abi:nn200100](v18);
        std::__function::__value_func<void ()(ecs2::Runtime &)>::~__value_func[abi:nn200100](v16);
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::FunctionHandle>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::FunctionHandle>(void)::metadata) = *(v3 + 4096);
}

uint64_t std::__function::__value_func<void ()(ecs2::Runtime &)>::operator=[abi:nn200100](uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 24);
  *(a1 + 24) = 0;
  if (v4 == a1)
  {
    (*(*v4 + 32))(v4);
  }

  else if (v4)
  {
    (*(*v4 + 40))(v4);
  }

  v5 = *(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = v5;
      *(a2 + 24) = 0;
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60D38;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60D58;
  v2 = a1[4];
  v3 = a1[5];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      std::__function::__value_func<void ()(ecs2::Runtime &)>::~__value_func[abi:nn200100](*(a1[7] + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 32 * (v4 & 0x3F));
      ++v4;
      v2 = a1[4];
      v3 = a1[5];
    }

    while (v4 < (v3 - v2) >> 2);
  }

  if (v3 != v2)
  {
    do
    {
      v2 = ecs2::sparse_set<ecs2::Entity,64ul>::erase(a1, v2);
    }

    while (a1[5] != v2);
  }

  v5 = a1[7];
  v6 = a1[8];
  while (v5 != v6)
  {
    if (*v5)
    {
      operator delete(*v5);
    }

    ++v5;
  }

  v7 = a1[10];
  if (v7)
  {
    a1[11] = v7;
    operator delete(v7);
  }

  v8 = a1[7];
  if (v8)
  {
    a1[8] = v8;
    operator delete(v8);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60D38;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::FunctionHandle,64ul>::~storage(a1);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_16TaskDependenciesEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDependencies>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDependencies>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::TaskDependencies>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v10[7];
        v16 = *(v15 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 48 * (v14 & 0x3F);
        v17 = *(v15 + ((v13 >> 3) & 0x1FF8)) + 48 * (v13 & 0x3F);
        v22 = *v17;
        v18 = *(v17 + 16);
        *v17 = 0;
        *(v17 + 8) = 0;
        *(v17 + 16) = 0;
        v24 = *(v17 + 24);
        v23 = *(v17 + 40);
        *(v17 + 24) = 0;
        *(v17 + 32) = 0;
        *(v17 + 40) = 0;
        *v17 = *v16;
        *(v17 + 16) = *(v16 + 16);
        *v16 = 0;
        *(v16 + 8) = 0;
        *(v16 + 16) = 0;
        v19 = *(v17 + 24);
        if (v19)
        {
          *(v17 + 32) = v19;
          operator delete(v19);
          *(v17 + 24) = 0;
          *(v17 + 32) = 0;
          *(v17 + 40) = 0;
        }

        *(v17 + 24) = *(v16 + 24);
        *(v17 + 40) = *(v16 + 40);
        *(v16 + 24) = 0;
        *(v16 + 32) = 0;
        *(v16 + 40) = 0;
        v20 = *v16;
        if (*v16)
        {
          *(v16 + 8) = v20;
          operator delete(v20);
          v21 = *(v16 + 24);
          *v16 = v22;
          *(v16 + 16) = v18;
          if (v21)
          {
            *(v16 + 32) = v21;
            operator delete(v21);
          }
        }

        else
        {
          *v16 = v22;
          *(v16 + 16) = v18;
        }

        *(v16 + 24) = v24;
        *(v16 + 40) = v23;
        std::__destroy_at[abi:nn200100]<md::MuninRoadEdgePolyline,0>(v16);
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDependencies>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDependencies>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60DC0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60DE0;
  v2 = a1[4];
  v3 = a1[5];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      std::__destroy_at[abi:nn200100]<md::MuninRoadEdgePolyline,0>(*(a1[7] + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 48 * (v4 & 0x3F));
      ++v4;
      v2 = a1[4];
      v3 = a1[5];
    }

    while (v4 < (v3 - v2) >> 2);
  }

  if (v3 != v2)
  {
    do
    {
      v2 = ecs2::sparse_set<ecs2::Entity,64ul>::erase(a1, v2);
    }

    while (a1[5] != v2);
  }

  v5 = a1[7];
  v6 = a1[8];
  while (v5 != v6)
  {
    if (*v5)
    {
      operator delete(*v5);
    }

    ++v5;
  }

  v7 = a1[10];
  if (v7)
  {
    a1[11] = v7;
    operator delete(v7);
  }

  v8 = a1[7];
  if (v8)
  {
    a1[8] = v8;
    operator delete(v8);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60DC0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::TaskDependencies,64ul>::~storage(a1);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_10TaskHandleEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskHandle>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskHandle>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::TaskHandle>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v14 & 0x3F;
        v16 = v10[7];
        v17 = *(v16 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8));
        v18 = v13 & 0x3F;
        v19 = *(v16 + ((v13 >> 3) & 0x1FF8));
        v20 = *(v19 + 8 * v18);
        *(v19 + 8 * v18) = *(v17 + 8 * v15);
        *(v17 + 8 * v15) = v20;
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskHandle>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskHandle>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60AF8;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60B18;
    ;
  }

  v3 = a1[7];
  v4 = a1[8];
  while (v3 != v4)
  {
    if (*v3)
    {
      operator delete(*v3);
    }

    ++v3;
  }

  v5 = a1[10];
  if (v5)
  {
    a1[11] = v5;
    operator delete(v5);
  }

  v6 = a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60AF8;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::TaskHandle,64ul>::~storage(a1);
}

uint64_t std::__function::__value_func<void ()(ecs2::ExecutionDebugTaskContext)>::__value_func[abi:nn200100](uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(a1 + 24) = a1;
      (*(**(a2 + 24) + 24))(*(a2 + 24), a1);
    }

    else
    {
      *(a1 + 24) = (*(*v3 + 16))(v3);
    }
  }

  else
  {
    *(a1 + 24) = 0;
  }

  return a1;
}

uint64_t std::vector<std::pair<ecs2::ExecutionDebugTaskOrderingFlags,std::function<void ()(ecs2::ExecutionDebugTaskContext)>>>::__emplace_back_slow_path<ecs2::ExecutionDebugTaskOrderingFlags const&,std::function<void ()(ecs2::ExecutionDebugTaskContext)> const&>(uint64_t *a1, _DWORD *a2, uint64_t a3)
{
  v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x666666666666666)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v4)
  {
    v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  }

  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333)
  {
    v6 = 0x666666666666666;
  }

  else
  {
    v6 = v4;
  }

  if (v6)
  {
    if (v6 <= 0x666666666666666)
    {
      operator new();
    }

    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  *(8 * ((a1[1] - *a1) >> 3)) = *a2;
  std::__function::__value_func<void ()(ecs2::ExecutionDebugTaskContext)>::__value_func[abi:nn200100](40 * v3 + 8, a3);
  v8 = *a1;
  v7 = a1[1];
  v9 = 40 * v3 - &v7[-*a1];
  if (v7 != *a1)
  {
    v10 = 0;
    v11 = -8 * (&v7[-*a1] >> 3) + 40 * v3;
    while (1)
    {
      v12 = &v8[v10];
      *(v9 + v10) = *&v8[v10];
      v13 = *&v8[v10 + 32];
      if (v13)
      {
        v14 = v11 + v10;
        if (v12 + 8 == v13)
        {
          *(v14 + 32) = v9 + v10 + 8;
          (*(**(v12 + 4) + 24))(*(v12 + 4));
          goto LABEL_18;
        }

        *(v14 + 32) = v13;
      }

      else
      {
        v12 = (v11 + v10);
      }

      *(v12 + 4) = 0;
LABEL_18:
      v10 += 40;
      if (&v8[v10] == v7)
      {
        do
        {
          std::__function::__value_func<void ()(ecs2::ExecutionDebugTaskContext)>::~__value_func[abi:nn200100]((v8 + 8));
          v8 += 40;
        }

        while (v8 != v7);
        break;
      }
    }
  }

  v15 = *a1;
  *a1 = v9;
  a1[1] = 40 * v3 + 40;
  a1[2] = 0;
  if (v15)
  {
    operator delete(v15);
  }

  return 40 * v3 + 40;
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_14TaskDescriptorEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDescriptor>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDescriptor>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::TaskDescriptor>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v14 & 0x3F;
        v16 = v10[7];
        v17 = *(v16 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8));
        v18 = *(v16 + ((v13 >> 3) & 0x1FF8)) + 32 * (v13 & 0x3F);
        LOWORD(v16) = *v18;
        v19 = v17 + 32 * v15;
        v20 = *(v18 + 8);
        *&v22 = *(v18 + 16);
        *(&v22 + 7) = *(v18 + 23);
        LODWORD(v15) = *(v18 + 31);
        *(v18 + 16) = 0;
        *(v18 + 24) = 0;
        *(v18 + 8) = 0;
        *v18 = *v19;
        v21 = *(v19 + 8);
        *(v18 + 24) = *(v19 + 24);
        *(v18 + 8) = v21;
        *v19 = v16;
        *(v19 + 23) = *(&v22 + 7);
        *(v19 + 8) = v20;
        *(v19 + 16) = v22;
        *(v19 + 31) = v15;
        if ((v15 & 0x80000000) != 0)
        {
          operator delete(v20);
        }

        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDescriptor>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::TaskDescriptor>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60CB0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60CD0;
  v2 = a1[4];
  v3 = a1[5];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      v5 = *(a1[7] + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 32 * (v4 & 0x3F);
      if (*(v5 + 31) < 0)
      {
        operator delete(*(v5 + 8));
        v2 = a1[4];
        v3 = a1[5];
      }

      ++v4;
    }

    while (v4 < (v3 - v2) >> 2);
  }

  if (v3 != v2)
  {
    do
    {
      v2 = ecs2::sparse_set<ecs2::Entity,64ul>::erase(a1, v2);
    }

    while (a1[5] != v2);
  }

  v6 = a1[7];
  v7 = a1[8];
  while (v6 != v7)
  {
    if (*v6)
    {
      operator delete(*v6);
    }

    ++v6;
  }

  v8 = a1[10];
  if (v8)
  {
    a1[11] = v8;
    operator delete(v8);
  }

  v9 = a1[7];
  if (v9)
  {
    a1[8] = v9;
    operator delete(v9);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60CB0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::TaskDescriptor,64ul>::~storage(a1);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_17ExecutionMetadataEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::ExecutionMetadata>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::ExecutionMetadata>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::ExecutionMetadata>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = v8 + 4 * v9;
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v10[7];
        v16 = *(v15 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8));
        v17 = *(v15 + ((*(v13 + 2) >> 3) & 0x1FF8)) + 32 * (*(v13 + 2) & 0x3FLL);
        v25[0] = v25;
        v25[1] = v25;
        v26 = 0;
        v18 = *(v17 + 16);
        if (v18)
        {
          v20 = *v17;
          v19 = *(v17 + 8);
          v21 = *(*v17 + 8);
          v22 = *v19;
          *(v22 + 8) = v21;
          *v21 = v22;
          v23 = v25[0];
          *(v25[0] + 8) = v19;
          *v19 = v23;
          *(v20 + 8) = v25;
          v25[0] = v20;
          v26 = v18;
          *(v17 + 16) = 0;
        }

        v24 = v16 + 32 * (v14 & 0x3F);
        v27 = *(v17 + 24);
        std::list<ecs2::Entity>::__move_assign(v17, v24);
        *(v17 + 24) = *(v24 + 24);
        std::list<ecs2::Entity>::__move_assign(v24, v25);
        *(v24 + 24) = v27;
        std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(v25);
        std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(v24);
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::ExecutionMetadata>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::ExecutionMetadata>(void)::metadata) = *(v3 + 4096);
}

void *std::list<ecs2::Entity>::__move_assign(uint64_t *a1, void *a2)
{
  result = std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear(a1);
  v5 = a2[2];
  if (v5)
  {
    v7 = *a2;
    v6 = a2[1];
    v8 = *(*a2 + 8);
    v9 = *v6;
    *(v9 + 8) = v8;
    *v8 = v9;
    v10 = *a1;
    *(v10 + 8) = v6;
    *v6 = v10;
    *a1 = v7;
    *(v7 + 8) = a1;
    a1[2] += v5;
    a2[2] = 0;
  }

  return result;
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60BA0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60BC0;
  v2 = a1[4];
  v3 = a1[5];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      std::__list_imp<std::pair<unsigned long long,unsigned char>>::clear((*(a1[7] + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) + 32 * (v4 & 0x3F)));
      ++v4;
      v2 = a1[4];
      v3 = a1[5];
    }

    while (v4 < (v3 - v2) >> 2);
  }

  if (v3 != v2)
  {
    do
    {
      v2 = ecs2::sparse_set<ecs2::Entity,64ul>::erase(a1, v2);
    }

    while (a1[5] != v2);
  }

  v5 = a1[7];
  v6 = a1[8];
  while (v5 != v6)
  {
    if (*v5)
    {
      operator delete(*v5);
    }

    ++v5;
  }

  v7 = a1[10];
  if (v7)
  {
    a1[11] = v7;
    operator delete(v7);
  }

  v8 = a1[7];
  if (v8)
  {
    a1[8] = v8;
    operator delete(v8);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60BA0;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::ExecutionMetadata,64ul>::~storage(a1);
}

void _ZNSt3__110__function6__funcIZN4ecs213BasicRegistryIvE7storageINS2_11GraphHandleEEERN3gdc12constness_asINS2_16component_traitsIJu14__remove_constIT_EvEE12storage_typeESA_E4typeEvEUlNS2_6EntityEE_NS_9allocatorISI_EEFvSH_EEclEOSH_(uint64_t a1, unsigned int *a2)
{
  v2 = *a2;
  v3 = *(a1 + 8);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::GraphHandle>();
  v4 = ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::GraphHandle>(void)::metadata;
  v5 = ecs2::BasicRegistry<void>::storage<ecs2::GraphHandle>(v3);
  v6 = v2 >> 22;
  v7 = v5[1];
  if (v2 >> 22 < (v5[2] - v7) >> 3)
  {
    v8 = *(v7 + 8 * v6);
    if (v8)
    {
      v9 = (v2 >> 16) & 0x3F;
      if (*(v8 + 4 * v9) == v2)
      {
        v10 = v5;
        v11 = v5[31];
        v12 = v5[32];
        if (v11 != v12)
        {
          do
          {
            std::function<void ()(ecs2::Entity)>::operator()(*(v11 + 24), v2);
            v11 += 32;
          }

          while (v11 != v12);
          v8 = *(v10[1] + 8 * v6);
        }

        v13 = *(v8 + 4 * v9 + 2);
        v14 = ((v10[5] - v10[4]) >> 2) - 1;
        v15 = v14 & 0x3F;
        v16 = v10[7];
        v17 = *(v16 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8));
        v18 = v13 & 0x3F;
        v19 = *(v16 + ((v13 >> 3) & 0x1FF8));
        v20 = *(v19 + 8 * v18);
        *(v19 + 8 * v18) = *(v17 + 8 * v15);
        *(v17 + 8 * v15) = v20;
        ecs2::sparse_set<ecs2::Entity,64ul>::erase(v10, v2, WORD1(v2));
      }
    }
  }

  *(*(v3 + 41016) + (v2 >> 16 << 6) + ((v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v4);
  ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::GraphHandle>();
  *(v3 + 8 * ecs2::ComponentMetadata::get<ecs2::BasicRegistry<void>,ecs2::GraphHandle>(void)::metadata) = *(v3 + 4096);
}

void ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60C28;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));
  ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>::~storage(void *a1)
{
  *a1 = &unk_1F2A60C48;
    ;
  }

  v3 = a1[7];
  v4 = a1[8];
  while (v3 != v4)
  {
    if (*v3)
    {
      operator delete(*v3);
    }

    ++v3;
  }

  v5 = a1[10];
  if (v5)
  {
    a1[11] = v5;
    operator delete(v5);
  }

  v6 = a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }

  return ecs2::sparse_set<ecs2::Entity,64ul>::~sparse_set(a1);
}

void ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>::~storage(void *a1)
{
  ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>::~storage(a1);

  JUMPOUT(0x1B8C62190);
}

void *ecs2::signal_mixin<ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>>::~signal_mixin(void *a1)
{
  *a1 = &unk_1F2A60C28;
  ecs2::signal_mixin<ecs2::storage<ecs2::Entity,md::ls::BaseMapTileHandle,64ul>>::{unnamed type#1}::~signal_mixin((a1 + 13));

  return ecs2::storage<ecs2::Entity,ecs2::GraphHandle,64ul>::~storage(a1);
}

void *ecs2::operator<<(void *a1, uint64_t a2)
{
  dumpGraph(v4, (a2 + 96), 0);
}

unsigned __int8 *gdc::LayerDataRequestKey::LayerDataRequestKey(unsigned __int8 *a1, unsigned __int8 a2, uint64_t a3)
{
  *a1 = a2;
  *(a1 + 4) = *a3;
  *(a1 + 2) = a1 + 48;
  *(a1 + 3) = a1 + 48;
  *(a1 + 4) = a1 + 48;
  *(a1 + 5) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>(a1 + 2, *(a3 + 8), *(a3 + 16));
  v5 = *(a3 + 72);
  *(a1 + 5) = v5;
  a1[96] = 0;
  a1[100] = 0;
  *(a1 + 13) = (*(&v5 + 1) + ((*a1 - 0x61C8864680B583EBLL) << 6) + ((*a1 - 0x61C8864680B583EBLL) >> 2) - 0x61C8864680B583EBLL) ^ (*a1 - 0x61C8864680B583EBLL);
  return a1;
}

void gdc::LayerDataRequestKey::keyData(gdc::LayerDataRequestKey *this, uint64_t a2)
{
  *this = this + 32;
  *(this + 1) = this + 32;
  *(this + 2) = this + 32;
  *(this + 3) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>(this, *(a2 + 16), *(a2 + 24));
  *(this + 8) = *(a2 + 80);
}

void gdc::LayerDataRequestKey::keysInt32Str(std::string *this, unsigned __int16 *a2)
{
  gdc::LayerDataKey::keysInt32Str(&v10, a2 + 4);
  v4 = std::string::append(&v10, " kt:", 4uLL);
  v5 = v4->__r_.__value_.__r.__words[2];
  *&v11.__r_.__value_.__l.__data_ = *&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = __p.__r_.__value_.__l.__size_;
  }

  v8 = std::string::append(&v11, p_p, size);
  *this = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void gdc::LayerDataRequestKey::createDebugNode(std::string *a1, unsigned __int16 *a2)
{
  std::string::basic_string[abi:nn200100]<0>(&__p, "Layer Data Key");
  gdc::DebugTreeNode::DebugTreeNode(a1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Request Type");
  v4 = *a2;
  v18 = 0;
  memset(&v17[4], 0, 24);
  v17[0] = v4;
  gdc::DebugTreeNode::addProperty(a1, &__p, v17);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  gdc::LayerDataKey::createDebugNode(&__p, a2 + 4);
  gdc::DebugTreeNode::addChildNode(a1, &__p);
  v19 = &v16;
  std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v19);
  v19 = &v15;
  std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v19);
  if (v14 < 0)
  {
    operator delete(v13);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }

  std::string::basic_string[abi:nn200100]<0>(&__p, "Priority");
  if (*(a2 + 100) == 1)
  {
    v5 = *(a2 + 24);
  }

  else
  {
    v5 = 0xFFFFFFFFLL;
  }

  v9 = 0;
  v10 = 0;
  v11 = 1;
  v8 = 0;
  v7 = v5;
  gdc::DebugTreeNode::addProperty(a1, &__p, v6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

uint64_t std::function<void ()(gdc::tf::Task)>::operator()(uint64_t a1, uint64_t a2)
{
  v4 = a2;
  if (a1)
  {
    return (*(*a1 + 48))(a1, &v4);
  }

  v3 = std::__throw_bad_function_call[abi:nn200100]();
  return gdc::FallbackData::FallbackData(v3);
}

uint64_t gdc::FallbackData::FallbackData(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *(a1 + 24) = 0;
  *(a1 + 4) = *(a2 + 4);
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 32) = *a3;
  *(a1 + 40) = a1 + 72;
  *(a1 + 48) = a1 + 72;
  *(a1 + 56) = a1 + 72;
  *(a1 + 64) = 32;
  geo::small_vector_base<unsigned char>::append<unsigned char const*>((a1 + 40), *(a3 + 8), *(a3 + 16));
  *(a1 + 104) = *(a3 + 72);
  v7 = a4[1];
  *(a1 + 120) = *a4;
  *(a1 + 128) = v7;
  if (v7)
  {
    atomic_fetch_add_explicit((v7 + 8), 1uLL, memory_order_relaxed);
  }

  return a1;
}

uint64_t gdc::FallbackCollector::addFallbackNode(uint64_t result, const geo::QuadTile *a2, uint64_t a3, void *a4)
{
  if (*(result + 16) == 1 && *a4 != 0)
  {
    v30 = v4;
    v31 = v5;
    v9 = result;
    geo::MortonTileIndex::MortonTileIndex(&v26, a2);
    v10 = v9[12];
    if (!v10)
    {
      v11 = malloc_type_malloc(104 * v9[10], 0x103204067762A1FuLL);
      v29 = v11;
      std::__tree<geo::Pool<gdc::FallbackNode>::Element *,std::less<geo::Pool<gdc::FallbackNode>::Element *>,std::allocator<geo::Pool<gdc::FallbackNode>::Element *>>::__emplace_unique_key_args<geo::Pool<gdc::FallbackNode>::Element *,geo::Pool<gdc::FallbackNode>::Element * const&>((v9 + 7), v11);
      v10 = v9[12];
      v12 = &v11[104 * v9[10] - 104];
      if (v12 >= v11)
      {
        do
        {
          v13 = v12;
          *v12 = v10;
          v12 -= 104;
          v10 = v13;
        }

        while (v12 >= v11);
        v10 = v12 + 104;
      }

      v9[12] = v10;
    }

    v9[12] = *v10;
    *v10 = *a3;
    *(v10 + 1) = v10 + 40;
    *(v10 + 2) = v10 + 40;
    *(v10 + 3) = v10 + 40;
    *(v10 + 4) = 32;
    geo::small_vector_base<unsigned char>::append<unsigned char const*>(v10 + 1, *(a3 + 8), *(a3 + 16));
    *(v10 + 72) = *(a3 + 72);
    v14 = a4[1];
    *(v10 + 11) = *a4;
    *(v10 + 12) = v14;
    if (v14)
    {
      atomic_fetch_add_explicit((v14 + 8), 1uLL, memory_order_relaxed);
    }

    v15 = v9[4];
    if (!v15)
    {
LABEL_35:
      operator new();
    }

    v16 = v27;
    v17 = v28;
    v18 = v26;
    v19 = v28;
    while (1)
    {
      while (1)
      {
        v20 = v15;
        v21 = *(v15 + 40);
        v23 = v16 - v21;
        v22 = v16 > v21;
        if (v16 < v21)
        {
          break;
        }

        v25 = *(v20 + 41);
        if (v22)
        {
          if (v25 == v17)
          {
            if (v18 >> (2 * v23) < v20[4])
            {
              goto LABEL_17;
            }
          }

          else if (v25 > v17)
          {
            goto LABEL_17;
          }
        }

        else if (v17 == v25)
        {
          if (v18 < v20[4])
          {
            goto LABEL_17;
          }
        }

        else if (v19 < v25)
        {
          goto LABEL_17;
        }

LABEL_25:
        result = std::__map_value_compare<geo::MortonTileIndex,std::__value_type<geo::MortonTileIndex,std::bitset<82ul>>,geo::MortonTileIndexCompare,true>::operator()[abi:nn200100](v20 + 4, &v26);
        if (!result)
        {
          return result;
        }

        v15 = v20[1];
        if (!v15)
        {
          goto LABEL_35;
        }
      }

      v24 = *(v20 + 41);
      if (v17 != v24)
      {
        if (v19 < v24)
        {
          goto LABEL_17;
        }

        goto LABEL_25;
      }

      if (v18 > v20[4] >> (2 * (v21 - v16)))
      {
        goto LABEL_25;
      }

LABEL_17:
      v15 = *v20;
      if (!*v20)
      {
        goto LABEL_35;
      }
    }
  }

  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>>>::__emplace_unique_key_args<gdc::LayerDataRequestKey,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataRequestKey const&>,std::tuple<>>(void *a1, unsigned __int8 *a2)
{
  v2 = *(a2 + 13);
  v3 = a1[1];
  if (!*&v3)
  {
    goto LABEL_21;
  }

  v5 = vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    v7 = *(a2 + 13);
    if (v2 >= *&v3)
    {
      v7 = v2 % *&v3;
    }
  }

  else
  {
    v7 = (*&v3 - 1) & v2;
  }

  v8 = *(*a1 + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_21:
    operator new();
  }

  v10 = *a2;
  v11 = *(a2 + 4);
  while (1)
  {
    v12 = v9[1];
    if (v12 == v2)
    {
      break;
    }

    if (v6 > 1)
    {
      if (v12 >= *&v3)
      {
        v12 %= *&v3;
      }
    }

    else
    {
      v12 &= *&v3 - 1;
    }

    if (v12 != v7)
    {
      goto LABEL_21;
    }

LABEL_20:
    v9 = *v9;
    if (!v9)
    {
      goto LABEL_21;
    }
  }

  if (*(v9 + 16) != v10 || *(v9 + 12) != v11 || !gdc::GenericKey::operator==((v9 + 4), (a2 + 16)))
  {
    goto LABEL_20;
  }

  return v9;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,void *>>>>::~unique_ptr[abi:nn200100](uint64_t a1)
{
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(a1 + 16) == 1)
    {
      std::__destroy_at[abi:nn200100]<std::pair<gdc::LayerDataRequestKey const,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,0>(v2 + 2);
    }

    operator delete(v2);
  }

  return a1;
}

void gdc::LayerDataRequestTracker::_processKey(void *a1, unsigned __int8 *a2, uint64_t **a3, char a4)
{
  v4 = a1 + 3;
  if (!std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerDataRequest>>>>::find<gdc::LayerDataRequestKey>(a1 + 3, a2))
  {
    return;
  }

  v62[0] = a2;
  v55 = v4;
  v5 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>>>::__emplace_unique_key_args<gdc::LayerDataRequestKey,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataRequestKey const&>,std::tuple<>>(v4, a2);
  v6 = v5[16];
  v60 = v5;
  if (v5[17] != v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = v6[v7];
      v9 = *(v8 + 64);
      if (v9)
      {
        v10 = *(a2 + 13);
        v11 = vcnt_s8(v9);
        v11.i16[0] = vaddlv_u8(v11);
        v12 = v11.u32[0];
        if (v11.u32[0] > 1uLL)
        {
          v13 = *(a2 + 13);
          if (v10 >= *&v9)
          {
            v13 = v10 % *&v9;
          }
        }

        else
        {
          v13 = (*&v9 - 1) & v10;
        }

        v58 = *(v8 + 56);
        v14 = *(v58 + 8 * v13);
        if (v14)
        {
          v15 = *v14;
          if (*v14)
          {
            v16 = *&v9 - 1;
            v17 = *a2;
            v18 = *(a2 + 4);
            do
            {
              v19 = v15[1];
              if (v19 == v10)
              {
                if (*(v15 + 16) == v17 && *(v15 + 12) == v18 && gdc::GenericKey::operator==((v15 + 4), (a2 + 16)))
                {
                  v28 = v15[1];
                  if (v12 > 1)
                  {
                    v29 = v58;
                    if (v28 >= *&v9)
                    {
                      v28 %= *&v9;
                    }
                  }

                  else
                  {
                    v28 &= v16;
                    v29 = v58;
                  }

                  v30 = *(v29 + 8 * v28);
                  do
                  {
                    v31 = v30;
                    v30 = *v30;
                  }

                  while (v30 != v15);
                  if (v31 == (v8 + 72))
                  {
                    goto LABEL_55;
                  }

                  v32 = v31[1];
                  if (v12 > 1)
                  {
                    if (v32 >= *&v9)
                    {
                      v32 %= *&v9;
                    }
                  }

                  else
                  {
                    v32 &= v16;
                  }

                  if (v32 != v28)
                  {
LABEL_55:
                    if (!*v15)
                    {
                      goto LABEL_56;
                    }

                    v33 = *(*v15 + 8);
                    if (v12 > 1)
                    {
                      if (v33 >= *&v9)
                      {
                        v33 %= *&v9;
                      }
                    }

                    else
                    {
                      v33 &= v16;
                    }

                    if (v33 != v28)
                    {
LABEL_56:
                      *(v29 + 8 * v28) = 0;
                    }
                  }

                  v34 = *v15;
                  if (*v15)
                  {
                    v35 = *(v34 + 8);
                    if (v12 > 1)
                    {
                      if (v35 >= *&v9)
                      {
                        v35 %= *&v9;
                      }
                    }

                    else
                    {
                      v35 &= v16;
                    }

                    if (v35 != v28)
                    {
                      *(*(v8 + 56) + 8 * v35) = v31;
                      v34 = *v15;
                    }
                  }

                  *v31 = v34;
                  *v15 = 0;
                  --*(v8 + 80);
                  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::__list_iterator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,long long,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,void *>>,void *>>>::operator()[abi:nn200100](1, v15);
                  break;
                }
              }

              else
              {
                if (v12 > 1)
                {
                  if (v19 >= *&v9)
                  {
                    v19 %= *&v9;
                  }
                }

                else
                {
                  v19 &= v16;
                }

                if (v19 != v13)
                {
                  break;
                }
              }

              v15 = *v15;
            }

            while (v15);
          }
        }
      }

      v62[0] = a2;
      v20 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>>>>::__emplace_unique_key_args<gdc::LayerDataRequestKey,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataRequestKey const&>,std::tuple<>>((v8 + 16), a2);
      v22 = *a3;
      v21 = a3[1];
      if (v21)
      {
        atomic_fetch_add_explicit(v21 + 1, 1uLL, memory_order_relaxed);
      }

      v23 = v20[17];
      v20[16] = v22;
      v20[17] = v21;
      if (v23)
      {
        std::__shared_weak_count::__release_shared[abi:nn200100](v23);
      }

      v24 = *(v8 + 96);
      if (v24)
      {
        goto LABEL_34;
      }

      if (a4)
      {
        break;
      }

      if (!*a3)
      {
        v24 = 2;
        goto LABEL_33;
      }

      v24 = 0;
LABEL_34:
      if (!*(v8 + 80))
      {
        std::function<void ()(gdc::RequestCompletionStatus,std::unordered_map<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<std::pair<gdc::LayerDataRequestKey const,std::shared_ptr<gdc::LayerData>>>> &&)>::operator()(*(v8 + 128), v24);
        v25 = v60[16][v7];
        v27 = *v25;
        v26 = v25[1];
        *(v27 + 8) = v26;
        *v26 = v27;
        --a1[2];
        std::__list_imp<gdc::LayerDataRequestTracker::RequestStatus>::__delete_node[abi:nn200100](v25);
      }

      ++v7;
      v6 = v60[16];
      if (v7 >= v60[17] - v6)
      {
        goto LABEL_65;
      }
    }

    v24 = 1;
LABEL_33:
    *(v8 + 96) = v24;
    goto LABEL_34;
  }

LABEL_65:
  v36 = a1[4];
  if (v36)
  {
    v37 = *(a2 + 13);
    v38 = vcnt_s8(v36);
    v38.i16[0] = vaddlv_u8(v38);
    v39 = v38.u32[0];
    if (v38.u32[0] > 1uLL)
    {
      v40 = *(a2 + 13);
      if (v37 >= *&v36)
      {
        v40 = v37 % *&v36;
      }
    }

    else
    {
      v40 = (*&v36 - 1) & v37;
    }

    v41 = *v55;
    v42 = *(*v55 + 8 * v40);
    if (v42)
    {
      v43 = *v42;
      if (*v42)
      {
        v44 = *&v36 - 1;
        v45 = *a2;
        v46 = *(a2 + 4);
        do
        {
          v47 = v43[1];
          if (v47 == v37)
          {
            if (*(v43 + 16) == v45 && *(v43 + 12) == v46 && gdc::GenericKey::operator==((v43 + 4), (a2 + 16)))
            {
              v48 = v43[1];
              if (v39 > 1)
              {
                if (v48 >= *&v36)
                {
                  v48 %= *&v36;
                }
              }

              else
              {
                v48 &= v44;
              }

              v49 = *(v41 + 8 * v48);
              do
              {
                v50 = v49;
                v49 = *v49;
              }

              while (v49 != v43);
              if (v50 == a1 + 5)
              {
                goto LABEL_102;
              }

              v51 = v50[1];
              if (v39 > 1)
              {
                if (v51 >= *&v36)
                {
                  v51 %= *&v36;
                }
              }

              else
              {
                v51 &= v44;
              }

              if (v51 != v48)
              {
LABEL_102:
                if (!*v43)
                {
                  goto LABEL_103;
                }

                v52 = *(*v43 + 8);
                if (v39 > 1)
                {
                  if (v52 >= *&v36)
                  {
                    v52 %= *&v36;
                  }
                }

                else
                {
                  v52 &= v44;
                }

                if (v52 != v48)
                {
LABEL_103:
                  *(v41 + 8 * v48) = 0;
                }
              }

              v53 = *v43;
              if (*v43)
              {
                v54 = v53[1];
                if (v39 > 1)
                {
                  if (v54 >= *&v36)
                  {
                    v54 %= *&v36;
                  }
                }

                else
                {
                  v54 &= v44;
                }

                if (v54 != v48)
                {
                  *(*v55 + 8 * v54) = v50;
                  v53 = *v43;
                }
              }

              *v50 = v53;
              *v43 = 0;
              --a1[6];
              v62[0] = v43;
              v62[1] = v55;
              v63 = 1;
              memset(v64, 0, sizeof(v64));
              std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,std::vector<std::__list_iterator<gdc::LayerDataRequestTracker::RequestStatus,void *>>>,void *>>>>::~unique_ptr[abi:nn200100](v62);
              return;
            }
          }

          else
          {
            if (v39 > 1)
            {
              if (v47 >= *&v36)
              {
                v47 %= *&v36;
              }
            }

            else
            {
              v47 &= v44;
            }

            if (v47 != v40)
            {
              return;
            }
          }

          v43 = *v43;
        }

        while (v43);
      }
    }
  }
}

double gdc::S2TileSelector::createDebugNode@<D0>(_OWORD *a1@<X8>)
{
  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

void gdc::S2TileSelector::~S2TileSelector(gdc::S2TileSelector *this)
{
  *this = &unk_1F2A61040;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 24);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A61040;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 24);
}

void gdc::TileSetSelectionContext::~TileSetSelectionContext(gdc::TileSetSelectionContext *this)
{
  *this = &unk_1F2A61128;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 16);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A61128;
  std::__hash_table<md::MuninJunction const*,std::hash<md::MuninJunction const*>,std::equal_to<md::MuninJunction const*>,std::allocator<md::MuninJunction const*>>::~__hash_table(this + 16);
}

void gdc::LoadingStatusTracker::~LoadingStatusTracker(gdc::LoadingStatusTracker *this)
{
  gdc::LoadingStatusTracker::~LoadingStatusTracker(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A610D8;
  v2 = (this + 8);
  std::mutex::lock((this + 8));
  v3 = *(this + 10);
  if (v3)
  {
    *(this + 10) = 0;
  }

  std::mutex::unlock(v2);
  std::__function::__value_func<void ()(gdc::SceneStatus)>::~__value_func[abi:nn200100](this + 192);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](this + 160);
  std::__function::__value_func<void ()(NSError *)>::~__value_func[abi:nn200100](this + 128);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](this + 96);

  std::mutex::~mutex(v2);
}

void sub_1B33971E4(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(gdc::SceneStatus)>::~__value_func[abi:nn200100](v1 + 192);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v1 + 160);
  std::__function::__value_func<void ()(NSError *)>::~__value_func[abi:nn200100](v1 + 128);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn200100](v1 + 96);

  std::mutex::~mutex(v2);
  _Unwind_Resume(a1);
}

void gdc::Histogram::~Histogram(gdc::Histogram *this)
{
  gdc::Histogram::~Histogram(this);

  JUMPOUT(0x1B8C62190);
}

{
  *this = &unk_1F2A61108;
  v2 = *(this + 9);
  *(this + 9) = 0;
  if (v2)
  {
    MEMORY[0x1B8C62190](v2, 0x1000C4000313F17);
  }

  v3 = *(this + 4);
  if (v3)
  {
    do
    {
      v4 = *v3;
      operator delete(v3);
      v3 = v4;
    }

    while (v4);
  }

  v5 = *(this + 2);
  *(this + 2) = 0;
  if (v5)
  {
    operator delete(v5);
  }
}

void gdc::Histogram::getHistogramData(gdc::Histogram *this, uint64_t a2)
{
  *(this + 1) = 0u;
  *(this + 2) = 0u;
  *this = 0u;
  if (*(a2 + 40))
  {
    v4 = *(a2 + 32);
    if (v4)
    {
      v5 = 0x8000000000000000;
      v6 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        v7 = v4[2];
        if (v7 < v6)
        {
          v6 = v4[2];
        }

        if (v5 <= v7)
        {
          v5 = v4[2];
        }

        v4 = *v4;
      }

      while (v4);
    }

    else
    {
      v6 = 0x7FFFFFFFFFFFFFFFLL;
      v5 = 0x8000000000000000;
    }

    v8 = *(a2 + 8);
    *this = v8 * v6;
    *(this + 1) = v8 * (v5 + 1);
    *(this + 2) = v8;
    std::vector<gdc::Entity>::reserve(this + 3, v5 + 1 - v6);
    if (v6 <= v5)
    {
      v9 = *(this + 4);
      v10 = *(this + 5);
      do
      {
        v11 = *(a2 + 24);
        if (v11)
        {
          v12 = vcnt_s8(v11);
          v12.i16[0] = vaddlv_u8(v12);
          if (v12.u32[0] > 1uLL)
          {
            v13 = v6;
            if (v6 >= *&v11)
            {
              v13 = v6 % *&v11;
            }
          }

          else
          {
            v13 = (*&v11 - 1) & v6;
          }

          v14 = *(*(a2 + 16) + 8 * v13);
          if (v14)
          {
            for (i = *v14; i; i = *i)
            {
              v16 = i[1];
              if (v6 == v16)
              {
                if (i[2] == v6)
                {
                  v24 = i[3];
                  goto LABEL_31;
                }
              }

              else
              {
                if (v12.u32[0] > 1uLL)
                {
                  if (v16 >= *&v11)
                  {
                    v16 %= *&v11;
                  }
                }

                else
                {
                  v16 &= *&v11 - 1;
                }

                if (v16 != v13)
                {
                  break;
                }
              }
            }
          }
        }

        v24 = 0;
LABEL_31:
        if (v9 >= v10)
        {
          v17 = *(this + 3);
          v18 = v9 - v17;
          v19 = (v9 - v17) >> 3;
          v20 = v19 + 1;
          if ((v19 + 1) >> 61)
          {
            std::__throw_bad_array_new_length[abi:nn200100]();
          }

          if ((v10 - v17) >> 2 > v20)
          {
            v20 = (v10 - v17) >> 2;
          }

          if (v10 - v17 >= 0x7FFFFFFFFFFFFFF8)
          {
            v21 = 0x1FFFFFFFFFFFFFFFLL;
          }

          else
          {
            v21 = v20;
          }

          if (v21)
          {
            std::__allocate_at_least[abi:nn200100]<std::allocator<unsigned long>>(v21);
          }

          v22 = (8 * v19);
          v10 = 0;
          *v22 = v24;
          v9 = (v22 + 1);
          memcpy(0, v17, v18);
          *(this + 3) = 0;
          *(this + 5) = 0;
          if (v17)
          {
            operator delete(v17);
          }
        }

        else
        {
          *v9 = v24;
          v9 += 8;
        }

        *(this + 4) = v9;
      }

      while (v6++ != v5);
    }
  }
}

float gdc::mun::transformFromPwinTransform(uint64_t a1, uint64_t a2)
{
  v6 = xmmword_1B33B0930;
  gm::Quaternion<float>::operator*(&v7, a2 + 24, &v6);
  *a1 = *a2;
  v4 = v7;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v4;
  *(a1 + 32) = v8;
  result = v9;
  *(a1 + 36) = v9;
  return result;
}

__n128 gdc::ViewDataAccess::worldRayFromScreenCursor(uint64_t a1, uint64_t a2, double *a3, int32x2_t a4)
{
  v4 = *(a2 + 448);
  v5.f64[0] = *(a2 + 488);
  v6.f64[0] = *(a2 + 368);
  v7 = v6.f64[0] * v4;
  v5.f64[1] = *(a2 + 376);
  v8 = vmulq_n_f64(v5, v4);
  v6.f64[1] = *(a2 + 492);
  v9 = vcvtq_f64_f32(vsub_f32(vcvt_f32_s32(a4), vcvt_f32_f64(vmulq_f64(v8, v6))));
  v8.f64[0] = v7;
  v10 = vdivq_f64(vaddq_f64(v9, v9), v8);
  gdc::ViewDataAccess::worldRayFromScreenNormalizedPoint(a1, a2, a3, v10.f64[0] + -1.0, 1.0 - v10.f64[1]);
  return result;
}

void gdc::GenericKey::keysInt32Str(std::string *this, void *a2)
{
  *&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  v4 = a2[1] - *a2;
  if (v4 >= 4)
  {
    v12 = v2;
    v13 = v3;
    v7 = 0;
    v8 = v4 >> 2;
    do
    {
      if (v7)
      {
        std::string::append(this, ".", 1uLL);
      }

      std::to_string(&v11, *(*a2 + 4 * v7));
      if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v9 = &v11;
      }

      else
      {
        v9 = v11.__r_.__value_.__r.__words[0];
      }

      if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
      }

      else
      {
        size = v11.__r_.__value_.__l.__size_;
      }

      std::string::append(this, v9, size);
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v11.__r_.__value_.__l.__data_);
      }

      ++v7;
    }

    while (v8 != v7);
  }
}

std::string *gdc::DebugTreeProperty::DebugTreeProperty(std::string *this, __int128 *a2, int a3)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v5;
  }

  LODWORD(this[1].__r_.__value_.__l.__data_) = a3;
  *&this[1].__r_.__value_.__r.__words[1] = 0u;
  *&this[2].__r_.__value_.__l.__data_ = 0u;
  *&this[2].__r_.__value_.__r.__words[2] = 0u;
  return this;
}

uint64_t gdc::DebugTreeProperty::addValue(void *a1, __int128 *a2)
{
  v3 = a1[5];
  v4 = a1[6];
  if (v3 >= v4)
  {
    v7 = a1[4];
    v8 = (v3 - v7) >> 6;
    if ((v8 + 1) >> 58)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v9 = v4 - v7;
    v10 = v9 >> 5;
    if (v9 >> 5 <= (v8 + 1))
    {
      v10 = v8 + 1;
    }

    if (v9 >= 0x7FFFFFFFFFFFFFC0)
    {
      v11 = 0x3FFFFFFFFFFFFFFLL;
    }

    else
    {
      v11 = v10;
    }

    v18[4] = a1 + 4;
    if (v11)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeValue>>(v11);
    }

    v12 = v8 << 6;
    std::construct_at[abi:nn200100]<gdc::DebugTreeValue,gdc::DebugTreeValue const&,gdc::DebugTreeValue*>(v12, a2);
    v6 = v12 + 64;
    v13 = a1[4];
    v14 = a1[5];
    v15 = v12 + v13 - v14;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeValue>,gdc::DebugTreeValue*>(v13, v14, v15);
    v16 = a1[4];
    a1[4] = v15;
    a1[5] = v12 + 64;
    v17 = a1[6];
    a1[6] = 0;
    v18[2] = v16;
    v18[3] = v17;
    v18[0] = v16;
    v18[1] = v16;
    result = std::__split_buffer<gdc::DebugTreeValue>::~__split_buffer(v18);
  }

  else
  {
    result = std::construct_at[abi:nn200100]<gdc::DebugTreeValue,gdc::DebugTreeValue const&,gdc::DebugTreeValue*>(v3, a2);
    v6 = result + 64;
  }

  a1[5] = v6;
  return result;
}

void gdc::DebugTreeProperty::addTag(uint64_t a1, __int128 *a2)
{
  v4 = *(a1 + 64);
  v3 = *(a1 + 72);
  if (v4 >= v3)
  {
    v6 = *(a1 + 56);
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 3);
    if (v7 + 1 > 0xAAAAAAAAAAAAAAALL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v6) >> 3);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
    {
      v9 = v7 + 1;
    }

    if (v8 >= 0x555555555555555)
    {
      v10 = 0xAAAAAAAAAAAAAAALL;
    }

    else
    {
      v10 = v9;
    }

    v19.__end_cap_.__value_ = (a1 + 56);
    if (v10)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<std::string>>(v10);
    }

    v12 = (24 * v7);
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *a2, *(a2 + 1));
    }

    else
    {
      v13 = *a2;
      v12->__r_.__value_.__r.__words[2] = *(a2 + 2);
      *&v12->__r_.__value_.__l.__data_ = v13;
    }

    v11 = v12 + 1;
    v14 = *(a1 + 56);
    v15 = *(a1 + 64) - v14;
    v16 = v12 - v15;
    memcpy(v12 - v15, v14, v15);
    v17 = *(a1 + 56);
    *(a1 + 56) = v16;
    *(a1 + 64) = v12 + 1;
    v18 = *(a1 + 72);
    *(a1 + 72) = 0;
    v19.__end_ = v17;
    v19.__end_cap_.__value_ = v18;
    v19.__first_ = v17;
    v19.__begin_ = v17;
    std::__split_buffer<std::string>::~__split_buffer(&v19);
  }

  else
  {
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(*(a1 + 64), *a2, *(a2 + 1));
    }

    else
    {
      v5 = *a2;
      *(v4 + 16) = *(a2 + 2);
      *v4 = v5;
    }

    v11 = (v4 + 24);
  }

  *(a1 + 64) = v11;
}

void gdc::DebugTreeProperty::valueAtIndex(gdc::DebugTreeProperty *this, uint64_t a2)
{
  *this = *a2;
  *(this + 9) = *(a2 + 9);
  if (*(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((this + 32), *(a2 + 32), *(a2 + 40));
  }

  else
  {
    *(this + 2) = *(a2 + 32);
    *(this + 6) = *(a2 + 48);
  }

  *(this + 14) = *(a2 + 56);
}

std::string *gdc::DebugTreeNode::DebugTreeNode(std::string *this, __int128 *a2)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v3 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v3;
  }

  std::string::basic_string[abi:nn200100]<0>(&this[1], "");
  *&this[2].__r_.__value_.__r.__words[2] = 0u;
  *&this[3].__r_.__value_.__r.__words[1] = 0u;
  *&this[2].__r_.__value_.__l.__data_ = 0u;
  return this;
}

std::string *gdc::DebugTreeNode::DebugTreeNode(std::string *this, __int128 *a2, __int128 *a3)
{
  if (*(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *a2, *(a2 + 1));
  }

  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *(a2 + 2);
    *&this->__r_.__value_.__l.__data_ = v5;
  }

  if (*(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *a3, *(a3 + 1));
  }

  else
  {
    v6 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *(a3 + 2);
    *&this[1].__r_.__value_.__l.__data_ = v6;
  }

  *&this[2].__r_.__value_.__r.__words[2] = 0u;
  *&this[3].__r_.__value_.__r.__words[1] = 0u;
  *&this[2].__r_.__value_.__l.__data_ = 0u;
  return this;
}

std::string *gdc::DebugTreeNode::createChildNode(void *a1, __int128 *a2)
{
  v3 = a1[7];
  v4 = a1[8];
  if (v3 >= v4)
  {
    v6 = a1[6];
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v6) >> 5);
    if (v7 + 1 > 0x2AAAAAAAAAAAAAALL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 5);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
    {
      v9 = v7 + 1;
    }

    if (v8 >= 0x155555555555555)
    {
      v10 = 0x2AAAAAAAAAAAAAALL;
    }

    else
    {
      v10 = v9;
    }

    v18[4] = a1 + 6;
    if (v10)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeNode>>(v10);
    }

    v11 = (96 * v7);
    gdc::DebugTreeNode::DebugTreeNode(v11, a2);
    v5 = v11 + 4;
    v12 = a1[6];
    v13 = a1[7];
    v14 = v11 + v12 - v13;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeNode>,gdc::DebugTreeNode*>(v12, v13, v14);
    v15 = a1[6];
    a1[6] = v14;
    a1[7] = v11 + 4;
    v16 = a1[8];
    a1[8] = 0;
    v18[2] = v15;
    v18[3] = v16;
    v18[0] = v15;
    v18[1] = v15;
    std::__split_buffer<gdc::DebugTreeNode>::~__split_buffer(v18);
  }

  else
  {
    v5 = gdc::DebugTreeNode::DebugTreeNode(v3, a2) + 4;
  }

  a1[7] = v5;
  return v5 - 4;
}

void std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeNode>,gdc::DebugTreeNode*>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v10[3] = v3;
    v10[4] = v4;
    v6 = a1;
    v7 = a1;
    do
    {
      v8 = *v7;
      *(a3 + 16) = *(v7 + 2);
      *a3 = v8;
      *(v7 + 1) = 0;
      *(v7 + 2) = 0;
      *v7 = 0;
      v9 = *(v7 + 24);
      *(a3 + 40) = *(v7 + 5);
      *(a3 + 24) = v9;
      *(v7 + 4) = 0;
      *(v7 + 5) = 0;
      *(v7 + 3) = 0;
      *(a3 + 48) = 0;
      *(a3 + 56) = 0;
      *(a3 + 64) = 0;
      *(a3 + 48) = v7[3];
      *(a3 + 64) = *(v7 + 8);
      *(v7 + 6) = 0;
      *(v7 + 7) = 0;
      *(v7 + 8) = 0;
      *(a3 + 72) = 0;
      *(a3 + 80) = 0;
      *(a3 + 88) = 0;
      *(a3 + 72) = *(v7 + 72);
      *(a3 + 88) = *(v7 + 11);
      *(v7 + 9) = 0;
      *(v7 + 10) = 0;
      *(v7 + 11) = 0;
      v7 += 6;
      a3 += 96;
    }

    while (v7 != a2);
    do
    {
      v10[0] = v6 + 9;
      std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](v10);
      v10[0] = v6 + 6;
      std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](v10);
      if (*(v6 + 47) < 0)
      {
        operator delete(v6[3]);
      }

      if (*(v6 + 23) < 0)
      {
        operator delete(*v6);
      }

      v6 += 12;
    }

    while (v6 != a2);
  }
}

uint64_t std::__split_buffer<gdc::DebugTreeNode>::~__split_buffer(uint64_t a1)
{
  v2 = *(a1 + 8);
  for (i = *(a1 + 16); i != v2; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 96;
    v5 = (i - 24);
    std::vector<gdc::DebugTreeProperty>::__destroy_vector::operator()[abi:nn200100](&v5);
    v5 = (i - 48);
    std::vector<gdc::DebugTreeNode>::__destroy_vector::operator()[abi:nn200100](&v5);
    if (*(i - 49) < 0)
    {
      operator delete(*(i - 72));
    }

    if (*(i - 73) < 0)
    {
      operator delete(*(i - 96));
    }
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

std::string *gdc::DebugTreeNode::createChildNode(void *a1, __int128 *a2, __int128 *a3)
{
  v4 = a1[7];
  v5 = a1[8];
  if (v4 >= v5)
  {
    v7 = a1[6];
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v7) >> 5);
    if (v8 + 1 > 0x2AAAAAAAAAAAAAALL)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v7) >> 5);
    v10 = 2 * v9;
    if (2 * v9 <= v8 + 1)
    {
      v10 = v8 + 1;
    }

    if (v9 >= 0x155555555555555)
    {
      v11 = 0x2AAAAAAAAAAAAAALL;
    }

    else
    {
      v11 = v10;
    }

    v19[4] = a1 + 6;
    if (v11)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeNode>>(v11);
    }

    v12 = (96 * v8);
    gdc::DebugTreeNode::DebugTreeNode(v12, a2, a3);
    v6 = v12 + 4;
    v13 = a1[6];
    v14 = a1[7];
    v15 = v12 + v13 - v14;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeNode>,gdc::DebugTreeNode*>(v13, v14, v15);
    v16 = a1[6];
    a1[6] = v15;
    a1[7] = v12 + 4;
    v17 = a1[8];
    a1[8] = 0;
    v19[2] = v16;
    v19[3] = v17;
    v19[0] = v16;
    v19[1] = v16;
    std::__split_buffer<gdc::DebugTreeNode>::~__split_buffer(v19);
  }

  else
  {
    v6 = gdc::DebugTreeNode::DebugTreeNode(v4, a2, a3) + 4;
  }

  a1[7] = v6;
  return v6 - 4;
}

void *gdc::DebugTreeNode::addChildNode(void *result, __int128 *a2)
{
  v2 = result;
  v3 = *(a2 + 23);
  if ((v3 & 0x80u) != 0)
  {
    v3 = *(a2 + 1);
  }

  if (v3)
  {
    goto LABEL_9;
  }

  v4 = *(a2 + 47);
  if ((v4 & 0x80u) != 0)
  {
    v4 = *(a2 + 4);
  }

  if (v4 || *(a2 + 6) != *(a2 + 7) || *(a2 + 9) != *(a2 + 10))
  {
LABEL_9:
    v5 = result[7];
    v6 = result[8];
    if (v5 >= v6)
    {
      v10 = result[6];
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v10) >> 5);
      v12 = v11 + 1;
      if (v11 + 1 > 0x2AAAAAAAAAAAAAALL)
      {
        std::__throw_bad_array_new_length[abi:nn200100]();
      }

      v13 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v10) >> 5);
      if (2 * v13 > v12)
      {
        v12 = 2 * v13;
      }

      if (v13 >= 0x155555555555555)
      {
        v14 = 0x2AAAAAAAAAAAAAALL;
      }

      else
      {
        v14 = v12;
      }

      v23[4] = v2 + 6;
      if (v14)
      {
        std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeNode>>(v14);
      }

      v15 = 96 * v11;
      v16 = *a2;
      *(v15 + 16) = *(a2 + 2);
      *v15 = v16;
      *(a2 + 1) = 0;
      *(a2 + 2) = 0;
      *a2 = 0;
      v17 = *(a2 + 24);
      *(v15 + 40) = *(a2 + 5);
      *(v15 + 24) = v17;
      *(a2 + 4) = 0;
      *(a2 + 5) = 0;
      *(a2 + 3) = 0;
      *(v15 + 48) = 0;
      *(v15 + 56) = 0;
      *(v15 + 64) = 0;
      *(v15 + 48) = a2[3];
      *(v15 + 64) = *(a2 + 8);
      *(a2 + 6) = 0;
      *(a2 + 7) = 0;
      *(a2 + 8) = 0;
      *(v15 + 72) = 0;
      *(v15 + 80) = 0;
      *(v15 + 88) = 0;
      *(v15 + 72) = *(a2 + 72);
      *(v15 + 88) = *(a2 + 11);
      *(a2 + 9) = 0;
      *(a2 + 10) = 0;
      *(a2 + 11) = 0;
      v9 = 96 * v11 + 96;
      v18 = v2[6];
      v19 = v2[7];
      v20 = v15 + v18 - v19;
      std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeNode>,gdc::DebugTreeNode*>(v18, v19, v20);
      v21 = v2[6];
      v2[6] = v20;
      v2[7] = v9;
      v22 = v2[8];
      v2[8] = 0;
      v23[2] = v21;
      v23[3] = v22;
      v23[0] = v21;
      v23[1] = v21;
      result = std::__split_buffer<gdc::DebugTreeNode>::~__split_buffer(v23);
    }

    else
    {
      v7 = *a2;
      *(v5 + 16) = *(a2 + 2);
      *v5 = v7;
      *(a2 + 1) = 0;
      *(a2 + 2) = 0;
      *a2 = 0;
      v8 = *(a2 + 24);
      *(v5 + 40) = *(a2 + 5);
      *(v5 + 24) = v8;
      *(a2 + 4) = 0;
      *(a2 + 5) = 0;
      *(a2 + 3) = 0;
      *(v5 + 48) = 0;
      *(v5 + 56) = 0;
      *(v5 + 64) = 0;
      *(v5 + 48) = a2[3];
      *(v5 + 64) = *(a2 + 8);
      *(a2 + 6) = 0;
      *(a2 + 7) = 0;
      *(a2 + 8) = 0;
      *(v5 + 72) = 0;
      *(v5 + 80) = 0;
      *(v5 + 88) = 0;
      *(v5 + 72) = *(a2 + 72);
      *(v5 + 88) = *(a2 + 11);
      *(a2 + 9) = 0;
      *(a2 + 10) = 0;
      *(a2 + 11) = 0;
      v9 = v5 + 96;
    }

    v2[7] = v9;
  }

  return result;
}

uint64_t gdc::DebugTreeNode::identifier(gdc::DebugTreeNode *this)
{
  v1 = *(this + 47);
  if (v1 < 0)
  {
    v1 = *(this + 4);
  }

  v2 = v1 == 0;
  v3 = 24;
  if (v2)
  {
    v3 = 0;
  }

  return this + v3;
}

void gdc::DebugTreeNode::toString(gdc::DebugTreeNode *this)
{
  v2[43] = *MEMORY[0x1E69E9840];
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn200100](v2);
  v1 = v2;
  v2[38] = 0;
  operator new();
}

uint64_t std::__function::__value_func<void ()(gdc::DebugTreeNode const&,unsigned long)>::~__value_func[abi:nn200100](uint64_t a1)
{
  v2 = *(a1 + 24);
  if (v2 == a1)
  {
    (*(*v2 + 32))(v2);
  }

  else if (v2)
  {
    (*(*v2 + 40))(v2);
  }

  return a1;
}

uint64_t std::function<void ()(gdc::DebugTreeNode const&,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = a3;
  if (a1)
  {
    return (*(*a1 + 48))(a1, a2, &v5);
  }

  v4 = std::__throw_bad_function_call[abi:nn200100]();
  return std::__function::__func<gdc::DebugTreeNode::toString(void)::$_0,std::allocator<gdc::DebugTreeNode::toString(void)::$_0>,void ()(gdc::DebugTreeNode const&,unsigned long)>::operator()(v4);
}

void std::__function::__func<gdc::DebugTreeNode::toString(void)::$_0,std::allocator<gdc::DebugTreeNode::toString(void)::$_0>,void ()(gdc::DebugTreeNode const&,unsigned long)>::operator()(void *a1, uint64_t a2, size_t *a3)
{
  v5 = *a3;
  v6 = a1[3];
  std::string::basic_string[abi:nn200100](&__p, *a3);
  if (v51 >= 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p;
  }

  if (v51 >= 0)
  {
    v8 = v51;
  }

  else
  {
    v8 = v50;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v6 + 16), p_p, v8);
  if (*(a2 + 23) < 0)
  {
    v9 = *(a2 + 8);
    if (v9)
    {
      std::string::__init_copy_ctor_external(&v48, *a2, v9);
      goto LABEL_13;
    }
  }

  else if (*(a2 + 23))
  {
    v48 = *a2;
    goto LABEL_13;
  }

  std::string::basic_string[abi:nn200100]<0>(&v48, "<Unknown>");
LABEL_13:
  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v10 = &v48;
  }

  else
  {
    v10 = v48.__r_.__value_.__r.__words[0];
  }

  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
  }

  else
  {
    size = v48.__r_.__value_.__l.__size_;
  }

  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v6 + 16), v10, size);
  std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v6 + 16), ":\n", 2);
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
  }

  if (v51 < 0)
  {
    operator delete(__p);
  }

  v12 = *(a2 + 72);
  for (i = *(a2 + 80); v12 != i; v5 = v19)
  {
    v13 = a1[2];
    v14 = *v13;
    std::string::basic_string[abi:nn200100](&__p, v5 + 1);
    if (v51 >= 0)
    {
      v15 = &__p;
    }

    else
    {
      v15 = __p;
    }

    if (v51 >= 0)
    {
      v16 = v51;
    }

    else
    {
      v16 = v50;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v14 + 16), v15, v16);
    if (*(v12 + 23) < 0)
    {
      v18 = *(v12 + 1);
      if (!v18)
      {
LABEL_35:
        std::string::basic_string[abi:nn200100]<0>(&v48, "<Unknown>");
        goto LABEL_36;
      }

      std::string::__init_copy_ctor_external(&v48, *v12, v18);
    }

    else
    {
      if (!*(v12 + 23))
      {
        goto LABEL_35;
      }

      v17 = *v12;
      v48.__r_.__value_.__r.__words[2] = *(v12 + 2);
      *&v48.__r_.__value_.__l.__data_ = v17;
    }

LABEL_36:
    v19 = v5;
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v20 = &v48;
    }

    else
    {
      v20 = v48.__r_.__value_.__r.__words[0];
    }

    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      v21 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    }

    else
    {
      v21 = v48.__r_.__value_.__l.__size_;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v14 + 16), v20, v21);
    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v14 + 16), ": ", 2);
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v48.__r_.__value_.__l.__data_);
    }

    if (v51 < 0)
    {
      operator delete(__p);
    }

    std::string::basic_string[abi:nn200100]<0>(&__p, "");
    v22 = *(v12 + 4);
    v23 = *(v12 + 5);
    while (v22 != v23)
    {
      v24 = *(v22 + 56);
      if (v24 <= 1)
      {
        if (v24)
        {
          if (v24 == 1)
          {
            v28 = *v13;
            if (v51 >= 0)
            {
              v29 = &__p;
            }

            else
            {
              v29 = __p;
            }

            if (v51 >= 0)
            {
              v30 = v51;
            }

            else
            {
              v30 = v50;
            }

            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v28 + 16), v29, v30);
            MEMORY[0x1B8C61CF0](v28 + 16, *(v22 + 8));
          }
        }

        else
        {
          v39 = *v13;
          if (v51 >= 0)
          {
            v40 = &__p;
          }

          else
          {
            v40 = __p;
          }

          if (v51 >= 0)
          {
            v41 = v51;
          }

          else
          {
            v41 = v50;
          }

          std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v39 + 16), v40, v41);
          MEMORY[0x1B8C61CE0](v39 + 16, *v22);
        }
      }

      else
      {
        switch(v24)
        {
          case 2:
            v31 = *v13;
            if (v51 >= 0)
            {
              v32 = &__p;
            }

            else
            {
              v32 = __p;
            }

            if (v51 >= 0)
            {
              v33 = v51;
            }

            else
            {
              v33 = v50;
            }

            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v31 + 16), v32, v33);
            MEMORY[0x1B8C61C60](v31 + 16, *(v22 + 16));
            break;
          case 3:
            v34 = *v13;
            if (v51 >= 0)
            {
              v35 = &__p;
            }

            else
            {
              v35 = __p;
            }

            if (v51 >= 0)
            {
              v36 = v51;
            }

            else
            {
              v36 = v50;
            }

            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v34 + 16), v35, v36);
            if (*(v22 + 24))
            {
              v37 = "True";
            }

            else
            {
              v37 = "False";
            }

            if (*(v22 + 24))
            {
              v38 = 4;
            }

            else
            {
              v38 = 5;
            }

            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v34 + 16), v37, v38);
            break;
          case 4:
            v25 = *v13;
            v26 = v51 >= 0 ? &__p : __p;
            v27 = v51 >= 0 ? v51 : v50;
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v25 + 16), v26, v27);
            if (*(v22 + 55) < 0)
            {
              std::string::__init_copy_ctor_external(&v48, *(v22 + 32), *(v22 + 40));
            }

            else
            {
              v48 = *(v22 + 32);
            }

            v42 = (v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? &v48 : v48.__r_.__value_.__r.__words[0];
            v43 = (v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0 ? HIBYTE(v48.__r_.__value_.__r.__words[2]) : v48.__r_.__value_.__l.__size_;
            std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((v25 + 16), v42, v43);
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v48.__r_.__value_.__l.__data_);
            }

            break;
        }
      }

      if (v51 < 0)
      {
        v50 = 2;
        v44 = __p;
      }

      else
      {
        v51 = 2;
        v44 = &__p;
      }

      strcpy(v44, ", ");
      v22 += 64;
    }

    std::__put_character_sequence[abi:nn200100]<char,std::char_traits<char>>((*v13 + 16), "\n", 1);
    if (v51 < 0)
    {
      operator delete(__p);
    }

    v12 += 5;
  }

  v46 = *(a2 + 48);
  v45 = *(a2 + 56);
  while (v46 != v45)
  {
    std::function<void ()(gdc::DebugTreeNode const&,unsigned long)>::operator()(*(a1[1] + 24), v46, v5 + 1);
    v46 += 96;
  }
}

_BYTE *std::string::basic_string[abi:nn200100](_BYTE *__b, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8)
  {
    std::__throw_bad_array_new_length[abi:nn200100]();
  }

  if (__len >= 0x17)
  {
    operator new();
  }

  __b[23] = __len;
  if (__len)
  {
    memset(__b, 9, __len);
  }

  __b[__len] = 0;
  return __b;
}

__n128 std::__function::__func<gdc::DebugTreeNode::toString(void)::$_0,std::allocator<gdc::DebugTreeNode::toString(void)::$_0>,void ()(gdc::DebugTreeNode const&,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *a2 = &unk_1F2A61148;
  result = *(a1 + 8);
  *(a2 + 24) = *(a1 + 24);
  *(a2 + 8) = result;
  return result;
}

uint64_t gdc::DebugTreeNode::findPropertyWithName(uint64_t a1, uint64_t a2, const void **a3)
{
  if (a1 == a2)
  {
    return 0;
  }

  v4 = a1;
  v5 = *(a3 + 23);
  if (v5 >= 0)
  {
    v6 = *(a3 + 23);
  }

  else
  {
    v6 = a3[1];
  }

  if (v5 >= 0)
  {
    v7 = a3;
  }

  else
  {
    v7 = *a3;
  }

  while (1)
  {
    v8 = *(v4 + 23);
    v9 = v8;
    if ((v8 & 0x80u) != 0)
    {
      v8 = *(v4 + 8);
    }

    if (v8 == v6)
    {
      v10 = v9 >= 0 ? v4 : *v4;
      if (!memcmp(v10, v7, v6))
      {
        break;
      }
    }

    v4 += 80;
    if (v4 == a2)
    {
      return 0;
    }
  }

  return v4;
}

uint64_t gdc::DebugTreeNode::findChildWithName(uint64_t a1, const void **a2)
{
  v2 = *(a1 + 48);
  v3 = *(a1 + 56);
  if (v2 == v3)
  {
    return 0;
  }

  v5 = *(a2 + 23);
  if (v5 >= 0)
  {
    v6 = *(a2 + 23);
  }

  else
  {
    v6 = a2[1];
  }

  if (v5 >= 0)
  {
    v7 = a2;
  }

  else
  {
    v7 = *a2;
  }

  while (1)
  {
    v8 = *(v2 + 23);
    v9 = v8;
    if ((v8 & 0x80u) != 0)
    {
      v8 = *(v2 + 8);
    }

    if (v8 == v6)
    {
      v10 = v9 >= 0 ? v2 : *v2;
      if (!memcmp(v10, v7, v6))
      {
        break;
      }
    }

    ChildWithName = gdc::DebugTreeNode::findChildWithName(v2, a2);
    if (ChildWithName)
    {
      return ChildWithName;
    }

    v2 += 96;
    if (v2 == v3)
    {
      return 0;
    }
  }

  return v2;
}

uint64_t gdc::DebugTreeNode::createProperty(uint64_t *a1, __int128 *a2)
{
  v4 = a1[10];
  v3 = a1[11];
  if (v4 >= v3)
  {
    v6 = a1[9];
    v7 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v6) >> 4);
    if (v7 + 1 > 0x333333333333333)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - v6) >> 4);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
    {
      v9 = v7 + 1;
    }

    if (v8 >= 0x199999999999999)
    {
      v10 = 0x333333333333333;
    }

    else
    {
      v10 = v9;
    }

    v20[4] = a1 + 9;
    if (v10)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>>(v10);
    }

    v12 = 80 * v7;
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *a2, *(a2 + 1));
    }

    else
    {
      v13 = *a2;
      *(v12 + 16) = *(a2 + 2);
      *v12 = v13;
    }

    *(v12 + 24) = 0;
    *(v12 + 32) = 0u;
    *(v12 + 48) = 0u;
    *(v12 + 64) = 0u;
    v11 = v12 + 80;
    v14 = a1[9];
    v15 = a1[10];
    v16 = v12 + v14 - v15;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>,gdc::DebugTreeProperty*>(v14, v15, v16);
    v17 = a1[9];
    a1[9] = v16;
    a1[10] = v12 + 80;
    v18 = a1[11];
    a1[11] = 0;
    v20[2] = v17;
    v20[3] = v18;
    v20[0] = v17;
    v20[1] = v17;
    std::__split_buffer<gdc::DebugTreeProperty>::~__split_buffer(v20);
  }

  else
  {
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(a1[10], *a2, *(a2 + 1));
    }

    else
    {
      v5 = *a2;
      *(v4 + 16) = *(a2 + 2);
      *v4 = v5;
    }

    *(v4 + 24) = 0;
    *(v4 + 32) = 0u;
    *(v4 + 48) = 0u;
    *(v4 + 64) = 0u;
    v11 = v4 + 80;
  }

  a1[10] = v11;
  return v11 - 80;
}

void std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>,gdc::DebugTreeProperty*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v4 = a1;
    v5 = a1;
    do
    {
      v6 = *v5;
      *(a3 + 16) = *(v5 + 16);
      *a3 = v6;
      *(v5 + 8) = 0;
      *(v5 + 16) = 0;
      *v5 = 0;
      *(a3 + 24) = *(v5 + 24);
      *(a3 + 40) = 0;
      *(a3 + 48) = 0;
      *(a3 + 32) = 0;
      *(a3 + 32) = *(v5 + 32);
      *(a3 + 48) = *(v5 + 48);
      *(v5 + 32) = 0;
      *(v5 + 40) = 0;
      *(v5 + 48) = 0;
      *(a3 + 56) = 0;
      *(a3 + 64) = 0;
      *(a3 + 72) = 0;
      *(a3 + 56) = *(v5 + 56);
      *(a3 + 72) = *(v5 + 72);
      *(v5 + 56) = 0;
      *(v5 + 64) = 0;
      *(v5 + 72) = 0;
      v5 += 80;
      a3 += 80;
    }

    while (v5 != a2);
    do
    {
      std::allocator_traits<std::allocator<gdc::DebugTreeProperty>>::destroy[abi:nn200100]<gdc::DebugTreeProperty,void,0>(v4);
      v4 += 80;
    }

    while (v4 != a2);
  }
}

uint64_t std::__split_buffer<gdc::DebugTreeProperty>::~__split_buffer(uint64_t a1)
{
  v3 = *(a1 + 8);
  for (i = *(a1 + 16); i != v3; i = *(a1 + 16))
  {
    *(a1 + 16) = i - 80;
    std::allocator_traits<std::allocator<gdc::DebugTreeProperty>>::destroy[abi:nn200100]<gdc::DebugTreeProperty,void,0>(i - 80);
  }

  if (*a1)
  {
    operator delete(*a1);
  }

  return a1;
}

void std::allocator_traits<std::allocator<gdc::DebugTreeProperty>>::destroy[abi:nn200100]<gdc::DebugTreeProperty,void,0>(uint64_t a1)
{
  v3 = (a1 + 56);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn200100](&v3);
  v3 = (a1 + 32);
  std::vector<gdc::DebugTreeValue>::__destroy_vector::operator()[abi:nn200100](&v3);
  if (*(a1 + 23) < 0)
  {
    v2 = *a1;

    operator delete(v2);
  }
}

uint64_t gdc::DebugTreeNode::createProperty(uint64_t *a1, __int128 *a2, int a3)
{
  v6 = a1[10];
  v5 = a1[11];
  if (v6 >= v5)
  {
    v8 = a1[9];
    v9 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v8) >> 4);
    if (v9 + 1 > 0x333333333333333)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - v8) >> 4);
    v11 = 2 * v10;
    if (2 * v10 <= v9 + 1)
    {
      v11 = v9 + 1;
    }

    if (v10 >= 0x199999999999999)
    {
      v12 = 0x333333333333333;
    }

    else
    {
      v12 = v11;
    }

    v22[4] = a1 + 9;
    if (v12)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>>(v12);
    }

    v14 = 80 * v9;
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v14, *a2, *(a2 + 1));
    }

    else
    {
      v15 = *a2;
      *(v14 + 16) = *(a2 + 2);
      *v14 = v15;
    }

    *(v14 + 24) = a3;
    *(v14 + 32) = 0u;
    *(v14 + 48) = 0u;
    *(v14 + 64) = 0u;
    v13 = v14 + 80;
    v16 = a1[9];
    v17 = a1[10];
    v18 = v14 + v16 - v17;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>,gdc::DebugTreeProperty*>(v16, v17, v18);
    v19 = a1[9];
    a1[9] = v18;
    a1[10] = v14 + 80;
    v20 = a1[11];
    a1[11] = 0;
    v22[2] = v19;
    v22[3] = v20;
    v22[0] = v19;
    v22[1] = v19;
    std::__split_buffer<gdc::DebugTreeProperty>::~__split_buffer(v22);
  }

  else
  {
    if (*(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(a1[10], *a2, *(a2 + 1));
    }

    else
    {
      v7 = *a2;
      *(v6 + 16) = *(a2 + 2);
      *v6 = v7;
    }

    *(v6 + 24) = a3;
    *(v6 + 32) = 0u;
    *(v6 + 48) = 0u;
    *(v6 + 64) = 0u;
    v13 = v6 + 80;
  }

  a1[10] = v13;
  return v13 - 80;
}

void *gdc::DebugTreeNode::addProperty(void *result, __int128 *a2)
{
  v2 = result;
  v3 = result[10];
  v4 = result[11];
  if (v3 >= v4)
  {
    v7 = result[9];
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - v7) >> 4);
    v9 = v8 + 1;
    if (v8 + 1 > 0x333333333333333)
    {
      std::__throw_bad_array_new_length[abi:nn200100]();
    }

    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v7) >> 4);
    if (2 * v10 > v9)
    {
      v9 = 2 * v10;
    }

    if (v10 >= 0x199999999999999)
    {
      v11 = 0x333333333333333;
    }

    else
    {
      v11 = v9;
    }

    v19[4] = v2 + 9;
    if (v11)
    {
      std::__allocate_at_least[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>>(v11);
    }

    v12 = 80 * v8;
    v13 = *a2;
    *(v12 + 16) = *(a2 + 2);
    *v12 = v13;
    *(a2 + 1) = 0;
    *(a2 + 2) = 0;
    *a2 = 0;
    *(v12 + 24) = *(a2 + 6);
    *(v12 + 40) = 0;
    *(v12 + 48) = 0;
    *(v12 + 32) = 0;
    *(v12 + 32) = a2[2];
    *(v12 + 48) = *(a2 + 6);
    *(a2 + 4) = 0;
    *(a2 + 5) = 0;
    *(a2 + 6) = 0;
    *(v12 + 56) = 0;
    *(v12 + 64) = 0;
    *(v12 + 72) = 0;
    *(v12 + 56) = *(a2 + 56);
    *(v12 + 72) = *(a2 + 9);
    *(a2 + 7) = 0;
    *(a2 + 8) = 0;
    *(a2 + 9) = 0;
    v6 = 80 * v8 + 80;
    v14 = v2[9];
    v15 = v2[10];
    v16 = v12 + v14 - v15;
    std::__uninitialized_allocator_relocate[abi:nn200100]<std::allocator<gdc::DebugTreeProperty>,gdc::DebugTreeProperty*>(v14, v15, v16);
    v17 = v2[9];
    v2[9] = v16;
    v2[10] = v6;
    v18 = v2[11];
    v2[11] = 0;
    v19[2] = v17;
    v19[3] = v18;
    v19[0] = v17;
    v19[1] = v17;
    result = std::__split_buffer<gdc::DebugTreeProperty>::~__split_buffer(v19);
  }

  else
  {
    v5 = *a2;
    *(v3 + 16) = *(a2 + 2);
    *v3 = v5;
    *(a2 + 1) = 0;
    *(a2 + 2) = 0;
    *a2 = 0;
    *(v3 + 24) = *(a2 + 6);
    *(v3 + 40) = 0;
    *(v3 + 48) = 0;
    *(v3 + 32) = 0;
    *(v3 + 32) = a2[2];
    *(v3 + 48) = *(a2 + 6);
    *(a2 + 4) = 0;
    *(a2 + 5) = 0;
    *(a2 + 6) = 0;
    *(v3 + 56) = 0;
    *(v3 + 64) = 0;
    *(v3 + 72) = 0;
    *(v3 + 56) = *(a2 + 56);
    *(v3 + 72) = *(a2 + 9);
    *(a2 + 7) = 0;
    *(a2 + 8) = 0;
    *(a2 + 9) = 0;
    v6 = v3 + 80;
  }

  v2[10] = v6;
  return result;
}

void gdc::DebugTreeNode::addProperty(uint64_t *a1, __int128 *a2, uint64_t a3)
{
  Property = gdc::DebugTreeNode::createProperty(a1, a2);
  v5[0] = *a3;
  *(v5 + 9) = *(a3 + 9);
  if (*(a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(a3 + 32), *(a3 + 40));
  }

  else
  {
    __p = *(a3 + 32);
  }

  v7 = *(a3 + 56);
  gdc::DebugTreeProperty::addValue(Property, v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

{
  Property = gdc::DebugTreeNode::createProperty(a1, a2, 1);
  v5[0] = *a3;
  *(v5 + 9) = *(a3 + 9);
  if (*(a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(a3 + 32), *(a3 + 40));
  }

  else
  {
    __p = *(a3 + 32);
  }

  v7 = *(a3 + 56);
  gdc::DebugTreeProperty::addValue(Property, v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void gdc::DebugTreeNode::addProperty(uint64_t *a1, __int128 *a2, uint64_t *a3)
{
  Property = gdc::DebugTreeNode::createProperty(a1, a2);
  v5 = *a3;
  v6 = a3[1];
  if (v5 != v6)
  {
    v7 = Property;
    v8 = v5 + 2;
    do
    {
      v9 = *(v8 - 2);
      *(v16 + 9) = *(v8 - 23);
      v16[0] = v9;
      if (*(v8 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v17, *v8, *(v8 + 1));
      }

      else
      {
        v10 = *v8;
        v17.__r_.__value_.__r.__words[2] = *(v8 + 2);
        *&v17.__r_.__value_.__l.__data_ = v10;
      }

      v11 = v8 - 2;
      v12 = *(v8 + 6);
      v18 = v12;
      v13[0] = v16[0];
      *(v13 + 9) = *(v16 + 9);
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
        v12 = v18;
      }

      else
      {
        __p = v17;
      }

      v15 = v12;
      gdc::DebugTreeProperty::addValue(v7, v13);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v17.__r_.__value_.__l.__data_);
      }

      v8 += 4;
    }

    while (v11 + 4 != v6);
  }
}

{
  Property = gdc::DebugTreeNode::createProperty(a1, a2, 2);
  v5 = *a3;
  v6 = a3[1];
  if (v5 != v6)
  {
    v7 = Property;
    v8 = v5 + 2;
    do
    {
      v9 = *(v8 - 2);
      *(v16 + 9) = *(v8 - 23);
      v16[0] = v9;
      if (*(v8 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v17, *v8, *(v8 + 1));
      }

      else
      {
        v10 = *v8;
        v17.__r_.__value_.__r.__words[2] = *(v8 + 2);
        *&v17.__r_.__value_.__l.__data_ = v10;
      }

      v11 = v8 - 2;
      v12 = *(v8 + 6);
      v18 = v12;
      v13[0] = v16[0];
      *(v13 + 9) = *(v16 + 9);
      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
        v12 = v18;
      }

      else
      {
        __p = v17;
      }

      v15 = v12;
      gdc::DebugTreeProperty::addValue(v7, v13);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v17.__r_.__value_.__l.__data_);
      }

      v8 += 4;
    }

    while (v11 + 4 != v6);
  }
}

void gdc::DebugTreeNode::addProperty(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4)
{
  Property = gdc::DebugTreeNode::createProperty(a1, a2);
  v7 = *a3;
  v8 = a3[1];
  if (v7 != v8)
  {
    v9 = v7 + 2;
    do
    {
      v10 = *(v9 - 2);
      *(v18 + 9) = *(v9 - 23);
      v18[0] = v10;
      if (*(v9 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v19, *v9, *(v9 + 1));
      }

      else
      {
        v11 = *v9;
        v19.__r_.__value_.__r.__words[2] = *(v9 + 2);
        *&v19.__r_.__value_.__l.__data_ = v11;
      }

      v12 = v9 - 2;
      v13 = *(v9 + 6);
      v20 = v13;
      v15[0] = v18[0];
      *(v15 + 9) = *(v18 + 9);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
        v13 = v20;
      }

      else
      {
        __p = v19;
      }

      v17 = v13;
      gdc::DebugTreeProperty::addValue(Property, v15);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }

      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v19.__r_.__value_.__l.__data_);
      }

      v9 += 4;
    }

    while (v12 + 4 != v8);
  }

  if (*(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v14, *a4, *(a4 + 8));
  }

  else
  {
    v14 = *a4;
  }

  gdc::DebugTreeProperty::addTag(Property, &v14);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

double gdc::DataKeyRequester::createDebugNode@<D0>(_OWORD *a1@<X8>)
{
  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  v2 = MEMORY[0x1EEDB7A68](theString, theIndex);
  result.length = v3;
  result.location = v2;
  return result;
}

CGRect CGContextGetPathBoundingBox(CGContextRef c)
{
  MEMORY[0x1EEDB95B0](c);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  MEMORY[0x1EEDBAC38](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  MEMORY[0x1EEDBAC40](path);
  result.y = v2;
  result.x = v1;
  return result;
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  MEMORY[0x1EEDBAD98](t, rect.origin, *&rect.origin.y, rect.size, *&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  MEMORY[0x1EEDBAE38](rect.origin, *&rect.origin.y, rect.size, *&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  MEMORY[0x1EEDBAE78](rect.origin, *&rect.origin.y, rect.size, *&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CTFontGetOpticalBoundsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count, CFOptionFlags options)
{
  MEMORY[0x1EEDBF020](font, glyphs, boundingRects, count, options);
  result.size.height = v8;
  result.size.width = v7;
  result.origin.y = v6;
  result.origin.x = v5;
  return result;
}

CGSize CTFramesetterSuggestFrameSizeWithConstraints(CTFramesetterRef framesetter, CFRange stringRange, CFDictionaryRef frameAttributes, CGSize constraints, CFRange *fitRange)
{
  MEMORY[0x1EEDBF1F0](framesetter, stringRange.location, stringRange.length, frameAttributes, fitRange, constraints, *&constraints.height);
  result.height = v6;
  result.width = v5;
  return result;
}

CGRect CTLineGetBoundsWithOptions(CTLineRef line, CTLineBoundsOptions options)
{
  MEMORY[0x1EEDBF2E0](line, options);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGRect CTLineGetImageBounds(CTLineRef line, CGContextRef context)
{
  MEMORY[0x1EEDBF300](line, context);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CFRange CTLineGetStringRange(CTLineRef line)
{
  v1 = MEMORY[0x1EEDBF340](line);
  result.length = v2;
  result.location = v1;
  return result;
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1EEE63EA0]();
}

{
  return MEMORY[0x1EEE63EB0]();
}

{
  return MEMORY[0x1EEE63EB8]();
}

{
  return MEMORY[0x1EEE63EC8]();
}

{
  return MEMORY[0x1EEE63ED0]();
}

{
  return MEMORY[0x1EEE63ED8]();
}

{
  return MEMORY[0x1EEE63EE0]();
}

{
  return MEMORY[0x1EEE63EE8]();
}

{
  return MEMORY[0x1EEE63EF0]();
}

{
  return MEMORY[0x1EEE63EF8]();
}

{
  return MEMORY[0x1EEE63F00]();
}

{
  return MEMORY[0x1EEE63F08]();
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x1EEE64438](this, a2, a3, a4);
}

{
  return MEMORY[0x1EEE64450](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x1EEE64440]();
}

{
  return MEMORY[0x1EEE64448]();
}

{
  return MEMORY[0x1EEE64458]();
}

{
  return MEMORY[0x1EEE64460]();
}

{
  return MEMORY[0x1EEE64470]();
}

{
  return MEMORY[0x1EEE64478]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return MEMORY[0x1EEE644C8](retstr, __val);
}

{
  return MEMORY[0x1EEE644D8](retstr, __val);
}

void operator delete[]()
{
    ;
  }
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void operator new[]()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1EEE73570](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1EEE73578](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}