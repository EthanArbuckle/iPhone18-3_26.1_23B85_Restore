unint64_t lazy protocol witness table accessor for type CGFloat and conformance CGFloat()
{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type CGFloat and conformance CGFloat;
  if (!lazy protocol witness table cache variable for type CGFloat and conformance CGFloat)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type CGFloat and conformance CGFloat);
  }

  return result;
}

uint64_t protocol witness for Decodable.init(from:) in conformance CGFloat@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  v18 = a2;
  v16 = *(type metadata accessor for DecodingError.Context() - 8);
  v4 = *(v16 + 64);
  MEMORY[0x1EEE9AC00]();
  v6 = v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = *(type metadata accessor for DecodingError() - 8);
  v7 = *(v17 + 64);
  MEMORY[0x1EEE9AC00]();
  v9 = v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = a1[4];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  dispatch thunk of Decoder.singleValueContainer()();
  if (v2)
  {
    return __swift_destroy_boxed_opaque_existential_1(a1);
  }

  v15[1] = v6;
  v15[2] = v9;
  v11 = v18;
  __swift_project_boxed_opaque_existential_1(v19, v19[3]);
  dispatch thunk of SingleValueDecodingContainer.decode(_:)();
  v13 = v12;
  __swift_destroy_boxed_opaque_existential_1(v19);
  result = __swift_destroy_boxed_opaque_existential_1(a1);
  *v11 = v13;
  return result;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(*(a2 - 8) + 80) & 0x20000) != 0)
  {
    return (*result + ((*(*(a2 - 8) + 80) + 16) & ~*(*(a2 - 8) + 80)));
  }

  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_1(void *a1)
{
  v1 = *(a1[3] - 8);
  if ((*(v1 + 82) & 2) != 0)
  {
    return MEMORY[0x1EEE6C0A8](*a1);
  }

  else
  {
    return (*(v1 + 8))();
  }
}

uint64_t protocol witness for CVarArg._cVarArgEncoding.getter in conformance CGFloat()
{
  v1 = *v0;
  result = _sSa9repeating5countSayxGx_SitcfCSi_Tt1gq5(0, 1uLL);
  *(result + 32) = v1;
  return result;
}

uint64_t _sSa9repeating5countSayxGx_SitcfCSi_Tt1gq5(uint64_t result, unint64_t a2)
{
  if ((a2 & 0x8000000000000000) != 0)
  {
    __break(1u);
    return result;
  }

  if (!a2)
  {
    return MEMORY[0x1E69E7CC0];
  }

  v3 = result;
  result = static Array._allocateBufferUninitialized(minimumCapacity:)();
  *(result + 16) = a2;
  v4 = (result + 32);
  if (a2 < 4)
  {
    v5 = 0;
LABEL_9:
    v9 = a2 - v5;
    do
    {
      *v4++ = v3;
      --v9;
    }

    while (v9);
    return result;
  }

  v5 = a2 & 0x7FFFFFFFFFFFFFFCLL;
  v4 += a2 & 0x7FFFFFFFFFFFFFFCLL;
  v6 = vdupq_n_s64(v3);
  v7 = (result + 48);
  v8 = a2 & 0x7FFFFFFFFFFFFFFCLL;
  do
  {
    v7[-1] = v6;
    *v7 = v6;
    v7 += 2;
    v8 -= 4;
  }

  while (v8);
  if (v5 != a2)
  {
    goto LABEL_9;
  }

  return result;
}

double protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance CGFloat(double *a1, double *a2)
{
  result = *a1 - *a2;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance CGFloat(double *a1, double *a2)
{
  result = *a2 + *a1;
  *a1 = result;
  return result;
}

double protocol witness for Numeric.magnitude.getter in conformance CGFloat@<D0>(double *a1@<X8>)
{
  result = fabs(*v1);
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  result = *a1 - *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  result = *a1 + *a2;
  *a3 = result;
  return result;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance CGFloat(void *a1)
{
  v2 = *v1;
  v3 = a1[4];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  dispatch thunk of Encoder.singleValueContainer()();
  __swift_mutable_project_boxed_opaque_existential_1(v5, v5[3]);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)();
  return __swift_destroy_boxed_opaque_existential_1(v5);
}

uint64_t __swift_mutable_project_boxed_opaque_existential_1(uint64_t a1, uint64_t a2)
{
  if ((*(*(a2 - 8) + 80) & 0x20000) != 0)
  {
    swift_makeBoxUnique();
    return v2;
  }

  return result;
}

uint64_t _CFObject.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3 = *(a3 + 8);
  v4 = dispatch thunk of Hashable.hashValue.getter();
  return MEMORY[0x1DA717090](v4);
}

double specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  v62 = *(AssociatedTypeWitness - 8);
  v63 = AssociatedTypeWitness;
  v7 = (*(v62 + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  (MEMORY[0x1EEE9AC00])();
  v61 = &v59 - v8;
  v9 = swift_getAssociatedTypeWitness();
  v59 = *(v9 - 8);
  v60 = v9;
  v10 = (*(v59 + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  v11 = (MEMORY[0x1EEE9AC00])();
  v13 = &v59 - v12;
  v14 = *(a2 - 8);
  v15 = *(v14 + 64);
  v16 = MEMORY[0x1EEE9AC00](v11);
  v18 = &v59 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1EEE9AC00](v16);
  v21 = &v59 - v20;
  MEMORY[0x1EEE9AC00](v19);
  v23 = &v59 - v22;
  v24 = dispatch thunk of static BinaryFloatingPoint.exponentBitCount.getter();
  v25 = dispatch thunk of static BinaryFloatingPoint.significandBitCount.getter();
  if (v24 == 11)
  {
    if (v25 == 52)
    {
      (*(v14 + 16))(v18, a1, a2);
      if (!swift_dynamicCast())
      {
        v28 = *(a3 + 16);
        v29 = dispatch thunk of FloatingPoint.sign.getter();
        dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter();
        v30 = v60;
        v31 = *(swift_getAssociatedConformanceWitness() + 8);
        v32 = dispatch thunk of BinaryInteger._lowWord.getter();
        (*(v59 + 8))(v13, v30);
        v33 = v61;
        dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter();
        (*(v14 + 8))(a1, a2);
        v34 = v63;
        v35 = *(swift_getAssociatedConformanceWitness() + 8);
        v36 = dispatch thunk of BinaryInteger._lowWord.getter();
        (*(v62 + 8))(v33, v34);
        *&result = (v29 << 63) | ((v32 & 0x7FF) << 52) | v36 & 0xFFFFFFFFFFFFFLL;
        return result;
      }

      goto LABEL_14;
    }

    goto LABEL_13;
  }

  if (v24 == 8)
  {
    if (v25 == 23)
    {
      (*(v14 + 16))(v21, a1, a2);
      if (swift_dynamicCast())
      {
        (*(v14 + 8))(a1, a2);
        return *&v64;
      }

      else
      {
        v37 = *(a3 + 16);
        v38 = dispatch thunk of FloatingPoint.sign.getter();
        dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter();
        v39 = v60;
        v40 = *(swift_getAssociatedConformanceWitness() + 8);
        v41 = dispatch thunk of BinaryInteger._lowWord.getter();
        (*(v59 + 8))(v13, v39);
        v42 = v61;
        dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter();
        (*(v14 + 8))(a1, a2);
        v43 = v63;
        v44 = *(swift_getAssociatedConformanceWitness() + 8);
        v45 = dispatch thunk of BinaryInteger._lowWord.getter();
        (*(v62 + 8))(v42, v43);
        return COERCE_FLOAT((v38 << 31) | (v41 << 23) | v45 & 0x7FFFFF);
      }
    }

    goto LABEL_13;
  }

  if (v24 != 5 || v25 != 10)
  {
LABEL_13:
    lazy protocol witness table accessor for type CGFloat and conformance CGFloat();
    static BinaryFloatingPoint._convert<A>(from:)();
LABEL_14:
    (*(v14 + 8))(a1, a2);
    return v64;
  }

  (*(v14 + 16))(v23, a1, a2);
  if (swift_dynamicCast())
  {
    (*(v14 + 8))(a1, a2);
    _H0 = LOWORD(v64);
  }

  else
  {
    v46 = *(a3 + 16);
    v47 = dispatch thunk of FloatingPoint.sign.getter();
    dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter();
    v48 = v60;
    v49 = *(swift_getAssociatedConformanceWitness() + 8);
    v50 = dispatch thunk of BinaryInteger._lowWord.getter();
    (*(v59 + 8))(v13, v48);
    v51 = v61;
    dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter();
    (*(v14 + 8))(a1, a2);
    v52 = v63;
    v53 = *(swift_getAssociatedConformanceWitness() + 8);
    v54 = dispatch thunk of BinaryInteger._lowWord.getter();
    (*(v62 + 8))(v51, v52);
    _H0 = (v47 << 15) | ((v50 & 0x1F) << 10) | v54 & 0x3FF;
  }

  __asm { FCVT            D0, H0 }

  return result;
}

uint64_t protocol witness for FloatingPoint.round(_:) in conformance CGFloat(uint64_t a1)
{
  v3 = type metadata accessor for FloatingPointRoundingRule();
  v4 = *(v3 - 8);
  v5 = *(v4 + 64);
  MEMORY[0x1EEE9AC00](v3);
  v7 = &v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(v4 + 16))(v7, a1, v3);
  result = (*(v4 + 88))(v7, v3);
  if (result == *MEMORY[0x1E69E7038])
  {
    *v1 = round(*v1);
    return result;
  }

  if (result == *MEMORY[0x1E69E7030])
  {
    *v1 = rint(*v1);
    return result;
  }

  if (result == *MEMORY[0x1E69E7040])
  {
    v9 = *v1;
LABEL_7:
    *v1 = ceil(v9);
    return result;
  }

  if (result == *MEMORY[0x1E69E7048])
  {
    v9 = *v1;
LABEL_10:
    *v1 = floor(v9);
    return result;
  }

  if (result == *MEMORY[0x1E69E7020])
  {
    *v1 = trunc(*v1);
  }

  else
  {
    if (result == *MEMORY[0x1E69E7028])
    {
      v9 = *v1;
      if ((*v1 & 0x8000000000000000) == 0)
      {
        goto LABEL_7;
      }

      goto LABEL_10;
    }

    Double._roundSlowPath(_:)();
    return (*(v4 + 8))(v7, v3);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type UInt and conformance UInt()
{
  result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type UInt and conformance UInt);
  }

  return result;
}

double protocol witness for static Numeric.* infix(_:_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  result = *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for static Numeric.*= infix(_:_:) in conformance CGFloat(double *a1, double *a2)
{
  result = *a2 * *a1;
  *a1 = result;
  return result;
}

double protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance CGFloat@<D0>(uint64_t *a1@<X0>, double *a2@<X8>)
{
  result = *a1;
  *a2 = result;
  return result;
}

double protocol witness for static FloatingPoint./= infix(_:_:) in conformance CGFloat(double *a1, double *a2)
{
  result = *a1 / *a2;
  *a1 = result;
  return result;
}

double CGFloat.init<A>(_:)(char *a1, uint64_t a2)
{
  v4 = *(a2 - 8);
  v5 = *(v4 + 64);
  MEMORY[0x1EEE9AC00](a1);
  v7 = v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(v4 + 16))(v7, a1, a2);
  if (dispatch thunk of BinaryInteger.bitWidth.getter() < 65)
  {
    v10 = dispatch thunk of static BinaryInteger.isSigned.getter();
    v11 = dispatch thunk of BinaryInteger._lowWord.getter();
    v12 = *(v4 + 8);
    v12(a1, a2);
    v12(v7, a2);
    if (v10)
    {
      return v11;
    }

    else
    {
      return v11;
    }
  }

  else
  {
    lazy protocol witness table accessor for type Double and conformance Double();
    lazy protocol witness table accessor for type UInt64 and conformance UInt64();
    static BinaryFloatingPoint<>._convert<A>(from:)();
    v8 = *(v4 + 8);
    v8(a1, a2);
    v8(v7, a2);
    return *&v13[1];
  }
}

uint64_t CGFloat.init<A>(exactly:)(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 - 8);
  v5 = *(v4 + 64);
  MEMORY[0x1EEE9AC00](a1);
  v7 = &v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(v4 + 16))(v7, a1, a2);
  v8 = Double.init<A>(exactly:)(v7, a2);
  LOBYTE(v7) = v9;
  (*(v4 + 8))(a1, a2);
  if (v7)
  {
    return 0;
  }

  else
  {
    return v8;
  }
}

uint64_t Double.init<A>(exactly:)(uint64_t a1, uint64_t a2)
{
  if (dispatch thunk of BinaryInteger.bitWidth.getter() > 64)
  {
    lazy protocol witness table accessor for type Double and conformance Double();
    lazy protocol witness table accessor for type UInt64 and conformance UInt64();
    v4 = static BinaryFloatingPoint<>._convert<A>(from:)();
    (*(*(a2 - 8) + 8))(a1, a2);
    if (v4)
    {
      v5 = v10;
      return *&v5;
    }

    return 0;
  }

  v6 = dispatch thunk of static BinaryInteger.isSigned.getter();
  v7 = dispatch thunk of BinaryInteger._lowWord.getter();
  result = (*(*(a2 - 8) + 8))(a1, a2);
  if ((v6 & 1) == 0)
  {
    v5 = v7;
    if (v7 < 1.84467441e19 && v7 == v7)
    {
      return *&v5;
    }

    return 0;
  }

  v5 = v7;
  if (v7 >= 9.22337204e18)
  {
    return 0;
  }

  if (v5 <= -9.22337204e18)
  {
    __break(1u);
    return result;
  }

  if (v7 != v5)
  {
    return 0;
  }

  return *&v5;
}

double protocol witness for static SignedNumeric.- prefix(_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  result = -*a1;
  *a2 = result;
  return result;
}

double protocol witness for SignedNumeric.negate() in conformance CGFloat()
{
  result = -*v0;
  *v0 = result;
  return result;
}

double static CGFloat.*= infix(_:_:)(double *a1, double a2)
{
  result = *a1 * a2;
  *a1 = result;
  return result;
}

double static CGFloat.+= infix(_:_:)(double *a1, double a2)
{
  result = *a1 + a2;
  *a1 = result;
  return result;
}

double static CGFloat.-= infix(_:_:)(double *a1, double a2)
{
  result = *a1 - a2;
  *a1 = result;
  return result;
}

CoreGraphics::CGFloat __swiftcall CGFloat.init(nan:signaling:)(Swift::UInt nan, Swift::Bool signaling)
{
  if (!(nan >> 50))
  {
    return ((0x8000000000000uLL >> signaling) | nan | 0x7FF0000000000000);
  }

  __break(1u);
  return result;
}

double CGFloat.ulp.getter(double a1)
{
  v2 = (*&a1 >> 52) & 0x7FFLL;
  if (v2)
  {
    result = NAN;
    if (v2 != 2047)
    {
      return COERCE_DOUBLE(*&a1 & 0x7FF0000000000000) * 2.22044605e-16;
    }
  }

  else
  {
    *&result = 1;
  }

  return result;
}

unint64_t CGFloat.exponent.getter(double a1)
{
  v1 = (*&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047)
  {
    return 0x7FFFFFFFFFFFFFFFLL;
  }

  v3 = *&a1 & 0xFFFFFFFFFFFFFLL;
  if (!(v1 | *&a1 & 0xFFFFFFFFFFFFFLL))
  {
    return 0x8000000000000000;
  }

  if (v1)
  {
    return v1 - 1023;
  }

  if (v3)
  {
    return -1011 - __clz(v3);
  }

  __break(1u);
  return result;
}

double CGFloat.significand.getter(double result)
{
  v1 = (*&result >> 52) & 0x7FFLL;
  v2 = *&result & 0xFFFFFFFFFFFFFLL;
  if ((*&result & 0xFFFFFFFFFFFFFLL) == 0 || v1 != 2047)
  {
    if (v1)
    {
      if (v1 != 2047)
      {
        *&result = v2 | 0x3FF0000000000000;
        return result;
      }
    }

    else if (v2)
    {
      *&result = (*&result << (__clz(v2) + 53)) & 0xFFFFFFFFFFFFFLL | 0x3FF0000000000000;
      return result;
    }

    *&result = v1 << 52;
  }

  return result;
}

uint64_t CGFloat.round(_:)(uint64_t a1)
{
  v3 = type metadata accessor for FloatingPointRoundingRule();
  v4 = *(v3 - 8);
  v5 = *(v4 + 64);
  MEMORY[0x1EEE9AC00](v3);
  v7 = &v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(v4 + 16))(v7, a1, v3);
  result = (*(v4 + 88))(v7, v3);
  if (result == *MEMORY[0x1E69E7038])
  {
    *v1 = round(*v1);
    return result;
  }

  if (result == *MEMORY[0x1E69E7030])
  {
    *v1 = rint(*v1);
    return result;
  }

  if (result == *MEMORY[0x1E69E7040])
  {
    v9 = *v1;
LABEL_7:
    *v1 = ceil(v9);
    return result;
  }

  if (result == *MEMORY[0x1E69E7048])
  {
    v9 = *v1;
LABEL_10:
    *v1 = floor(v9);
    return result;
  }

  if (result == *MEMORY[0x1E69E7020])
  {
    *v1 = trunc(*v1);
  }

  else
  {
    if (result == *MEMORY[0x1E69E7028])
    {
      v9 = *v1;
      if ((*v1 & 0x8000000000000000) == 0)
      {
        goto LABEL_7;
      }

      goto LABEL_10;
    }

    Double._roundSlowPath(_:)();
    return (*(v4 + 8))(v7, v3);
  }

  return result;
}

double CGFloat.nextUp.getter(double a1)
{
  result = a1 + 0.0;
  if (a1 != INFINITY)
  {
    *&result += (*&result >> 63) | 1;
  }

  return result;
}

double static CGFloat./= infix(_:_:)(double *a1, double a2)
{
  result = *a1 / a2;
  *a1 = result;
  return result;
}

double CGFloat.binade.getter(double a1)
{
  v1 = (*&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047)
  {
    return NAN;
  }

  if ((*&a1 & 0xFFFFFFFFFFFFFLL) != 0 && !v1)
  {
    return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 * 4.50359963e15) & 0xFFF0000000000000) * 2.22044605e-16;
  }

  *&result = *&a1 & 0xFFF0000000000000;
  return result;
}

uint64_t CGFloat.significandWidth.getter(double a1)
{
  v1 = *&a1 & 0xFFFFFFFFFFFFFLL;
  v2 = __clz(__rbit64(*&a1 & 0xFFFFFFFFFFFFFLL));
  v3 = (*&a1 >> 52) & 0x7FFLL;
  if (v3 && v3 != 2047)
  {
    v6 = 52 - v2;
    if (v1)
    {
      return v6;
    }

    else
    {
      return 0;
    }
  }

  else
  {
    v4 = 63 - __clz(v1) - v2;
    if (v3)
    {
      v4 = -1;
    }

    if (v1)
    {
      return v4;
    }

    else
    {
      return -1;
    }
  }
}

double protocol witness for BinaryFloatingPoint.init(_:) in conformance CGFloat@<D0>(double *a1@<X8>, float a2@<S0>)
{
  result = a2;
  *a1 = result;
  return result;
}

uint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance CGFloat@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *a4 = result;
  *(a4 + 8) = v6 & 1;
  return result;
}

uint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  swift_getAssociatedTypeWitness();
  v7 = *(swift_getAssociatedConformanceWitness() + 8);
  v82 = *(*(v7 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  v9 = *(*(AssociatedTypeWitness - 8) + 64);
  MEMORY[0x1EEE9AC00](AssociatedTypeWitness);
  v80 = &v78 - v10;
  v11 = swift_checkMetadataState();
  v12 = *(v11 - 8);
  v13 = *(v12 + 64);
  v14 = MEMORY[0x1EEE9AC00](v11);
  v81 = &v78 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1EEE9AC00](v14);
  v83 = &v78 - v17;
  MEMORY[0x1EEE9AC00](v16);
  v19 = &v78 - v18;
  if (dispatch thunk of FloatingPoint.isNaN.getter())
  {
    (*(*(a2 - 8) + 8))(a1, a2);
    return 0;
  }

  v84 = a3;
  v21 = a1;
  if (dispatch thunk of static BinaryFloatingPoint.exponentBitCount.getter() <= 11 && dispatch thunk of static BinaryFloatingPoint.significandBitCount.getter() < 53 || (dispatch thunk of FloatingPoint.isFinite.getter() & 1) == 0 || (dispatch thunk of FloatingPoint.isZero.getter() & 1) != 0)
  {
    return specialized BinaryFloatingPoint.init<A>(_:)(v21, a2, v84);
  }

  dispatch thunk of FloatingPoint.exponent.getter();
  v85 = -1022;
  v22 = v7;
  if ((dispatch thunk of static BinaryInteger.isSigned.getter() & 1) == 0)
  {
    v26 = dispatch thunk of static BinaryInteger.isSigned.getter();
    v27 = dispatch thunk of BinaryInteger.bitWidth.getter();
    v79 = v12;
    v21 = a1;
    if (v26)
    {
      if (v27 <= 64)
      {
        swift_getAssociatedConformanceWitness();
        dispatch thunk of _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:)();
        v35 = v83;
        dispatch thunk of ExpressibleByIntegerLiteral.init(integerLiteral:)();
        v24 = v7;
        v36 = *(*(v7 + 32) + 8);
        v37 = dispatch thunk of static Comparable.< infix(_:_:)();
        v25 = v79;
        (*(v79 + 8))(v35, v11);
        if ((v37 & 1) != 0 || dispatch thunk of BinaryInteger._lowWord.getter() < -1022)
        {
          goto LABEL_25;
        }
      }

      else
      {
        lazy protocol witness table accessor for type Int and conformance Int();
        v28 = v83;
        v24 = v7;
        dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
        v29 = *(*(v7 + 32) + 8);
        v30 = dispatch thunk of static Comparable.< infix(_:_:)();
        v25 = v79;
        (*(v79 + 8))(v28, v11);
        if (v30)
        {
          goto LABEL_25;
        }
      }
    }

    else
    {
      if (v27 >= 64)
      {
        v24 = v7;
        v25 = v79;
        goto LABEL_33;
      }

      v24 = v7;
      v34 = dispatch thunk of BinaryInteger._lowWord.getter();
      v25 = v79;
      if (v34 < -1022)
      {
        goto LABEL_25;
      }
    }

LABEL_33:
    v85 = 1023;
    v43 = dispatch thunk of static BinaryInteger.isSigned.getter();
    v44 = dispatch thunk of BinaryInteger.bitWidth.getter();
    if (v43)
    {
      if (v44 <= 64)
      {
        goto LABEL_35;
      }
    }

    else if (v44 <= 63)
    {
LABEL_35:
      v45 = dispatch thunk of BinaryInteger._lowWord.getter();
      (*(v25 + 8))(v19, v11);
      if (v45 > 1023)
      {
LABEL_73:
        (*(*(a2 - 8) + 8))(v21, a2);
        return 0;
      }

LABEL_39:
      if (dispatch thunk of BinaryFloatingPoint.significandWidth.getter() < 53)
      {
        return specialized BinaryFloatingPoint.init<A>(_:)(v21, a2, v84);
      }

      goto LABEL_73;
    }

    lazy protocol witness table accessor for type Int and conformance Int();
    v46 = v83;
    dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
    v47 = *(*(v24 + 32) + 8);
    v48 = dispatch thunk of static Comparable.< infix(_:_:)();
    v49 = *(v25 + 8);
    v49(v46, v11);
    v49(v19, v11);
    if (v48)
    {
      goto LABEL_73;
    }

    goto LABEL_39;
  }

  v23 = v12;
  if (dispatch thunk of BinaryInteger.bitWidth.getter() >= 64)
  {
    lazy protocol witness table accessor for type Int and conformance Int();
    v31 = v83;
    dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
    v32 = *(*(v22 + 32) + 8);
    v33 = dispatch thunk of static Comparable.< infix(_:_:)();
    (*(v12 + 8))(v31, v11);
    v24 = v22;
    v21 = a1;
    v25 = v23;
    if (v33)
    {
      goto LABEL_25;
    }

    goto LABEL_33;
  }

  v24 = v7;
  v21 = a1;
  v25 = v23;
  if (dispatch thunk of BinaryInteger._lowWord.getter() > -1023)
  {
    goto LABEL_33;
  }

LABEL_25:
  v85 = -1074;
  if (dispatch thunk of static BinaryInteger.isSigned.getter())
  {
    if (dispatch thunk of BinaryInteger.bitWidth.getter() < 64)
    {
      if (dispatch thunk of BinaryInteger._lowWord.getter() > -1075)
      {
        goto LABEL_47;
      }

LABEL_46:
      (*(*(a2 - 8) + 8))(v21, a2);
      (*(v25 + 8))(v19, v11);
      return 0;
    }

LABEL_31:
    lazy protocol witness table accessor for type Int and conformance Int();
    v40 = v83;
    dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
    v41 = *(*(v24 + 32) + 8);
    v42 = dispatch thunk of static Comparable.< infix(_:_:)();
    (*(v25 + 8))(v40, v11);
    if ((v42 & 1) == 0)
    {
      goto LABEL_47;
    }

    goto LABEL_46;
  }

  v38 = dispatch thunk of static BinaryInteger.isSigned.getter();
  v39 = dispatch thunk of BinaryInteger.bitWidth.getter();
  if (v38)
  {
    if (v39 > 64)
    {
      goto LABEL_31;
    }

    swift_getAssociatedConformanceWitness();
    dispatch thunk of _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:)();
    v50 = v83;
    dispatch thunk of ExpressibleByIntegerLiteral.init(integerLiteral:)();
    v51 = *(*(v24 + 32) + 8);
    v52 = dispatch thunk of static Comparable.< infix(_:_:)();
    v53 = v50;
    v54 = *(v25 + 8);
    v54(v53, v11);
    if (v52)
    {
      (*(*(a2 - 8) + 8))(v21, a2);
      v54(v19, v11);
      return 0;
    }
  }

  else if (v39 >= 64)
  {
    goto LABEL_47;
  }

  if (dispatch thunk of BinaryInteger._lowWord.getter() < -1074)
  {
    goto LABEL_46;
  }

LABEL_47:
  v55 = dispatch thunk of BinaryFloatingPoint.significandWidth.getter();
  v56 = v81;
  (*(v25 + 32))();
  if ((dispatch thunk of static BinaryInteger.isSigned.getter() & 1) != 0 && dispatch thunk of BinaryInteger.bitWidth.getter() >= 65)
  {
    v85 = 0x8000000000000000;
    if (dispatch thunk of static BinaryInteger.isSigned.getter())
    {
      if (dispatch thunk of BinaryInteger.bitWidth.getter() >= 64)
      {
        lazy protocol witness table accessor for type Int and conformance Int();
        v57 = v55;
        v58 = v83;
        dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
        v59 = *(*(v24 + 32) + 8);
        v60 = dispatch thunk of static Comparable.< infix(_:_:)();
        v61 = v58;
        v55 = v57;
        result = (*(v25 + 8))(v61, v11);
        if (v60)
        {
          goto LABEL_75;
        }

        goto LABEL_61;
      }

      goto LABEL_60;
    }

    v62 = dispatch thunk of static BinaryInteger.isSigned.getter();
    v63 = dispatch thunk of BinaryInteger.bitWidth.getter();
    if (v62)
    {
      v79 = v55;
      if (v63 > 64)
      {
        lazy protocol witness table accessor for type Int and conformance Int();
        v64 = v83;
        dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
        v65 = *(*(v24 + 32) + 8);
        v66 = dispatch thunk of static Comparable.< infix(_:_:)();
        result = (*(v25 + 8))(v64, v11);
        v55 = v79;
        if (v66)
        {
          goto LABEL_75;
        }

        goto LABEL_61;
      }

      swift_getAssociatedConformanceWitness();
      dispatch thunk of _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:)();
      v67 = v83;
      dispatch thunk of ExpressibleByIntegerLiteral.init(integerLiteral:)();
      v68 = *(*(v24 + 32) + 8);
      v69 = dispatch thunk of static Comparable.< infix(_:_:)();
      result = (*(v25 + 8))(v67, v11);
      v55 = v79;
      if (v69)
      {
LABEL_75:
        __break(1u);
        return result;
      }

      goto LABEL_60;
    }

    if (v63 < 64)
    {
LABEL_60:
      dispatch thunk of BinaryInteger._lowWord.getter();
    }
  }

LABEL_61:
  if (dispatch thunk of BinaryInteger.bitWidth.getter() <= 64)
  {
    goto LABEL_66;
  }

  while (1)
  {
    v85 = 0x7FFFFFFFFFFFFFFFLL;
    v70 = dispatch thunk of static BinaryInteger.isSigned.getter();
    v71 = dispatch thunk of BinaryInteger.bitWidth.getter();
    if ((v70 & 1) == 0)
    {
      break;
    }

    if (v71 <= 64)
    {
      goto LABEL_70;
    }

LABEL_64:
    lazy protocol witness table accessor for type Int and conformance Int();
    v72 = v55;
    v73 = v83;
    dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)();
    v74 = *(*(v24 + 32) + 8);
    v75 = dispatch thunk of static Comparable.< infix(_:_:)();
    v76 = v73;
    v55 = v72;
    (*(v25 + 8))(v76, v11);
    if (v75)
    {
      __break(1u);
LABEL_66:
      if (dispatch thunk of BinaryInteger.bitWidth.getter() == 64 && (dispatch thunk of static BinaryInteger.isSigned.getter() & 1) == 0)
      {
        continue;
      }
    }

    goto LABEL_71;
  }

  if (v71 >= 64)
  {
    goto LABEL_64;
  }

LABEL_70:
  dispatch thunk of BinaryInteger._lowWord.getter();
LABEL_71:
  v77 = dispatch thunk of BinaryInteger._lowWord.getter();
  result = (*(v25 + 8))(v56, v11);
  if (__OFADD__(v77, 1074))
  {
    __break(1u);
    goto LABEL_75;
  }

  if (v77 + 1074 < v55)
  {
    goto LABEL_73;
  }

  return specialized BinaryFloatingPoint.init<A>(_:)(v21, a2, v84);
}

double protocol witness for BinaryFloatingPoint.binade.getter in conformance CGFloat@<D0>(double *a1@<X8>)
{
  v2 = *v1;
  v3 = (*v1 >> 52) & 0x7FFLL;
  if (v3 == 2047)
  {
    v5 = NAN;
    goto LABEL_7;
  }

  if ((*&v2 & 0xFFFFFFFFFFFFFLL) != 0)
  {
    v4 = v3 == 0;
    *v1;
  }

  else
  {
    v4 = 0;
  }

  if (!v4)
  {
    *&v5 = *&v2 & 0xFFF0000000000000;
LABEL_7:
    result = v5;
    *a1 = v5;
    return result;
  }

  result = COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*v1 * 4.50359963e15) & 0xFFF0000000000000) * 2.22044605e-16;
  *a1 = result;
  return result;
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance CGFloat()
{
  v1 = *v0 & 0xFFFFFFFFFFFFFLL;
  v2 = __clz(__rbit64(v1));
  v3 = (*v0 >> 52) & 0x7FFLL;
  if (v3 && (v4 = ((*v0 >> 52) & 0x7FFLL) == 2047, v3 != 2047))
  {
    v8 = 52 - v2;
    *v0;
    if (v1)
    {
      return v8;
    }

    else
    {
      return 0;
    }
  }

  else
  {
    *v0;
    if (v1)
    {
      v5 = v3 == 0;
      *v0;
    }

    else
    {
      v5 = 0;
    }

    v6 = 63 - __clz(v1) - v2;
    if (v5)
    {
      return v6;
    }

    else
    {
      return -1;
    }
  }
}

double protocol witness for FloatingPoint.init(_:) in conformance CGFloat@<D0>(uint64_t a1@<X0>, double *a2@<X8>)
{
  result = a1;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance CGFloat@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v6 = *(a2 - 8);
  v7 = *(v6 + 64);
  MEMORY[0x1EEE9AC00](a1);
  v9 = &v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(v6 + 16))(v9, a1, a2);
  v10 = Double.init<A>(exactly:)(v9, a2);
  v12 = v11;
  result = (*(v6 + 8))(a1, a2);
  if (v12)
  {
    v14 = 0;
  }

  else
  {
    v14 = v10;
  }

  *a3 = v14;
  *(a3 + 8) = v12 & 1;
  return result;
}

double protocol witness for FloatingPoint.ulp.getter in conformance CGFloat@<D0>(double *a1@<X8>)
{
  v2 = (*v1 >> 52) & 0x7FFLL;
  if (v2)
  {
    v3 = ((*v1 >> 52) & 0x7FFLL) == 2047;
    if (v2 != 2047)
    {
      result = COERCE_DOUBLE(*v1 & 0x7FF0000000000000) * 2.22044605e-16;
      *a1 = result;
      return result;
    }

    v5 = NAN;
  }

  else
  {
    *&v5 = 1;
  }

  result = v5;
  *a1 = v5;
  return result;
}

void protocol witness for FloatingPoint.exponent.getter in conformance CGFloat(void *a1@<X8>)
{
  v2 = (*v1 >> 52) & 0x7FFLL;
  if (v2 == 2047)
  {
    *a1 = 0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    v3 = *v1 & 0xFFFFFFFFFFFFFLL;
    if (v2 | v3)
    {
      if (v2)
      {
        *a1 = v2 - 1023;
      }

      else if (v3)
      {
        *a1 = -1011 - __clz(v3);
      }

      else
      {
        __break(1u);
      }
    }

    else
    {
      *a1 = 0x8000000000000000;
    }
  }
}

void protocol witness for FloatingPoint.significand.getter in conformance CGFloat(void *a1@<X8>)
{
  v2 = *v1;
  v3 = (*v1 >> 52) & 0x7FF;
  v4 = *v1 & 0xFFFFFFFFFFFFFLL;
  if (v4)
  {
    v5 = ((*v1 >> 52) & 0x7FF) == 2047;
    if (v3 == 2047)
    {
      *a1 = v2;
      return;
    }
  }

  if (v3)
  {
    v5 = ((*v1 >> 52) & 0x7FF) == 2047;
    if (v3 != 2047)
    {
      *a1 = v4 | 0x3FF0000000000000;
      return;
    }
  }

  else if (v4)
  {
    *a1 = (v2 << (__clz(v4) + 53)) & 0xFFFFFFFFFFFFFLL | 0x3FF0000000000000;
    return;
  }

  *a1 = v3 << 52;
}

double protocol witness for static FloatingPoint./ infix(_:_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  result = *a1 / *a2;
  *a3 = result;
  return result;
}

double protocol witness for FloatingPoint.addingProduct(_:_:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  result = *v3 + *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for FloatingPoint.addProduct(_:_:) in conformance CGFloat(double *a1, double *a2)
{
  result = *v2 + *a1 * *a2;
  *v2 = result;
  return result;
}

double *protocol witness for static FloatingPoint.minimum(_:_:) in conformance CGFloat@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  v3 = *result;
  v4 = *a2;
  if (*result > *a2)
  {
    v5 = *a2;
    if ((*&v4 & 0xFFFFFFFFFFFFFLL) == 0)
    {
      v3 = *a2;
    }

    if ((~*&v4 & 0x7FF0000000000000) != 0)
    {
      v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximum(_:_:) in conformance CGFloat@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  v3 = *result;
  v4 = *a2;
  if (*a2 >= *result)
  {
    v5 = *a2;
    if ((*&v4 & 0xFFFFFFFFFFFFFLL) == 0)
    {
      v3 = *a2;
    }

    if ((~*&v4 & 0x7FF0000000000000) != 0)
    {
      v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance CGFloat@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  v3 = *result;
  v4 = *a2;
  if (fabs(*result) > fabs(*a2))
  {
    v5 = *a2;
    if ((*&v4 & 0xFFFFFFFFFFFFFLL) == 0)
    {
      v3 = *a2;
    }

    if ((~*&v4 & 0x7FF0000000000000) != 0)
    {
      v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance CGFloat@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  v3 = *result;
  v4 = *a2;
  if (fabs(*a2) >= fabs(*result))
  {
    v5 = *a2;
    if ((*&v4 & 0xFFFFFFFFFFFFFLL) == 0)
    {
      v3 = *a2;
    }

    if ((~*&v4 & 0x7FF0000000000000) != 0)
    {
      v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

uint64_t protocol witness for FloatingPoint.rounded(_:) in conformance CGFloat@<X0>(uint64_t a1@<X0>, double *a2@<X8>)
{
  v5 = type metadata accessor for FloatingPointRoundingRule();
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  MEMORY[0x1EEE9AC00](v5);
  v9 = &v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *v2;
  v15 = *v2;
  (*(v6 + 16))(v9, a1, v5);
  result = (*(v6 + 88))(v9, v5);
  if (result == *MEMORY[0x1E69E7038])
  {
    v12 = round(v10);
  }

  else if (result == *MEMORY[0x1E69E7030])
  {
    v12 = rint(v10);
  }

  else if (result == *MEMORY[0x1E69E7040])
  {
    v12 = ceil(v10);
  }

  else if (result == *MEMORY[0x1E69E7048])
  {
    v12 = floor(v10);
  }

  else if (result == *MEMORY[0x1E69E7020])
  {
    v12 = trunc(v10);
  }

  else if (result == *MEMORY[0x1E69E7028])
  {
    v12 = ceil(v10);
    v13 = floor(v10);
    if (v10 < 0.0)
    {
      v12 = v13;
    }
  }

  else
  {
    Double._roundSlowPath(_:)();
    result = (*(v6 + 8))(v9, v5);
    v12 = v15;
  }

  *a2 = v12;
  return result;
}

void protocol witness for FloatingPoint.nextUp.getter in conformance CGFloat(double *a1@<X8>)
{
  v2 = *v1 + 0.0;
  if (*v1 != INFINITY)
  {
    *&v2 += (*&v2 >> 63) | 1;
  }

  *a1 = v2;
}

double protocol witness for FloatingPoint.nextDown.getter in conformance CGFloat@<D0>(double *a1@<X8>)
{
  v2 = 0.0 - *v1;
  if (v2 != INFINITY)
  {
    *&v2 += (*&v2 >> 63) | 1;
  }

  result = -v2;
  *a1 = result;
  return result;
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(double a1, double a2)
{
  if (a2 < a1)
  {
    return 1;
  }

  v3 = (*&a2 >> 52) & 0x7FFLL;
  v4 = (*&a1 >> 52) & 0x7FFLL;
  v5 = *&a2 & 0xFFFFFFFFFFFFFLL;
  v6 = *&a1 & 0xFFFFFFFFFFFFFLL;
  v8 = a2 >= 0.0 || v5 >= v6;
  if (v6 < v5)
  {
    v8 = *&a2 >> 63;
  }

  if (v3 < v4)
  {
    v8 = a2 >= 0.0;
  }

  if (v4 < v3)
  {
    v8 = *&a2 >> 63;
  }

  if ((*&a2 ^ *&a1) >= 0)
  {
    return v8;
  }

  else
  {
    return *&a2 >> 63;
  }
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance CGFloat()
{
  *v0;
  if ((~*v0 & 0x7FF0000000000000) != 0)
  {
    v1 = 1;
  }

  else
  {
    v1 = (*v0 & 0xFFFFFFFFFFFFFLL) == 0;
    *v0;
  }

  return !v1 && (*v0 & 0x8000000000000) == 0;
}

double protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance CGFloat@<D0>(double *a1@<X0>, void *a2@<X8>)
{
  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t CGFloat.hash(into:)(double a1)
{
  if (a1 == 0.0)
  {
    a1 = 0.0;
  }

  return MEMORY[0x1DA7170A0](*&a1);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance CGFloat()
{
  v1 = *v0;
  if (*v0 == 0.0)
  {
    v1 = 0.0;
  }

  return MEMORY[0x1DA7170A0](*&v1);
}

Swift::UInt8 __swiftcall UInt8.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -1.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native >= 256.0)
  {
LABEL_7:
    __break(1u);
    return v1;
  }

  return a1.native;
}

Swift::Int8 __swiftcall Int8.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -129.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native >= 128.0)
  {
LABEL_7:
    __break(1u);
    return v1;
  }

  return a1.native;
}

Swift::UInt16 __swiftcall UInt16.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -1.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native >= 65536.0)
  {
LABEL_7:
    __break(1u);
    return v1;
  }

  return a1.native;
}

Swift::Int16 __swiftcall Int16.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -32769.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native >= 32768.0)
  {
LABEL_7:
    __break(1u);
    return v1;
  }

  return a1.native;
}

Swift::UInt32 __swiftcall UInt32.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -1.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native < 4294967300.0)
  {
    return a1.native;
  }

LABEL_7:
  __break(1u);
  return result;
}

Swift::Int32 __swiftcall Int32.init(_:)(CoreGraphics::CGFloat a1)
{
  if ((a1.native & 0x7FFFFFFFFFFFFFFFLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1.native <= -2147483650.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1.native < 2147483650.0)
  {
    return a1.native;
  }

LABEL_7:
  __break(1u);
  return result;
}

unint64_t UInt64.init(_:)(double a1)
{
  if ((*&a1 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1 <= -1.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1 < 1.84467441e19)
  {
    return a1;
  }

LABEL_7:
  __break(1u);
  return result;
}

uint64_t Int64.init(_:)(double a1)
{
  if ((*&a1 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    __break(1u);
    goto LABEL_6;
  }

  if (a1 <= -9.22337204e18)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  if (a1 < 9.22337204e18)
  {
    return a1;
  }

LABEL_7:
  __break(1u);
  return result;
}

double protocol witness for Strideable.distance(to:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  result = *a1 - *v2;
  *a2 = result;
  return result;
}

double protocol witness for Strideable.advanced(by:) in conformance CGFloat@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  result = *a1 + *v2;
  *a2 = result;
  return result;
}

double *protocol witness for static Strideable._step(after:from:by:) in conformance CGFloat(double *result, uint64_t a2, char a3, double *a4, double *a5, double *a6)
{
  v6 = a2;
  v7 = *a6;
  if (a3)
  {
    v8 = v7 + *a4;
LABEL_5:
    *result = v8;
    return v6;
  }

  v6 = a2 + 1;
  if (!__OFADD__(a2, 1))
  {
    v8 = *a5 + v6 * v7;
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

uint64_t CGFloat._cVarArgEncoding.getter(double a1)
{
  result = static Array._allocateBufferUninitialized(minimumCapacity:)();
  *(result + 16) = 1;
  *(result + 32) = a1;
  return result;
}

double CGFloat.init(from:)(void *a1)
{
  v4 = type metadata accessor for DecodingError();
  v17 = *(v4 - 8);
  v5 = *(v17 + 64);
  MEMORY[0x1EEE9AC00](v4);
  v6 = type metadata accessor for DecodingError.Context();
  v16 = *(v6 - 8);
  v7 = *(v16 + 64);
  MEMORY[0x1EEE9AC00](v6);
  v9 = &v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = a1[4];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  dispatch thunk of Decoder.singleValueContainer()();
  if (v1)
  {
    __swift_destroy_boxed_opaque_existential_1(a1);
  }

  else
  {
    v14 = v9;
    v15 = a1;
    __swift_project_boxed_opaque_existential_1(v18, v18[3]);
    dispatch thunk of SingleValueDecodingContainer.decode(_:)();
    v2 = v11;
    v12 = v15;
    __swift_destroy_boxed_opaque_existential_1(v18);
    __swift_destroy_boxed_opaque_existential_1(v12);
  }

  return v2;
}

uint64_t CGFloat.encode(to:)(void *a1)
{
  v1 = a1[4];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  dispatch thunk of Encoder.singleValueContainer()();
  __swift_mutable_project_boxed_opaque_existential_1(v3, v3[3]);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)();
  return __swift_destroy_boxed_opaque_existential_1(v3);
}

uint64_t specialized FloatingPoint.floatingPointClass.getter(double a1)
{
  v1 = (*&a1 >> 52) & 0x7FFLL;
  if (a1 < 0.0)
  {
    v2 = 5;
  }

  else
  {
    v2 = 6;
  }

  if (a1 < 0.0)
  {
    v3 = 4;
  }

  else
  {
    v3 = 7;
  }

  if ((*&a1 & 0xFFFFFFFFFFFFFLL) != 0)
  {
    v2 = v3;
  }

  if (a1 < 0.0)
  {
    v4 = 3;
  }

  else
  {
    v4 = 8;
  }

  if (a1 < 0.0)
  {
    v5 = 2;
  }

  else
  {
    v5 = 9;
  }

  if ((*&a1 & 0xFFFFFFFFFFFFFLL) != 0)
  {
    v6 = (*&a1 >> 51) & 1;
  }

  else
  {
    v6 = v5;
  }

  if (v1 != 2047)
  {
    v6 = v4;
  }

  if (v1)
  {
    return v6;
  }

  else
  {
    return v2;
  }
}

double specialized Double.init(sign:exponent:significand:)(char a1, uint64_t a2, double a3)
{
  result = -a3;
  if ((a1 & 1) == 0)
  {
    result = a3;
  }

  v5 = (*&a3 >> 52) & 0x7FFLL;
  if (v5 != 2047 && v5 | *&a3 & 0xFFFFFFFFFFFFFLL)
  {
    if (a2 >= -1022)
    {
      if (a2 >= 1024)
      {
        if (a2 >= 0xBFD)
        {
          a2 = 3069;
        }

        do
        {
          a2 -= 1023;
          result = result * 8.98846567e307;
        }

        while (a2 > 0x3FF);
      }
    }

    else
    {
      v6 = -3066;
      if (a2 > 0xFFFFFFFFFFFFF406)
      {
        v6 = a2;
      }

      v7 = v6 + 1022;
      result = result * 2.22507386e-308;
      v8 = v6 + 2044;
      v9 = __CFADD__(a2, 2044);
      if (a2 >= 0xFFFFFFFFFFFFF804)
      {
        a2 = v7;
      }

      else
      {
        a2 = v8;
      }

      if (!v9)
      {
        result = result * 2.22507386e-308;
      }
    }

    return result * COERCE_DOUBLE(((a2 << 52) + 0x3FF0000000000000) & 0x7FF0000000000000);
  }

  return result;
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameV2(uint64_t *a1, uint64_t *a2)
{
  result = *a1;
  if (!result)
  {
    v4 = *a2;
    result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Int and conformance Int()
{
  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Double and conformance Double()
{
  result = lazy protocol witness table cache variable for type Double and conformance Double;
  if (!lazy protocol witness table cache variable for type Double and conformance Double)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type Double and conformance Double);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type UInt64 and conformance UInt64()
{
  result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    result = swift_getWitnessTable();
    atomic_store(result, &lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }

  return result;
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode(_:)()
{
  return MEMORY[0x1EEE6B208]();
}

{
  return MEMORY[0x1EEE6B210]();
}