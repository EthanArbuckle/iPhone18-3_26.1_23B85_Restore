uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(a6 + 256))(a1, a2, a3 & 1);
}

{
  return (*(a6 + 304))(a1, a2, a3 & 1);
}

atomic_ullong **__swift_initWithCopy_strong(atomic_ullong **a1, atomic_ullong **a2)
{
  v3 = *a2;
  *a1 = *a2;
  v3;
  return a1;
}

uint64_t *__swift_assignWithCopy_strong(uint64_t *a1, atomic_ullong **a2)
{
  v3 = *a2;
  v4 = *a1;
  *a1 = *a2;
  v3;
  v4;
  return a1;
}

uint64_t *__swift_assignWithTake_strong(uint64_t *a1, uint64_t *a2)
{
  v3 = *a1;
  *a1 = *a2;
  v3;
  return a1;
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(a3 + 56))() & 1;
}

{
  return (*(a3 + 64))();
}

{
  return (*(a3 + 72))();
}

{
  return (*(a3 + 80))();
}

{
  return (*(a3 + 88))();
}

{
  return (*(a3 + 96))();
}

{
  return (*(a3 + 104))();
}

{
  return (*(a3 + 112))();
}

{
  return (*(a3 + 120))();
}

{
  return (*(a3 + 128))();
}

{
  return (*(a3 + 136))();
}

{
  return (*(a3 + 144))();
}

{
  return (*(a3 + 152))();
}

{
  return (*(a3 + 160))();
}

{
  return (*(a3 + 168))();
}

{
  return (*(a3 + 176))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(a3 + 192))();
}

{
  return (*(a3 + 200))();
}

{
  return (*(a3 + 208))();
}

{
  v3 = (*(a3 + 216))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(a3 + 224))();
}

{
  return (*(a3 + 232))() & 0x1FF;
}

{
  return (*(a3 + 240))() & 0x1FFFF;
}

{
  v3 = (*(a3 + 248))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(a3 + 256))();
}

{
  return (*(a3 + 264))();
}

{
  return (*(a3 + 272))();
}

{
  return (*(a3 + 280))() & 0x1FF;
}

{
  return (*(a3 + 288))() & 0x1FFFF;
}

{
  v3 = (*(a3 + 296))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(a3 + 304))();
}

{
  return (*(a3 + 312))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(a3 + 32))();
}

{
  return (*(a3 + 64))();
}

{
  return (*(a3 + 72))();
}

{
  return (*(a3 + 80))();
}

{
  return (*(a3 + 88))();
}

{
  return (*(a3 + 96))();
}

{
  return (*(a3 + 112))();
}

{
  return (*(a3 + 120))();
}

{
  return (*(a3 + 128))();
}

{
  return (*(a3 + 136))();
}

{
  return (*(a3 + 144))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 40))();
}

{
  return (*(a4 + 104))();
}

{
  return (*(a4 + 152))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 48))();
}

{
  return (*(a2 + 56))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(a5 + 176))();
}

{
  return (*(a5 + 184))();
}

{
  return (*(a5 + 192))();
}

{
  return (*(a5 + 200))();
}

{
  return (*(a5 + 208))();
}

{
  return (*(a5 + 216))();
}

{
  return (*(a5 + 224))();
}

{
  return (*(a5 + 232))();
}

{
  return (*(a5 + 240))();
}

{
  return (*(a5 + 248))();
}

{
  return (*(a5 + 256))();
}

{
  return (*(a5 + 264))();
}

{
  return (*(a5 + 272))();
}

{
  return (*(a5 + 280))();
}

{
  return (*(a5 + 288))();
}

{
  return (*(a5 + 296))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 48))() & 1;
}

{
  return (*(a2 + 56))();
}

{
  return (*(a2 + 64))();
}

{
  return (*(a2 + 72))();
}

{
  return (*(a2 + 80))();
}

{
  return (*(a2 + 88))();
}

{
  return (*(a2 + 96))();
}

{
  return (*(a2 + 104))();
}

{
  return (*(a2 + 112))();
}

{
  return (*(a2 + 120))();
}

{
  return (*(a2 + 128))();
}

{
  return (*(a2 + 136))();
}

{
  return (*(a2 + 144))();
}

{
  return (*(a2 + 152))();
}

{
  return (*(a2 + 160))();
}

{
  return (*(a2 + 168))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 184))();
}

{
  return (*(a2 + 192))();
}

{
  return (*(a2 + 200))();
}

{
  v2 = (*(a2 + 208))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(a2 + 216))();
}

{
  return (*(a2 + 224))() & 0x1FF;
}

{
  return (*(a2 + 232))() & 0x1FFFF;
}

{
  v2 = (*(a2 + 240))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(a2 + 248))();
}

{
  return (*(a2 + 256))();
}

{
  return (*(a2 + 264))();
}

{
  return (*(a2 + 272))() & 0x1FF;
}

{
  return (*(a2 + 280))() & 0x1FFFF;
}

{
  v2 = (*(a2 + 288))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(a2 + 296))();
}

{
  return (*(a2 + 304))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(a3 + 24))();
}

{
  return (*(a3 + 56))();
}

{
  return (*(a3 + 64))();
}

{
  return (*(a3 + 72))();
}

{
  return (*(a3 + 80))();
}

{
  return (*(a3 + 88))();
}

{
  return (*(a3 + 104))();
}

{
  return (*(a3 + 112))();
}

{
  return (*(a3 + 120))();
}

{
  return (*(a3 + 128))();
}

{
  return (*(a3 + 136))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 32))();
}

{
  return (*(a4 + 96))();
}

{
  return (*(a4 + 144))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 40))();
}

{
  return (*(a2 + 48))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 24))() & 1;
}

{
  return (*(a2 + 32))();
}

{
  return (*(a2 + 40))();
}

{
  return (*(a2 + 48))();
}

{
  return (*(a2 + 56))();
}

{
  return (*(a2 + 64))();
}

{
  return (*(a2 + 72))();
}

{
  return (*(a2 + 80))();
}

{
  return (*(a2 + 88))();
}

{
  return (*(a2 + 96))();
}

{
  return (*(a2 + 104))();
}

{
  return (*(a2 + 112))();
}

{
  return (*(a2 + 120))();
}

{
  return (*(a2 + 128))();
}

{
  return (*(a2 + 136))();
}

{
  return (*(a2 + 144))();
}

void destroy for EncodingError(uint64_t *a1)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  a1[4];
  a1[6];
  v2 = a1[7];

  v2;
}

void *initializeWithCopy for EncodingError(void *a1, void *a2)
{
  v4 = a2[3];
  a1[3] = v4;
  (**(v4 - 8))();
  v5 = a2[4];
  v6 = a2[5];
  a1[4] = v5;
  a1[5] = v6;
  v8 = a2[6];
  v7 = a2[7];
  a1[6] = v8;
  v5;
  v8;
  swift_errorRetain(v7);
  a1[7] = v7;
  return a1;
}

uint64_t *assignWithCopy for EncodingError(uint64_t *a1, void *a2)
{
  __swift_assign_boxed_opaque_existential_0(a1, a2);
  v4 = a2[4];
  v5 = a1[4];
  a1[4] = v4;
  v4;
  v5;
  a1[5] = a2[5];
  v6 = a2[6];
  v7 = a1[6];
  a1[6] = v6;
  v6;
  v7;
  v8 = a1[7];
  v9 = a2[7];
  swift_errorRetain(v9);
  a1[7] = v9;
  v8;
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_0(uint64_t *result, uint64_t a2)
{
  if (result != a2)
  {
    v2 = result[3];
    v3 = *(a2 + 24);
    if (v2 == v3)
    {
      v10 = *(v2 - 8);
      if ((*(v10 + 82) & 2) != 0)
      {
        v13 = *result;
        v14 = *a2;
        v15 = result;
        *a2;
        result = v13;
        *v15 = v14;
      }

      else
      {
        v11 = *(v10 + 24);

        return v11();
      }
    }

    else
    {
      result[3] = v3;
      v4 = *(v2 - 8);
      v5 = *(v3 - 8);
      v6 = v5;
      v7 = *(v5 + 80);
      if ((*(v4 + 82) & 2) != 0)
      {
        v12 = *result;
        if ((v7 & 0x20000) != 0)
        {
          v17 = *a2;
          *result = *a2;
          v17;
        }

        else
        {
          (*(v5 + 16))();
        }

        return v12;
      }

      else
      {
        v9 = result;
        (*(v4 + 32))(v18);
        if ((v7 & 0x20000) != 0)
        {
          v16 = *a2;
          *v9 = *a2;
          v16;
        }

        else
        {
          (*(v6 + 16))(v9, a2, v3);
        }

        return (*(v4 + 8))(v18, v2);
      }
    }
  }

  return result;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  v4 = *(a2 + 48);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 48) = v4;
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for EncodingError(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v4;
  v5 = *(a1 + 32);
  *(a1 + 32) = *(a2 + 32);
  v5;
  v6 = *(a2 + 48);
  v7 = *(a1 + 48);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 48) = v6;
  v7;
  v8 = *(a1 + 56);
  *(a1 + 56) = *(a2 + 56);
  v8;
  return a1;
}

uint64_t getEnumTagSinglePayload for EncodingError(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 64))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for EncodingError(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 56) = 0;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 64) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 24) = (a2 - 1);
      return result;
    }

    *(result + 64) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

void destroy for DecodingError(uint64_t a1)
{
  v2 = *(a1 + 72);
  if (v2 >= 4)
  {
    v2 = *a1 + 4;
  }

  if (v2 > 1)
  {
    if (v2 == 2)
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1);
      v5 = (a1 + 40);
      v4 = 64;
      v3 = 56;
    }

    else
    {
      v4 = 24;
      v3 = 16;
      v5 = a1;
    }
  }

  else
  {
    v3 = 24;
    v4 = 32;
    v5 = (a1 + 8);
  }

  *v5;
  *(a1 + v3);
  v6 = *(a1 + v4);

  v6;
}

uint64_t initializeWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 72);
  if (v3 >= 4)
  {
    v3 = *a2 + 4;
  }

  if (v3 > 1)
  {
    if (v3 == 2)
    {
      v7 = *(a2 + 24);
      *(a1 + 24) = v7;
      v8 = a2;
      (**(v7 - 8))(a1);
      a2 = v8;
      v6 = (a1 + 40);
      v5 = (v8 + 40);
      v4 = 2;
      v9 = 64;
      v10 = 56;
      v11 = 48;
    }

    else
    {
      v4 = 3;
      v9 = 24;
      v10 = 16;
      v11 = 8;
      v5 = a2;
      v6 = a1;
    }
  }

  else
  {
    if (v3)
    {
      v5 = (a2 + 8);
      *a1 = *a2;
      v6 = (a1 + 8);
      v4 = 1;
    }

    else
    {
      v4 = 0;
      v5 = (a2 + 8);
      *a1 = *a2;
      v6 = (a1 + 8);
    }

    v9 = 32;
    v10 = 24;
    v11 = 16;
  }

  v12 = *v5;
  *v6 = *v5;
  *(a1 + v11) = *(a2 + v11);
  v13 = *(a2 + v10);
  *(a1 + v10) = v13;
  v14 = *(a2 + v9);
  v12;
  v13;
  swift_errorRetain(v14);
  *(a1 + v9) = v14;
  *(a1 + 72) = v4;
  return a1;
}

uint64_t assignWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v4 = *(a1 + 72);
    if (v4 >= 4)
    {
      v4 = *a1 + 4;
    }

    if (v4 > 1)
    {
      if (v4 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        v7 = (a1 + 40);
        v6 = 64;
        v5 = 56;
      }

      else
      {
        v6 = 24;
        v5 = 16;
        v7 = a1;
      }
    }

    else
    {
      v5 = 24;
      v6 = 32;
      v7 = (a1 + 8);
    }

    *v7;
    *(a1 + v5);
    *(a1 + v6);
    v8 = *(a2 + 72);
    if (v8 >= 4)
    {
      v8 = *a2 + 4;
    }

    if (v8 > 1)
    {
      if (v8 == 2)
      {
        v12 = *(a2 + 24);
        *(a1 + 24) = v12;
        *(a1 + 32) = *(a2 + 32);
        (**(v12 - 8))(a1, a2);
        v11 = (a1 + 40);
        v10 = (a2 + 40);
        v9 = 2;
        v13 = 64;
        v14 = 56;
        v15 = 48;
      }

      else
      {
        v9 = 3;
        v13 = 24;
        v14 = 16;
        v15 = 8;
        v10 = a2;
        v11 = a1;
      }
    }

    else
    {
      if (v8)
      {
        v10 = (a2 + 8);
        *a1 = *a2;
        v11 = (a1 + 8);
        v9 = 1;
      }

      else
      {
        v9 = 0;
        v10 = (a2 + 8);
        *a1 = *a2;
        v11 = (a1 + 8);
      }

      v13 = 32;
      v14 = 24;
      v15 = 16;
    }

    v16 = *v10;
    *v11 = *v10;
    *(a1 + v15) = *(a2 + v15);
    v17 = *(a2 + v14);
    *(a1 + v14) = v17;
    v18 = *(a2 + v13);
    v16;
    v17;
    swift_errorRetain(v18);
    *(a1 + v13) = v18;
    *(a1 + 72) = v9;
  }

  return a1;
}

__n128 __swift_memcpy73_8(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  result = *(a2 + 16);
  v3 = *(a2 + 32);
  v4 = *(a2 + 48);
  *(a1 + 57) = *(a2 + 57);
  *(a1 + 32) = v3;
  *(a1 + 48) = v4;
  *(a1 + 16) = result;
  return result;
}

uint64_t assignWithTake for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    v4 = *(a1 + 72);
    if (v4 >= 4)
    {
      v4 = *a1 + 4;
    }

    if (v4 > 1)
    {
      if (v4 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        v7 = (a1 + 40);
        v6 = 64;
        v5 = 56;
      }

      else
      {
        v6 = 24;
        v5 = 16;
        v7 = a1;
      }
    }

    else
    {
      v5 = 24;
      v6 = 32;
      v7 = (a1 + 8);
    }

    *v7;
    *(a1 + v5);
    *(a1 + v6);
    v8 = *(a2 + 72);
    if (v8 >= 4)
    {
      v8 = *a2 + 4;
    }

    if (v8 > 1)
    {
      if (v8 == 2)
      {
        v10 = *(a2 + 48);
        *(a1 + 32) = *(a2 + 32);
        *(a1 + 48) = v10;
        *(a1 + 64) = *(a2 + 64);
        v11 = *(a2 + 16);
        *a1 = *a2;
        *(a1 + 16) = v11;
        LOBYTE(v8) = 2;
      }

      else
      {
        v12 = *(a2 + 16);
        *a1 = *a2;
        *(a1 + 16) = v12;
        LOBYTE(v8) = 3;
      }
    }

    else
    {
      v9 = *(a2 + 16);
      *a1 = *a2;
      *(a1 + 16) = v9;
      *(a1 + 32) = *(a2 + 32);
      if (v8)
      {
        LOBYTE(v8) = 1;
      }
    }

    *(a1 + 72) = v8;
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for DecodingError(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFD && *(a1 + 73))
  {
    return (*a1 + 253);
  }

  v3 = *(a1 + 72);
  if (v3 >= 4)
  {
    return (v3 ^ 0xFF) + 1;
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for DecodingError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(result + 57) = 0u;
    *(result + 32) = 0u;
    *(result + 48) = 0u;
    *result = 0u;
    *(result + 16) = 0u;
    *result = a2 - 253;
    if (a3 >= 0xFD)
    {
      *(result + 73) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD)
    {
      *(result + 73) = 0;
    }

    if (a2)
    {
      *(result + 72) = -a2;
    }
  }

  return result;
}

uint64_t getEnumTag for DecodingError(uint64_t a1)
{
  result = *(a1 + 72);
  if (result >= 4)
  {
    return (*a1 + 4);
  }

  return result;
}

uint64_t destructiveInjectEnumTag for DecodingError(uint64_t result, unsigned int a2)
{
  if (a2 > 3)
  {
    *(result + 64) = 0;
    *(result + 32) = 0u;
    *(result + 48) = 0u;
    *result = 0u;
    *(result + 16) = 0u;
    *result = a2 - 4;
    LOBYTE(a2) = 4;
  }

  *(result + 72) = a2;
  return result;
}

void destroy for EncodingError.Context(unint64_t *a1)
{
  *a1;
  a1[2];
  v2 = a1[3];

  v2;
}

unint64_t *initializeWithCopy for EncodingError.Context(unint64_t *a1, unint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  v5 = a2[2];
  v6 = a2[3];
  a1[2] = v5;
  v3;
  v5;
  swift_errorRetain(v6);
  a1[3] = v6;
  return a1;
}

unint64_t *assignWithCopy for EncodingError.Context(unint64_t *a1, unint64_t *a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  a1[1] = a2[1];
  v6 = a2[2];
  v7 = a1[2];
  a1[2] = v6;
  v6;
  v7;
  v8 = a1[3];
  v9 = a2[3];
  swift_errorRetain(v9);
  a1[3] = v9;
  v8;
  return a1;
}

unint64_t *assignWithTake for EncodingError.Context(unint64_t *a1, uint64_t a2)
{
  v4 = *a1;
  *a1 = *a2;
  v4;
  a1[1] = *(a2 + 8);
  a1[2];
  v5 = a1[3];
  *(a1 + 1) = *(a2 + 16);
  v5;
  return a1;
}

uint64_t type metadata completion function for _KeyedEncodingContainerBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 416));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 432);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for _KeyedDecodingContainerBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 424));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 440);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

unint64_t type metadata completion function for IndexingIterator(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 8) + 64;
    swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    v3 = v5;
    if (v6 <= 0x3F)
    {
      v8[1] = *(v5 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v8, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for IndexingIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 80);
  v11 = v7 + v10;
  v12 = (*(v6 + 80) | *(v9 + 80));
  if (v12 > 7 || ((*(v6 + 80) | *(v9 + 80)) & 0x100000) != 0 || (v11 & ~v10) + *(*(v8 - 8) + 64) > 0x18)
  {
    v15 = *a2;
    *a1 = *a2;
    a1 = (v15 + ((v12 + 16) & ~v12));
    v15;
  }

  else
  {
    v16 = v8;
    v17 = ~v10;
    (*(v6 + 16))(a1, a2, v5);
    (*(v9 + 16))((a1 + v11) & v17, (a2 + v11) & v17, v16);
  }

  return a1;
}

uint64_t destroy for IndexingIterator(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v5 = *(v4 - 8) + 8;
  (*v5)(a1, v4);
  v6 = *(v5 + 56) + a1;
  swift_getAssociatedTypeWitness(0, *(a2 + 24), v4, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = v7;
  v9 = *(v7 - 8);
  v10 = *(v9 + 8);
  v11 = (v6 + *(v9 + 80)) & ~*(v9 + 80);

  return v10(v11, v8);
}

uint64_t initializeWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 16;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 48);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 16))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t assignWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 24;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 40);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 24))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t initializeWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 32;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 32);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 32))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t assignWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 40;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 24);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 40))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for IndexingIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v9 + 80);
  if (v10 <= v7)
  {
    v12 = v7;
  }

  else
  {
    v12 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v13 = *(v6 + 64) + v11;
  if (a2 <= v12)
  {
    goto LABEL_28;
  }

  v14 = (v13 & ~v11) + *(*(v8 - 8) + 64);
  v15 = 8 * v14;
  if (v14 <= 3)
  {
    v17 = ((a2 - v12 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      v16 = *(a1 + v14);
      if (!v16)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      v16 = *(a1 + v14);
      if (!*(a1 + v14))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_27:
      if (v12)
      {
LABEL_28:
        if (v7 >= v10)
        {
          v23 = *(v6 + 48);

          return v23(a1, v7, v5);
        }

        else
        {
          v21 = *(v9 + 48);

          return v21((a1 + v13) & ~v11);
        }
      }

      return 0;
    }
  }

  v16 = *(a1 + v14);
  if (!*(a1 + v14))
  {
    goto LABEL_27;
  }

LABEL_14:
  v18 = (v16 - 1) << v15;
  if (v14 > 3)
  {
    v18 = 0;
  }

  if (v14)
  {
    if (v14 <= 3)
    {
      v19 = v14;
    }

    else
    {
      v19 = 4;
    }

    if (v19 > 2)
    {
      if (v19 == 3)
      {
        v20 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v20 = *a1;
      }
    }

    else if (v19 == 1)
    {
      v20 = *a1;
    }

    else
    {
      v20 = *a1;
    }
  }

  else
  {
    v20 = 0;
  }

  return v12 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for IndexingIterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v25 = v8;
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v11 = *(v10 - 8);
  v12 = *(v11 + 84);
  if (v12 <= v9)
  {
    v13 = v9;
  }

  else
  {
    v13 = *(v11 + 84);
  }

  v14 = *(v11 + 80);
  v15 = *(v8 + 64) + v14;
  v16 = (v15 & ~v14) + *(*(v10 - 8) + 64);
  if (a3 <= v13)
  {
    v17 = 0;
  }

  else if (v16 <= 3)
  {
    v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      v17 = 4;
    }

    else
    {
      if (v20 < 0x100)
      {
        v21 = 1;
      }

      else
      {
        v21 = 2;
      }

      if (v20 >= 2)
      {
        v17 = v21;
      }

      else
      {
        v17 = 0;
      }
    }
  }

  else
  {
    v17 = 1;
  }

  if (v13 < a2)
  {
    v18 = ~v13 + a2;
    if (v16 < 4)
    {
      v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        v22 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 != 3)
        {
          if (v16 == 2)
          {
            *a1 = v22;
            if (v17 > 1)
            {
LABEL_46:
              if (v17 == 2)
              {
                *&a1[v16] = v19;
              }

              else
              {
                *&a1[v16] = v19;
              }

              return;
            }
          }

          else
          {
            *a1 = v18;
            if (v17 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v22;
        a1[2] = BYTE2(v22);
      }

      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v16);
      *a1 = v18;
      v19 = 1;
      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v17)
    {
      a1[v16] = v19;
    }

    return;
  }

  if (v17 > 1)
  {
    if (v17 != 2)
    {
      *&a1[v16] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v16] = 0;
  }

  else if (v17)
  {
    a1[v16] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v9 >= v12)
  {
    v24 = *(v25 + 56);

    v24(a1, a2, v9, v7);
  }

  else
  {
    v23 = *(v11 + 56);

    v23(&a1[v15] & ~v14, a2);
  }
}

uint64_t dispatch thunk of Collection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 160))();
}

{
  return (*(a4 + 168))();
}

{
  return (*(a4 + 176))();
}

uint64_t initializeBufferWithCopyOfBuffer for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  v3;
  return a1;
}

uint64_t *assignWithCopy for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  a1[1] = *(a2 + 8);
  a1[2] = *(a2 + 16);
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  *a1;
  *a1 = *a2;
  a1[2] = *(a2 + 16);
  return a1;
}

atomic_ullong *initializeBufferWithCopyOfBuffer for Dictionary.Keys.Iterator(atomic_ullong **a1, atomic_ullong **a2)
{
  v2 = *a2;
  *a1 = *a2;
  v2;
  return v2 + 2;
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  *(a1 + 32) = *(a2 + 32);
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

__n128 __swift_memcpy17_8(__n128 *a1, __n128 *a2)
{
  result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

swift *type metadata completion function for _SwiftDictionaryNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_1EEEAAE60;
  v2[1] = "\b";
  v2[2] = &value witness table for Builtin.Int64.size;
  v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4, v2, a1 + 120);
}

swift *type metadata completion function for _SwiftDeferredNSDictionary(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = "\b";
  v2[2] = &unk_1EEEAAE60;
  return swift_initClassMetadata2(a1, 0, 3, v2, a1 + 120);
}

void type metadata completion function for DiscontiguousSlice.Index(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  swift_getAssociatedTypeWitness(319, *(a1 + 24), *(a1 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    v4[1] = *(v2 - 8) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, v4, a1 + 32);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DiscontiguousSlice.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  v7 = *(v6 + 80);
  if (v7 <= 7 && (*(v6 + 80) & 0x100000) == 0 && ((-9 - v7) | v7) - *(*(v5 - 8) + 64) >= 0xFFFFFFFFFFFFFFE7)
  {
    *a1 = *a2;
    (*(v6 + 16))((a1 + v7 + 8) & ~v7, (a2 + v7 + 8) & ~v7, v5);
  }

  else
  {
    v10 = *a2;
    *a1 = *a2;
    a1 = (v10 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
    v10;
  }

  return a1;
}

uint64_t destroy for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v4 = v3;
  v5 = *(v3 - 8);
  v6 = *(v5 + 8);
  v7 = (a1 + *(v5 + 80) + 8) & ~*(v5 + 80);

  return v6(v7, v4);
}

void *initializeWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  (*(v6 + 16))((a1 + *(v6 + 80) + 8) & ~*(v6 + 80), (a2 + *(v6 + 80) + 8) & ~*(v6 + 80), v5);
  return a1;
}

void *assignWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  (*(v6 + 24))((a1 + *(v6 + 80) + 8) & ~*(v6 + 80), (a2 + *(v6 + 80) + 8) & ~*(v6 + 80), v5);
  return a1;
}

void *initializeWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  (*(v6 + 32))((a1 + *(v6 + 80) + 8) & ~*(v6 + 80), (a2 + *(v6 + 80) + 8) & ~*(v6 + 80), v5);
  return a1;
}

void *assignWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  (*(v6 + 40))((a1 + *(v6 + 80) + 8) & ~*(v6 + 80), (a2 + *(v6 + 80) + 8) & ~*(v6 + 80), v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  v8 = *(v6 + 80);
  if (!a2)
  {
    return 0;
  }

  if (a2 <= v7)
  {
LABEL_23:
    v14 = *(v6 + 48);

    return v14((a1 + v8 + 8) & ~v8);
  }

  v9 = ((v8 + 8) & ~v8) + *(*(v5 - 8) + 64);
  v10 = 8 * v9;
  if (v9 <= 3)
  {
    v12 = ((a2 - v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      v11 = *(a1 + v9);
      if (!v11)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v12 > 0xFF)
    {
      v11 = *(a1 + v9);
      if (!*(a1 + v9))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v12 < 2)
    {
LABEL_22:
      if (v7)
      {
        goto LABEL_23;
      }

      return 0;
    }
  }

  v11 = *(a1 + v9);
  if (!*(a1 + v9))
  {
    goto LABEL_22;
  }

LABEL_11:
  v13 = (v11 - 1) << v10;
  if (v9 > 3)
  {
    v13 = 0;
  }

  if (v9)
  {
    if (v9 > 3)
    {
      LODWORD(v9) = 4;
    }

    if (v9 > 2)
    {
      if (v9 == 3)
      {
        LODWORD(v9) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v9) = *a1;
      }
    }

    else if (v9 == 1)
    {
      LODWORD(v9) = *a1;
    }

    else
    {
      LODWORD(v9) = *a1;
    }
  }

  return v7 + (v9 | v13) + 1;
}

void storeEnumTagSinglePayload for DiscontiguousSlice.Index(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 80);
  v11 = ((v10 + 8) & ~v10) + *(v8 + 64);
  if (a3 <= v9)
  {
    v12 = 0;
  }

  else if (v11 <= 3)
  {
    v15 = ((a3 - v9 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v15))
    {
      v12 = 4;
    }

    else
    {
      if (v15 < 0x100)
      {
        v16 = 1;
      }

      else
      {
        v16 = 2;
      }

      if (v15 >= 2)
      {
        v12 = v16;
      }

      else
      {
        v12 = 0;
      }
    }
  }

  else
  {
    v12 = 1;
  }

  if (v9 < a2)
  {
    v13 = ~v9 + a2;
    if (v11 < 4)
    {
      v14 = (v13 >> (8 * v11)) + 1;
      if (v11)
      {
        v17 = v13 & ~(-1 << (8 * v11));
        bzero(a1, v11);
        if (v11 != 3)
        {
          if (v11 == 2)
          {
            *a1 = v17;
            if (v12 > 1)
            {
LABEL_39:
              if (v12 == 2)
              {
                *&a1[v11] = v14;
              }

              else
              {
                *&a1[v11] = v14;
              }

              return;
            }
          }

          else
          {
            *a1 = v13;
            if (v12 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *a1 = v17;
        a1[2] = BYTE2(v17);
      }

      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      bzero(a1, v11);
      *a1 = v13;
      v14 = 1;
      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v12)
    {
      a1[v11] = v14;
    }

    return;
  }

  if (v12 > 1)
  {
    if (v12 != 2)
    {
      *&a1[v11] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_28;
    }

    *&a1[v11] = 0;
  }

  else if (v12)
  {
    a1[v11] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return;
  }

LABEL_28:
  v18 = *(v8 + 56);

  v18(&a1[v10 + 8] & ~v10, a2);
}

void *initializeBufferWithCopyOfBuffer for _ClosureBasedIterator(void *a1, void *a2)
{
  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  v3;
  return a1;
}

uint64_t assignWithTake for _ClosureBasedIterator(uint64_t a1, _OWORD *a2)
{
  v3 = *(a1 + 8);
  *a1 = *a2;
  v3;
  return a1;
}

uint64_t type metadata completion function for _IteratorBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 104));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 120);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

swift *type metadata completion function for _AnyCollectionBox(uint64_t a1)
{
  v2[0] = &unk_180726B08;
  v2[1] = &unk_180726B08;
  return swift_initClassMetadata2(a1, 0, 2, v2, a1 + 216);
}

uint64_t dispatch thunk of _AnyCollectionBox.subscript.getter()
{
  return (*(*v0 + 256))();
}

{
  return (*(*v0 + 336))();
}

uint64_t type metadata completion function for _SequenceBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 208));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 224);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for _CollectionBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 344));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 360);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for _BidirectionalCollectionBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 368));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 384);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for _RandomAccessCollectionBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 376));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 392);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

void *assignWithCopy for _ClosureBasedIterator(void *a1, void *a2)
{
  v3 = a2[1];
  v4 = a1[1];
  *a1 = *a2;
  a1[1] = v3;
  v3;
  v4;
  return a1;
}

__int128 *initializeBufferWithCopyOfBuffer for AnyIndex(__int128 *a1, __int128 *a2)
{
  v3 = *a2;
  *a1 = *a2;
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AnyIndex(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  v5 = *a1;
  *a1 = *a2;
  swift_unknownObjectRetain(v3);
  swift_unknownObjectRelease(v5);
  *(a1 + 8) = v4;
  return a1;
}

id *assignWithTake for AnyIndex(id *a1, _OWORD *a2)
{
  swift_unknownObjectRelease(*a1);
  *a1 = *a2;
  return a1;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyFilterSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  v8 = *(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    v11 = *a2;
    *a1 = *a2;
    a1 = (v11 + (((v8 & 0xF8) + 23) & ~(v8 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(v6 + 16))(a1, a2, v5);
    v10 = ((a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    v11 = v10[1];
    v12 = ((a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    *v12 = *v10;
    v12[1] = v11;
  }

  v11;
  return a1;
}

uint64_t initializeWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 16;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 48) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = v9[1];
  *v8 = *v9;
  v8[1] = v10;
  v10;
  return a1;
}

uint64_t assignWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 24;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 40) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = v9[1];
  v11 = v8[1];
  *v8 = *v9;
  v8[1] = v10;
  v10;
  v11;
  return a1;
}

uint64_t initializeWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 32;
  (*v6)(a1, a2, v5);
  *((*(v6 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v6 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 40;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 24) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(v8 + 8);
  *v8 = *((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9;
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyFilterSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(*(v5 - 8) + 64);
  if (!a2)
  {
    return 0;
  }

  if (v8 >= a2)
  {
    goto LABEL_28;
  }

  v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  v11 = v10 & 0xFFFFFFF8;
  if ((v10 & 0xFFFFFFF8) != 0)
  {
    v12 = 2;
  }

  else
  {
    v12 = a2 - v8 + 1;
  }

  if (v12 >= 0x10000)
  {
    v13 = 4;
  }

  else
  {
    v13 = 2;
  }

  if (v12 < 0x100)
  {
    v13 = 1;
  }

  if (v12 >= 2)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  if (v14 > 1)
  {
    if (v14 == 2)
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_28;
      }
    }

    else
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_28;
      }
    }
  }

  else if (!v14 || (v15 = *(a1 + v10)) == 0)
  {
LABEL_28:
    if (v7 < 0x7FFFFFFF)
    {
      v19 = *((a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
      if (v19 >= 0xFFFFFFFF)
      {
        LODWORD(v19) = -1;
      }

      return (v19 + 1);
    }

    else
    {
      v18 = *(v6 + 48);

      return v18(a1);
    }
  }

  v17 = v15 - 1;
  if (v11)
  {
    v17 = 0;
    LODWORD(v11) = *a1;
  }

  return v8 + (v11 | v17) + 1;
}

void storeEnumTagSinglePayload for LazyFilterSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 64);
  if (v9 <= 0x7FFFFFFF)
  {
    v11 = 0x7FFFFFFF;
  }

  else
  {
    v11 = *(v8 + 84);
  }

  v12 = ((v10 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v10 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
  {
    v13 = a3 - v11 + 1;
  }

  else
  {
    v13 = 2;
  }

  if (v13 >= 0x10000)
  {
    v14 = 4;
  }

  else
  {
    v14 = 2;
  }

  if (v13 < 0x100)
  {
    v14 = 1;
  }

  if (v13 >= 2)
  {
    v15 = v14;
  }

  else
  {
    v15 = 0;
  }

  if (v11 < a3)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  if (a2 > v11)
  {
    if (((v10 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
    {
      v17 = a2 - v11;
    }

    else
    {
      v17 = 1;
    }

    if (((v10 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      v18 = ~v11 + a2;
      bzero(a1, v12);
      *a1 = v18;
    }

    if (v16 > 1)
    {
      if (v16 == 2)
      {
        *(a1 + v12) = v17;
      }

      else
      {
        *(a1 + v12) = v17;
      }
    }

    else if (v16)
    {
      *(a1 + v12) = v17;
    }

    return;
  }

  if (v16 > 1)
  {
    if (v16 != 2)
    {
      *(a1 + v12) = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_36;
    }

    *(a1 + v12) = 0;
  }

  else if (v16)
  {
    *(a1 + v12) = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_36;
  }

  if (!a2)
  {
    return;
  }

LABEL_36:
  if (v9 < 0x7FFFFFFF)
  {
    v20 = ((a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((a2 & 0x80000000) != 0)
    {
      *v20 = a2 & 0x7FFFFFFF;
      v20[1] = 0;
    }

    else
    {
      *v20 = (a2 - 1);
    }
  }

  else
  {
    v19 = *(v8 + 56);

    v19(a1, a2);
  }
}

void type metadata completion function for FlattenSequence.Iterator(void *a1)
{
  v3 = a1[2];
  v2 = a1[3];
  swift_getAssociatedTypeWitness(319, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v13[0] = *(v4 - 8) + 64;
    v6 = a1[4];
    swift_getAssociatedTypeWitness(255, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    v11 = type metadata accessor for Optional(319, v8, v9, v10);
    if (v12 <= 0x3F)
    {
      v13[1] = *(v11 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v13, (a1 + 5));
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for FlattenSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 64);
  v12 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = *(v14 - 8);
  v16 = *(v15 + 80);
  v17 = v11 + v16;
  if (*(v15 + 84))
  {
    v18 = *(v15 + 64);
  }

  else
  {
    v18 = *(v15 + 64) + 1;
  }

  v19 = (*(v10 + 80) | *(v15 + 80));
  if (v19 > 7 || ((*(v10 + 80) | *(v15 + 80)) & 0x100000) != 0 || (v17 & ~v16) + v18 > 0x18)
  {
    v22 = *a2;
    *a1 = *a2;
    a1 = (v22 + ((v19 + 16) & ~v19));
    v22;
  }

  else
  {
    v23 = v14;
    v24 = ~v16;
    (*(v10 + 16))(a1, a2, v9);
    v25 = a1 + v17;
    v26 = a2 + v17;
    if ((*(v15 + 48))(v26 & v24, 1, v23))
    {
      memcpy((v25 & v24), (v26 & v24), v18);
    }

    else
    {
      (*(v15 + 16))(v25 & v24, v26 & v24, v23);
      (*(v15 + 56))(v25 & v24, 0, 1, v23);
    }
  }

  return a1;
}

uint64_t destroy for FlattenSequence.Iterator(uint64_t a1, void *a2)
{
  v5 = a2[2];
  v4 = a2[3];
  swift_getAssociatedTypeWitness(0, v4, v5, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 8;
  (*v7)(a1, v6);
  v8 = *(v7 + 56);
  v9 = a2[4];
  swift_getAssociatedTypeWitness(255, v4, v5, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v9, v10, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v12 = v11;
  v13 = *(v11 - 8);
  v14 = *(v13 + 80);
  v15 = v8 + a1 + v14;
  v18 = v13;
  result = (*(v13 + 48))(v15 & ~v14, 1, v11);
  if (!result)
  {
    v17 = *(v18 + 8);

    return v17(v15 & ~v14, v12);
  }

  return result;
}

uint64_t initializeWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 16;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 48);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  if ((*(v15 + 48))(v18 & ~v16, 1, v13))
  {
    if (*(v15 + 84))
    {
      v19 = *(v15 + 64);
    }

    else
    {
      v19 = *(v15 + 64) + 1;
    }

    memcpy((v17 & ~v16), (v18 & ~v16), v19);
  }

  else
  {
    (*(v15 + 16))(v17 & ~v16, v18 & ~v16, v14);
    (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
  }

  return a1;
}

uint64_t assignWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 24;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 40);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  v19 = *(v15 + 48);
  LODWORD(a2) = v19(v17 & ~v16, 1, v13);
  v20 = v19(v18 & ~v16, 1, v14);
  if (a2)
  {
    if (!v20)
    {
      (*(v15 + 16))(v17 & ~v16, v18 & ~v16, v14);
      (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
      return a1;
    }

    v21 = *(v15 + 84);
    v22 = *(v15 + 64);
  }

  else
  {
    if (!v20)
    {
      (*(v15 + 24))(v17 & ~v16, v18 & ~v16, v14);
      return a1;
    }

    v24 = *(v15 + 8);
    v23 = v15 + 8;
    v24(v17 & ~v16, v14);
    v21 = *(v23 + 76);
    v22 = *(v23 + 56);
  }

  if (v21)
  {
    v25 = v22;
  }

  else
  {
    v25 = v22 + 1;
  }

  memcpy((v17 & ~v16), (v18 & ~v16), v25);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 32;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 32);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  if ((*(v15 + 48))(v18 & ~v16, 1, v13))
  {
    if (*(v15 + 84))
    {
      v19 = *(v15 + 64);
    }

    else
    {
      v19 = *(v15 + 64) + 1;
    }

    memcpy((v17 & ~v16), (v18 & ~v16), v19);
  }

  else
  {
    (*(v15 + 32))(v17 & ~v16, v18 & ~v16, v14);
    (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
  }

  return a1;
}

uint64_t assignWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 40;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 24);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  v19 = *(v15 + 48);
  LODWORD(a2) = v19(v17 & ~v16, 1, v13);
  v20 = v19(v18 & ~v16, 1, v14);
  if (a2)
  {
    if (!v20)
    {
      (*(v15 + 32))(v17 & ~v16, v18 & ~v16, v14);
      (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
      return a1;
    }

    v21 = *(v15 + 84);
    v22 = *(v15 + 64);
  }

  else
  {
    if (!v20)
    {
      (*(v15 + 40))(v17 & ~v16, v18 & ~v16, v14);
      return a1;
    }

    v24 = *(v15 + 8);
    v23 = v15 + 8;
    v24(v17 & ~v16, v14);
    v21 = *(v23 + 76);
    v22 = *(v23 + 56);
  }

  if (v21)
  {
    v25 = v22;
  }

  else
  {
    v25 = v22 + 1;
  }

  memcpy((v17 & ~v16), (v18 & ~v16), v25);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence.Iterator(unsigned __int16 *a1, unsigned int a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 84);
  v12 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = *(v14 - 8);
  v16 = *(v15 + 84);
  if (v16)
  {
    v17 = v16 - 1;
  }

  else
  {
    v17 = 0;
  }

  if (v17 <= v11)
  {
    v18 = v11;
  }

  else
  {
    v18 = v17;
  }

  v19 = *(v15 + 80);
  if (v16)
  {
    v20 = *(*(v14 - 8) + 64);
  }

  else
  {
    v20 = *(*(v14 - 8) + 64) + 1;
  }

  if (!a2)
  {
    return 0;
  }

  v21 = *(v10 + 64) + v19;
  if (a2 <= v18)
  {
    goto LABEL_34;
  }

  v22 = v20 + (v21 & ~v19);
  v23 = 8 * v22;
  if (v22 <= 3)
  {
    v25 = ((a2 - v18 + ~(-1 << v23)) >> v23) + 1;
    if (HIWORD(v25))
    {
      v24 = *(a1 + v22);
      if (!v24)
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v25 > 0xFF)
    {
      v24 = *(a1 + v22);
      if (!*(a1 + v22))
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v25 < 2)
    {
LABEL_33:
      if (v18)
      {
LABEL_34:
        if (v11 >= v17)
        {
          v31 = *(v10 + 48);

          return v31(a1, v11, v9);
        }

        else
        {
          v29 = (*(v15 + 48))((a1 + v21) & ~v19);
          if (v29 >= 2)
          {
            return v29 - 1;
          }

          else
          {
            return 0;
          }
        }
      }

      return 0;
    }
  }

  v24 = *(a1 + v22);
  if (!*(a1 + v22))
  {
    goto LABEL_33;
  }

LABEL_20:
  v26 = (v24 - 1) << v23;
  if (v22 > 3)
  {
    v26 = 0;
  }

  if (v22)
  {
    if (v22 <= 3)
    {
      v27 = v22;
    }

    else
    {
      v27 = 4;
    }

    if (v27 > 2)
    {
      if (v27 == 3)
      {
        v28 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v28 = *a1;
      }
    }

    else if (v27 == 1)
    {
      v28 = *a1;
    }

    else
    {
      v28 = *a1;
    }
  }

  else
  {
    v28 = 0;
  }

  return v18 + (v28 | v26) + 1;
}

void storeEnumTagSinglePayload for FlattenSequence.Iterator(_BYTE *a1, uint64_t a2, unsigned int a3, void *a4)
{
  v9 = a4[2];
  v8 = a4[3];
  swift_getAssociatedTypeWitness(0, v8, v9, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v11 = *(v10 - 8);
  v36 = v10;
  v12 = *(v11 + 84);
  v13 = a4[4];
  swift_getAssociatedTypeWitness(255, v8, v9, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v13, v14, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = 0;
  v17 = *(v16 - 8);
  v18 = *(v17 + 84);
  v19 = v18 - 1;
  if (!v18)
  {
    v19 = 0;
  }

  if (v19 <= v12)
  {
    v20 = v12;
  }

  else
  {
    v20 = v19;
  }

  v21 = *(v17 + 80);
  v22 = *(v11 + 64) + v21;
  if (v18)
  {
    v23 = *(v17 + 64);
  }

  else
  {
    v23 = *(v17 + 64) + 1;
  }

  v24 = (v22 & ~v21) + v23;
  if (a3 <= v20)
  {
    goto LABEL_20;
  }

  if (v24 <= 3)
  {
    v25 = ((a3 - v20 + ~(-1 << (8 * v24))) >> (8 * v24)) + 1;
    if (HIWORD(v25))
    {
      v15 = 4;
      if (v20 >= a2)
      {
        goto LABEL_30;
      }

      goto LABEL_21;
    }

    if (v25 < 0x100)
    {
      v26 = 1;
    }

    else
    {
      v26 = 2;
    }

    if (v25 >= 2)
    {
      v15 = v26;
    }

    else
    {
      v15 = 0;
    }

LABEL_20:
    if (v20 >= a2)
    {
      goto LABEL_30;
    }

    goto LABEL_21;
  }

  v15 = 1;
  if (v20 >= a2)
  {
LABEL_30:
    if (v15 > 1)
    {
      if (v15 != 2)
      {
        *&a1[v24] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_37;
      }

      *&a1[v24] = 0;
    }

    else if (v15)
    {
      a1[v24] = 0;
      if (!a2)
      {
        return;
      }

LABEL_37:
      if (v12 >= v19)
      {
        v34 = *(v11 + 56);

        v34(a1, a2, v12, v36);
      }

      else
      {
        v30 = (&a1[v22] & ~v21);
        if (v19 >= a2)
        {
          v35 = *(v17 + 56);

          v35(v30, (a2 + 1));
        }

        else
        {
          if (v23 <= 3)
          {
            v31 = ~(-1 << (8 * v23));
          }

          else
          {
            v31 = -1;
          }

          if (v23)
          {
            v32 = v31 & (~v19 + a2);
            if (v23 <= 3)
            {
              v33 = v23;
            }

            else
            {
              v33 = 4;
            }

            bzero(v30, v23);
            if (v33 > 2)
            {
              if (v33 == 3)
              {
                *v30 = v32;
                v30[2] = BYTE2(v32);
              }

              else
              {
                *v30 = v32;
              }
            }

            else if (v33 == 1)
            {
              *v30 = v32;
            }

            else
            {
              *v30 = v32;
            }
          }
        }
      }

      return;
    }

    if (!a2)
    {
      return;
    }

    goto LABEL_37;
  }

LABEL_21:
  v27 = ~v20 + a2;
  if (v24 >= 4)
  {
    bzero(a1, (v22 & ~v21) + v23);
    *a1 = v27;
    v28 = 1;
    if (v15 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v28 = (v27 >> (8 * v24)) + 1;
  if (!v24)
  {
LABEL_58:
    if (v15 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v29 = v27 & ~(-1 << (8 * v24));
  bzero(a1, v24);
  if (v24 == 3)
  {
    *a1 = v29;
    a1[2] = BYTE2(v29);
    goto LABEL_58;
  }

  if (v24 == 2)
  {
    *a1 = v29;
    if (v15 > 1)
    {
LABEL_62:
      if (v15 == 2)
      {
        *&a1[v24] = v28;
      }

      else
      {
        *&a1[v24] = v28;
      }

      return;
    }
  }

  else
  {
    *a1 = v27;
    if (v15 > 1)
    {
      goto LABEL_62;
    }
  }

LABEL_59:
  if (v15)
  {
    a1[v24] = v28;
  }
}

void type metadata completion function for FlattenSequence<>.Index(void *a1)
{
  v2 = a1[2];
  v3 = a1[3];
  swift_getAssociatedTypeWitness(319, v3, v2, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v5 <= 0x3F)
  {
    v13[0] = *(v4 - 8) + 64;
    v6 = a1[4];
    swift_getAssociatedTypeWitness(255, *(v3 + 8), v2, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    v11 = type metadata accessor for Optional(319, v8, v9, v10);
    if (v12 <= 0x3F)
    {
      v13[1] = *(v11 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v13, (a1 + 5));
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for FlattenSequence<>.Index(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 64);
  v12 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v15 = *(v14 - 8);
  v16 = *(v15 + 80);
  v17 = v11 + v16;
  if (*(v15 + 84))
  {
    v18 = *(v15 + 64);
  }

  else
  {
    v18 = *(v15 + 64) + 1;
  }

  v19 = (*(v10 + 80) | *(v15 + 80));
  if (v19 > 7 || ((*(v10 + 80) | *(v15 + 80)) & 0x100000) != 0 || ((v11 + v16) & ~v16) + v18 > 0x18)
  {
    v22 = *a2;
    *a1 = *a2;
    a1 = (v22 + ((v19 + 16) & ~v19));
    v22;
  }

  else
  {
    v23 = v14;
    v24 = ~v16;
    (*(v10 + 16))(a1, a2, v9);
    v25 = a1 + v17;
    v26 = a2 + v17;
    if ((*(v15 + 48))(v26 & v24, 1, v23))
    {
      memcpy((v25 & v24), (v26 & v24), v18);
    }

    else
    {
      (*(v15 + 16))(v25 & v24, v26 & v24, v23);
      (*(v15 + 56))(v25 & v24, 0, 1, v23);
    }
  }

  return a1;
}

uint64_t destroy for FlattenSequence<>.Index(uint64_t a1, void *a2)
{
  v5 = a2[2];
  v4 = a2[3];
  swift_getAssociatedTypeWitness(0, v4, v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = *(v6 - 8) + 8;
  (*v7)(a1, v6);
  v8 = *(v7 + 56) + a1;
  v9 = a2[4];
  swift_getAssociatedTypeWitness(255, *(v4 + 8), v5, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v9, v10, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v12 = v11;
  v13 = *(v11 - 8);
  v14 = *(v13 + 80);
  v17 = v13;
  result = (*(v13 + 48))((v8 + v14) & ~v14, 1, v11);
  if (!result)
  {
    v16 = *(v17 + 8);

    return v16((v8 + v14) & ~v14, v12);
  }

  return result;
}

uint64_t initializeWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8) + 16;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 48);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  if ((*(v15 + 48))(v18 & ~v16, 1, v13))
  {
    if (*(v15 + 84))
    {
      v19 = *(v15 + 64);
    }

    else
    {
      v19 = *(v15 + 64) + 1;
    }

    memcpy((v17 & ~v16), (v18 & ~v16), v19);
  }

  else
  {
    (*(v15 + 16))(v17 & ~v16, v18 & ~v16, v14);
    (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
  }

  return a1;
}

uint64_t assignWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8) + 24;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 40);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  v19 = *(v15 + 48);
  LODWORD(a2) = v19(v17 & ~v16, 1, v13);
  v20 = v19(v18 & ~v16, 1, v14);
  if (a2)
  {
    if (!v20)
    {
      (*(v15 + 16))(v17 & ~v16, v18 & ~v16, v14);
      (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
      return a1;
    }

    v21 = *(v15 + 84);
    v22 = *(v15 + 64);
  }

  else
  {
    if (!v20)
    {
      (*(v15 + 24))(v17 & ~v16, v18 & ~v16, v14);
      return a1;
    }

    v24 = *(v15 + 8);
    v23 = v15 + 8;
    v24(v17 & ~v16, v14);
    v21 = *(v23 + 76);
    v22 = *(v23 + 56);
  }

  if (v21)
  {
    v25 = v22;
  }

  else
  {
    v25 = v22 + 1;
  }

  memcpy((v17 & ~v16), (v18 & ~v16), v25);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8) + 32;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 32);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  if ((*(v15 + 48))(v18 & ~v16, 1, v13))
  {
    if (*(v15 + 84))
    {
      v19 = *(v15 + 64);
    }

    else
    {
      v19 = *(v15 + 64) + 1;
    }

    memcpy((v17 & ~v16), (v18 & ~v16), v19);
  }

  else
  {
    (*(v15 + 32))(v17 & ~v16, v18 & ~v16, v14);
    (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
  }

  return a1;
}

uint64_t assignWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8) + 40;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 24);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = v10 + v16 + a1;
  v18 = v10 + v16 + a2;
  v19 = *(v15 + 48);
  LODWORD(a2) = v19(v17 & ~v16, 1, v13);
  v20 = v19(v18 & ~v16, 1, v14);
  if (a2)
  {
    if (!v20)
    {
      (*(v15 + 32))(v17 & ~v16, v18 & ~v16, v14);
      (*(v15 + 56))(v17 & ~v16, 0, 1, v14);
      return a1;
    }

    v21 = *(v15 + 84);
    v22 = *(v15 + 64);
  }

  else
  {
    if (!v20)
    {
      (*(v15 + 40))(v17 & ~v16, v18 & ~v16, v14);
      return a1;
    }

    v24 = *(v15 + 8);
    v23 = v15 + 8;
    v24(v17 & ~v16, v14);
    v21 = *(v23 + 76);
    v22 = *(v23 + 56);
  }

  if (v21)
  {
    v25 = v22;
  }

  else
  {
    v25 = v22 + 1;
  }

  memcpy((v17 & ~v16), (v18 & ~v16), v25);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence<>.Index(unsigned __int16 *a1, unsigned int a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v31 = v8;
  v10 = *(v9 + 84);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, *(v6 + 8), v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = *(v13 - 8);
  v15 = *(v14 + 84);
  if (v15)
  {
    v16 = v15 - 1;
  }

  else
  {
    v16 = 0;
  }

  if (v16 <= v10)
  {
    v17 = v10;
  }

  else
  {
    v17 = v16;
  }

  v18 = *(v14 + 80);
  if (v15)
  {
    v19 = *(*(v13 - 8) + 64);
  }

  else
  {
    v19 = *(*(v13 - 8) + 64) + 1;
  }

  if (!a2)
  {
    return 0;
  }

  v20 = *(v9 + 64) + v18;
  if (a2 <= v17)
  {
    goto LABEL_34;
  }

  v21 = v19 + (v20 & ~v18);
  v22 = 8 * v21;
  if (v21 <= 3)
  {
    v24 = ((a2 - v17 + ~(-1 << v22)) >> v22) + 1;
    if (HIWORD(v24))
    {
      v23 = *(a1 + v21);
      if (!v23)
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v24 > 0xFF)
    {
      v23 = *(a1 + v21);
      if (!*(a1 + v21))
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v24 < 2)
    {
LABEL_33:
      if (v17)
      {
LABEL_34:
        if (v10 >= v16)
        {
          v30 = *(v9 + 48);

          return v30(a1, v10, v31);
        }

        else
        {
          v28 = (*(v14 + 48))((a1 + v20) & ~v18);
          if (v28 >= 2)
          {
            return v28 - 1;
          }

          else
          {
            return 0;
          }
        }
      }

      return 0;
    }
  }

  v23 = *(a1 + v21);
  if (!*(a1 + v21))
  {
    goto LABEL_33;
  }

LABEL_20:
  v25 = (v23 - 1) << v22;
  if (v21 > 3)
  {
    v25 = 0;
  }

  if (v21)
  {
    if (v21 <= 3)
    {
      v26 = v21;
    }

    else
    {
      v26 = 4;
    }

    if (v26 > 2)
    {
      if (v26 == 3)
      {
        v27 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v27 = *a1;
      }
    }

    else if (v26 == 1)
    {
      v27 = *a1;
    }

    else
    {
      v27 = *a1;
    }
  }

  else
  {
    v27 = 0;
  }

  return v17 + (v27 | v25) + 1;
}

void storeEnumTagSinglePayload for FlattenSequence<>.Index(_BYTE *a1, uint64_t a2, unsigned int a3, void *a4)
{
  v8 = a4[2];
  v7 = a4[3];
  swift_getAssociatedTypeWitness(0, v7, v8, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  v35 = v9;
  v11 = *(v10 + 84);
  v12 = a4[4];
  swift_getAssociatedTypeWitness(255, *(v7 + 8), v8, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = 0;
  v16 = *(v15 - 8);
  v17 = *(v16 + 84);
  v18 = v17 - 1;
  if (!v17)
  {
    v18 = 0;
  }

  if (v18 <= v11)
  {
    v19 = v11;
  }

  else
  {
    v19 = v18;
  }

  v20 = *(v16 + 80);
  v21 = *(v10 + 64) + v20;
  if (v17)
  {
    v22 = *(v16 + 64);
  }

  else
  {
    v22 = *(v16 + 64) + 1;
  }

  v23 = (v21 & ~v20) + v22;
  if (a3 <= v19)
  {
    goto LABEL_20;
  }

  if (v23 <= 3)
  {
    v24 = ((a3 - v19 + ~(-1 << (8 * v23))) >> (8 * v23)) + 1;
    if (HIWORD(v24))
    {
      v14 = 4;
      if (v19 >= a2)
      {
        goto LABEL_30;
      }

      goto LABEL_21;
    }

    if (v24 < 0x100)
    {
      v25 = 1;
    }

    else
    {
      v25 = 2;
    }

    if (v24 >= 2)
    {
      v14 = v25;
    }

    else
    {
      v14 = 0;
    }

LABEL_20:
    if (v19 >= a2)
    {
      goto LABEL_30;
    }

    goto LABEL_21;
  }

  v14 = 1;
  if (v19 >= a2)
  {
LABEL_30:
    if (v14 > 1)
    {
      if (v14 != 2)
      {
        *&a1[v23] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_37;
      }

      *&a1[v23] = 0;
    }

    else if (v14)
    {
      a1[v23] = 0;
      if (!a2)
      {
        return;
      }

LABEL_37:
      if (v11 >= v18)
      {
        v33 = *(v10 + 56);

        v33(a1, a2, v11, v35);
      }

      else
      {
        v29 = (&a1[v21] & ~v20);
        if (v18 >= a2)
        {
          v34 = *(v16 + 56);

          v34(&a1[v21] & ~v20, (a2 + 1));
        }

        else
        {
          if (v22 <= 3)
          {
            v30 = ~(-1 << (8 * v22));
          }

          else
          {
            v30 = -1;
          }

          if (v22)
          {
            v31 = v30 & (~v18 + a2);
            if (v22 <= 3)
            {
              v32 = v22;
            }

            else
            {
              v32 = 4;
            }

            bzero(v29, v22);
            if (v32 > 2)
            {
              if (v32 == 3)
              {
                *v29 = v31;
                v29[2] = BYTE2(v31);
              }

              else
              {
                *v29 = v31;
              }
            }

            else if (v32 == 1)
            {
              *v29 = v31;
            }

            else
            {
              *v29 = v31;
            }
          }
        }
      }

      return;
    }

    if (!a2)
    {
      return;
    }

    goto LABEL_37;
  }

LABEL_21:
  v26 = ~v19 + a2;
  if (v23 >= 4)
  {
    bzero(a1, (v21 & ~v20) + v22);
    *a1 = v26;
    v27 = 1;
    if (v14 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v27 = (v26 >> (8 * v23)) + 1;
  if (!v23)
  {
LABEL_58:
    if (v14 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v28 = v26 & ~(-1 << (8 * v23));
  bzero(a1, v23);
  if (v23 == 3)
  {
    *a1 = v28;
    a1[2] = BYTE2(v28);
    goto LABEL_58;
  }

  if (v23 == 2)
  {
    *a1 = v28;
    if (v14 > 1)
    {
LABEL_62:
      if (v14 == 2)
      {
        *&a1[v23] = v27;
      }

      else
      {
        *&a1[v23] = v27;
      }

      return;
    }
  }

  else
  {
    *a1 = v26;
    if (v14 > 1)
    {
      goto LABEL_62;
    }
  }

LABEL_59:
  if (v14)
  {
    a1[v23] = v27;
  }
}

uint64_t getEnumTagSinglePayload for FloatingPointClassification(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xF7)
  {
    goto LABEL_17;
  }

  if (a2 + 9 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 9) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 9;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xA;
  v8 = v6 - 10;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for FloatingPointClassification(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 9 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 9) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xF7)
  {
    v4 = 0;
  }

  if (a2 > 0xF6)
  {
    v5 = ((a2 - 247) >> 8) + 1;
    *result = a2 + 9;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 9;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for FloatingPointRoundingRule(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFB)
  {
    goto LABEL_17;
  }

  if (a2 + 5 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 5) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 5;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 6;
  v8 = v6 - 6;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for FloatingPointRoundingRule(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 5 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 5) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xFB)
  {
    v4 = 0;
  }

  if (a2 > 0xFA)
  {
    v5 = ((a2 - 251) >> 8) + 1;
    *result = a2 + 5;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 5;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(_:)(uint64_t a1, uint64_t a2)
{
  return (*(a2 + 64))();
}

{
  return (*(a2 + 72))();
}

uint64_t initializeWithCopy for AnyHashable(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 24);
  *(a1 + 24) = v3;
  (**(v3 - 8))();
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t a2)
{
  if (result != a2)
  {
    v2 = result[3];
    v3 = *(a2 + 24);
    if (v2 == v3)
    {
      v10 = *(v2 - 8);
      if ((*(v10 + 82) & 2) != 0)
      {
        v13 = *result;
        v14 = *a2;
        v15 = result;
        *a2;
        result = v13;
        *v15 = v14;
      }

      else
      {
        v11 = *(v10 + 24);

        return v11();
      }
    }

    else
    {
      result[3] = v3;
      result[4] = *(a2 + 32);
      v4 = *(v2 - 8);
      v5 = *(v3 - 8);
      v6 = v5;
      v7 = *(v5 + 80);
      if ((*(v4 + 82) & 2) != 0)
      {
        v12 = *result;
        if ((v7 & 0x20000) != 0)
        {
          v17 = *a2;
          *result = *a2;
          v17;
        }

        else
        {
          (*(v5 + 16))();
        }

        return v12;
      }

      else
      {
        v9 = result;
        (*(v4 + 32))(v18);
        if ((v7 & 0x20000) != 0)
        {
          v16 = *a2;
          *v9 = *a2;
          v16;
        }

        else
        {
          (*(v6 + 16))(v9, a2, v3);
        }

        return (*(v4 + 8))(v18, v2);
      }
    }
  }

  return result;
}

uint64_t assignWithTake for AnyHashable(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v4;
  *(a1 + 32) = *(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for AnyHashable(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 40))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AnyHashable(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0u;
    *(result + 24) = 0u;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 40) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 24) = (a2 - 1);
      return result;
    }

    *(result + 40) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

__n128 __swift_memcpy72_8(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  result = *(a2 + 16);
  v3 = *(a2 + 32);
  v4 = *(a2 + 48);
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 32) = v3;
  *(a1 + 48) = v4;
  *(a1 + 16) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for Hasher._Core(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 72))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Hasher._Core(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 56) = 0u;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 72) = v3;
  return result;
}

void type metadata accessor for __BridgingBufferStorage(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!*a2)
  {
    swift_getSingletonMetadata(0, a3);
  }
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 != 1 && *(a1 + 16))
  {
    return (*a1 + 2);
  }

  if (*a1)
  {
    v3 = -1;
  }

  else
  {
    v3 = 0;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *result = a2 - 2;
    *(result + 8) = 0;
    if (a3 >= 2)
    {
      *(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 2)
    {
      *(result + 16) = 0;
    }

    if (a2)
    {
      *result = 0;
    }
  }

  return result;
}

uint64_t __swift_memcpy12_8(uint64_t result, uint64_t *a2)
{
  v2 = *a2;
  *(result + 8) = *(a2 + 2);
  *result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _HashTable.Index(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 12))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _HashTable.Index(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 8) = 0;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 12) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset.Iterator(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 != 1 && *(a1 + 32))
  {
    return (*a1 + 2);
  }

  if (*a1)
  {
    v3 = -1;
  }

  else
  {
    v3 = 0;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset.Iterator(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 - 2;
    *(result + 8) = 0;
    if (a3 >= 2)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if (a3 >= 2)
    {
      *(result + 32) = 0;
    }

    if (a2)
    {
      *result = 0;
    }
  }

  return result;
}

unint64_t type metadata completion function for DefaultIndices(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v8 = *(v2 - 8) + 64;
    swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    v3 = v5;
    if (v6 <= 0x3F)
    {
      v9 = *(v5 - 8) + 64;
      v10 = v9;
      swift_initStructMetadata(a1, 0, 3uLL, &v8, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DefaultIndices(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 80);
  v11 = v7 + v10;
  v12 = (v7 + v10) & ~v10;
  v13 = *(v9 + 64);
  v14 = v13 + v10;
  v15 = ((v13 + v10 + v12) & ~v10) + v13;
  v16 = (*(v6 + 80) | *(v9 + 80));
  if (v16 > 7 || ((*(v6 + 80) | *(v9 + 80)) & 0x100000) != 0 || v15 > 0x18)
  {
    v19 = *a2;
    *a1 = *a2;
    a1 = (v19 + ((v16 + 16) & ~v16));
    v19;
  }

  else
  {
    v20 = v8;
    v21 = ~v10;
    (*(v6 + 16))(a1, a2, v5);
    v22 = (a2 + v11) & v21;
    v23 = *(v9 + 16);
    v23((a1 + v11) & v21, v22, v20);
    v23((v14 + ((a1 + v11) & v21)) & v21, (v14 + v22) & v21, v20);
  }

  return a1;
}

uint64_t destroy for DefaultIndices(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v5 = *(v4 - 8) + 8;
  (*v5)(a1, v4);
  v6 = *(v5 + 56) + a1;
  swift_getAssociatedTypeWitness(0, *(a2 + 24), v4, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = v7;
  v9 = *(v7 - 8);
  v14 = v9 + 8;
  v15 = *(v9 + 8);
  v10 = *(v9 + 80);
  v11 = (v6 + v10) & ~v10;
  v15(v11, v7);
  v12 = (*(v14 + 56) + v10 + v11) & ~v10;

  return (v15)(v12, v8);
}

uint64_t initializeWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 16;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 48);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 16);
  v13 = v11 + 16;
  v14 = *(v11 + 80);
  v15 = (v8 + v14 + a2) & ~v14;
  v12((v8 + v14 + a1) & ~v14, v15, v9);
  v12((*(v13 + 48) + v14 + ((v8 + v14 + a1) & ~v14)) & ~v14, (*(v13 + 48) + v14 + v15) & ~v14, v10);
  return a1;
}

uint64_t assignWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 24;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 40);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 24);
  v13 = v11 + 24;
  v14 = *(v11 + 80);
  v15 = (v8 + v14 + a2) & ~v14;
  v12((v8 + v14 + a1) & ~v14, v15, v9);
  v12((*(v13 + 40) + v14 + ((v8 + v14 + a1) & ~v14)) & ~v14, (*(v13 + 40) + v14 + v15) & ~v14, v10);
  return a1;
}

uint64_t initializeWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 32;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 32);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 32);
  v13 = v11 + 32;
  v14 = *(v11 + 80);
  v15 = (v8 + v14 + a2) & ~v14;
  v12((v8 + v14 + a1) & ~v14, v15, v9);
  v12((*(v13 + 32) + v14 + ((v8 + v14 + a1) & ~v14)) & ~v14, (*(v13 + 32) + v14 + v15) & ~v14, v10);
  return a1;
}

uint64_t assignWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 40;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 24);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 40);
  v13 = v11 + 40;
  v14 = *(v11 + 80);
  v15 = (v8 + v14 + a2) & ~v14;
  v12((v8 + v14 + a1) & ~v14, v15, v9);
  v12((*(v13 + 24) + v14 + ((v8 + v14 + a1) & ~v14)) & ~v14, (*(v13 + 24) + v14 + v15) & ~v14, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for DefaultIndices(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v9 + 80);
  if (v10 <= v7)
  {
    v12 = v7;
  }

  else
  {
    v12 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v13 = *(v6 + 64) + v11;
  if (a2 <= v12)
  {
    goto LABEL_28;
  }

  v14 = ((*(*(v8 - 8) + 64) + v11 + (v13 & ~v11)) & ~v11) + *(*(v8 - 8) + 64);
  v15 = 8 * v14;
  if (v14 <= 3)
  {
    v17 = ((a2 - v12 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      v16 = *(a1 + v14);
      if (!v16)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      v16 = *(a1 + v14);
      if (!*(a1 + v14))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_27:
      if (v12)
      {
LABEL_28:
        if (v7 >= v10)
        {
          v23 = *(v6 + 48);

          return v23(a1, v7, v5);
        }

        else
        {
          v21 = *(v9 + 48);

          return v21((a1 + v13) & ~v11);
        }
      }

      return 0;
    }
  }

  v16 = *(a1 + v14);
  if (!*(a1 + v14))
  {
    goto LABEL_27;
  }

LABEL_14:
  v18 = (v16 - 1) << v15;
  if (v14 > 3)
  {
    v18 = 0;
  }

  if (v14)
  {
    if (v14 <= 3)
    {
      v19 = v14;
    }

    else
    {
      v19 = 4;
    }

    if (v19 > 2)
    {
      if (v19 == 3)
      {
        v20 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v20 = *a1;
      }
    }

    else if (v19 == 1)
    {
      v20 = *a1;
    }

    else
    {
      v20 = *a1;
    }
  }

  else
  {
    v20 = 0;
  }

  return v12 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for DefaultIndices(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v25 = v8;
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v11 = *(v10 - 8);
  v12 = *(v11 + 84);
  if (v12 <= v9)
  {
    v13 = v9;
  }

  else
  {
    v13 = *(v11 + 84);
  }

  v14 = *(v11 + 80);
  v15 = *(v8 + 64) + v14;
  v16 = ((*(*(v10 - 8) + 64) + v14 + (v15 & ~v14)) & ~v14) + *(*(v10 - 8) + 64);
  if (a3 <= v13)
  {
    v17 = 0;
  }

  else if (v16 <= 3)
  {
    v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      v17 = 4;
    }

    else
    {
      if (v20 < 0x100)
      {
        v21 = 1;
      }

      else
      {
        v21 = 2;
      }

      if (v20 >= 2)
      {
        v17 = v21;
      }

      else
      {
        v17 = 0;
      }
    }
  }

  else
  {
    v17 = 1;
  }

  if (v13 < a2)
  {
    v18 = ~v13 + a2;
    if (v16 < 4)
    {
      v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        v22 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 != 3)
        {
          if (v16 == 2)
          {
            *a1 = v22;
            if (v17 > 1)
            {
LABEL_46:
              if (v17 == 2)
              {
                *&a1[v16] = v19;
              }

              else
              {
                *&a1[v16] = v19;
              }

              return;
            }
          }

          else
          {
            *a1 = v18;
            if (v17 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v22;
        a1[2] = BYTE2(v22);
      }

      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v16);
      *a1 = v18;
      v19 = 1;
      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v17)
    {
      a1[v16] = v19;
    }

    return;
  }

  if (v17 > 1)
  {
    if (v17 != 2)
    {
      *&a1[v16] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v16] = 0;
  }

  else if (v17)
  {
    a1[v16] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v9 >= v12)
  {
    v24 = *(v25 + 56);

    v24(a1, a2, v9, v7);
  }

  else
  {
    v23 = *(v11 + 56);

    v23(&a1[v15] & ~v14, a2);
  }
}

void *type metadata completion function for InlineArray(uint64_t a1)
{
  result = swift_getFixedArrayTypeMetadata(319, *(a1 + 16), *(a1 + 24));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 32);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for InlineArray(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v5 = *(a3 + 24);
  v6 = *(v5 - 8);
  v7 = *(v6 + 72);
  v8 = *(a3 + 16);
  v9 = v8 & ~(v8 >> 63);
  v10 = *(v6 + 80);
  if (v10 > 7 || (*(v6 + 80) & 0x100000) != 0 || (v9 * v7) >= 0x19)
  {
    v13 = *a2;
    *a1 = *a2;
    a1 = (v13 + ((v10 + 16) & ~v10));
    v13;
  }

  else if (v8 >= 1)
  {
    v14 = 0;
    v15 = *(v6 + 16);
    do
    {
      v15(a1 + v14, a2 + v14, v5);
      v14 += v7;
      --v9;
    }

    while (v9);
  }

  return a1;
}

uint64_t destroy for InlineArray(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 16);
  if (v2 >= 1)
  {
    v3 = result;
    v4 = *(a2 + 24);
    v5 = *(v4 - 8);
    v6 = *(v5 + 8);
    do
    {
      result = v6(v3, v4);
      v3 += *(v5 + 72);
      --v2;
    }

    while (v2);
  }

  return result;
}

uint64_t initializeWithCopy for InlineArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  if (v4 >= 1)
  {
    v6 = *(a3 + 24);
    v7 = *(v6 - 8);
    v8 = *(v7 + 16);
    v9 = a1;
    do
    {
      v8(v9, a2, v6);
      v10 = *(v7 + 72);
      v9 += v10;
      a2 += v10;
      --v4;
    }

    while (v4);
  }

  return a1;
}

uint64_t assignWithCopy for InlineArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  if (v4 >= 1)
  {
    v6 = *(a3 + 24);
    v7 = *(v6 - 8);
    v8 = *(v7 + 24);
    v9 = a1;
    do
    {
      v8(v9, a2, v6);
      v10 = *(v7 + 72);
      v9 += v10;
      a2 += v10;
      --v4;
    }

    while (v4);
  }

  return a1;
}

uint64_t initializeWithTake for InlineArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  if (v4 >= 1)
  {
    v6 = *(a3 + 24);
    v7 = *(v6 - 8);
    v8 = *(v7 + 32);
    v9 = a1;
    do
    {
      v8(v9, a2, v6);
      v10 = *(v7 + 72);
      v9 += v10;
      a2 += v10;
      --v4;
    }

    while (v4);
  }

  return a1;
}

uint64_t assignWithTake for InlineArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  if (v4 >= 1)
  {
    v6 = *(a3 + 24);
    v7 = *(v6 - 8);
    v8 = *(v7 + 40);
    v9 = a1;
    do
    {
      v8(v9, a2, v6);
      v10 = *(v7 + 72);
      v9 += v10;
      a2 += v10;
      --v4;
    }

    while (v4);
  }

  return a1;
}

uint64_t dispatch thunk of BinaryInteger.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(a5 + 80))();
}

{
  return (*(a5 + 88))();
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DiscontiguousSlice(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 64);
  v6 = *(v4 + 80);
  if ((v6 & 0x1000F8) != 0 || ((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    v10 = *a2;
    *v3 = *a2;
    v3 = (v10 + (((v6 & 0xF8) + 23) & ~(v6 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(v4 + 16))(a1);
    v9 = ((a2 + v5 + 7) & 0xFFFFFFFFFFFFFFF8);
    v10 = *v9;
    *((v3 + v5 + 7) & 0xFFFFFFFFFFFFFFF8) = *v9;
  }

  v10;
  return v3;
}

uint64_t destroy for DiscontiguousSlice(uint64_t a1, uint64_t a2)
{
  v3 = *(*(a2 + 16) - 8) + 8;
  (*v3)();
  v4 = *((a1 + *(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8);

  return v4;
}

uint64_t initializeWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 16;
  (*v5)();
  v6 = *(v5 + 48) + 7;
  v7 = ((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  v8 = ((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9 = *v8;
  *v7 = *v8;
  v9;
  return a1;
}

uint64_t assignWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 24;
  (*v5)();
  v6 = *(v5 + 40) + 7;
  v7 = ((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  v8 = ((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9 = *v8;
  v10 = *v7;
  *v7 = *v8;
  v9;
  v10;
  return a1;
}

uint64_t assignWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 40;
  (*v5)();
  v6 = *(v5 + 24) + 7;
  v7 = ((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  v8 = *v7;
  *v7 = *((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v8;
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = *(v4 + 64);
  if (v5 <= 0x7FFFFFFF)
  {
    v7 = 0x7FFFFFFF;
  }

  else
  {
    v7 = *(v4 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  if (v7 >= a2)
  {
    goto LABEL_28;
  }

  v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  v9 = a2 - v7;
  v10 = v8 & 0xFFFFFFF8;
  if ((v8 & 0xFFFFFFF8) != 0)
  {
    v11 = 2;
  }

  else
  {
    v11 = v9 + 1;
  }

  if (v11 >= 0x10000)
  {
    v12 = 4;
  }

  else
  {
    v12 = 2;
  }

  if (v11 < 0x100)
  {
    v12 = 1;
  }

  if (v11 >= 2)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0;
  }

  if (v13 > 1)
  {
    if (v13 == 2)
    {
      v14 = *(a1 + v8);
      if (!v14)
      {
        goto LABEL_28;
      }
    }

    else
    {
      v14 = *(a1 + v8);
      if (!v14)
      {
        goto LABEL_28;
      }
    }
  }

  else if (!v13 || (v14 = *(a1 + v8)) == 0)
  {
LABEL_28:
    if (v5 >= 0x7FFFFFFF)
    {
      return (*(v4 + 48))();
    }

    v17 = *((a1 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (v17 >= 0xFFFFFFFF)
    {
      LODWORD(v17) = -1;
    }

    return (v17 + 1);
  }

  v16 = v14 - 1;
  if (v10)
  {
    v16 = 0;
    LODWORD(v10) = *a1;
  }

  return v7 + (v10 | v16) + 1;
}

_DWORD *storeEnumTagSinglePayload for DiscontiguousSlice(_DWORD *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  if (v6 <= 0x7FFFFFFF)
  {
    v7 = 0x7FFFFFFF;
  }

  else
  {
    v7 = *(v5 + 84);
  }

  v8 = *(*(*(a4 + 16) - 8) + 64);
  v9 = ((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (((v8 + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
  {
    v10 = a3 - v7 + 1;
  }

  else
  {
    v10 = 2;
  }

  if (v10 >= 0x10000)
  {
    v11 = 4;
  }

  else
  {
    v11 = 2;
  }

  if (v10 < 0x100)
  {
    v11 = 1;
  }

  if (v10 >= 2)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  if (v7 < a3)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0;
  }

  if (a2 > v7)
  {
    if (((v8 + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      v14 = a2 - v7;
    }

    else
    {
      v14 = 1;
    }

    if (((v8 + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
    {
      v15 = ~v7 + a2;
      v16 = result;
      bzero(result, ((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 8);
      result = v16;
      *v16 = v15;
    }

    if (v13 > 1)
    {
      if (v13 == 2)
      {
        *(result + v9) = v14;
      }

      else
      {
        *(result + v9) = v14;
      }
    }

    else if (v13)
    {
      *(result + v9) = v14;
    }

    return result;
  }

  if (v13 > 1)
  {
    if (v13 != 2)
    {
      *(result + v9) = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_36;
    }

    *(result + v9) = 0;
  }

  else if (v13)
  {
    *(result + v9) = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_36;
  }

  if (!a2)
  {
    return result;
  }

LABEL_36:
  if (v6 < 0x7FFFFFFF)
  {
    v18 = ((result + v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((a2 & 0x80000000) != 0)
    {
      v19 = a2 & 0x7FFFFFFF;
    }

    else
    {
      v19 = a2 - 1;
    }

    *v18 = v19;
  }

  else
  {
    v17 = *(v5 + 56);

    return v17();
  }

  return result;
}

void type metadata completion function for JoinedSequence.Iterator(void *a1)
{
  v3 = a1[2];
  v2 = a1[3];
  swift_getAssociatedTypeWitness(319, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v13[0] = *(v4 - 8) + 64;
    v6 = a1[4];
    swift_getAssociatedTypeWitness(255, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    v11 = type metadata accessor for Optional(319, v8, v9, v10);
    if (v12 <= 0x3F)
    {
      v13[1] = *(v11 - 8) + 64;
      v13[2] = &unk_1EEEAAE60;
      v13[3] = &unk_180727168;
      v13[4] = &unk_180727180;
      swift_initStructMetadata(a1, 0, 5uLL, v13, (a1 + 5));
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for JoinedSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 64);
  v12 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = *(v14 - 8);
  v16 = *(v15 + 80);
  v17 = v11 + v16;
  if (*(v15 + 84))
  {
    v18 = *(v15 + 64);
  }

  else
  {
    v18 = *(v15 + 64) + 1;
  }

  v19 = v16 | *(v10 + 80) & 0xF8;
  if (v19 > 7 || ((*(v10 + 80) | *(v15 + 80)) & 0x100000) != 0 || ((((v18 + ((v11 + v16) & ~v16) + 7) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17 > 0x18)
  {
    v22 = *a2;
    *a1 = v22;
    a1 = (v22 + (((v19 | 7) + 16) & ~(v19 | 7)));
  }

  else
  {
    v23 = v14;
    v24 = ~v16;
    (*(v10 + 16))(a1, a2, v9);
    v25 = ((a2 + v17) & v24);
    if ((*(v15 + 48))(v25, 1, v23))
    {
      memcpy(((a1 + v17) & v24), v25, v18);
    }

    else
    {
      (*(v15 + 16))((a1 + v17) & v24, v25, v23);
      (*(v15 + 56))((a1 + v17) & v24, 0, 1, v23);
    }

    v26 = ((((a1 + v17) & v24) + v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v27 = ((v25 + v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v28 = *v27;
    *v26 = *v27;
    v29 = (v26 + 15) & 0xFFFFFFFFFFFFFFF8;
    v30 = (v27 + 15) & 0xFFFFFFFFFFFFFFF8;
    v22 = *v30;
    *v29 = *v30;
    *(v29 + 8) = *(v30 + 8);
    *(v29 + 16) = *(v30 + 16);
    v28;
  }

  v22;
  return a1;
}

uint64_t destroy for JoinedSequence.Iterator(uint64_t a1, void *a2)
{
  v5 = a2[2];
  v4 = a2[3];
  swift_getAssociatedTypeWitness(0, v4, v5, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 8;
  (*v7)(a1, v6);
  v8 = *(v7 + 56);
  v9 = a2[4];
  swift_getAssociatedTypeWitness(255, v4, v5, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v9, v10, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v12 = v11;
  v13 = *(v11 - 8);
  v14 = (v8 + a1 + *(v13 + 80)) & ~*(v13 + 80);
  if (!(*(v13 + 48))(v14, 1, v11))
  {
    (*(v13 + 8))(v14, v12);
  }

  v15 = v14 + *(v13 + 64);
  if (!*(v13 + 84))
  {
    ++v15;
  }

  v16 = v15 + 7;
  v17 = (v16 & 0xFFFFFFFFFFFFFFF8) + 15;
  *(v16 & 0xFFFFFFFFFFFFFFF8);
  v18 = *(v17 & 0xFFFFFFFFFFFFFFF8);

  return v18;
}

uint64_t initializeWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 16;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 48);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = ((v10 + v16 + a1) & ~v16);
  v18 = ((v10 + v16 + a2) & ~v16);
  if ((*(v15 + 48))(v18, 1, v13))
  {
    v19 = *(v15 + 84);
    v20 = *(v15 + 64);
    if (v19)
    {
      v21 = v20;
    }

    else
    {
      v21 = v20 + 1;
    }

    memcpy(v17, v18, v21);
  }

  else
  {
    (*(v15 + 16))(v17, v18, v14);
    v23 = *(v15 + 56);
    v22 = v15 + 56;
    v23(v17, 0, 1, v14);
    v19 = *(v22 + 28);
    v20 = *(v22 + 8);
  }

  if (v19)
  {
    v24 = v20;
  }

  else
  {
    v24 = v20 + 1;
  }

  v25 = ((v17 + v24 + 7) & 0xFFFFFFFFFFFFFFF8);
  v26 = ((v18 + v24 + 7) & 0xFFFFFFFFFFFFFFF8);
  v27 = *v26;
  *v25 = *v26;
  v28 = (v25 + 15) & 0xFFFFFFFFFFFFFFF8;
  v29 = (v26 + 15) & 0xFFFFFFFFFFFFFFF8;
  v30 = *v29;
  *v28 = *v29;
  *(v28 + 8) = *(v29 + 8);
  *(v28 + 16) = *(v29 + 16);
  v27;
  v30;
  return a1;
}

uint64_t assignWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 24;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 40);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = ((v10 + v16 + a1) & ~v16);
  v18 = ((v10 + v16 + a2) & ~v16);
  v19 = *(v15 + 48);
  v20 = v19(v17, 1, v13);
  v21 = v19(v18, 1, v14);
  if (v20)
  {
    if (!v21)
    {
      (*(v15 + 16))(v17, v18, v14);
      (*(v15 + 56))(v17, 0, 1, v14);
      goto LABEL_12;
    }

    v22 = *(v15 + 84);
    v23 = *(v15 + 64);
  }

  else
  {
    if (!v21)
    {
      (*(v15 + 24))(v17, v18, v14);
      goto LABEL_12;
    }

    (*(v15 + 8))(v17, v14);
    v22 = *(v15 + 84);
    v23 = *(v15 + 64);
  }

  if (v22)
  {
    v24 = v23;
  }

  else
  {
    v24 = v23 + 1;
  }

  memcpy(v17, v18, v24);
LABEL_12:
  if (*(v15 + 84))
  {
    v25 = *(v15 + 64);
  }

  else
  {
    v25 = *(v15 + 64) + 1;
  }

  v26 = v17 + v25 + 7;
  v27 = v18 + v25 + 7;
  v29 = (v27 & 0xFFFFFFFFFFFFFFF8) + 15;
  v28 = *(v27 & 0xFFFFFFFFFFFFFFF8);
  v30 = *(v26 & 0xFFFFFFFFFFFFFFF8);
  *(v26 & 0xFFFFFFFFFFFFFFF8) = v28;
  v31 = (v26 & 0xFFFFFFFFFFFFFFF8) + 15;
  v28;
  v30;
  v31 &= 0xFFFFFFFFFFFFFFF8;
  v29 &= 0xFFFFFFFFFFFFFFF8;
  v32 = *v29;
  v33 = *v31;
  *v31 = *v29;
  v32;
  v33;
  *(v31 + 8) = *(v29 + 8);
  *(v31 + 16) = *(v29 + 16);
  return a1;
}

uint64_t initializeWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 32;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 32);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = ((v10 + v16 + a1) & ~v16);
  v18 = ((v10 + v16 + a2) & ~v16);
  if ((*(v15 + 48))(v18, 1, v13))
  {
    v19 = *(v15 + 84);
    v20 = *(v15 + 64);
    if (v19)
    {
      v21 = v20;
    }

    else
    {
      v21 = v20 + 1;
    }

    memcpy(v17, v18, v21);
  }

  else
  {
    (*(v15 + 32))(v17, v18, v14);
    v23 = *(v15 + 56);
    v22 = v15 + 56;
    v23(v17, 0, 1, v14);
    v19 = *(v22 + 28);
    v20 = *(v22 + 8);
  }

  if (v19)
  {
    v24 = v20;
  }

  else
  {
    v24 = v20 + 1;
  }

  v25 = ((v17 + v24 + 7) & 0xFFFFFFFFFFFFFFF8);
  v26 = ((v18 + v24 + 7) & 0xFFFFFFFFFFFFFFF8);
  *v25 = *v26;
  v27 = (v25 + 15) & 0xFFFFFFFFFFFFFFF8;
  v28 = (v26 + 15) & 0xFFFFFFFFFFFFFFF8;
  *v27 = *v28;
  *(v27 + 16) = *(v28 + 16);
  return a1;
}

uint64_t assignWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8) + 40;
  (*v9)(a1, a2, v8);
  v10 = *(v9 + 24);
  v11 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v11, v12, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = v13;
  v15 = *(v13 - 8);
  v16 = *(v15 + 80);
  v17 = ((v10 + v16 + a1) & ~v16);
  v18 = ((v10 + v16 + a2) & ~v16);
  v19 = *(v15 + 48);
  v20 = v19(v17, 1, v13);
  v21 = v19(v18, 1, v14);
  if (v20)
  {
    if (!v21)
    {
      (*(v15 + 32))(v17, v18, v14);
      (*(v15 + 56))(v17, 0, 1, v14);
      goto LABEL_12;
    }

    v22 = *(v15 + 84);
    v23 = *(v15 + 64);
  }

  else
  {
    if (!v21)
    {
      (*(v15 + 40))(v17, v18, v14);
      goto LABEL_12;
    }

    (*(v15 + 8))(v17, v14);
    v22 = *(v15 + 84);
    v23 = *(v15 + 64);
  }

  if (v22)
  {
    v24 = v23;
  }

  else
  {
    v24 = v23 + 1;
  }

  memcpy(v17, v18, v24);
LABEL_12:
  if (*(v15 + 84))
  {
    v25 = *(v15 + 64);
  }

  else
  {
    v25 = *(v15 + 64) + 1;
  }

  v26 = v17 + v25 + 7;
  v27 = ((v18 + v25 + 7) & 0xFFFFFFFFFFFFFFF8);
  v28 = *(v26 & 0xFFFFFFFFFFFFFFF8);
  *(v26 & 0xFFFFFFFFFFFFFFF8) = *v27;
  v29 = (v26 & 0xFFFFFFFFFFFFFFF8) + 15;
  v28;
  v29 &= 0xFFFFFFFFFFFFFFF8;
  v30 = (v27 + 15) & 0xFFFFFFFFFFFFFFF8;
  v31 = *v29;
  *v29 = *v30;
  v31;
  *(v29 + 8) = *(v30 + 8);
  *(v29 + 16) = *(v30 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  v7 = a3[2];
  v6 = a3[3];
  swift_getAssociatedTypeWitness(0, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 84);
  v12 = a3[4];
  swift_getAssociatedTypeWitness(255, v6, v7, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v12, v13, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = *(v14 - 8);
  v16 = v15;
  v17 = *(v15 + 84);
  if (v17)
  {
    v18 = v17 - 1;
  }

  else
  {
    v18 = 0;
  }

  if (v18 <= v11)
  {
    v19 = v11;
  }

  else
  {
    v19 = v18;
  }

  if (v19 <= 0x7FFFFFFF)
  {
    v19 = 0x7FFFFFFF;
  }

  v20 = *(v15 + 80);
  v21 = *(*(v14 - 8) + 64);
  if (!v17)
  {
    ++v21;
  }

  if (!a2)
  {
    return 0;
  }

  v22 = *(v10 + 64) + v20;
  v23 = v21 + 7;
  if (v19 < a2)
  {
    v24 = ((((v23 + (v22 & ~v20)) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17;
    if (v24 <= 3)
    {
      v25 = ((a2 - v19 + 255) >> 8) + 1;
    }

    else
    {
      v25 = 2;
    }

    if (v25 >= 0x10000)
    {
      v26 = 4;
    }

    else
    {
      v26 = 2;
    }

    if (v25 < 0x100)
    {
      v26 = 1;
    }

    if (v25 >= 2)
    {
      v27 = v26;
    }

    else
    {
      v27 = 0;
    }

    if (v27 > 1)
    {
      if (v27 == 2)
      {
        v28 = *&a1[v24];
        if (*&a1[v24])
        {
          goto LABEL_27;
        }
      }

      else
      {
        v28 = *&a1[v24];
        if (v28)
        {
          goto LABEL_27;
        }
      }
    }

    else if (v27)
    {
      v28 = a1[v24];
      if (a1[v24])
      {
LABEL_27:
        v29 = (v28 - 1) << (8 * v24);
        if (v24 <= 3)
        {
          v30 = *a1;
        }

        else
        {
          v29 = 0;
          v30 = *a1;
        }

        return v19 + (v30 | v29) + 1;
      }
    }
  }

  if (v11 == v19)
  {
    v31 = *(v10 + 48);

    return v31(a1, v11, v9);
  }

  v33 = &a1[v22] & ~v20;
  if (v18 == v19)
  {
    if (v17 >= 2)
    {
      v35 = (*(v16 + 48))(v33);
      if (v35 >= 2)
      {
        return v35 - 1;
      }

      else
      {
        return 0;
      }
    }

    return 0;
  }

  v34 = *((v23 + v33) & 0xFFFFFFFFFFFFFFF8);
  if (v34 >= 0xFFFFFFFF)
  {
    LODWORD(v34) = -1;
  }

  return (v34 + 1);
}

void storeEnumTagSinglePayload for JoinedSequence.Iterator(_BYTE *a1, uint64_t a2, unsigned int a3, void *a4)
{
  v9 = a4[2];
  v8 = a4[3];
  swift_getAssociatedTypeWitness(0, v8, v9, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v11 = *(v10 - 8);
  v36 = v10;
  v12 = *(v11 + 84);
  v13 = a4[4];
  swift_getAssociatedTypeWitness(255, v8, v9, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  swift_getAssociatedTypeWitness(0, v13, v14, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v15 = 0;
  v17 = *(v16 - 8);
  v18 = *(v17 + 84);
  v19 = *(v11 + 64);
  v20 = v18 - 1;
  if (!v18)
  {
    v20 = 0;
  }

  v21 = *(v17 + 80);
  if (v20 <= v12)
  {
    v22 = v12;
  }

  else
  {
    v22 = v20;
  }

  if (v22 <= 0x7FFFFFFF)
  {
    v22 = 0x7FFFFFFF;
  }

  v23 = v19 + v21;
  v24 = (v19 + v21) & ~v21;
  if (v18)
  {
    v25 = *(v17 + 64);
  }

  else
  {
    v25 = *(v17 + 64) + 1;
  }

  v26 = v25 + 7;
  v27 = ((((v26 + v24) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17;
  if (v22 < a3)
  {
    if (v27 <= 3)
    {
      v28 = ((a3 - v22 + 255) >> 8) + 1;
    }

    else
    {
      v28 = 2;
    }

    if (v28 >= 0x10000)
    {
      v29 = 4;
    }

    else
    {
      v29 = 2;
    }

    if (v28 < 0x100)
    {
      v29 = 1;
    }

    if (v28 >= 2)
    {
      v15 = v29;
    }

    else
    {
      v15 = 0;
    }
  }

  if (v22 >= a2)
  {
    if (v15 > 1)
    {
      if (v15 != 2)
      {
        *&a1[v27] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_41;
      }

      *&a1[v27] = 0;
    }

    else if (v15)
    {
      a1[v27] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_41;
    }

    if (!a2)
    {
      return;
    }

LABEL_41:
    if (v12 == v22)
    {
      v32 = *(v11 + 56);

      v32(a1, a2, v12, v36);
    }

    else
    {
      v33 = &a1[v23] & ~v21;
      if (v20 == v22)
      {
        v34 = *(v17 + 56);

        v34(v33, (a2 + 1));
      }

      else
      {
        if ((a2 & 0x80000000) != 0)
        {
          v35 = a2 & 0x7FFFFFFF;
        }

        else
        {
          v35 = (a2 - 1);
        }

        *((v26 + v33) & 0xFFFFFFFFFFFFFFF8) = v35;
      }
    }

    return;
  }

  v30 = ~v22 + a2;
  bzero(a1, v27);
  if (v27 <= 3)
  {
    v31 = (v30 >> 8) + 1;
  }

  else
  {
    v31 = 1;
  }

  if (v27 <= 3)
  {
    *a1 = v30;
    if (v15 > 1)
    {
LABEL_29:
      if (v15 == 2)
      {
        *&a1[v27] = v31;
      }

      else
      {
        *&a1[v27] = v31;
      }

      return;
    }
  }

  else
  {
    *a1 = v30;
    if (v15 > 1)
    {
      goto LABEL_29;
    }
  }

  if (v15)
  {
    a1[v27] = v31;
  }
}

swift *type metadata completion function for ClassHolder(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &value witness table for Builtin.UnknownObject.size;
  return swift_initClassMetadata2(a1, 0, 2, v2, a1 + 88);
}

uint64_t type metadata completion function for MutatingWritebackBuffer(uint64_t a1)
{
  v4[0] = "\b";
  v4[1] = &unk_1EEEAAF10;
  v4[2] = &unk_1EEEAAF10;
  v4[3] = &unk_1EEEAAF10;
  v4[4] = &value witness table for Builtin.Int64.size;
  result = swift_checkMetadataState(319, *(a1 + 88));
  if (v3 <= 0x3F)
  {
    v4[5] = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 6, v4, a1 + 96);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for NonmutatingWritebackBuffer(uint64_t a1)
{
  v5[0] = "\b";
  result = swift_checkMetadataState(319, *(a1 + 80));
  if (v3 <= 0x3F)
  {
    v5[1] = *(result - 8) + 64;
    v5[2] = &unk_1EEEAAF10;
    v5[3] = &unk_1EEEAAF10;
    v5[4] = &value witness table for Builtin.Int64.size;
    result = swift_checkMetadataState(319, *(a1 + 88));
    if (v4 <= 0x3F)
    {
      v5[5] = *(result - 8) + 64;
      result = swift_initClassMetadata2(a1, 0, 6, v5, a1 + 96);
      if (!result)
      {
        return 0;
      }
    }
  }

  return result;
}

uint64_t default associated conformance accessor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection(uint64_t a1, const char *a2, int ***a3)
{
  swift_getAssociatedTypeWitness(255, a3[2], a2, &protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);

  return swift_getAssociatedConformanceWitness(a3, a2, v5, &protocol requirements base descriptor for LazyCollectionProtocol, associated conformance descriptor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection);
}

uint64_t default associated conformance accessor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence(uint64_t a1, const char *a2, int **a3)
{
  swift_getAssociatedTypeWitness(255, a3, a2, &protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);

  return swift_getAssociatedConformanceWitness(a3, a2, v5, &protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
}

uint64_t type metadata completion function for _IndexBox(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 80));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    result = swift_initClassMetadata2(a1, 0, 1, &v4, a1 + 96);
    if (!result)
    {
      return 0;
    }
  }

  return result;
}

uint64_t type metadata completion function for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 8) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, v8, a1 + 40);
    return 0;
  }

  return result;
}

void type metadata completion function for LazyMapSequence.Iterator(uint64_t a1)
{
  swift_getAssociatedTypeWitness(319, *(a1 + 32), *(a1 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[0] = *(v2 - 8) + 64;
    v4[1] = &unk_1EEEAC098;
    swift_initStructMetadata(a1, 0, 2uLL, v4, a1 + 40);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyMapSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  v8 = *(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    v11 = *a2;
    *a1 = *a2;
    a1 = (v11 + (((v8 & 0xF8) + 23) & ~(v8 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(v6 + 16))(a1, a2, v5);
    v10 = ((a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    v11 = v10[1];
    v12 = ((a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    *v12 = *v10;
    v12[1] = v11;
  }

  v11;
  return a1;
}

uint64_t destroy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 32), *(a2 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v4 = *(v3 - 8) + 8;
  (*v4)(a1, v3);
  v5 = *(((a1 + *(v4 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return v5;
}

uint64_t initializeWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 16;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 48) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = v9[1];
  *v8 = *v9;
  v8[1] = v10;
  v10;
  return a1;
}

uint64_t assignWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 24;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 40) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = v9[1];
  v11 = v8[1];
  *v8 = *v9;
  v8[1] = v10;
  v10;
  v11;
  return a1;
}

uint64_t initializeWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 32;
  (*v6)(a1, a2, v5);
  *((*(v6 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v6 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 40;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 24) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(v8 + 8);
  *v8 = *((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9;
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyMapSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(*(v5 - 8) + 64);
  if (!a2)
  {
    return 0;
  }

  if (v8 >= a2)
  {
    goto LABEL_28;
  }

  v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  v11 = v10 & 0xFFFFFFF8;
  if ((v10 & 0xFFFFFFF8) != 0)
  {
    v12 = 2;
  }

  else
  {
    v12 = a2 - v8 + 1;
  }

  if (v12 >= 0x10000)
  {
    v13 = 4;
  }

  else
  {
    v13 = 2;
  }

  if (v12 < 0x100)
  {
    v13 = 1;
  }

  if (v12 >= 2)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  if (v14 > 1)
  {
    if (v14 == 2)
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_28;
      }
    }

    else
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_28;
      }
    }
  }

  else if (!v14 || (v15 = *(a1 + v10)) == 0)
  {
LABEL_28:
    if (v7 < 0x7FFFFFFF)
    {
      v19 = *((a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
      if (v19 >= 0xFFFFFFFF)
      {
        LODWORD(v19) = -1;
      }

      return (v19 + 1);
    }

    else
    {
      v18 = *(v6 + 48);

      return v18(a1);
    }
  }

  v17 = v15 - 1;
  if (v11)
  {
    v17 = 0;
    LODWORD(v11) = *a1;
  }

  return v8 + (v11 | v17) + 1;
}

void storeEnumTagSinglePayload for LazyMapSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 32), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 64);
  if (v9 <= 0x7FFFFFFF)
  {
    v11 = 0x7FFFFFFF;
  }

  else
  {
    v11 = *(v8 + 84);
  }

  v12 = ((v10 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v10 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
  {
    v13 = a3 - v11 + 1;
  }

  else
  {
    v13 = 2;
  }

  if (v13 >= 0x10000)
  {
    v14 = 4;
  }

  else
  {
    v14 = 2;
  }

  if (v13 < 0x100)
  {
    v14 = 1;
  }

  if (v13 >= 2)
  {
    v15 = v14;
  }

  else
  {
    v15 = 0;
  }

  if (v11 < a3)
  {
    v16 = v15;
  }

  else
  {
    v16 = 0;
  }

  if (a2 > v11)
  {
    if (((v10 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
    {
      v17 = a2 - v11;
    }

    else
    {
      v17 = 1;
    }

    if (((v10 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      v18 = ~v11 + a2;
      bzero(a1, v12);
      *a1 = v18;
    }

    if (v16 > 1)
    {
      if (v16 == 2)
      {
        *(a1 + v12) = v17;
      }

      else
      {
        *(a1 + v12) = v17;
      }
    }

    else if (v16)
    {
      *(a1 + v12) = v17;
    }

    return;
  }

  if (v16 > 1)
  {
    if (v16 != 2)
    {
      *(a1 + v12) = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_36;
    }

    *(a1 + v12) = 0;
  }

  else if (v16)
  {
    *(a1 + v12) = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_36;
  }

  if (!a2)
  {
    return;
  }

LABEL_36:
  if (v9 < 0x7FFFFFFF)
  {
    v20 = ((a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((a2 & 0x80000000) != 0)
    {
      *v20 = a2 & 0x7FFFFFFF;
      v20[1] = 0;
    }

    else
    {
      *v20 = (a2 - 1);
    }
  }

  else
  {
    v19 = *(v8 + 56);

    v19(a1, a2);
  }
}

uint64_t dispatch thunk of MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 24))();
}

{
  return (*(a4 + 40))();
}

uint64_t dispatch thunk of MutableCollection.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 32))();
}

{
  return (*(a4 + 48))();
}

uint64_t initializeWithCopy for _NativeSet.Iterator(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 24) = *(a2 + 24);
  v3;
  return a1;
}

uint64_t *assignWithCopy for _NativeDictionary.Iterator(uint64_t *a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  a1[1] = *(a2 + 8);
  a1[2] = *(a2 + 16);
  a1[3] = *(a2 + 24);
  a1[4] = *(a2 + 32);
  return a1;
}

uint64_t assignWithTake for _NativeDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  *a1;
  v4 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v4;
  *(a1 + 32) = *(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 40))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0u;
    *(result + 24) = 0u;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 40) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 40) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t type metadata completion function for ClosedRange<>.Index(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *(result - 8) + 64, 1u);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 64);
  v6 = *(v4 + 80);
  if ((v6 & 0x1000F8) != 0 || ((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    v10 = *a2;
    *v3 = *a2;
    v3 = (v10 + (((v6 & 0xF8) + 23) & ~(v6 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(v4 + 16))(a1);
    v9 = ((a2 + v5 + 7) & 0xFFFFFFFFFFFFFFF8);
    v10 = v9[1];
    v11 = ((v3 + v5 + 7) & 0xFFFFFFFFFFFFFFF8);
    *v11 = *v9;
    v11[1] = v10;
  }

  v10;
  return v3;
}

uint64_t destroy for LazyDropWhileSequence(uint64_t a1, uint64_t a2)
{
  v3 = *(*(a2 + 16) - 8) + 8;
  (*v3)();
  v4 = *(((a1 + *(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return v4;
}

uint64_t initializeWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 16;
  (*v5)();
  v6 = *(v5 + 48) + 7;
  v7 = ((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  v8 = ((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9 = v8[1];
  *v7 = *v8;
  v7[1] = v9;
  v9;
  return a1;
}

uint64_t assignWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 24;
  (*v5)();
  v6 = *(v5 + 40) + 7;
  v7 = ((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  v8 = ((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v9 = v8[1];
  v10 = v7[1];
  *v7 = *v8;
  v7[1] = v9;
  v9;
  v10;
  return a1;
}

uint64_t initializeWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 32;
  (*v5)();
  *((*(v5 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v5 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 40;
  (*v5)();
  v6 = *(v5 + 24) + 7;
  v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  v8 = *(v7 + 8);
  *v7 = *((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  v8;
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = *(v4 + 64);
  if (v5 <= 0x7FFFFFFF)
  {
    v7 = 0x7FFFFFFF;
  }

  else
  {
    v7 = *(v4 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  if (v7 >= a2)
  {
    goto LABEL_28;
  }

  v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  v9 = a2 - v7;
  v10 = v8 & 0xFFFFFFF8;
  if ((v8 & 0xFFFFFFF8) != 0)
  {
    v11 = 2;
  }

  else
  {
    v11 = v9 + 1;
  }

  if (v11 >= 0x10000)
  {
    v12 = 4;
  }

  else
  {
    v12 = 2;
  }

  if (v11 < 0x100)
  {
    v12 = 1;
  }

  if (v11 >= 2)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0;
  }

  if (v13 > 1)
  {
    if (v13 == 2)
    {
      v14 = *(a1 + v8);
      if (!v14)
      {
        goto LABEL_28;
      }
    }

    else
    {
      v14 = *(a1 + v8);
      if (!v14)
      {
        goto LABEL_28;
      }
    }
  }

  else if (!v13 || (v14 = *(a1 + v8)) == 0)
  {
LABEL_28:
    if (v5 >= 0x7FFFFFFF)
    {
      return (*(v4 + 48))();
    }

    v17 = *((a1 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (v17 >= 0xFFFFFFFF)
    {
      LODWORD(v17) = -1;
    }

    return (v17 + 1);
  }

  v16 = v14 - 1;
  if (v10)
  {
    v16 = 0;
    LODWORD(v10) = *a1;
  }

  return v7 + (v10 | v16) + 1;
}

_DWORD *storeEnumTagSinglePayload for LazyDropWhileSequence(_DWORD *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  if (v6 <= 0x7FFFFFFF)
  {
    v7 = 0x7FFFFFFF;
  }

  else
  {
    v7 = *(v5 + 84);
  }

  v8 = *(*(*(a4 + 16) - 8) + 64);
  v9 = ((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v8 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
  {
    v10 = a3 - v7 + 1;
  }

  else
  {
    v10 = 2;
  }

  if (v10 >= 0x10000)
  {
    v11 = 4;
  }

  else
  {
    v11 = 2;
  }

  if (v10 < 0x100)
  {
    v11 = 1;
  }

  if (v10 >= 2)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  if (v7 < a3)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0;
  }

  if (a2 > v7)
  {
    if (((v8 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
    {
      v14 = a2 - v7;
    }

    else
    {
      v14 = 1;
    }

    if (((v8 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      v15 = ~v7 + a2;
      v16 = result;
      bzero(result, ((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 16);
      result = v16;
      *v16 = v15;
    }

    if (v13 > 1)
    {
      if (v13 == 2)
      {
        *(result + v9) = v14;
      }

      else
      {
        *(result + v9) = v14;
      }
    }

    else if (v13)
    {
      *(result + v9) = v14;
    }

    return result;
  }

  if (v13 > 1)
  {
    if (v13 != 2)
    {
      *(result + v9) = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_36;
    }

    *(result + v9) = 0;
  }

  else if (v13)
  {
    *(result + v9) = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_36;
  }

  if (!a2)
  {
    return result;
  }

LABEL_36:
  if (v6 < 0x7FFFFFFF)
  {
    v18 = ((result + v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((a2 & 0x80000000) != 0)
    {
      *v18 = a2 & 0x7FFFFFFF;
      v18[1] = 0;
    }

    else
    {
      *v18 = a2 - 1;
    }
  }

  else
  {
    v17 = *(v5 + 56);

    return v17();
  }

  return result;
}

void type metadata completion function for LazyDropWhileSequence.Iterator(uint64_t a1)
{
  v4[0] = &unk_1807268D8;
  swift_getAssociatedTypeWitness(319, *(a1 + 24), *(a1 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[1] = *(v2 - 8) + 64;
    v4[2] = &unk_1EEEAC098;
    swift_initStructMetadata(a1, 0, 3uLL, v4, a1 + 32);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 80);
  v8 = *(v6 + 64) + 7;
  if (v7 > 7 || (*(v6 + 80) & 0x100000) != 0 || ((v8 + ((v7 + 1) & ~v7)) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    v17 = *a2;
    *a1 = *a2;
    a1 = (v17 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
  }

  else
  {
    v11 = ~v7;
    *a1 = *a2;
    v12 = a1 + v7;
    v13 = a2 + v7;
    v14 = (v12 + 1) & v11;
    v15 = (v13 + 1) & v11;
    (*(v6 + 16))(v14, v15, v5);
    v16 = ((v8 + v15) & 0xFFFFFFFFFFFFFFF8);
    v17 = v16[1];
    v18 = ((v8 + v14) & 0xFFFFFFFFFFFFFFF8);
    *v18 = *v16;
    v18[1] = v17;
  }

  v17;
  return a1;
}

uint64_t destroy for LazyDropWhileSequence.Iterator(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v4 = *(v3 - 8);
  v5 = v4 + 8;
  v6 = (a1 + *(v4 + 80) + 1) & ~*(v4 + 80);
  (*(v4 + 8))(v6, v3);
  v7 = *(((*(v5 + 56) + v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return v7;
}

_BYTE *initializeWithCopy for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = v6 + 16;
  v8 = *(v6 + 80);
  v9 = &a1[v8 + 1] & ~v8;
  v10 = &a2[v8 + 1] & ~v8;
  (*(v6 + 16))(v9, v10, v5);
  v11 = *(v7 + 48) + 7;
  v12 = ((v11 + v9) & 0xFFFFFFFFFFFFFFF8);
  v13 = ((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  v14 = v13[1];
  *v12 = *v13;
  v12[1] = v14;
  v14;
  return a1;
}

_BYTE *assignWithCopy for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = v6 + 24;
  v8 = *(v6 + 80);
  v9 = &a1[v8 + 1] & ~v8;
  v10 = &a2[v8 + 1] & ~v8;
  (*(v6 + 24))(v9, v10, v5);
  v11 = *(v7 + 40) + 7;
  v12 = ((v11 + v9) & 0xFFFFFFFFFFFFFFF8);
  v13 = ((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  v14 = v13[1];
  v15 = v12[1];
  *v12 = *v13;
  v12[1] = v14;
  v14;
  v15;
  return a1;
}

_BYTE *initializeWithTake for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = v6 + 32;
  v8 = *(v6 + 80);
  v9 = &a1[v8 + 1] & ~v8;
  v10 = &a2[v8 + 1] & ~v8;
  (*(v6 + 32))(v9, v10, v5);
  *((*(v7 + 32) + 7 + v9) & 0xFFFFFFFFFFFFFFF8) = *((*(v7 + 32) + 7 + v10) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

_BYTE *assignWithTake for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = v6 + 40;
  v8 = *(v6 + 80);
  v9 = &a1[v8 + 1] & ~v8;
  v10 = &a2[v8 + 1] & ~v8;
  (*(v6 + 40))(v9, v10, v5);
  v11 = *(v7 + 24) + 7;
  v12 = (v11 + v9) & 0xFFFFFFFFFFFFFFF8;
  v13 = *(v12 + 8);
  *v12 = *((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  v13;
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence.Iterator(int *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(v6 + 80);
  if (!a2)
  {
    return 0;
  }

  v10 = *(*(v5 - 8) + 64) + 7;
  if (v8 >= a2)
  {
    goto LABEL_27;
  }

  v11 = ((v10 + ((v9 + 1) & ~v9)) & 0xFFFFFFFFFFFFFFF8) + 16;
  v12 = v11 & 0xFFFFFFF8;
  if ((v11 & 0xFFFFFFF8) != 0)
  {
    v13 = 2;
  }

  else
  {
    v13 = a2 - v8 + 1;
  }

  if (v13 >= 0x10000)
  {
    v14 = 4;
  }

  else
  {
    v14 = 2;
  }

  if (v13 < 0x100)
  {
    v14 = 1;
  }

  if (v13 >= 2)
  {
    v15 = v14;
  }

  else
  {
    v15 = 0;
  }

  if (v15 > 1)
  {
    if (v15 == 2)
    {
      v16 = *(a1 + v11);
      if (!v16)
      {
        goto LABEL_27;
      }
    }

    else
    {
      v16 = *(a1 + v11);
      if (!v16)
      {
        goto LABEL_27;
      }
    }

LABEL_24:
    v18 = v16 - 1;
    if (v12)
    {
      v18 = 0;
      v19 = *a1;
    }

    else
    {
      v19 = 0;
    }

    return v8 + (v19 | v18) + 1;
  }

  if (v15)
  {
    v16 = *(a1 + v11);
    if (v16)
    {
      goto LABEL_24;
    }
  }

LABEL_27:
  v20 = (a1 + v9 + 1) & ~v9;
  if (v7 < 0x7FFFFFFF)
  {
    v22 = *((v10 + v20) & 0xFFFFFFFFFFFFFFF8);
    if (v22 >= 0xFFFFFFFF)
    {
      LODWORD(v22) = -1;
    }

    return (v22 + 1);
  }

  else
  {
    v21 = *(v6 + 48);

    return v21(v20);
  }
}

void storeEnumTagSinglePayload for LazyDropWhileSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 80);
  if (v9 <= 0x7FFFFFFF)
  {
    v11 = 0x7FFFFFFF;
  }

  else
  {
    v11 = *(v8 + 84);
  }

  v12 = *(*(v7 - 8) + 64) + 7;
  v13 = ((v12 + ((v10 + 1) & ~v10)) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (v11 >= a3)
  {
    v16 = 0;
    v17 = a2 - v11;
    if (a2 <= v11)
    {
      goto LABEL_17;
    }
  }

  else
  {
    if (((v12 + ((v10 + 1) & ~v10)) & 0xFFFFFFF8) == 0xFFFFFFF0)
    {
      v14 = a3 - v11 + 1;
    }

    else
    {
      v14 = 2;
    }

    if (v14 >= 0x10000)
    {
      v15 = 4;
    }

    else
    {
      v15 = 2;
    }

    if (v14 < 0x100)
    {
      v15 = 1;
    }

    if (v14 >= 2)
    {
      v16 = v15;
    }

    else
    {
      v16 = 0;
    }

    v17 = a2 - v11;
    if (a2 <= v11)
    {
LABEL_17:
      if (v16 > 1)
      {
        if (v16 != 2)
        {
          *(a1 + v13) = 0;
          if (!a2)
          {
            return;
          }

          goto LABEL_33;
        }

        *(a1 + v13) = 0;
      }

      else if (v16)
      {
        *(a1 + v13) = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_33;
      }

      if (!a2)
      {
        return;
      }

LABEL_33:
      v20 = (a1 + v10 + 1) & ~v10;
      if (v9 < 0x7FFFFFFF)
      {
        v22 = ((v12 + v20) & 0xFFFFFFFFFFFFFFF8);
        if ((a2 & 0x80000000) != 0)
        {
          *v22 = a2 & 0x7FFFFFFF;
          v22[1] = 0;
        }

        else
        {
          *v22 = (a2 - 1);
        }
      }

      else
      {
        v21 = *(v8 + 56);

        v21(v20, a2);
      }

      return;
    }
  }

  if (((v12 + ((v10 + 1) & ~v10)) & 0xFFFFFFF8) == 0xFFFFFFF0)
  {
    v18 = v17;
  }

  else
  {
    v18 = 1;
  }

  if (((v12 + ((v10 + 1) & ~v10)) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    v19 = ~v11 + a2;
    bzero(a1, v13);
    *a1 = v19;
  }

  if (v16 > 1)
  {
    if (v16 == 2)
    {
      *(a1 + v13) = v18;
    }

    else
    {
      *(a1 + v13) = v18;
    }
  }

  else if (v16)
  {
    *(a1 + v13) = v18;
  }
}

void type metadata completion function for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1)
{
  swift_getAssociatedTypeWitness(319, *(a1 + 24), *(a1 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *(v2 - 8) + 64, 1u);
  }
}

uint64_t getEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v4 = *(*(v3 - 8) + 48);

  return v4(a1, 1, v3);
}

uint64_t destructiveInjectEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(*(v5 - 8) + 56);

  return v6(a1, a2, 1, v5);
}

uint64_t type metadata completion function for LazyPrefixWhileSequence<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(319, *(a1 + 16), *(a1 + 24), a4);
  if (v6 <= 0x3F)
  {
    v7 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v7, a1 + 32);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyPrefixWhileSequence<>._IndexRepresentation(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  if (*(v6 + 84))
  {
    v7 = *(v6 + 64);
  }

  else
  {
    v7 = *(v6 + 64) + 1;
  }

  v8 = *(v6 + 80);
  if (v8 > 7 || (*(v6 + 80) & 0x100000) != 0 || v7 > 0x18)
  {
    v11 = *a2;
    *a1 = *a2;
    a1 = (v11 + ((v8 + 16) & ~v8));
    v11;
    return a1;
  }

  v12 = v5;
  if (!(*(v6 + 48))(a2, 1, v5))
  {
    (*(v6 + 16))(a1, a2, v12);
    (*(v6 + 56))(a1, 0, 1, v12);
    return a1;
  }

  return memcpy(a1, a2, v7);
}

uint64_t destroy for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v4 = v3;
  v7 = *(v3 - 8);
  result = (*(v7 + 48))(a1, 1, v3);
  if (!result)
  {
    v6 = *(v7 + 8);

    return v6(a1, v4);
  }

  return result;
}

void *initializeWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, const void *a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = v5;
  v7 = *(v5 - 8);
  if ((*(v7 + 48))(a2, 1, v5))
  {
    if (*(v7 + 84))
    {
      v8 = *(v7 + 64);
    }

    else
    {
      v8 = *(v7 + 64) + 1;
    }

    return memcpy(a1, a2, v8);
  }

  else
  {
    (*(v7 + 16))(a1, a2, v6);
    (*(v7 + 56))(a1, 0, 1, v6);
    return a1;
  }
}

void *assignWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = v5;
  v7 = *(v5 - 8);
  v8 = *(v7 + 48);
  v9 = v8(a1, 1, v5);
  v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (v10)
    {
      v14 = *(v7 + 8);
      v13 = v7 + 8;
      v14(a1, v6);
      v11 = *(v13 + 76);
      v12 = *(v13 + 56);
      goto LABEL_6;
    }

    (*(v7 + 24))(a1, a2, v6);
    return a1;
  }

  if (!v10)
  {
    (*(v7 + 16))(a1, a2, v6);
    (*(v7 + 56))(a1, 0, 1, v6);
    return a1;
  }

  v11 = *(v7 + 84);
  v12 = *(v7 + 64);
LABEL_6:
  if (v11)
  {
    v15 = v12;
  }

  else
  {
    v15 = v12 + 1;
  }

  return memcpy(a1, a2, v15);
}

void *initializeWithTake for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, const void *a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = v5;
  v7 = *(v5 - 8);
  if ((*(v7 + 48))(a2, 1, v5))
  {
    if (*(v7 + 84))
    {
      v8 = *(v7 + 64);
    }

    else
    {
      v8 = *(v7 + 64) + 1;
    }

    return memcpy(a1, a2, v8);
  }

  else
  {
    (*(v7 + 32))(a1, a2, v6);
    (*(v7 + 56))(a1, 0, 1, v6);
    return a1;
  }
}

void *assignWithTake for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = v5;
  v7 = *(v5 - 8);
  v8 = *(v7 + 48);
  v9 = v8(a1, 1, v5);
  v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (v10)
    {
      v14 = *(v7 + 8);
      v13 = v7 + 8;
      v14(a1, v6);
      v11 = *(v13 + 76);
      v12 = *(v13 + 56);
      goto LABEL_6;
    }

    (*(v7 + 40))(a1, a2, v6);
    return a1;
  }

  if (!v10)
  {
    (*(v7 + 32))(a1, a2, v6);
    (*(v7 + 56))(a1, 0, 1, v6);
    return a1;
  }

  v11 = *(v7 + 84);
  v12 = *(v7 + 64);
LABEL_6:
  if (v11)
  {
    v15 = v12;
  }

  else
  {
    v15 = v12 + 1;
  }

  return memcpy(a1, a2, v15);
}

uint64_t getEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  v8 = v7 - 1;
  if (!v7)
  {
    v8 = 0;
  }

  v9 = *(*(v5 - 8) + 64);
  if (!v7)
  {
    ++v9;
  }

  if (!a2)
  {
    return 0;
  }

  if (a2 > v8)
  {
    v10 = 8 * v9;
    if (v9 > 3)
    {
      goto LABEL_8;
    }

    v12 = ((a2 - v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      v11 = *(a1 + v9);
      if (v11)
      {
        goto LABEL_15;
      }
    }

    else
    {
      if (v12 <= 0xFF)
      {
        if (v12 < 2)
        {
          goto LABEL_26;
        }

LABEL_8:
        v11 = *(a1 + v9);
        if (!*(a1 + v9))
        {
          goto LABEL_26;
        }

LABEL_15:
        v13 = (v11 - 1) << v10;
        if (v9 > 3)
        {
          v13 = 0;
        }

        if (v9)
        {
          if (v9 > 3)
          {
            LODWORD(v9) = 4;
          }

          if (v9 > 2)
          {
            if (v9 == 3)
            {
              LODWORD(v9) = *a1 | (*(a1 + 2) << 16);
            }

            else
            {
              LODWORD(v9) = *a1;
            }
          }

          else if (v9 == 1)
          {
            LODWORD(v9) = *a1;
          }

          else
          {
            LODWORD(v9) = *a1;
          }
        }

        return v8 + (v9 | v13) + 1;
      }

      v11 = *(a1 + v9);
      if (*(a1 + v9))
      {
        goto LABEL_15;
      }
    }
  }

LABEL_26:
  if (v7 < 2)
  {
    return 0;
  }

  v15 = (*(v6 + 48))(a1);
  if (v15 >= 2)
  {
    return v15 - 1;
  }

  else
  {
    return 0;
  }
}

void storeEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = 0;
  v9 = *(v7 - 8);
  v10 = *(v9 + 84);
  v11 = v10 - 1;
  if (v10)
  {
    v12 = *(*(v7 - 8) + 64);
  }

  else
  {
    v11 = 0;
    v12 = *(*(v7 - 8) + 64) + 1;
  }

  if (a3 <= v11)
  {
    goto LABEL_15;
  }

  if (v12 <= 3)
  {
    v13 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v13))
    {
      v8 = 4;
      if (v11 >= a2)
      {
        goto LABEL_25;
      }

      goto LABEL_16;
    }

    if (v13 < 0x100)
    {
      v14 = 1;
    }

    else
    {
      v14 = 2;
    }

    if (v13 >= 2)
    {
      v8 = v14;
    }

    else
    {
      v8 = 0;
    }

LABEL_15:
    if (v11 >= a2)
    {
      goto LABEL_25;
    }

    goto LABEL_16;
  }

  v8 = 1;
  if (v11 >= a2)
  {
LABEL_25:
    if (v8 > 1)
    {
      if (v8 != 2)
      {
        *&a1[v12] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_32;
      }

      *&a1[v12] = 0;
    }

    else if (v8)
    {
      a1[v12] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_32;
    }

    if (!a2)
    {
      return;
    }

LABEL_32:
    if (v10 >= 2)
    {
      v18 = *(v9 + 56);

      v18(a1, a2 + 1);
    }

    return;
  }

LABEL_16:
  v15 = ~v11 + a2;
  if (v12 >= 4)
  {
    bzero(a1, v12);
    *a1 = v15;
    v16 = 1;
    if (v8 > 1)
    {
      goto LABEL_43;
    }

    goto LABEL_40;
  }

  v16 = (v15 >> (8 * v12)) + 1;
  if (!v12)
  {
LABEL_39:
    if (v8 > 1)
    {
      goto LABEL_43;
    }

    goto LABEL_40;
  }

  v17 = v15 & ~(-1 << (8 * v12));
  bzero(a1, v12);
  if (v12 == 3)
  {
    *a1 = v17;
    a1[2] = BYTE2(v17);
    goto LABEL_39;
  }

  if (v12 == 2)
  {
    *a1 = v17;
    if (v8 > 1)
    {
LABEL_43:
      if (v8 == 2)
      {
        *&a1[v12] = v16;
      }

      else
      {
        *&a1[v12] = v16;
      }

      return;
    }
  }

  else
  {
    *a1 = v15;
    if (v8 > 1)
    {
      goto LABEL_43;
    }
  }

LABEL_40:
  if (v8)
  {
    a1[v12] = v16;
  }
}

uint64_t type metadata completion function for ClosedRange(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 8) + 64;
    v4[1] = v4[0];
    swift_initStructMetadata(a1, 0, 2uLL, v4, a1 + 32);
    return 0;
  }

  return result;
}

uint64_t type metadata completion function for FlattenSequence(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 40);
    return 0;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for _EachFieldOptions(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 4))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _EachFieldOptions(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *result = a2 - 1;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 4) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for _MetadataKind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xF1)
  {
    goto LABEL_17;
  }

  if (a2 + 15 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 15) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 15;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 15;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 15;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x10;
  v8 = v6 - 16;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for _MetadataKind(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 15 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 15) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xF1)
  {
    v4 = 0;
  }

  if (a2 > 0xF0)
  {
    v5 = ((a2 - 241) >> 8) + 1;
    *result = a2 + 15;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 15;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t type metadata completion function for Repeated(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[1] = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, v4, a1 + 24);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Repeated(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 80);
  if (v5 <= 7 && (*(v4 + 80) & 0x100000) == 0 && ((-9 - v5) | v5) - *(*(*(a3 + 16) - 8) + 64) >= 0xFFFFFFFFFFFFFFE7)
  {
    *a1 = *a2;
    (*(v4 + 16))((a1 + v5 + 8) & ~v5, (a2 + v5 + 8) & ~v5);
  }

  else
  {
    v8 = *a2;
    *v3 = *a2;
    v3 = (v8 + ((v5 & 0xF8 ^ 0x1F8) & (v5 + 16)));
    v8;
  }

  return v3;
}

void *initializeWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  v4 = *(*(a3 + 16) - 8);
  (*(v4 + 16))((a1 + *(v4 + 80) + 8) & ~*(v4 + 80), (a2 + *(v4 + 80) + 8) & ~*(v4 + 80));
  return a1;
}

void *assignWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  v4 = *(*(a3 + 16) - 8);
  (*(v4 + 24))((a1 + *(v4 + 80) + 8) & ~*(v4 + 80), (a2 + *(v4 + 80) + 8) & ~*(v4 + 80));
  return a1;
}

void *initializeWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  v4 = *(*(a3 + 16) - 8);
  (*(v4 + 32))((a1 + *(v4 + 80) + 8) & ~*(v4 + 80), (a2 + *(v4 + 80) + 8) & ~*(v4 + 80));
  return a1;
}

void *assignWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  v4 = *(*(a3 + 16) - 8);
  (*(v4 + 40))((a1 + *(v4 + 80) + 8) & ~*(v4 + 80), (a2 + *(v4 + 80) + 8) & ~*(v4 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Repeated(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = *(v4 + 80);
  if (!a2)
  {
    return 0;
  }

  v7 = a2 - v5;
  if (a2 <= v5)
  {
    return (*(v4 + 48))((a1 + v6 + 8) & ~v6);
  }

  v8 = ((v6 + 8) & ~v6) + *(*(*(a3 + 16) - 8) + 64);
  v9 = 8 * v8;
  if (v8 <= 3)
  {
    v11 = ((v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      v10 = *(a1 + v8);
      if (!v10)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      v10 = *(a1 + v8);
      if (!*(a1 + v8))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_22:
      if (v5)
      {
        return (*(v4 + 48))((a1 + v6 + 8) & ~v6);
      }

      return 0;
    }
  }

  v10 = *(a1 + v8);
  if (!*(a1 + v8))
  {
    goto LABEL_22;
  }

LABEL_11:
  v12 = (v10 - 1) << v9;
  if (v8 > 3)
  {
    v12 = 0;
  }

  if (v8)
  {
    if (v8 > 3)
    {
      LODWORD(v8) = 4;
    }

    if (v8 > 2)
    {
      if (v8 == 3)
      {
        LODWORD(v8) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v8) = *a1;
      }
    }

    else if (v8 == 1)
    {
      LODWORD(v8) = *a1;
    }

    else
    {
      LODWORD(v8) = *a1;
    }
  }

  return v5 + (v8 | v12) + 1;
}

void storeEnumTagSinglePayload for Repeated(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v6 = *(*(a4 + 16) - 8);
  v7 = *(v6 + 84);
  v8 = *(v6 + 80);
  v9 = ((v8 + 8) & ~v8) + *(v6 + 64);
  v10 = a3 >= v7;
  v11 = a3 - v7;
  if (v11 != 0 && v10)
  {
    if (v9 <= 3)
    {
      v15 = ((v11 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (HIWORD(v15))
      {
        v12 = 4;
      }

      else
      {
        if (v15 < 0x100)
        {
          v16 = 1;
        }

        else
        {
          v16 = 2;
        }

        if (v15 >= 2)
        {
          v12 = v16;
        }

        else
        {
          v12 = 0;
        }
      }
    }

    else
    {
      v12 = 1;
    }
  }

  else
  {
    v12 = 0;
  }

  if (v7 < a2)
  {
    v13 = ~v7 + a2;
    if (v9 < 4)
    {
      v14 = (v13 >> (8 * v9)) + 1;
      if (v9)
      {
        v17 = v13 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if (v9 != 3)
        {
          if (v9 == 2)
          {
            *a1 = v17;
            if (v12 > 1)
            {
LABEL_39:
              if (v12 == 2)
              {
                *&a1[v9] = v14;
              }

              else
              {
                *&a1[v9] = v14;
              }

              return;
            }
          }

          else
          {
            *a1 = v13;
            if (v12 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *a1 = v17;
        a1[2] = BYTE2(v17);
      }

      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      bzero(a1, v9);
      *a1 = v13;
      v14 = 1;
      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v12)
    {
      a1[v9] = v14;
    }

    return;
  }

  if (v12 > 1)
  {
    if (v12 != 2)
    {
      *&a1[v9] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_28;
    }

    *&a1[v9] = 0;
  }

  else if (v12)
  {
    a1[v9] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return;
  }

LABEL_28:
  v18 = *(v6 + 56);
  v19 = &a1[v8 + 8] & ~v8;

  v18(v19);
}

uint64_t type metadata completion function for Result(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 8) + 64;
    result = swift_checkMetadataState(319, *(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 8) + 64;
      swift_initEnumMetadataMultiPayload(a1, 0, 2u, v5);
      return 0;
    }
  }

  return result;
}

void *initializeBufferWithCopyOfBuffer for Result(void *a1, unsigned __int16 *a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(*(a3 + 24) - 8);
  if (*(v5 + 64) <= *(v4 + 64))
  {
    v6 = *(*(*(a3 + 16) - 8) + 64);
  }

  else
  {
    v6 = *(v5 + 64);
  }

  v7 = (*(v5 + 80) | *(v4 + 80));
  if (v7 > 7 || (v6 + 1) > 0x18 || ((*(v5 + 80) | *(v4 + 80)) & 0x100000) != 0)
  {
    v10 = *a2;
    *v3 = *a2;
    v3 = (v10 + ((v7 + 16) & ~v7));
    v10;
    return v3;
  }

  v11 = *(a2 + v6);
  v12 = v11 - 2;
  if (v11 >= 2)
  {
    if (v6 <= 3)
    {
      v13 = v6;
    }

    else
    {
      v13 = 4;
    }

    if (v13 > 1)
    {
      if (v13 == 2)
      {
        v14 = *a2;
      }

      else if (v13 == 3)
      {
        v14 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v14 = *a2;
      }

LABEL_24:
      v15 = (v14 | (v12 << (8 * v6))) + 2;
      v11 = v14 + 2;
      if (v6 < 4)
      {
        v11 = v15;
      }

      goto LABEL_26;
    }

    if (v13)
    {
      v14 = *a2;
      goto LABEL_24;
    }
  }

LABEL_26:
  if (v11 == 1)
  {
    (*(v5 + 16))(a1);
    *(v3 + v6) = 1;
  }

  else
  {
    (*(v4 + 16))(a1);
    *(v3 + v6) = 0;
  }

  return v3;
}

uint64_t destroy for Result(unsigned __int8 *a1, uint64_t a2)
{
  v2 = *(a2 + 24) - 8;
  v3 = *v2;
  v4 = *(*v2 + 64);
  if (v4 <= *(*(*(a2 + 16) - 8) + 64))
  {
    v4 = *(*(*(a2 + 16) - 8) + 64);
  }

  v5 = a1[v4];
  v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3)
    {
      v7 = v4;
    }

    else
    {
      v7 = 4;
    }

    if (v7 <= 1)
    {
      if (!v7)
      {
        goto LABEL_17;
      }

      v8 = *a1;
    }

    else if (v7 == 2)
    {
      v8 = *a1;
    }

    else if (v7 == 3)
    {
      v8 = *a1 | (a1[2] << 16);
    }

    else
    {
      v8 = *a1;
    }

    v9 = (v8 | (v6 << (8 * v4))) + 2;
    v5 = v8 + 2;
    if (v4 < 4)
    {
      v5 = v9;
    }
  }

LABEL_17:
  if (v5 == 1)
  {
    v10 = v3;
  }

  else
  {
    v10 = *(*(a2 + 16) - 8);
  }

  return (*(v10 + 8))();
}

uint64_t initializeWithCopy for Result(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  v4 = *(a3 + 24);
  v5 = *(*(a3 + 16) - 8);
  if (*(*(v4 - 8) + 64) <= *(v5 + 64))
  {
    v6 = *(*(*(a3 + 16) - 8) + 64);
  }

  else
  {
    v6 = *(*(v4 - 8) + 64);
  }

  v7 = a2[v6];
  v8 = v7 - 2;
  if (v7 >= 2)
  {
    if (v6 <= 3)
    {
      v9 = v6;
    }

    else
    {
      v9 = 4;
    }

    if (v9 <= 1)
    {
      if (!v9)
      {
        goto LABEL_18;
      }

      v10 = *a2;
    }

    else if (v9 == 2)
    {
      v10 = *a2;
    }

    else if (v9 == 3)
    {
      v10 = *a2 | (a2[2] << 16);
    }

    else
    {
      v10 = *a2;
    }

    v11 = (v10 | (v8 << (8 * v6))) + 2;
    v7 = v10 + 2;
    if (v6 < 4)
    {
      v7 = v11;
    }
  }

LABEL_18:
  v12 = v7 == 1;
  if (v7 == 1)
  {
    v5 = *(v4 - 8);
  }

  (*(v5 + 16))(a1);
  *(a1 + v6) = v12;
  return a1;
}

unsigned __int8 *assignWithCopy for Result(unsigned __int8 *a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a1 == a2)
  {
    return a1;
  }

  v5 = *(a3 + 16);
  v6 = *(a3 + 24);
  v7 = *(v5 - 8);
  v8 = *(v6 - 8);
  if (*(v8 + 64) <= *(v7 + 64))
  {
    v9 = *(*(*(a3 + 16) - 8) + 64);
  }

  else
  {
    v9 = *(*(v6 - 8) + 64);
  }

  v10 = a1[v9];
  v11 = v10 - 2;
  if (v10 >= 2)
  {
    if (v9 <= 3)
    {
      v12 = v9;
    }

    else
    {
      v12 = 4;
    }

    if (v12 <= 1)
    {
      if (!v12)
      {
        goto LABEL_19;
      }

      v13 = *a1;
    }

    else if (v12 == 2)
    {
      v13 = *a1;
    }

    else if (v12 == 3)
    {
      v13 = *a1 | (a1[2] << 16);
    }

    else
    {
      v13 = *a1;
    }

    v14 = (v13 | (v11 << (8 * v9))) + 2;
    v10 = v13 + 2;
    if (v9 < 4)
    {
      v10 = v14;
    }
  }

LABEL_19:
  if (v10 == 1)
  {
    v15 = *(v6 - 8);
  }

  else
  {
    v15 = *(*(a3 + 16) - 8);
  }

  if (v10 == 1)
  {
    v16 = *(a3 + 24);
  }

  else
  {
    v16 = *(a3 + 16);
  }

  (*(v15 + 8))(a1, v16);
  v17 = *(a2 + v9);
  v18 = v17 - 2;
  if (v17 >= 2)
  {
    if (v9 <= 3)
    {
      v19 = v9;
    }

    else
    {
      v19 = 4;
    }

    if (v19 > 1)
    {
      if (v19 == 2)
      {
        v20 = *a2;
      }

      else if (v19 == 3)
      {
        v20 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v20 = *a2;
      }

LABEL_37:
      v21 = (v20 | (v18 << (8 * v9))) + 2;
      v17 = v20 + 2;
      if (v9 < 4)
      {
        v17 = v21;
      }

      goto LABEL_39;
    }

    if (v19)
    {
      v20 = *a2;
      goto LABEL_37;
    }
  }

LABEL_39:
  v22 = v17 == 1;
  if (v17 == 1)
  {
    v23 = v8;
  }

  else
  {
    v23 = v7;
  }

  if (v17 == 1)
  {
    v24 = v6;
  }

  else
  {
    v24 = v5;
  }

  (*(v23 + 16))(a1, a2, v24);
  a1[v9] = v22;
  return a1;
}

uint64_t initializeWithTake for Result(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  v4 = *(a3 + 24);
  v5 = *(*(a3 + 16) - 8);
  if (*(*(v4 - 8) + 64) <= *(v5 + 64))
  {
    v6 = *(*(*(a3 + 16) - 8) + 64);
  }

  else
  {
    v6 = *(*(v4 - 8) + 64);
  }

  v7 = a2[v6];
  v8 = v7 - 2;
  if (v7 >= 2)
  {
    if (v6 <= 3)
    {
      v9 = v6;
    }

    else
    {
      v9 = 4;
    }

    if (v9 <= 1)
    {
      if (!v9)
      {
        goto LABEL_18;
      }

      v10 = *a2;
    }

    else if (v9 == 2)
    {
      v10 = *a2;
    }

    else if (v9 == 3)
    {
      v10 = *a2 | (a2[2] << 16);
    }

    else
    {
      v10 = *a2;
    }

    v11 = (v10 | (v8 << (8 * v6))) + 2;
    v7 = v10 + 2;
    if (v6 < 4)
    {
      v7 = v11;
    }
  }

LABEL_18:
  v12 = v7 == 1;
  if (v7 == 1)
  {
    v5 = *(v4 - 8);
  }

  (*(v5 + 32))(a1);
  *(a1 + v6) = v12;
  return a1;
}

unsigned __int8 *assignWithTake for Result(unsigned __int8 *a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a1 == a2)
  {
    return a1;
  }

  v5 = *(a3 + 16);
  v6 = *(a3 + 24);
  v7 = *(v5 - 8);
  v8 = *(v6 - 8);
  if (*(v8 + 64) <= *(v7 + 64))
  {
    v9 = *(*(*(a3 + 16) - 8) + 64);
  }

  else
  {
    v9 = *(*(v6 - 8) + 64);
  }

  v10 = a1[v9];
  v11 = v10 - 2;
  if (v10 >= 2)
  {
    if (v9 <= 3)
    {
      v12 = v9;
    }

    else
    {
      v12 = 4;
    }

    if (v12 <= 1)
    {
      if (!v12)
      {
        goto LABEL_19;
      }

      v13 = *a1;
    }

    else if (v12 == 2)
    {
      v13 = *a1;
    }

    else if (v12 == 3)
    {
      v13 = *a1 | (a1[2] << 16);
    }

    else
    {
      v13 = *a1;
    }

    v14 = (v13 | (v11 << (8 * v9))) + 2;
    v10 = v13 + 2;
    if (v9 < 4)
    {
      v10 = v14;
    }
  }

LABEL_19:
  if (v10 == 1)
  {
    v15 = *(v6 - 8);
  }

  else
  {
    v15 = *(*(a3 + 16) - 8);
  }

  if (v10 == 1)
  {
    v16 = *(a3 + 24);
  }

  else
  {
    v16 = *(a3 + 16);
  }

  (*(v15 + 8))(a1, v16);
  v17 = *(a2 + v9);
  v18 = v17 - 2;
  if (v17 >= 2)
  {
    if (v9 <= 3)
    {
      v19 = v9;
    }

    else
    {
      v19 = 4;
    }

    if (v19 > 1)
    {
      if (v19 == 2)
      {
        v20 = *a2;
      }

      else if (v19 == 3)
      {
        v20 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v20 = *a2;
      }

LABEL_37:
      v21 = (v20 | (v18 << (8 * v9))) + 2;
      v17 = v20 + 2;
      if (v9 < 4)
      {
        v17 = v21;
      }

      goto LABEL_39;
    }

    if (v19)
    {
      v20 = *a2;
      goto LABEL_37;
    }
  }

LABEL_39:
  v22 = v17 == 1;
  if (v17 == 1)
  {
    v23 = v8;
  }

  else
  {
    v23 = v7;
  }

  if (v17 == 1)
  {
    v24 = v6;
  }

  else
  {
    v24 = v5;
  }

  (*(v23 + 32))(a1, a2, v24);
  a1[v9] = v22;
  return a1;
}

uint64_t getEnumTagSinglePayload for Result(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v3 = *(*(*(a3 + 24) - 8) + 64);
  if (v3 <= *(*(*(a3 + 16) - 8) + 64))
  {
    v3 = *(*(*(a3 + 16) - 8) + 64);
  }

  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFF)
  {
    goto LABEL_25;
  }

  v4 = v3 + 1;
  v5 = 8 * (v3 + 1);
  if ((v3 + 1) <= 3)
  {
    v8 = ((a2 + ~(-1 << v5) - 254) >> v5) + 1;
    if (HIWORD(v8))
    {
      v6 = *(a1 + v4);
      if (!v6)
      {
        goto LABEL_25;
      }

      goto LABEL_14;
    }

    if (v8 > 0xFF)
    {
      v6 = *(a1 + v4);
      if (!*(a1 + v4))
      {
        goto LABEL_25;
      }

      goto LABEL_14;
    }

    if (v8 < 2)
    {
LABEL_25:
      v10 = *(a1 + v3);
      if (v10 >= 2)
      {
        return (v10 ^ 0xFF) + 1;
      }

      else
      {
        return 0;
      }
    }
  }

  v6 = *(a1 + v4);
  if (!*(a1 + v4))
  {
    goto LABEL_25;
  }

LABEL_14:
  v9 = (v6 - 1) << v5;
  if (v4 > 3)
  {
    v9 = 0;
  }

  if (v4)
  {
    if (v4 > 3)
    {
      LODWORD(v4) = 4;
    }

    if (v4 > 2)
    {
      if (v4 == 3)
      {
        LODWORD(v4) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v4) = *a1;
      }
    }

    else if (v4 == 1)
    {
      LODWORD(v4) = *a1;
    }

    else
    {
      LODWORD(v4) = *a1;
    }
  }

  return (v4 | v9) + 255;
}

void storeEnumTagSinglePayload for Result(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(*(a4 + 16) - 8) + 64);
  if (*(*(*(a4 + 24) - 8) + 64) > v5)
  {
    v5 = *(*(*(a4 + 24) - 8) + 64);
  }

  v6 = v5 + 1;
  if (a3 < 0xFF)
  {
    v7 = 0;
  }

  else if (v6 <= 3)
  {
    v10 = ((a3 + ~(-1 << (8 * v6)) - 254) >> (8 * v6)) + 1;
    if (HIWORD(v10))
    {
      v7 = 4;
    }

    else
    {
      if (v10 < 0x100)
      {
        v11 = 1;
      }

      else
      {
        v11 = 2;
      }

      if (v10 >= 2)
      {
        v7 = v11;
      }

      else
      {
        v7 = 0;
      }
    }
  }

  else
  {
    v7 = 1;
  }

  if (a2 > 0xFE)
  {
    v8 = a2 - 255;
    if (v6 >= 4)
    {
      bzero(a1, v5 + 1);
      *a1 = v8;
      v9 = 1;
      if (v7 > 1)
      {
        goto LABEL_39;
      }

      goto LABEL_36;
    }

    v9 = (v8 >> (8 * v6)) + 1;
    if (v5 != -1)
    {
      v12 = v8 & ~(-1 << (8 * v6));
      bzero(a1, v6);
      if (v6 != 3)
      {
        if (v6 == 2)
        {
          *a1 = v12;
          if (v7 > 1)
          {
LABEL_39:
            if (v7 == 2)
            {
              *&a1[v6] = v9;
            }

            else
            {
              *&a1[v6] = v9;
            }

            return;
          }
        }

        else
        {
          *a1 = v8;
          if (v7 > 1)
          {
            goto LABEL_39;
          }
        }

LABEL_36:
        if (v7)
        {
          a1[v6] = v9;
        }

        return;
      }

      *a1 = v12;
      a1[2] = BYTE2(v12);
    }

    if (v7 > 1)
    {
      goto LABEL_39;
    }

    goto LABEL_36;
  }

  if (v7 <= 1)
  {
    if (v7)
    {
      a1[v6] = 0;
      if (!a2)
      {
        return;
      }

LABEL_25:
      a1[v5] = -a2;
      return;
    }

LABEL_24:
    if (!a2)
    {
      return;
    }

    goto LABEL_25;
  }

  if (v7 == 2)
  {
    *&a1[v6] = 0;
    goto LABEL_24;
  }

  *&a1[v6] = 0;
  if (a2)
  {
    goto LABEL_25;
  }
}

uint64_t getEnumTag for Result(unsigned __int8 *a1, uint64_t a2)
{
  v2 = *(*(*(a2 + 24) - 8) + 64);
  if (v2 <= *(*(*(a2 + 16) - 8) + 64))
  {
    v2 = *(*(*(a2 + 16) - 8) + 64);
  }

  v3 = a1[v2];
  v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (v2 <= 3)
    {
      v5 = v2;
    }

    else
    {
      v5 = 4;
    }

    if (v5 <= 1)
    {
      if (!v5)
      {
        return v3;
      }

      v6 = *a1;
    }

    else if (v5 == 2)
    {
      v6 = *a1;
    }

    else if (v5 == 3)
    {
      v6 = *a1 | (a1[2] << 16);
    }

    else
    {
      v6 = *a1;
    }

    v7 = (v6 | (v4 << (8 * v2))) + 2;
    LODWORD(v3) = v6 + 2;
    if (v2 >= 4)
    {
      return v3;
    }

    else
    {
      return v7;
    }
  }

  return v3;
}

void destructiveInjectEnumTag for Result(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  if (a2 > 1)
  {
    v5 = *(*(a3 + 24) - 8);
    if (*(v5 + 64) <= *(*(*(a3 + 16) - 8) + 64))
    {
      v6 = *(*(*(a3 + 16) - 8) + 64);
    }

    else
    {
      v6 = *(v5 + 64);
    }

    v7 = a2 - 2;
    if (v6 < 4)
    {
      a1[v6] = (v7 >> (8 * v6)) + 2;
      if (v6)
      {
        v9 = v7 & ~(-1 << (8 * v6));
        bzero(a1, v6);
        if (v6 == 3)
        {
          *a1 = v9;
          a1[2] = BYTE2(v9);
        }

        else if (v6 == 2)
        {
          *a1 = v9;
        }

        else
        {
          *a1 = v7;
        }
      }
    }

    else
    {
      a1[v6] = 2;
      bzero(a1, v6);
      *a1 = v7;
    }
  }

  else
  {
    v3 = *(*(a3 + 24) - 8);
    v4 = *(*(*(a3 + 16) - 8) + 64);
    if (*(v3 + 64) > v4)
    {
      v4 = *(v3 + 64);
    }

    a1[v4] = a2;
  }
}

unint64_t type metadata completion function for ReversedCollection.Iterator(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 8) + 64;
    swift_getAssociatedTypeWitness(319, *(*(a1 + 24) + 8), v2, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    v3 = v5;
    if (v6 <= 0x3F)
    {
      v8[1] = *(v5 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v8, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ReversedCollection.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 80);
  v11 = v7 + v10;
  v12 = (*(v6 + 80) | *(v9 + 80));
  if (v12 > 7 || ((*(v6 + 80) | *(v9 + 80)) & 0x100000) != 0 || (v11 & ~v10) + *(*(v8 - 8) + 64) > 0x18)
  {
    v15 = *a2;
    *a1 = *a2;
    a1 = (v15 + ((v12 + 16) & ~v12));
    v15;
  }

  else
  {
    v16 = v8;
    v17 = ~v10;
    (*(v6 + 16))(a1, a2, v5);
    (*(v9 + 16))((a1 + v11) & v17, (a2 + v11) & v17, v16);
  }

  return a1;
}

uint64_t destroy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v5 = *(v4 - 8) + 8;
  (*v5)(a1, v4);
  v6 = *(v5 + 56) + a1;
  swift_getAssociatedTypeWitness(0, *(*(a2 + 24) + 8), v4, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = v7;
  v9 = *(v7 - 8);
  v10 = *(v9 + 8);
  v11 = (v6 + *(v9 + 80)) & ~*(v9 + 80);

  return v10(v11, v8);
}

uint64_t initializeWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 16;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 48);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 16))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 24;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 40);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 24))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 32;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 32);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 32))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8) + 40;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 24);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v6, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(v9 - 8);
  (*(v10 + 40))((v8 + *(v10 + 80) + a1) & ~*(v10 + 80), (v8 + *(v10 + 80) + a2) & ~*(v10 + 80), v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Iterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v9 + 80);
  if (v10 <= v7)
  {
    v12 = v7;
  }

  else
  {
    v12 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v13 = *(v6 + 64) + v11;
  if (a2 <= v12)
  {
    goto LABEL_28;
  }

  v14 = (v13 & ~v11) + *(*(v8 - 8) + 64);
  v15 = 8 * v14;
  if (v14 <= 3)
  {
    v17 = ((a2 - v12 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      v16 = *(a1 + v14);
      if (!v16)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      v16 = *(a1 + v14);
      if (!*(a1 + v14))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_27:
      if (v12)
      {
LABEL_28:
        if (v7 >= v10)
        {
          v23 = *(v6 + 48);

          return v23(a1, v7, v5);
        }

        else
        {
          v21 = *(v9 + 48);

          return v21((a1 + v13) & ~v11);
        }
      }

      return 0;
    }
  }

  v16 = *(a1 + v14);
  if (!*(a1 + v14))
  {
    goto LABEL_27;
  }

LABEL_14:
  v18 = (v16 - 1) << v15;
  if (v14 > 3)
  {
    v18 = 0;
  }

  if (v14)
  {
    if (v14 <= 3)
    {
      v19 = v14;
    }

    else
    {
      v19 = 4;
    }

    if (v19 > 2)
    {
      if (v19 == 3)
      {
        v20 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v20 = *a1;
      }
    }

    else if (v19 == 1)
    {
      v20 = *a1;
    }

    else
    {
      v20 = *a1;
    }
  }

  else
  {
    v20 = 0;
  }

  return v12 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for ReversedCollection.Iterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v25 = v8;
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(*(a4 + 24) + 8), v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v11 = *(v10 - 8);
  v12 = *(v11 + 84);
  if (v12 <= v9)
  {
    v13 = v9;
  }

  else
  {
    v13 = *(v11 + 84);
  }

  v14 = *(v11 + 80);
  v15 = *(v8 + 64) + v14;
  v16 = (v15 & ~v14) + *(*(v10 - 8) + 64);
  if (a3 <= v13)
  {
    v17 = 0;
  }

  else if (v16 <= 3)
  {
    v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      v17 = 4;
    }

    else
    {
      if (v20 < 0x100)
      {
        v21 = 1;
      }

      else
      {
        v21 = 2;
      }

      if (v20 >= 2)
      {
        v17 = v21;
      }

      else
      {
        v17 = 0;
      }
    }
  }

  else
  {
    v17 = 1;
  }

  if (v13 < a2)
  {
    v18 = ~v13 + a2;
    if (v16 < 4)
    {
      v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        v22 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 != 3)
        {
          if (v16 == 2)
          {
            *a1 = v22;
            if (v17 > 1)
            {
LABEL_46:
              if (v17 == 2)
              {
                *&a1[v16] = v19;
              }

              else
              {
                *&a1[v16] = v19;
              }

              return;
            }
          }

          else
          {
            *a1 = v18;
            if (v17 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v22;
        a1[2] = BYTE2(v22);
      }

      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v16);
      *a1 = v18;
      v19 = 1;
      if (v17 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v17)
    {
      a1[v16] = v19;
    }

    return;
  }

  if (v17 > 1)
  {
    if (v17 != 2)
    {
      *&a1[v16] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v16] = 0;
  }

  else if (v17)
  {
    a1[v16] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v9 >= v12)
  {
    v24 = *(v25 + 56);

    v24(a1, a2, v9, v7);
  }

  else
  {
    v23 = *(v11 + 56);

    v23(&a1[v15] & ~v14, a2);
  }
}

void type metadata completion function for ReversedCollection.Index(uint64_t a1)
{
  swift_getAssociatedTypeWitness(319, *(*(a1 + 24) + 8), *(a1 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    v4 = *(v2 - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 32);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ReversedCollection.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  v7 = *(v6 + 80);
  if (v7 <= 7 && *(*(v5 - 8) + 64) <= 0x18uLL && (*(v6 + 80) & 0x100000) == 0)
  {
    (*(v6 + 16))(a1, a2, v5);
  }

  else
  {
    v10 = *a2;
    *a1 = *a2;
    a1 = (v10 + ((v7 + 16) & ~v7));
    v10;
  }

  return a1;
}

uint64_t destroy for ReversedCollection.Index(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(*(a2 + 24) + 8), *(a2 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v4 = *(*(v3 - 8) + 8);

  return v4(a1, v3);
}

uint64_t initializeWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(*(v5 - 8) + 16))(a1, a2, v5);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(*(v5 - 8) + 24))(a1, a2, v5);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(*(v5 - 8) + 32))(a1, a2, v5);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(*(v5 - 8) + 40))(a1, a2, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(*(a3 + 24) + 8), *(a3 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  v8 = *(v6 + 64);
  if (!a2)
  {
    return 0;
  }

  if (a2 <= v7)
  {
LABEL_23:
    v13 = *(v6 + 48);

    return v13(a1);
  }

  v9 = 8 * v8;
  if (v8 <= 3)
  {
    v11 = ((a2 - v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      v10 = *(a1 + v8);
      if (!v10)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      v10 = *(a1 + v8);
      if (!*(a1 + v8))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_22:
      if (v7)
      {
        goto LABEL_23;
      }

      return 0;
    }
  }

  v10 = *(a1 + v8);
  if (!*(a1 + v8))
  {
    goto LABEL_22;
  }

LABEL_11:
  v12 = (v10 - 1) << v9;
  if (v8 > 3)
  {
    v12 = 0;
  }

  if (v8)
  {
    if (v8 > 3)
    {
      LODWORD(v8) = 4;
    }

    if (v8 > 2)
    {
      if (v8 == 3)
      {
        LODWORD(v8) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v8) = *a1;
      }
    }

    else if (v8 == 1)
    {
      LODWORD(v8) = *a1;
    }

    else
    {
      LODWORD(v8) = *a1;
    }
  }

  return v7 + (v8 | v12) + 1;
}

void storeEnumTagSinglePayload for ReversedCollection.Index(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(*(a4 + 24) + 8), *(a4 + 16), &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 64);
  if (a3 <= v9)
  {
    v11 = 0;
  }

  else if (v10 <= 3)
  {
    v14 = ((a3 - v9 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
    if (HIWORD(v14))
    {
      v11 = 4;
    }

    else
    {
      if (v14 < 0x100)
      {
        v15 = 1;
      }

      else
      {
        v15 = 2;
      }

      if (v14 >= 2)
      {
        v11 = v15;
      }

      else
      {
        v11 = 0;
      }
    }
  }

  else
  {
    v11 = 1;
  }

  if (v9 < a2)
  {
    v12 = ~v9 + a2;
    if (v10 < 4)
    {
      v13 = (v12 >> (8 * v10)) + 1;
      if (v10)
      {
        v16 = v12 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 != 3)
        {
          if (v10 == 2)
          {
            *a1 = v16;
            if (v11 > 1)
            {
LABEL_39:
              if (v11 == 2)
              {
                *&a1[v10] = v13;
              }

              else
              {
                *&a1[v10] = v13;
              }

              return;
            }
          }

          else
          {
            *a1 = v12;
            if (v11 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *a1 = v16;
        a1[2] = BYTE2(v16);
      }

      if (v11 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      bzero(a1, v10);
      *a1 = v12;
      v13 = 1;
      if (v11 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v11)
    {
      a1[v10] = v13;
    }

    return;
  }

  if (v11 > 1)
  {
    if (v11 != 2)
    {
      *&a1[v10] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_28;
    }

    *&a1[v10] = 0;
  }

  else if (v11)
  {
    a1[v10] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return;
  }

LABEL_28:
  v17 = *(v8 + 56);

  v17(a1, a2);
}

uint64_t storeEnumTagSinglePayload for Hasher._State(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 56) = 0;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 64) = v3;
  return result;
}

uint64_t type metadata completion function for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 8) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, v8, a1 + 32);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DropFirstSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 64);
  v6 = *(v4 + 80);
  if ((v6 & 0x1000F8) != 0 || ((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    v8 = *a2;
    *v3 = *a2;
    v3 = (v8 + (((v6 & 0xF8) + 23) & ~(v6 & 0xF8) & 0x1F8));
    v8;
  }

  else
  {
    (*(v4 + 16))(a1);
    *((v3 + v5 + 7) & 0xFFFFFFFFFFFFFFF8) = *((a2 + v5 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  return v3;
}

uint64_t initializeWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 16;
  (*v5)();
  *((*(v5 + 48) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v5 + 48) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 24;
  (*v5)();
  *((*(v5 + 40) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v5 + 40) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t initializeWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 32;
  (*v5)();
  *((*(v5 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v5 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 16) - 8) + 40;
  (*v5)();
  *((*(v5 + 24) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v5 + 24) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropFirstSequence(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  if (!a2)
  {
    return 0;
  }

  if (v5 >= a2)
  {
    return (*(v4 + 48))();
  }

  v6 = ((*(*(*(a3 + 16) - 8) + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  v7 = a2 - v5;
  v8 = v6 & 0xFFFFFFF8;
  if ((v6 & 0xFFFFFFF8) != 0)
  {
    v9 = 2;
  }

  else
  {
    v9 = v7 + 1;
  }

  if (v9 >= 0x10000)
  {
    v10 = 4;
  }

  else
  {
    v10 = 2;
  }

  if (v9 < 0x100)
  {
    v10 = 1;
  }

  if (v9 >= 2)
  {
    v11 = v10;
  }

  else
  {
    v11 = 0;
  }

  if (v11 > 1)
  {
    if (v11 == 2)
    {
      v12 = *(a1 + v6);
      if (!v12)
      {
        goto LABEL_24;
      }
    }

    else
    {
      v12 = *(a1 + v6);
      if (!v12)
      {
        goto LABEL_24;
      }
    }
  }

  else if (!v11 || (v12 = *(a1 + v6)) == 0)
  {
LABEL_24:
    if (v5)
    {
      return (*(v4 + 48))();
    }

    return 0;
  }

  v13 = v12 - 1;
  if (v8)
  {
    v13 = 0;
    LODWORD(v8) = *a1;
  }

  return v5 + (v8 | v13) + 1;
}

unsigned int *storeEnumTagSinglePayload for DropFirstSequence(unsigned int *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  v7 = ((*(v5 + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (v6 >= a3)
  {
    v11 = 0;
    v12 = a2 - v6;
    if (a2 <= v6)
    {
      goto LABEL_14;
    }
  }

  else
  {
    v8 = a3 - v6;
    if (((*(v5 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      v9 = v8 + 1;
    }

    else
    {
      v9 = 2;
    }

    if (v9 >= 0x10000)
    {
      v10 = 4;
    }

    else
    {
      v10 = 2;
    }

    if (v9 < 0x100)
    {
      v10 = 1;
    }

    if (v9 >= 2)
    {
      v11 = v10;
    }

    else
    {
      v11 = 0;
    }

    v12 = a2 - v6;
    if (a2 <= v6)
    {
LABEL_14:
      if (v11 > 1)
      {
        if (v11 != 2)
        {
          *(result + v7) = 0;
          if (!a2)
          {
            return result;
          }

          goto LABEL_30;
        }

        *(result + v7) = 0;
      }

      else if (v11)
      {
        *(result + v7) = 0;
        if (!a2)
        {
          return result;
        }

        goto LABEL_30;
      }

      if (!a2)
      {
        return result;
      }

LABEL_30:
      v16 = *(v5 + 56);

      return v16();
    }
  }

  if (((*(v5 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
  {
    v13 = v12;
  }

  else
  {
    v13 = 1;
  }

  if (((*(v5 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    v14 = ~v6 + a2;
    v15 = result;
    bzero(result, v7);
    result = v15;
    *v15 = v14;
  }

  if (v11 > 1)
  {
    if (v11 == 2)
    {
      *(result + v7) = v13;
    }

    else
    {
      *(result + v7) = v13;
    }
  }

  else if (v11)
  {
    *(result + v7) = v13;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8);
  v9 = *(v8 + 64);
  v10 = *(v8 + 80);
  if ((v10 & 0x1000F8) != 0 || ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    v12 = *a2;
    *a1 = *a2;
    a1 = (v12 + (((v10 & 0xF8) + 23) & ~(v10 & 0xF8) & 0x1F8));
    v12;
  }

  else
  {
    (*(v8 + 16))(a1, a2, v7);
    *((a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) = *((a2 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  }

  return a1;
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8) + 16;
  (*v8)(a1, a2, v7);
  *((*(v8 + 48) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v8 + 48) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8) + 24;
  (*v8)(a1, a2, v7);
  *((*(v8 + 40) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v8 + 40) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8) + 32;
  (*v8)(a1, a2, v7);
  *((*(v8 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v8 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8) + 40;
  (*v8)(a1, a2, v7);
  *((*(v8 + 24) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *((*(v8 + 24) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), a4, a5);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  if (!a2)
  {
    return 0;
  }

  if (v9 >= a2)
  {
LABEL_25:
    v18 = *(v8 + 48);

    return v18(a1);
  }

  v10 = ((*(*(v7 - 8) + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  v11 = v10 & 0xFFFFFFF8;
  if ((v10 & 0xFFFFFFF8) != 0)
  {
    v12 = 2;
  }

  else
  {
    v12 = a2 - v9 + 1;
  }

  if (v12 >= 0x10000)
  {
    v13 = 4;
  }

  else
  {
    v13 = 2;
  }

  if (v12 < 0x100)
  {
    v13 = 1;
  }

  if (v12 >= 2)
  {
    v14 = v13;
  }

  else
  {
    v14 = 0;
  }

  if (v14 > 1)
  {
    if (v14 == 2)
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_24;
      }
    }

    else
    {
      v15 = *(a1 + v10);
      if (!v15)
      {
        goto LABEL_24;
      }
    }
  }

  else if (!v14 || (v15 = *(a1 + v10)) == 0)
  {
LABEL_24:
    if (v9)
    {
      goto LABEL_25;
    }

    return 0;
  }

  v16 = v15 - 1;
  if (v11)
  {
    v16 = 0;
    LODWORD(v11) = *a1;
  }

  return v9 + (v11 | v16) + 1;
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), a5, a6);
  v10 = *(v9 - 8);
  v11 = *(v10 + 84);
  v12 = ((*(v10 + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (v11 >= a3)
  {
    v15 = 0;
    v16 = a2 - v11;
    if (a2 <= v11)
    {
      goto LABEL_14;
    }
  }

  else
  {
    if (((*(v10 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      v13 = a3 - v11 + 1;
    }

    else
    {
      v13 = 2;
    }

    if (v13 >= 0x10000)
    {
      v14 = 4;
    }

    else
    {
      v14 = 2;
    }

    if (v13 < 0x100)
    {
      v14 = 1;
    }

    if (v13 >= 2)
    {
      v15 = v14;
    }

    else
    {
      v15 = 0;
    }

    v16 = a2 - v11;
    if (a2 <= v11)
    {
LABEL_14:
      if (v15 > 1)
      {
        if (v15 != 2)
        {
          *(a1 + v12) = 0;
          if (!a2)
          {
            return;
          }

          goto LABEL_30;
        }

        *(a1 + v12) = 0;
      }

      else if (v15)
      {
        *(a1 + v12) = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_30;
      }

      if (!a2)
      {
        return;
      }

LABEL_30:
      v19 = *(v10 + 56);

      v19(a1, a2);
      return;
    }
  }

  if (((*(v10 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
  {
    v17 = v16;
  }

  else
  {
    v17 = 1;
  }

  if (((*(v10 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    v18 = ~v11 + a2;
    bzero(a1, v12);
    *a1 = v18;
  }

  if (v15 > 1)
  {
    if (v15 == 2)
    {
      *(a1 + v12) = v17;
    }

    else
    {
      *(a1 + v12) = v17;
    }
  }

  else if (v15)
  {
    *(a1 + v12) = v17;
  }
}

void type metadata completion function for DropWhileSequence(uint64_t a1)
{
  v3 = *(a1 + 16);
  v2 = *(a1 + 24);
  swift_getAssociatedTypeWitness(319, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v11[0] = *(v4 - 8) + 64;
    swift_getAssociatedTypeWitness(255, v2, v3, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    v9 = type metadata accessor for Optional(319, v6, v7, v8);
    if (v10 <= 0x3F)
    {
      v11[1] = *(v9 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v11, a1 + 32);
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DropWhileSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = v7;
  v9 = *(v7 - 8);
  v10 = *(v9 + 64);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v12 = *(v11 - 8);
  v13 = *(v12 + 80);
  v14 = v10 + v13;
  if (*(v12 + 84))
  {
    v15 = *(v12 + 64);
  }

  else
  {
    v15 = *(v12 + 64) + 1;
  }

  v16 = (*(v9 + 80) | *(v12 + 80));
  if (v16 > 7 || ((*(v9 + 80) | *(v12 + 80)) & 0x100000) != 0 || ((v10 + v13) & ~v13) + v15 > 0x18)
  {
    v19 = *a2;
    *a1 = *a2;
    a1 = (v19 + ((v16 + 16) & ~v16));
    v19;
  }

  else
  {
    v20 = v11;
    v21 = ~v13;
    (*(v9 + 16))(a1, a2, v8);
    v22 = a1 + v14;
    v23 = a2 + v14;
    if ((*(v12 + 48))(v23 & v21, 1, v20))
    {
      memcpy((v22 & v21), (v23 & v21), v15);
    }

    else
    {
      (*(v12 + 16))(v22 & v21, v23 & v21, v20);
      (*(v12 + 56))(v22 & v21, 0, 1, v20);
    }
  }

  return a1;
}

uint64_t destroy for DropWhileSequence(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v3 = *(a2 + 24);
  swift_getAssociatedTypeWitness(0, v3, v4, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 8;
  (*v6)(a1, v5);
  v7 = *(v6 + 56);
  swift_getAssociatedTypeWitness(0, v3, v4, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 80);
  v12 = v7 + a1 + v11;
  v15 = v10;
  result = (*(v10 + 48))(v12 & ~v11, 1, v8);
  if (!result)
  {
    v14 = *(v15 + 8);

    return v14(v12 & ~v11, v9);
  }

  return result;
}

uint64_t initializeWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8) + 16;
  (*v8)(a1, a2, v7);
  v9 = *(v8 + 48);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = v10;
  v12 = *(v10 - 8);
  v13 = *(v12 + 80);
  v14 = v9 + v13;
  v15 = v9 + v13 + a1;
  v16 = v14 + a2;
  if ((*(v12 + 48))(v16 & ~v13, 1, v10))
  {
    if (*(v12 + 84))
    {
      v17 = *(v12 + 64);
    }

    else
    {
      v17 = *(v12 + 64) + 1;
    }

    memcpy((v15 & ~v13), (v16 & ~v13), v17);
  }

  else
  {
    (*(v12 + 16))(v15 & ~v13, v16 & ~v13, v11);
    (*(v12 + 56))(v15 & ~v13, 0, 1, v11);
  }

  return a1;
}

uint64_t assignWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8) + 24;
  (*v8)(a1, a2, v7);
  v9 = *(v8 + 40);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = v10;
  v12 = *(v10 - 8);
  v13 = *(v12 + 80);
  v14 = v9 + v13;
  v15 = v9 + v13 + a1;
  v16 = v14 + a2;
  v17 = *(v12 + 48);
  LODWORD(a2) = v17(v15 & ~v13, 1, v10);
  v18 = v17(v16 & ~v13, 1, v11);
  if (a2)
  {
    if (!v18)
    {
      (*(v12 + 16))(v15 & ~v13, v16 & ~v13, v11);
      (*(v12 + 56))(v15 & ~v13, 0, 1, v11);
      return a1;
    }

    v19 = *(v12 + 84);
    v20 = *(v12 + 64);
  }

  else
  {
    if (!v18)
    {
      (*(v12 + 24))(v15 & ~v13, v16 & ~v13, v11);
      return a1;
    }

    v22 = *(v12 + 8);
    v21 = v12 + 8;
    v22(v15 & ~v13, v11);
    v19 = *(v21 + 76);
    v20 = *(v21 + 56);
  }

  if (v19)
  {
    v23 = v20;
  }

  else
  {
    v23 = v20 + 1;
  }

  memcpy((v15 & ~v13), (v16 & ~v13), v23);
  return a1;
}

uint64_t initializeWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8) + 32;
  (*v8)(a1, a2, v7);
  v9 = *(v8 + 32);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = v10;
  v12 = *(v10 - 8);
  v13 = *(v12 + 80);
  v14 = v9 + v13;
  v15 = v9 + v13 + a1;
  v16 = v14 + a2;
  if ((*(v12 + 48))(v16 & ~v13, 1, v10))
  {
    if (*(v12 + 84))
    {
      v17 = *(v12 + 64);
    }

    else
    {
      v17 = *(v12 + 64) + 1;
    }

    memcpy((v15 & ~v13), (v16 & ~v13), v17);
  }

  else
  {
    (*(v12 + 32))(v15 & ~v13, v16 & ~v13, v11);
    (*(v12 + 56))(v15 & ~v13, 0, 1, v11);
  }

  return a1;
}

uint64_t assignWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8) + 40;
  (*v8)(a1, a2, v7);
  v9 = *(v8 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = v10;
  v12 = *(v10 - 8);
  v13 = *(v12 + 80);
  v14 = v9 + v13;
  v15 = v9 + v13 + a1;
  v16 = v14 + a2;
  v17 = *(v12 + 48);
  LODWORD(a2) = v17(v15 & ~v13, 1, v10);
  v18 = v17(v16 & ~v13, 1, v11);
  if (a2)
  {
    if (!v18)
    {
      (*(v12 + 32))(v15 & ~v13, v16 & ~v13, v11);
      (*(v12 + 56))(v15 & ~v13, 0, 1, v11);
      return a1;
    }

    v19 = *(v12 + 84);
    v20 = *(v12 + 64);
  }

  else
  {
    if (!v18)
    {
      (*(v12 + 40))(v15 & ~v13, v16 & ~v13, v11);
      return a1;
    }

    v22 = *(v12 + 8);
    v21 = v12 + 8;
    v22(v15 & ~v13, v11);
    v19 = *(v21 + 76);
    v20 = *(v21 + 56);
  }

  if (v19)
  {
    v23 = v20;
  }

  else
  {
    v23 = v20 + 1;
  }

  memcpy((v15 & ~v13), (v16 & ~v13), v23);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropWhileSequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v5 = *(a3 + 24);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = v7;
  v9 = *(v7 - 8);
  v10 = *(v9 + 84);
  swift_getAssociatedTypeWitness(0, v5, v6, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v12 = *(v11 - 8);
  v13 = *(v12 + 84);
  if (v13)
  {
    v14 = v13 - 1;
  }

  else
  {
    v14 = 0;
  }

  if (v14 <= v10)
  {
    v15 = v10;
  }

  else
  {
    v15 = v14;
  }

  v16 = *(v12 + 80);
  if (v13)
  {
    v17 = *(*(v11 - 8) + 64);
  }

  else
  {
    v17 = *(*(v11 - 8) + 64) + 1;
  }

  if (!a2)
  {
    return 0;
  }

  v18 = *(v9 + 64) + v16;
  if (a2 <= v15)
  {
    goto LABEL_34;
  }

  v19 = v17 + (v18 & ~v16);
  v20 = 8 * v19;
  if (v19 <= 3)
  {
    v22 = ((a2 - v15 + ~(-1 << v20)) >> v20) + 1;
    if (HIWORD(v22))
    {
      v21 = *(a1 + v19);
      if (!v21)
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v22 > 0xFF)
    {
      v21 = *(a1 + v19);
      if (!*(a1 + v19))
      {
        goto LABEL_33;
      }

      goto LABEL_20;
    }

    if (v22 < 2)
    {
LABEL_33:
      if (v15)
      {
LABEL_34:
        if (v10 >= v14)
        {
          v28 = *(v9 + 48);

          return v28(a1, v10, v8);
        }

        else
        {
          v26 = (*(v12 + 48))((a1 + v18) & ~v16);
          if (v26 >= 2)
          {
            return v26 - 1;
          }

          else
          {
            return 0;
          }
        }
      }

      return 0;
    }
  }

  v21 = *(a1 + v19);
  if (!*(a1 + v19))
  {
    goto LABEL_33;
  }

LABEL_20:
  v23 = (v21 - 1) << v20;
  if (v19 > 3)
  {
    v23 = 0;
  }

  if (v19)
  {
    if (v19 <= 3)
    {
      v24 = v19;
    }

    else
    {
      v24 = 4;
    }

    if (v24 > 2)
    {
      if (v24 == 3)
      {
        v25 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v25 = *a1;
      }
    }

    else if (v24 == 1)
    {
      v25 = *a1;
    }

    else
    {
      v25 = *a1;
    }
  }

  else
  {
    v25 = 0;
  }

  return v15 + (v25 | v23) + 1;
}

void storeEnumTagSinglePayload for DropWhileSequence(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v8 = *(a4 + 16);
  v7 = *(a4 + 24);
  swift_getAssociatedTypeWitness(0, v7, v8, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 84);
  swift_getAssociatedTypeWitness(0, v7, v8, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = 0;
  v15 = *(v14 - 8);
  v16 = *(v15 + 84);
  v17 = v16 - 1;
  if (!v16)
  {
    v17 = 0;
  }

  if (v17 <= v12)
  {
    v18 = v12;
  }

  else
  {
    v18 = v17;
  }

  v19 = *(v15 + 80);
  v20 = *(v11 + 64) + v19;
  if (v16)
  {
    v21 = *(v15 + 64);
  }

  else
  {
    v21 = *(v15 + 64) + 1;
  }

  v22 = (v20 & ~v19) + v21;
  if (a3 <= v18)
  {
    goto LABEL_20;
  }

  if (v22 <= 3)
  {
    v23 = ((a3 - v18 + ~(-1 << (8 * v22))) >> (8 * v22)) + 1;
    if (HIWORD(v23))
    {
      v13 = 4;
      if (v18 >= a2)
      {
        goto LABEL_30;
      }

      goto LABEL_21;
    }

    if (v23 < 0x100)
    {
      v24 = 1;
    }

    else
    {
      v24 = 2;
    }

    if (v23 >= 2)
    {
      v13 = v24;
    }

    else
    {
      v13 = 0;
    }

LABEL_20:
    if (v18 >= a2)
    {
      goto LABEL_30;
    }

    goto LABEL_21;
  }

  v13 = 1;
  if (v18 >= a2)
  {
LABEL_30:
    if (v13 > 1)
    {
      if (v13 != 2)
      {
        *&a1[v22] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_37;
      }

      *&a1[v22] = 0;
    }

    else if (v13)
    {
      a1[v22] = 0;
      if (!a2)
      {
        return;
      }

LABEL_37:
      if (v12 >= v17)
      {
        v32 = *(v11 + 56);

        v32(a1, a2, v12, v10);
      }

      else
      {
        v28 = (&a1[v20] & ~v19);
        if (v17 >= a2)
        {
          v33 = *(v15 + 56);

          v33(v28, (a2 + 1));
        }

        else
        {
          if (v21 <= 3)
          {
            v29 = ~(-1 << (8 * v21));
          }

          else
          {
            v29 = -1;
          }

          if (v21)
          {
            v30 = v29 & (~v17 + a2);
            if (v21 <= 3)
            {
              v31 = v21;
            }

            else
            {
              v31 = 4;
            }

            bzero(v28, v21);
            if (v31 > 2)
            {
              if (v31 == 3)
              {
                *v28 = v30;
                v28[2] = BYTE2(v30);
              }

              else
              {
                *v28 = v30;
              }
            }

            else if (v31 == 1)
            {
              *v28 = v30;
            }

            else
            {
              *v28 = v30;
            }
          }
        }
      }

      return;
    }

    if (!a2)
    {
      return;
    }

    goto LABEL_37;
  }

LABEL_21:
  v25 = ~v18 + a2;
  if (v22 >= 4)
  {
    bzero(a1, (v20 & ~v19) + v21);
    *a1 = v25;
    v26 = 1;
    if (v13 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v26 = (v25 >> (8 * v22)) + 1;
  if (!v22)
  {
LABEL_58:
    if (v13 > 1)
    {
      goto LABEL_62;
    }

    goto LABEL_59;
  }

  v27 = v25 & ~(-1 << (8 * v22));
  bzero(a1, v22);
  if (v22 == 3)
  {
    *a1 = v27;
    a1[2] = BYTE2(v27);
    goto LABEL_58;
  }

  if (v22 == 2)
  {
    *a1 = v27;
    if (v13 > 1)
    {
LABEL_62:
      if (v13 == 2)
      {
        *&a1[v22] = v26;
      }

      else
      {
        *&a1[v22] = v26;
      }

      return;
    }
  }

  else
  {
    *a1 = v25;
    if (v13 > 1)
    {
      goto LABEL_62;
    }
  }

LABEL_59:
  if (v13)
  {
    a1[v22] = v26;
  }
}

swift *type metadata completion function for _SwiftSetNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_1EEEAAE60;
  v2[1] = "\b";
  v2[2] = &value witness table for Builtin.Int64.size;
  v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4, v2, a1 + 112);
}

swift *type metadata completion function for _SwiftDeferredNSSet(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &unk_1EEEAAE60;
  return swift_initClassMetadata2(a1, 0, 2, v2, a1 + 112);
}

unint64_t *initializeBufferWithCopyOfBuffer for __CocoaSet.Index(unint64_t *a1, unint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  v3;
  return a1;
}

unint64_t *assignWithCopy for __CocoaDictionary.Index(unint64_t *a1, unint64_t *a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  a1[1] = a2[1];
  return a1;
}

unint64_t *assignWithTake for __CocoaSet.Index(unint64_t *a1, unint64_t *a2)
{
  v4 = *a1;
  *a1 = *a2;
  v4;
  a1[1] = a2[1];
  return a1;
}

void *initializeBufferWithCopyOfBuffer for _SetBuilder(void *a1, uint64_t a2)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  *a1 = *a2;
  a1[1] = v4;
  v3;
  return a1;
}

uint64_t *assignWithCopy for _DictionaryBuilder(uint64_t *a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  a1[1] = *(a2 + 8);
  return a1;
}

uint64_t *assignWithTake for _SetBuilder(uint64_t *a1, uint64_t *a2)
{
  v4 = *a1;
  *a1 = *a2;
  v4;
  a1[1] = a2[1];
  return a1;
}

void type metadata completion function for Slice(uint64_t a1)
{
  v2 = *(a1 + 16);
  swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v4 <= 0x3F)
  {
    v7[0] = *(v3 - 8) + 64;
    v7[1] = v7[0];
    v5 = swift_checkMetadataState(319, v2);
    if (v6 <= 0x3F)
    {
      v7[2] = *(v5 - 8) + 64;
      swift_initStructMetadata(a1, 0, 3uLL, v7, a1 + 32);
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Slice(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = *(v6 - 8);
  v8 = *(v7 + 64);
  v9 = *(v7 + 80);
  v10 = v8 + v9;
  v11 = *(v5 - 8);
  v12 = *(v11 + 80);
  v13 = v8 + v12;
  v14 = ((v8 + v12 + ((v8 + v9) & ~v9)) & ~v12) + *(v11 + 64);
  if ((v12 | v9) > 7 || ((*(v11 + 80) | *(v7 + 80)) & 0x100000) != 0 || v14 > 0x18)
  {
    v17 = *a2;
    *a1 = *a2;
    v23 = (v17 + (((v12 | v9) + 16) & ~(v12 | v9)));
    v17;
  }

  else
  {
    v18 = v6;
    v19 = ~v9;
    v25 = ~v12;
    v20 = *(v7 + 16);
    v20(a1, a2, v6);
    v26 = a1;
    v21 = (a1 + v10) & v19;
    v22 = (a2 + v10) & v19;
    v20(v21, v22, v18);
    v23 = v26;
    (*(v11 + 16))((v21 + v13) & v25, (v22 + v13) & v25, v5);
  }

  return v23;
}

uint64_t destroy for Slice(unint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 16);
  swift_getAssociatedTypeWitness(0, *(a2 + 24), v3, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v5 = v4;
  v6 = *(v4 - 8);
  v7 = *(v6 + 8);
  v8 = v6 + 8;
  v7(a1, v4);
  v9 = *(v8 + 56);
  v10 = (v9 + a1 + *(v8 + 72)) & ~*(v8 + 72);
  v7(v10, v5);
  v11 = *(v3 - 8);
  v12 = *(v11 + 8);
  v13 = (v10 + v9 + *(v11 + 80)) & ~*(v11 + 80);

  return v12(v13, v3);
}

uint64_t initializeWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 16);
  v10 = v8 + 16;
  v9(a1, a2, v6);
  v11 = *(v10 + 48);
  v12 = *(v10 + 64);
  v13 = (v11 + v12 + a1) & ~v12;
  v14 = (v11 + v12 + a2) & ~v12;
  v9(v13, v14, v7);
  v15 = *(v5 - 8);
  (*(v15 + 16))((v11 + *(v15 + 80) + v13) & ~*(v15 + 80), (v11 + *(v15 + 80) + v14) & ~*(v15 + 80), v5);
  return a1;
}

uint64_t assignWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 24);
  v10 = v8 + 24;
  v9(a1, a2, v6);
  v11 = *(v10 + 40);
  v12 = *(v10 + 56);
  v13 = (v11 + v12 + a1) & ~v12;
  v14 = (v11 + v12 + a2) & ~v12;
  v9(v13, v14, v7);
  v15 = *(v5 - 8);
  (*(v15 + 24))((v11 + *(v15 + 80) + v13) & ~*(v15 + 80), (v11 + *(v15 + 80) + v14) & ~*(v15 + 80), v5);
  return a1;
}

uint64_t initializeWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 32);
  v10 = v8 + 32;
  v9(a1, a2, v6);
  v11 = *(v10 + 32);
  v12 = *(v10 + 48);
  v13 = (v11 + v12 + a1) & ~v12;
  v14 = (v11 + v12 + a2) & ~v12;
  v9(v13, v14, v7);
  v15 = *(v5 - 8);
  (*(v15 + 32))((v11 + *(v15 + 80) + v13) & ~*(v15 + 80), (v11 + *(v15 + 80) + v14) & ~*(v15 + 80), v5);
  return a1;
}

uint64_t assignWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 40);
  v10 = v8 + 40;
  v9(a1, a2, v6);
  v11 = *(v10 + 24);
  v12 = *(v10 + 40);
  v13 = (v11 + v12 + a1) & ~v12;
  v14 = (v11 + v12 + a2) & ~v12;
  v9(v13, v14, v7);
  v15 = *(v5 - 8);
  (*(v15 + 40))((v11 + *(v15 + 80) + v13) & ~*(v15 + 80), (v11 + *(v15 + 80) + v14) & ~*(v15 + 80), v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for Slice(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = *(v6 - 8);
  v8 = *(v7 + 84);
  v9 = *(v5 - 8);
  v10 = *(v9 + 84);
  v11 = *(v7 + 64);
  v12 = *(v7 + 80);
  v13 = *(v9 + 80);
  if (v10 <= v8)
  {
    v14 = *(v7 + 84);
  }

  else
  {
    v14 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v15 = v11 + v12;
  if (a2 <= v14)
  {
    goto LABEL_28;
  }

  v16 = ((v11 + v13 + (v15 & ~v12)) & ~v13) + *(*(v5 - 8) + 64);
  v17 = 8 * v16;
  if (v16 <= 3)
  {
    v19 = ((a2 - v14 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      v18 = *(a1 + v16);
      if (!v18)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 > 0xFF)
    {
      v18 = *(a1 + v16);
      if (!*(a1 + v16))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 < 2)
    {
LABEL_27:
      if (v14)
      {
LABEL_28:
        if (v8 >= v10)
        {
          v25 = *(v7 + 48);

          return v25(a1);
        }

        else
        {
          v23 = *(v9 + 48);

          return v23((((a1 + v15) & ~v12) + v11 + v13) & ~v13, v10, v5);
        }
      }

      return 0;
    }
  }

  v18 = *(a1 + v16);
  if (!*(a1 + v16))
  {
    goto LABEL_27;
  }

LABEL_14:
  v20 = (v18 - 1) << v17;
  if (v16 > 3)
  {
    v20 = 0;
  }

  if (v16)
  {
    if (v16 <= 3)
    {
      v21 = ((v11 + v13 + (v15 & ~v12)) & ~v13) + *(*(v5 - 8) + 64);
    }

    else
    {
      v21 = 4;
    }

    if (v21 > 2)
    {
      if (v21 == 3)
      {
        v22 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v22 = *a1;
      }
    }

    else if (v21 == 1)
    {
      v22 = *a1;
    }

    else
    {
      v22 = *a1;
    }
  }

  else
  {
    v22 = 0;
  }

  return v14 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for Slice(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v7 - 8);
  v12 = *(v11 + 84);
  v13 = *(v9 + 64);
  v14 = *(v9 + 80);
  v15 = *(v11 + 80);
  if (v12 <= v10)
  {
    v16 = *(v9 + 84);
  }

  else
  {
    v16 = *(v11 + 84);
  }

  v17 = ((v13 + v15 + ((v13 + v14) & ~v14)) & ~v15) + *(*(v7 - 8) + 64);
  if (a3 <= v16)
  {
    v18 = 0;
  }

  else if (v17 <= 3)
  {
    v21 = ((a3 - v16 + ~(-1 << (8 * v17))) >> (8 * v17)) + 1;
    if (HIWORD(v21))
    {
      v18 = 4;
    }

    else
    {
      if (v21 < 0x100)
      {
        v22 = 1;
      }

      else
      {
        v22 = 2;
      }

      if (v21 >= 2)
      {
        v18 = v22;
      }

      else
      {
        v18 = 0;
      }
    }
  }

  else
  {
    v18 = 1;
  }

  if (v16 < a2)
  {
    v19 = ~v16 + a2;
    if (v17 < 4)
    {
      v20 = (v19 >> (8 * v17)) + 1;
      if (v17)
      {
        v23 = v19 & ~(-1 << (8 * v17));
        bzero(a1, v17);
        if (v17 != 3)
        {
          if (v17 == 2)
          {
            *a1 = v23;
            if (v18 > 1)
            {
LABEL_46:
              if (v18 == 2)
              {
                *&a1[v17] = v20;
              }

              else
              {
                *&a1[v17] = v20;
              }

              return;
            }
          }

          else
          {
            *a1 = v19;
            if (v18 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v23;
        a1[2] = BYTE2(v23);
      }

      if (v18 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v17);
      *a1 = v19;
      v20 = 1;
      if (v18 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v18)
    {
      a1[v17] = v20;
    }

    return;
  }

  if (v18 > 1)
  {
    if (v18 != 2)
    {
      *&a1[v17] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v17] = 0;
  }

  else if (v18)
  {
    a1[v17] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v10 >= v12)
  {
    v25 = *(v9 + 56);

    v25(a1, a2);
  }

  else
  {
    v24 = *(v11 + 56);

    v24(((&a1[v13 + v14] & ~v14) + v13 + v15) & ~v15, a2, v12, v7);
  }
}

__n128 assignWithTake for OutputSpan(__n128 *a1, __n128 *a2)
{
  result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  return result;
}

uint64_t getEnumTagSinglePayload for OutputSpan(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 24))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for OutputSpan(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 8) = 0;
    *(result + 16) = 0;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 24) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for StaticString(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 17))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for StaticString(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 16) = 0;
    *result = (a2 - 1);
    *(result + 8) = 0;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 17) = v3;
  return result;
}

unint64_t type metadata completion function for StrideToIterator(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v5 = *(v2 - 8) + 64;
    v10[0] = v5;
    v10[1] = v5;
    swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    v3 = v6;
    if (v7 <= 0x3F)
    {
      v10[2] = *(v6 - 8) + 64;
      swift_getTupleTypeLayout2(v9, "\t", v5);
      v10[3] = v9;
      swift_initStructMetadata(a1, 0, 4uLL, v10, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideToIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  v5 = *(v4 - 8);
  v6 = *(v5 + 64);
  v7 = *(v5 + 80);
  v8 = v7;
  v9 = v6 + v7;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v4, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v11 = *(v10 - 8);
  v12 = *(v11 + 80);
  v13 = v6 + v12;
  if ((v12 | v7) <= 7 && ((*(v11 + 80) | v7) & 0x100000) == 0 && ((-10 - v7) | v7) - v6 - ((*(*(v10 - 8) + 64) + (v7 | 7) + ((v6 + v12 + ((v6 + v7) & ~v7)) & ~v12)) & ~(v7 | 7)) >= 0xFFFFFFFFFFFFFFE7)
  {
    v26 = ~v12;
    v27 = *(*(v10 - 8) + 64);
    v18 = *(v5 + 16);
    v28 = v10;
    v18(a1, a2, v4);
    v19 = (a2 + v9) & ~v7;
    v18(((a1 + v9) & ~v8), v19, v4);
    v20 = (((a1 + v9) & ~v8) + v13) & v26;
    v21 = (v19 + v13) & v26;
    (*(v11 + 16))(v20, v21, v28);
    v22 = (v27 + 7 + v20) & 0xFFFFFFFFFFFFFFF8;
    v23 = (v27 + 7 + v21) & 0xFFFFFFFFFFFFFFF8;
    v24 = *(v23 + 8);
    *v22 = *v23;
    *(v22 + 8) = v24;
    v17 = a1;
    v18(((v8 + 9 + v22) & ~v8), ((v8 + 9 + v23) & ~v8), v4);
  }

  else
  {
    v16 = *a2;
    *a1 = *a2;
    v17 = (v16 + (((v12 | v7) & 0xF8 ^ 0x1F8) & ((v12 | v7) + 16)));
    v16;
  }

  return v17;
}

uint64_t initializeWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 16);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 16;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 16))(v16, v17, v12);
  v18 = *(v14 + 48) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  v21 = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t assignWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 24);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 24;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 24))(v16, v17, v12);
  v18 = *(v14 + 40) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  v21 = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t initializeWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 32);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 32;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 32))(v16, v17, v12);
  v18 = *(v14 + 32) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  v21 = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t assignWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 40);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 40;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 40))(v16, v17, v12);
  v18 = *(v14 + 24) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  v21 = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideToIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v6 + 64);
  v12 = *(v6 + 80);
  v13 = *(v9 + 80);
  if (v10 <= v7)
  {
    v14 = v7;
  }

  else
  {
    v14 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v15 = v11 + v12;
  if (a2 <= v14)
  {
    goto LABEL_28;
  }

  v16 = ((v12 + 9) & ~v12) + v11 + (((v12 | 7) + *(*(v8 - 8) + 64) + ((v11 + v13 + (v15 & ~v12)) & ~v13)) & ~(v12 | 7));
  v17 = 8 * v16;
  if (v16 <= 3)
  {
    v19 = ((a2 - v14 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      v18 = *(a1 + v16);
      if (!v18)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 > 0xFF)
    {
      v18 = *(a1 + v16);
      if (!*(a1 + v16))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 < 2)
    {
LABEL_27:
      if (v14)
      {
LABEL_28:
        if (v7 >= v10)
        {
          v25 = *(v6 + 48);

          return v25(a1, v7, v5);
        }

        else
        {
          v23 = *(v9 + 48);

          return v23((((a1 + v15) & ~v12) + v11 + v13) & ~v13);
        }
      }

      return 0;
    }
  }

  v18 = *(a1 + v16);
  if (!*(a1 + v16))
  {
    goto LABEL_27;
  }

LABEL_14:
  v20 = (v18 - 1) << v17;
  if (v16 > 3)
  {
    v20 = 0;
  }

  if (v16)
  {
    if (v16 <= 3)
    {
      v21 = v16;
    }

    else
    {
      v21 = 4;
    }

    if (v21 > 2)
    {
      if (v21 == 3)
      {
        v22 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v22 = *a1;
      }
    }

    else if (v21 == 1)
    {
      v22 = *a1;
    }

    else
    {
      v22 = *a1;
    }
  }

  else
  {
    v22 = 0;
  }

  return v14 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for StrideToIterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v11 = v8;
  v12 = *(v10 - 8);
  v13 = *(v12 + 84);
  v14 = *(v8 + 64);
  if (v13 <= v9)
  {
    v15 = v9;
  }

  else
  {
    v15 = *(v12 + 84);
  }

  v16 = *(v11 + 80);
  v17 = *(v12 + 80);
  v18 = ((v16 + 9) & ~v16) + v14 + (((v16 | 7) + *(*(v10 - 8) + 64) + ((v14 + v17 + ((v14 + v16) & ~v16)) & ~v17)) & ~(v16 | 7));
  if (a3 <= v15)
  {
    v19 = 0;
  }

  else if (v18 <= 3)
  {
    v22 = ((a3 - v15 + ~(-1 << (8 * v18))) >> (8 * v18)) + 1;
    if (HIWORD(v22))
    {
      v19 = 4;
    }

    else
    {
      if (v22 < 0x100)
      {
        v23 = 1;
      }

      else
      {
        v23 = 2;
      }

      if (v22 >= 2)
      {
        v19 = v23;
      }

      else
      {
        v19 = 0;
      }
    }
  }

  else
  {
    v19 = 1;
  }

  if (v15 < a2)
  {
    v20 = ~v15 + a2;
    if (v18 < 4)
    {
      v21 = (v20 >> (8 * v18)) + 1;
      if (v18)
      {
        v24 = v20 & ~(-1 << (8 * v18));
        bzero(a1, v18);
        if (v18 != 3)
        {
          if (v18 == 2)
          {
            *a1 = v24;
            if (v19 > 1)
            {
LABEL_46:
              if (v19 == 2)
              {
                *&a1[v18] = v21;
              }

              else
              {
                *&a1[v18] = v21;
              }

              return;
            }
          }

          else
          {
            *a1 = v20;
            if (v19 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v24;
        a1[2] = BYTE2(v24);
      }

      if (v19 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v18);
      *a1 = v20;
      v21 = 1;
      if (v19 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v19)
    {
      a1[v18] = v21;
    }

    return;
  }

  if (v19 > 1)
  {
    if (v19 != 2)
    {
      *&a1[v18] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v18] = 0;
  }

  else if (v19)
  {
    a1[v18] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v9 >= v13)
  {
    v26 = *(v11 + 56);

    v26(a1, a2, v9, v7);
  }

  else
  {
    v25 = *(v12 + 56);

    v25(((&a1[v14 + v16] & ~v16) + v14 + v17) & ~v17, a2);
  }
}

unint64_t type metadata completion function for StrideThroughIterator(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v5 = *(v2 - 8) + 64;
    v10[0] = v5;
    v10[1] = v5;
    swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    v3 = v6;
    if (v7 <= 0x3F)
    {
      v10[2] = *(v6 - 8) + 64;
      swift_getTupleTypeLayout2(v9, "\t", v5);
      v10[3] = v9;
      v10[4] = &unk_1807268D8;
      swift_initStructMetadata(a1, 0, 5uLL, v10, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideThroughIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = *(a3 + 16);
  v4 = *(v3 - 8);
  v5 = *(v4 + 64);
  v6 = *(v4 + 80);
  v7 = v5 + v6;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v3, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v9 = *(v8 - 8);
  v10 = *(v9 + 80);
  v11 = v5 + v10;
  v12 = v6 + 9;
  v13 = (v12 & ~v6) + v5;
  if ((v10 | v6) > 7 || ((*(v9 + 80) | v6) & 0x100000) != 0 || v13 + ((*(*(v8 - 8) + 64) + (v6 | 7) + ((v5 + v10 + ((v5 + v6) & ~v6)) & ~v10)) & ~(v6 | 7)) + 1 > 0x18)
  {
    v16 = *a2;
    *a1 = *a2;
    v19 = (v16 + (((v10 | v6) & 0xF8 ^ 0x1F8) & ((v10 | v6) + 16)));
    v16;
  }

  else
  {
    v17 = ~v6;
    v28 = ~v10;
    v29 = v8;
    v18 = *(v4 + 16);
    v19 = a1;
    v30 = *(*(v8 - 8) + 64);
    v31 = v13;
    v18(a1, a2, v3);
    v20 = (a1 + v7) & v17;
    v21 = (a2 + v7) & v17;
    v18(v20, v21, v3);
    v22 = (v20 + v11) & v28;
    v23 = (v21 + v11) & v28;
    (*(v9 + 16))(v22, v23, v29);
    v24 = (v30 + 7 + v23) & 0xFFFFFFFFFFFFFFF8;
    v25 = *(v24 + 8);
    v26 = (v30 + 7 + v22) & 0xFFFFFFFFFFFFFFF8;
    *v26 = *v24;
    *(v26 + 8) = v25;
    v18(((v12 + v26) & v17), ((v12 + v24) & v17), v3);
    *(v26 + v31) = *(v24 + v31);
  }

  return v19;
}

uint64_t destroy for StrideToIterator(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v5 = *(v4 - 8);
  v15 = *(v5 + 8);
  v15(a1, v4);
  v6 = *(v5 + 64);
  v7 = *(v5 + 80);
  v8 = (v6 + a1 + v7) & ~v7;
  v15(v8, v4);
  swift_getAssociatedTypeWitness(0, *(a2 + 24), v4, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v10 = *(v9 - 8);
  v11 = v10 + 8;
  v12 = (v8 + v6 + *(v10 + 80)) & ~*(v10 + 80);
  (*(v10 + 8))(v12, v9);
  v13 = (v7 + ((*(v11 + 56) + (v7 | 7) + v12) & ~(v7 | 7)) + 9) & ~v7;

  return v15(v13, v4);
}

uint64_t initializeWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 16);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 16;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 16))(v16, v17, v12);
  v18 = *(v14 + 48) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(v19 + ((v10 + 9) & ~v10) + v9) = *(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 24);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 24;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 24))(v16, v17, v12);
  v18 = *(v14 + 40) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(v19 + ((v10 + 9) & ~v10) + v9) = *(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t initializeWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 32);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 32;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 32))(v16, v17, v12);
  v18 = *(v14 + 32) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(v19 + ((v10 + 9) & ~v10) + v9) = *(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 40);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v13 = *(v12 - 8);
  v14 = v13 + 40;
  v15 = *(v13 + 80);
  v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  v17 = (v9 + v15 + v11) & ~v15;
  (*(v13 + 40))(v16, v17, v12);
  v18 = *(v14 + 24) + (v10 | 7);
  v19 = (v18 + v16) & ~(v10 | 7);
  v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(v20 + 8);
  *v19 = *v20;
  *(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(v19 + ((v10 + 9) & ~v10) + v9) = *(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideThroughIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v9 = v6;
  v10 = *(v8 - 8);
  v11 = *(v10 + 84);
  v12 = *(v6 + 64);
  if (v11 <= v7)
  {
    v13 = v7;
  }

  else
  {
    v13 = *(v10 + 84);
  }

  v14 = *(v9 + 80);
  v15 = *(v10 + 80);
  if (v13 <= 0xFE)
  {
    v13 = 254;
  }

  if (!a2)
  {
    return 0;
  }

  v16 = v12 + v14;
  v17 = v14 | 7;
  v18 = (v14 | 7) + *(*(v8 - 8) + 64);
  v19 = ((v14 + 9) & ~v14) + v12;
  if (a2 > v13)
  {
    v20 = v19 + ((v18 + ((v12 + v15 + (v16 & ~v14)) & ~v15)) & ~v17) + 1;
    v21 = 8 * v20;
    if (v20 > 3)
    {
      goto LABEL_9;
    }

    v23 = ((a2 - v13 + ~(-1 << v21)) >> v21) + 1;
    if (HIWORD(v23))
    {
      v22 = *(a1 + v20);
      if (!v22)
      {
        goto LABEL_29;
      }

      goto LABEL_16;
    }

    if (v23 > 0xFF)
    {
      v22 = *(a1 + v20);
      if (!*(a1 + v20))
      {
        goto LABEL_29;
      }

      goto LABEL_16;
    }

    if (v23 >= 2)
    {
LABEL_9:
      v22 = *(a1 + v20);
      if (!*(a1 + v20))
      {
        goto LABEL_29;
      }

LABEL_16:
      v24 = (v22 - 1) << v21;
      if (v20 > 3)
      {
        v24 = 0;
      }

      if (v20)
      {
        if (v20 <= 3)
        {
          v25 = v20;
        }

        else
        {
          v25 = 4;
        }

        if (v25 > 2)
        {
          if (v25 == 3)
          {
            v26 = *a1 | (*(a1 + 2) << 16);
          }

          else
          {
            v26 = *a1;
          }
        }

        else if (v25 == 1)
        {
          v26 = *a1;
        }

        else
        {
          v26 = *a1;
        }
      }

      else
      {
        v26 = 0;
      }

      v32 = v13 + (v26 | v24);
      return (v32 + 1);
    }
  }

LABEL_29:
  if (v7 == v13)
  {
    v27 = *(v9 + 48);

    return v27(a1, v7, v5);
  }

  v29 = (((a1 + v16) & ~v14) + v12 + v15) & ~v15;
  if (v11 != v13)
  {
    v31 = *(((v18 + v29) & ~v17) + v19);
    if (v31 < 2)
    {
      return 0;
    }

    v32 = (v31 + 2147483646) & 0x7FFFFFFF;
    return (v32 + 1);
  }

  v30 = *(v10 + 48);

  return v30(v29);
}

void storeEnumTagSinglePayload for StrideThroughIterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v11 = v8;
  v12 = *(v10 - 8);
  v13 = *(v12 + 84);
  v14 = *(v8 + 64);
  if (v13 <= v9)
  {
    v15 = v9;
  }

  else
  {
    v15 = *(v12 + 84);
  }

  v16 = *(v11 + 80);
  v17 = *(v12 + 80);
  if (v15 <= 0xFE)
  {
    v15 = 254;
  }

  v18 = (v16 | 7) + *(*(v10 - 8) + 64);
  v19 = ((v16 + 9) & ~v16) + v14;
  v20 = v19 + ((v18 + ((v14 + v17 + ((v14 + v16) & ~v16)) & ~v17)) & ~(v16 | 7)) + 1;
  if (a3 <= v15)
  {
    v21 = 0;
  }

  else if (v20 <= 3)
  {
    v24 = ((a3 - v15 + ~(-1 << (8 * v20))) >> (8 * v20)) + 1;
    if (HIWORD(v24))
    {
      v21 = 4;
    }

    else
    {
      if (v24 < 0x100)
      {
        v25 = 1;
      }

      else
      {
        v25 = 2;
      }

      if (v24 >= 2)
      {
        v21 = v25;
      }

      else
      {
        v21 = 0;
      }
    }
  }

  else
  {
    v21 = 1;
  }

  if (v15 < a2)
  {
    v22 = ~v15 + a2;
    if (v20 < 4)
    {
      v23 = (v22 >> (8 * v20)) + 1;
      if (v19 + ((v18 + ((v14 + v17 + ((v14 + v16) & ~v16)) & ~v17)) & ~(v16 | 7)) != -1)
      {
        v26 = v22 & ~(-1 << (8 * v20));
        bzero(a1, v20);
        if (v20 != 3)
        {
          if (v20 == 2)
          {
            *a1 = v26;
            if (v21 > 1)
            {
LABEL_50:
              if (v21 == 2)
              {
                *&a1[v20] = v23;
              }

              else
              {
                *&a1[v20] = v23;
              }

              return;
            }
          }

          else
          {
            *a1 = v22;
            if (v21 > 1)
            {
              goto LABEL_50;
            }
          }

          goto LABEL_47;
        }

        *a1 = v26;
        a1[2] = BYTE2(v26);
      }

      if (v21 > 1)
      {
        goto LABEL_50;
      }
    }

    else
    {
      bzero(a1, v20);
      *a1 = v22;
      v23 = 1;
      if (v21 > 1)
      {
        goto LABEL_50;
      }
    }

LABEL_47:
    if (v21)
    {
      a1[v20] = v23;
    }

    return;
  }

  if (v21 > 1)
  {
    if (v21 != 2)
    {
      *&a1[v20] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_33;
    }

    *&a1[v20] = 0;
  }

  else if (v21)
  {
    a1[v20] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_33;
  }

  if (!a2)
  {
    return;
  }

LABEL_33:
  if (v9 == v15)
  {
    v27 = *(v11 + 56);

    v27(a1, a2, v9, v7);
  }

  else
  {
    v28 = ((&a1[v14 + v16] & ~v16) + v14 + v17) & ~v17;
    if (v13 == v15)
    {
      v29 = *(v12 + 56);

      v29(v28, a2);
    }

    else
    {
      *(((v18 + v28) & ~(v16 | 7)) + v19) = a2 + 1;
    }
  }
}

unint64_t type metadata completion function for StrideTo(uint64_t a1)
{
  v2 = swift_checkMetadataState(319, *(a1 + 16));
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 8) + 64;
    v8[1] = v8[0];
    swift_getAssociatedTypeWitness(319, *(a1 + 24), v2, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    v3 = v5;
    if (v6 <= 0x3F)
    {
      v8[2] = *(v5 - 8) + 64;
      swift_initStructMetadata(a1, 0, 3uLL, v8, a1 + 32);
      return 0;
    }
  }

  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideTo(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  v5 = *(v4 - 8);
  v6 = *(v5 + 64);
  v7 = *(v5 + 80);
  v8 = v6 + v7;
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v4, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v10 = *(v9 - 8);
  v11 = *(v10 + 80);
  v12 = v6 + v11;
  if ((v11 | v7) > 7 || ((*(v10 + 80) | v7) & 0x100000) != 0 || ((v12 + (v8 & ~v7)) & ~v11) + *(*(v9 - 8) + 64) > 0x18)
  {
    v15 = *a2;
    *a1 = *a2;
    a1 = (v15 + (((v11 | v7) + 16) & ~(v11 | v7)));
    v15;
  }

  else
  {
    v20 = v9;
    v21 = ~v11;
    v16 = *(v5 + 16);
    v16(a1, a2, v4);
    v17 = (a1 + v8) & ~v7;
    v18 = (a2 + v8) & ~v7;
    v16(v17, v18, v4);
    (*(v10 + 16))((v17 + v12) & v21, (v18 + v12) & v21, v20);
  }

  return a1;
}

uint64_t destroy for StrideTo(unint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  v5 = *(v4 - 8);
  v6 = *(v5 + 8);
  v6(a1, v4);
  v7 = *(v5 + 64);
  v8 = (v7 + a1 + *(v5 + 80)) & ~*(v5 + 80);
  v6(v8, v4);
  swift_getAssociatedTypeWitness(0, *(a2 + 24), v4, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v10 = v9;
  v11 = *(v9 - 8);
  v12 = *(v11 + 8);
  v13 = (v8 + v7 + *(v11 + 80)) & ~*(v11 + 80);

  return v12(v13, v10);
}

uint64_t initializeWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 16);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a1) & ~v10;
  v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v14 = *(v13 - 8);
  (*(v14 + 16))((v9 + *(v14 + 80) + v11) & ~*(v14 + 80), (v9 + *(v14 + 80) + v12) & ~*(v14 + 80), v13);
  return a1;
}

uint64_t assignWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 24);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a1) & ~v10;
  v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v14 = *(v13 - 8);
  (*(v14 + 24))((v9 + *(v14 + 80) + v11) & ~*(v14 + 80), (v9 + *(v14 + 80) + v12) & ~*(v14 + 80), v13);
  return a1;
}

uint64_t initializeWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 32);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a1) & ~v10;
  v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v14 = *(v13 - 8);
  (*(v14 + 32))((v9 + *(v14 + 80) + v11) & ~*(v14 + 80), (v9 + *(v14 + 80) + v12) & ~*(v14 + 80), v13);
  return a1;
}

uint64_t assignWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(a3 + 16);
  v7 = *(v6 - 8);
  v8 = *(v7 + 40);
  v8(a1, a2, v6);
  v9 = *(v7 + 64);
  v10 = *(v7 + 80);
  v11 = (v9 + v10 + a1) & ~v10;
  v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v6, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v14 = *(v13 - 8);
  (*(v14 + 40))((v9 + *(v14 + 80) + v11) & ~*(v14 + 80), (v9 + *(v14 + 80) + v12) & ~*(v14 + 80), v13);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideTo(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 24), v5, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v6 + 64);
  v12 = *(v6 + 80);
  v13 = *(v9 + 80);
  if (v10 <= v7)
  {
    v14 = v7;
  }

  else
  {
    v14 = *(v9 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v15 = v11 + v12;
  if (a2 <= v14)
  {
    goto LABEL_28;
  }

  v16 = ((v11 + v13 + (v15 & ~v12)) & ~v13) + *(*(v8 - 8) + 64);
  v17 = 8 * v16;
  if (v16 <= 3)
  {
    v19 = ((a2 - v14 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      v18 = *(a1 + v16);
      if (!v18)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 > 0xFF)
    {
      v18 = *(a1 + v16);
      if (!*(a1 + v16))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v19 < 2)
    {
LABEL_27:
      if (v14)
      {
LABEL_28:
        if (v7 >= v10)
        {
          v25 = *(v6 + 48);

          return v25(a1, v7, v5);
        }

        else
        {
          v23 = *(v9 + 48);

          return v23((((a1 + v15) & ~v12) + v11 + v13) & ~v13);
        }
      }

      return 0;
    }
  }

  v18 = *(a1 + v16);
  if (!*(a1 + v16))
  {
    goto LABEL_27;
  }

LABEL_14:
  v20 = (v18 - 1) << v17;
  if (v16 > 3)
  {
    v20 = 0;
  }

  if (v16)
  {
    if (v16 <= 3)
    {
      v21 = v16;
    }

    else
    {
      v21 = 4;
    }

    if (v21 > 2)
    {
      if (v21 == 3)
      {
        v22 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v22 = *a1;
      }
    }

    else if (v21 == 1)
    {
      v22 = *a1;
    }

    else
    {
      v22 = *a1;
    }
  }

  else
  {
    v22 = 0;
  }

  return v14 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for StrideTo(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  v7 = *(a4 + 16);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 24), v7, &protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v11 = v8;
  v12 = *(v10 - 8);
  v13 = *(v12 + 84);
  v14 = *(v8 + 64);
  if (v13 <= v9)
  {
    v15 = v9;
  }

  else
  {
    v15 = *(v12 + 84);
  }

  v16 = *(v11 + 80);
  v17 = *(v12 + 80);
  v18 = ((v14 + v17 + ((v14 + v16) & ~v16)) & ~v17) + *(*(v10 - 8) + 64);
  if (a3 <= v15)
  {
    v19 = 0;
  }

  else if (v18 <= 3)
  {
    v22 = ((a3 - v15 + ~(-1 << (8 * v18))) >> (8 * v18)) + 1;
    if (HIWORD(v22))
    {
      v19 = 4;
    }

    else
    {
      if (v22 < 0x100)
      {
        v23 = 1;
      }

      else
      {
        v23 = 2;
      }

      if (v22 >= 2)
      {
        v19 = v23;
      }

      else
      {
        v19 = 0;
      }
    }
  }

  else
  {
    v19 = 1;
  }

  if (v15 < a2)
  {
    v20 = ~v15 + a2;
    if (v18 < 4)
    {
      v21 = (v20 >> (8 * v18)) + 1;
      if (v18)
      {
        v24 = v20 & ~(-1 << (8 * v18));
        bzero(a1, v18);
        if (v18 != 3)
        {
          if (v18 == 2)
          {
            *a1 = v24;
            if (v19 > 1)
            {
LABEL_46:
              if (v19 == 2)
              {
                *&a1[v18] = v21;
              }

              else
              {
                *&a1[v18] = v21;
              }

              return;
            }
          }

          else
          {
            *a1 = v20;
            if (v19 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *a1 = v24;
        a1[2] = BYTE2(v24);
      }

      if (v19 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      bzero(a1, v18);
      *a1 = v20;
      v21 = 1;
      if (v19 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v19)
    {
      a1[v18] = v21;
    }

    return;
  }

  if (v19 > 1)
  {
    if (v19 != 2)
    {
      *&a1[v18] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_31;
    }

    *&a1[v18] = 0;
  }

  else if (v19)
  {
    a1[v18] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return;
  }

LABEL_31:
  if (v9 >= v13)
  {
    v26 = *(v11 + 56);

    v26(a1, a2, v9, v7);
  }

  else
  {
    v25 = *(v12 + 56);

    v25(((&a1[v14 + v16] & ~v16) + v14 + v17) & ~v17, a2);
  }
}

uint64_t initializeWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  v3 = *(a2 + 24);
  v4 = *(a2 + 32);
  outlined copy of _StringRepresentation._Form(v3, v4);
  *(a1 + 24) = v3;
  *(a1 + 32) = v4;
  return a1;
}

uint64_t assignWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  v3 = *(a2 + 24);
  v4 = *(a2 + 32);
  outlined copy of _StringRepresentation._Form(v3, v4);
  v5 = *(a1 + 24);
  *(a1 + 24) = v3;
  v6 = *(a1 + 32);
  *(a1 + 32) = v4;
  outlined consume of _StringRepresentation._Form(v5, v6);
  return a1;
}

__n128 __swift_memcpy33_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  *(a1 + 32) = *(a2 + 32);
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  v3 = *(a2 + 32);
  v4 = *(a1 + 24);
  *(a1 + 24) = *(a2 + 24);
  v5 = *(a1 + 32);
  *(a1 + 32) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFF && a1[33])
  {
    return (*a1 + 255);
  }

  v3 = *a1;
  v4 = v3 >= 2;
  v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4)
  {
    v5 = -1;
  }

  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *(result + 32) = 0;
    *result = a2 - 255;
    *(result + 8) = 0;
    if (a3 >= 0xFF)
    {
      *(result + 33) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF)
    {
      *(result + 33) = 0;
    }

    if (a2)
    {
      *result = a2 + 1;
    }
  }

  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  outlined copy of _StringRepresentation._Form(*a2, v4);
  *a1 = v3;
  *(a1 + 8) = v4;
  return a1;
}

uint64_t assignWithCopy for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  v4 = *(a2 + 8);
  outlined copy of _StringRepresentation._Form(*a2, v4);
  v5 = *a1;
  *a1 = v3;
  v6 = *(a1 + 8);
  *(a1 + 8) = v4;
  outlined consume of _StringRepresentation._Form(v5, v6);
  return a1;
}

uint64_t __swift_memcpy9_8(uint64_t result, uint64_t *a2)
{
  v2 = *a2;
  *(result + 8) = *(a2 + 8);
  *result = v2;
  return result;
}

uint64_t assignWithTake for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  v4 = *a1;
  *a1 = *a2;
  v5 = *(a1 + 8);
  *(a1 + 8) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation._Form(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFD && *(a1 + 9))
  {
    return (*a1 + 253);
  }

  v3 = *(a1 + 8);
  if (v3 <= 3)
  {
    v4 = -1;
  }

  else
  {
    v4 = v3 ^ 0xFF;
  }

  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation._Form(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(result + 8) = 0;
    *result = a2 - 253;
    if (a3 >= 0xFD)
    {
      *(result + 9) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD)
    {
      *(result + 9) = 0;
    }

    if (a2)
    {
      *(result + 8) = -a2;
    }
  }

  return result;
}

uint64_t getEnumTag for _StringRepresentation._Form(uint64_t a1)
{
  if (*(a1 + 8) <= 2u)
  {
    return *(a1 + 8);
  }

  else
  {
    return (*a1 + 3);
  }
}

uint64_t destructiveInjectEnumTag for _StringRepresentation._Form(uint64_t result, unsigned int a2)
{
  if (a2 >= 3)
  {
    *result = a2 - 3;
    LOBYTE(a2) = 3;
  }

  *(result + 8) = a2;
  return result;
}

uint64_t initializeWithCopy for String.Iterator(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v3;
  *(a1 + 16) = *(a2 + 16);
  v3;
  return a1;
}

void *assignWithCopy for String.Iterator(void *a1, void *a2)
{
  *a1 = *a2;
  v4 = a2[1];
  v5 = a1[1];
  a1[1] = v4;
  v4;
  v5;
  a1[2] = a2[2];
  a1[3] = a2[3];
  return a1;
}

uint64_t assignWithTake for String.Iterator(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *a1 = *a2;
  *(a1 + 8) = v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.Iterator(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 32))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = (a2 - 1);
      return result;
    }

    *(result + 32) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t initializeWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v3;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 34) = *(a2 + 34);
  v3;
  return a1;
}

uint64_t assignWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *(a1 + 8) = v4;
  v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  v6 = *(a2 + 32);
  *(a1 + 34) = *(a2 + 34);
  *(a1 + 32) = v6;
  return a1;
}

__n128 __swift_memcpy35_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  *(a1 + 31) = *(a2 + 31);
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *a1 = *a2;
  *(a1 + 8) = v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 34) = *(a2 + 34);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 35))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *(result + 34) = 0;
    *(result + 32) = 0;
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 35) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = (a2 - 1);
      return result;
    }

    *(result + 35) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

void *assignWithCopy for Character(void *a1, void *a2)
{
  *a1 = *a2;
  v3 = a2[1];
  v4 = a1[1];
  a1[1] = v3;
  v3;
  v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for Character(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 16))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Character(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 16) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = (a2 - 1);
      return result;
    }

    *(result + 16) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  v2 = *a2;
  *(result + 4) = *(a2 + 4);
  *result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 5))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 4) = 0;
    *result = a2 - 1;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 5) = v3;
  return result;
}

uint64_t type metadata completion function for Unicode.ParseResult(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 8) + 64;
    v4[1] = &value witness table for Builtin.Int64.size;
    swift_initEnumMetadataMultiPayload(a1, 0, 2u, v4);
    return 0;
  }

  return result;
}

char *initializeBufferWithCopyOfBuffer for Unicode.ParseResult(char *result, unsigned __int16 *a2, uint64_t a3)
{
  v3 = *(*(a3 + 16) - 8);
  if (*(v3 + 64) <= 8uLL)
  {
    v4 = 8;
  }

  else
  {
    v4 = *(*(*(a3 + 16) - 8) + 64);
  }

  v5 = *(v3 + 80);
  if ((v5 & 0x1000F8) != 0 || (v4 + 1) > 0x18)
  {
    v7 = *a2;
    *result = *a2;
    v8 = v7 + (((v5 & 0xF8) + 23) & ~(v5 & 0xF8) & 0x1F8);
    v7;
    return v8;
  }

  v9 = *(a2 + v4);
  v10 = v9 - 2;
  if (v9 >= 2)
  {
    if (v4 <= 3)
    {
      v11 = v4;
    }

    else
    {
      v11 = 4;
    }

    if (v11 > 1)
    {
      if (v11 == 2)
      {
        v12 = *a2;
      }

      else if (v11 == 3)
      {
        v12 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v12 = *a2;
      }

LABEL_22:
      v13 = (v12 | (v10 << (8 * v4))) + 2;
      v9 = v12 + 2;
      if (v4 < 4)
      {
        v9 = v13;
      }

      goto LABEL_24;
    }

    if (v11)
    {
      v12 = *a2;
      goto LABEL_22;
    }
  }

LABEL_24:
  if (v9 == 1)
  {
    *result = *a2;
    result[v4] = 1;
  }

  else if (v9)
  {

    return memcpy(result, a2, v4 + 1);
  }

  else
  {
    v14 = result;
    (*(v3 + 16))();
    result = v14;
    v14[v4] = 0;
  }

  return result;
}

unsigned __int8 *destroy for Unicode.ParseResult(unsigned __int8 *result, uint64_t a2)
{
  v2 = *(*(*(a2 + 16) - 8) + 64);
  if (v2 <= 8)
  {
    v2 = 8;
  }

  v3 = result[v2];
  v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (v2 <= 3)
    {
      v5 = v2;
    }

    else
    {
      v5 = 4;
    }

    if (v5 <= 1)
    {
      if (!v5)
      {
        return result;
      }

      v6 = *result;
    }

    else if (v5 == 2)
    {
      v6 = *result;
    }

    else if (v5 == 3)
    {
      v6 = *result | (result[2] << 16);
    }

    else
    {
      v6 = *result;
    }

    v7 = (v6 | (v4 << (8 * v2))) + 2;
    v3 = v6 + 2;
    if (v2 < 4)
    {
      v3 = v7;
    }
  }

  if (!v3)
  {
    return (*(*(*(a2 + 16) - 8) + 8))();
  }

  return result;
}

void *initializeWithCopy for Unicode.ParseResult(void *result, unsigned __int8 *a2, uint64_t a3)
{
  if (*(*(*(a3 + 16) - 8) + 64) <= 8uLL)
  {
    v3 = 8;
  }

  else
  {
    v3 = *(*(*(a3 + 16) - 8) + 64);
  }

  v4 = a2[v3];
  v5 = v4 - 2;
  if (v4 >= 2)
  {
    if (v3 <= 3)
    {
      v6 = v3;
    }

    else
    {
      v6 = 4;
    }

    if (v6 <= 1)
    {
      if (!v6)
      {
        goto LABEL_18;
      }

      v7 = *a2;
    }

    else if (v6 == 2)
    {
      v7 = *a2;
    }

    else if (v6 == 3)
    {
      v7 = *a2 | (a2[2] << 16);
    }

    else
    {
      v7 = *a2;
    }

    v8 = (v7 | (v5 << (8 * v3))) + 2;
    v4 = v7 + 2;
    if (v3 < 4)
    {
      v4 = v8;
    }
  }

LABEL_18:
  if (v4 == 1)
  {
    *result = *a2;
    *(result + v3) = 1;
  }

  else if (v4)
  {

    return memcpy(result, a2, v3 + 1);
  }

  else
  {
    v9 = result;
    (*(*(*(a3 + 16) - 8) + 16))();
    result = v9;
    *(v9 + v3) = 0;
  }

  return result;
}

unsigned __int8 *assignWithCopy for Unicode.ParseResult(unsigned __int8 *result, unsigned __int16 *a2, uint64_t a3)
{
  if (result == a2)
  {
    return result;
  }

  v3 = *(*(a3 + 16) - 8);
  if (*(v3 + 64) <= 8uLL)
  {
    v4 = 8;
  }

  else
  {
    v4 = *(v3 + 64);
  }

  v5 = result[v4];
  v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3)
    {
      v7 = v4;
    }

    else
    {
      v7 = 4;
    }

    if (v7 <= 1)
    {
      if (!v7)
      {
        goto LABEL_21;
      }

      v8 = *result;
    }

    else if (v7 == 2)
    {
      v8 = *result;
    }

    else if (v7 == 3)
    {
      v8 = *result | (result[2] << 16);
    }

    else
    {
      v8 = *result;
    }

    v9 = (v8 | (v6 << (8 * v4))) + 2;
    v5 = v8 + 2;
    if (v4 < 4)
    {
      v5 = v9;
    }
  }

  if (!v5)
  {
    v10 = result;
    v11 = a2;
    (*(v3 + 8))();
    a2 = v11;
    result = v10;
  }

LABEL_21:
  v12 = *(a2 + v4);
  v13 = v12 - 2;
  if (v12 >= 2)
  {
    if (v4 <= 3)
    {
      v14 = v4;
    }

    else
    {
      v14 = 4;
    }

    if (v14 > 1)
    {
      if (v14 == 2)
      {
        v15 = *a2;
      }

      else if (v14 == 3)
      {
        v15 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v15 = *a2;
      }

LABEL_33:
      v16 = (v15 | (v13 << (8 * v4))) + 2;
      v12 = v15 + 2;
      if (v4 < 4)
      {
        v12 = v16;
      }

      goto LABEL_35;
    }

    if (v14)
    {
      v15 = *a2;
      goto LABEL_33;
    }
  }

LABEL_35:
  if (v12 == 1)
  {
    *result = *a2;
    result[v4] = 1;
  }

  else if (v12)
  {

    return memcpy(result, a2, v4 + 1);
  }

  else
  {
    v17 = result;
    (*(v3 + 16))();
    result = v17;
    v17[v4] = 0;
  }

  return result;
}

void *initializeWithTake for Unicode.ParseResult(void *result, unsigned __int8 *a2, uint64_t a3)
{
  if (*(*(*(a3 + 16) - 8) + 64) <= 8uLL)
  {
    v3 = 8;
  }

  else
  {
    v3 = *(*(*(a3 + 16) - 8) + 64);
  }

  v4 = a2[v3];
  v5 = v4 - 2;
  if (v4 >= 2)
  {
    if (v3 <= 3)
    {
      v6 = v3;
    }

    else
    {
      v6 = 4;
    }

    if (v6 <= 1)
    {
      if (!v6)
      {
        goto LABEL_18;
      }

      v7 = *a2;
    }

    else if (v6 == 2)
    {
      v7 = *a2;
    }

    else if (v6 == 3)
    {
      v7 = *a2 | (a2[2] << 16);
    }

    else
    {
      v7 = *a2;
    }

    v8 = (v7 | (v5 << (8 * v3))) + 2;
    v4 = v7 + 2;
    if (v3 < 4)
    {
      v4 = v8;
    }
  }

LABEL_18:
  if (v4 == 1)
  {
    *result = *a2;
    *(result + v3) = 1;
  }

  else if (v4)
  {

    return memcpy(result, a2, v3 + 1);
  }

  else
  {
    v9 = result;
    (*(*(*(a3 + 16) - 8) + 32))();
    result = v9;
    *(v9 + v3) = 0;
  }

  return result;
}

unsigned __int8 *assignWithTake for Unicode.ParseResult(unsigned __int8 *result, unsigned __int16 *a2, uint64_t a3)
{
  if (result == a2)
  {
    return result;
  }

  v3 = *(*(a3 + 16) - 8);
  if (*(v3 + 64) <= 8uLL)
  {
    v4 = 8;
  }

  else
  {
    v4 = *(v3 + 64);
  }

  v5 = result[v4];
  v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3)
    {
      v7 = v4;
    }

    else
    {
      v7 = 4;
    }

    if (v7 <= 1)
    {
      if (!v7)
      {
        goto LABEL_21;
      }

      v8 = *result;
    }

    else if (v7 == 2)
    {
      v8 = *result;
    }

    else if (v7 == 3)
    {
      v8 = *result | (result[2] << 16);
    }

    else
    {
      v8 = *result;
    }

    v9 = (v8 | (v6 << (8 * v4))) + 2;
    v5 = v8 + 2;
    if (v4 < 4)
    {
      v5 = v9;
    }
  }

  if (!v5)
  {
    v10 = result;
    v11 = a2;
    (*(v3 + 8))();
    a2 = v11;
    result = v10;
  }

LABEL_21:
  v12 = *(a2 + v4);
  v13 = v12 - 2;
  if (v12 >= 2)
  {
    if (v4 <= 3)
    {
      v14 = v4;
    }

    else
    {
      v14 = 4;
    }

    if (v14 > 1)
    {
      if (v14 == 2)
      {
        v15 = *a2;
      }

      else if (v14 == 3)
      {
        v15 = *a2 | (*(a2 + 2) << 16);
      }

      else
      {
        v15 = *a2;
      }

LABEL_33:
      v16 = (v15 | (v13 << (8 * v4))) + 2;
      v12 = v15 + 2;
      if (v4 < 4)
      {
        v12 = v16;
      }

      goto LABEL_35;
    }

    if (v14)
    {
      v15 = *a2;
      goto LABEL_33;
    }
  }

LABEL_35:
  if (v12 == 1)
  {
    *result = *a2;
    result[v4] = 1;
  }

  else if (v12)
  {

    return memcpy(result, a2, v4 + 1);
  }

  else
  {
    v17 = result;
    (*(v3 + 32))();
    result = v17;
    v17[v4] = 0;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Unicode.ParseResult(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v3 = *(*(a3 + 16) - 8);
  v4 = 8;
  if (*(v3 + 64) > 8uLL)
  {
    v4 = *(v3 + 64);
  }

  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFE)
  {
    goto LABEL_25;
  }

  v5 = v4 + 1;
  v6 = 8 * (v4 + 1);
  if ((v4 + 1) <= 3)
  {
    v9 = ((a2 + ~(-1 << v6) - 253) >> v6) + 1;
    if (HIWORD(v9))
    {
      v7 = *(a1 + v5);
      if (!v7)
      {
        goto LABEL_25;
      }

      goto LABEL_14;
    }

    if (v9 > 0xFF)
    {
      v7 = *(a1 + v5);
      if (!*(a1 + v5))
      {
        goto LABEL_25;
      }

      goto LABEL_14;
    }

    if (v9 < 2)
    {
LABEL_25:
      v11 = *(a1 + v4);
      if (v11 >= 3)
      {
        return (v11 ^ 0xFF) + 1;
      }

      else
      {
        return 0;
      }
    }
  }

  v7 = *(a1 + v5);
  if (!*(a1 + v5))
  {
    goto LABEL_25;
  }

LABEL_14:
  v10 = (v7 - 1) << v6;
  if (v5 > 3)
  {
    v10 = 0;
  }

  if (v5)
  {
    if (v5 > 3)
    {
      LODWORD(v5) = 4;
    }

    if (v5 > 2)
    {
      if (v5 == 3)
      {
        LODWORD(v5) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v5) = *a1;
      }
    }

    else if (v5 == 1)
    {
      LODWORD(v5) = *a1;
    }

    else
    {
      LODWORD(v5) = *a1;
    }
  }

  return (v5 | v10) + 254;
}

void storeEnumTagSinglePayload for Unicode.ParseResult(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(*(a4 + 16) - 8) + 64);
  if (v5 <= 8)
  {
    v5 = 8;
  }

  v6 = v5 + 1;
  if (a3 < 0xFE)
  {
    v7 = 0;
  }

  else if (v6 <= 3)
  {
    v10 = ((a3 + ~(-1 << (8 * v6)) - 253) >> (8 * v6)) + 1;
    if (HIWORD(v10))
    {
      v7 = 4;
    }

    else
    {
      if (v10 < 0x100)
      {
        v11 = 1;
      }

      else
      {
        v11 = 2;
      }

      if (v10 >= 2)
      {
        v7 = v11;
      }

      else
      {
        v7 = 0;
      }
    }
  }

  else
  {
    v7 = 1;
  }

  if (a2 > 0xFD)
  {
    v8 = a2 - 254;
    if (v6 >= 4)
    {
      bzero(a1, v5 + 1);
      *a1 = v8;
      v9 = 1;
      if (v7 > 1)
      {
        goto LABEL_39;
      }

      goto LABEL_36;
    }

    v9 = (v8 >> (8 * v6)) + 1;
    if (v5 != -1)
    {
      v12 = v8 & ~(-1 << (8 * v6));
      bzero(a1, v6);
      if (v6 != 3)
      {
        if (v6 == 2)
        {
          *a1 = v12;
          if (v7 > 1)
          {
LABEL_39:
            if (v7 == 2)
            {
              *&a1[v6] = v9;
            }

            else
            {
              *&a1[v6] = v9;
            }

            return;
          }
        }

        else
        {
          *a1 = v8;
          if (v7 > 1)
          {
            goto LABEL_39;
          }
        }

LABEL_36:
        if (v7)
        {
          a1[v6] = v9;
        }

        return;
      }

      *a1 = v12;
      a1[2] = BYTE2(v12);
    }

    if (v7 > 1)
    {
      goto LABEL_39;
    }

    goto LABEL_36;
  }

  if (v7 <= 1)
  {
    if (v7)
    {
      a1[v6] = 0;
      if (!a2)
      {
        return;
      }

LABEL_25:
      a1[v5] = -a2;
      return;
    }

LABEL_24:
    if (!a2)
    {
      return;
    }

    goto LABEL_25;
  }

  if (v7 == 2)
  {
    *&a1[v6] = 0;
    goto LABEL_24;
  }

  *&a1[v6] = 0;
  if (a2)
  {
    goto LABEL_25;
  }
}

uint64_t getEnumTag for Unicode.ParseResult(unsigned __int8 *a1, uint64_t a2)
{
  v2 = *(*(a2 + 16) - 8);
  v3 = 8;
  if (*(v2 + 64) > 8uLL)
  {
    v3 = *(v2 + 64);
  }

  v4 = a1[v3];
  v5 = v4 - 2;
  if (v4 >= 2)
  {
    if (v3 <= 3)
    {
      v6 = v3;
    }

    else
    {
      v6 = 4;
    }

    if (v6 <= 1)
    {
      if (!v6)
      {
        return v4;
      }

      v7 = *a1;
    }

    else if (v6 == 2)
    {
      v7 = *a1;
    }

    else if (v6 == 3)
    {
      v7 = *a1 | (a1[2] << 16);
    }

    else
    {
      v7 = *a1;
    }

    v8 = (v7 | (v5 << (8 * v3))) + 2;
    LODWORD(v4) = v7 + 2;
    if (v3 >= 4)
    {
      return v4;
    }

    else
    {
      return v8;
    }
  }

  return v4;
}

void destructiveInjectEnumTag for Unicode.ParseResult(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  if (*(*(*(a3 + 16) - 8) + 64) <= 8uLL)
  {
    v3 = 8;
  }

  else
  {
    v3 = *(*(*(a3 + 16) - 8) + 64);
  }

  if (a2 > 1)
  {
    v4 = a2 - 2;
    if (v3 < 4)
    {
      a1[v3] = (v4 >> (8 * v3)) + 2;
      if (v3)
      {
        v6 = v4 & ~(-1 << (8 * v3));
        bzero(a1, v3);
        if (v3 == 3)
        {
          *a1 = v6;
          a1[2] = BYTE2(v6);
        }

        else if (v3 == 2)
        {
          *a1 = v6;
        }

        else
        {
          *a1 = v4;
        }
      }
    }

    else
    {
      a1[v3] = 2;
      bzero(a1, v3);
      *a1 = v4;
    }
  }

  else
  {
    a1[v3] = a2;
  }
}

uint64_t getEnumTagSinglePayload for Unicode.GeneralCategory(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xE3)
  {
    goto LABEL_17;
  }

  if (a2 + 29 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 29) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 29;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 29;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 29;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x1E;
  v8 = v6 - 30;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode.GeneralCategory(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 29 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 29) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xE3)
  {
    v4 = 0;
  }

  if (a2 > 0xE2)
  {
    v5 = ((a2 - 227) >> 8) + 1;
    *result = a2 + 29;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 29;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Unicode.CanonicalCombiningClass(unsigned __int8 *a1, int a2)
{
  if (a2)
  {
    if ((a2 + 255) >= 0xFFFF00)
    {
      v2 = 4;
    }

    else
    {
      v2 = 2;
    }

    if ((a2 + 255) >> 8 < 0xFF)
    {
      v3 = 1;
    }

    else
    {
      v3 = v2;
    }

    if (v3 == 4)
    {
      v4 = *(a1 + 1);
      if (v4)
      {
        return (*a1 | (v4 << 8)) - 255;
      }
    }

    else if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (*(a1 + 1))
      {
        return (*a1 | (v4 << 8)) - 255;
      }
    }

    else
    {
      v4 = a1[1];
      if (a1[1])
      {
        return (*a1 | (v4 << 8)) - 255;
      }
    }
  }

  return 0;
}

uint64_t storeEnumTagSinglePayload for Unicode.CanonicalCombiningClass(uint64_t result, int a2, int a3)
{
  if ((a3 + 255) >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 255) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (!a3)
  {
    v4 = 0;
  }

  if (a2)
  {
    v5 = ((a2 - 1) >> 8) + 1;
    *result = a2 - 1;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }
  }

  else if (v4 > 1)
  {
    if (v4 == 2)
    {
      *(result + 1) = 0;
    }

    else
    {
      *(result + 1) = 0;
    }
  }

  else if (v4)
  {
    *(result + 1) = 0;
  }

  return result;
}

void destroy for Unicode._NFD.Iterator(uint64_t a1)
{
  *(a1 + 24);
  v2 = *(a1 + 48);

  v2;
}

uint64_t initializeWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v3 = *(a2 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v3;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v4 = *(a2 + 48);
  *(a1 + 48) = v4;
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 60) = *(a2 + 60);
  *(a1 + 63) = *(a2 + 63);
  *(a1 + 67) = *(a2 + 67);
  v3;
  v4;
  return a1;
}

uint64_t assignWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  v4 = *(a2 + 24);
  v5 = *(a1 + 24);
  *(a1 + 24) = v4;
  v4;
  v5;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v6 = *(a2 + 48);
  v7 = *(a1 + 48);
  *(a1 + 48) = v6;
  v6;
  v7;
  *(a1 + 56) = *(a2 + 56);
  v8 = *(a2 + 60);
  *(a1 + 63) = *(a2 + 63);
  *(a1 + 60) = v8;
  *(a1 + 67) = *(a2 + 67);
  return a1;
}

__n128 __swift_memcpy68_8(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  result = *(a2 + 16);
  v3 = *(a2 + 32);
  v4 = *(a2 + 48);
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 32) = v3;
  *(a1 + 48) = v4;
  *(a1 + 16) = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 24);
  v5 = *(a1 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v4;
  v5;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v6 = *(a1 + 48);
  *(a1 + 48) = *(a2 + 48);
  v6;
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 60) = *(a2 + 60);
  *(a1 + 63) = *(a2 + 63);
  *(a1 + 67) = *(a2 + 67);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 68))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 56) = 0;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 64) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 68) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 24) = (a2 - 1);
      return result;
    }

    *(result + 68) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t initializeWithCopy for Substring(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v3 = *(a2 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v3;
  v3;
  return a1;
}

void *assignWithCopy for Substring(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  v3 = a2[3];
  v4 = a1[3];
  a1[3] = v3;
  v3;
  v4;
  return a1;
}

uint64_t assignWithTake for Substring(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v3 = *(a2 + 24);
  v4 = *(a1 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v3;
  v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for Substring(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 32))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Substring(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 24) = (a2 - 1);
      return result;
    }

    *(result + 32) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

void destroy for Unicode._NFC.Iterator(unint64_t *a1)
{
  a1[3];
  a1[7];
  v2 = a1[10];

  v2;
}

uint64_t initializeWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v3 = *(a2 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v3;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 41) = *(a2 + 41);
  *(a1 + 48) = *(a2 + 48);
  v4 = *(a2 + 56);
  *(a1 + 56) = v4;
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 68) = *(a2 + 68);
  *(a1 + 71) = *(a2 + 71);
  *(a1 + 75) = *(a2 + 75);
  v5 = *(a2 + 80);
  *(a1 + 80) = v5;
  *(a1 + 88) = *(a2 + 88);
  *(a1 + 92) = *(a2 + 92);
  *(a1 + 96) = *(a2 + 96);
  v3;
  v4;
  v5;
  return a1;
}

uint64_t assignWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  v4 = *(a2 + 24);
  v5 = *(a1 + 24);
  *(a1 + 24) = v4;
  v4;
  v5;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 41) = *(a2 + 41);
  *(a1 + 42) = *(a2 + 42);
  *(a1 + 48) = *(a2 + 48);
  v6 = *(a2 + 56);
  v7 = *(a1 + 56);
  *(a1 + 56) = v6;
  v6;
  v7;
  *(a1 + 64) = *(a2 + 64);
  v8 = *(a2 + 68);
  *(a1 + 71) = *(a2 + 71);
  *(a1 + 68) = v8;
  *(a1 + 75) = *(a2 + 75);
  v9 = *(a2 + 80);
  v10 = *(a1 + 80);
  *(a1 + 80) = v9;
  v9;
  v10;
  *(a1 + 88) = *(a2 + 88);
  v11 = *(a2 + 92);
  *(a1 + 96) = *(a2 + 96);
  *(a1 + 92) = v11;
  return a1;
}

__n128 __swift_memcpy97_8(uint64_t a1, __int128 *a2)
{
  v2 = *a2;
  v3 = a2[2];
  *(a1 + 16) = a2[1];
  *(a1 + 32) = v3;
  *a1 = v2;
  result = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(a1 + 96) = *(a2 + 96);
  *(a1 + 64) = v5;
  *(a1 + 80) = v6;
  *(a1 + 48) = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 24);
  v5 = *(a1 + 24);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = v4;
  v5;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 41) = *(a2 + 41);
  *(a1 + 42) = *(a2 + 42);
  *(a1 + 48) = *(a2 + 48);
  v6 = *(a1 + 56);
  *(a1 + 56) = *(a2 + 56);
  v6;
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 68) = *(a2 + 68);
  *(a1 + 71) = *(a2 + 71);
  *(a1 + 75) = *(a2 + 75);
  v7 = *(a1 + 80);
  *(a1 + 80) = *(a2 + 80);
  v7;
  *(a1 + 88) = *(a2 + 88);
  *(a1 + 92) = *(a2 + 92);
  *(a1 + 96) = *(a2 + 96);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 97))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 88) = 0;
    *(result + 72) = 0u;
    *(result + 56) = 0u;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 96) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 97) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 24) = (a2 - 1);
      return result;
    }

    *(result + 97) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for _BridgeableMetatype(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 8))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _BridgeableMetatype(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 8) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 8) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTag for UnicodeDecodingResult(uint64_t a1)
{
  if (*(a1 + 4))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t destructiveInjectEnumTag for UnicodeDecodingResult(uint64_t result, int a2)
{
  if (a2)
  {
    *result = a2 - 1;
    *(result + 4) = 1;
  }

  else
  {
    *(result + 4) = 0;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Unicode._CharacterRecognizer(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFF && *(a1 + 8))
  {
    return (*a1 + 255);
  }

  v3 = *(a1 + 4);
  v4 = v3 >= 2;
  v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4)
  {
    v5 = -1;
  }

  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._CharacterRecognizer(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *result = a2 - 255;
    if (a3 >= 0xFF)
    {
      *(result + 8) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF)
    {
      *(result + 8) = 0;
    }

    if (a2)
    {
      *(result + 4) = a2 + 1;
    }
  }

  return result;
}

void destroy for _PlaygroundQuickLook(uint64_t a1)
{
  v1 = *(a1 + 32);
  if (v1 >= 0x13)
  {
    v1 = *a1 + 19;
  }

  if (v1 <= 9)
  {
    if (v1 <= 4)
    {
      if ((v1 - 1) < 4)
      {
        return;
      }

      goto LABEL_12;
    }

LABEL_9:
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    return;
  }

  if (v1 < 15)
  {
    return;
  }

  if (v1 <= 16)
  {
    goto LABEL_9;
  }

  if (v1 != 17)
  {
    *a1;
    v2 = *(a1 + 16);
    goto LABEL_14;
  }

LABEL_12:
  v2 = *(a1 + 8);
LABEL_14:

  v2;
}

uint64_t initializeWithCopy for _PlaygroundQuickLook(uint64_t result, uint64_t a2)
{
  v2 = *(a2 + 32);
  if (v2 >= 0x13)
  {
    v2 = *a2 + 19;
  }

  switch(v2)
  {
    case 1u:
      *result = *a2;
      *(result + 32) = 1;
      return result;
    case 2u:
      *result = *a2;
      *(result + 32) = 2;
      return result;
    case 3u:
      *result = *a2;
      *(result + 32) = 3;
      return result;
    case 4u:
      *result = *a2;
      *(result + 32) = 4;
      return result;
    case 5u:
      v11 = *(a2 + 24);
      *(result + 24) = v11;
      v5 = result;
      (**(v11 - 8))();
      result = v5;
      v6 = 5;
      goto LABEL_24;
    case 6u:
      v12 = *(a2 + 24);
      *(result + 24) = v12;
      v5 = result;
      (**(v12 - 8))();
      result = v5;
      v6 = 6;
      goto LABEL_24;
    case 7u:
      v9 = *(a2 + 24);
      *(result + 24) = v9;
      v5 = result;
      (**(v9 - 8))();
      result = v5;
      v6 = 7;
      goto LABEL_24;
    case 8u:
      v18 = *(a2 + 24);
      *(result + 24) = v18;
      v5 = result;
      (**(v18 - 8))();
      result = v5;
      v6 = 8;
      goto LABEL_24;
    case 9u:
      v7 = *(a2 + 24);
      *(result + 24) = v7;
      v5 = result;
      (**(v7 - 8))();
      result = v5;
      v6 = 9;
      goto LABEL_24;
    case 0xAu:
      v17 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v17;
      *(result + 32) = 10;
      return result;
    case 0xBu:
      *result = *a2;
      *(result + 32) = 11;
      return result;
    case 0xCu:
      *result = *a2;
      *(result + 32) = 12;
      return result;
    case 0xDu:
      *result = *a2;
      *(result + 32) = 13;
      return result;
    case 0xEu:
      *result = *a2;
      *(result + 32) = 14;
      return result;
    case 0xFu:
      v8 = *(a2 + 24);
      *(result + 24) = v8;
      v5 = result;
      (**(v8 - 8))();
      result = v5;
      v6 = 15;
      goto LABEL_24;
    case 0x10u:
      v4 = *(a2 + 24);
      *(result + 24) = v4;
      v5 = result;
      (**(v4 - 8))();
      result = v5;
      v6 = 16;
LABEL_24:
      *(v5 + 32) = v6;
      return result;
    case 0x11u:
      v3 = *(a2 + 8);
      *result = *a2;
      *(result + 8) = v3;
      *(result + 32) = 17;
      goto LABEL_17;
    case 0x12u:
      v13 = *a2;
      v14 = *(a2 + 8);
      *result = *a2;
      *(result + 8) = v14;
      v15 = *(a2 + 16);
      *(result + 16) = v15;
      *(result + 32) = 18;
      v16 = result;
      v13;
      v15;
      return v16;
    default:
      v3 = *(a2 + 8);
      *result = *a2;
      *(result + 8) = v3;
      *(result + 32) = 0;
LABEL_17:
      v10 = result;
      v3;
      return v10;
  }
}

uint64_t assignWithCopy for _PlaygroundQuickLook(uint64_t result, uint64_t a2)
{
  if (result == a2)
  {
    return result;
  }

  v2 = *(result + 32);
  if (v2 >= 0x13)
  {
    v2 = *result + 19;
  }

  if (v2 > 9)
  {
    if (v2 < 15)
    {
      goto LABEL_22;
    }

    if (v2 > 16)
    {
      v7 = a2;
      v8 = result;
      if (v2 == 17)
      {
        v9 = *(result + 8);
      }

      else
      {
        *result;
        v9 = *(v8 + 16);
      }

      v9;
      result = v8;
      a2 = v7;
      goto LABEL_22;
    }

    v5 = a2;
LABEL_15:
    v6 = result;
    __swift_destroy_boxed_opaque_existential_1Tm(result);
    result = v6;
    a2 = v5;
    goto LABEL_22;
  }

  if (v2 > 4)
  {
    if (v2 <= 6)
    {
      v5 = a2;
    }

    else
    {
      if (v2 == 7)
      {
        v3 = result;
        v4 = a2;
        __swift_destroy_boxed_opaque_existential_1Tm(result);
        goto LABEL_19;
      }

      v5 = a2;
    }

    goto LABEL_15;
  }

  if ((v2 - 1) >= 4)
  {
    v3 = result;
    v4 = a2;
    *(result + 8);
LABEL_19:
    a2 = v4;
    result = v3;
  }

LABEL_22:
  v10 = *(a2 + 32);
  if (v10 >= 0x13)
  {
    v10 = *a2 + 19;
  }

  switch(v10)
  {
    case 1u:
      *result = *a2;
      v14 = 1;
      goto LABEL_44;
    case 2u:
      *result = *a2;
      v14 = 2;
      goto LABEL_44;
    case 3u:
      *result = *a2;
      v14 = 3;
      goto LABEL_44;
    case 4u:
      *result = *a2;
      v14 = 4;
      goto LABEL_44;
    case 5u:
      v22 = *(a2 + 24);
      *(result + 24) = v22;
      v23 = result;
      (**(v22 - 8))();
      result = v23;
      *(v23 + 32) = 5;
      return result;
    case 6u:
      v24 = *(a2 + 24);
      *(result + 24) = v24;
      v25 = result;
      (**(v24 - 8))();
      result = v25;
      *(v25 + 32) = 6;
      return result;
    case 7u:
      v19 = *(a2 + 24);
      *(result + 24) = v19;
      v20 = result;
      (**(v19 - 8))();
      result = v20;
      *(v20 + 32) = 7;
      return result;
    case 8u:
      v30 = *(a2 + 24);
      *(result + 24) = v30;
      v31 = result;
      (**(v30 - 8))();
      result = v31;
      *(v31 + 32) = 8;
      return result;
    case 9u:
      v15 = *(a2 + 24);
      *(result + 24) = v15;
      v16 = result;
      (**(v15 - 8))();
      result = v16;
      *(v16 + 32) = 9;
      return result;
    case 0xAu:
      v29 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v29;
      v14 = 10;
      goto LABEL_44;
    case 0xBu:
      *result = *a2;
      v14 = 11;
      goto LABEL_44;
    case 0xCu:
      *result = *a2;
      v14 = 12;
      goto LABEL_44;
    case 0xDu:
      *result = *a2;
      v14 = 13;
      goto LABEL_44;
    case 0xEu:
      *result = *a2;
      v14 = 14;
LABEL_44:
      *(result + 32) = v14;
      return result;
    case 0xFu:
      v17 = *(a2 + 24);
      *(result + 24) = v17;
      v18 = result;
      (**(v17 - 8))();
      result = v18;
      *(v18 + 32) = 15;
      return result;
    case 0x10u:
      v12 = *(a2 + 24);
      *(result + 24) = v12;
      v13 = result;
      (**(v12 - 8))();
      result = v13;
      *(v13 + 32) = 16;
      return result;
    case 0x11u:
      *result = *a2;
      v11 = *(a2 + 8);
      *(result + 8) = v11;
      *(result + 32) = 17;
      goto LABEL_38;
    case 0x12u:
      v26 = *a2;
      *result = *a2;
      *(result + 8) = *(a2 + 8);
      v27 = *(a2 + 16);
      *(result + 16) = v27;
      *(result + 32) = 18;
      v28 = result;
      v26;
      v27;
      return v28;
    default:
      *result = *a2;
      v11 = *(a2 + 8);
      *(result + 8) = v11;
      *(result + 32) = 0;
LABEL_38:
      v21 = result;
      v11;
      result = v21;
      break;
  }

  return result;
}

uint64_t assignWithTake for _PlaygroundQuickLook(uint64_t result, uint64_t a2)
{
  if (result == a2)
  {
    return result;
  }

  v2 = *(result + 32);
  if (v2 >= 0x13)
  {
    v2 = *result + 19;
  }

  if (v2 > 9)
  {
    if (v2 < 15)
    {
      goto LABEL_22;
    }

    if (v2 > 16)
    {
      v7 = a2;
      v8 = result;
      if (v2 == 17)
      {
        v9 = *(result + 8);
      }

      else
      {
        *result;
        v9 = *(v8 + 16);
      }

      v9;
      result = v8;
      a2 = v7;
      goto LABEL_22;
    }

    v5 = a2;
LABEL_15:
    v6 = result;
    __swift_destroy_boxed_opaque_existential_1Tm(result);
    result = v6;
    a2 = v5;
    goto LABEL_22;
  }

  if (v2 > 4)
  {
    if (v2 <= 6)
    {
      v5 = a2;
    }

    else
    {
      if (v2 == 7)
      {
        v3 = result;
        v4 = a2;
        __swift_destroy_boxed_opaque_existential_1Tm(result);
        goto LABEL_19;
      }

      v5 = a2;
    }

    goto LABEL_15;
  }

  if ((v2 - 1) >= 4)
  {
    v3 = result;
    v4 = a2;
    *(result + 8);
LABEL_19:
    a2 = v4;
    result = v3;
  }

LABEL_22:
  v10 = *(a2 + 32);
  if (v10 >= 0x13)
  {
    v10 = *a2 + 19;
  }

  switch(v10)
  {
    case 1u:
      *result = *a2;
      v11 = 1;
      break;
    case 2u:
      *result = *a2;
      v11 = 2;
      break;
    case 3u:
      *result = *a2;
      v11 = 3;
      break;
    case 4u:
      *result = *a2;
      v11 = 4;
      break;
    case 5u:
      v16 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v16;
      v11 = 5;
      break;
    case 6u:
      v17 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v17;
      v11 = 6;
      break;
    case 7u:
      v15 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v15;
      v11 = 7;
      break;
    case 8u:
      v19 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v19;
      v11 = 8;
      break;
    case 9u:
      v13 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v13;
      v11 = 9;
      break;
    case 0xAu:
      v18 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v18;
      v11 = 10;
      break;
    case 0xBu:
      *result = *a2;
      v11 = 11;
      break;
    case 0xCu:
      *result = *a2;
      v11 = 12;
      break;
    case 0xDu:
      *result = *a2;
      v11 = 13;
      break;
    case 0xEu:
      *result = *a2;
      v11 = 14;
      break;
    case 0xFu:
      v14 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v14;
      v11 = 15;
      break;
    case 0x10u:
      v12 = *(a2 + 16);
      *result = *a2;
      *(result + 16) = v12;
      v11 = 16;
      break;
    case 0x11u:
      *result = *a2;
      v11 = 17;
      break;
    case 0x12u:
      *result = *a2;
      *(result + 16) = *(a2 + 16);
      v11 = 18;
      break;
    default:
      v11 = 0;
      *result = *a2;
      break;
  }

  *(result + 32) = v11;
  return result;
}

uint64_t getEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xEE && *(a1 + 33))
  {
    return (*a1 + 238);
  }

  v3 = *(a1 + 32);
  if (v3 >= 0x13)
  {
    return (v3 ^ 0xFF) + 1;
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xED)
  {
    *(result + 32) = 0;
    *result = 0u;
    *(result + 16) = 0u;
    *result = a2 - 238;
    if (a3 >= 0xEE)
    {
      *(result + 33) = 1;
    }
  }

  else
  {
    if (a3 >= 0xEE)
    {
      *(result + 33) = 0;
    }

    if (a2)
    {
      *(result + 32) = -a2;
    }
  }

  return result;
}

uint64_t getEnumTag for _PlaygroundQuickLook(uint64_t a1)
{
  result = *(a1 + 32);
  if (result >= 0x13)
  {
    return (*a1 + 19);
  }

  return result;
}

uint64_t destructiveInjectEnumTag for _PlaygroundQuickLook(uint64_t result, unsigned int a2)
{
  if (a2 > 0x12)
  {
    *result = 0u;
    *(result + 16) = 0u;
    *result = a2 - 19;
    LOBYTE(a2) = 19;
  }

  *(result + 32) = a2;
  return result;
}

uint64_t type metadata completion function for CollectionDifference.Change(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8);
    swift_getTupleTypeLayout3(v6, &value witness table for Builtin.Int64.size, v4 + 64, "\t");
    v7[0] = v6;
    swift_getTupleTypeLayout3(v5, &value witness table for Builtin.Int64.size, v4 + 64, "\t");
    v7[1] = v5;
    swift_initEnumMetadataMultiPayload(a1, 0, 2u, v7);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for CollectionDifference.Change(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 80);
  v6 = *(v4 + 64) + 7;
  v7 = (v6 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8;
  if (v5 > 7 || (*(v4 + 80) & 0x100000) != 0 || v7 + 10 > 0x18)
  {
    v10 = *a2;
    *v3 = *a2;
    v3 = (v10 + ((v5 & 0xF8 ^ 0x1F8) & (v5 + 16)));
    v10;
  }

  else
  {
    v11 = ~v5;
    v12 = v7 + 9;
    v13 = *(a2 + v7 + 9);
    if (v13 >= 2)
    {
      if ((v12 & 0xFFFFFFF8) != 0)
      {
        v13 = *a2 + 2;
      }

      else
      {
        v13 = (*a2 | (v13 << 8)) - 510;
      }
    }

    *a1 = *a2;
    v14 = (a1 + v5 + 8) & v11;
    v15 = (a2 + v5 + 8) & v11;
    (*(v4 + 16))(v14, v15);
    v16 = (v6 + v15) & 0xFFFFFFFFFFFFFFF8;
    v17 = *(v16 + 8);
    v18 = (v6 + v14) & 0xFFFFFFFFFFFFFFF8;
    *v18 = *v16;
    *(v18 + 8) = v17;
    *(v3 + v12) = v13 == 1;
  }

  return v3;
}

void *initializeWithCopy for CollectionDifference.Change(void *a1, _DWORD *a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 80);
  v6 = ~v5;
  v7 = *(v4 + 64) + 7;
  v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8) + 9;
  v9 = *(a2 + v8);
  if (v9 >= 2)
  {
    if ((v8 & 0xFFFFFFF8) != 0)
    {
      v9 = *a2 + 2;
    }

    else
    {
      v9 = (*a2 | (v9 << 8)) - 510;
    }
  }

  v10 = v9 == 1;
  *a1 = *a2;
  v11 = (a1 + v5 + 8) & v6;
  v12 = (a2 + v5 + 8) & v6;
  (*(v4 + 16))(v11, v12);
  v13 = (v7 + v12) & 0xFFFFFFFFFFFFFFF8;
  v14 = *(v13 + 8);
  v15 = (v7 + v11) & 0xFFFFFFFFFFFFFFF8;
  *v15 = *v13;
  *(v15 + 8) = v14;
  *(a1 + v8) = v10;
  return a1;
}

void *assignWithCopy for CollectionDifference.Change(void *a1, _DWORD *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v5 = *(a3 + 16);
    v6 = *(v5 - 8);
    v7 = v6;
    v8 = *(v6 + 80);
    v9 = *(v6 + 64) + 7;
    v10 = ((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFFFFFFFFFF8) + 9;
    v11 = (a1 + v8 + 8) & ~v8;
    (*(v6 + 8))(v11, v5);
    v12 = *(a2 + v10);
    if (v12 >= 2)
    {
      if ((v10 & 0xFFFFFFF8) != 0)
      {
        v12 = *a2 + 2;
      }

      else
      {
        v12 = (*a2 | (v12 << 8)) - 510;
      }
    }

    v13 = v12 == 1;
    *a1 = *a2;
    v14 = (a2 + v8 + 8) & ~v8;
    (*(v7 + 16))((a1 + v8 + 8) & ~v8, v14, v5);
    v15 = (v9 + v14) & 0xFFFFFFFFFFFFFFF8;
    v16 = *(v15 + 8);
    v17 = (v9 + v11) & 0xFFFFFFFFFFFFFFF8;
    *v17 = *v15;
    *(v17 + 8) = v16;
    *(a1 + v10) = v13;
  }

  return a1;
}

void *initializeWithTake for CollectionDifference.Change(void *a1, _DWORD *a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 80);
  v6 = ~v5;
  v7 = *(v4 + 64) + 7;
  v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8) + 9;
  v9 = *(a2 + v8);
  if (v9 >= 2)
  {
    if ((v8 & 0xFFFFFFF8) != 0)
    {
      v9 = *a2 + 2;
    }

    else
    {
      v9 = (*a2 | (v9 << 8)) - 510;
    }
  }

  v10 = v9 == 1;
  *a1 = *a2;
  v11 = (a1 + v5 + 8) & v6;
  v12 = (a2 + v5 + 8) & v6;
  (*(v4 + 32))(v11, v12);
  v13 = (v7 + v12) & 0xFFFFFFFFFFFFFFF8;
  v14 = *(v13 + 8);
  v15 = (v7 + v11) & 0xFFFFFFFFFFFFFFF8;
  *v15 = *v13;
  *(v15 + 8) = v14;
  *(a1 + v8) = v10;
  return a1;
}

void *assignWithTake for CollectionDifference.Change(void *a1, _DWORD *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    v5 = *(a3 + 16);
    v6 = *(v5 - 8);
    v7 = v6;
    v8 = *(v6 + 80);
    v9 = *(v6 + 64) + 7;
    v10 = ((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFFFFFFFFFF8) + 9;
    v11 = (a1 + v8 + 8) & ~v8;
    (*(v6 + 8))(v11, v5);
    v12 = *(a2 + v10);
    if (v12 >= 2)
    {
      if ((v10 & 0xFFFFFFF8) != 0)
      {
        v12 = *a2 + 2;
      }

      else
      {
        v12 = (*a2 | (v12 << 8)) - 510;
      }
    }

    v13 = v12 == 1;
    *a1 = *a2;
    v14 = (a2 + v8 + 8) & ~v8;
    (*(v7 + 32))((a1 + v8 + 8) & ~v8, v14, v5);
    v15 = (v9 + v14) & 0xFFFFFFFFFFFFFFF8;
    v16 = *(v15 + 8);
    v17 = (v9 + v11) & 0xFFFFFFFFFFFFFFF8;
    *v17 = *v15;
    *(v17 + 8) = v16;
    *(a1 + v10) = v13;
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for CollectionDifference.Change(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v3 = *(*(a3 + 16) - 8);
  v4 = *(v3 + 80);
  v5 = *(v3 + 64);
  if (!a2)
  {
    return 0;
  }

  v6 = (v5 + ((v4 + 8) & ~v4) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (a2 < 0xFF)
  {
    goto LABEL_25;
  }

  v7 = v6 + 10;
  if ((v6 + 10) <= 3)
  {
    v8 = ((a2 + 65281) >> 16) + 1;
  }

  else
  {
    v8 = 2;
  }

  if (v8 >= 0x10000)
  {
    v9 = 4;
  }

  else
  {
    v9 = 2;
  }

  if (v8 < 0x100)
  {
    v9 = 1;
  }

  if (v8 >= 2)
  {
    v10 = v9;
  }

  else
  {
    v10 = 0;
  }

  if (v10 > 1)
  {
    if (v10 == 2)
    {
      v11 = *(a1 + v7);
      if (*(a1 + v7))
      {
        goto LABEL_21;
      }
    }

    else
    {
      v11 = *(a1 + v7);
      if (v11)
      {
        goto LABEL_21;
      }
    }

LABEL_25:
    v15 = *(a1 + v6 + 9);
    if (v15 >= 2)
    {
      return (v15 ^ 0xFF) + 1;
    }

    else
    {
      return 0;
    }
  }

  if (!v10)
  {
    goto LABEL_25;
  }

  v11 = *(a1 + v7);
  if (!*(a1 + v7))
  {
    goto LABEL_25;
  }

LABEL_21:
  v13 = (v11 - 1) << (8 * v7);
  if (v7 <= 3)
  {
    v14 = *a1;
  }

  else
  {
    v13 = 0;
    v14 = *a1;
  }

  return (v14 | v13) + 255;
}

void storeEnumTagSinglePayload for CollectionDifference.Change(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = (*(*(*(a4 + 16) - 8) + 64) + ((*(*(*(a4 + 16) - 8) + 80) + 8) & ~*(*(*(a4 + 16) - 8) + 80)) + 7) & 0xFFFFFFFFFFFFFFF8;
  v6 = v5 + 10;
  if (a3 < 0xFF)
  {
    v9 = 0;
    if (a2 > 0xFE)
    {
      goto LABEL_14;
    }

LABEL_22:
    if (v9 > 1)
    {
      if (v9 != 2)
      {
        *&a1[v6] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_32;
      }

      *&a1[v6] = 0;
    }

    else if (v9)
    {
      a1[v6] = 0;
      if (!a2)
      {
        return;
      }

LABEL_32:
      a1[v5 + 9] = -a2;
      return;
    }

    if (!a2)
    {
      return;
    }

    goto LABEL_32;
  }

  if (v6 <= 3)
  {
    v7 = ((a3 + 65281) >> 16) + 1;
  }

  else
  {
    v7 = 2;
  }

  if (v7 >= 0x10000)
  {
    v8 = 4;
  }

  else
  {
    v8 = 2;
  }

  if (v7 < 0x100)
  {
    v8 = 1;
  }

  if (v7 >= 2)
  {
    v9 = v8;
  }

  else
  {
    v9 = 0;
  }

  if (a2 <= 0xFE)
  {
    goto LABEL_22;
  }

LABEL_14:
  v10 = a2 - 255;
  v11 = (a2 - 255) >> 16;
  bzero(a1, v5 + 10);
  if (v6 <= 3)
  {
    v12 = v11 + 1;
  }

  else
  {
    v12 = 1;
  }

  if (v6 <= 3)
  {
    *a1 = v10;
    if (v9 > 1)
    {
LABEL_19:
      if (v9 == 2)
      {
        *&a1[v6] = v12;
      }

      else
      {
        *&a1[v6] = v12;
      }

      return;
    }
  }

  else
  {
    *a1 = v10;
    if (v9 > 1)
    {
      goto LABEL_19;
    }
  }

  if (v9)
  {
    a1[v6] = v12;
  }
}

uint64_t getEnumTag for CollectionDifference.Change(_DWORD *a1, uint64_t a2)
{
  v2 = ((*(*(*(a2 + 16) - 8) + 64) + ((*(*(*(a2 + 16) - 8) + 80) + 8) & ~*(*(*(a2 + 16) - 8) + 80)) + 7) & 0xFFFFFFFFFFFFFFF8) + 9;
  v3 = *(a1 + v2);
  if (v3 >= 2)
  {
    if ((v2 & 0xFFFFFFF8) != 0)
    {
      return (*a1 + 2);
    }

    return (*a1 | (v3 << 8)) - 510;
  }

  return v3;
}

void destructiveInjectEnumTag for CollectionDifference.Change(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  v4 = (*(*(*(a3 + 16) - 8) + 64) + 7 + ((*(*(*(a3 + 16) - 8) + 80) + 8) & ~*(*(*(a3 + 16) - 8) + 80))) & 0xFFFFFFFFFFFFFFF8;
  if (a2 > 1)
  {
    v5 = v4 + 9;
    v6 = a2 - 2;
    v7 = ((a2 - 2) >> 8) + 2;
    if (v5 > 3)
    {
      LOBYTE(v7) = 2;
    }

    a1[v5] = v7;
    bzero(a1, v5);
    if (v5 <= 3)
    {
      *a1 = v6;
    }

    else
    {
      *a1 = v6;
    }
  }

  else
  {
    a1[v4 + 9] = a2;
  }
}

uint64_t type metadata completion function for CollectionOfOne(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 24);
    return 0;
  }

  return result;
}

uint64_t type metadata completion function for CollectionOfOne.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result = type metadata accessor for Optional(319, *(a1 + 16), a3, a4);
  if (v6 <= 0x3F)
  {
    v7 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v7, a1 + 24);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ClosedRange<>.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v4 = *(a3 + 16);
  v5 = *(v4 - 8);
  if (*(v5 + 84))
  {
    v6 = *(v5 + 64);
  }

  else
  {
    v6 = *(v5 + 64) + 1;
  }

  v7 = *(v5 + 80);
  if (v7 > 7 || (*(v5 + 80) & 0x100000) != 0 || v6 > 0x18)
  {
    v10 = *a2;
    *a1 = *a2;
    a1 = (v10 + ((v7 + 16) & ~v7));
    v10;
    return a1;
  }

  if (!(*(v5 + 48))(a2, 1, v4))
  {
    (*(v5 + 16))(a1, a2, v4);
    (*(v5 + 56))(a1, 0, 1, v4);
    return a1;
  }

  return memcpy(a1, a2, v6);
}

uint64_t destroy for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 16);
  v6 = *(v3 - 8);
  result = (*(v6 + 48))(a1, 1, v3);
  if (!result)
  {
    v5 = *(v6 + 8);

    return v5(a1, v3);
  }

  return result;
}

void *initializeWithCopy for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  if ((*(v6 + 48))(a2, 1, v5))
  {
    if (*(v6 + 84))
    {
      v7 = *(v6 + 64);
    }

    else
    {
      v7 = *(v6 + 64) + 1;
    }

    return memcpy(a1, a2, v7);
  }

  else
  {
    (*(v6 + 16))(a1, a2, v5);
    (*(v6 + 56))(a1, 0, 1, v5);
    return a1;
  }
}

void *assignWithCopy for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 48);
  v8 = v7(a1, 1, v5);
  v9 = v7(a2, 1, v5);
  if (!v8)
  {
    if (v9)
    {
      v13 = *(v6 + 8);
      v12 = v6 + 8;
      v13(a1, v5);
      v10 = *(v12 + 76);
      v11 = *(v12 + 56);
      goto LABEL_6;
    }

    (*(v6 + 24))(a1, a2, v5);
    return a1;
  }

  if (!v9)
  {
    (*(v6 + 16))(a1, a2, v5);
    (*(v6 + 56))(a1, 0, 1, v5);
    return a1;
  }

  v10 = *(v6 + 84);
  v11 = *(v6 + 64);
LABEL_6:
  if (v10)
  {
    v14 = v11;
  }

  else
  {
    v14 = v11 + 1;
  }

  return memcpy(a1, a2, v14);
}

void *initializeWithTake for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  if ((*(v6 + 48))(a2, 1, v5))
  {
    if (*(v6 + 84))
    {
      v7 = *(v6 + 64);
    }

    else
    {
      v7 = *(v6 + 64) + 1;
    }

    return memcpy(a1, a2, v7);
  }

  else
  {
    (*(v6 + 32))(a1, a2, v5);
    (*(v6 + 56))(a1, 0, 1, v5);
    return a1;
  }
}

void *assignWithTake for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 48);
  v8 = v7(a1, 1, v5);
  v9 = v7(a2, 1, v5);
  if (!v8)
  {
    if (v9)
    {
      v13 = *(v6 + 8);
      v12 = v6 + 8;
      v13(a1, v5);
      v10 = *(v12 + 76);
      v11 = *(v12 + 56);
      goto LABEL_6;
    }

    (*(v6 + 40))(a1, a2, v5);
    return a1;
  }

  if (!v9)
  {
    (*(v6 + 32))(a1, a2, v5);
    (*(v6 + 56))(a1, 0, 1, v5);
    return a1;
  }

  v10 = *(v6 + 84);
  v11 = *(v6 + 64);
LABEL_6:
  if (v10)
  {
    v14 = v11;
  }

  else
  {
    v14 = v11 + 1;
  }

  return memcpy(a1, a2, v14);
}

uint64_t getEnumTagSinglePayload for ClosedRange<>.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = v5 - 1;
  if (!v5)
  {
    v6 = 0;
  }

  v7 = *(*(*(a3 + 16) - 8) + 64);
  if (!v5)
  {
    ++v7;
  }

  if (!a2)
  {
    return 0;
  }

  v8 = a2 - v6;
  if (a2 > v6)
  {
    v9 = 8 * v7;
    if (v7 > 3)
    {
      goto LABEL_8;
    }

    v11 = ((v8 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      v10 = *(a1 + v7);
      if (v10)
      {
        goto LABEL_15;
      }
    }

    else
    {
      if (v11 <= 0xFF)
      {
        if (v11 < 2)
        {
          goto LABEL_28;
        }

LABEL_8:
        v10 = *(a1 + v7);
        if (!*(a1 + v7))
        {
          goto LABEL_28;
        }

LABEL_15:
        v12 = (v10 - 1) << v9;
        if (v7 > 3)
        {
          v12 = 0;
        }

        if (v7)
        {
          if (v7 <= 3)
          {
            v13 = v7;
          }

          else
          {
            v13 = 4;
          }

          if (v13 > 2)
          {
            if (v13 == 3)
            {
              v14 = *a1 | (*(a1 + 2) << 16);
            }

            else
            {
              v14 = *a1;
            }
          }

          else if (v13 == 1)
          {
            v14 = *a1;
          }

          else
          {
            v14 = *a1;
          }
        }

        else
        {
          v14 = 0;
        }

        return v6 + (v14 | v12) + 1;
      }

      v10 = *(a1 + v7);
      if (*(a1 + v7))
      {
        goto LABEL_15;
      }
    }
  }

LABEL_28:
  if (v5 < 2)
  {
    return 0;
  }

  v16 = (*(v4 + 48))(a1, v5);
  if (v16 >= 2)
  {
    return v16 - 1;
  }

  else
  {
    return 0;
  }
}

char *storeEnumTagSinglePayload for ClosedRange<>.Index(char *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = 0;
  v6 = *(*(a4 + 16) - 8);
  v7 = *(v6 + 84);
  v8 = v7 - 1;
  if (v7)
  {
    v9 = *(*(*(a4 + 16) - 8) + 64);
  }

  else
  {
    v8 = 0;
    v9 = *(*(*(a4 + 16) - 8) + 64) + 1;
  }

  v10 = a3 >= v8;
  v11 = a3 - v8;
  if (v11 == 0 || !v10)
  {
    goto LABEL_16;
  }

  if (v9 > 3)
  {
    v5 = 1;
    if (v8 < a2)
    {
      goto LABEL_17;
    }

    goto LABEL_26;
  }

  v12 = ((v11 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
  if (!HIWORD(v12))
  {
    if (v12 < 0x100)
    {
      v13 = 1;
    }

    else
    {
      v13 = 2;
    }

    if (v12 >= 2)
    {
      v5 = v13;
    }

    else
    {
      v5 = 0;
    }

LABEL_16:
    if (v8 < a2)
    {
      goto LABEL_17;
    }

    goto LABEL_26;
  }

  v5 = 4;
  if (v8 < a2)
  {
LABEL_17:
    v14 = ~v8 + a2;
    if (v9 < 4)
    {
      v16 = (v14 >> (8 * v9)) + 1;
      if (v9)
      {
        v17 = v14 & ~(-1 << (8 * v9));
        v18 = result;
        bzero(result, v9);
        result = v18;
        if (v9 != 3)
        {
          if (v9 == 2)
          {
            *v18 = v17;
            if (v5 > 1)
            {
LABEL_44:
              if (v5 == 2)
              {
                *&result[v9] = v16;
              }

              else
              {
                *&result[v9] = v16;
              }

              return result;
            }
          }

          else
          {
            *v18 = v14;
            if (v5 > 1)
            {
              goto LABEL_44;
            }
          }

          goto LABEL_41;
        }

        *v18 = v17;
        v18[2] = BYTE2(v17);
      }

      if (v5 > 1)
      {
        goto LABEL_44;
      }
    }

    else
    {
      v15 = result;
      bzero(result, v9);
      result = v15;
      *v15 = v14;
      v16 = 1;
      if (v5 > 1)
      {
        goto LABEL_44;
      }
    }

LABEL_41:
    if (v5)
    {
      result[v9] = v16;
    }

    return result;
  }

LABEL_26:
  if (v5 > 1)
  {
    if (v5 != 2)
    {
      *&result[v9] = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_33;
    }

    *&result[v9] = 0;
  }

  else if (v5)
  {
    result[v9] = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_33;
  }

  if (!a2)
  {
    return result;
  }

LABEL_33:
  if (v7 >= 2)
  {
    v19 = *(v6 + 56);

    return v19();
  }

  return result;
}

uint64_t dispatch thunk of static DurationProtocol./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(a4 + 24))();
}

{
  return (*(a4 + 56))();
}

__n128 __swift_memcpy41_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  *(a1 + 25) = *(a2 + 25);
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

void *destroy for Mirror.AncestorRepresentation(void *result)
{
  if (*result >= 0xFFFFFFFFuLL)
  {
    return result[1];
  }

  return result;
}

__n128 initializeBufferWithCopyOfBuffer for Mirror.AncestorRepresentation(__n128 *a1, __n128 *a2)
{
  if (a2->n128_u64[0] < 0xFFFFFFFF)
  {
    result = *a2;
    *a1 = *a2;
  }

  else
  {
    v2 = a2->n128_u64[1];
    a1->n128_u64[0] = a2->n128_u64[0];
    a1->n128_u64[1] = v2;
    v2;
  }

  return result;
}

__n128 assignWithCopy for Mirror.AncestorRepresentation(uint64_t a1, unint64_t *a2)
{
  v2 = *a2;
  if (*a1 < 0xFFFFFFFFuLL)
  {
    if (v2 < 0xFFFFFFFF)
    {
      result = *a2;
      *a1 = *a2;
    }

    else
    {
      v6 = a2[1];
      *a1 = v2;
      *(a1 + 8) = v6;
      v6;
    }
  }

  else if (v2 < 0xFFFFFFFF)
  {
    *(a1 + 8);
    result = *a2;
    *a1 = *a2;
  }

  else
  {
    v3 = a2[1];
    v4 = *(a1 + 8);
    *a1 = v2;
    *(a1 + 8) = v3;
    v3;
    v4;
  }

  return result;
}

__n128 assignWithTake for Mirror.AncestorRepresentation(uint64_t a1, unint64_t *a2)
{
  v2 = *a2;
  if (*a1 < 0xFFFFFFFFuLL)
  {
    if (v2 < 0xFFFFFFFF)
    {
      result = *a2;
      *a1 = *a2;
    }

    else
    {
      v6 = a2[1];
      *a1 = v2;
      *(a1 + 8) = v6;
    }
  }

  else if (v2 < 0xFFFFFFFF)
  {
    *(a1 + 8);
    result = *a2;
    *a1 = *a2;
  }

  else
  {
    v3 = a2[1];
    v4 = *(a1 + 8);
    *a1 = v2;
    *(a1 + 8) = v3;
    v4;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Mirror.AncestorRepresentation(uint64_t *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0x7FFFFFFE && *(a1 + 16))
  {
    return (*a1 + 2147483646);
  }

  v3 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v3) = -1;
  }

  v4 = v3 + 1;
  v5 = v3 - 1;
  if (v4 >= 3)
  {
    return v5;
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Mirror.AncestorRepresentation(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *result = 0;
    *(result + 8) = 0;
    *result = a2 - 2147483646;
    if (a3 >= 0x7FFFFFFE)
    {
      *(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7FFFFFFE)
    {
      *(result + 16) = 0;
    }

    if (a2)
    {
      *result = a2 + 1;
    }
  }

  return result;
}

uint64_t getEnumTag for Mirror.AncestorRepresentation(uint64_t *a1)
{
  v1 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v1) = -1;
  }

  return (v1 + 1);
}

void *destructiveInjectEnumTag for Mirror.AncestorRepresentation(void *result, int a2)
{
  if (a2 < 0)
  {
    v2 = a2 & 0x7FFFFFFF;
    result[1] = 0;
  }

  else
  {
    if (!a2)
    {
      return result;
    }

    v2 = (a2 - 1);
  }

  *result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for Mirror.DisplayStyle(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xF8)
  {
    goto LABEL_17;
  }

  if (a2 + 8 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 8) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 8;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 8;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 8;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 9;
  v8 = v6 - 9;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for Mirror.DisplayStyle(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 8 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 8) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xF8)
  {
    v4 = 0;
  }

  if (a2 > 0xF7)
  {
    v5 = ((a2 - 248) >> 8) + 1;
    *result = a2 + 8;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 8;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for _SwiftifyExpr(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 9))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _SwiftifyExpr(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *result = 0;
    *(result + 8) = 0;
    *result = a2 - 1;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 9) = v3;
  return result;
}

uint64_t getEnumTag for _SwiftifyExpr(uint64_t a1)
{
  if (*(a1 + 8))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t destructiveInjectEnumTag for _SwiftifyExpr(uint64_t result, int a2)
{
  if (a2)
  {
    *result = (a2 - 1);
    *(result + 8) = 1;
  }

  else
  {
    *(result + 8) = 0;
  }

  return result;
}

unint64_t outlined copy of _SwiftifyInfo(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!(a2 >> 62))
  {
    return a4;
  }

  return result;
}

void outlined consume of _SwiftifyInfo(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!(a2 >> 62))
  {
    a4;
  }
}

uint64_t *initializeWithCopy for _SwiftifyInfo(uint64_t *a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  outlined copy of _SwiftifyInfo(*a2, v4, v5, v6);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  return a1;
}

uint64_t *assignWithCopy for _SwiftifyInfo(uint64_t *a1, uint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  outlined copy of _SwiftifyInfo(*a2, v4, v5, v6);
  v7 = *a1;
  v8 = a1[1];
  v9 = a1[2];
  v10 = a1[3];
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  outlined consume of _SwiftifyInfo(v7, v8, v9, v10);
  return a1;
}

uint64_t *assignWithTake for _SwiftifyInfo(uint64_t *a1, _OWORD *a2)
{
  v3 = *a1;
  v5 = a1[1];
  v4 = a1[2];
  v6 = a1[3];
  v7 = a2[1];
  *a1 = *a2;
  *(a1 + 1) = v7;
  outlined consume of _SwiftifyInfo(v3, v5, v4, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for _SwiftifyInfo(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 32))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8) >> 1;
  if (v2 > 0x80000000)
  {
    v3 = ~v2;
  }

  else
  {
    v3 = -1;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _SwiftifyInfo(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = 0;
      *(result + 8) = 2 * -a2;
      *(result + 16) = 0;
      *(result + 24) = 0;
      return result;
    }

    *(result + 32) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t initializeWithCopy for ArraySlice(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 24) = *(a2 + 24);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for ArraySlice(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for ArraySlice(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 32))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ArraySlice(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 32) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t type metadata completion function for UnfoldSequence(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 24));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 8) + 64;
    v4[1] = &unk_1EEEAC098;
    v4[2] = &unk_1807268D8;
    swift_initStructMetadata(a1, 0, 3uLL, v4, a1 + 32);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for UnfoldSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 24) - 8);
  v5 = *(v4 + 64);
  v6 = *(v4 + 80);
  if ((v6 & 0x1000F8) != 0 || ((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 17 > 0x18)
  {
    v11 = *a2;
    *v3 = *a2;
    v3 = (v11 + (((v6 & 0xF8) + 23) & ~(v6 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(v4 + 16))(a1);
    v9 = (v3 + v5 + 7) & 0xFFFFFFFFFFFFFFF8;
    v10 = (a2 + v5 + 7) & 0xFFFFFFFFFFFFFFF8;
    v11 = *(v10 + 8);
    *v9 = *v10;
    *(v9 + 8) = v11;
    *(v9 + 16) = *(v10 + 16);
  }

  v11;
  return v3;
}

uint64_t destroy for UnfoldSequence(uint64_t a1, uint64_t a2)
{
  v3 = *(*(a2 + 24) - 8) + 8;
  (*v3)();
  v4 = *(((a1 + *(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return v4;
}

uint64_t initializeWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 24) - 8) + 16;
  (*v5)();
  v6 = *(v5 + 48) + 7;
  v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(v8 + 8);
  *v7 = *v8;
  *(v7 + 8) = v9;
  *(v7 + 16) = *(v8 + 16);
  v9;
  return a1;
}

uint64_t assignWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 24) - 8) + 24;
  (*v5)();
  v6 = *(v5 + 40) + 7;
  v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(v8 + 8);
  v10 = *(v7 + 8);
  *v7 = *v8;
  *(v7 + 8) = v9;
  v9;
  v10;
  *(v7 + 16) = *(v8 + 16);
  return a1;
}

uint64_t initializeWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 24) - 8) + 32;
  (*v5)();
  v6 = *(v5 + 32) + 7;
  v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v7 = *v8;
  *(v7 + 16) = *(v8 + 16);
  return a1;
}

uint64_t assignWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5 = *(*(a3 + 24) - 8) + 40;
  (*v5)();
  v6 = *(v5 + 24) + 7;
  v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(v7 + 8);
  *v7 = *v8;
  v9;
  *(v7 + 16) = *(v8 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for UnfoldSequence(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 24) - 8);
  v5 = *(v4 + 84);
  v6 = *(v4 + 64);
  if (v5 <= 0x7FFFFFFF)
  {
    v7 = 0x7FFFFFFF;
  }

  else
  {
    v7 = *(v4 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  if (v7 >= a2)
  {
    goto LABEL_28;
  }

  v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 17;
  v9 = (a2 - v7 + 255) >> 8;
  if (v8 <= 3)
  {
    v10 = v9 + 1;
  }

  else
  {
    v10 = 2;
  }

  if (v10 >= 0x10000)
  {
    v11 = 4;
  }

  else
  {
    v11 = 2;
  }

  if (v10 < 0x100)
  {
    v11 = 1;
  }

  if (v10 >= 2)
  {
    v12 = v11;
  }

  else
  {
    v12 = 0;
  }

  if (v12 > 1)
  {
    if (v12 == 2)
    {
      v13 = *&a1[v8];
      if (!*&a1[v8])
      {
        goto LABEL_28;
      }
    }

    else
    {
      v13 = *&a1[v8];
      if (!v13)
      {
        goto LABEL_28;
      }
    }
  }

  else if (!v12 || (v13 = a1[v8]) == 0)
  {
LABEL_28:
    if (v5 >= 0x7FFFFFFF)
    {
      return (*(v4 + 48))();
    }

    v17 = *(&a1[v6 + 7] & 0xFFFFFFFFFFFFFFF8);
    if (v17 >= 0xFFFFFFFF)
    {
      LODWORD(v17) = -1;
    }

    return (v17 + 1);
  }

  v15 = (v13 - 1) << (8 * v8);
  if (v8 <= 3)
  {
    v16 = *a1;
  }

  else
  {
    v15 = 0;
    v16 = *a1;
  }

  return v7 + (v16 | v15) + 1;
}

void storeEnumTagSinglePayload for UnfoldSequence(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v6 = *(*(a4 + 24) - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(*(*(a4 + 24) - 8) + 64);
  v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 17;
  if (v8 >= a3)
  {
    v14 = 0;
    if (v8 >= a2)
    {
      goto LABEL_17;
    }
  }

  else
  {
    v11 = (a3 - v8 + 255) >> 8;
    if (v10 <= 3)
    {
      v12 = v11 + 1;
    }

    else
    {
      v12 = 2;
    }

    if (v12 >= 0x10000)
    {
      v13 = 4;
    }

    else
    {
      v13 = 2;
    }

    if (v12 < 0x100)
    {
      v13 = 1;
    }

    if (v12 >= 2)
    {
      v14 = v13;
    }

    else
    {
      v14 = 0;
    }

    if (v8 >= a2)
    {
LABEL_17:
      if (v14 > 1)
      {
        if (v14 != 2)
        {
          *&a1[v10] = 0;
          if (!a2)
          {
            return;
          }

          goto LABEL_32;
        }

        *&a1[v10] = 0;
      }

      else if (v14)
      {
        a1[v10] = 0;
        if (!a2)
        {
          return;
        }

        goto LABEL_32;
      }

      if (!a2)
      {
        return;
      }

LABEL_32:
      if (v7 < 0x7FFFFFFF)
      {
        v18 = (&a1[v9 + 7] & 0xFFFFFFFFFFFFFFF8);
        if ((a2 & 0x80000000) != 0)
        {
          *v18 = a2 & 0x7FFFFFFF;
          v18[1] = 0;
        }

        else
        {
          *v18 = a2 - 1;
        }
      }

      else
      {
        v17 = *(v6 + 56);

        v17();
      }

      return;
    }
  }

  v15 = ~v8 + a2;
  bzero(a1, ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 17);
  if (v10 <= 3)
  {
    v16 = (v15 >> 8) + 1;
  }

  else
  {
    v16 = 1;
  }

  if (v10 <= 3)
  {
    *a1 = v15;
    if (v14 > 1)
    {
LABEL_27:
      if (v14 == 2)
      {
        *&a1[v10] = v16;
      }

      else
      {
        *&a1[v10] = v16;
      }

      return;
    }
  }

  else
  {
    *a1 = v15;
    if (v14 > 1)
    {
      goto LABEL_27;
    }
  }

  if (v14)
  {
    a1[v10] = v16;
  }
}

void type metadata completion function for Zip2Sequence.Iterator(uint64_t a1)
{
  swift_getAssociatedTypeWitness(319, *(a1 + 32), *(a1 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v6[0] = *(v2 - 8) + 64;
    swift_getAssociatedTypeWitness(319, *(a1 + 40), *(a1 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    if (v5 <= 0x3F)
    {
      v6[1] = *(v4 - 8) + 64;
      v6[2] = &unk_1807268D8;
      swift_initStructMetadata(a1, 0, 3uLL, v6, a1 + 48);
    }
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Zip2Sequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 64);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v11 = *(v10 - 8);
  v12 = *(v11 + 80);
  v13 = v9 + v12;
  v14 = *(v11 + 64);
  v15 = (*(v8 + 80) | *(v11 + 80));
  if (v15 > 7 || ((*(v8 + 80) | *(v11 + 80)) & 0x100000) != 0 || v14 + (v13 & ~v12) + 1 > 0x18)
  {
    v18 = *a2;
    *a1 = *a2;
    a1 = (v18 + ((v15 + 16) & ~v15));
    v18;
  }

  else
  {
    v19 = v10;
    v20 = ~v12;
    (*(v8 + 16))(a1, a2, v7);
    v21 = (a2 + v13) & v20;
    (*(v11 + 16))((a1 + v13) & v20, v21, v19);
    *(((a1 + v13) & v20) + v14) = *(v21 + v14);
  }

  return a1;
}

uint64_t destroy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 32), *(a2 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v5 = *(v4 - 8) + 8;
  (*v5)(a1, v4);
  v6 = *(v5 + 56) + a1;
  swift_getAssociatedTypeWitness(0, *(a2 + 40), *(a2 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = v7;
  v9 = *(v7 - 8);
  v10 = *(v9 + 8);
  v11 = (v6 + *(v9 + 80)) & ~*(v9 + 80);

  return v10(v11, v8);
}

uint64_t initializeWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 16;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 48);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = *(v9 - 8);
  v11 = v10 + 16;
  v12 = *(v10 + 80);
  v13 = (v8 + v12 + a1) & ~v12;
  v14 = (v8 + v12 + a2) & ~v12;
  (*(v10 + 16))(v13, v14, v9);
  *(*(v11 + 48) + v13) = *(*(v11 + 48) + v14);
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 24;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 40);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = *(v9 - 8);
  v11 = v10 + 24;
  v12 = *(v10 + 80);
  v13 = (v8 + v12 + a1) & ~v12;
  v14 = (v8 + v12 + a2) & ~v12;
  (*(v10 + 24))(v13, v14, v9);
  *(*(v11 + 40) + v13) = *(*(v11 + 40) + v14);
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 32;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 32);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = *(v9 - 8);
  v11 = v10 + 32;
  v12 = *(v10 + 80);
  v13 = (v8 + v12 + a1) & ~v12;
  v14 = (v8 + v12 + a2) & ~v12;
  (*(v10 + 32))(v13, v14, v9);
  *(*(v11 + 32) + v13) = *(*(v11 + 32) + v14);
  return a1;
}

uint64_t assignWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(v6 - 8) + 40;
  (*v7)(a1, a2, v6);
  v8 = *(v7 + 24);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = *(v9 - 8);
  v11 = v10 + 40;
  v12 = *(v10 + 80);
  v13 = (v8 + v12 + a1) & ~v12;
  v14 = (v8 + v12 + a2) & ~v12;
  (*(v10 + 40))(v13, v14, v9);
  *(*(v11 + 24) + v13) = *(*(v11 + 24) + v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence.Iterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 32), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = v6;
  v8 = *(v6 - 8);
  v9 = *(v8 + 84);
  swift_getAssociatedTypeWitness(0, *(a3 + 40), *(a3 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v11 = *(v10 - 8);
  v12 = *(v11 + 84);
  if (v12 <= v9)
  {
    v13 = v9;
  }

  else
  {
    v13 = *(v11 + 84);
  }

  v14 = *(v11 + 80);
  v15 = *(*(v10 - 8) + 64);
  if (v13 <= 0xFE)
  {
    v13 = 254;
  }

  if (!a2)
  {
    return 0;
  }

  v16 = *(v8 + 64) + v14;
  if (a2 > v13)
  {
    v17 = v15 + (v16 & ~v14) + 1;
    v18 = 8 * v17;
    if (v17 > 3)
    {
      goto LABEL_9;
    }

    v20 = ((a2 - v13 + ~(-1 << v18)) >> v18) + 1;
    if (HIWORD(v20))
    {
      v19 = *(a1 + v17);
      if (!v19)
      {
        goto LABEL_29;
      }

      goto LABEL_16;
    }

    if (v20 > 0xFF)
    {
      v19 = *(a1 + v17);
      if (!*(a1 + v17))
      {
        goto LABEL_29;
      }

      goto LABEL_16;
    }

    if (v20 >= 2)
    {
LABEL_9:
      v19 = *(a1 + v17);
      if (!*(a1 + v17))
      {
        goto LABEL_29;
      }

LABEL_16:
      v21 = (v19 - 1) << v18;
      if (v17 > 3)
      {
        v21 = 0;
      }

      if (v17)
      {
        if (v17 <= 3)
        {
          v22 = v17;
        }

        else
        {
          v22 = 4;
        }

        if (v22 > 2)
        {
          if (v22 == 3)
          {
            v23 = *a1 | (*(a1 + 2) << 16);
          }

          else
          {
            v23 = *a1;
          }
        }

        else if (v22 == 1)
        {
          v23 = *a1;
        }

        else
        {
          v23 = *a1;
        }
      }

      else
      {
        v23 = 0;
      }

      v29 = v13 + (v23 | v21);
      return (v29 + 1);
    }
  }

LABEL_29:
  if (v9 == v13)
  {
    v24 = *(v8 + 48);

    return v24(a1, v9, v7);
  }

  v26 = (a1 + v16) & ~v14;
  if (v12 != v13)
  {
    v28 = *(v26 + v15);
    if (v28 < 2)
    {
      return 0;
    }

    v29 = (v28 + 2147483646) & 0x7FFFFFFF;
    return (v29 + 1);
  }

  v27 = *(v11 + 48);

  return v27(v26);
}

void storeEnumTagSinglePayload for Zip2Sequence.Iterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 32), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = v8;
  v10 = *(v8 - 8);
  v11 = *(v10 + 84);
  swift_getAssociatedTypeWitness(0, *(a4 + 40), *(a4 + 24), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v13 = *(v12 - 8);
  v14 = *(v13 + 84);
  if (v14 <= v11)
  {
    v15 = v11;
  }

  else
  {
    v15 = *(v13 + 84);
  }

  v16 = *(v13 + 80);
  v17 = *(*(v12 - 8) + 64);
  if (v15 <= 0xFE)
  {
    v18 = 254;
  }

  else
  {
    v18 = v15;
  }

  v19 = *(v10 + 64) + v16;
  v20 = v17 + (v19 & ~v16) + 1;
  if (a3 <= v18)
  {
    v21 = 0;
  }

  else if (v20 <= 3)
  {
    v24 = ((a3 - v18 + ~(-1 << (8 * v20))) >> (8 * v20)) + 1;
    if (HIWORD(v24))
    {
      v21 = 4;
    }

    else
    {
      if (v24 < 0x100)
      {
        v25 = 1;
      }

      else
      {
        v25 = 2;
      }

      if (v24 >= 2)
      {
        v21 = v25;
      }

      else
      {
        v21 = 0;
      }
    }
  }

  else
  {
    v21 = 1;
  }

  if (v18 < a2)
  {
    v22 = ~v18 + a2;
    if (v20 < 4)
    {
      v23 = (v22 >> (8 * v20)) + 1;
      if (v17 + (v19 & ~v16) != -1)
      {
        v26 = v22 & ~(-1 << (8 * v20));
        bzero(a1, v20);
        if (v20 != 3)
        {
          if (v20 == 2)
          {
            *a1 = v26;
            if (v21 > 1)
            {
LABEL_51:
              if (v21 == 2)
              {
                *&a1[v20] = v23;
              }

              else
              {
                *&a1[v20] = v23;
              }

              return;
            }
          }

          else
          {
            *a1 = v22;
            if (v21 > 1)
            {
              goto LABEL_51;
            }
          }

          goto LABEL_48;
        }

        *a1 = v26;
        a1[2] = BYTE2(v26);
      }

      if (v21 > 1)
      {
        goto LABEL_51;
      }
    }

    else
    {
      bzero(a1, v20);
      *a1 = v22;
      v23 = 1;
      if (v21 > 1)
      {
        goto LABEL_51;
      }
    }

LABEL_48:
    if (v21)
    {
      a1[v20] = v23;
    }

    return;
  }

  if (v21 > 1)
  {
    if (v21 != 2)
    {
      *&a1[v20] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_34;
    }

    *&a1[v20] = 0;
  }

  else if (v21)
  {
    a1[v20] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_34;
  }

  if (!a2)
  {
    return;
  }

LABEL_34:
  if (v11 == v18)
  {
    v27 = *(v10 + 56);

    v27(a1, a2, v11, v9);
  }

  else
  {
    v28 = &a1[v19] & ~v16;
    if (v14 == v18)
    {
      v29 = *(v13 + 56);

      v29(v28, a2);
    }

    else
    {
      *(v28 + v17) = a2 + 1;
    }
  }
}

uint64_t getEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 16))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *result = (a2 - 1);
    *(result + 8) = 0;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 16) = v3;
  return result;
}

void type metadata completion function for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(319, *(a1 + 24), *(a1 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  if (v6 <= 0x3F)
  {
    v7 = *(v5 - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v7, a1 + 32);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD2(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  v7 = *(v6 - 8);
  v8 = *(v7 + 80);
  if (v8 <= 7 && *(*(v6 - 8) + 64) <= 0x18uLL && (*(v7 + 80) & 0x100000) == 0)
  {
    (*(v7 + 16))(a1, a2, v6);
  }

  else
  {
    v11 = *a2;
    *a1 = *a2;
    a1 = (v11 + ((v8 + 16) & ~v8));
    v11;
  }

  return a1;
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), a3, a4);
  v6 = *(*(v5 - 8) + 8);

  return v6(a1, v5);
}

uint64_t initializeWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  (*(*(v6 - 8) + 16))(a1, a2, v6);
  return a1;
}

uint64_t assignWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  (*(*(v6 - 8) + 24))(a1, a2, v6);
  return a1;
}

uint64_t initializeWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  (*(*(v6 - 8) + 32))(a1, a2, v6);
  return a1;
}

uint64_t assignWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  (*(*(v6 - 8) + 40))(a1, a2, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for SIMD2(unsigned __int16 *a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for SIMDScalar, a4);
  v7 = *(v6 - 8);
  v8 = *(v7 + 84);
  v9 = *(v7 + 64);
  if (!a2)
  {
    return 0;
  }

  if (a2 <= v8)
  {
LABEL_23:
    v14 = *(v7 + 48);

    return v14(a1);
  }

  v10 = 8 * v9;
  if (v9 <= 3)
  {
    v12 = ((a2 - v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      v11 = *(a1 + v9);
      if (!v11)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v12 > 0xFF)
    {
      v11 = *(a1 + v9);
      if (!*(a1 + v9))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v12 < 2)
    {
LABEL_22:
      if (v8)
      {
        goto LABEL_23;
      }

      return 0;
    }
  }

  v11 = *(a1 + v9);
  if (!*(a1 + v9))
  {
    goto LABEL_22;
  }

LABEL_11:
  v13 = (v11 - 1) << v10;
  if (v9 > 3)
  {
    v13 = 0;
  }

  if (v9)
  {
    if (v9 > 3)
    {
      LODWORD(v9) = 4;
    }

    if (v9 > 2)
    {
      if (v9 == 3)
      {
        LODWORD(v9) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v9) = *a1;
      }
    }

    else if (v9 == 1)
    {
      LODWORD(v9) = *a1;
    }

    else
    {
      LODWORD(v9) = *a1;
    }
  }

  return v8 + (v9 | v13) + 1;
}

void storeEnumTagSinglePayload for SIMD2(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4, _DWORD *a5)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for SIMDScalar, a5);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v9 + 64);
  if (a3 <= v10)
  {
    v12 = 0;
  }

  else if (v11 <= 3)
  {
    v15 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v15))
    {
      v12 = 4;
    }

    else
    {
      if (v15 < 0x100)
      {
        v16 = 1;
      }

      else
      {
        v16 = 2;
      }

      if (v15 >= 2)
      {
        v12 = v16;
      }

      else
      {
        v12 = 0;
      }
    }
  }

  else
  {
    v12 = 1;
  }

  if (v10 < a2)
  {
    v13 = ~v10 + a2;
    if (v11 < 4)
    {
      v14 = (v13 >> (8 * v11)) + 1;
      if (v11)
      {
        v17 = v13 & ~(-1 << (8 * v11));
        bzero(a1, v11);
        if (v11 != 3)
        {
          if (v11 == 2)
          {
            *a1 = v17;
            if (v12 > 1)
            {
LABEL_39:
              if (v12 == 2)
              {
                *&a1[v11] = v14;
              }

              else
              {
                *&a1[v11] = v14;
              }

              return;
            }
          }

          else
          {
            *a1 = v13;
            if (v12 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *a1 = v17;
        a1[2] = BYTE2(v17);
      }

      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      bzero(a1, v11);
      *a1 = v13;
      v14 = 1;
      if (v12 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v12)
    {
      a1[v11] = v14;
    }

    return;
  }

  if (v12 > 1)
  {
    if (v12 != 2)
    {
      *&a1[v11] = 0;
      if (!a2)
      {
        return;
      }

      goto LABEL_28;
    }

    *&a1[v11] = 0;
  }

  else if (v12)
  {
    a1[v11] = 0;
    if (!a2)
    {
      return;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return;
  }

LABEL_28:
  v18 = *(v9 + 56);

  v18(a1, a2);
}

__n128 __swift_memcpy32_16(_OWORD *a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  *a1 = *a2;
  a1[1] = v3;
  return result;
}

__n128 __swift_memcpy64_16(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  v4 = *(a2 + 48);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 48) = v4;
  *a1 = result;
  *(a1 + 16) = v3;
  return result;
}

__n128 __swift_memcpy128_16(uint64_t a1, __int128 *a2)
{
  v2 = *a2;
  v3 = a2[1];
  v4 = a2[3];
  *(a1 + 32) = a2[2];
  *(a1 + 48) = v4;
  *a1 = v2;
  *(a1 + 16) = v3;
  result = a2[4];
  v6 = a2[5];
  v7 = a2[7];
  *(a1 + 96) = a2[6];
  *(a1 + 112) = v7;
  *(a1 + 64) = result;
  *(a1 + 80) = v6;
  return result;
}

__n128 __swift_memcpy256_16(uint64_t a1, __int128 *a2)
{
  v2 = *a2;
  v3 = a2[1];
  v4 = a2[3];
  *(a1 + 32) = a2[2];
  *(a1 + 48) = v4;
  *a1 = v2;
  *(a1 + 16) = v3;
  v5 = a2[4];
  v6 = a2[5];
  v7 = a2[7];
  *(a1 + 96) = a2[6];
  *(a1 + 112) = v7;
  *(a1 + 64) = v5;
  *(a1 + 80) = v6;
  v8 = a2[8];
  v9 = a2[9];
  v10 = a2[11];
  *(a1 + 160) = a2[10];
  *(a1 + 176) = v10;
  *(a1 + 128) = v8;
  *(a1 + 144) = v9;
  result = a2[12];
  v12 = a2[13];
  v13 = a2[15];
  *(a1 + 224) = a2[14];
  *(a1 + 240) = v13;
  *(a1 + 192) = result;
  *(a1 + 208) = v12;
  return result;
}

uint64_t getEnumTagSinglePayload for Double.SIMD4Storage(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 32))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD4Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = (a2 - 1);
    *(result + 8) = 0;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 32) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for Double.SIMD8Storage(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 64))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t getEnumTagSinglePayload for Double.SIMD16Storage(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 128))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD16Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 120) = 0;
    *(result + 104) = 0u;
    *(result + 88) = 0u;
    *(result + 72) = 0u;
    *(result + 56) = 0u;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 128) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for Double.SIMD32Storage(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 256))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD32Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 248) = 0;
    *(result + 232) = 0u;
    *(result + 216) = 0u;
    *(result + 200) = 0u;
    *(result + 184) = 0u;
    *(result + 168) = 0u;
    *(result + 152) = 0u;
    *(result + 136) = 0u;
    *(result + 120) = 0u;
    *(result + 104) = 0u;
    *(result + 88) = 0u;
    *(result + 72) = 0u;
    *(result + 56) = 0u;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 256) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for Double.SIMD64Storage(uint64_t a1, int a2)
{
  if (a2 && *(a1 + 512))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD64Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(result + 504) = 0;
    *(result + 248) = 0u;
    *(result + 232) = 0u;
    *(result + 216) = 0u;
    *(result + 200) = 0u;
    *(result + 184) = 0u;
    *(result + 168) = 0u;
    *(result + 152) = 0u;
    *(result + 136) = 0u;
    *(result + 120) = 0u;
    *(result + 104) = 0u;
    *(result + 88) = 0u;
    *(result + 72) = 0u;
    *(result + 56) = 0u;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 488) = 0u;
    *(result + 472) = 0u;
    *(result + 456) = 0u;
    *(result + 440) = 0u;
    *(result + 424) = 0u;
    *(result + 408) = 0u;
    *(result + 392) = 0u;
    *(result + 376) = 0u;
    *(result + 360) = 0u;
    *(result + 344) = 0u;
    *(result + 328) = 0u;
    *(result + 312) = 0u;
    *(result + 296) = 0u;
    *(result + 280) = 0u;
    *(result + 264) = 0u;
    *result = (a2 - 1);
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 512) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for _GraphemeBreakingState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFF && a1[4])
  {
    return (*a1 + 255);
  }

  v3 = *a1;
  v4 = v3 >= 2;
  v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4)
  {
    v5 = -1;
  }

  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _GraphemeBreakingState(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *result = a2 - 255;
    if (a3 >= 0xFF)
    {
      *(result + 4) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF)
    {
      *(result + 4) = 0;
    }

    if (a2)
    {
      *result = a2 + 1;
    }
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Unicode._InternalNFC.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  v8 = *(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 57 > 0x18)
  {
    v10 = *a2;
    *a1 = *a2;
    a1 = (v10 + (((v8 & 0xF8) + 23) & ~(v8 & 0xF8) & 0x1F8));
    v10;
  }

  else
  {
    (*(v6 + 16))(a1, a2, v5);
    v11 = (a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v12 = (a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    *v11 = *v12;
    *(v11 + 1) = *(v12 + 1);
    *(v11 + 2) = *(v12 + 2);
    *(v11 + 8) = *(v12 + 8);
    v13 = *(v12 + 16);
    *(v11 + 16) = v13;
    *(v11 + 24) = *(v12 + 24);
    v14 = *(v12 + 28);
    *(v11 + 31) = *(v12 + 31);
    *(v11 + 28) = v14;
    *(v11 + 35) = *(v12 + 35);
    v15 = *(v12 + 40);
    *(v11 + 40) = v15;
    *(v11 + 48) = *(v12 + 48);
    v16 = *(v12 + 52);
    *(v11 + 56) = *(v12 + 56);
    *(v11 + 52) = v16;
    v13;
    v15;
  }

  return a1;
}

void destroy for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2)
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v4 = *(v3 - 8) + 8;
  (*v4)(a1, v3);
  v5 = (a1 + *(v4 + 56) + 7) & 0xFFFFFFFFFFFFFFF8;
  *(v5 + 16);
  v6 = *(v5 + 40);

  v6;
}

uint64_t initializeWithCopy for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 16;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 48) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  *(v8 + 1) = *(v9 + 1);
  *(v8 + 2) = *(v9 + 2);
  *(v8 + 8) = *(v9 + 8);
  v10 = *(v9 + 16);
  *(v8 + 16) = v10;
  *(v8 + 24) = *(v9 + 24);
  v11 = *(v9 + 31);
  *(v8 + 28) = *(v9 + 28);
  *(v8 + 31) = v11;
  *(v8 + 35) = *(v9 + 35);
  v12 = *(v9 + 40);
  *(v8 + 40) = v12;
  *(v8 + 48) = *(v9 + 48);
  LOBYTE(v11) = *(v9 + 56);
  *(v8 + 52) = *(v9 + 52);
  *(v8 + 56) = v11;
  v10;
  v12;
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 24;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 40) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  *(v8 + 1) = *(v9 + 1);
  *(v8 + 2) = *(v9 + 2);
  *(v8 + 8) = *(v9 + 8);
  v10 = *(v9 + 16);
  v11 = *(v8 + 16);
  *(v8 + 16) = v10;
  v10;
  v11;
  *(v8 + 24) = *(v9 + 24);
  v12 = *(v9 + 28);
  *(v8 + 31) = *(v9 + 31);
  *(v8 + 28) = v12;
  *(v8 + 35) = *(v9 + 35);
  v13 = *(v9 + 40);
  v14 = *(v8 + 40);
  *(v8 + 40) = v13;
  v13;
  v14;
  *(v8 + 48) = *(v9 + 48);
  v15 = *(v9 + 52);
  *(v8 + 56) = *(v9 + 56);
  *(v8 + 52) = v15;
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 32;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 32) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v11 = v9[1];
  v10 = v9[2];
  v12 = *v9;
  *(v8 + 41) = *(v9 + 41);
  v8[1] = v11;
  v8[2] = v10;
  *v8 = v12;
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 40;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 24) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  *(v8 + 1) = *(v9 + 1);
  *(v8 + 2) = *(v9 + 2);
  *(v8 + 8) = *(v9 + 8);
  v10 = *(v8 + 16);
  *(v8 + 16) = *(v9 + 16);
  v10;
  *(v8 + 24) = *(v9 + 24);
  v11 = *(v9 + 28);
  *(v8 + 31) = *(v9 + 31);
  *(v8 + 28) = v11;
  *(v8 + 35) = *(v9 + 35);
  v12 = *(v8 + 40);
  *(v8 + 40) = *(v9 + 40);
  v12;
  *(v8 + 48) = *(v9 + 48);
  v13 = *(v9 + 52);
  *(v8 + 56) = *(v9 + 56);
  *(v8 + 52) = v13;
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFC.Iterator(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(*(v5 - 8) + 64);
  if (!a2)
  {
    return 0;
  }

  if (v8 >= a2)
  {
    goto LABEL_28;
  }

  v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 57;
  if (v10 <= 3)
  {
    v11 = ((a2 - v8 + 255) >> 8) + 1;
  }

  else
  {
    v11 = 2;
  }

  if (v11 >= 0x10000)
  {
    v12 = 4;
  }

  else
  {
    v12 = 2;
  }

  if (v11 < 0x100)
  {
    v12 = 1;
  }

  if (v11 >= 2)
  {
    v13 = v12;
  }

  else
  {
    v13 = 0;
  }

  if (v13 > 1)
  {
    if (v13 == 2)
    {
      v14 = *&a1[v10];
      if (!*&a1[v10])
      {
        goto LABEL_28;
      }
    }

    else
    {
      v14 = *&a1[v10];
      if (!v14)
      {
        goto LABEL_28;
      }
    }

LABEL_24:
    v16 = (v14 - 1) << (8 * v10);
    if (v10 <= 3)
    {
      v17 = *a1;
    }

    else
    {
      v16 = 0;
      v17 = *a1;
    }

    return v8 + (v17 | v16) + 1;
  }

  if (v13)
  {
    v14 = a1[v10];
    if (a1[v10])
    {
      goto LABEL_24;
    }
  }

LABEL_28:
  if (v7 < 0x7FFFFFFF)
  {
    v19 = *((&a1[v9 + 7] & 0xFFFFFFFFFFFFFFF8) + 16);
    if (v19 >= 0xFFFFFFFF)
    {
      LODWORD(v19) = -1;
    }

    return (v19 + 1);
  }

  else
  {
    v18 = *(v6 + 48);

    return v18(a1);
  }
}

double storeEnumTagSinglePayload for Unicode._InternalNFC.Iterator(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(v8 - 8);
  v10 = *(v9 + 84);
  v11 = *(v9 + 64);
  if (v10 <= 0x7FFFFFFF)
  {
    v12 = 0x7FFFFFFF;
  }

  else
  {
    v12 = *(v9 + 84);
  }

  v13 = ((v11 + 7) & 0xFFFFFFFFFFFFFFF8) + 57;
  if (v12 >= a3)
  {
    v16 = 0;
    if (v12 >= a2)
    {
      goto LABEL_17;
    }
  }

  else
  {
    if (v13 <= 3)
    {
      v14 = ((a3 - v12 + 255) >> 8) + 1;
    }

    else
    {
      v14 = 2;
    }

    if (v14 >= 0x10000)
    {
      v15 = 4;
    }

    else
    {
      v15 = 2;
    }

    if (v14 < 0x100)
    {
      v15 = 1;
    }

    if (v14 >= 2)
    {
      v16 = v15;
    }

    else
    {
      v16 = 0;
    }

    if (v12 >= a2)
    {
LABEL_17:
      if (v16 > 1)
      {
        if (v16 != 2)
        {
          *&a1[v13] = 0;
          if (!a2)
          {
            return result;
          }

          goto LABEL_32;
        }

        *&a1[v13] = 0;
      }

      else if (v16)
      {
        a1[v13] = 0;
        if (!a2)
        {
          return result;
        }

        goto LABEL_32;
      }

      if (!a2)
      {
        return result;
      }

LABEL_32:
      if (v10 < 0x7FFFFFFF)
      {
        v20 = &a1[v11 + 7] & 0xFFFFFFFFFFFFFFF8;
        if ((a2 & 0x80000000) != 0)
        {
          result = 0.0;
          *(v20 + 40) = 0u;
          *(v20 + 24) = 0u;
          *(v20 + 8) = 0u;
          *(v20 + 56) = 0;
          *v20 = a2 & 0x7FFFFFFF;
        }

        else
        {
          *(v20 + 16) = (a2 - 1);
        }
      }

      else
      {
        v19 = *(v9 + 56);

        v19(a1, a2);
      }

      return result;
    }
  }

  v17 = ~v12 + a2;
  bzero(a1, v13);
  if (v13 <= 3)
  {
    v18 = (v17 >> 8) + 1;
  }

  else
  {
    v18 = 1;
  }

  if (v13 <= 3)
  {
    *a1 = v17;
    if (v16 > 1)
    {
LABEL_27:
      if (v16 == 2)
      {
        *&a1[v13] = v18;
      }

      else
      {
        *&a1[v13] = v18;
      }

      return result;
    }
  }

  else
  {
    *a1 = v17;
    if (v16 > 1)
    {
      goto LABEL_27;
    }
  }

  if (v16)
  {
    a1[v13] = v18;
  }

  return result;
}

void type metadata completion function for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  swift_getAssociatedTypeWitness(319, *(a1 + 24), *(a1 + 16), a4, a5);
  if (v9 <= 0x3F)
  {
    v10[0] = *(v8 - 8) + 64;
    v10[1] = a6;
    swift_initStructMetadata(a1, 0, 2uLL, v10, a1 + 32);
  }
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Unicode._InternalNFD.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 64);
  v8 = *(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 28 > 0x18)
  {
    v10 = *a2;
    *a1 = *a2;
    a1 = (v10 + (((v8 & 0xF8) + 23) & ~(v8 & 0xF8) & 0x1F8));
    v10;
  }

  else
  {
    (*(v6 + 16))(a1, a2, v5);
    v11 = (a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v12 = (a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    *v11 = *v12;
    v13 = *(v12 + 8);
    *(v11 + 8) = v13;
    *(v11 + 16) = *(v12 + 16);
    v14 = *(v12 + 20);
    *(v11 + 23) = *(v12 + 23);
    *(v11 + 20) = v14;
    *(v11 + 27) = *(v12 + 27);
    v13;
  }

  return a1;
}

uint64_t destroy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t (*a5)(uint64_t))
{
  swift_getAssociatedTypeWitness(0, *(a2 + 24), *(a2 + 16), a3, a4);
  v7 = *(v6 - 8) + 8;
  (*v7)(a1, v6);
  v8 = *(((a1 + *(v7 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return a5(v8);
}

uint64_t initializeWithCopy for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 16;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 48) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  v10 = *(v9 + 8);
  *(v8 + 8) = v10;
  *(v8 + 16) = *(v9 + 16);
  v11 = *(v9 + 23);
  *(v8 + 20) = *(v9 + 20);
  *(v8 + 23) = v11;
  *(v8 + 27) = *(v9 + 27);
  v10;
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 24;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 40) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  v10 = *(v9 + 8);
  v11 = *(v8 + 8);
  *(v8 + 8) = v10;
  v10;
  v11;
  *(v8 + 16) = *(v9 + 16);
  v12 = *(v9 + 20);
  *(v8 + 23) = *(v9 + 23);
  *(v8 + 20) = v12;
  *(v8 + 27) = *(v9 + 27);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 32;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 32) + 7;
  v8 = ((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = ((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = *(v9 + 12);
  *v8 = *v9;
  *(v8 + 12) = v10;
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8) + 40;
  (*v6)(a1, a2, v5);
  v7 = *(v6 + 24) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v7 + a2) & 0xFFFFFFFFFFFFFFF8;
  *v8 = *v9;
  v10 = *(v8 + 8);
  *(v8 + 8) = *(v9 + 8);
  v10;
  *(v8 + 16) = *(v9 + 16);
  v11 = *(v9 + 20);
  *(v8 + 23) = *(v9 + 23);
  *(v8 + 20) = v11;
  *(v8 + 27) = *(v9 + 27);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFD.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  swift_getAssociatedTypeWitness(0, *(a3 + 24), *(a3 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(v5 - 8);
  v7 = *(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
  {
    v8 = 0x7FFFFFFF;
  }

  else
  {
    v8 = *(v6 + 84);
  }

  v9 = *(*(v5 - 8) + 64);
  if (!a2)
  {
    return 0;
  }

  if (v8 < a2 && *(a1 + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 28))
  {
    return v8 + *a1 + 1;
  }

  if (v7 < 0x7FFFFFFF)
  {
    v12 = *(((a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 8);
    if (v12 >= 0xFFFFFFFF)
    {
      LODWORD(v12) = -1;
    }

    return (v12 + 1);
  }

  else
  {
    v11 = *(v6 + 48);

    return v11(a1);
  }
}

void storeEnumTagSinglePayload for Unicode._InternalNFD.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  swift_getAssociatedTypeWitness(0, *(a4 + 24), *(a4 + 16), &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v8 + 64);
  if (v9 <= 0x7FFFFFFF)
  {
    v11 = 0x7FFFFFFF;
  }

  else
  {
    v11 = *(v8 + 84);
  }

  v12 = ((v10 + 7) & 0xFFFFFFFFFFFFFFF8) + 28;
  if (v11 >= a2)
  {
    if (v11 < a3)
    {
      *(a1 + v12) = 0;
    }

    if (a2)
    {
      if (v9 < 0x7FFFFFFF)
      {
        v14 = (a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8;
        if ((a2 & 0x80000000) != 0)
        {
          *(v14 + 8) = 0;
          *(v14 + 16) = 0;
          *(v14 + 24) = 0;
          *v14 = a2 & 0x7FFFFFFF;
        }

        else
        {
          *(v14 + 8) = (a2 - 1);
        }
      }

      else
      {
        v13 = *(v8 + 56);

        v13(a1, a2);
      }
    }
  }

  else
  {
    bzero(a1, v12);
    *a1 = ~v11 + a2;
    if (v11 < a3)
    {
      *(a1 + v12) = 1;
    }
  }
}

uint64_t initializeBufferWithCopyOfBuffer for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  return a1;
}

uint64_t assignWithTake for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  swift_unknownObjectRelease(*a1);
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 24))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0;
    *(result + 16) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 24) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 24) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

__n128 __swift_memcpy128_8(uint64_t a1, __int128 *a2)
{
  v2 = *a2;
  v3 = a2[1];
  v4 = a2[3];
  *(a1 + 32) = a2[2];
  *(a1 + 48) = v4;
  *a1 = v2;
  *(a1 + 16) = v3;
  result = a2[4];
  v6 = a2[5];
  v7 = a2[7];
  *(a1 + 96) = a2[6];
  *(a1 + 112) = v7;
  *(a1 + 64) = result;
  *(a1 + 80) = v6;
  return result;
}

void type metadata accessor for _SwiftNSFastEnumerationState(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  if (!*a2)
  {
    swift_getForeignTypeMetadata(0, a3);
    if (!v5)
    {
      atomic_store(v4, a2);
    }
  }
}

uint64_t destroy for Mirror(uint64_t a1)
{
  *(a1 + 8);
  v2 = *(a1 + 32);

  return v2;
}

uint64_t initializeWithCopy for Mirror(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v3;
  *(a1 + 16) = *(a2 + 16);
  v4 = *(a2 + 32);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 32) = v4;
  *(a1 + 40) = *(a2 + 40);
  v3;
  v4;
  return a1;
}

uint64_t assignWithCopy for Mirror(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *(a1 + 8) = v4;
  v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  v6 = *(a2 + 32);
  v7 = *(a1 + 32);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 32) = v6;
  v6;
  v7;
  *(a1 + 40) = *(a2 + 40);
  return a1;
}

uint64_t assignWithTake for Mirror(uint64_t a1, uint64_t a2)
{
  v4 = *(a1 + 8);
  *a1 = *a2;
  v4;
  *(a1 + 16) = *(a2 + 16);
  v5 = *(a1 + 32);
  *(a1 + 24) = *(a2 + 24);
  v5;
  *(a1 + 40) = *(a2 + 40);
  return a1;
}

uint64_t getEnumTagSinglePayload for Mirror(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 41))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Mirror(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 40) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 41) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 41) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFD)
  {
    goto LABEL_17;
  }

  if (a2 + 3 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 3) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 3;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 4;
  v8 = v6 - 4;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 3) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xFD)
  {
    v4 = 0;
  }

  if (a2 > 0xFC)
  {
    v5 = ((a2 - 253) >> 8) + 1;
    *result = a2 + 3;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 3;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

void destroy for _SetAnyHashableBox(unint64_t *a1)
{
  *a1;
  v2 = a1[1];

  v2;
}

uint64_t type metadata completion function for _Pair(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_getTupleTypeLayout2(v4, *(result - 8) + 64, *(result - 8) + 64);
    v5 = v4;
    swift_initStructMetadata(a1, 0, 1uLL, &v5, a1 + 24);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ClosedRange(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(a3 + 16);
  v5 = *(v4 - 8);
  v6 = *(v5 + 64);
  v7 = *(v5 + 80);
  v8 = ~v7;
  v9 = v6 + v7;
  v10 = ((v6 + v7) & ~v7) + v6;
  if (v7 > 7 || (*(v5 + 80) & 0x100000) != 0 || v10 > 0x18)
  {
    v13 = *a2;
    *v3 = *a2;
    v3 = (v13 + ((v7 + 16) & v8));
    v13;
  }

  else
  {
    v14 = *(v5 + 16);
    v14(a1, a2, v4);
    v14(((v3 + v9) & v8), ((a2 + v9) & v8), v4);
  }

  return v3;
}

uint64_t destroy for ClosedRange(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 16);
  v6 = *(v3 - 8) + 8;
  v7 = *v6;
  (*v6)(a1, v3);
  v4 = (*(v6 + 56) + a1 + *(v6 + 72)) & ~*(v6 + 72);

  return v7(v4, v3);
}

unint64_t initializeWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 16);
  v8 = v6 + 16;
  v7(a1, a2, v5);
  v7((*(v8 + 48) + *(v8 + 64) + a1) & ~*(v8 + 64), (*(v8 + 48) + *(v8 + 64) + a2) & ~*(v8 + 64), v5);
  return a1;
}

unint64_t assignWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 24);
  v8 = v6 + 24;
  v7(a1, a2, v5);
  v7((*(v8 + 40) + *(v8 + 56) + a1) & ~*(v8 + 56), (*(v8 + 40) + *(v8 + 56) + a2) & ~*(v8 + 56), v5);
  return a1;
}

unint64_t initializeWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 32);
  v8 = v6 + 32;
  v7(a1, a2, v5);
  v7((*(v8 + 32) + *(v8 + 48) + a1) & ~*(v8 + 48), (*(v8 + 32) + *(v8 + 48) + a2) & ~*(v8 + 48), v5);
  return a1;
}

unint64_t assignWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  v5 = *(a3 + 16);
  v6 = *(v5 - 8);
  v7 = *(v6 + 40);
  v8 = v6 + 40;
  v7(a1, a2, v5);
  v7((*(v8 + 24) + *(v8 + 40) + a1) & ~*(v8 + 40), (*(v8 + 24) + *(v8 + 40) + a2) & ~*(v8 + 40), v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for ClosedRange(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  if (!a2)
  {
    return 0;
  }

  v7 = a2 - v5;
  if (a2 <= v5)
  {
    return (*(v4 + 48))();
  }

  v6 = *(*(*(a3 + 16) - 8) + 64);
  v8 = ((v6 + *(v4 + 80)) & ~*(v4 + 80)) + v6;
  v9 = 8 * v8;
  if (v8 <= 3)
  {
    v11 = ((v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      v10 = *(a1 + v8);
      if (!v10)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      v10 = *(a1 + v8);
      if (!*(a1 + v8))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_22:
      if (v5)
      {
        return (*(v4 + 48))();
      }

      return 0;
    }
  }

  v10 = *(a1 + v8);
  if (!*(a1 + v8))
  {
    goto LABEL_22;
  }

LABEL_11:
  v12 = (v10 - 1) << v9;
  if (v8 > 3)
  {
    v12 = 0;
  }

  if (v8)
  {
    if (v8 > 3)
    {
      LODWORD(v8) = 4;
    }

    if (v8 > 2)
    {
      if (v8 == 3)
      {
        LODWORD(v8) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v8) = *a1;
      }
    }

    else if (v8 == 1)
    {
      LODWORD(v8) = *a1;
    }

    else
    {
      LODWORD(v8) = *a1;
    }
  }

  return v5 + (v8 | v12) + 1;
}

char *storeEnumTagSinglePayload for ClosedRange(char *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  v7 = ((*(v5 + 64) + *(v5 + 80)) & ~*(v5 + 80)) + *(v5 + 64);
  v8 = a3 >= v6;
  v9 = a3 - v6;
  if (v9 != 0 && v8)
  {
    if (v7 <= 3)
    {
      v14 = ((v9 + ~(-1 << (8 * v7))) >> (8 * v7)) + 1;
      if (HIWORD(v14))
      {
        v10 = 4;
      }

      else
      {
        if (v14 < 0x100)
        {
          v15 = 1;
        }

        else
        {
          v15 = 2;
        }

        if (v14 >= 2)
        {
          v10 = v15;
        }

        else
        {
          v10 = 0;
        }
      }
    }

    else
    {
      v10 = 1;
    }
  }

  else
  {
    v10 = 0;
  }

  if (v6 < a2)
  {
    v11 = ~v6 + a2;
    if (v7 < 4)
    {
      v13 = (v11 >> (8 * v7)) + 1;
      if (v7)
      {
        v16 = v11 & ~(-1 << (8 * v7));
        v17 = result;
        bzero(result, v7);
        result = v17;
        if (v7 != 3)
        {
          if (v7 == 2)
          {
            *v17 = v16;
            if (v10 > 1)
            {
LABEL_39:
              if (v10 == 2)
              {
                *&result[v7] = v13;
              }

              else
              {
                *&result[v7] = v13;
              }

              return result;
            }
          }

          else
          {
            *v17 = v11;
            if (v10 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *v17 = v16;
        v17[2] = BYTE2(v16);
      }

      if (v10 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      v12 = result;
      bzero(result, v7);
      result = v12;
      *v12 = v11;
      v13 = 1;
      if (v10 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v10)
    {
      result[v7] = v13;
    }

    return result;
  }

  if (v10 > 1)
  {
    if (v10 != 2)
    {
      *&result[v7] = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_28;
    }

    *&result[v7] = 0;
  }

  else if (v10)
  {
    result[v7] = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return result;
  }

LABEL_28:
  v18 = *(v5 + 56);

  return v18();
}

uint64_t type metadata completion function for Zip2Sequence(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 8) + 64;
    result = swift_checkMetadataState(319, *(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, v5, a1 + 48);
      return 0;
    }
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Zip2Sequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 64);
  v6 = *(a3 + 24);
  v7 = *(v6 - 8);
  v8 = *(v7 + 80);
  v9 = v5 + v8;
  v10 = ((v5 + v8) & ~v8) + *(v7 + 64);
  v11 = (*(v4 + 80) | *(v7 + 80));
  if (v11 > 7 || ((*(v4 + 80) | *(v7 + 80)) & 0x100000) != 0 || v10 > 0x18)
  {
    v14 = *a2;
    *v3 = *a2;
    v3 = (v14 + ((v11 + 16) & ~v11));
    v14;
  }

  else
  {
    v15 = ~v8;
    (*(v4 + 16))(a1);
    (*(v7 + 16))((v3 + v9) & v15, (a2 + v9) & v15, v6);
  }

  return v3;
}

uint64_t destroy for Zip2Sequence(uint64_t a1, uint64_t a2)
{
  v4 = *(*(a2 + 16) - 8) + 8;
  (*v4)();
  v5 = *(*(a2 + 24) - 8);
  v6 = *(v5 + 8);
  v7 = (*(v4 + 56) + a1 + *(v5 + 80)) & ~*(v5 + 80);

  return v6(v7);
}

uint64_t initializeWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(*(a3 + 16) - 8) + 16;
  (*v6)();
  v7 = *(*(a3 + 24) - 8);
  (*(v7 + 16))((*(v6 + 48) + *(v7 + 80) + a1) & ~*(v7 + 80), (*(v6 + 48) + *(v7 + 80) + a2) & ~*(v7 + 80));
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(*(a3 + 16) - 8) + 24;
  (*v6)();
  v7 = *(*(a3 + 24) - 8);
  (*(v7 + 24))((*(v6 + 40) + *(v7 + 80) + a1) & ~*(v7 + 80), (*(v6 + 40) + *(v7 + 80) + a2) & ~*(v7 + 80));
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(*(a3 + 16) - 8) + 32;
  (*v6)();
  v7 = *(*(a3 + 24) - 8);
  (*(v7 + 32))((*(v6 + 32) + *(v7 + 80) + a1) & ~*(v7 + 80), (*(v6 + 32) + *(v7 + 80) + a2) & ~*(v7 + 80));
  return a1;
}

uint64_t assignWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6 = *(*(a3 + 16) - 8) + 40;
  (*v6)();
  v7 = *(*(a3 + 24) - 8);
  (*(v7 + 40))((*(v6 + 24) + *(v7 + 80) + a1) & ~*(v7 + 80), (*(v6 + 24) + *(v7 + 80) + a2) & ~*(v7 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = *(a3 + 24);
  v7 = *(v6 - 8);
  v8 = *(v7 + 84);
  v9 = *(v7 + 80);
  if (v8 <= v5)
  {
    v10 = *(v4 + 84);
  }

  else
  {
    v10 = *(v7 + 84);
  }

  if (!a2)
  {
    return 0;
  }

  v11 = *(*(*(a3 + 16) - 8) + 64) + v9;
  v12 = a2 - v10;
  if (a2 <= v10)
  {
    goto LABEL_28;
  }

  v13 = (v11 & ~v9) + *(*(v6 - 8) + 64);
  v14 = 8 * v13;
  if (v13 <= 3)
  {
    v16 = ((v12 + ~(-1 << v14)) >> v14) + 1;
    if (HIWORD(v16))
    {
      v15 = *(a1 + v13);
      if (!v15)
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v16 > 0xFF)
    {
      v15 = *(a1 + v13);
      if (!*(a1 + v13))
      {
        goto LABEL_27;
      }

      goto LABEL_14;
    }

    if (v16 < 2)
    {
LABEL_27:
      if (v10)
      {
LABEL_28:
        if (v5 >= v8)
        {
          return (*(v4 + 48))();
        }

        else
        {
          return (*(v7 + 48))((a1 + v11) & ~v9, v8, v6);
        }
      }

      return 0;
    }
  }

  v15 = *(a1 + v13);
  if (!*(a1 + v13))
  {
    goto LABEL_27;
  }

LABEL_14:
  v17 = (v15 - 1) << v14;
  if (v13 > 3)
  {
    v17 = 0;
  }

  if (v13)
  {
    if (v13 <= 3)
    {
      v18 = v13;
    }

    else
    {
      v18 = 4;
    }

    if (v18 > 2)
    {
      if (v18 == 3)
      {
        v19 = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        v19 = *a1;
      }
    }

    else if (v18 == 1)
    {
      v19 = *a1;
    }

    else
    {
      v19 = *a1;
    }
  }

  else
  {
    v19 = 0;
  }

  return v10 + (v19 | v17) + 1;
}

char *storeEnumTagSinglePayload for Zip2Sequence(char *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  v7 = *(a4 + 24);
  v8 = *(v7 - 8);
  v9 = *(v8 + 84);
  v10 = *(v5 + 64);
  v11 = *(v8 + 80);
  if (v9 <= v6)
  {
    v12 = *(v5 + 84);
  }

  else
  {
    v12 = *(v8 + 84);
  }

  v13 = ((v10 + v11) & ~v11) + *(*(v7 - 8) + 64);
  v14 = a3 >= v12;
  v15 = a3 - v12;
  if (v15 != 0 && v14)
  {
    if (v13 <= 3)
    {
      v20 = ((v15 + ~(-1 << (8 * v13))) >> (8 * v13)) + 1;
      if (HIWORD(v20))
      {
        v16 = 4;
      }

      else
      {
        if (v20 < 0x100)
        {
          v21 = 1;
        }

        else
        {
          v21 = 2;
        }

        if (v20 >= 2)
        {
          v16 = v21;
        }

        else
        {
          v16 = 0;
        }
      }
    }

    else
    {
      v16 = 1;
    }
  }

  else
  {
    v16 = 0;
  }

  if (v12 < a2)
  {
    v17 = ~v12 + a2;
    if (v13 < 4)
    {
      v19 = (v17 >> (8 * v13)) + 1;
      if (v13)
      {
        v22 = v17 & ~(-1 << (8 * v13));
        v23 = result;
        bzero(result, v13);
        result = v23;
        if (v13 != 3)
        {
          if (v13 == 2)
          {
            *v23 = v22;
            if (v16 > 1)
            {
LABEL_46:
              if (v16 == 2)
              {
                *&result[v13] = v19;
              }

              else
              {
                *&result[v13] = v19;
              }

              return result;
            }
          }

          else
          {
            *v23 = v17;
            if (v16 > 1)
            {
              goto LABEL_46;
            }
          }

          goto LABEL_43;
        }

        *v23 = v22;
        v23[2] = BYTE2(v22);
      }

      if (v16 > 1)
      {
        goto LABEL_46;
      }
    }

    else
    {
      v18 = result;
      bzero(result, v13);
      result = v18;
      *v18 = v17;
      v19 = 1;
      if (v16 > 1)
      {
        goto LABEL_46;
      }
    }

LABEL_43:
    if (v16)
    {
      result[v13] = v19;
    }

    return result;
  }

  if (v16 > 1)
  {
    if (v16 != 2)
    {
      *&result[v13] = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_31;
    }

    *&result[v13] = 0;
  }

  else if (v16)
  {
    result[v13] = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_31;
  }

  if (!a2)
  {
    return result;
  }

LABEL_31:
  if (v6 >= v9)
  {
    v26 = *(v5 + 56);

    return v26();
  }

  else
  {
    v24 = *(v8 + 56);
    v25 = &result[v10 + v11] & ~v11;

    return v24(v25);
  }
}

uint64_t type metadata completion function for SIMDMask(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 48);
    return 0;
  }

  return result;
}

uint64_t type metadata completion function for EnumeratedSequence(uint64_t a1)
{
  result = swift_checkMetadataState(319, *(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, &v4, a1 + 32);
    return 0;
  }

  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for EnumeratedSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  v3 = a1;
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 80);
  if (v5 <= 7 && *(*(*(a3 + 16) - 8) + 64) <= 0x18uLL && (*(v4 + 80) & 0x100000) == 0)
  {
    (*(v4 + 16))(a1);
  }

  else
  {
    v8 = *a2;
    *v3 = *a2;
    v3 = (v8 + ((v5 + 16) & ~v5));
    v8;
  }

  return v3;
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  v4 = *(*(a3 + 16) - 8);
  v5 = *(v4 + 84);
  v6 = *(v4 + 64);
  if (!a2)
  {
    return 0;
  }

  v7 = a2 - v5;
  if (a2 <= v5)
  {
    return (*(v4 + 48))();
  }

  v8 = 8 * v6;
  if (v6 <= 3)
  {
    v10 = ((v7 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      v9 = *(a1 + v6);
      if (!v9)
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v10 > 0xFF)
    {
      v9 = *(a1 + v6);
      if (!*(a1 + v6))
      {
        goto LABEL_22;
      }

      goto LABEL_11;
    }

    if (v10 < 2)
    {
LABEL_22:
      if (v5)
      {
        return (*(v4 + 48))();
      }

      return 0;
    }
  }

  v9 = *(a1 + v6);
  if (!*(a1 + v6))
  {
    goto LABEL_22;
  }

LABEL_11:
  v11 = (v9 - 1) << v8;
  if (v6 > 3)
  {
    v11 = 0;
  }

  if (v6)
  {
    if (v6 > 3)
    {
      LODWORD(v6) = 4;
    }

    if (v6 > 2)
    {
      if (v6 == 3)
      {
        LODWORD(v6) = *a1 | (*(a1 + 2) << 16);
      }

      else
      {
        LODWORD(v6) = *a1;
      }
    }

    else if (v6 == 1)
    {
      LODWORD(v6) = *a1;
    }

    else
    {
      LODWORD(v6) = *a1;
    }
  }

  return v5 + (v6 | v11) + 1;
}

char *storeEnumTagSinglePayload for EnumeratedSequence(char *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  v5 = *(*(a4 + 16) - 8);
  v6 = *(v5 + 84);
  v7 = *(v5 + 64);
  v8 = a3 >= v6;
  v9 = a3 - v6;
  if (v9 != 0 && v8)
  {
    if (v7 <= 3)
    {
      v14 = ((v9 + ~(-1 << (8 * v7))) >> (8 * v7)) + 1;
      if (HIWORD(v14))
      {
        v10 = 4;
      }

      else
      {
        if (v14 < 0x100)
        {
          v15 = 1;
        }

        else
        {
          v15 = 2;
        }

        if (v14 >= 2)
        {
          v10 = v15;
        }

        else
        {
          v10 = 0;
        }
      }
    }

    else
    {
      v10 = 1;
    }
  }

  else
  {
    v10 = 0;
  }

  if (v6 < a2)
  {
    v11 = ~v6 + a2;
    if (v7 < 4)
    {
      v13 = (v11 >> (8 * v7)) + 1;
      if (v7)
      {
        v16 = v11 & ~(-1 << (8 * v7));
        v17 = result;
        bzero(result, v7);
        result = v17;
        if (v7 != 3)
        {
          if (v7 == 2)
          {
            *v17 = v16;
            if (v10 > 1)
            {
LABEL_39:
              if (v10 == 2)
              {
                *&result[v7] = v13;
              }

              else
              {
                *&result[v7] = v13;
              }

              return result;
            }
          }

          else
          {
            *v17 = v11;
            if (v10 > 1)
            {
              goto LABEL_39;
            }
          }

          goto LABEL_36;
        }

        *v17 = v16;
        v17[2] = BYTE2(v16);
      }

      if (v10 > 1)
      {
        goto LABEL_39;
      }
    }

    else
    {
      v12 = result;
      bzero(result, v7);
      result = v12;
      *v12 = v11;
      v13 = 1;
      if (v10 > 1)
      {
        goto LABEL_39;
      }
    }

LABEL_36:
    if (v10)
    {
      result[v7] = v13;
    }

    return result;
  }

  if (v10 > 1)
  {
    if (v10 != 2)
    {
      *&result[v7] = 0;
      if (!a2)
      {
        return result;
      }

      goto LABEL_28;
    }

    *&result[v7] = 0;
  }

  else if (v10)
  {
    result[v7] = 0;
    if (!a2)
    {
      return result;
    }

    goto LABEL_28;
  }

  if (!a2)
  {
    return result;
  }

LABEL_28:
  v18 = *(v5 + 56);

  return v18();
}

unint64_t *initializeBufferWithCopyOfBuffer for CollectionDifference(unint64_t *a1, unint64_t *a2)
{
  v3 = *a2;
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  v3;
  v4;
  return a1;
}

unint64_t *assignWithCopy for CollectionDifference(unint64_t *a1, unint64_t *a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  v6 = a2[1];
  v7 = a1[1];
  a1[1] = v6;
  v6;
  v7;
  return a1;
}

unint64_t *assignWithTake for CollectionDifference(unint64_t *a1, _OWORD *a2)
{
  *a1;
  v4 = a1[1];
  *a1 = *a2;
  v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 16))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *result = a2 & 0x7FFFFFFF;
    *(result + 8) = 0;
    if (a3 < 0)
    {
      *(result + 16) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 16) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

__n128 __swift_memcpy25_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  *(a1 + 9) = *(a2 + 9);
  *a1 = result;
  return result;
}

uint64_t initializeWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 8);
  *a1 = *a2;
  *(a1 + 8) = v3;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  v3;
  return a1;
}

uint64_t assignWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *(a1 + 8) = v4;
  v4;
  v5;
  v6 = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 16) = v6;
  return a1;
}

uint64_t assignWithTake for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *a1 = *a2;
  *(a1 + 8) = v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for _DictionaryCodingKey(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 25))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _DictionaryCodingKey(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0;
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 25) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = (a2 - 1);
      return result;
    }

    *(result + 25) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

void *initializeWithCopy for Dictionary.Keys.Iterator(void *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t))
{
  v5 = *a2;
  v6 = a2[1];
  v7 = a2[2];
  v8 = a2[3];
  v9 = a2[4];
  a4(*a2, v6, v7, v8, v9);
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  a1[3] = v8;
  a1[4] = v9;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator(uint64_t *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  v7 = *a2;
  v8 = a2[1];
  v9 = a2[2];
  v10 = a2[3];
  v11 = a2[4];
  a4(*a2, v8, v9, v10, v11);
  v12 = *a1;
  v13 = a1[1];
  v14 = a1[2];
  v15 = a1[3];
  v16 = a1[4];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v9;
  a1[3] = v10;
  a1[4] = v11;
  a5(v12, v13, v14, v15, v16);
  return a1;
}

void *assignWithTake for Dictionary.Keys.Iterator(void *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  v6 = *(a2 + 32);
  v7 = *a1;
  v9 = a1[1];
  v8 = a1[2];
  v10 = a1[3];
  v11 = a1[4];
  v12 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 1) = v12;
  a1[4] = v6;
  a4(v7, v9, v8, v10, v11);
  return a1;
}

uint64_t getEnumTagSinglePayload for Dictionary.Keys.Iterator(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0x7F && *(a1 + 40))
  {
    return (*a1 + 127);
  }

  v3 = (((*a1 >> 57) >> 6) | (2 * ((*a1 >> 57) & 0x38 | *a1 & 7))) ^ 0x7F;
  if (v3 >= 0x7E)
  {
    v3 = -1;
  }

  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for Dictionary.Keys.Iterator(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7E)
  {
    *(result + 8) = 0u;
    *(result + 24) = 0u;
    *result = a2 - 127;
    if (a3 >= 0x7F)
    {
      *(result + 40) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7F)
    {
      *(result + 40) = 0;
    }

    if (a2)
    {
      v3 = (-a2 >> 1) & 0x3F | ((-a2 & 0x7F) << 6);
      *result = (v3 | (v3 << 57)) & 0xF000000000000007;
      *(result + 8) = 0u;
      *(result + 24) = 0u;
    }
  }

  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index(uint64_t a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t))
{
  v5 = *a2;
  v6 = a2[1];
  v7 = *(a2 + 16);
  a4(*a2, v6, v7);
  *a1 = v5;
  *(a1 + 8) = v6;
  *(a1 + 16) = v7;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Index(uint64_t *a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t))
{
  v7 = *a2;
  v8 = a2[1];
  v9 = *(a2 + 16);
  a4(*a2, v8, v9);
  v10 = *a1;
  v11 = a1[1];
  v12 = *(a1 + 16);
  *a1 = v7;
  a1[1] = v8;
  *(a1 + 16) = v9;
  a5(v10, v11, v12);
  return a1;
}

uint64_t *assignWithTake for Dictionary.Index(uint64_t *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t))
{
  v5 = *(a2 + 16);
  v6 = *a1;
  v7 = a1[1];
  v8 = *(a1 + 16);
  *a1 = *a2;
  *(a1 + 16) = v5;
  a4(v6, v7, v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for Dictionary.Index(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFF && *(a1 + 17))
  {
    return (*a1 + 255);
  }

  v3 = *(a1 + 16);
  if (v3 <= 1)
  {
    v4 = -1;
  }

  else
  {
    v4 = v3 ^ 0xFF;
  }

  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for Dictionary.Index(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(result + 16) = 0;
    *result = a2 - 255;
    *(result + 8) = 0;
    if (a3 >= 0xFF)
    {
      *(result + 17) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF)
    {
      *(result + 17) = 0;
    }

    if (a2)
    {
      *(result + 16) = -a2;
    }
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for _Pair<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

uint64_t lazy protocol witness table accessor for type _Int128 and conformance _Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128, &type metadata for _Int128, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128, &type metadata for _Int128, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }

  return result;
}

uint64_t instantiation function for generic protocol witness table for _UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

uint64_t lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

uint64_t lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, &type metadata for _Int128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, &type metadata for _Int128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, &type metadata for _Int128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, &type metadata for _Int128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

uint64_t instantiation function for generic protocol witness table for _Int128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

uint64_t lazy protocol witness table accessor for type Slice<_Int128.Words> and conformance <> Slice<A>()
{
  result = lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>;
  if (!lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>)
  {
    v6[3] = v0;
    v6[4] = v1;
    v3 = __swift_instantiateConcreteTypeFromMangledNameAbstractV2(&_ss5SliceVys7_Int128V5WordsVGMd, _ss5SliceVys7_Int128V5WordsVGMR);
    v6[0] = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(v3, v4, v5);
    result = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, v3, v6);
    atomic_store(result, &lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>;
  if (!lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>)
  {
    v6[3] = v0;
    v6[4] = v1;
    v3 = __swift_instantiateConcreteTypeFromMangledNameAbstractV2(&_ss5SliceVys7_Int128V5WordsVGMd, _ss5SliceVys7_Int128V5WordsVGMR);
    v6[0] = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(v3, v4, v5);
    result = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, v3, v6);
    atomic_store(result, &lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>);
  }

  return result;
}

uint64_t lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, &type metadata for _UInt128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, &type metadata for _UInt128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, &type metadata for _UInt128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, &type metadata for _UInt128.Words, a3);
    atomic_store(result, &lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(unint64_t *a1, uint64_t *a2, unsigned __int8 *a3, int *a4)
{
  result = *a1;
  if (!result)
  {
    v7 = __swift_instantiateConcreteTypeFromMangledNameAbstractV2(a2, a3);
    result = swift_getWitnessTable(a4, v7, v8);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t instantiation function for generic protocol witness table for _UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

{
  result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(a1 + 8) = result;
  return result;
}

uint64_t lazy protocol witness table accessor for type Slice<_UInt128.Words> and conformance <> Slice<A>()
{
  result = lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>;
  if (!lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>)
  {
    v6[3] = v0;
    v6[4] = v1;
    v3 = __swift_instantiateConcreteTypeFromMangledNameAbstractV2(&_ss5SliceVys8_UInt128V5WordsVGMd, _ss5SliceVys8_UInt128V5WordsVGMR);
    v6[0] = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(v3, v4, v5);
    result = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, v3, v6);
    atomic_store(result, &lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>);
  }

  return result;
}

{
  result = lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>;
  if (!lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>)
  {
    v6[3] = v0;
    v6[4] = v1;
    v3 = __swift_instantiateConcreteTypeFromMangledNameAbstractV2(&_ss5SliceVys8_UInt128V5WordsVGMd, _ss5SliceVys8_UInt128V5WordsVGMR);
    v6[0] = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(v3, v4, v5);
    result = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, v3, v6);
    atomic_store(result, &lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>);
  }

  return result;
}

unint64_t partial apply for closure #1 in Unicode._InternalNFC.Iterator.next()()
{
  v1 = *(v0 + 16);
  v2 = *(v0 + 24);
  swift_getAssociatedTypeWitness(255, v2, v1, &protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v4 = v3;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v2, v1, v3, &protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v6 = *(AssociatedConformanceWitness + 16);
  v7 = swift_checkMetadataState(0, v4);
  v6(&v9, v7, AssociatedConformanceWitness);
  return v9 | (BYTE4(v9) << 32);
}

__n128 partial apply for closure #1 in _SwiftNSMutableArray.countByEnumerating(with:objects:count:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v4 = *(v3 + 16);
  v5 = *(v3 + 24);
  *(v4 + 8) = a1;
  *(v4 + 16) = &_fastEnumerationStorageMutationsTarget;
  *v4 = 1;
  result = *v4;
  v7 = *(v4 + 16);
  v8 = *(v4 + 48);
  *(v5 + 32) = *(v4 + 32);
  *(v5 + 48) = v8;
  *v5 = result;
  *(v5 + 16) = v7;
  *a3 = a2;
  return result;
}

char *partial apply for closure #1 in _SwiftNSMutableArray.getObjects(_:range:)(char *result, uint64_t a2)
{
  v3 = v2[2];
  if (v3 < 0 || v3 > a2)
  {
    goto LABEL_13;
  }

  v4 = v2[3];
  v5 = v3 + v4;
  if (__OFADD__(v3, v4))
  {
    __break(1u);
    goto LABEL_16;
  }

  if (v5 < 0 || v5 > a2)
  {
    goto LABEL_13;
  }

  if (!a2)
  {
    return result;
  }

  if (!result)
  {
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2);
  }

  if ((v4 - 0x1000000000000000) >> 61 != 7)
  {
LABEL_16:
    __break(1u);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2);
  }

  if (8 * v4 < 0)
  {
    goto LABEL_17;
  }

  v6 = &result[8 * v3];
  v7 = v2[4];

  return memmove(v7, v6, 8 * v4);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool)@<X0>(_BYTE *a1@<X8>)
{
  result = (*(v1 + 16))();
  *a1 = result & 1;
  return result;
}

BOOL partial apply for specialized closure #1 in _AbstractStringStorage._isEqual(_:)(void *__s2)
{
  v2 = *(v1 + 16);
  v3 = *(v1 + 24);
  if ((*(v3 + 32) & 0xFFFFFFFFFFFFLL) != v2)
  {
    return 0;
  }

  v5 = *(v3 + 24);
  return v5 == __s2 || memcmp(v5, __s2, v2) == 0;
}

{
  v2 = *(v1 + 16);
  v3 = *(v1 + 24);
  if ((*(v3 + 24) & 0xFFFFFFFFFFFFLL) != v2)
  {
    return 0;
  }

  if ((v3 + 32) == __s2)
  {
    return 1;
  }

  return memcmp((v3 + 32), __s2, v2) == 0;
}

uint64_t partial apply for specialized closure #1 in MutableCollection<>.partition(by:)@<X0>(uint64_t *a1@<X8>)
{
  result = specialized MutableCollection<>._partitionImpl(by:)(*(v1 + 16));
  if (!v2)
  {
    *a1 = result;
  }

  return result;
}

void *partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:)@<X0>(_BYTE *a1@<X8>)
{
  return partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:)(a1);
}

{
  result = (*(v1 + 16))(&v5);
  if (!v2)
  {
    *a1 = v5;
  }

  return result;
}

_BYTE *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(_BYTE *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  v3 = *result;
  v4 = v3 > 0x20;
  v5 = (1 << v3) & 0x100003E01;
  if (v4 || v5 == 0)
  {
    result = a2();
    if (result)
    {
      v8 = *result == 0;
    }

    else
    {
      v8 = 0;
    }

    *a3 = v8;
  }

  else
  {
    *a3 = 0;
  }

  return result;
}

uint64_t outlined destroy of Unicode._NFD.Iterator(uint64_t a1)
{
  *(a1 + 24);
  *(a1 + 48);
  return a1;
}

void outlined consume of CollectionDifference<A.Element>?<A, B>(unint64_t a1, unint64_t a2)
{
  if (a1)
  {
    a1;

    a2;
  }
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)(uint64_t a1, uint64_t a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)(a1, a2) & 1;
}

{
  return (*(v2 + 32))(a1, *a2, *(a2 + 8)) & 1;
}

__objc2_class **_ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_TP5TA@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __objc2_class ***a3@<X8>)
{
  result = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5(a1, a2, *(v3 + 32), *(v3 + 40), *(v3 + 48), *(v3 + 16), *(v3 + 24));
  if (!v4)
  {
    *a3 = result;
  }

  return result;
}

uint64_t outlined destroy of _HasContiguousBytes?(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  v4 = __swift_instantiateConcreteTypeFromMangledNameV2(a2, a3);
  (*(*(v4 - 8) + 8))(a1, v4);
  return a1;
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7 = *(v4 + 16);
  v6 = *(v4 + 24);
  v8 = *(v4 + 32);
  v9 = *(v4 + 40);
  v10 = *(type metadata accessor for Range(0, v7, v6, a4) + 36);
  if (v8 == 1)
  {
    v11 = (*(v6 + 32))(a1 + v10, v9, v7, v6);
  }

  else
  {
    v11 = (*(v6 + 40))(a1 + v10, v9, v7, v6);
  }

  return v11 & 1;
}

uint64_t partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7 = *(v4 + 16);
  v6 = *(v4 + 24);
  v8 = *(v4 + 32);
  v9 = *(v4 + 40);
  v10 = *(type metadata accessor for Range(0, v7, v6, a4) + 36);
  if (v8 == 1)
  {
    v11 = (*(v6 + 40))(a1, v9 + v10, v7, v6);
  }

  else
  {
    v11 = (*(v6 + 32))(a1, v9 + v10, v7, v6);
  }

  return v11 & 1;
}

uint64_t partial apply for closure #2 in closure #2 in closure #2 in KeyPath._projectReadOnly(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 <= 0)
  {
    _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2);
  }

  return (*(*(*(v3 + 24) - 8) + 32))(a3, a1);
}

uint64_t outlined consume of Mirror?(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    a2;

    return a5;
  }

  return result;
}

uint64_t outlined destroy of Mirror(uint64_t a1)
{
  *(a1 + 8);
  *(a1 + 32);
  return a1;
}

void sub_1806560A0()
{
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 2);

  swift_deallocObject(v0);
}

_OWORD *partial apply for closure #1 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v4 = *(v2 + 48);
  v5 = *a1;
  v12 = 0;
  v13 = 0;
  swift_reflectionMirror_subscript((v2 + 16), v4, v5, &v13, &v12, byte_1EEEAC6F8, v11);
  if (!v13)
  {
    v6 = 0;
    v8 = 0;
    v9 = v12;
    if (!v12)
    {
      goto LABEL_4;
    }

    goto LABEL_3;
  }

  v6 = specialized String.init(validatingUTF8:)(v13);
  v8 = v7;
  v9 = v12;
  if (v12)
  {
LABEL_3:
    (v9)(v13);
  }

LABEL_4:
  result = outlined init with take of Any(v11, (a2 + 16));
  *a2 = v6;
  *(a2 + 8) = v8;
  return result;
}

void sub_18065617C()
{
  if (v0[3])
  {
    v0[4];
    v0[7];
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 9);

  swift_deallocObject(v0);
}

unint64_t partial apply for closure #2 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>(uint64_t a1@<X8>)
{
  v3 = *(v1 + 16);
  v4 = *(v1 + 32);
  v5 = *(v1 + 56);
  result = swift_isClassType(v3);
  if (result)
  {
    v7 = v3 == 0;
  }

  else
  {
    v7 = 1;
  }

  if (v7 || (result = _swift_class_getSuperclass(v3)) == 0)
  {
    *(a1 + 25) = 0u;
    *a1 = 0u;
    *(a1 + 16) = 0u;
    return result;
  }

  v8 = *(v1 + 24);
  if (!v8)
  {
    goto LABEL_16;
  }

  v9 = *(v1 + 40);
  v10 = *(v1 + 48);
  v11 = *(v1 + 64);
  if (result != v8)
  {
    if (*(v1 + 64))
    {
      *a1 = v8;
      *(a1 + 8) = v4;
      *(a1 + 16) = v9;
      *(a1 + 24) = v10;
      *(a1 + 32) = v5;
      *(a1 + 40) = 1;
      goto LABEL_13;
    }

LABEL_16:
    v12 = result;
    outlined init with copy of Any(v1 + 72, v18);
    v13 = *(v1 + 40);
    v16 = *(v1 + 24);
    v17[0] = v13;
    *(v17 + 9) = *(v1 + 49);
    outlined init with copy of Mirror?(v1 + 24, &v19);
    result = Mirror.init(internalReflecting:subjectType:customAncestor:)(&v19, v18, v12, &v16);
    v14 = v20;
    v15 = v22;
    *a1 = v19;
    *(a1 + 16) = v14;
    *(a1 + 24) = v21;
    *(a1 + 40) = v15;
    return result;
  }

  *a1 = result;
  *(a1 + 8) = v4;
  *(a1 + 16) = v9;
  *(a1 + 24) = v10;
  *(a1 + 32) = v5;
  *(a1 + 40) = v11 & 1;
LABEL_13:
  v4;

  return v5;
}

void *outlined destroy of Mirror?(void *a1)
{
  if (*a1 >= 0xFFFFFFFFuLL)
  {
    a1[1];
    a1[4];
  }

  return a1;
}

uint64_t outlined init with copy of MirrorPath(uint64_t a1, uint64_t a2)
{
  v3 = *(a1 + 24);
  *(a2 + 24) = v3;
  *(a2 + 32) = *(a1 + 32);
  (**(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of (String, Any)(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned __int8 *a4)
{
  v6 = __swift_instantiateConcreteTypeFromMangledNameV2(a3, a4);
  (*(*(v6 - 8) + 16))(a2, a1, v6);
  return a2;
}

void sub_180656538()
{
  v1 = *(v0 + 2);
  v2 = *(v1 - 8);
  v3 = (*(v2 + 80) + 48) & ~*(v2 + 80);
  *(v0 + 4);
  (*(v2 + 8))(&v0[v3], v1);

  swift_deallocObject(v0);
}

void *partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:)@<X0>(uint64_t a1@<X8>)
{
  v2 = v1;
  v4 = *(v1 + 16);
  v5 = *(v4 - 8);
  v6 = *(v5 + 80);
  v7 = *(v1 + 40);
  result = (*(v1 + 24))(&v21);
  v9 = v21;
  v10 = v22;
  v11 = v23;
  v12 = v24;
  if (v21 != v7 && (v24 & 1) == 0)
  {
    v20[3] = v4;
    v14 = v21;
    v15 = v23;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v20);
    (*(v5 + 16))(boxed_opaque_existential_0Tm, v2 + ((v6 + 48) & ~v6), v4);
    v16 = v14;
    v17 = v10;
    v18 = v15;
    v19 = 0;
    result = Mirror.init(internalReflecting:subjectType:customAncestor:)(v20, v7, &v16, &v21);
    v9 = v21;
    LODWORD(v10) = v22;
    v11 = v23;
    v12 = v24;
  }

  *a1 = v9;
  *(a1 + 16) = v10;
  *(a1 + 24) = v11;
  *(a1 + 40) = v12;
  return result;
}

void sub_180656718()
{
  (*(*(v0[2] - 8) + 8))(v0 + ((*(*(v0[2] - 8) + 80) + 24) & ~*(*(v0[2] - 8) + 80)));

  swift_deallocObject(v0);
}

double partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(uint64_t a1@<X8>)
{
  v4 = *(*(v1 + 16) - 8);
  v5 = (*(v4 + 80) + 24) & ~*(v4 + 80);
  v6 = *(v1 + ((*(v4 + 64) + v5 + 7) & 0xFFFFFFFFFFFFFFF8));
  v13 = *(v1 + 16);
  v3 = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12);
  (*(v4 + 16))(boxed_opaque_existential_0Tm, v1 + v5, v3);
  memset(v11, 0, 41);
  Mirror.init(internalReflecting:subjectType:customAncestor:)(v12, v6, v11, &v14);
  v8 = v15;
  v9 = v17;
  *a1 = v14;
  *(a1 + 16) = v8;
  result = *&v16;
  *(a1 + 24) = v16;
  *(a1 + 40) = v9;
  return result;
}

uint64_t __swift_instantiateGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  v6[0] = a2;
  v6[1] = a3;
  v6[2] = a4;
  return swift_getGenericMetadata(a1, v6, a5);
}

uint64_t __swift_instantiateCanonicalPrespecializedGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, dispatch_once_t *predicate)
{
  v7[0] = a2;
  v7[1] = a3;
  v7[2] = a4;
  return swift_getCanonicalPrespecializedGenericMetadata(a1, v7, a5, predicate);
}

uint64_t initializeWithCopy for GetKeyPathClassAndInstanceSizeFromPattern(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 56) = *(a2 + 56);
  v3 = *(a2 + 64);
  *(a1 + 64) = v3;
  v3;
  return a1;
}

uint64_t assignWithCopy for GetKeyPathClassAndInstanceSizeFromPattern(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 17) = *(a2 + 17);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 56) = *(a2 + 56);
  v3 = *(a2 + 64);
  v4 = *(a1 + 64);
  *(a1 + 64) = v3;
  v3;
  v4;
  return a1;
}

uint64_t assignWithTake for GetKeyPathClassAndInstanceSizeFromPattern(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 17) = *(a2 + 17);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 40) = *(a2 + 40);
  *(a1 + 56) = *(a2 + 56);
  v3 = *(a1 + 64);
  *(a1 + 64) = *(a2 + 64);
  v3;
  return a1;
}

uint64_t getEnumTagSinglePayload for GetKeyPathClassAndInstanceSizeFromPattern(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 72))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 64);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for GetKeyPathClassAndInstanceSizeFromPattern(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 56) = 0u;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 72) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 64) = (a2 - 1);
      return result;
    }

    *(result + 72) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t initializeWithCopy for InstantiateKeyPathBuffer(uint64_t a1, uint64_t a2)
{
  v3 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v3;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v4 = *(a2 + 48);
  v5 = *(a2 + 56);
  *(a1 + 48) = v4;
  *(a1 + 56) = v5;
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 72) = *(a2 + 72);
  v4;
  return a1;
}

uint64_t assignWithCopy for InstantiateKeyPathBuffer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v4 = *(a2 + 48);
  v5 = *(a1 + 48);
  *(a1 + 48) = v4;
  v4;
  v5;
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 72) = *(a2 + 72);
  *(a1 + 80) = *(a2 + 80);
  return a1;
}

__n128 __swift_memcpy88_8(uint64_t a1, uint64_t a2)
{
  v2 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v2;
  result = *(a2 + 32);
  v4 = *(a2 + 48);
  v5 = *(a2 + 64);
  *(a1 + 80) = *(a2 + 80);
  *(a1 + 48) = v4;
  *(a1 + 64) = v5;
  *(a1 + 32) = result;
  return result;
}

uint64_t assignWithTake for InstantiateKeyPathBuffer(uint64_t a1, uint64_t a2)
{
  v4 = *(a2 + 16);
  *a1 = *a2;
  *(a1 + 16) = v4;
  *(a1 + 32) = *(a2 + 32);
  *(a1 + 40) = *(a2 + 40);
  v5 = *(a1 + 48);
  *(a1 + 48) = *(a2 + 48);
  v5;
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 64) = *(a2 + 64);
  *(a1 + 72) = *(a2 + 72);
  return a1;
}

uint64_t getEnumTagSinglePayload for InstantiateKeyPathBuffer(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 88))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 32);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for InstantiateKeyPathBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 72) = 0u;
    *(result + 56) = 0u;
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 88) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 32) = (a2 - 1);
      return result;
    }

    *(result + 88) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for _MergeError(unsigned int *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if ((a2 + 1) >= 0x10000)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 1) < 0x100)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    return *a1;
  }

  if (v3 == 2)
  {
    return *a1;
  }

  return *a1;
}

_WORD *storeEnumTagSinglePayload for _MergeError(_WORD *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 1) < 0x100)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (!a3)
  {
    v4 = 0;
  }

  if (a2)
  {
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *result = a2;
      }

      else
      {
        *result = a2;
      }
    }

    else if (v4)
    {
      *result = a2;
    }
  }

  else if (v4 > 1)
  {
    if (v4 == 2)
    {
      *result = 0;
    }

    else
    {
      *result = 0;
    }
  }

  else if (v4)
  {
    *result = 0;
  }

  return result;
}

__n128 __swift_memcpy56_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  v4 = *(a2 + 32);
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 16) = v3;
  *(a1 + 32) = v4;
  *a1 = result;
  return result;
}

uint64_t getEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 56))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8) >> 2;
  if (v2 > 0x80000000)
  {
    v3 = ~v2;
  }

  else
  {
    v3 = -1;
  }

  return (v3 + 1);
}

double storeEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2, int a3)
{
  if (a2 < 0)
  {
    result = 0.0;
    *(a1 + 40) = 0u;
    *(a1 + 24) = 0u;
    *(a1 + 8) = 0u;
    *a1 = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(a1 + 56) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *a1 = 0;
      *(a1 + 8) = 4 * -a2;
      result = 0.0;
      *(a1 + 16) = 0u;
      *(a1 + 32) = 0u;
      *(a1 + 48) = 0;
      return result;
    }

    *(a1 + 56) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTag for KeyPathComponent(uint64_t a1)
{
  v1 = *(a1 + 8) >> 61;
  if (v1 <= 4)
  {
    return v1;
  }

  else
  {
    return (*a1 + 5);
  }
}

uint64_t destructiveInjectEnumTag for KeyPathComponent(uint64_t result, uint64_t a2)
{
  if (a2 < 5)
  {
    *(result + 8) = *(result + 8) & 3 | (a2 << 61);
  }

  else
  {
    *result = (a2 - 5);
    *(result + 8) = 0xA000000000000000;
    *(result + 16) = 0u;
    *(result + 32) = 0u;
    *(result + 48) = 0;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for UTF8ValidationResult(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 24))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 1);
  if (v2 > 0x80000000)
  {
    v3 = ~v2;
  }

  else
  {
    v3 = -1;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for UTF8ValidationResult(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0;
    *(result + 16) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 24) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = 0;
      *(result + 16) = 0;
      *result = -a2 << 8;
      return result;
    }

    *(result + 24) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t storeEnumTagSinglePayload for _WordQuestion(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *result = 0;
    *(result + 8) = 0;
    *(result + 16) = 0;
    *result = a2 - 1;
    if (!a3)
    {
      return result;
    }

    v3 = 1;
  }

  else
  {
    if (!a3)
    {
      return result;
    }

    v3 = 0;
  }

  *(result + 17) = v3;
  return result;
}

uint64_t getEnumTag for _WordQuestion(uint64_t a1)
{
  if (*(a1 + 16))
  {
    return (*a1 + 1);
  }

  else
  {
    return 0;
  }
}

uint64_t destructiveInjectEnumTag for _WordQuestion(uint64_t result, int a2)
{
  if (a2)
  {
    *result = (a2 - 1);
    *(result + 8) = 0;
    *(result + 16) = 1;
  }

  else
  {
    *(result + 16) = 0;
  }

  return result;
}

void destroy for Unicode._NFCNormalizer(uint64_t a1)
{
  *(a1 + 16);
  v2 = *(a1 + 40);

  v2;
}

uint64_t initializeWithCopy for Unicode._NFCNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 1) = *(a2 + 1);
  *(a1 + 8) = *(a2 + 8);
  v3 = *(a2 + 16);
  *(a1 + 16) = v3;
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 28) = *(a2 + 28);
  *(a1 + 31) = *(a2 + 31);
  *(a1 + 35) = *(a2 + 35);
  v4 = *(a2 + 40);
  *(a1 + 40) = v4;
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 52) = *(a2 + 52);
  *(a1 + 56) = *(a2 + 56);
  v3;
  v4;
  return a1;
}

uint64_t assignWithCopy for Unicode._NFCNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 1) = *(a2 + 1);
  *(a1 + 2) = *(a2 + 2);
  *(a1 + 8) = *(a2 + 8);
  v4 = *(a2 + 16);
  v5 = *(a1 + 16);
  *(a1 + 16) = v4;
  v4;
  v5;
  *(a1 + 24) = *(a2 + 24);
  v6 = *(a2 + 28);
  *(a1 + 31) = *(a2 + 31);
  *(a1 + 28) = v6;
  *(a1 + 35) = *(a2 + 35);
  v7 = *(a2 + 40);
  v8 = *(a1 + 40);
  *(a1 + 40) = v7;
  v7;
  v8;
  *(a1 + 48) = *(a2 + 48);
  v9 = *(a2 + 52);
  *(a1 + 56) = *(a2 + 56);
  *(a1 + 52) = v9;
  return a1;
}

__n128 __swift_memcpy57_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  v3 = *(a2 + 16);
  v4 = *(a2 + 32);
  *(a1 + 41) = *(a2 + 41);
  *(a1 + 16) = v3;
  *(a1 + 32) = v4;
  *a1 = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFCNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  *(a1 + 1) = *(a2 + 1);
  *(a1 + 2) = *(a2 + 2);
  *(a1 + 8) = *(a2 + 8);
  v4 = *(a1 + 16);
  *(a1 + 16) = *(a2 + 16);
  v4;
  *(a1 + 24) = *(a2 + 24);
  *(a1 + 28) = *(a2 + 28);
  *(a1 + 31) = *(a2 + 31);
  *(a1 + 35) = *(a2 + 35);
  v5 = *(a1 + 40);
  *(a1 + 40) = *(a2 + 40);
  v5;
  *(a1 + 48) = *(a2 + 48);
  *(a1 + 52) = *(a2 + 52);
  *(a1 + 56) = *(a2 + 56);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFCNormalizer(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 57))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 16);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFCNormalizer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 40) = 0u;
    *(result + 24) = 0u;
    *(result + 8) = 0u;
    *(result + 56) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 57) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 16) = (a2 - 1);
      return result;
    }

    *(result + 57) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t initializeWithCopy for Unicode._NFDNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v3 = *(a2 + 8);
  *(a1 + 8) = v3;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 20) = *(a2 + 20);
  *(a1 + 23) = *(a2 + 23);
  *(a1 + 27) = *(a2 + 27);
  v3;
  return a1;
}

uint64_t assignWithCopy for Unicode._NFDNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a2 + 8);
  v5 = *(a1 + 8);
  *(a1 + 8) = v4;
  v4;
  v5;
  *(a1 + 16) = *(a2 + 16);
  v6 = *(a2 + 20);
  *(a1 + 23) = *(a2 + 23);
  *(a1 + 20) = v6;
  *(a1 + 27) = *(a2 + 27);
  return a1;
}

__n128 __swift_memcpy28_8(uint64_t a1, uint64_t a2)
{
  result = *a2;
  *(a1 + 12) = *(a2 + 12);
  *a1 = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFDNormalizer(uint64_t a1, uint64_t a2)
{
  *a1 = *a2;
  v4 = *(a1 + 8);
  *(a1 + 8) = *(a2 + 8);
  v4;
  *(a1 + 16) = *(a2 + 16);
  *(a1 + 20) = *(a2 + 20);
  *(a1 + 23) = *(a2 + 23);
  *(a1 + 27) = *(a2 + 27);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFDNormalizer(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 28))
  {
    return *a1 + 0x80000000;
  }

  v2 = *(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFDNormalizer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0;
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 28) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *(result + 8) = (a2 - 1);
      return result;
    }

    *(result + 28) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for KeyPathComponent.ArgumentRef(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 != 1 && *(a1 + 32))
  {
    return (*a1 + 2);
  }

  if (*(a1 + 16))
  {
    v3 = -1;
  }

  else
  {
    v3 = 0;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for KeyPathComponent.ArgumentRef(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(result + 16) = 0;
    *(result + 24) = 0;
    *result = a2 - 2;
    *(result + 8) = 0;
    if (a3 >= 2)
    {
      *(result + 32) = 1;
    }
  }

  else
  {
    if (a3 >= 2)
    {
      *(result + 32) = 0;
    }

    if (a2)
    {
      *(result + 16) = 0;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for ComputedPropertyID(uint64_t a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 >= 0xFE && *(a1 + 9))
  {
    return (*a1 + 254);
  }

  v3 = *(a1 + 8);
  v4 = v3 >= 3;
  v5 = v3 - 3;
  if (!v4)
  {
    v5 = -1;
  }

  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for ComputedPropertyID(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(result + 8) = 0;
    *result = a2 - 254;
    if (a3 >= 0xFE)
    {
      *(result + 9) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE)
    {
      *(result + 9) = 0;
    }

    if (a2)
    {
      *(result + 8) = a2 + 2;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Bool(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFF)
  {
    goto LABEL_17;
  }

  if (a2 + 1 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 1) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 1;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 2;
  v8 = (v6 + 2147483646) & 0x7FFFFFFF;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for Bool(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 1) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xFF)
  {
    v4 = 0;
  }

  if (a2 > 0xFE)
  {
    v5 = ((a2 - 255) >> 8) + 1;
    *result = a2 + 1;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 1;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t getEnumTagSinglePayload for FloatingPointSign(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFF)
  {
    goto LABEL_17;
  }

  if (a2 + 1 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 1) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 1;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 2;
  v8 = v6 - 2;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t initializeBufferWithCopyOfBuffer for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  v3 = *a2;
  *a1 = *a2;
  *(a1 + 8) = *(a2 + 8);
  v3;
  return a1;
}

uint64_t assignWithCopy for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  v4 = *a2;
  v5 = *a1;
  *a1 = *a2;
  v4;
  v5;
  *(a1 + 8) = *(a2 + 8);
  return a1;
}

uint64_t assignWithTake for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  v4 = *a1;
  *a1 = *a2;
  v4;
  *(a1 + 8) = *(a2 + 8);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t *a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0 && *(a1 + 9))
  {
    return *a1 + 0x80000000;
  }

  v2 = *a1;
  if (*a1 >= 0xFFFFFFFF)
  {
    LODWORD(v2) = -1;
  }

  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(result + 8) = 0;
    *result = a2 & 0x7FFFFFFF;
    if (a3 < 0)
    {
      *(result + 9) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
      {
        return result;
      }

LABEL_8:
      *result = (a2 - 1);
      return result;
    }

    *(result + 9) = 0;
    if (a2)
    {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer(uint64_t a1, int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 != 1 && *(a1 + 8))
  {
    return (*a1 + 2);
  }

  if (*a1)
  {
    v3 = -1;
  }

  else
  {
    v3 = 0;
  }

  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *result = a2 - 2;
    if (a3 >= 2)
    {
      *(result + 8) = 1;
    }
  }

  else
  {
    if (a3 >= 2)
    {
      *(result + 8) = 0;
    }

    if (a2)
    {
      *result = 0;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Unicode.NumericType(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    return 0;
  }

  if (a2 < 0xFE)
  {
    goto LABEL_17;
  }

  if (a2 + 2 >= 0xFFFF00)
  {
    v2 = 4;
  }

  else
  {
    v2 = 2;
  }

  if ((a2 + 2) >> 8 < 0xFF)
  {
    v3 = 1;
  }

  else
  {
    v3 = v2;
  }

  if (v3 == 4)
  {
    v4 = *(a1 + 1);
    if (v4)
    {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

  else
  {
    if (v3 == 2)
    {
      v4 = *(a1 + 1);
      if (!*(a1 + 1))
      {
        goto LABEL_17;
      }

      return (*a1 | (v4 << 8)) - 2;
    }

    v4 = a1[1];
    if (a1[1])
    {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

LABEL_17:
  v6 = *a1;
  v7 = v6 >= 3;
  v8 = v6 - 3;
  if (!v7)
  {
    v8 = -1;
  }

  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode.NumericType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00)
  {
    v3 = 4;
  }

  else
  {
    v3 = 2;
  }

  if ((a3 + 2) >> 8 < 0xFF)
  {
    v4 = 1;
  }

  else
  {
    v4 = v3;
  }

  if (a3 < 0xFE)
  {
    v4 = 0;
  }

  if (a2 > 0xFD)
  {
    v5 = ((a2 - 254) >> 8) + 1;
    *result = a2 + 2;
    if (v4 > 1)
    {
      if (v4 == 2)
      {
        *(result + 1) = v5;
      }

      else
      {
        *(result + 1) = v5;
      }
    }

    else if (v4)
    {
      *(result + 1) = v5;
    }

    return result;
  }

  if (v4 > 1)
  {
    if (v4 != 2)
    {
      *(result + 1) = 0;
      if (a2)
      {
        goto LABEL_20;
      }

      return result;
    }

    *(result + 1) = 0;
  }

  else if (v4)
  {
    *(result + 1) = 0;
    if (!a2)
    {
      return result;
    }

LABEL_20:
    *result = a2 + 2;
    return result;
  }

  if (a2)
  {
    goto LABEL_20;
  }

  return result;
}

uint64_t _swift_stdlib_overrideUnsafeArgvArgc(uint64_t result, int a2)
{
  _swift_stdlib_ProcessOverrideUnsafeArgv = result;
  _swift_stdlib_ProcessOverrideUnsafeArgc = a2;
  return result;
}

char **_swift_stdlib_getUnsafeArgvArgc(int *a1)
{
  result = _swift_stdlib_ProcessOverrideUnsafeArgv;
  if (_swift_stdlib_ProcessOverrideUnsafeArgv)
  {
    v3 = _swift_stdlib_ProcessOverrideUnsafeArgc;
  }

  else
  {
    *a1 = *_NSGetArgc();
    result = *_NSGetArgv();
    if (result)
    {
      return result;
    }

    v3 = 0;
    result = &_swift_stdlib_getUnsafeArgvArgc::emptyArgv;
  }

  *a1 = v3;
  return result;
}

BOOL __isOSVersionAtLeast(int a1, int a2, int a3)
{
  if (qword_1ED42CF70 == -1)
  {
    v3 = _MergedGlobals_2 < a1;
    if (_MergedGlobals_2 > a1)
    {
      return 1;
    }
  }

  else
  {
    v5 = a3;
    v6 = a2;
    __isOSVersionAtLeast_cold_1();
    a2 = v6;
    a3 = v5;
    v3 = _MergedGlobals_2 < a1;
    if (_MergedGlobals_2 > a1)
    {
      return 1;
    }
  }

  if (v3)
  {
    return 0;
  }

  if (dword_1ED42CF64 > a2)
  {
    return 1;
  }

  if (dword_1ED42CF64 < a2)
  {
    return 0;
  }

  return dword_1ED42CF68 >= a3;
}

uint64_t __isPlatformVersionAtLeast(uint64_t a1, int a2, int a3, int a4)
{
  if (qword_1ED42CF78 == -1)
  {
    if (qword_1ED42CF80)
    {
      return _availability_version_check();
    }
  }

  else
  {
    v5 = a4;
    v6 = a3;
    v7 = a2;
    __isPlatformVersionAtLeast_cold_1();
    a2 = v7;
    a3 = v6;
    a4 = v5;
    if (qword_1ED42CF80)
    {
      return _availability_version_check();
    }
  }

  if (qword_1ED42CF70 != -1)
  {
    v9 = a4;
    v10 = a3;
    v11 = a2;
    __isOSVersionAtLeast_cold_1();
    a3 = v10;
    a4 = v9;
    v8 = _MergedGlobals_2 < v11;
    if (_MergedGlobals_2 > v11)
    {
      return 1;
    }

LABEL_7:
    if (!v8)
    {
      if (dword_1ED42CF64 > a3)
      {
        return 1;
      }

      if (dword_1ED42CF64 >= a3)
      {
        return dword_1ED42CF68 >= a4;
      }
    }

    return 0;
  }

  v8 = _MergedGlobals_2 < a2;
  if (_MergedGlobals_2 <= a2)
  {
    goto LABEL_7;
  }

  return 1;
}

uint64_t _initializeAvailabilityCheck(uint64_t result)
{
  v29 = *MEMORY[0x1E69E9840];
  v1 = qword_1ED42CF80;
  if (qword_1ED42CF80)
  {
    v2 = result == 0;
  }

  else
  {
    v2 = 0;
  }

  if (!v2)
  {
    if (MEMORY[0x1EEE9AC60])
    {
      v1 = MEMORY[0x1EEE9AC60];
      qword_1ED42CF80 = MEMORY[0x1EEE9AC60];
    }

    if (v1)
    {
      v3 = result == 0;
    }

    else
    {
      v3 = 0;
    }

    if (!v3)
    {
      result = dlsym(0xFFFFFFFFFFFFFFFELL, "kCFAllocatorNull");
      if (result)
      {
        v4 = *result;
        result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFDataCreateWithBytesNoCopy");
        if (result)
        {
          v5 = result;
          v6 = dlsym(0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateWithData");
          result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateFromXMLData");
          if (v6 | result)
          {
            v7 = result;
            result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFStringCreateWithCStringNoCopy");
            if (result)
            {
              v8 = result;
              result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFDictionaryGetValue");
              if (result)
              {
                v9 = result;
                result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFGetTypeID");
                if (result)
                {
                  v10 = result;
                  result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFStringGetTypeID");
                  if (result)
                  {
                    v11 = result;
                    result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFStringGetCString");
                    v27 = result;
                    if (result)
                    {
                      result = dlsym(0xFFFFFFFFFFFFFFFELL, "CFRelease");
                      if (result)
                      {
                        v12 = result;
                        result = fopen("/System/Library/CoreServices/SystemVersion.plist", "r");
                        if (result)
                        {
                          v13 = result;
                          v26 = v12;
                          fseek(result, 0, 2);
                          v14 = MEMORY[0x1865C97A0](v13);
                          if (v14 < 0)
                          {
                            v16 = 0;
                          }

                          else
                          {
                            v15 = v14;
                            rewind(v13);
                            v16 = malloc(v15);
                            if (v16)
                            {
                              v25 = v16;
                              if (fread(v16, 1uLL, v15, v13) == v15 && (v17 = v5(0, v25, v15, v4)) != 0)
                              {
                                v18 = v17;
                                if (v6)
                                {
                                  v19 = (v6)(0, v17, 0, 0, 0);
                                }

                                else
                                {
                                  v19 = v7(0, v17, 0, 0);
                                }

                                v20 = v19;
                                if (v19)
                                {
                                  v21 = v8(0, "ProductVersion", 1536, v4);
                                  if (v21)
                                  {
                                    v22 = v21;
                                    v23 = v9(v20, v21);
                                    (v26)(v22);
                                    if (v23)
                                    {
                                      v24 = v10(v23);
                                      if (v24 == v11())
                                      {
                                        if (v27(v23, v28, 32, 134217984))
                                        {
                                          sscanf(v28, "%d.%d.%d", &_MergedGlobals_2, &dword_1ED42CF64, &dword_1ED42CF68);
                                        }
                                      }
                                    }
                                  }

                                  (v26)(v20);
                                }

                                (v26)(v18);
                                v16 = v25;
                              }

                              else
                              {
                                v16 = v25;
                              }
                            }
                          }

                          free(v16);
                          return fclose(v13);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

void swift::ConcurrentReadableHashMap<anonymous namespace::HashableConformanceEntry,swift::LazyMutex>::find<anonymous namespace::HashableConformanceKey>()
{
  {
    v0 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
    if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override)
    {
      v0 = 0xFF51AFD7ED558CCDLL;
    }

    __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v0;
  }
}

void multiPayloadEnumFNResolved<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  v8 = *((*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
  v9 = *(((*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL) + 8);
  v10 = *(((*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL) + 0x10);
  v11 = *a2 + 32;
  v12 = *a3;
  v13 = (*(*a2 & 0x7FFFFFFFFFFFFFFFLL))(a4 + *a3);
  *a2 = v11 + v9 + 8 * v8;
  *a3 += v10;
  if (v8 > v13)
  {
    OUTLINED_FUNCTION_2();
    v18 = v12 + (v14 & 0xFFFFFFFFFFFFFFLL);
    for (i = v15 + 8; HIBYTE(v14); i = v16 + 8)
    {
      (destroyTable[HIBYTE(v14)])(a1, &i, &v18, a4);
      OUTLINED_FUNCTION_2();
      v18 = v17 + (v14 & 0xFFFFFFFFFFFFFFLL);
    }
  }
}

void handleRefCountsDestroy()
{
  OUTLINED_FUNCTION_2();
  *v1 = v5 + 8;
  *v2 += v4 & 0xFFFFFFFFFFFFFFLL;
  if (HIBYTE(v4))
  {
    v6 = v3;
    v7 = v2;
    v8 = v1;
    v9 = v0;
    do
    {
      (destroyTable[HIBYTE(v4)])(v9, v8, v7, v6);
      OUTLINED_FUNCTION_2();
      *v8 = v10 + 8;
      *v7 += v4 & 0xFFFFFFFFFFFFFFLL;
    }

    while (HIBYTE(v4));
  }
}

void handleRefCountsInitWithCopy()
{
  OUTLINED_FUNCTION_1();
  while (1)
  {
    v4 = *v2;
    v5 = *(*v3 & 0x7FFFFFFFFFFFFFFFLL);
    *v3 += 8;
    if ((v5 & 0xFFFFFFFFFFFFFFLL) != 0)
    {
      memcpy((v1 + v4), (v0 + v4), v5 & 0xFFFFFFFFFFFFFFLL);
    }

    *v2 = (v5 & 0xFFFFFFFFFFFFFFLL) + v4;
    if (!HIBYTE(v5))
    {
      break;
    }

    v6 = OUTLINED_FUNCTION_0_0();
    v7(v6);
  }
}

void *singlePayloadEnumFNResolvedAssignWithCopy(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v9 = *(*a2 & 0x7FFFFFFFFFFFFFFFLL);
  v10 = *((*a2 & 0x7FFFFFFFFFFFFFFFLL) + 8);
  v11 = *((*a2 & 0x7FFFFFFFFFFFFFFFLL) + 0x10);
  v12 = *a2 + 24;
  v24 = v12;
  v13 = v9(a5 + *a3);
  result = v9(a4 + *a3);
  if (v13 | result)
  {
    if (v13)
    {
      if (result)
      {
        v12 += v10;
      }

      else
      {
        v25 = *a3;
        if (v10 >= 1)
        {
          v19 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
          v20 = (v12 & 0x7FFFFFFFFFFFFFFFLL) + v10;
          do
          {
            v21 = *v19;
            v12 += 8;
            v24 = v12;
            v25 += v21 & 0xFFFFFFFFFFFFFFLL;
            v22 = HIBYTE(v21);
            if (v22)
            {
              (destroyTable[v22])(a1, &v24, &v25, a4);
              v12 = v24;
            }

            v19 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
          }

          while (v20 > (v12 & 0x7FFFFFFFFFFFFFFFuLL));
        }
      }

      result = memcpy((a4 + *a3), (a5 + *a3), v11);
      *a3 += v11;
    }

    else if (v10 >= 1)
    {
      v15 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
      v16 = (v12 & 0x7FFFFFFFFFFFFFFFLL) + v10;
      do
      {
        v17 = *v15;
        v12 += 8;
        v24 = v12;
        v18 = *a3;
        if ((v17 & 0xFFFFFFFFFFFFFFLL) != 0)
        {
          result = memcpy((a4 + v18), (a5 + v18), v17 & 0xFFFFFFFFFFFFFFLL);
        }

        *a3 = v18 + (v17 & 0xFFFFFFFFFFFFFFLL);
        if (HIBYTE(v17))
        {
          result = (initWithCopyTable[HIBYTE(v17)])(a1, &v24, a3, a4, a5);
          v12 = v24;
        }

        v15 = (v12 & 0x7FFFFFFFFFFFFFFFLL);
      }

      while (v16 > (v12 & 0x7FFFFFFFFFFFFFFFuLL));
    }
  }

  *a2 = v12;
  return result;
}

void handleSingleRefCountInitWithCopy()
{
  OUTLINED_FUNCTION_1();
  v4 = *(*v3 & 0x7FFFFFFFFFFFFFFFLL);
  *v3 += 8;
  v6 = *v5;
  if ((v4 & 0xFFFFFFFFFFFFFFLL) != 0)
  {
    memcpy((v1 + v6), (v0 + v6), v4 & 0xFFFFFFFFFFFFFFLL);
  }

  *v2 = v6 + (v4 & 0xFFFFFFFFFFFFFFLL);
  if (HIBYTE(v4))
  {
    v7 = OUTLINED_FUNCTION_0_0();

    v8(v7);
  }
}

uint64_t handleSingleRefCountDestroy(uint64_t a1, void *a2, void *a3)
{
  v3 = *(*a2 & 0x7FFFFFFFFFFFFFFFLL);
  *a2 += 8;
  *a3 += v3 & 0xFFFFFFFFFFFFFFLL;
  if (HIBYTE(v3))
  {
    return destroyTable[HIBYTE(v3)]();
  }

  return result;
}

uint64_t *findBridgeWitness(uint64_t *result, void *a2)
{
  v2 = *result;
  if (*result > 0x7FF)
  {
    LODWORD(v2) = 0;
  }

  if (v2 != 772)
  {
    if (v2 == 774 && (result[2] & 0x80FFFFFF) == 0)
    {
      v3 = &protocol witness table for _BridgeableMetatype;
      goto LABEL_14;
    }

LABEL_13:
    v3 = 0;
    goto LABEL_14;
  }

  if (*result[1] <= 0x7FFuLL)
  {
    v4 = *result[1];
  }

  else
  {
    v4 = 0;
  }

  v3 = &protocol witness table for _BridgeableMetatype;
  if (v4 && v4 != 515 && v4 != 773)
  {
    goto LABEL_13;
  }

LABEL_14:
  *a2 = v3;
  return result;
}

void findBridgeWitness(swift *a1)
{
  if (__cxa_guard_acquire(&qword_1ED415EC8))
  {
    _MergedGlobals = swift_conformsToProtocolCommon(a1, &protocol descriptor for _ObjectiveCBridgeable);

    __cxa_guard_release(&qword_1ED415EC8);
  }
}

{
  if (__cxa_guard_acquire(&qword_1ED415F18))
  {
    _MergedGlobals_0 = swift_conformsToProtocolCommon(a1, &protocol descriptor for _ObjectiveCBridgeable);

    __cxa_guard_release(&qword_1ED415F18);
  }
}

void getNonNullSrcObject(Class *a1, Class *a2)
{
  swift::nameForMetadata(&__p, a1, 1);
  v4 = swift::nameForMetadata(&v11, a2, 1);
  v5 = swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration(v4);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }

  else
  {
    p_p = __p.__r_.__value_.__r.__words[0];
  }

  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v9 = &v11;
  }

  else
  {
    v9 = v11.__r_.__value_.__r.__words[0];
  }

  if (!v5)
  {
    swift::fatalError(v5, "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (Detected while casting to '%s' (%p))%s\n", v6, v7, p_p, a1, v9, a2, "");
  }

  swift::warning(0, "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (Detected while casting to '%s' (%p))%s\n", v6, v7, p_p, a1, v9, a2, ": Continuing with null object, but expect problems later.");
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v11.__r_.__value_.__l.__data_);
  }

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void swift_deallocClassInstance_cold_1(unint64_t **a1, uint64_t a2)
{
  if (*a1)
  {
    v4 = *a1;
  }

  else
  {
    v4 = 0;
  }

  TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(v4);
  if (TypeContextDescriptor)
  {
    v8 = (TypeContextDescriptor + 8 + *(TypeContextDescriptor + 8));
  }

  else
  {
    v8 = "<unknown>";
  }

  swift::fatalError(0, "Object %p of class %s deallocated with non-zero retain count %zd. This object's deinit, or something called from it, may have created a strong reference to self which outlived deinit, resulting in a dangling reference.\n", v6, v7, a1, v8, a2 + 1);
}

uint64_t swift::getLibPrespecializedTypeDescriptor(uint64_t a1, uint64_t a2, const void *a3)
{
  swift::Demangle::__runtime::mangleNode(a3);
  if (*a1)
  {
    if (prespecializedLoggingEnabled)
    {
      fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Failed to build demangling for node %p.\n", a3);
    }

    return 0;
  }

  else
  {
    if (prespecializedLoggingEnabled)
    {
      fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Looking up descriptor named '%.*s'.\n", *(a1 + 32), *(a1 + 24));
    }

    return 1;
  }
}

void LibPrespecializedState::LibPrespecializedState()
{
  OUTLINED_FUNCTION_0_3(&swift::runtime::environment::initializeToken);
}

{
  dispatch_once_f(&swift::runtime::environment::initializeToken, 0, swift::runtime::environment::initialize);
}

uint64_t LibPrespecializedState::LibPrespecializedState(uint64_t a1)
{
  v1 = "true";
  if (!a1)
  {
    v1 = "false";
  }

  return fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Setting descriptorMapEnabled=%s from the option flags.\n", v1);
}

uint64_t LibPrespecializedState::LibPrespecializedState(char a1)
{
  v1 = "true";
  if (a1)
  {
    v1 = "false";
  }

  return fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Toggling descriptorMapEnabled to %s togglePrespecializationDescriptorMap is set.\n", v1);
}

{
  v1 = "false";
  if (a1)
  {
    v1 = "true";
  }

  return fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Setting descriptorMapEnabled=%s from SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP.\n", v1);
}

uint64_t LibPrespecializedState::findLibPrespecialized()
{
  v0 = *MEMORY[0x1E69E9848];
  v1 = dyld_shared_cache_some_image_overridden();
  return fprintf(v0, "Prespecializations library: Disabling prespecialized metadata, dyld_shared_cache_some_image_overridden = %d\n", v1);
}

uint64_t LibPrespecializedState::findLibPrespecialized(_DWORD *a1, void *a2)
{
  v4 = MEMORY[0x1E69E9848];
  result = fprintf(*MEMORY[0x1E69E9848], "Prespecializations library: Returning data %p, major version %u minor %u\n", a1, *a1, a1[1]);
  if (prespecializedLoggingEnabled)
  {
    v6 = OUTLINED_FUNCTION_2_0();
    v8 = v7 > 2 ? *(a1 + 4) : 0;
    result = fprintf(v6, "Prespecializations library:   optionFlags=%#zx\n", v8);
    if (prespecializedLoggingEnabled)
    {
      result = fprintf(*v4, "Prespecializations library:   metadataMap=%p\n", *(a1 + 1));
      if (prespecializedLoggingEnabled)
      {
        v9 = OUTLINED_FUNCTION_2_0();
        v11 = v10 > 1 ? *(a1 + 2) : 0;
        result = fprintf(v9, "Prespecializations library:   disabledProcessTable=%p\n", v11);
        if (prespecializedLoggingEnabled)
        {
          v12 = OUTLINED_FUNCTION_2_0();
          v14 = v13 > 2 ? *(a1 + 3) : 0;
          result = fprintf(v12, "Prespecializations library:   pointerKeyedMetadataMap=%p\n", v14);
          if (prespecializedLoggingEnabled)
          {
            v15 = OUTLINED_FUNCTION_2_0();
            if (v16 > 3)
            {
              v17 = *(a1 + 5);
            }

            else
            {
              v17 = 0;
            }

            result = fprintf(v15, "Prespecializations library:   descriptorMap=%p\n", v17);
          }
        }
      }
    }
  }

  *a2 = a1;
  return result;
}

unsigned __int8 *swift::MetadataAllocator::Allocate(unint64_t a1, _WORD *a2, _WORD *a3, void *a4)
{
  *a2 = a1;
  a2[1] = *a3;
  v5 = a2 + 4;
  *a4 = a2 + 4;
  if (swift::runtime::environment::initializeToken != -1)
  {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, swift::runtime::environment::initialize);
  }

  if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_METADATA_BACKTRACE_LOGGING_variable == 1)
  {
    recordBacktrace(v5);
  }

  return checkScribble(v5, a1);
}

void getCache()
{
  {
    OUTLINED_FUNCTION_4();
    v2 = v1 | 0xFF51AFD7ED550000;
    if (v3)
    {
      v0 = v2;
    }

    OUTLINED_FUNCTION_3(v0);
  }
}

void swift::LockingConcurrentMap<anonymous namespace::TupleCacheEntry,anonymous namespace::TupleCacheStorage>::getOrInsert<anonymous namespace::TupleCacheEntry::Key,swift::MetadataRequest &,swift::TargetValueWitnessTable<swift::InProcess> const*&>()
{
  {
    OUTLINED_FUNCTION_4();
    v2 = v1 | 0xFF51AFD7ED550000;
    if (v3)
    {
      v0 = v2;
    }

    OUTLINED_FUNCTION_3(v0);
  }
}

void _swift_initClassMetadataImpl()
{
  OUTLINED_FUNCTION_0(&_swift_initClassMetadataImpl(swift::TargetClassMetadata<swift::InProcess,swift::TargetAnyClassMetadataObjCInterop<swift::InProcess>> *,swift::ClassLayoutFlags,unsigned long,swift::TargetTypeLayout<swift::InProcess> const* const*,unsigned long *,BOOL)::onceToken);
}

{
  dispatch_once_f(&qword_1ED426160, &supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy, supportsLazyObjcClassNames(void)::$_0::operator() const(void)::{lambda(void *)#1}::__invoke);
}

void swift::ResolveAsSymbolicReference::operator()(swift::SymbolInfo *a1, swift::SymbolInfo *this, uint64_t a3)
{
  swift::SymbolInfo::lookup(this, a1);
  if (*(a1 + 32) == 1)
  {
    if (swift::SymbolInfo::getFilename(a1))
    {
      Filename = swift::SymbolInfo::getFilename(a1);
    }

    else
    {
      Filename = "<unknown>";
    }

    if (swift::SymbolInfo::getSymbolName(a1))
    {
      SymbolName = swift::SymbolInfo::getSymbolName(a1);
    }

    else
    {
      SymbolName = "<unknown>";
    }
  }

  else
  {
    Filename = "<unknown>";
    SymbolName = "<unknown>";
  }

  swift::fatalError(0, "Failed to look up symbolic reference at %p - offset %d - symbol %s in %s - pointer at %#lx is likely a reference to a missing weak symbol\n", v6, v7, this, a3, SymbolName, Filename, this + a3);
}

void _findContextDescriptor(int a1, char *a2, uint64_t a3, std::string *a4)
{
  if ((a1 & 0xFFFFFFFE) != 0)
  {
    return;
  }

  v8 = v7;
  if (qword_1ED426338 == -1)
  {
    if (v7)
    {
LABEL_4:
      v9 = v8;
      goto LABEL_7;
    }
  }

  else
  {
    OUTLINED_FUNCTION_5_0();
    dispatch_once_f(&qword_1ED426338, _MergedGlobals_1, v10);
    if (v8)
    {
      goto LABEL_4;
    }
  }

  v9 = 0;
LABEL_7:
  if (_MergedGlobals_1[0] <= v9 && unk_1ED426330 > v9)
  {
    if (a3)
    {
      OUTLINED_FUNCTION_7();
      v13 = v12;
    }

    else
    {
      v13 = 0;
    }

    if (!swift::equalContexts(v13, v8))
    {
      swift::Demangle::__runtime::getNodeTreeAsString(a2, a4);
      OUTLINED_FUNCTION_9();
      swift::fatalError(0, "Searching for type descriptor, prespecialized descriptor map returned %p, but scan returned %p. Node tree:\n%s", v14, v15);
    }
  }
}

void swift::addImageDynamicReplacementBlockCallback(uint64_t a1)
{
  OUTLINED_FUNCTION_1_1(a1, &DynamicReplacementLock);
}

{
  v1 = OUTLINED_FUNCTION_8(a1, &opaqueTypeMappings);
  dispatch_once_f(v1, v2, v3);
}

void swift::Demangle::__runtime::TypeDecoder<anonymous namespace::DecodedMetadataBuilder>::decodeMangledProtocolType(int a1, char *a2, uint64_t a3, std::string *a4)
{
  if ((a1 & 0xFFFFFFFE) != 0)
  {
    return;
  }

  v8 = v7;
  if (qword_1ED426338 == -1)
  {
    if (v7)
    {
LABEL_4:
      v9 = v8;
      goto LABEL_7;
    }
  }

  else
  {
    OUTLINED_FUNCTION_5_0();
    dispatch_once_f(&qword_1ED426338, _MergedGlobals_1, v10);
    if (v8)
    {
      goto LABEL_4;
    }
  }

  v9 = 0;
LABEL_7:
  if (_MergedGlobals_1[0] <= v9 && unk_1ED426330 > v9)
  {
    if (a3)
    {
      OUTLINED_FUNCTION_7();
      v13 = v12;
    }

    else
    {
      v13 = 0;
    }

    if (!swift::equalContexts(v13, v8))
    {
      swift::Demangle::__runtime::getNodeTreeAsString(a2, a4);
      OUTLINED_FUNCTION_9();
      swift::fatalError(0, "Searching for type descriptor, prespecialized descriptor map returned %p, but scan returned %p. Node tree:\n%s", v14, v15);
    }
  }
}

void swift::_searchConformancesByMangledTypeName(uint64_t a1)
{
  v1 = OUTLINED_FUNCTION_3_1(a1, &swift::runtime::trace::tracingReady(void)::{lambda(void)#1}::operator() const(void)::TheLazy);
  dispatch_once_f(v1, v2, v3);
}

{
  v1 = OUTLINED_FUNCTION_1_2(a1, &Conformances);
  dispatch_once_f(v1, v2, v3);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return MEMORY[0x1EEE644C8](retstr, __val);
}

{
  return MEMORY[0x1EEE644D8](retstr, __val);
}

void operator delete(void *__p)
{
    ;
  }
}

void operator delete(void *__p, std::align_val_t a2)
{
    ;
  }
}

void operator delete()
{
    ;
  }
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
    ;
  }
}

void operator new()
{
    ;
  }
}

uint64_t _s10Foundation21_bridgeNSErrorToError_3outSbSo0C0C_SpyxGtAA021_ObjectiveCBridgeableE0RzlF_delayInitStub(double a1)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    dlopenHelper_Foundation(a1);
  }

  return MEMORY[0x1EEDC3BF8]();
}

uint64_t _s10Foundation24_getErrorDefaultUserInfoyyXlSgxs0C0RzlF_delayInitStub(double a1)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    dlopenHelper_Foundation(a1);
  }

  return MEMORY[0x1EEDC3E30]();
}

uint64_t CFStringHashCString_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreFoundation))
  {
    dlopenHelper_CoreFoundation(a1);
  }

  return MEMORY[0x1EEDB7AA0]();
}

uint64_t CFStringHashNSString_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreFoundation))
  {
    dlopenHelper_CoreFoundation(a1);
  }

  return MEMORY[0x1EEDB7AB8]();
}

uint64_t _CFStringCreateTaggedPointerString_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreFoundation))
  {
    dlopenHelper_CoreFoundation(a1);
  }

  return MEMORY[0x1EEDB85D0]();
}

uint64_t _NSIsNSString_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreFoundation))
  {
    dlopenHelper_CoreFoundation(a1);
  }

  return MEMORY[0x1EEDB8920]();
}

double gotLoadHelper_x16___s10Foundation26_ObjectiveCBridgeableErrorMp(double result)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    return dlopenHelper_Foundation(result);
  }

  return result;
}

void gotLoadHelper_x21___sSo10CFErrorRefas5Error10FoundationMc(double a1)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    dlopenHelper_Foundation(a1);
  }
}

void gotLoadHelper_x19___sSo10CFErrorRefas5Error10FoundationMc(double a1)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    dlopenHelper_Foundation(a1);
  }
}

void gotLoadHelper_x20___sSo10CFErrorRefas5Error10FoundationMc(double a1)
{
  if (!atomic_load(dlopenHelperFlag_Foundation))
  {
    dlopenHelper_Foundation(a1);
  }
}

void gotLoadHelper_x19___sSo8NSObjectCSH10ObjectiveCMc(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libswiftObjectiveC_dylib))
  {
    dlopenHelper_libswiftObjectiveC_dylib(a1);
  }
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_CoreFoundation(double a1)
{
  dlopen("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation", 0);
  atomic_store(1u, &dlopenHelperFlag_CoreFoundation);
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_Foundation(double a1)
{
  dlopen("/System/Library/Frameworks/Foundation.framework/Foundation", 0);
  atomic_store(1u, dlopenHelperFlag_Foundation);
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_libswiftObjectiveC_dylib(double a1)
{
  dlopen("/usr/lib/swift/libswiftObjectiveC.dylib", 0);
  atomic_store(1u, &dlopenHelperFlag_libswiftObjectiveC_dylib);
  return a1;
}